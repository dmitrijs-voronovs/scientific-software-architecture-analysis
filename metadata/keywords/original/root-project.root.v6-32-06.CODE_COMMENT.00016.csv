id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:205,Usability,usab,usable,205,"// Unpack argument packs, which we translate them into separate; // arguments.; // FIXME: We could do much better if we could guarantee that the; // TemplateArgumentLocInfo for the pack expansion would be usable for; // all of the template arguments in the argument pack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:47,Performance,perform,perform,47,"// The transform has determined that we should perform a simple; // transformation on the pack expansion, producing another pack; // expansion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:57,Usability,simpl,simple,57,"// The transform has determined that we should perform a simple; // transformation on the pack expansion, producing another pack; // expansion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:47,Performance,perform,perform,47,// The transform has determined that we should perform an elementwise; // expansion of the pattern. Do so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:7,Usability,simpl,simple,7,// The simple case:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:35,Deployability,update,updated,35,"// RebuildQualifiedType might have updated the type, but not in a way; // that invalidates the TypeLoc. (There's no location information for; // qualifiers.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:5,Integrability,depend,dependent,5,"// A dependent pointer type 'T *' has is being transformed such; // that an Objective-C class type is being replaced for 'T'. The; // resulting pointer type is an ObjCObjectPointerType, not a; // PointerType.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:179,Integrability,depend,dependent,179,"// We might have either a ConstantArrayType or a VariableArrayType now:; // a ConstantArrayType is allowed to have an element type which is a; // VariableArrayType if the type is dependent. Fortunately, all array; // types have the same location layout.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:49,Modifiability,Variab,VariableArrayType,49,"// We might have either a ConstantArrayType or a VariableArrayType now:; // a ConstantArrayType is allowed to have an element type which is a; // VariableArrayType if the type is dependent. Fortunately, all array; // types have the same location layout.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:146,Modifiability,Variab,VariableArrayType,146,"// We might have either a ConstantArrayType or a VariableArrayType now:; // a ConstantArrayType is allowed to have an element type which is a; // VariableArrayType if the type is dependent. Fortunately, all array; // types have the same location layout.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:19,Integrability,depend,dependent,19,// Result might be dependent or not.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:19,Integrability,depend,dependent,19,// Result might be dependent or not.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:19,Integrability,depend,dependent,19,// Result might be dependent or not.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:201,Availability,down,down,201,"// The next parameter should have the same adjustment as the; // last thing we pushed, but we post-incremented indexAdjustment; // on every push. Also, if we push nothing, the adjustment should; // go down by one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:10,Modifiability,extend,extended,10,// Handle extended parameter information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:3,Deployability,Update,Update,3,// Update this scrope because ContextDecl in Sema will be used in; // TransformExpr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:104,Integrability,depend,dependent,104,"// The nested-name-specifier never matters in a TemplateSpecializationType,; // because we can't have a dependent nested-name-specifier anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:4,Usability,Simpl,Simple,4,/// Simple iterator that traverses the template arguments in a; /// container that provides a \c getArgLoc() member function.; ///; /// This iterator is intended to be used with the iterator form of; /// \c TreeTransform<Derived>::TransformTemplateArguments().,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:157,Integrability,depend,dependent,157,"// Specializations of template template parameters are represented as; // TemplateSpecializationTypes, and substitution of type alias templates; // within a dependent context can transform them into; // DependentTemplateSpecializationTypes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:203,Integrability,Depend,DependentTemplateSpecializationTypes,203,"// Specializations of template template parameters are represented as; // TemplateSpecializationTypes, and substitution of type alias templates; // within a dependent context can transform them into; // DependentTemplateSpecializationTypes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:11,Integrability,Wrap,Wrap,11,/// FIXME: Wrap this in an elaborated-type-specifier?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:84,Usability,simpl,simple-template-id,84,"// C++0x [dcl.type.elab]p2:; // If the identifier resolves to a typedef-name or the simple-template-id; // resolves to an alias template specialization, the; // elaborated-type-specifier is ill-formed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:10,Integrability,depend,dependent,10,// FIXME: dependent operand expressions?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:31,Availability,avail,available,31,// The BTFTagAttributedType is available for C only.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:30,Integrability,depend,dependent,30,// ObjCInterfaceType is never dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:140,Usability,clear,clear,140,"// If we're transforming ""in-place"" (we're not creating new local; // declarations), assume we're replacing the old label statement; // and clear out the reference to it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:38,Modifiability,variab,variable,38,// In OpenMP loop region loop control variable must be captured and be; // private. Perform analysis of first part (if any).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:84,Performance,Perform,Perform,84,// In OpenMP loop region loop control variable must be captured and be; // private. Perform analysis of first part (if any).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:103,Integrability,depend,depend,103,"// We re-build the coroutine promise object (and the coroutine parameters its; // type and constructor depend on) based on the types used in our current; // function. We must do so, and set it on the current FunctionScopeInfo,; // before attempting to transform the other parts of the coroutine body; // statement, such as the implicit suspend statements (because those; // statements reference the FunctionScopeInfo::CoroutinePromise).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:65,Integrability,depend,dependent,65,"// Transform the implicit coroutine statements constructed using dependent; // types during the previous parse: initial and final suspensions, the return; // object, and others. We also transform the coroutine function's body.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:58,Integrability,depend,dependent,58,"// If during the previous parse the coroutine still had a dependent promise; // statement, we may need to build some implicit coroutine statements; // (such as exception and fallthrough handlers) for the first time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:87,Integrability,depend,dependent,87,"// We can only build these statements, however, if the current promise type; // is not dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:53,Integrability,inject,injected,53,// Always rebuild; we don't know if this needs to be injected into a new; // context or if the promise type has changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:53,Security,inject,injected,53,// Always rebuild; we don't know if this needs to be injected into a new; // context or if the promise type has changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:53,Integrability,inject,injected,53,// Always rebuild; we don't know if this needs to be injected into a new; // context or if the promise type has changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:53,Security,inject,injected,53,// Always rebuild; we don't know if this needs to be injected into a new; // context or if the promise type has changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:53,Integrability,inject,injected,53,// Always rebuild; we don't know if this needs to be injected into a new; // context or if the promise type has changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:53,Security,inject,injected,53,// Always rebuild; we don't know if this needs to be injected into a new; // context or if the promise type has changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:53,Integrability,inject,injected,53,// Always rebuild; we don't know if this needs to be injected into a new; // context or if the promise type has changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:53,Security,inject,injected,53,// Always rebuild; we don't know if this needs to be injected into a new; // context or if the promise type has changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:55,Modifiability,variab,variable,55,// Might not have attached any initializer to the loop variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:21,Integrability,depend,dependent,21,"// The name is still dependent, so build a dependent expression again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:43,Integrability,depend,dependent,43,"// The name is still dependent, so build a dependent expression again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:47,Integrability,depend,dependent,47,"// No need to rebuild this clause, no template-dependent parameters.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:47,Integrability,depend,dependent,47,"// No need to rebuild this clause, no template-dependent parameters.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:47,Integrability,depend,dependent,47,"// No need to rebuild this clause, no template-dependent parameters.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:47,Integrability,depend,dependent,47,"// No need to rebuild this clause, no template-dependent parameters.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:47,Integrability,depend,dependent,47,"// No need to rebuild this clause, no template-dependent parameters.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:47,Integrability,depend,dependent,47,"// No need to rebuild this clause, no template-dependent parameters.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:47,Integrability,depend,dependent,47,"// No need to rebuild this clause, no template-dependent parameters.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:47,Integrability,depend,dependent,47,"// No need to rebuild this clause, no template-dependent parameters.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:47,Integrability,depend,dependent,47,"// No need to rebuild this clause, no template-dependent parameters.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:47,Integrability,depend,dependent,47,"// No need to rebuild this clause, no template-dependent parameters.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:47,Integrability,depend,dependent,47,"// No need to rebuild this clause, no template-dependent parameters.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:47,Integrability,depend,dependent,47,"// No need to rebuild this clause, no template-dependent parameters.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:47,Integrability,depend,dependent,47,"// No need to rebuild this clause, no template-dependent parameters.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:47,Integrability,depend,dependent,47,"// No need to rebuild this clause, no template-dependent parameters.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:47,Integrability,depend,dependent,47,"// No need to rebuild this clause, no template-dependent parameters.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:47,Integrability,depend,dependent,47,"// No need to rebuild this clause, no template-dependent parameters.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:47,Integrability,depend,dependent,47,"// No need to rebuild this clause, no template-dependent parameters.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:124,Integrability,depend,dependent,124,"// Build a list of all candidate OMPDeclareMapperDecls, which is provided by; // the previous user-defined mapper lookup in dependent environment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:89,Modifiability,variab,variable-category,89,// Rebuild Defaultmap Clause since we need to invoke the checking of; // defaultmap(none:variable-category) after template initialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:165,Availability,avail,available,165,/// The operand of a unary address-of operator has special rules: it's; /// allowed to refer to a non-static member of a class even if there's no 'this'; /// object available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:125,Energy Efficiency,efficient,efficient,125,"// Transform all of the components into components similar to what the; // parser uses.; // FIXME: It would be slightly more efficient in the non-dependent case to; // just map FieldDecls, rather than requiring the rebuilder to look for; // the fields again. However, __builtin_offsetof is rare enough in; // template code that we don't care.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:146,Integrability,depend,dependent,146,"// Transform all of the components into components similar to what the; // parser uses.; // FIXME: It would be slightly more efficient in the non-dependent case to; // just map FieldDecls, rather than requiring the rebuilder to look for; // the fields again. However, __builtin_offsetof is rare enough in; // template code that we don't care.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:10,Availability,recover,recover,10,"// Try to recover if we have something like sizeof(T::X) where X is a type.; // Notably, there must be *exactly* one set of parens if X is a type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:10,Safety,recover,recover,10,"// Try to recover if we have something like sizeof(T::X) where X is a type.; // Notably, there must be *exactly* one set of parens if X is a type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:123,Integrability,depend,dependent,123,"// FIXME: to do this check properly, we will need to preserve the; // first-qualifier-in-scope here, just in case we had a dependent; // base (and therefore couldn't do the check) and a; // nested-name-qualifier (and therefore could do the lookup).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:34,Modifiability,rewrite,rewrite,34,"// Mark all functions used in the rewrite as referenced. Note that when; // a < b is rewritten to (a <=> b) < 0, both the <=> and the < might be; // function calls, and/or there might be a user-defined conversion sequence; // applied to the operands of the <.; // FIXME: this is a bit instantiation-specific.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:20,Availability,error,error,20,"// Calling this an 'error' is unintuitive, but it does the right thing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:18,Modifiability,config,config,18,// Transform exec config.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:61,Modifiability,polymorphi,polymorphic,61,"// Typeid's operand is an unevaluated context, unless it's a polymorphic; // type. We must not unilaterally enter unevaluated context here, as then; // semantic processing can re-transform an already transformed operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:42,Integrability,depend,depends,42,"// In lambdas, the qualifiers of the type depends of where in; // the call operator `this` appear, and we do not have a good way to; // rebuild this information, so we transform the type.; //; // In other contexts, the type of `this` may be overrided; // for type deduction, so we need to recompute it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:257,Integrability,depend,dependently-sized,257,"// If no array size was specified, but the new expression was; // instantiated with an array type (e.g., ""new T"" where T is; // instantiated with ""int[4]""), extract the outer bound from the; // array type as our array size. We do this with constant and; // dependently-sized array types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:57,Availability,down,down,57,"// We aren't likely to be able to resolve the identifier down to a type; // now anyway, so just retain the identifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:102,Integrability,depend,dependent,102,// Silently ignore these if a UsingShadowDecl instantiated to nothing.; // This can happen because of dependent hiding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:47,Performance,perform,perform,47,"// The transform has determined that we should perform a simple; // transformation on the pack expansion, producing another pack; // expansion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:57,Usability,simpl,simple,57,"// The transform has determined that we should perform a simple; // transformation on the pack expansion, producing another pack; // expansion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:6,Availability,failure,failure,6,"// On failure to transform, TransformRequiresTypeParams returns an expression; // in the event that the transformation of the type params failed in some way.; // It is expected that this will result in a 'not satisfied' Requires clause; // when instantiating.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:18,Availability,error,errors,18,"// Propagate both errors and recovered types, which return ExprEmpty.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:29,Availability,recover,recovered,29,"// Propagate both errors and recovered types, which return ExprEmpty.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:29,Safety,recover,recovered,29,"// Propagate both errors and recovered types, which return ExprEmpty.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:19,Integrability,wrap,wrap,19,"// We got an expr, wrap it up in parens.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:68,Integrability,Depend,DependencyKind,68,"// Create the local class that will describe the lambda.; // FIXME: DependencyKind below is wrong when substituting inside a templated; // context that isn't a DeclContext (such as a variable template), or when; // substituting an unevaluated lambda inside of a function's parameter's type; // - as parameter types are not instantiated from within a function's DC. We; // use evaluation contexts to distinguish the function parameter case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:183,Modifiability,variab,variable,183,"// Create the local class that will describe the lambda.; // FIXME: DependencyKind below is wrong when substituting inside a templated; // context that isn't a DeclContext (such as a variable template), or when; // substituting an unevaluated lambda inside of a function's parameter's type; // - as parameter types are not instantiated from within a function's DC. We; // use evaluation contexts to distinguish the function parameter case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:58,Modifiability,variab,variables,58,// Captured expression will be recaptured during captured variables; // rebuilding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:47,Performance,perform,perform,47,// The transform has determined that we should perform an expansion;; // transform and capture each of the arguments.; // expansion of the pattern. Do so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:27,Modifiability,variab,variable,27,// Capture the transformed variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:26,Modifiability,variab,variable,26,// Transform the captured variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:27,Modifiability,variab,variable,27,// Capture the transformed variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:58,Modifiability,variab,variables,58,// Captured expression will be recaptured during captured variables; // rebuilding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:26,Modifiability,variab,variable,26,// Transform the captured variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:27,Modifiability,variab,variable,27,// Capture the transformed variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:95,Performance,Optimiz,Optimize,95,// This is a reference to a member without an explicitly-specified; // template argument list. Optimize for this common case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:123,Integrability,depend,dependent,123,"// FIXME: to do this check properly, we will need to preserve the; // first-qualifier-in-scope here, just in case we had a dependent; // base (and therefore couldn't do the check) and a; // nested-name-qualifier (and therefore could do the lookup).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:21,Integrability,depend,dependent,21,"// If E is not value-dependent, then nothing will change when we transform it.; // Note: This is an instantiation-centric view.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:37,Performance,perform,performing,37,// Try to compute the result without performing a partial substitution.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:101,Safety,avoid,avoid,101,// Formally a fold expression expands to nested parenthesized expressions.; // Enforce this limit to avoid creating trees so deep we can't safely traverse; // them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:139,Safety,safe,safely,139,// Formally a fold expression expands to nested parenthesized expressions.; // Enforce this limit to avoid creating trees so deep we can't safely traverse; // them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:47,Performance,perform,perform,47,// The transform has determined that we should perform an elementwise; // expansion of the pattern. Do so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:13,Availability,down,down,13,// We've got down to a single element; build a binary operator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:115,Availability,error,error,115,"// If we had no init and an empty pack, and we're not retaining an expansion,; // then produce a fallback value or error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:47,Performance,perform,perform,47,"// The transform has determined that we should perform a simple; // transformation on the pack expansion, producing another pack; // expansion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:57,Usability,simpl,simple,57,"// The transform has determined that we should perform a simple; // transformation on the pack expansion, producing another pack; // expansion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:47,Performance,perform,perform,47,// The transform has determined that we should perform an elementwise; // expansion of the pattern. Do so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:9,Integrability,message,message,9,// Class message: transform the receiver type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:48,Integrability,message,message,48,"// If nothing changed, just retain the existing message send.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:21,Integrability,message,message,21,// Build a new class message send.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:21,Integrability,message,message,21,// Build a new class message send to 'super'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:12,Integrability,message,message,12,// Instance message: transform the receiver,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:48,Integrability,message,message,48,"// If nothing changed, just retain the existing message send.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:24,Integrability,message,message,24,// Build a new instance message send.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:18,Testability,assert,assertions,18,"// In builds with assertions, make sure that we captured everything we; // captured before.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:97,Integrability,depend,dependent,97,// Note that we can return a VariableArrayType here in the case where; // the element type was a dependent VariableArrayType.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:29,Modifiability,Variab,VariableArrayType,29,// Note that we can return a VariableArrayType here in the case where; // the element type was a dependent VariableArrayType.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:107,Modifiability,Variab,VariableArrayType,107,// Note that we can return a VariableArrayType here in the case where; // the element type was a dependent VariableArrayType.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:44,Availability,Recover,RecoveryExpr,44,// It is possible that the type refers to a RecoveryExpr created earlier; // in the tree transformation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:44,Safety,Recover,RecoveryExpr,44,// It is possible that the type refers to a RecoveryExpr created earlier; // in the tree transformation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:40,Integrability,depend,dependent,40,// Add any functions found via argument-dependent lookup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TypeLocBuilder.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate the new buffer and copy the old data into it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TypeLocBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TypeLocBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TypeLocBuilder.h:87,Safety,safe,safe,87,/// Tell the TypeLocBuilder that the type it is storing has been; /// modified in some safe way that doesn't affect type-location information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TypeLocBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TypeLocBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTCommon.cpp:99,Deployability,patch,patched,99,"// FIXME: These are defined in one place, but properties in class extensions; // end up being back-patched into the main interface. See; // Sema::HandlePropertyInClassExtension for the offending code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTCommon.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTCommon.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTCommon.cpp:121,Integrability,interface,interface,121,"// FIXME: These are defined in one place, but properties in class extensions; // end up being back-patched into the main interface. See; // Sema::HandlePropertyInClassExtension for the offending code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTCommon.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTCommon.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTCommon.cpp:280,Availability,avail,available,280,"// Friend declarations in dependent contexts aren't anonymous in the usual; // sense, but they cannot be found by name lookup in their semantic context; // (or indeed in any context), so we treat them as anonymous.; //; // This doesn't apply to friend tag decls; Sema makes those available to name; // lookup in the surrounding context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTCommon.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTCommon.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTCommon.cpp:26,Integrability,depend,dependent,26,"// Friend declarations in dependent contexts aren't anonymous in the usual; // sense, but they cannot be found by name lookup in their semantic context; // (or indeed in any context), so we treat them as anonymous.; //; // This doesn't apply to friend tag decls; Sema makes those available to name; // lookup in the surrounding context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTCommon.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTCommon.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTCommon.cpp:140,Modifiability,variab,variables,140,"// Otherwise, we only care about anonymous class members / block-scope decls.; // FIXME: We need to handle blocks within inline / templated variables too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTCommon.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTCommon.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTCommon.h:391,Integrability,protocol,protocols,391,"/// Retrieve the ""definitive"" declaration that provides all of the; /// visible entries for the given declaration context, if there is one.; ///; /// The ""definitive"" declaration is the only place where we need to look to; /// find information about the declarations within the given declaration; /// context. For example, C++ and Objective-C classes, C structs/unions, and; /// Objective-C protocols, categories, and extensions are all defined in a; /// single place in the source code, so they have definitive declarations; /// associated with them. C++ namespaces, on the other hand, can have; /// multiple definitions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTCommon.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTCommon.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:89,Security,validat,validator,89,//===----------------------------------------------------------------------===//; // PCH validator implementation; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:3,Security,Sanitiz,Sanitizer,3,"// Sanitizer feature mismatches are treated as compatible differences. If; // compatible differences aren't allowed, we still only want to check for; // mismatches of non-modular sanitizers (the only ones which can affect AST; // generation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:179,Security,sanitiz,sanitizers,179,"// Sanitizer feature mismatches are treated as compatible differences. If; // compatible differences aren't allowed, we still only want to check for; // mismatches of non-modular sanitizers (the only ones which can affect AST; // generation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:10,Availability,toler,tolerate,10,"// We can tolerate different CPUs in many cases, notably when one CPU; // supports a strict superset of another. When allowing compatible; // differences skip this check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:130,Availability,error,errors,130,"// Check current mappings for new -Werror mappings, and the stored mappings; // for cases that were explicitly mapped to *not* be errors that are now; // errors because of options like -Werror.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:154,Availability,error,errors,154,"// Check current mappings for new -Werror mappings, and the stored mappings; // for cases that were explicitly mapped to *not* be errors that are now; // errors because of options like -Werror.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:229,Performance,load,loaded,229,"// If the original import came from a file explicitly generated by the user,; // don't check the diagnostic mappings.; // FIXME: currently this is approximated by checking whether this is not a; // module import of an implicitly-loaded module file.; // Note: ModuleMgr.rbegin() may not be the current module, but it must be in; // the transitive closure of its imports, since unrelated modules cannot be; // imported until after this module finishes validation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:450,Security,validat,validation,450,"// If the original import came from a file explicitly generated by the user,; // don't check the diagnostic mappings.; // FIXME: currently this is approximated by checking whether this is not a; // module import of an implicitly-loaded module file.; // Note: ModuleMgr.rbegin() may not be the current module, but it must be in; // the transitive closure of its imports, since unrelated modules cannot be; // imported until after this module finishes validation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:470,Availability,toler,tolerate,470,"/// Check the preprocessor options deserialized from the control block; /// against the preprocessor options in an existing preprocessor.; ///; /// \param Diags If non-null, produce diagnostics for any mismatches incurred.; /// \param Validation If set to OptionValidateNone, ignore differences in; /// preprocessor options. If set to OptionValidateContradictions,; /// require that options passed both in the AST file and on the command; /// line (-D or -U) match, but tolerate options missing in one or the; /// other. If set to OptionValidateContradictions, require that there; /// are no differences in the options between the two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:235,Security,Validat,Validation,235,"/// Check the preprocessor options deserialized from the control block; /// against the preprocessor options in an existing preprocessor.; ///; /// \param Diags If non-null, produce diagnostics for any mismatches incurred.; /// \param Validation If set to OptionValidateNone, ignore differences in; /// preprocessor options. If set to OptionValidateContradictions,; /// require that options passed both in the AST file and on the command; /// line (-D or -U) match, but tolerate options missing in one or the; /// other. If set to OptionValidateContradictions, require that there; /// are no differences in the options between the two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:42,Availability,toler,tolerate,42,"// If strict matches are requested, don't tolerate any extra defines; // on the command line that are missing in the AST file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:42,Availability,toler,tolerate,42,"// If strict matches are requested, don't tolerate any extra defines in; // the AST file that are missing on the command line.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:64,Performance,cache,cache,64,// Detailed record is important since it is used for the module cache hash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:70,Security,hash,hash,70,// Detailed record is important since it is used for the module cache hash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:3,Performance,Load,Load,3,// Load instance methods,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:3,Performance,Load,Load,3,// Load factory methods,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:109,Performance,load,loading,109,"// For uninteresting identifiers, there's nothing else to do. Just notify; // the reader that we've finished loading this identifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:90,Deployability,update,updates,90,"// If we are handling a C++ class template instantiation, we can see multiple; // lexical updates for the same record. It's important that we select only one; // of them, so that field numbering works properly. Just pick the first one we; // see.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:12,Safety,safe,safely,12,"// We can't safely determine the primary context yet, so delay attaching the; // lookup table until we're done with recursive deserialization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:53,Availability,Failure,Failure,53,"// We will detect whether a file changed and return 'Failure' for it, but; // we will also try to fail gracefully by setting up the SLocEntry.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:11,Safety,detect,detect,11,"// We will detect whether a file changed and return 'Failure' for it, but; // we will also try to fail gracefully by setting up the SLocEntry.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:138,Availability,recover,recover,138,// Note that we only check if a File was returned. If it was out-of-date; // we have complained but we will continue creating a FileID to recover; // gracefully.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:138,Safety,recover,recover,138,// Note that we only check if a File was returned. If it was out-of-date; // we have complained but we will continue creating a FileID to recover; // gracefully.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:26,Availability,down,down,26,// FIXME: Can we map this down to a particular submodule? That would be; // ideal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:20,Availability,error,errors,20,// FIXME this drops errors on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:3,Deployability,Install,Install,3,// Install function-like macro info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:10,Modifiability,Refactor,Refactor,10,// FIXME: Refactor with mergeHeaderFileInfo in HeaderSearch.cpp.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:38,Performance,load,loaded,38,// This HeaderFileInfo was externally loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:20,Performance,load,loading,20,// Note that we are loading defined macros.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:20,Performance,load,loading,20,// Note that we are loading an identifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:3,Deployability,Update,Update,3,// Update the generation for this identifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:39,Integrability,depend,dependency,39,// Module macros are listed in reverse dependency order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:15,Performance,load,loaded,15,// If a PCH is loaded and validation is disabled for PCH then disable; // validation for the PCH and the modules it loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:116,Performance,load,loads,116,// If a PCH is loaded and validation is disabled for PCH then disable; // validation for the PCH and the modules it loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:26,Security,validat,validation,26,// If a PCH is loaded and validation is disabled for PCH then disable; // validation for the PCH and the modules it loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:74,Security,validat,validation,74,// If a PCH is loaded and validation is disabled for PCH then disable; // validation for the PCH and the modules it loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:20,Performance,load,loaded,20,"// If we've already loaded this input file, return it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:20,Availability,error,errors,20,// FIXME this drops errors on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:20,Availability,error,errors,20,// FIXME this drops errors on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:20,Availability,error,errors,20,// FIXME this drops errors on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:20,Availability,error,errors,20,// FIXME this drops errors on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:20,Availability,error,errors,20,// FIXME this drops errors on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:19,Performance,load,loaded,19,// Note that we've loaded this input file info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:20,Performance,load,loaded,20,"// If we've already loaded this input file, return it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:20,Availability,error,errors,20,// FIXME this drops errors on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:64,Availability,recover,recover,64,"// After emitting the diagnostic, bypass the overriding file to recover; // (this creates a separate FileEntry).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:64,Safety,recover,recover,64,"// After emitting the diagnostic, bypass the overriding file to recover; // (this creates a separate FileEntry).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:77,Performance,cache,cached,77,"// In case the modification time changes but not the content,; // accept the cached file as legit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:45,Security,Validat,ValidateASTInputFilesContent,45,"// When ForceCheckCXX20ModulesInputFiles and ValidateASTInputFilesContent; // enabled, it is better to check the contents of the inputs. Since we can't; // get correct modified time information for inputs from overriden inputs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:47,Security,validat,validate,47,"// For an overridden file, there is nothing to validate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:78,Availability,error,error,78,"// FIXME: If the file is overridden and we've already opened it,; // issue an error (or split it into a separate FileEntry).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:19,Performance,load,loaded,19,// Note that we've loaded this input file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:14,Performance,load,loading,14,"/// If we are loading a relocatable PCH or module file, and the filename; /// is not an absolute path, add the system or module root to the beginning of; /// the file name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:20,Availability,error,errors,20,// FIXME this drops errors on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:20,Availability,error,errors,20,// FIXME this drops errors on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:20,Availability,error,errors,20,// FIXME this drops errors on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:3,Security,Validat,Validate,3,// Validate the module before returning. This call catches an AST with; // no module name and no imports.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:3,Security,Validat,Validate,3,// Validate input files.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:154,Performance,load,loaded,154,"// All user input files reside at the index range [0, NumUserInputs), and; // system input files reside at [NumUserInputs, NumInputs). For explicitly; // loaded module files, ignore missing inputs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:23,Deployability,configurat,configuration,23,// Should we allow the configuration of the module file to differ from; // the configuration of the current translation unit in a compatible; // way?; //; // FIXME: Allow this for files explicitly specified with -include-pch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:79,Deployability,configurat,configuration,79,// Should we allow the configuration of the module file to differ from; // the configuration of the current translation unit in a compatible; // way?; //; // FIXME: Allow this for files explicitly specified with -include-pch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:23,Modifiability,config,configuration,23,// Should we allow the configuration of the module file to differ from; // the configuration of the current translation unit in a compatible; // way?; //; // FIXME: Allow this for files explicitly specified with -include-pch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:79,Modifiability,config,configuration,79,// Should we allow the configuration of the module file to differ from; // the configuration of the current translation unit in a compatible; // way?; //; // FIXME: Allow this for files explicitly specified with -include-pch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:15,Performance,load,load,15,"// If we can't load the module, exit early since we likely; // will rebuild the module anyway. The stream may be in the; // middle of a block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:103,Availability,error,error,103,"// If requested by the caller and the module hasn't already been read; // or compiled, mark modules on error as out-of-date.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:89,Availability,error,error-prone,89,"// Validate the AST before processing any imports (otherwise, untangling; // them can be error-prone and expensive). A module will have a name and; // will already have been validated, but this catches the PCH case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:3,Security,Validat,Validate,3,"// Validate the AST before processing any imports (otherwise, untangling; // them can be error-prone and expensive). A module will have a name and; // will already have been validated, but this catches the PCH case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:174,Security,validat,validated,174,"// Validate the AST before processing any imports (otherwise, untangling; // them can be error-prone and expensive). A module will have a name and; // will already have been validated, but this catches the PCH case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:3,Performance,Load,Load,3,// Load each of the imported PCH files.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:16,Security,hash,hash,16,// FIXME: Add a hash comparison to check if ImportedFile's hash and the; // new Modules Path's hash matches or not.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:59,Security,hash,hash,59,// FIXME: Add a hash comparison to check if ImportedFile's hash and the; // new Modules Path's hash matches or not.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:95,Security,hash,hash,95,// FIXME: Add a hash comparison to check if ImportedFile's hash and the; // new Modules Path's hash matches or not.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:82,Integrability,depend,dependency,82,"// If our client can't cope with us being out of date, we can't cope with; // our dependency being missing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:3,Performance,Load,Load,3,// Load the AST file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:28,Integrability,depend,dependency,28,"// If we have to ignore the dependency, we'll have to ignore this too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:74,Availability,failure,failure,74,// Validate the AST as soon as we have a name so we can exit early on; // failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:3,Security,Validat,Validate,3,// Validate the AST as soon as we have a name so we can exit early on; // failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:20,Performance,load,loaded,20,"// If we've already loaded a module map file covering this module, we may; // have a better path for it (relative to the current build).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:137,Availability,error,error,137,"// If we're implicitly loading a module, the base directory can't; // change between the build and use.; // Don't emit module relocation error if we have -fno-validate-pch",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:23,Performance,load,loading,23,"// If we're implicitly loading a module, the base directory can't; // change between the build and use.; // Don't emit module relocation error if we have -fno-validate-pch",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:159,Security,validat,validate-pch,159,"// If we're implicitly loading a module, the base directory can't; // change between the build and use.; // Don't emit module relocation error if we have -fno-validate-pch",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:13,Performance,load,load,13,"// We lazily load the decls block, but we want to set up the; // DeclsCursor cursor to point into it. Clone our current bitcode; // cursor to it, enter the block and read the abbrevs in that block.; // With the main cursor, we just skip over it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:16,Performance,load,loading,16,"// If we're not loading an AST context, we don't care about most records.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:49,Deployability,update,updates,49,"// If we've already loaded the decl, perform the updates when we finish; // loading this block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:20,Performance,load,loaded,20,"// If we've already loaded the decl, perform the updates when we finish; // loading this block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:37,Performance,perform,perform,37,"// If we've already loaded the decl, perform the updates when we finish; // loading this block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:76,Performance,load,loading,76,"// If we've already loaded the decl, perform the updates when we finish; // loading this block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:101,Usability,clear,clearly,101,// Later tables overwrite earlier ones.; // FIXME: Modules will have some trouble with this. This is clearly not; // the right way to do this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:49,Deployability,update,updates,49,"// If we've already loaded the decl, perform the updates when we finish; // loading this block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:20,Performance,load,loaded,20,"// If we've already loaded the decl, perform the updates when we finish; // loading this block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:37,Performance,perform,perform,37,"// If we've already loaded the decl, perform the updates when we finish; // loading this block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:76,Performance,load,loading,76,"// If we've already loaded the decl, perform the updates when we finish; // loading this block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:16,Performance,load,loading,16,"// If we aren't loading a module (which has its own exports), make; // all of the imported modules visible.; // FIXME: Deal with macros-only imports.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:3,Deployability,Continuous,Continuous,3,// Continuous range maps we may be updating in our module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:21,Integrability,depend,dependency,21,"// FIXME: Looking up dependency modules by filename is horrible. Let's; // start fixing this with prebuilt, explicit and implicit modules and see; // how it goes...",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:225,Usability,usab,usable,225,"// Try to resolve ModuleName in the current header search context and; // verify that it is found in the same module map file as we saved. If the; // top-level AST file is a main file, skip this check because there is no; // usable header search context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:17,Performance,load,loaded,17,// An implicitly-loaded module file should have its module listed in some; // module map file that we've already loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:113,Performance,load,loaded,113,// An implicitly-loaded module file should have its module listed in some; // module map file that we've already loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:32,Availability,error,error,32,// Don't emit module relocation error if we have -fno-validate-pch,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:54,Security,validat,validate-pch,54,// Don't emit module relocation error if we have -fno-validate-pch,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:3,Deployability,Update,Update,3,// Update the module's name visibility.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:10,Performance,load,load,10,// Try to load the global index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:20,Availability,error,errors,20,// FIXME this drops errors on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:28,Availability,error,error,28,// Avoid triggering a fatal error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:3,Safety,Avoid,Avoid,3,// Avoid triggering a fatal error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:166,Availability,failure,failure,166,"/// Given a cursor at the start of an AST file, scan ahead and drop the; /// cursor into the start of the given block ID, returning false on success and; /// true on failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:20,Availability,error,errors,20,// FIXME this drops errors on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:20,Availability,error,errors,20,// FIXME this drops errors on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:521,Availability,error,errors,521,"// Here comes stuff that we only do once the entire chain is loaded. Do *not*; // remove modules from this point. Various fields are updated during reading; // the AST block and removing the modules would result in dangling pointers.; // They are generally only incidentally dereferenced, ie. a binary search; // runs over `GlobalSLocEntryMap`, which could cause an invalid module to; // be dereferenced but it wouldn't actually be used.; // Load the AST blocks of all of the modules that we loaded. We can still; // hit errors parsing the ASTs at this point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:133,Deployability,update,updated,133,"// Here comes stuff that we only do once the entire chain is loaded. Do *not*; // remove modules from this point. Various fields are updated during reading; // the AST block and removing the modules would result in dangling pointers.; // They are generally only incidentally dereferenced, ie. a binary search; // runs over `GlobalSLocEntryMap`, which could cause an invalid module to; // be dereferenced but it wouldn't actually be used.; // Load the AST blocks of all of the modules that we loaded. We can still; // hit errors parsing the ASTs at this point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:61,Performance,load,loaded,61,"// Here comes stuff that we only do once the entire chain is loaded. Do *not*; // remove modules from this point. Various fields are updated during reading; // the AST block and removing the modules would result in dangling pointers.; // They are generally only incidentally dereferenced, ie. a binary search; // runs over `GlobalSLocEntryMap`, which could cause an invalid module to; // be dereferenced but it wouldn't actually be used.; // Load the AST blocks of all of the modules that we loaded. We can still; // hit errors parsing the ASTs at this point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:442,Performance,Load,Load,442,"// Here comes stuff that we only do once the entire chain is loaded. Do *not*; // remove modules from this point. Various fields are updated during reading; // the AST block and removing the modules would result in dangling pointers.; // They are generally only incidentally dereferenced, ie. a binary search; // runs over `GlobalSLocEntryMap`, which could cause an invalid module to; // be dereferenced but it wouldn't actually be used.; // Load the AST blocks of all of the modules that we loaded. We can still; // hit errors parsing the ASTs at this point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:492,Performance,load,loaded,492,"// Here comes stuff that we only do once the entire chain is loaded. Do *not*; // remove modules from this point. Various fields are updated during reading; // the AST block and removing the modules would result in dangling pointers.; // They are generally only incidentally dereferenced, ie. a binary search; // runs over `GlobalSLocEntryMap`, which could cause an invalid module to; // be dereferenced but it wouldn't actually be used.; // Load the AST blocks of all of the modules that we loaded. We can still; // hit errors parsing the ASTs at this point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:53,Deployability,update,update,53,"// Once read, set the ModuleFile bit base offset and update the size in; // bits of all files we've seen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:165,Deployability,update,updateOutOfDateIdentifier,165,"// Identifiers present in both the module file and the importing; // instance are marked out-of-date so that they can be deserialized; // on next use via ASTReader::updateOutOfDateIdentifier().; // Identifiers present in the module file but not in the importing; // instance are ignored for now, preventing growth of the identifier; // table. They will be deserialized on first use via ASTReader::get().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:320,Deployability,update,updateOutOfDateIdentifier,320,"// With C++ modules, not many identifiers are considered interesting.; // All identifiers in the module file can be placed into the identifier; // table of the importing instance and marked as out-of-date. This makes; // ASTReader::get() a no-op, and deserialization will take place on; // first/next use via ASTReader::updateOutOfDateIdentifier().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:20,Performance,load,load,20,// FIXME: How do we load the 'use'd modules? They may not be submodules.; // Might be unnecessary as use declarations are only used to build the; // module itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:57,Performance,load,loaded,57,"// For any Objective-C class definitions we have already loaded, make sure; // that we load any additional categories.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:87,Performance,load,load,87,"// For any Objective-C class definitions we have already loaded, make sure; // that we load any additional categories.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:57,Integrability,depend,depends,57,"// Now we are certain that the module and all modules it depends on are; // up-to-date. For implicitly-built module files, ensure the corresponding; // timestamp files are up-to-date in this build session.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:122,Availability,error,error,122,"// FIXME checking magic headers is done in other places such as; // SerializedDiagnosticReader and GlobalModuleIndex, but error handling isn't; // always done the same. Unify it all with a helper.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:3,Performance,Load,Load,3,// Load module file below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:24,Availability,error,error,24,"// Otherwise, return an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:15,Performance,load,load,15,"// We couldn't load the module file because it is out-of-date. If the; // client can handle out-of-date, return it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:24,Availability,error,error,24,"// Otherwise, return an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:31,Performance,load,load,31,"// Check that we didn't try to load a non-module AST file as a module.; //; // FIXME: Should we also perform the converse check? Loading a module as; // a PCH file sort of works, but it's a bit wonky.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:101,Performance,perform,perform,101,"// Check that we didn't try to load a non-module AST file as a module.; //; // FIXME: Should we also perform the converse check? Loading a module as; // a PCH file sort of works, but it's a bit wonky.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:129,Performance,Load,Loading,129,"// Check that we didn't try to load a non-module AST file as a module.; //; // FIXME: Should we also perform the converse check? Loading a module as; // a PCH file sort of works, but it's a bit wonky.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:21,Performance,load,loaded,21,// Record that we've loaded this module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:65,Security,validat,validated,65,"// If F was directly imported by another module, it's implicitly validated by; // the importing module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:102,Performance,load,load,102,"// If this module has already been finalized in the ModuleCache, we're stuck; // with it; we can only load a single version of each module.; //; // This can happen when a module is imported in two contexts: in one, as a; // user module; in another, as a system module (due to an import from; // another module marked with the [system] flag). It usually indicates a; // bug in the module map: this module should also be marked with [system].; //; // If -Wno-system-headers (the default), and the first import is as a; // system module, then validation will fail during the as-user import,; // since -Werror flags won't have been validated. However, it's reasonable; // to treat this consistently as a system module.; //; // If -Wsystem-headers, the PCM on disk was built with; // -Wno-system-headers, and the first import is as a user module, then; // validation will fail during the as-system import since the PCM on disk; // doesn't guarantee that -Werror was respected. However, the -Werror; // flags were checked during the initial as-user import.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:540,Security,validat,validation,540,"// If this module has already been finalized in the ModuleCache, we're stuck; // with it; we can only load a single version of each module.; //; // This can happen when a module is imported in two contexts: in one, as a; // user module; in another, as a system module (due to an import from; // another module marked with the [system] flag). It usually indicates a; // bug in the module map: this module should also be marked with [system].; //; // If -Wno-system-headers (the default), and the first import is as a; // system module, then validation will fail during the as-user import,; // since -Werror flags won't have been validated. However, it's reasonable; // to treat this consistently as a system module.; //; // If -Wsystem-headers, the PCM on disk was built with; // -Wno-system-headers, and the first import is as a user module, then; // validation will fail during the as-system import since the PCM on disk; // doesn't guarantee that -Werror was respected. However, the -Werror; // flags were checked during the initial as-user import.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:628,Security,validat,validated,628,"// If this module has already been finalized in the ModuleCache, we're stuck; // with it; we can only load a single version of each module.; //; // This can happen when a module is imported in two contexts: in one, as a; // user module; in another, as a system module (due to an import from; // another module marked with the [system] flag). It usually indicates a; // bug in the module map: this module should also be marked with [system].; //; // If -Wno-system-headers (the default), and the first import is as a; // system module, then validation will fail during the as-user import,; // since -Werror flags won't have been validated. However, it's reasonable; // to treat this consistently as a system module.; //; // If -Wsystem-headers, the PCM on disk was built with; // -Wno-system-headers, and the first import is as a user module, then; // validation will fail during the as-system import since the PCM on disk; // doesn't guarantee that -Werror was respected. However, the -Werror; // flags were checked during the initial as-user import.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:851,Security,validat,validation,851,"// If this module has already been finalized in the ModuleCache, we're stuck; // with it; we can only load a single version of each module.; //; // This can happen when a module is imported in two contexts: in one, as a; // user module; in another, as a system module (due to an import from; // another module marked with the [system] flag). It usually indicates a; // bug in the module map: this module should also be marked with [system].; //; // If -Wno-system-headers (the default), and the first import is as a; // system module, then validation will fail during the as-user import,; // since -Werror flags won't have been validated. However, it's reasonable; // to treat this consistently as a system module.; //; // If -Wsystem-headers, the PCM on disk was built with; // -Wno-system-headers, and the first import is as a user module, then; // validation will fail during the as-system import since the PCM on disk; // doesn't guarantee that -Werror was respected. However, the -Werror; // flags were checked during the initial as-user import.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:24,Availability,error,error,24,// FIXME this drops the error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:129,Performance,Load,Load,129,"// FIXME: Find a better way to deal with collisions between these; // built-in types. Right now, we just ignore the problem.; // Load the special types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:8,Deployability,update,updates,8,"// This updates visibility for Preprocessor only. For Sema, which can be; // nullptr here, we do the same later, in UpdateSema().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:116,Deployability,Update,UpdateSema,116,"// This updates visibility for Preprocessor only. For Sema, which can be; // nullptr here, we do the same later, in UpdateSema().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:105,Performance,load,loading,105,"/// Retrieve the name of the original source file name; /// directly from the AST file, without actually loading the AST; /// file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:20,Availability,error,errors,20,// FIXME this drops errors on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:24,Availability,error,errors,24,// FIXME this drops the errors on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:311,Performance,load,loading,311,"// FIXME: We should add the pcm to the InMemoryModuleCache if it could be; // read again later, but we do not have the context here to determine if it; // is safe to change the result of InMemoryModuleCache::getPCMState().; // FIXME: This allows use of the VFS; we do not allow use of the; // VFS when actually loading a module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:158,Safety,safe,safe,158,"// FIXME: We should add the pcm to the InMemoryModuleCache if it could be; // read again later, but we do not have the context here to determine if it; // is safe to change the result of InMemoryModuleCache::getPCMState().; // FIXME: This allows use of the VFS; we do not allow use of the; // VFS when actually loading a module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:20,Availability,error,errors,20,// FIXME this drops errors on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:24,Availability,error,error,24,// FIXME this drops the error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:20,Availability,error,errors,20,// FIXME this drops errors on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:20,Availability,error,errors,20,// FIXME this drops errors on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:20,Availability,error,errors,20,// FIXME this drops errors on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:26,Performance,perform,perform,26,// No other validation to perform.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:12,Security,validat,validation,12,// No other validation to perform.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:24,Availability,error,error,24,// FIXME this drops the error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:24,Availability,error,error,24,// FIXME this drops the error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:2,Security,Validat,ValidateDiagnosticOptions,2,/*ValidateDiagnosticOptions=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:89,Availability,error,error,89,// Submodule information is only valid if we have a current module.; // FIXME: Should we error on these cases?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:32,Availability,error,error,32,// Don't emit module relocation error if we have -fno-validate-pch,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:54,Security,validat,validate-pch,54,// Don't emit module relocation error if we have -fno-validate-pch,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:3,Usability,Clear,Clear,3,// Clear out data that will be replaced by what is in the module file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:17,Availability,avail,available,17,"// The module is available unless it's missing a requirement; relevant; // requirements will be (re-)added by SUBMODULE_REQUIRES records.; // Missing headers that were present when the module was built do not; // make it unavailable -- if we got this far, this must be an explicitly; // imported module file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:66,Performance,Load,Load,66,// FIXME: Textual headers are not marked in the HeaderInfo table. Load; // them here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:14,Performance,load,loaded,14,"// Once we've loaded the set of exports, there's no reason to keep; // the parsed, unresolved exports around.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:91,Integrability,rout,routine,91,"/// Parse the record that corresponds to a LangOptions data; /// structure.; ///; /// This routine parses the language options from the AST file and then gives; /// them to the AST listener if one is set.; ///; /// \returns true if the listener deems the file unacceptable, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:23,Security,hash,hash,23,// Look in the on-disk hash table for an entry for this file name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:71,Deployability,upgrade,upgraded,71,"// If this mapping was specified as a warning but the severity was; // upgraded due to diagnostic settings, simulate the current diagnostic; // settings (and use a warning).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:49,Modifiability,config,configured,49,"// For prefix ASTs, start with whatever the user configured on the; // command line.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:42,Performance,load,loading,42,/// Get the correct cursor and offset for loading a type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:139,Integrability,rout,routine,139,"/// Read and return the type with the given index..; ///; /// The index is the type ID, shifted and minus the number of predefs. This; /// routine actually reads the record corresponding to the type at the given; /// location. It is a helper routine for GetType, which deals with reading type; /// IDs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:242,Integrability,rout,routine,242,"/// Read and return the type with the given index..; ///; /// The index is the type ID, shifted and minus the number of predefs. This; /// routine actually reads the record corresponding to the type at the given; /// location. It is a helper routine for GetType, which deals with reading type; /// IDs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:20,Performance,load,loading,20,// Note that we are loading a type record.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:63,Deployability,update,update,63,"// Outside of C++, we don't have a lookup table for the TU, so update; // the identifier instead. (For C++ modules, we don't store decls; // in the serialized identifier table, so we do the lookup in the TU.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:3,Performance,Load,Load,3,// Load the list of declarations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:123,Integrability,depend,depends,123,"/// Under non-PCH compilation the consumer receives the objc methods; /// before receiving the implementation, and codegen depends on this.; /// We simulate this by deserializing and passing to consumer the methods of the; /// implementation before passing the deserialized implementation decl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:65,Availability,down,down,65,"/// Return the amount of memory used by memory buffers, breaking down; /// by heap-backed versus mmap'ed memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:3,Performance,Load,Load,3,// Load the offsets of the declarations that Sema references.; // They will be lazily deserialized when needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:3,Deployability,Update,Update,3,// Update the state of pragmas. Use the same API as if we had encountered the; // pragma in the source.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:20,Performance,load,loading,20,// Note that we are loading an identifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:164,Performance,Perform,Perform,164,"// We don't need to do identifier table lookups in C++ modules (we preload; // all interesting declarations, and don't need to use the scope for name; // lookups). Perform the lookup in PCH files, though, since we don't build; // a complete initial identifier table if we're carrying on from a PCH.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:11,Performance,queue,queued,11,"// Try the queued iterator, which may itself be empty.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:113,Performance,Load,LoadSelector,113,"// FIXME: Not quite happy with the statistics here. We probably should; // disable this tracking when called via LoadSelector.; // Also, should entries without methods count as misses?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:35,Deployability,update,update,35,// Get the selector generation and update it to the current generation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:157,Deployability,update,update,157,"// Add methods to the global pool *after* setting hasMoreThanOneDecl, since; // when building a module we keep every method individually and may need to; // update hasMoreThanOneDecl as we add the methods.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:81,Performance,load,loaded,81,// Keep track of this lambda so it can be merged with another lambda that; // is loaded later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:30,Safety,avoid,avoid,30,// It would be complicated to avoid reading the methods anyway. So don't.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:210,Performance,queue,queued,210,"/// Set the globally-visible declarations associated with the given; /// identifier.; ///; /// If the AST reader is currently in a state where the given declaration IDs; /// cannot safely be resolved, they are queued until it is safe to resolve; /// them.; ///; /// \param II an IdentifierInfo that refers to one or more globally-visible; /// declarations.; ///; /// \param DeclIDs the set of declaration IDs with the name @p II that are; /// visible at global scope.; ///; /// \param Decls if non-null, this vector will be populated with the set of; /// deserialized declarations. These declarations will not be pushed into; /// scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:181,Safety,safe,safely,181,"/// Set the globally-visible declarations associated with the given; /// identifier.; ///; /// If the AST reader is currently in a state where the given declaration IDs; /// cannot safely be resolved, they are queued until it is safe to resolve; /// them.; ///; /// \param II an IdentifierInfo that refers to one or more globally-visible; /// declarations.; ///; /// \param DeclIDs the set of declaration IDs with the name @p II that are; /// visible at global scope.; ///; /// \param Decls if non-null, this vector will be populated with the set of; /// deserialized declarations. These declarations will not be pushed into; /// scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:229,Safety,safe,safe,229,"/// Set the globally-visible declarations associated with the given; /// identifier.; ///; /// If the AST reader is currently in a state where the given declaration IDs; /// cannot safely be resolved, they are queued until it is safe to resolve; /// them.; ///; /// \param II an IdentifierInfo that refers to one or more globally-visible; /// declarations.; ///; /// \param DeclIDs the set of declaration IDs with the name @p II that are; /// visible at global scope.; ///; /// \param Decls if non-null, this vector will be populated with the set of; /// deserialized declarations. These declarations will not be pushed into; /// scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:3,Performance,Queue,Queue,3,// Queue this declaration so that it will be added to the; // translation unit scope and identifier's declaration chain; // once a Sema object is known.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:12,Usability,simpl,simply,12,"// If we're simply supposed to record the declarations, do so now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:159,Performance,load,loaded,159,"// For a file representing a module, use the submodule ID of the top-level; // module as the file ID. For any other kind of file, the number of such; // files loaded beforehand will be the same on reload.; // FIXME: Is this true even if we have an explicit module file and a PCH?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:3,Performance,Load,Load,3,// Load this selector from the selector table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:78,Performance,load,loaded,78,"// If any identifiers with corresponding top-level declarations have; // been loaded, load those declarations now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:86,Performance,load,load,86,"// If any identifiers with corresponding top-level declarations have; // been loaded, load those declarations now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:3,Performance,Load,Load,3,// Load each function type that we deferred loading because it was a; // deduced type that might refer to a local type declared within itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:44,Performance,load,loading,44,// Load each function type that we deferred loading because it was a; // deduced type that might refer to a local type declared within itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:13,Modifiability,variab,variable,13,// Load each variable type that we deferred loading because it was a; // deduced type that might refer to a local type declared within itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:3,Performance,Load,Load,3,// Load each variable type that we deferred loading because it was a; // deduced type that might refer to a local type declared within itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:44,Performance,load,loading,44,// Load each variable type that we deferred loading because it was a; // deduced type that might refer to a local type declared within itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:3,Performance,Load,Load,3,// Load pending declaration chains.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:3,Performance,Load,Load,3,// Load any pending macro definitions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:82,Performance,load,loading,82,// Wire up the DeclContexts for Decls that we delayed setting until; // recursive loading is completed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:35,Deployability,update,updates,35,// Perform any pending declaration updates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:3,Performance,Perform,Perform,3,// Perform any pending declaration updates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:2,Availability,Error,ErrorOnTagTypeMismatch,2,/*ErrorOnTagTypeMismatch =*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:42,Performance,cache,cached,42,// Invalidate duplicate extension and the cached ivar list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:22,Deployability,update,update,22,"// At this point, all update records for loaded decls are in place, so any; // fake class definitions should have become real.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:41,Performance,load,loaded,41,"// At this point, all update records for loaded decls are in place, so any; // fake class definitions should have become real.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:84,Integrability,protocol,protocol,84,"// If we deserialized any C++ or Objective-C class definitions, any; // Objective-C protocol definitions, or any redeclarable templates, make sure; // that all redeclarations point to the definitions. Note that this can only; // happen now, after the redeclaration chains have been fully wired.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:3,Performance,Load,Load,3,// Load the bodies of any functions or methods we've encountered. We do; // this now (delayed) so that we can be sure that the declaration chains; // have been fully wired up (hasBody relies on this).; // FIXME: We shouldn't require complete redeclaration chains here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:11,Performance,perform,perform,11,// We only perform ODR checks for decls not in the explicit; // global module fragment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:95,Availability,error,error,95,"// Only diagnose out-of-line method definitions. If they are; // in class definitions, then an error will be generated when; // processing the class bodies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:202,Availability,failure,failures,202,"// Trigger the import of the full definition of each class that had any; // odr-merging problems, so we can produce better diagnostics for them.; // These updates may in turn find and diagnose some ODR failures, so take; // ownership of the set first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:155,Deployability,update,updates,155,"// Trigger the import of the full definition of each class that had any; // odr-merging problems, so we can produce better diagnostics for them.; // These updates may in turn find and diagnose some ODR failures, so take; // ownership of the set first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:34,Integrability,interface,interface,34,// Trigger the import of the full interface definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:34,Integrability,protocol,protocol,34,// Trigger the import of the full protocol definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:185,Energy Efficiency,efficient,efficiently,185,"// This can happen if the declaration is merely mergeable and not; // actually redeclarable (we looked for redeclarations earlier).; //; // FIXME: We should be able to detect this more efficiently, without; // pulling in all of the members of CanonDef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:168,Safety,detect,detect,168,"// This can happen if the declaration is merely mergeable and not; // actually redeclarable (we looked for redeclarations earlier).; //; // FIXME: We should be able to detect this more efficiently, without; // pulling in all of the members of CanonDef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:25,Availability,failure,failure,25,// Issue any pending ODR-failure diagnostics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:23,Deployability,update,updates,23,// All definitions are updates to the same declaration. This happens if a; // module instantiates the declaration of a class template specialization; // and two or more other modules instantiate its definition.; //; // FIXME: Indicate which modules had instantiations of this definition.; // FIXME: How can this even happen?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:25,Availability,failure,failure,25,// Issue any pending ODR-failure diagnostics for RecordDecl in C/ObjC. Note; // that in C++ this is done as a part of CXXRecordDecl ODR checking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:13,Availability,failure,failures,13,// Issue ODR failures diagnostics for functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:13,Availability,failure,failures,13,// Issue ODR failures diagnostics for enums.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:61,Integrability,interface,interface,61,"// If we've already pointed out a specific problem with this interface,; // don't bother issuing a general ""something's different"" diagnostic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:61,Integrability,protocol,protocol,61,"// If we've already pointed out a specific problem with this protocol,; // don't bother issuing a general ""something's different"" diagnostic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:95,Safety,avoid,avoid,95,"// We decrease NumCurrentElementsDeserializing only after pending actions; // are finished, to avoid recursively re-calling finishPendingActions().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:54,Deployability,update,updates,54,// Propagate exception specification and deduced type updates along; // redeclaration chains.; //; // We do this now rather than in finishPendingActions because we want to; // be able to walk the complete redeclaration chains of the updated decls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:233,Deployability,update,updated,233,// Propagate exception specification and deduced type updates along; // redeclaration chains.; //; // We do this now rather than in finishPendingActions because we want to; // be able to walk the complete redeclaration chains of the updated decls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:27,Performance,load,loading,27,"// We are not in recursive loading, so it's safe to pass the ""interesting""; // decls to the consumer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:44,Safety,safe,safe,44,"// We are not in recursive loading, so it's safe to pass the ""interesting""; // decls to the consumer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:39,Performance,perform,performance,39,"// FIXME: this works around module+PCH performance issue.; // Rather than erase the result from the map, which is O(n), just clear; // the vector of NamedDecls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:125,Usability,clear,clear,125,"// FIXME: this works around module+PCH performance issue.; // Rather than erase the result from the map, which is O(n), just clear; // the vector of NamedDecls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:474,Performance,load,loading,474,"//===- ASTReaderDecl.cpp - Decl Deserialization ---------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the ASTReader::readDeclRecord method, which is the; // entrypoint for loading a decl.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:184,Energy Efficiency,allocate,allocate,184,"/// Commit to a primary definition of the class RD, which is known to be; /// a definition of the class. We might not have read the definition data; /// for it yet. If we haven't then allocate placeholder definition data; /// now too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:17,Performance,load,loading,17,/// Results from loading a RedeclarableDecl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:143,Deployability,update,update,143,"/// Class used to capture the result of searching for an existing; /// declaration of a specific kind and name, along with the ability; /// to update the place where this result was found (the declaration; /// chain hanging off an identifier or the DeclContext we searched in); /// if requested.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:20,Safety,avoid,avoid,20,// FIXME: We should avoid this pattern of getting the ASTContext.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:49,Performance,load,load,49,// Store the offset of the body so we can lazily load it later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:80,Deployability,update,update,80,// At this point we have deserialized and merged the decl and it is safe to; // update its canonical decl to signal that the entire entity is used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:68,Safety,safe,safe,68,// At this point we have deserialized and merged the decl and it is safe to; // update its canonical decl to signal that the entire entity is used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:82,Performance,load,load,82,"// If this is a tag declaration with a typedef name for linkage, it's safe; // to load that typedef now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:70,Safety,safe,safe,70,"// If this is a tag declaration with a typedef name for linkage, it's safe; // to load that typedef now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:51,Safety,safe,safely,51,"// if we have a fully initialized TypeDecl, we can safely read its type now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:123,Deployability,update,update,123,"// If the context is a class, we might not have actually merged it yet, in; // the case where the definition comes from an update record.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:3,Safety,Avoid,Avoid,3,// Avoid calling setLexicalDeclContext() directly because it uses; // Decl::getASTContext() internally which is unsafe during derialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:112,Safety,unsafe,unsafe,112,// Avoid calling setLexicalDeclContext() directly because it uses; // Decl::getASTContext() internally which is unsafe during derialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:3,Safety,Avoid,Avoid,3,// Avoid calling setAttrs() directly because it uses Decl::getASTContext(); // internally which is unsafe during derialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:99,Safety,unsafe,unsafe,99,// Avoid calling setAttrs() directly because it uses Decl::getASTContext(); // internally which is unsafe during derialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:34,Security,hash,hash,34,// We don't want to check the ODR hash value for declarations from global; // module fragment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:19,Modifiability,variab,variable,19,"// For function or variable declarations, defer reading the type in case the; // declaration has a deduced type that references an entity declared within; // the function definition or variable initializer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:185,Modifiability,variab,variable,185,"// For function or variable declarations, defer reading the type in case the; // declaration has a deduced type that references an entity declared within; // the function definition or variable initializer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:104,Safety,safe,safe,104,// if canonical add to template's set.; // The template that contains the specializations set. It's not safe to; // use getCanonicalDecl on Template since it may still be initializing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:100,Safety,avoid,avoid,100,// Get the InsertPos by FindNodeOrInsertPos() instead of calling; // InsertNode(FTInfo) directly to avoid the getASTContext() call in; // FunctionTemplateSpecializationInfo's Profile().; // We avoid getASTContext because a decl in the parent hierarchy may; // be initializing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:193,Safety,avoid,avoid,193,// Get the InsertPos by FindNodeOrInsertPos() instead of calling; // InsertNode(FTInfo) directly to avoid the getASTContext() call in; // FunctionTemplateSpecializationInfo's Profile().; // We avoid getASTContext because a decl in the parent hierarchy may; // be initializing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:66,Integrability,depend,dependent,66,// These are not merged; we don't need to merge redeclarations of dependent; // template friends.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:60,Performance,load,loading,60,"// We'll set up the real type in Visit, once we've finished loading the; // function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:115,Security,access,access,115,// Defer calling `setPure` until merging above has guaranteed we've set; // `DefinitionData` (as this will need to access it).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:3,Performance,Load,Load,3,"// Load the body on-demand. Most clients won't care, because method; // definitions rarely show up in headers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:32,Integrability,protocol,protocols,32,// Read the directly referenced protocols and their SourceLocations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:34,Integrability,protocol,protocols,34,// Read the transitive closure of protocols referenced by this class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:19,Performance,load,loaded,19,// Note that we've loaded this Objective-C class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:36,Integrability,interface,interfaces,36,// Don't check ObjCInterfaceDecl as interfaces are named and mismatches can be; // detected in VisitObjCInterfaceDecl. Here we are looking for redeclarations; // in extensions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:83,Safety,detect,detected,83,// Don't check ObjCInterfaceDecl as interfaces are named and mismatches can be; // detected in VisitObjCInterfaceDecl. Here we are looking for redeclarations; // in extensions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:90,Integrability,interface,interface,90,"// Note that this category has been deserialized. We do this before; // deserializing the interface declaration, so that it will consider this; /// category.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:3,Integrability,Protocol,Protocols,3,// Protocols in the class extension belong to the class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:12,Usability,GUID,GUID,12,"// Add this GUID to the AST context's lookup structure, and merge if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:11,Modifiability,variab,variable,11,"// If this variable has a deduced type, defer reading that type until we are; // done deserializing this variable, because the type might refer back to the; // variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:105,Modifiability,variab,variable,105,"// If this variable has a deduced type, defer reading that type until we are; // done deserializing this variable, because the type might refer back to the; // variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:160,Modifiability,variab,variable,160,"// If this variable has a deduced type, defer reading that type until we are; // done deserializing this variable, because the type might refer back to the; // variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:13,Modifiability,variab,variables,13,// Only true variables (not parameters or implicit parameters) can be; // merged; the other kinds are not really redeclarable at all.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:122,Modifiability,variab,variable,122,"// Store the offset of the initializer. Don't deserialize it yet: it might; // not be needed, and might refer back to the variable, for example if it; // contains a lambda.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:83,Modifiability,inherit,inheritance,83,"// FIXME: If this is a redeclaration of a function from another module, handle; // inheritance of default arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:9,Performance,load,loading,9,"// Defer loading the anonymous namespace until we've finished merging; // this namespace; loading it might load a later declaration of the; // same namespace, and we have an invariant that older declarations; // get merged before newer ones try to merge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:90,Performance,load,loading,90,"// Defer loading the anonymous namespace until we've finished merging; // this namespace; loading it might load a later declaration of the; // same namespace, and we have an invariant that older declarations; // get merged before newer ones try to merge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:107,Performance,load,load,107,"// Defer loading the anonymous namespace until we've finished merging; // this namespace; loading it might load a later declaration of the; // same namespace, and we have an invariant that older declarations; // get merged before newer ones try to merge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:11,Performance,perform,perform,11,// We only perform ODR checks for decls not in GMF.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:88,Performance,load,loaded,88,// We faked up this definition data because we found a class for which we'd; // not yet loaded the definition. Replace it with the real thing now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:88,Performance,load,load,88,// FIXME: Issue a diagnostic if the base classes don't match when we come; // to lazily load them.; // FIXME: Issue a diagnostic if the list of conversion functions doesn't; // match when we come to lazily load them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:206,Performance,load,load,206,// FIXME: Issue a diagnostic if the base classes don't match when we come; // to lazily load them.; // FIXME: Issue a diagnostic if the list of conversion functions doesn't; // match when we come to lazily load them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:85,Performance,load,load,85,// FIXME: Issue a diagnostic if FirstFriend doesn't match when we come to; // lazily load it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:71,Energy Efficiency,allocate,allocate,71,"// Determine whether this is a lambda closure type, so that we can; // allocate the appropriate DefinitionData structure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:117,Deployability,update,update,117,"// We might already have a different definition for this record. This can; // happen either because we're reading an update record, or because we've; // already done some merging. Either way, just merge into it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:49,Deployability,update,update,49,"// If this is not the first declaration or is an update record, we can have; // other redeclarations already. Make a note that we need to propagate the; // DefinitionData pointer onto them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:22,Performance,load,loaded,22,"// We've not actually loaded the ClassTemplateDecl yet, because we're; // currently being loaded as its pattern. Rely on it to set up our; // TypeForDecl (see VisitClassTemplateDecl).; //; // Beware: we do not yet know our canonical declaration, and may still; // get merged once the surrounding class template has got off the ground.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:90,Performance,load,loaded,90,"// We've not actually loaded the ClassTemplateDecl yet, because we're; // currently being loaded as its pattern. Rely on it to set up our; // TypeForDecl (see VisitClassTemplateDecl).; //; // Beware: we do not yet know our canonical declaration, and may still; // get merged once the surrounding class template has got off the ground.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:2,Deployability,Update,Update,2,/*Update=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:10,Performance,load,load,10,// Lazily load the key function to avoid deserializing every method so we can; // compute it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:35,Safety,avoid,avoid,35,// Lazily load the key function to avoid deserializing every method so we can; // compute it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:137,Deployability,update,update,137,"// FIXME: This is wrong for the ARM ABI, where some other module may have; // made this function no longer be a key function. We need an update; // record or similar for that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:3,Safety,Avoid,Avoid,3,"// Avoid invariant checking of CXXMethodDecl::addOverriddenMethod,; // MD may be initializing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:15,Modifiability,inherit,inherited,15,"// We need the inherited constructor information to merge the declaration,; // so we have to read it before we call VisitCXXMethodDecl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:19,Energy Efficiency,allocate,allocated,19,// Make sure we've allocated the Common pointer first. We do this before; // VisitTemplateDecl so that getCommonPtr() can be used during initialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:11,Performance,load,loaded,11,"// We were loaded before our templated declaration was. We've not set up; // its corresponding type yet (see VisitCXXRecordDeclImpl), so reconstruct; // it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:103,Performance,optimiz,optimization,103,"// 0 indicates that this declaration was the only declaration of its entity,; // and is used for space optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:12,Performance,load,loading,12,// We delay loading of the redeclaration chain to avoid deeply nested calls.; // We temporarily set the first (canonical) declaration as the previous one; // which is the one that matters and mark the real previous DeclID to be; // loaded & attached later on.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:232,Performance,load,loaded,232,// We delay loading of the redeclaration chain to avoid deeply nested calls.; // We temporarily set the first (canonical) declaration as the previous one; // which is the one that matters and mark the real previous DeclID to be; // loaded & attached later on.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:50,Safety,avoid,avoid,50,// We delay loading of the redeclaration chain to avoid deeply nested calls.; // We temporarily set the first (canonical) declaration as the previous one; // which is the one that matters and mark the real previous DeclID to be; // loaded & attached later on.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:24,Performance,load,load,24,// Note that we need to load local redeclarations of this decl and build a; // decl chain for them. This must happen *after* we perform the preloading; // above; this ensures that the redeclaration chain is built in the correct; // order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:128,Performance,perform,perform,128,// Note that we need to load local redeclarations of this decl and build a; // decl chain for them. This must happen *after* we perform the preloading; // above; this ensures that the redeclaration chain is built in the correct; // order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:22,Availability,avail,available,22,"// If modules are not available, there is no reason to perform this merge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:55,Performance,perform,perform,55,"// If modules are not available, there is no reason to perform this merge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:273,Modifiability,variab,variables,273,"/// Attempt to merge D with a previous declaration of the same lambda, which is; /// found by its index within its context declaration, if it has one.; ///; /// We can't look up lambdas in their enclosing lexical or semantic context in; /// general, because for lambdas in variables, both of those might be a; /// namespace or the translation unit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:22,Availability,avail,available,22,"// If modules are not available, there is no reason to perform this merge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:55,Performance,perform,perform,55,"// If modules are not available, there is no reason to perform this merge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:96,Performance,load,loaded,96,"// Look up this lambda to see if we've seen it before. If so, merge with the; // one we already loaded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:22,Testability,assert,asserting,22,"/// ""Cast"" to type T, asserting if we don't have an implicit conversion.; /// We use this to put code in a template that will only be valid for certain; /// instantiations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:88,Modifiability,Refactor,Refactor,88,// Merge with any existing definition.; // FIXME: This is duplicated in several places. Refactor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:30,Deployability,update,update,30,"// When we merge a namespace, update its pointer to the first namespace.; // We cannot have loaded any redeclarations of this declaration yet, so; // there's nothing else that needs to be updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:188,Deployability,update,updated,188,"// When we merge a namespace, update its pointer to the first namespace.; // We cannot have loaded any redeclarations of this declaration yet, so; // there's nothing else that needs to be updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:92,Performance,load,loaded,92,"// When we merge a namespace, update its pointer to the first namespace.; // We cannot have loaded any redeclarations of this declaration yet, so; // there's nothing else that needs to be updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:22,Availability,avail,available,22,"// If modules are not available, there is no reason to perform this merge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:55,Performance,perform,perform,55,"// If modules are not available, there is no reason to perform this merge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:22,Availability,avail,available,22,"// If modules are not available, there is no reason to perform this merge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:55,Performance,perform,perform,55,"// If modules are not available, there is no reason to perform this merge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:24,Performance,perform,performed,24,"// ODR-based merging is performed in C++ and in some cases (tag types) in C.; // Note that C identically-named things in different translation units are; // not redeclarations, but may still have compatible types, where ODR-like; // semantics may apply.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:280,Integrability,rout,routine,280,"//===----------------------------------------------------------------------===//; // ASTReader Implementation; //===----------------------------------------------------------------------===//; /// Note that we have loaded the declaration with the given; /// Index.; ///; /// This routine notes that this declaration has already been loaded,; /// so that future GetDecl calls will return this declaration rather; /// than trying to load a new declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:215,Performance,load,loaded,215,"//===----------------------------------------------------------------------===//; // ASTReader Implementation; //===----------------------------------------------------------------------===//; /// Note that we have loaded the declaration with the given; /// Index.; ///; /// This routine notes that this declaration has already been loaded,; /// so that future GetDecl calls will return this declaration rather; /// than trying to load a new declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:333,Performance,load,loaded,333,"//===----------------------------------------------------------------------===//; // ASTReader Implementation; //===----------------------------------------------------------------------===//; /// Note that we have loaded the declaration with the given; /// Index.; ///; /// This routine notes that this declaration has already been loaded,; /// so that future GetDecl calls will return this declaration rather; /// than trying to load a new declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:431,Performance,load,load,431,"//===----------------------------------------------------------------------===//; // ASTReader Implementation; //===----------------------------------------------------------------------===//; /// Note that we have loaded the declaration with the given; /// Index.; ///; /// This routine notes that this declaration has already been loaded,; /// so that future GetDecl calls will return this declaration rather; /// than trying to load a new declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:127,Integrability,rout,routine,127,"/// Determine whether the consumer will be interested in seeing; /// this declaration (via HandleTopLevelDecl).; ///; /// This routine should return true for anything that might affect; /// code generation, e.g., inline function definitions, Objective-C; /// declarations with metadata, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:42,Performance,load,loading,42,/// Get the correct cursor and offset for loading a declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:69,Deployability,update,update,69,"// If there's no definition yet, then DC's definition is added by an update; // record, but we've not yet loaded that update record. In this case, we; // commit to DC being the canonical definition now, and will fix this when; // we load the update record.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:118,Deployability,update,update,118,"// If there's no definition yet, then DC's definition is added by an update; // record, but we've not yet loaded that update record. In this case, we; // commit to DC being the canonical definition now, and will fix this when; // we load the update record.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:242,Deployability,update,update,242,"// If there's no definition yet, then DC's definition is added by an update; // record, but we've not yet loaded that update record. In this case, we; // commit to DC being the canonical definition now, and will fix this when; // we load the update record.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:106,Performance,load,loaded,106,"// If there's no definition yet, then DC's definition is added by an update; // record, but we've not yet loaded that update record. In this case, we; // commit to DC being the canonical definition now, and will fix this when; // we load the update record.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:233,Performance,load,load,233,"// If there's no definition yet, then DC's definition is added by an update; // record, but we've not yet loaded that update record. In this case, we; // commit to DC being the canonical definition now, and will fix this when; // we load the update record.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:179,Performance,perform,perform,179,"// If this declaration is from a merged context, make a note that we need to; // check that the canonical definition of that context contains the decl.; //; // Note that we don't perform ODR checks for decls from the global module; // fragment.; //; // FIXME: We should do something similar if we merge two definitions of the; // same template specialization into the same CXXRecordDecl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:66,Performance,Cache,Cache,66,// We should keep at most one definition on the chain.; // FIXME: Cache the definition once we've found it. Building a chain with; // N definitions currently takes O(N^2) time here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:4,Modifiability,Inherit,Inherit,4,/// Inherit the default template argument from \p From to \p To. Returns; /// \c false if there is no default template for \p From.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:50,Modifiability,inherit,inherit,50,"// If the declaration declares a template, it may inherit default arguments; // from the previous declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:54,Modifiability,Inherit,Inheritable,54,"// If any of the declaration in the chain contains an Inheritable attribute,; // it needs to be added to all the declarations in the redeclarable chain.; // FIXME: Only the logic of merging MSInheritableAttr is present, it should; // be extended for all inheritable attributes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:237,Modifiability,extend,extended,237,"// If any of the declaration in the chain contains an Inheritable attribute,; // it needs to be added to all the declarations in the redeclarable chain.; // FIXME: Only the logic of merging MSInheritableAttr is present, it should; // be extended for all inheritable attributes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:254,Modifiability,inherit,inheritable,254,"// If any of the declaration in the chain contains an Inheritable attribute,; // it needs to be added to all the declarations in the redeclarable chain.; // FIXME: Only the logic of merging MSInheritableAttr is present, it should; // be extended for all inheritable attributes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:173,Testability,log,logic,173,"// If any of the declaration in the chain contains an Inheritable attribute,; // it needs to be added to all the declarations in the redeclarable chain.; // FIXME: Only the logic of merging MSInheritableAttr is present, it should; // be extended for all inheritable attributes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:20,Performance,load,loading,20,// Note that we are loading a declaration record.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:21,Deployability,update,update,21,// Load any relevant update records.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:3,Performance,Load,Load,3,// Load any relevant update records.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:3,Performance,Load,Load,3,// Load the categories after recursive loading is finished.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:39,Performance,load,loading,39,// Load the categories after recursive loading is finished.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:110,Performance,queue,queue,110,"// If we have deserialized a declaration that has a definition the; // AST consumer might need to know about, queue it.; // We don't pass it to the consumer immediately because we may be in recursive; // loading, and some declarations may still be initializing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:204,Performance,load,loading,204,"// If we have deserialized a declaration that has a definition the; // AST consumer might need to know about, queue it.; // We don't pass it to the consumer immediately because we may be in recursive; // loading, and some declarations may still be initializing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:9,Modifiability,variab,variable,9,// Guard variable to avoid recursively redoing the process of passing; // decls to consumer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:21,Safety,avoid,avoid,21,// Guard variable to avoid recursively redoing the process of passing; // decls to consumer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:21,Performance,load,loaded,21,// Ensure that we've loaded all potentially-interesting declarations; // that need to be eagerly loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:97,Performance,load,loaded,97,// Ensure that we've loaded all potentially-interesting declarations; // that need to be eagerly loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:127,Deployability,update,updates,127,"// The declaration may have been modified by files later in the chain.; // If this is the case, read the record containing the updates from each file; // and pass it to ASTDeclReader to make the modifications.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:66,Performance,load,loaded,66,"// Check if this decl was interesting to the consumer. If we just loaded; // the declaration, then we know it was interesting and we skip the call; // to isConsumerInterestedIn because it is unsafe to call in the; // current ASTReader state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:191,Safety,unsafe,unsafe,191,"// Check if this decl was interesting to the consumer. If we just loaded; // the declaration, then we know it was interesting and we skip the call; // to isConsumerInterestedIn because it is unsafe to call in the; // current ASTReader state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:26,Availability,error,error,26,// FIXME don't do a fatal error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:28,Deployability,update,updates,28,"// Load the pending visible updates for this decl context, if it has any.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:3,Performance,Load,Load,3,"// Load the pending visible updates for this decl context, if it has any.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:3,Performance,Load,Load,3,// Load the list of other redeclarations from this module file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:18,Integrability,interface,interface,18,"/// Given an ObjC interface, goes through the modules and links to the; /// interface all the categories for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:76,Integrability,interface,interface,76,"/// Given an ObjC interface, goes through the modules and links to the; /// interface all the categories for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:2,Availability,Error,ErrorOnTagTypeMismatch,2,/*ErrorOnTagTypeMismatch =*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:12,Performance,load,loaded,12,"// If we've loaded all of the category information we care about from; // this module file, we're done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:35,Availability,down,down,35,"// Map global ID of the definition down to the local ID used in this; // module file. If there is no such mapping, we'll find nothing here; // (or in any module it imports).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:3,Performance,Perform,Perform,3,// Perform a binary search to find the local redeclarations for this; // declaration (if any).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:105,Integrability,depend,depends,105,"// We didn't find anything. If the class definition is in this module; // file, then the module files it depends on cannot have any categories,; // so suppress further lookup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:105,Deployability,update,update,105,// We have to read the default argument regardless of whether we use it; // so that hypothetical further update records aren't messed up.; // TODO: Add a function to skip over the next expr record.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:18,Deployability,update,update,18,// Only apply the update if the parameter still has an uninstantiated; // default argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:18,Deployability,update,update,18,// Only apply the update if the field still has an uninstantiated; // default member initializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:81,Deployability,update,update,81,// FIXME: Maybe check for ODR violations.; // It's safe to stop now because this update record is always last.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:51,Safety,safe,safe,51,// FIXME: Maybe check for ODR violations.; // It's safe to stop now because this update record is always last.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:2,Deployability,Update,Update,2,/*Update*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:11,Deployability,update,update,11,// Visible update is handled separately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:93,Performance,load,loaded,93,"// If the declaration already has attributes, we assume that some other; // AST file already loaded them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:64,Deployability,update,update,64,// Set the 'operator delete' directly to avoid emitting another update; // record.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:41,Safety,avoid,avoid,41,// Set the 'operator delete' directly to avoid emitting another update; // record.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:3,Deployability,Update,Update,3,"// Update this declaration's exception specification, if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h:15,Performance,perform,performs,15,/// Class that performs name lookup into a DeclContext stored; /// in an AST file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h:52,Security,hash,hash,52,"/// Base class for the trait describing the on-disk hash table for the; /// identifiers in an AST file.; ///; /// This class is not useful by itself; rather, it provides common; /// functionality for accessing the on-disk hash table of identifiers; /// in an AST file. Different subclasses customize that functionality; /// based on what information they are interested in. Those subclasses; /// must provide the \c data_type type and the ReadData operation, only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h:200,Security,access,accessing,200,"/// Base class for the trait describing the on-disk hash table for the; /// identifiers in an AST file.; ///; /// This class is not useful by itself; rather, it provides common; /// functionality for accessing the on-disk hash table of identifiers; /// in an AST file. Different subclasses customize that functionality; /// based on what information they are interested in. Those subclasses; /// must provide the \c data_type type and the ReadData operation, only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h:222,Security,hash,hash,222,"/// Base class for the trait describing the on-disk hash table for the; /// identifiers in an AST file.; ///; /// This class is not useful by itself; rather, it provides common; /// functionality for accessing the on-disk hash table of identifiers; /// in an AST file. Different subclasses customize that functionality; /// based on what information they are interested in. Those subclasses; /// must provide the \c data_type type and the ReadData operation, only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h:59,Performance,optimiz,optimizer,59,// This hopefully will just get inlined and removed by the optimizer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h:59,Performance,optimiz,optimizer,59,// This hopefully will just get inlined and removed by the optimizer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h:15,Performance,perform,performs,15,/// Class that performs lookup for an identifier stored in an AST file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h:16,Security,hash,hash,16,/// The on-disk hash table used to contain information about; /// all of the identifiers in the program.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h:15,Performance,perform,performs,15,/// Class that performs lookup for a selector's entries in the global; /// method pool stored in an AST file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h:16,Security,hash,hash,16,/// The on-disk hash table used for the global method pool.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h:43,Security,hash,hash,43,"/// Trait class used to search the on-disk hash table containing all of; /// the header search information.; ///; /// The on-disk hash table contains a mapping from each header path to; /// information about that header (how many times it has been included, its; /// controlling macro, etc.). Note that we actually hash based on the size; /// and mtime, and support ""deep"" comparisons of file names based on current; /// inode numbers, so that the search can cope with non-normalized path names; /// and symlinks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h:130,Security,hash,hash,130,"/// Trait class used to search the on-disk hash table containing all of; /// the header search information.; ///; /// The on-disk hash table contains a mapping from each header path to; /// information about that header (how many times it has been included, its; /// controlling macro, etc.). Note that we actually hash based on the size; /// and mtime, and support ""deep"" comparisons of file names based on current; /// inode numbers, so that the search can cope with non-normalized path names; /// and symlinks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h:315,Security,hash,hash,315,"/// Trait class used to search the on-disk hash table containing all of; /// the header search information.; ///; /// The on-disk hash table contains a mapping from each header path to; /// information about that header (how many times it has been included, its; /// controlling macro, etc.). Note that we actually hash based on the size; /// and mtime, and support ""deep"" comparisons of file names based on current; /// inode numbers, so that the search can cope with non-normalized path names; /// and symlinks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h:16,Security,hash,hash,16,/// The on-disk hash table used for known header files.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderStmt.cpp:137,Energy Efficiency,allocate,allocate,137,"// NumAttrs in AttributedStmt is set when creating an empty; // AttributedStmt in AttributedStmt::CreateEmpty, since it is needed; // to allocate the right amount of space for the trailing Attr *.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderStmt.cpp:100,Energy Efficiency,allocate,allocate,100,"// NumConcatenated, Length and CharByteWidth are set by the empty; // ctor since they are needed to allocate storage for the trailing objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderStmt.cpp:16,Availability,failure,failure,16,// Substitution failure,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderStmt.cpp:13,Testability,test,test,13,// FIXME: no test coverage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderStmt.cpp:13,Testability,test,test,13,// FIXME: no test coverage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderStmt.cpp:13,Testability,test,test,13,// FIXME: no test coverage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderStmt.cpp:3,Deployability,Install,Install,3,// Install all the subexpressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTReaderStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:35,Security,hash,hash,35,"// For implicit modules, write the hash of the PCM as its signature.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:34,Security,hash,hash,34,// Flush first to prepare the PCM hash (signature).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:35,Security,hash,hash,35,"// For implicit modules, write the hash of the PCM as its signature.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:32,Testability,log,log,32,"// Note: we don't serialize the log or serialization file names, because; // they are generally transient files and will almost always be overridden.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:3,Availability,Error,Errors,3,// Errors,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:120,Performance,load,loading,120,"// If the home of the module is the current working directory, then we; // want to pick up the cwd of the build process loading the module, not; // our cwd, when we load this module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:165,Performance,load,load,165,"// If the home of the module is the current working directory, then we; // want to pick up the cwd of the build process loading the module, not; // our cwd, when we load this module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:33,Performance,cache,cache,33,// Write out the specific module cache path that contains the module files.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:55,Security,hash,hash,55,"// If we're building an implicit module with a context hash, the importer is; // guaranteed to have the same macros defined on the command line. Skip; // writing them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:64,Performance,cache,cache,64,// Detailed record is important since it is used for the module cache hash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:70,Security,hash,hash,70,// Detailed record is important since it is used for the module cache hash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:21,Security,hash,hash,21,// Create input file hash abbreviation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:16,Security,hash,hash,16,// Emit content hash for this file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:30,Security,hash,hash,30,// Trait used for the on-disk hash table of header search information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:7,Security,hash,hash,7,"// The hash is based only on size/time of the file, so that the reader can; // match even when symlinking or excess path elements (""foo/../"", ""../""); // change the form of the name. However, complete path is still the key.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:242,Safety,avoid,avoid,242,"// Map to disk files where possible, to pick up any missing stat; // information. This also means we don't need to check the unresolved; // headers list when emitting resolved headers in the first loop below.; // FIXME: It'd be preferable to avoid doing this if we were given; // sufficient stat information in the module map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:32,Performance,load,load,32,"// Get the file info. This will load info from the external source if; // necessary. Skip emitting this file if we have no information on it; // as a header file (in which case HFI will be null) or if it hasn't; // changed since it was loaded. Also skip it if it's for a modular header; // from a different module; in that case, we rely on the module(s); // containing the header to provide this information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:236,Performance,load,loaded,236,"// Get the file info. This will load info from the external source if; // necessary. Skip emitting this file if we have no information on it; // as a header file (in which case HFI will be null) or if it hasn't; // changed since it was loaded. Also skip it if it's for a modular header; // from a different module; in that case, we rely on the module(s); // containing the header to provide this information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:9,Performance,perform,performed,9,"// If we performed any translation on the file name at all, we need to; // save this string, since the generator will refer to it later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:22,Security,hash,hash,22,// Create the on-disk hash table in a buffer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:295,Availability,error,errors,295,"/// Writes the block containing the serialized form of the; /// source manager.; ///; /// TODO: We should probably use an on-disk hash table (stored in a; /// blob), indexed based on the file name, so that we only create; /// entries for files that we actually need. In the common case (no; /// errors), we probably won't have to create file entries for any of; /// the files in the AST.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:130,Security,hash,hash,130,"/// Writes the block containing the serialized form of the; /// source manager.; ///; /// TODO: We should probably use an on-disk hash table (stored in a; /// blob), indexed based on the file name, so that we only create; /// entries for files that we actually need. In the common case (no; /// errors), we probably won't have to create file entries for any of; /// the files in the AST.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:97,Performance,load,loading,97,// Write the source-location offsets table into the AST block. This; // table is used for lazily loading source-location information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:28,Integrability,depend,depends,28,"// Write the line table. It depends on remapping working, so it must come; // after the source location offsets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:42,Integrability,interface,interfaces,42,"// C+=20 Header Units are compiled module interfaces, but they preserve; // macros that are live (i.e. have a defined value) at the end of the; // compilation. So when writing a header unit, we preserve only the final; // value of each macro (and discard any that are undefined). Header units; // do not have sub-modules (although they might import other header units).; // PCH files, conversely, retain the history of each macro's define/undef; // and of leaf macros in sub modules.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:111,Availability,error,errors,111,// Check that the FileEntry is not null because it was not resolved and; // we create a PCH even with compiler errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:102,Performance,load,loading,102,"// FIXME: This can easily happen, if we have a reference to a submodule that; // did not result in us loading a module file for that submodule. For; // instance, a cross-top-level-module 'conflict' declaration will hit this.; // assert((ID || !Mod) &&; // ""asked for module ID for non-local, non-imported module"");",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:229,Testability,assert,assert,229,"// FIXME: This can easily happen, if we have a reference to a submodule that; // did not result in us loading a module file for that submodule. For; // instance, a cross-top-level-module 'conflict' declaration will hit this.; // assert((ID || !Mod) &&; // ""asked for module ID for non-local, non-imported module"");",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:3,Modifiability,Config,ConfigMacrosExh,3,// ConfigMacrosExh...,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:3,Integrability,Message,Message,3,// Message,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:12,Deployability,configurat,configuration,12,// Emit the configuration macros.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:12,Modifiability,config,configuration,12,// Emit the configuration macros.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:3,Performance,Queue,Queue,3,// Queue up the submodules of this module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:3,Deployability,Update,Update,3,// Update the placeholder.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:308,Availability,error,errors,308,"// Emit CurDiagStateLoc. Do it last in order to match source order.; //; // This also protects against a hypothetical corner case with simulating; // -Werror settings for implicit modules in the ASTReader, where reading; // CurDiagState out of context could change whether warning pragmas are; // treated as errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:34,Energy Efficiency,reduce,reduce,34,"// Don't write comments to BMI to reduce the size of BMI.; // If language services (e.g., clangd) want such abilities,; // we can offer a special option then.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:30,Security,hash,hash,30,// Trait used for the on-disk hash table used in the method pool.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:162,Security,hash,hash,162,"// namespace; /// Write ObjC data: selectors and the method pool.; ///; /// The method pool contains both instance and factory methods, stored; /// in an on-disk hash table indexed by the selector. The hash table also; /// contains an empty entry for every other selector known to Sema.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:202,Security,hash,hash,202,"// namespace; /// Write ObjC data: selectors and the method pool.; ///; /// The method pool contains both instance and factory methods, stored; /// in an on-disk hash table indexed by the selector. The hash table also; /// contains an empty entry for every other selector known to Sema.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:22,Security,hash,hash,22,// Create the on-disk hash table representation. We walk through every; // selector we've seen and look it up in the method pool.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:22,Security,hash,hash,22,// Create the on-disk hash table in a buffer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:51,Integrability,depend,dependent,51,"// Note: this writes out all references even for a dependent AST. But it is; // very tricky to fix, and given that @selector shouldn't really appear in; // headers, probably not worth it. It's not a correctness issue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:38,Integrability,inject,injected-class-names,38,"// Exception: in very rare cases (for injected-class-names), not all; // redeclarations are in the same semantic context. Skip ones in a; // different context. They don't go in this lookup table at all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:38,Security,inject,injected-class-names,38,"// Exception: in very rare cases (for injected-class-names), not all; // redeclarations are in the same semantic context. Skip ones in a; // different context. They don't go in this lookup table at all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:124,Security,hash,hash,124,"/// Determines whether this is an ""interesting"" identifier that needs a; /// full IdentifierInfo structure written into the hash table. Notably, this; /// doesn't check whether the name has macros defined; use PublicMacroIterator; /// to check that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:128,Security,hash,hash,128,"// Look for any identifiers that were named while processing the; // headers, but are otherwise not needed. We add these to the hash; // table to enable checking of the predefines buffer in the case; // where the user adds new macro definitions when building the AST; // file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:22,Security,hash,hash,22,// Create the on-disk hash table representation. We only store offsets; // for identifiers that appear here for the first time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:98,Performance,load,loaded,98,// Write out identifiers if either the ID is local or the identifier has; // changed since it was loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:22,Security,hash,hash,22,// Create the on-disk hash table in a buffer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:30,Security,hash,hash,30,// Trait used for the on-disk hash table used in the method pool.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:55,Testability,log,logically,55,"// FIXME: We need to build the lookups table, which is logically const.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:22,Security,hash,hash,22,// Create the on-disk hash table representation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:164,Performance,perform,performing,164,"// If there are no local declarations in our lookup result, we; // don't need to write an entry for the name at all. If we can't; // write out a lookup set without performing more deserialization,; // just skip this entry.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:93,Availability,avail,available,93,"// We also skip empty results. If any of the results could be external and; // the currently available results are empty, then all of the results are; // external and we skip it above. So the only way we get here with an empty; // results is when no results could have been external *and* we have; // external results.; //; // FIXME: While we might want to start emitting on-disk entries for negative; // lookups into a decl context as an optimization, today we *have* to skip; // them because there are names with empty lookup results in decl contexts; // which we can't emit in any stable ordering: we lookup constructors and; // conversion functions in the enclosing namespace scope creating empty; // results for them. This in almost certainly a bug in Clang's name lookup,; // but that is likely to be hard or impossible to fix and so we tolerate it; // here by omitting lookups with empty results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:843,Availability,toler,tolerate,843,"// We also skip empty results. If any of the results could be external and; // the currently available results are empty, then all of the results are; // external and we skip it above. So the only way we get here with an empty; // results is when no results could have been external *and* we have; // external results.; //; // FIXME: While we might want to start emitting on-disk entries for negative; // lookups into a decl context as an optimization, today we *have* to skip; // them because there are names with empty lookup results in decl contexts; // which we can't emit in any stable ordering: we lookup constructors and; // conversion functions in the enclosing namespace scope creating empty; // results for them. This in almost certainly a bug in Clang's name lookup,; // but that is likely to be hard or impossible to fix and so we tolerate it; // here by omitting lookups with empty results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:439,Performance,optimiz,optimization,439,"// We also skip empty results. If any of the results could be external and; // the currently available results are empty, then all of the results are; // external and we skip it above. So the only way we get here with an empty; // results is when no results could have been external *and* we have; // external results.; //; // FIXME: While we might want to start emitting on-disk entries for negative; // lookups into a decl context as an optimization, today we *have* to skip; // them because there are names with empty lookup results in decl contexts; // which we can't emit in any stable ordering: we lookup constructors and; // conversion functions in the enclosing namespace scope creating empty; // results for them. This in almost certainly a bug in Clang's name lookup,; // but that is likely to be hard or impossible to fix and so we tolerate it; // here by omitting lookups with empty results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:264,Performance,optimiz,optimization,264,"// We need to establish an ordering of constructor and conversion function; // names, and they don't have an intrinsic ordering.; // First we try the easy case by forming the current context's constructor; // name and adding that name first. This is a very useful optimization to; // avoid walking the lexical declarations in many cases, and it also; // handles the only case where a constructor name can come from some other; // lexical context -- when that name is an implicit constructor merged from; // another declaration in the redecl chain. Any non-implicit constructor or; // conversion function which doesn't occur in all the lexical contexts; // would be an ODR violation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:284,Safety,avoid,avoid,284,"// We need to establish an ordering of constructor and conversion function; // names, and they don't have an intrinsic ordering.; // First we try the easy case by forming the current context's constructor; // name and adding that name first. This is a very useful optimization to; // avoid walking the lexical declarations in many cases, and it also; // handles the only case where a constructor name can come from some other; // lexical context -- when that name is an implicit constructor merged from; // another declaration in the redecl chain. Any non-implicit constructor or; // conversion function which doesn't occur in all the lexical contexts; // would be an ODR violation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:253,Performance,load,loaded,253,// Next we need to do a lookup with each name into this decl context to fully; // populate any results from external sources. We don't actually use the; // results of these lookups because we only want to use the results after all; // results have been loaded and the pointers into them will be stable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:60,Security,hash,hash,60,"// Now we need to insert the results for each name into the hash table. For; // constructor names and conversion function names, we actually need to merge; // all of the results for them into one list of results each and insert; // those.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:22,Security,hash,hash,22,// Create the on-disk hash table. Also emit the existing imported and; // merged table if there is one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:98,Deployability,update,update,98,"// If we imported a key declaration of this namespace, write the visible; // lookup results as an update record for it rather than including them; // on this declaration. We will only look at key declarations on reload.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:32,Deployability,update,update,32,// Note that we need to emit an update record for the primary context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:103,Performance,cache,cached,103,// We have to work around a name lookup bug here where negative lookup; // results for these names get cached in namespace lookup tables (these; // names should never be looked up in a namespace).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:21,Performance,perform,perform,21,"// If not in C++, we perform name lookup for the translation unit via the; // IdentifierInfo chains, don't bother to build a visible-declarations table.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:22,Security,hash,hash,22,// Create the on-disk hash table in a buffer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:166,Integrability,depend,dependent,166,"/// Write an UPDATE_VISIBLE block for the given context.; ///; /// UPDATE_VISIBLE blocks contain the declarations that are added to an existing; /// DeclContext in a dependent AST file. As such, they only exist for the TU; /// (in C++), for namespaces, and for classes with forward-declared unscoped; /// enumeration members (in C++11).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:22,Security,hash,hash,22,// Create the on-disk hash table in a buffer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:82,Deployability,update,update,82,"// If we're updating a namespace, select a key declaration as the key for the; // update record; those are the only ones that will be checked on reload.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate space for the size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:3,Deployability,Update,Update,3,// Update the size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:15,Integrability,interface,interface,15,// Record this interface -> category map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:78,Performance,perform,performing,78,"// Sort the categories map by the definition ID, since the reader will be; // performing binary searches on this information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:37,Performance,optimiz,optimize,37,/// Write the state of 'pragma clang optimize' at the end of the module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:107,Integrability,Rout,Routines,107,//===----------------------------------------------------------------------===//; // General Serialization Routines; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:52,Availability,avail,available,52,// Don't record offsets for selectors that are also available in a different; // file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:30,Deployability,update,update,30,// Construct MemoryBuffer and update buffer manager.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:56,Modifiability,extend,extend,56,"// If the previous file was non-affecting as well, just extend its entry; // with our information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:97,Integrability,depend,depends,97,"// This needs to be done very early, since everything that writes; // SourceLocations or FileIDs depends on it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:20,Deployability,update,update,20,// Create a lexical update block containing all of the declarations in the; // translation unit that do not come from other AST files.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:17,Deployability,update,updates,17,// And a visible updates block for the translation unit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:56,Deployability,update,update,56,"// If we have any extern ""C"" names, write out a visible update for them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:88,Deployability,update,update,88,"// If the translation unit has an anonymous namespace, and we don't already; // have an update block for it, write it as an update block.; // FIXME: Why do we not do this if there's already an update block?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:124,Deployability,update,update,124,"// If the translation unit has an anonymous namespace, and we don't already; // have an update block for it, write it as an update block.; // FIXME: Why do we not do this if there's already an update block?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:193,Deployability,update,update,193,"// If the translation unit has an anonymous namespace, and we don't already; // have an update block for it, write it as an update block.; // FIXME: Why do we not do this if there's already an update block?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:7,Deployability,update,update,7,"// Add update records for all mangling numbers and static local numbers.; // These aren't really update records, but this is a convenient way of; // tagging this rare extra data onto the declarations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:97,Deployability,update,update,97,"// Add update records for all mangling numbers and static local numbers.; // These aren't really update records, but this is a convenient way of; // tagging this rare extra data onto the declarations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:61,Performance,load,loaded,61,"// Make sure visible decls, added to DeclContexts previously loaded from; // an AST file, are registered for serialization. Likewise for template; // specializations added to imported templates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:304,Deployability,update,updateOutOfDateSelector,304,"// For method pool in the module, if it contains an entry for a selector,; // the entry should be complete, containing everything introduced by that; // module and all modules it imports. It's possible that the entry is out of; // date, so we need to pull in the new content here.; // It's possible that updateOutOfDateSelector can update SelectorIDs. To be; // safe, we copy all selectors out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:332,Deployability,update,update,332,"// For method pool in the module, if it contains an entry for a selector,; // the entry should be complete, containing everything introduced by that; // module and all modules it imports. It's possible that the entry is out of; // date, so we need to pull in the new content here.; // It's possible that updateOutOfDateSelector can update SelectorIDs. To be; // safe, we copy all selectors out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:362,Safety,safe,safe,362,"// For method pool in the module, if it contains an entry for a selector,; // the entry should be complete, containing everything introduced by that; // module and all modules it imports. It's possible that the entry is out of; // date, so we need to pull in the new content here.; // It's possible that updateOutOfDateSelector can update SelectorIDs. To be; // safe, we copy all selectors out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:55,Integrability,depend,dependencies,55,"// Write the mapping information describing our module dependencies and how; // each of those modules were mapped into our own offset/ID space, so that; // the reader can build the appropriate mapping to its own offset/ID space.; // The map consists solely of a blob with the following format:; // *(module-kind:i8; // module-name-len:i16 module-name:len*i8; // source-location-offset:i32; // identifier-id:i32; // preprocessed-entity-id:i32; // macro-definition-id:i32; // submodule-id:i32; // selector-id:i32; // declaration-id:i32; // c++-base-specifiers-id:i32; // type-id:i32); //; // module-kind is the ModuleKind enum value. If it is MK_PrebuiltModule,; // MK_ExplicitModule or MK_ImplicitModule, then the module-name is the; // module name. Otherwise, it is the module file name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:64,Performance,load,load,64,"// Note: if a base ID was uint max, it would not be possible to load; // another module after it or have more than one entity inside it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:90,Deployability,Continuous,ContinuousRangeMaps,90,"// These values should be unique within a chain, since they will be read; // as keys into ContinuousRangeMaps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:53,Deployability,update,update,53,"// Keep writing types, declarations, and declaration update records; // until we've emitted all of them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:46,Modifiability,variab,variables,46,"// Write the undefined internal functions and variables, and inline functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:21,Deployability,update,updates,21,// Write the visible updates to DeclContexts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:8,Usability,simpl,simple,8,// Some simple statistics,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:6,Deployability,update,updated,6,"// An updated body is emitted last, so that the reader doesn't need; // to skip over the lazy body to reach statements for other records.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:27,Deployability,update,updated,27,"// This state is sometimes updated by template instantiation, when we; // switch from the specialization referring to the template declaration; // to it referring to the template definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:18,Deployability,update,update,18,"// Add a trailing update record, if any. These must go last because we; // lazily load their attached statement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:82,Performance,load,load,82,"// Add a trailing update record, if any. These must go last because we; // lazily load their attached statement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:3,Safety,Avoid,Avoid,3,// Avoid storing the same expr twice.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:80,Performance,queue,queue,80,// We haven't seen this type before. Assign it a new ID and put it; // into the queue of types to emit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:52,Integrability,interface,interface,52,// FIXME: Move this out of the main ASTRecordWriter interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:52,Integrability,interface,interface,52,// FIXME: Move this out of the main ASTRecordWriter interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:52,Integrability,interface,interface,52,// FIXME: Move this out of the main ASTRecordWriter interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:11,Performance,perform,perform,11,// We only perform ODR checks for decls not in GMF.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:53,Safety,avoid,avoid,53,// FIXME: Make VBases lazily computed when needed to avoid storing them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:121,Energy Efficiency,schedul,schedule,121,"// Always take the highest-numbered type index. This copes with an interesting; // case for chained AST writing where we schedule writing the type and then,; // later, deserialize the type from another AST. In this case, we want to; // keep the higher-numbered entry so that we can properly write it out to; // the AST file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:54,Modifiability,Rewrite,Rewrite,54,"// A forward reference was mutated into a definition. Rewrite it.; // FIXME: This happens during template instantiation, should we; // have created a new definition decl instead ?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:90,Deployability,update,update,90,"// If we don't already know the exception specification for this redecl; // chain, add an update record for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:84,Deployability,update,update,84,"// Since the actual instantiation is delayed, this really means that we need; // to update the instantiation location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:104,Deployability,update,update,104,"// If there is *any* declaration of the entity that's not from an AST file,; // we can skip writing the update record. We make sure that isUsed() triggers; // completion of the redeclaration chain of the entity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:186,Performance,load,load,186,/// Add to the record the first declaration from each module file that; /// provides a declaration of D. The intent is to provide a sufficient; /// set such that reloading this set will load all current redeclarations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:236,Performance,load,load,236,/// Add to the record the first template specialization from each module; /// file that provides a declaration of D. We store the DeclId and an; /// ODRHash of the template arguments of D which should provide enough; /// information to load D only if the template instantiator needs it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:3,Deployability,Update,Update,3,// Update the size entry we added earlier. We linerized the; // LazySpecializationInfo members and we need to adjust the size as we; // will read them always together.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:208,Deployability,update,update,208,"// If the canonical template is local, we'll write out this specialization; // when we emit it.; // FIXME: We can do the same thing if there is any local declaration of; // the template, to avoid emitting an update record.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:190,Safety,avoid,avoid,190,"// If the canonical template is local, we'll write out this specialization; // when we emit it.; // FIXME: We can do the same thing if there is any local declaration of; // the template, to avoid emitting an update record.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:35,Modifiability,variab,variable-length,35,"// Source locations require array (variable-length) abbreviations. The; // abbreviation infrastructure requires that arrays are encoded last, so; // we handle it here in the case of those classes derived from DeclaratorDecl",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:251,Modifiability,variab,variable,251,"// Similar to FunctionDecls, handle VarDecl's initializer here and write it; // after all other Stmts/Exprs. We will not read the initializer until after; // we have finished recursive deserialization, because it can recursively; // refer back to the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:152,Deployability,update,update,152,"// If this declaration injected a name into a context different from its; // lexical context, and that context is an imported namespace, we need to; // update its visible declarations to include this name.; //; // This happens when we instantiate a class with a friend declaration or a; // function with a local extern declaration, for instance.; //; // FIXME: Can we handle this in AddedVisibleDecl instead?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:23,Integrability,inject,injected,23,"// If this declaration injected a name into a context different from its; // lexical context, and that context is an imported namespace, we need to; // update its visible declarations to include this name.; //; // This happens when we instantiate a class with a friend declaration or a; // function with a local extern declaration, for instance.; //; // FIXME: Can we handle this in AddedVisibleDecl instead?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:23,Security,inject,injected,23,"// If this declaration injected a name into a context different from its; // lexical context, and that context is an imported namespace, we need to; // update its visible declarations to include this name.; //; // This happens when we instantiate a class with a friend declaration or a; // function with a local extern declaration, for instance.; //; // FIXME: Can we handle this in AddedVisibleDecl instead?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:11,Performance,perform,perform,11,// We only perform ODR checks for decls not in GMF.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:11,Performance,perform,perform,11,// We only perform ODR checks for decls not in GMF.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:17,Integrability,protocol,protocols,17,// Write out the protocols that are directly referenced by the @interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:64,Integrability,interface,interface,64,// Write out the protocols that are directly referenced by the @interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:17,Integrability,protocol,protocols,17,// Write out the protocols that are transitively referenced.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:32,Integrability,interface,interface,32,"// When building a C++20 module interface unit or a partition unit, a; // strong definition in the module interface is provided by the; // compilation of that unit, not by its users. (Inline variables are still; // emitted in module users.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:106,Integrability,interface,interface,106,"// When building a C++20 module interface unit or a partition unit, a; // strong definition in the module interface is provided by the; // compilation of that unit, not by its users. (Inline variables are still; // emitted in module users.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:191,Modifiability,variab,variables,191,"// When building a C++20 module interface unit or a partition unit, a; // strong definition in the module interface is provided by the; // compilation of that unit, not by its users. (Inline variables are still; // emitted in module users.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:128,Performance,optimiz,optimize,128,"// If the assumptions about the DECL_PARM_VAR abbrev are true, use it. Here; // we dynamically check for the properties that we optimize for, but don't; // know are true of all PARM_VAR_DECLs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:42,Usability,simpl,simplify,42,// Record the number of bindings first to simplify deserialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:139,Deployability,update,update,139,"// This is a most recent reopening of the anonymous namespace. If its parent; // is in a previous PCH (or is the TU), mark that parent for update, because; // the original namespace always points to the latest re-opening of its; // anonymous namespace.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:63,Safety,avoid,avoid,63,// Store (what we currently believe to be) the key function to avoid; // deserializing every method so we can compute it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:79,Usability,simpl,simplify,79,// Record the number of friend type template parameter lists here; // so as to simplify memory allocation during deserialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:124,Energy Efficiency,allocate,allocate,124,"// For an expanded parameter pack, record the number of expansion types here; // so that it's easier for deserialization to allocate the right amount of; // memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:124,Energy Efficiency,allocate,allocate,124,"// For an expanded parameter pack, record the number of expansion types here; // so that it's easier for deserialization to allocate the right amount of; // memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:67,Security,Access,AccessSpecifier,67,"// Packed DeclBits: ModuleOwnershipKind,; // isUsed, isReferenced, AccessSpecifier,; // isImplicit; //; // The following bits should be 0:; // HasStandaloneLexicalDC, HasAttrs,; // TopLevelDeclInObjCContainer,; // isInvalidDecl",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:119,Modifiability,variab,variable,119,"// ODRHash; // This Array slurps the rest of the record. Fortunately we want to encode; // (nearly) all the remaining (variable number of) fields in the same way.; //; // This is:; // NumParams and Params[] from FunctionDecl, and; // NumOverriddenMethods, OverriddenMethods[] from CXXMethodDecl.; //; // Add an AbbrevOp for 'size then elements' and use it here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:67,Security,Access,AccessSpecifier,67,"// Packed DeclBits: ModuleOwnershipKind,; // isUsed, isReferenced, AccessSpecifier,; //; // The following bits should be 0:; // isImplicit, HasStandaloneLexicalDC, HasAttrs,; // TopLevelDeclInObjCContainer,; // isInvalidDecl",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:144,Security,Access,AccessSpecifier,144,"// Packed DeclBits: HasStandaloneLexicalDC,; // isInvalidDecl, HasAttrs, isImplicit, isUsed,; // isReferenced, TopLevelDeclInObjCContainer,; // AccessSpecifier, ModuleOwnershipKind",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:67,Security,Access,AccessSpecifier,67,"// Packed DeclBits: ModuleOwnershipKind,; // isUsed, isReferenced, AccessSpecifier,; //; // The following bits should be 0:; // isImplicit, HasStandaloneLexicalDC, HasAttrs,; // TopLevelDeclInObjCContainer,; // isInvalidDecl",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:67,Security,Access,AccessSpecifier,67,"// Packed DeclBits: ModuleOwnershipKind,; // isUsed, isReferenced, AccessSpecifier,; //; // The following bits should be 0:; // isImplicit, HasStandaloneLexicalDC, HasAttrs,; // TopLevelDeclInObjCContainer,; // isInvalidDecl",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:28,Modifiability,Flexible,FlexibleArrayMember,28,"// Packed Record Decl Bits: FlexibleArrayMember,; // AnonymousStructUnion, hasObjectMember, hasVolatileMember,; // isNonTrivialToPrimitiveDefaultInitialize,; // isNonTrivialToPrimitiveCopy, isNonTrivialToPrimitiveDestroy,; // hasNonTrivialToPrimitiveDefaultInitializeCUnion,; // hasNonTrivialToPrimitiveDestructCUnion,; // hasNonTrivialToPrimitiveCopyCUnion, isParamDestroyedInCallee,; // getArgPassingRestrictions; // ODRHash",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:67,Security,Access,AccessSpecifier,67,"// Packed DeclBits: ModuleOwnershipKind, isUsed,; // isReferenced, AccessSpecifier,; // HasStandaloneLexicalDC, HasAttrs, isImplicit,; // TopLevelDeclInObjCContainer,; // isInvalidDecl,",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:67,Security,Access,AccessSpecifier,67,"// Packed DeclBits: ModuleOwnershipKind,; // isReferenced, isUsed, AccessSpecifier. Other; // higher bits should be 0: isImplicit,; // HasStandaloneLexicalDC, HasAttrs,; // TopLevelDeclInObjCContainer, isInvalidDecl",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:144,Security,Access,AccessSpecifier,144,"// Packed DeclBits: HasStandaloneLexicalDC,; // isInvalidDecl, HasAttrs, isImplicit, isUsed,; // isReferenced, TopLevelDeclInObjCContainer,; // AccessSpecifier, ModuleOwnershipKind",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:67,Security,Access,AccessSpecifier,67,"// Packed DeclBits: ModuleOwnershipKind,; // isReferenced, isUsed, AccessSpecifier. Other; // higher bits should be 0: isImplicit,; // HasStandaloneLexicalDC, HasAttrs,; // TopLevelDeclInObjCContainer, isInvalidDecl",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:144,Security,Access,AccessSpecifier,144,"// Packed DeclBits: HasStandaloneLexicalDC,; // isInvalidDecl, HasAttrs, isImplicit, isUsed,; // isReferenced, TopLevelDeclInObjCContainer,; // AccessSpecifier, ModuleOwnershipKind",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:34,Integrability,Depend,DependenceKind,34,"// Stmt; // Expr; // PackingBits: DependenceKind, ValueKind. ObjectKind should be 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:20,Integrability,Depend,DependenceKind,20,"//Stmt; // Expr; // DependenceKind, ValueKind, ObjectKind",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:20,Integrability,Depend,DependenceKind,20,"//Stmt; // Expr; // DependenceKind, ValueKind, ObjectKind",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:35,Integrability,Depend,DependenceKind,35,"// Stmt; // Expr; // Packing Bits: DependenceKind, ValueKind, ObjectKind,",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:35,Integrability,Depend,DependenceKind,35,// Stmt; // Expr; // Packing Bits: DependenceKind. ValueKind and ObjectKind should; // be 0 in this case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:35,Integrability,Depend,DependenceKind,35,// Stmt; // Expr; // Packing Bits: DependenceKind. ValueKind and ObjectKind should; // be 0 in this case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:35,Integrability,Depend,DependenceKind,35,"// Stmt; // Expr; // Packing Bits: DependenceKind, ValueKind, ObjectKind,",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:35,Integrability,Depend,DependenceKind,35,"// Stmt; // Expr; // Packing Bits: DependenceKind, ValueKind, ObjectKind,",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:35,Integrability,Depend,DependenceKind,35,"// Stmt; // Expr; // Packing Bits: DependenceKind, ValueKind, ObjectKind,",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:32,Integrability,interface,interface,32,"// When building a C++20 module interface unit or a partition unit, a; // strong definition in the module interface is provided by the; // compilation of that unit, not by its users. (Inline functions are still; // emitted in module users.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:106,Integrability,interface,interface,106,"// When building a C++20 module interface unit or a partition unit, a; // strong definition in the module interface is provided by the; // compilation of that unit, not by its users. (Inline functions are still; // emitted in module users.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:120,Availability,avail,available,120,"// Under -fmodules-codegen, codegen is performed for all non-internal,; // non-always_inline functions, unless they are available elsewhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:39,Performance,perform,performed,39,"// Under -fmodules-codegen, codegen is performed for all non-internal,; // non-always_inline functions, unless they are available elsewhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterStmt.cpp:29,Security,access,access,29,"// Write this first for easy access when deserializing, as they affect the; // size of the UnaryOperator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterStmt.cpp:30,Security,access,access,30,"// Write these first for easy access when deserializing, as they affect the; // size of the MemberExpr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterStmt.cpp:29,Security,access,access,29,"// Write this first for easy access when deserializing, as they affect the; // size of the UnaryOperator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterStmt.cpp:13,Testability,test,test,13,// FIXME: no test coverage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterStmt.cpp:13,Testability,test,test,13,// FIXME: no test coverage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterStmt.cpp:13,Testability,test,test,13,// FIXME: no test coverage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterStmt.cpp:59,Deployability,update,update,59,// Don't emit anything here (or if you do you will have to update; // the corresponding deserialization function).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterStmt.cpp:65,Performance,queue,queue,65,/// Flush all of the statements that have been added to the; /// queue via AddStmt().,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterStmt.cpp:78,Testability,assert,assert,78,"// We expect to be the only consumer of the two temporary statement maps,; // assert that they are empty.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterStmt.cpp:125,Performance,load,loading,125,"// For a nested statement, write out the substatements in reverse order (so; // that a simple stack machine can be used when loading), and don't emit a; // STMT_STOP after each one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterStmt.cpp:87,Usability,simpl,simple,87,"// For a nested statement, write out the substatements in reverse order (so; // that a simple stack machine can be used when loading), and don't emit a; // STMT_STOP after each one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ASTWriterStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GeneratePCH.cpp:42,Availability,failure,failures,42,// Don't create a PCH if there were fatal failures during module loading.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/GeneratePCH.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GeneratePCH.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GeneratePCH.cpp:65,Performance,load,loading,65,// Don't create a PCH if there were fatal failures during module loading.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/GeneratePCH.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GeneratePCH.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GeneratePCH.cpp:3,Availability,Error,Errors,3,// Errors that do not prevent the PCH from being written should not cause the; // overall compilation to fail either.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/GeneratePCH.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GeneratePCH.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp:52,Integrability,depend,dependencies,52,"/// Describes a module, including its file name and dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp:61,Security,hash,hash,61,/// Trait used to read the identifier index from the on-disk hash; /// table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp:3,Integrability,Depend,Dependencies,3,// Dependencies,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp:16,Security,hash,hash,16,// Remove the -<hash of ModuleMapPath>,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp:3,Performance,Load,Load,3,"// Load the index file, if it's there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp:10,Integrability,depend,dependencies,10,// Record dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp:44,Integrability,depend,depends,44,/// The set of modules on which this module depends. Each entry is; /// a module ID.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp:4,Performance,Load,Load,4,/// Load the contents of the given module file into the builder.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp:69,Availability,error,error,69,"/// Write the index to the given bitstream.; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp:17,Integrability,depend,dependencies,17,// Handle module dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp:3,Performance,Load,Load,3,// Load each of the imported PCH files.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp:3,Performance,Load,Load,3,// Load stored size/modification time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp:91,Security,validat,validate,91,// Skip the stored signature.; // FIXME: we could read the signature out of the import and validate it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp:114,Performance,cache,cached,114,// Skip the module name (currently this is only used for prebuilt; // modules while here we are only dealing with cached).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp:2,Performance,Cache,CacheFailure,2,/*CacheFailure=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp:77,Performance,load,loading,77,// Save the information in ImportedModuleFileInfo so we can verify after; // loading all pcms.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp:14,Integrability,depend,dependency,14,// Record the dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp:62,Security,hash,hash,62,/// Trait used to generate the identifier index as an on-disk hash; /// table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp:3,Integrability,Depend,Dependencies,3,// Dependencies,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp:16,Security,hash,hash,16,// Populate the hash table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp:22,Security,hash,hash,22,// Create the on-disk hash table in a buffer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp:3,Performance,Load,Load,3,// Load each of the module files.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp:3,Performance,Load,Load,3,// Load this module file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/InMemoryModuleCache.cpp:33,Performance,Cache,Cache,33,"//===- InMemoryModuleCache.cpp - Cache for loaded memory buffers ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/InMemoryModuleCache.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/InMemoryModuleCache.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/InMemoryModuleCache.cpp:43,Performance,load,loaded,43,"//===- InMemoryModuleCache.cpp - Cache for loaded memory buffers ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/InMemoryModuleCache.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/InMemoryModuleCache.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleFile.cpp:469,Performance,load,loaded,469,"//===- ModuleFile.cpp - Module description --------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the ModuleFile class, which describes a module that; // has been loaded from an AST file.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ModuleFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp:449,Performance,load,loaded,449,"//===- ModuleManager.cpp - Module Manager ---------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the ModuleManager class, which manages a set of loaded; // modules for the ASTReader.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp:2,Performance,Cache,CacheFailure,2,/*CacheFailure=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp:2,Performance,Cache,CacheFailure,2,/*CacheFailure=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp:62,Performance,cache,cache,62,"// If we're not expecting to pull this file out of the module cache, it; // might have a different mtime due to being moved across filesystems in; // a distributed build. The size must still match, though. (As must the; // contents, but we can't check that.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp:77,Performance,load,loaded,77,"// The ModuleManager's use of FileEntry nodes as the keys for its map of; // loaded modules is less than ideal. Uniqueness for FileEntry nodes is; // maintained by FileManager, which in turn uses inode numbers on hosts; // that support that. When coupled with the module cache's proclivity for; // turning over and deleting stale PCMs, this means entries for different; // module files can wind up reusing the same underlying inode. When this; // happens, subsequent accesses to the Modules map will disagree on the; // ModuleFile associated with a given file. In general, it is not sufficient; // to resolve this conundrum with a type like FileEntryRef that stores the; // name of the FileEntry node on first access because of path canonicalization; // issues. However, the paths constructed for implicit module builds are; // fully under Clang's control. We *can*, therefore, rely on their structure; // being consistent across operating systems and across subsequent accesses; // to the Modules map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp:271,Performance,cache,cache,271,"// The ModuleManager's use of FileEntry nodes as the keys for its map of; // loaded modules is less than ideal. Uniqueness for FileEntry nodes is; // maintained by FileManager, which in turn uses inode numbers on hosts; // that support that. When coupled with the module cache's proclivity for; // turning over and deleting stale PCMs, this means entries for different; // module files can wind up reusing the same underlying inode. When this; // happens, subsequent accesses to the Modules map will disagree on the; // ModuleFile associated with a given file. In general, it is not sufficient; // to resolve this conundrum with a type like FileEntryRef that stores the; // name of the FileEntry node on first access because of path canonicalization; // issues. However, the paths constructed for implicit module builds are; // fully under Clang's control. We *can*, therefore, rely on their structure; // being consistent across operating systems and across subsequent accesses; // to the Modules map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp:467,Security,access,accesses,467,"// The ModuleManager's use of FileEntry nodes as the keys for its map of; // loaded modules is less than ideal. Uniqueness for FileEntry nodes is; // maintained by FileManager, which in turn uses inode numbers on hosts; // that support that. When coupled with the module cache's proclivity for; // turning over and deleting stale PCMs, this means entries for different; // module files can wind up reusing the same underlying inode. When this; // happens, subsequent accesses to the Modules map will disagree on the; // ModuleFile associated with a given file. In general, it is not sufficient; // to resolve this conundrum with a type like FileEntryRef that stores the; // name of the FileEntry node on first access because of path canonicalization; // issues. However, the paths constructed for implicit module builds are; // fully under Clang's control. We *can*, therefore, rely on their structure; // being consistent across operating systems and across subsequent accesses; // to the Modules map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp:710,Security,access,access,710,"// The ModuleManager's use of FileEntry nodes as the keys for its map of; // loaded modules is less than ideal. Uniqueness for FileEntry nodes is; // maintained by FileManager, which in turn uses inode numbers on hosts; // that support that. When coupled with the module cache's proclivity for; // turning over and deleting stale PCMs, this means entries for different; // module files can wind up reusing the same underlying inode. When this; // happens, subsequent accesses to the Modules map will disagree on the; // ModuleFile associated with a given file. In general, it is not sufficient; // to resolve this conundrum with a type like FileEntryRef that stores the; // name of the FileEntry node on first access because of path canonicalization; // issues. However, the paths constructed for implicit module builds are; // fully under Clang's control. We *can*, therefore, rely on their structure; // being consistent across operating systems and across subsequent accesses; // to the Modules map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp:970,Security,access,accesses,970,"// The ModuleManager's use of FileEntry nodes as the keys for its map of; // loaded modules is less than ideal. Uniqueness for FileEntry nodes is; // maintained by FileManager, which in turn uses inode numbers on hosts; // that support that. When coupled with the module cache's proclivity for; // turning over and deleting stale PCMs, this means entries for different; // module files can wind up reusing the same underlying inode. When this; // happens, subsequent accesses to the Modules map will disagree on the; // ModuleFile associated with a given file. In general, it is not sufficient; // to resolve this conundrum with a type like FileEntryRef that stores the; // name of the FileEntry node on first access because of path canonicalization; // issues. However, the paths constructed for implicit module builds are; // fully under Clang's control. We *can*, therefore, rely on their structure; // being consistent across operating systems and across subsequent accesses; // to the Modules map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp:28,Performance,load,loaded,28,"// Check whether we already loaded this module, before",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate a new module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp:5,Performance,cache,cached,5,// A cached stat value would be fine as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp:3,Performance,Load,Load,3,// Load the contents of the module,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp:13,Performance,cache,cached,13,"// Since the cached buffer is reused, it is safe to close the file; // descriptor that was opened while stat()ing the PCM in; // lookupModuleFile() above, it won't be needed any longer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp:44,Safety,safe,safe,44,"// Since the cached buffer is reused, it is safe to close the file; // descriptor that was opened while stat()ing the PCM in; // lookupModuleFile() above, it won't be needed any longer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp:59,Safety,Avoid,Avoid,59,// Read the signature eagerly now so that we can check it. Avoid calling; // ReadSignature unless there's something to check though.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp:14,Usability,clear,clear,14,// Explicitly clear VisitOrder since we might not notice it is stale.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp:27,Performance,cache,cached,27,"// Fast path: if we have a cached state, use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate and return a new state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp:77,Performance,load,loaded,77,// Notify the global module index about all of the modules we've already; // loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp:128,Performance,queue,queue,128,"// Record the number of incoming edges for each module. When we; // encounter a module with no incoming edges, push it into the queue; // to seed the queue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp:150,Performance,queue,queue,150,"// Record the number of incoming edges for each module. When we; // encounter a module with no incoming edges, push it into the queue; // to seed the queue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp:84,Integrability,depend,dependencies,84,"// Traverse the graph, making sure to visit a module before visiting any; // of its dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp:35,Integrability,depend,depends,35,"// For any module that this module depends on, push it on the; // stack (if it hasn't already been marked as visited).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp:76,Integrability,depend,depend,76,"// Remove our current module as an impediment to visiting the; // module we depend on. If we were the last unvisited module; // that depends on this particular module, push it into the; // queue to be visited.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp:133,Integrability,depend,depends,133,"// Remove our current module as an impediment to visiting the; // module we depend on. If we were the last unvisited module; // that depends on this particular module, push it into the; // queue to be visited.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp:189,Performance,queue,queue,189,"// Remove our current module as an impediment to visiting the; // module we depend on. If we were the last unvisited module; // that depends on this particular module, push it into the; // queue to be visited.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp:95,Integrability,depend,depends,95,"// The visitor has requested that cut off visitation of any; // module that the current module depends on. To indicate this; // behavior, we mark all of the reachable modules as having been visited.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp:35,Integrability,depend,depends,35,"// For any module that this module depends on, push it on the; // stack (if it hasn't already been marked as visited).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp:2,Performance,Cache,CacheFailure,2,/*CacheFailure=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/MultiOnDiskHashTable.h:593,Performance,perform,performance,593,"//===- MultiOnDiskHashTable.h - Merged set of hash tables -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides a hash table data structure suitable for incremental and; // distributed storage across a set of files.; //; // Multiple hash tables from different files are implicitly merged to improve; // performance, and on reload the merged table will override those from other; // files.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/MultiOnDiskHashTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/MultiOnDiskHashTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/MultiOnDiskHashTable.h:46,Security,hash,hash,46,"//===- MultiOnDiskHashTable.h - Merged set of hash tables -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides a hash table data structure suitable for incremental and; // distributed storage across a set of files.; //; // Multiple hash tables from different files are implicitly merged to improve; // performance, and on reload the merged table will override those from other; // files.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/MultiOnDiskHashTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/MultiOnDiskHashTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/MultiOnDiskHashTable.h:404,Security,hash,hash,404,"//===- MultiOnDiskHashTable.h - Merged set of hash tables -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides a hash table data structure suitable for incremental and; // distributed storage across a set of files.; //; // Multiple hash tables from different files are implicitly merged to improve; // performance, and on reload the merged table will override those from other; // files.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/MultiOnDiskHashTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/MultiOnDiskHashTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/MultiOnDiskHashTable.h:523,Security,hash,hash,523,"//===- MultiOnDiskHashTable.h - Merged set of hash tables -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides a hash table data structure suitable for incremental and; // distributed storage across a set of files.; //; // Multiple hash tables from different files are implicitly merged to improve; // performance, and on reload the merged table will override those from other; // files.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/MultiOnDiskHashTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/MultiOnDiskHashTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/MultiOnDiskHashTable.h:66,Performance,perform,performance,66,"/// A collection of on-disk hash tables, merged when relevant for performance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/MultiOnDiskHashTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/MultiOnDiskHashTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/MultiOnDiskHashTable.h:28,Security,hash,hash,28,"/// A collection of on-disk hash tables, merged when relevant for performance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/MultiOnDiskHashTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/MultiOnDiskHashTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/MultiOnDiskHashTable.h:50,Security,hash,hash,50,/// A pointer to an on-disk representation of the hash table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/MultiOnDiskHashTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/MultiOnDiskHashTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/MultiOnDiskHashTable.h:6,Security,hash,hash,6,/// A hash table stored on disk.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/MultiOnDiskHashTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/MultiOnDiskHashTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/MultiOnDiskHashTable.h:26,Performance,load,loaded,26,/// Add the table \p Data loaded from file \p File.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/MultiOnDiskHashTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/MultiOnDiskHashTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/MultiOnDiskHashTable.h:27,Security,hash,hash,27,/// Writer for the on-disk hash table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Serialization/MultiOnDiskHashTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/MultiOnDiskHashTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/AllocationState.h:119,Availability,error,errors,119,/// This function provides an additional visitor that augments the bug report; /// with information relevant to memory errors caused by the misuse of; /// AF_InnerBuffer symbols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/AllocationState.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/AllocationState.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/AnalysisOrderChecker.cpp:566,Modifiability,extend,extend,566,"//===- AnalysisOrderChecker - Print callbacks called ------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker prints callbacks that are called during analysis.; // This is required to ensure that callbacks are fired in order; // and do not duplicate or get lost.; // Feel free to extend this checker with any callback you need to check.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/AnalysisOrderChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/AnalysisOrderChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/AnalyzerStatsChecker.cpp:54,Performance,optimiz,optimization,54,// Only check the coverage in the top level function (optimization).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/AnalyzerStatsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/AnalyzerStatsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundChecker.cpp:494,Security,access,access,494,"//== ArrayBoundChecker.cpp ------------------------------*- C++ -*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines ArrayBoundChecker, which is a path-sensitive check; // which looks for an out-of-bound array element access.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundChecker.cpp:40,Security,access,access,40,// Check for out of bound array element access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundChecker.cpp:24,Security,access,accessed,24,// Get the index of the accessed element.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundChecker.cpp:67,Usability,clear,clear,67,"// FIXME: It would be nice to eventually make this diagnostic more clear,; // e.g., by referencing the original declaration or by saying *why* this; // reference is outside the range.; // Generate a report for this bug.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp:504,Security,access,access,504,"//== ArrayBoundCheckerV2.cpp ------------------------------------*- C++ -*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines ArrayBoundCheckerV2, which is a path-sensitive check; // which looks for an out-of-bound array element access.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp:343,Testability,log,logic,343,"// NOTE: The `ArraySubscriptExpr` and `UnaryOperator` callbacks are `PostStmt`; // instead of `PreStmt` because the current implementation passes the whole; // expression to `CheckerContext::getSVal()` which only works after the; // symbolic evaluation of the expression. (To turn them into `PreStmt`; // callbacks, we'd need to duplicate the logic that evaluates these; // expressions.) The `MemberExpr` callback would work as `PreStmt` but it's; // defined as `PostStmt` for the sake of consistency with the other callbacks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp:61,Safety,safe,safeguard,61,"// FIXME: The following early return was presumably added to safeguard the; // getTypeSizeInChars() call (which doesn't accept an incomplete type), but; // it seems that `ElemType` cannot be incomplete at this point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp:3,Performance,Perform,Perform,3,// Perform Offset += Delta.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp:241,Safety,safe,safe,241,"// TODO: once the constraint manager is smart enough to handle non simplified; // symbolic expressions remove this function. Note that this can not be used in; // the constraint manager as is, since this does not handle overflows. It is; // safe to assume, however, that memory offsets will not overflow.; // NOTE: callers of this function need to be aware of the effects of overflows; // and signed<->unsigned conversions!",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp:67,Usability,simpl,simplified,67,"// TODO: once the constraint manager is smart enough to handle non simplified; // symbolic expressions remove this function. Note that this can not be used in; // the constraint manager as is, since this does not handle overflows. It is; // safe to assume, however, that memory offsets will not overflow.; // NOTE: callers of this function need to be aware of the effects of overflows; // and signed<->unsigned conversions!",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp:78,Usability,simpl,simplified,78,"// The constant should never be 0 here, becasue multiplication by zero; // is simplified by the engine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp:77,Usability,simpl,simplification,77,"// Evaluate the comparison Value < Threshold with the help of the custom; // simplification algorithm defined for this checker. Return a pair of states,; // where the first one corresponds to ""value below threshold"" and the second; // corresponds to ""value at or above threshold"". Returns {nullptr, nullptr} in; // the case when the evaluation fails.; // If the optional argument CheckEquality is true, then use BO_EQ instead of; // the default BO_LT after consistently applying the same simplification steps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp:488,Usability,simpl,simplification,488,"// Evaluate the comparison Value < Threshold with the help of the custom; // simplification algorithm defined for this checker. Return a pair of states,; // where the first one corresponds to ""value below threshold"" and the second; // corresponds to ""value at or above threshold"". Returns {nullptr, nullptr} in; // the case when the evaluation fails.; // If the optional argument CheckEquality is true, then use BO_EQ instead of; // the default BO_LT after consistently applying the same simplification steps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp:19,Energy Efficiency,reduce,reduced,19,// In this case we reduced the bound check to a comparison of the form; // (symbol or value with unsigned type) < (negative number); // which is always false. We are handling these cases separately because; // evalBinOpNN can perform a signed->unsigned conversion that turns the; // negative number into a huge positive value and leads to wildly; // inaccurate conclusions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp:226,Performance,perform,perform,226,// In this case we reduced the bound check to a comparison of the form; // (symbol or value with unsigned type) < (negative number); // which is always false. We are handling these cases separately because; // evalBinOpNN can perform a signed->unsigned conversion that turns the; // negative number into a huge positive value and leads to wildly; // inaccurate conclusions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp:343,Security,access,access,343,"// NOTE: Instead of using ProgramState::assumeInBound(), we are prototyping; // some new logic here that reasons directly about memory region extents.; // Once that logic is more mature, we can bring it back to assumeInBound(); // for all clients to use.; //; // The algorithm we are using here for bounds checking is to see if the; // memory access is within the extent of the base region. Since we; // have some flexibility in defining the base region, we can achieve; // various levels of conservatism in our buffer overflow checking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp:89,Testability,log,logic,89,"// NOTE: Instead of using ProgramState::assumeInBound(), we are prototyping; // some new logic here that reasons directly about memory region extents.; // Once that logic is more mature, we can bring it back to assumeInBound(); // for all clients to use.; //; // The algorithm we are using here for bounds checking is to see if the; // memory access is within the extent of the base region. Since we; // have some flexibility in defining the base region, we can achieve; // various levels of conservatism in our buffer overflow checking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp:165,Testability,log,logic,165,"// NOTE: Instead of using ProgramState::assumeInBound(), we are prototyping; // some new logic here that reasons directly about memory region extents.; // Once that logic is more mature, we can bring it back to assumeInBound(); // for all clients to use.; //; // The algorithm we are using here for bounds checking is to see if the; // memory access is within the extent of the base region. Since we; // have some flexibility in defining the base region, we can achieve; // various levels of conservatism in our buffer overflow checking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp:37,Usability,Simpl,Simple,37,"//== BasicObjCFoundationChecks.cpp - Simple Apple-Foundation checks -*- C++ -*--; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines BasicObjCFoundationChecks, a class that encapsulates; // a set of simple checks to run on Objective-C code using Apple's Foundation; // classes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp:467,Usability,simpl,simple,467,"//== BasicObjCFoundationChecks.cpp - Simple Apple-Foundation checks -*- C++ -*--; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines BasicObjCFoundationChecks, a class that encapsulates; // a set of simple checks to run on Objective-C code using Apple's Foundation; // classes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp:20,Performance,cache,cache,20,// FIXME: Should we cache this at all?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp:35,Availability,error,errors,35,"// NOTE: We cannot throw non-fatal errors from warnIfNilExpr,; // because it's called multiple times from some callers, so it'd cause; // an unwanted state split if two or more non-fatal errors are thrown; // within the same checker callback. For now we don't want to, but; // it'll need to be fixed if we ever want to.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp:187,Availability,error,errors,187,"// NOTE: We cannot throw non-fatal errors from warnIfNilExpr,; // because it's called multiple times from some callers, so it'd cause; // an unwanted state split if two or more non-fatal errors are thrown; // within the same checker callback. For now we don't want to, but; // it'll need to be fixed if we ever want to.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp:39,Availability,error,error,39,// FIXME: In some cases we can emit an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp:91,Modifiability,enhance,enhanced,91,// FIXME: Eventually we should handle arbitrary locations. We can do this; // by having an enhanced memory model that does low-level typing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp:114,Deployability,release,release,114,"//===----------------------------------------------------------------------===//; // Check for sending 'retain', 'release', or 'autorelease' directly to a Class.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp:78,Integrability,message,message,78,"// end anonymous namespace; /// isVariadicMessage - Returns whether the given message is a variadic message,; /// where all arguments must be Objective-C types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp:100,Integrability,message,message,100,"// end anonymous namespace; /// isVariadicMessage - Returns whether the given message is a variadic message,; /// where all arguments must be Objective-C types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp:44,Integrability,interface,interface,44,"// FIXME: Ideally we'd look at the receiver interface here, but that's not; // useful for init, because alloc returns 'id'. In theory, this could lead; // to false positives, for example if there existed a class that had an; // initWithObjects: implementation that does accept non-Objective-C pointer; // types, but the chance of that happening is pretty small compared to the; // gains that this analysis gives.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp:48,Integrability,bridg,bridged,48,"// Ignore CF references, which can be toll-free bridged.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp:21,Availability,error,error,21,// Generate only one error node to use for all bug reports.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BitwiseShiftChecker.cpp:141,Deployability,update,updated,141,/// An implementation detail class which is introduced to split the checker; /// logic into several methods while maintaining a consistently updated state; /// and access to other contextual data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BitwiseShiftChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BitwiseShiftChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BitwiseShiftChecker.cpp:164,Security,access,access,164,/// An implementation detail class which is introduced to split the checker; /// logic into several methods while maintaining a consistently updated state; /// and access to other contextual data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BitwiseShiftChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BitwiseShiftChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BitwiseShiftChecker.cpp:81,Testability,log,logic,81,/// An implementation detail class which is introduced to split the checker; /// logic into several methods while maintaining a consistently updated state; /// and access to other contextual data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BitwiseShiftChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BitwiseShiftChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BitwiseShiftChecker.cpp:21,Deployability,update,update,21,"// No bugs detected, update the state and add a single note tag which; // summarizes the new assumptions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BitwiseShiftChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BitwiseShiftChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BitwiseShiftChecker.cpp:11,Safety,detect,detected,11,"// No bugs detected, update the state and add a single note tag which; // summarizes the new assumptions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BitwiseShiftChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BitwiseShiftChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BitwiseShiftChecker.cpp:233,Availability,failure,failure,233,"/// This method checks a requirement that must be satisfied by the value on the; /// given Side of a bitwise shift operator in well-defined code. If the; /// requirement is incompatible with prior knowledge, this method reports; /// failure by returning false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BitwiseShiftChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BitwiseShiftChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BitwiseShiftChecker.cpp:6,Safety,detect,detected,6,// We detected undefined behavior (the caller will report it).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BitwiseShiftChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BitwiseShiftChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BitwiseShiftChecker.cpp:85,Energy Efficiency,reduce,reduced,85,"// Quote ""For unsigned lhs, the value of LHS << RHS is the value of LHS *; // 2^RHS, reduced modulo maximum value of the return type plus 1.""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BitwiseShiftChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BitwiseShiftChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BlockInCriticalSectionChecker.cpp:717,Performance,perform,performance,717,"//===-- BlockInCriticalSectionChecker.cpp -----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Defines a checker for blocks in critical sections. This checker should find; // the calls to blocking functions (for example: sleep, getc, fgets, read,; // recv etc.) inside a critical section. When sleep(x) is called while a mutex; // is held, other threades cannot lock the same mutex. This might take some; // time, leading to bad performance or even deadlock.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BlockInCriticalSectionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BlockInCriticalSectionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BlockInCriticalSectionChecker.cpp:228,Modifiability,variab,variable,228,"/* In case of checking C code, or when the corresponding headers are not; * included, we might end up query the identifier table every time when this; * function is called instead of early returning it. To avoid this, a bool; * variable (IdentifierInfoInitialized) is used and the function will be run; * only once. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BlockInCriticalSectionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BlockInCriticalSectionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BlockInCriticalSectionChecker.cpp:206,Safety,avoid,avoid,206,"/* In case of checking C code, or when the corresponding headers are not; * included, we might end up query the identifier table every time when this; * function is called instead of early returning it. To avoid this, a bool; * variable (IdentifierInfoInitialized) is used and the function will be run; * only once. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BlockInCriticalSectionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BlockInCriticalSectionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BoolAssignmentChecker.cpp:522,Modifiability,variab,variables,522,"//== BoolAssignmentChecker.cpp - Boolean assignment checker -----*- C++ -*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines BoolAssignmentChecker, a builtin check in ExprEngine that; // performs checks for assignment of non-Boolean values to Boolean variables.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BoolAssignmentChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BoolAssignmentChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BoolAssignmentChecker.cpp:458,Performance,perform,performs,458,"//== BoolAssignmentChecker.cpp - Boolean assignment checker -----*- C++ -*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines BoolAssignmentChecker, a builtin check in ExprEngine that; // performs checks for assignment of non-Boolean values to Boolean variables.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BoolAssignmentChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BoolAssignmentChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BuiltinFunctionChecker.cpp:80,Safety,safe,safe,80,"// If we didn't manage to figure out if the value is constant or not,; // it is safe to assume that it's not constant and unsafe to assume; // that it's constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BuiltinFunctionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BuiltinFunctionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BuiltinFunctionChecker.cpp:122,Safety,unsafe,unsafe,122,"// If we didn't manage to figure out if the value is constant or not,; // it is safe to assume that it's not constant and unsafe to assume; // that it's constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BuiltinFunctionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BuiltinFunctionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp:465,Availability,error,errors,465,"//===--- CallAndMessageChecker.cpp ------------------------------*- C++ -*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines CallAndMessageChecker, a builtin checker that checks for various; // errors of call and objc message expressions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp:489,Integrability,message,message,489,"//===--- CallAndMessageChecker.cpp ------------------------------*- C++ -*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines CallAndMessageChecker, a builtin checker that checks for various; // errors of call and objc message expressions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp:882,Integrability,message,messages,882,"// These correspond with the checker options. Looking at other checkers such; // as MallocChecker and CStringChecker, this is similar as to how they pull; // off having a modeling class, but emitting diagnostics under a smaller; // checker's name that can be safely disabled without disturbing the; // underlaying modeling engine.; // The reason behind having *checker options* rather then actual *checkers*; // here is that CallAndMessage is among the oldest checkers out there, and can; // be responsible for the majority of the reports on any given project. This; // is obviously not ideal, but changing checker name has the consequence of; // changing the issue hashes associated with the reports, and databases; // relying on this (CodeChecker, for instance) would suffer greatly.; // If we ever end up making changes to the issue hash generation algorithm, or; // the warning messages here, we should totally jump on the opportunity to; // convert these to actual checkers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp:259,Safety,safe,safely,259,"// These correspond with the checker options. Looking at other checkers such; // as MallocChecker and CStringChecker, this is similar as to how they pull; // off having a modeling class, but emitting diagnostics under a smaller; // checker's name that can be safely disabled without disturbing the; // underlaying modeling engine.; // The reason behind having *checker options* rather then actual *checkers*; // here is that CallAndMessage is among the oldest checkers out there, and can; // be responsible for the majority of the reports on any given project. This; // is obviously not ideal, but changing checker name has the consequence of; // changing the issue hashes associated with the reports, and databases; // relying on this (CodeChecker, for instance) would suffer greatly.; // If we ever end up making changes to the issue hash generation algorithm, or; // the warning messages here, we should totally jump on the opportunity to; // convert these to actual checkers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp:666,Security,hash,hashes,666,"// These correspond with the checker options. Looking at other checkers such; // as MallocChecker and CStringChecker, this is similar as to how they pull; // off having a modeling class, but emitting diagnostics under a smaller; // checker's name that can be safely disabled without disturbing the; // underlaying modeling engine.; // The reason behind having *checker options* rather then actual *checkers*; // here is that CallAndMessage is among the oldest checkers out there, and can; // be responsible for the majority of the reports on any given project. This; // is obviously not ideal, but changing checker name has the consequence of; // changing the issue hashes associated with the reports, and databases; // relying on this (CodeChecker, for instance) would suffer greatly.; // If we ever end up making changes to the issue hash generation algorithm, or; // the warning messages here, we should totally jump on the opportunity to; // convert these to actual checkers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp:836,Security,hash,hash,836,"// These correspond with the checker options. Looking at other checkers such; // as MallocChecker and CStringChecker, this is similar as to how they pull; // off having a modeling class, but emitting diagnostics under a smaller; // checker's name that can be safely disabled without disturbing the; // underlaying modeling engine.; // The reason behind having *checker options* rather then actual *checkers*; // here is that CallAndMessage is among the oldest checkers out there, and can; // be responsible for the majority of the reports on any given project. This; // is obviously not ideal, but changing checker name has the consequence of; // changing the issue hashes associated with the reports, and databases; // relying on this (CodeChecker, for instance) would suffer greatly.; // If we ever end up making changes to the issue hash generation algorithm, or; // the warning messages here, we should totally jump on the opportunity to; // convert these to actual checkers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp:28,Availability,avail,available,28,"// No parameter declaration available, i.e. variadic function argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp:10,Modifiability,enhance,enhance,10,// FIXME: enhance track back for uninitialized value for arbitrary; // memregions,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp:96,Availability,avail,available,96,"// Don't check for uninitialized field values in arguments if the; // caller has a body that is available and we have the chance to inline it.; // This is a hack, but is a reasonable compromise betweens sometimes warning; // and sometimes not depending on if we decide to inline a function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp:243,Integrability,depend,depending,243,"// Don't check for uninitialized field values in arguments if the; // caller has a body that is available and we have the chance to inline it.; // This is a hack, but is a reasonable compromise betweens sometimes warning; // and sometimes not depending on if we decide to inline a function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp:37,Integrability,message,messages,37,"// FIXME: This won't track ""self"" in messages to super.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp:32,Integrability,message,message,32,// Check the return type of the message expression. A message to nil will; // return different values depending on the return type and the architecture.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp:54,Integrability,message,message,54,// Check the return type of the message expression. A message to nil will; // return different values depending on the return type and the architecture.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp:102,Integrability,depend,depending,102,// Check the return type of the message expression. A message to nil will; // return different values depending on the return type and the architecture.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp:25,Safety,safe,safe,25,// Structure returns are safe since the compiler zeroes them out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp:14,Safety,safe,safe,14,"// Handle the safe cases where the return value is 0 if the; // receiver is nil.; //; // FIXME: For now take the conservative approach that we only; // return null values if we *know* that the receiver is nil.; // This is because we can have surprises like:; //; // ... = [[NSScreens screens] objectAtIndex:0];; //; // What can happen is that [... screens] could return nil, but; // it most likely isn't nil. We should assume the semantics; // of this case unless we have *a lot* more knowledge.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CastSizeChecker.cpp:306,Energy Efficiency,allocate,allocate,306,/// Check if we are casting to a struct with a flexible array at the end.; /// \code; /// struct foo {; /// size_t len;; /// struct bar data[];; /// };; /// \endcode; /// or; /// \code; /// struct foo {; /// size_t len;; /// struct bar data[0];; /// }; /// \endcode; /// In these cases it is also valid to allocate size of struct foo + a multiple; /// of struct bar.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CastSizeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CastSizeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CastSizeChecker.cpp:47,Modifiability,flexible,flexible,47,/// Check if we are casting to a struct with a flexible array at the end.; /// \code; /// struct foo {; /// size_t len;; /// struct bar data[];; /// };; /// \endcode; /// or; /// \code; /// struct foo {; /// size_t len;; /// struct bar data[0];; /// }; /// \endcode; /// In these cases it is also valid to allocate size of struct foo + a multiple; /// of struct bar.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CastSizeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CastSizeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CastSizeChecker.cpp:8,Performance,perform,perform,8,// Only perform the check if 'ToPointeeTy' is a complete type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CastSizeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CastSizeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CastSizeChecker.cpp:172,Modifiability,flexible,flexible,172,"// PR31226: C++ is more complicated than what this checker currently supports.; // There are derived-to-base casts, there are different rules for 0-size; // structures, no flexible arrays, etc.; // FIXME: Disabled on C++ for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CastSizeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CastSizeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CastValueChecker.cpp:90,Testability,log,logic,90,//===----------------------------------------------------------------------===//; // Main logic to evaluate a cast.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CastValueChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CastValueChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CastValueChecker.cpp:90,Testability,log,logic,90,//===----------------------------------------------------------------------===//; // Main logic to evaluate a call.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CastValueChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CastValueChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp:140,Performance,perform,performed,140,"/// Pre-visit the Statement.; ///; /// The method will be called before the analyzer core processes the; /// statement. The notification is performed for every explored CFGElement,; /// which does not include the control flow statements such as IfStmt. The; /// callback can be specialized to be called with any subclass of Stmt.; ///; /// See checkBranchCondition() callback for performing custom processing of; /// the branching statements.; ///; /// check::PreStmt<ReturnStmt>",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp:380,Performance,perform,performing,380,"/// Pre-visit the Statement.; ///; /// The method will be called before the analyzer core processes the; /// statement. The notification is performed for every explored CFGElement,; /// which does not include the control flow statements such as IfStmt. The; /// callback can be specialized to be called with any subclass of Stmt.; ///; /// See checkBranchCondition() callback for performing custom processing of; /// the branching statements.; ///; /// check::PreStmt<ReturnStmt>",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp:140,Performance,perform,performed,140,"/// Post-visit the Statement.; ///; /// The method will be called after the analyzer core processes the; /// statement. The notification is performed for every explored CFGElement,; /// which does not include the control flow statements such as IfStmt. The; /// callback can be specialized to be called with any subclass of Stmt.; ///; /// check::PostStmt<DeclStmt>",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp:30,Integrability,message,message,30,"/// Pre-visit the Objective C message.; ///; /// This will be called before the analyzer core processes the method call.; /// This is called for any action which produces an Objective-C message send,; /// including explicit message syntax and property access.; ///; /// check::PreObjCMessage",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp:186,Integrability,message,message,186,"/// Pre-visit the Objective C message.; ///; /// This will be called before the analyzer core processes the method call.; /// This is called for any action which produces an Objective-C message send,; /// including explicit message syntax and property access.; ///; /// check::PreObjCMessage",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp:224,Integrability,message,message,224,"/// Pre-visit the Objective C message.; ///; /// This will be called before the analyzer core processes the method call.; /// This is called for any action which produces an Objective-C message send,; /// including explicit message syntax and property access.; ///; /// check::PreObjCMessage",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp:252,Security,access,access,252,"/// Pre-visit the Objective C message.; ///; /// This will be called before the analyzer core processes the method call.; /// This is called for any action which produces an Objective-C message send,; /// including explicit message syntax and property access.; ///; /// check::PreObjCMessage",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp:31,Integrability,message,message,31,/// Post-visit the Objective C message.; /// \sa checkPreObjCMessage(); ///; /// check::PostObjCMessage,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp:25,Integrability,message,message,25,"/// Visit an Objective-C message whose receiver is nil.; ///; /// This will be called when the analyzer core processes a method call whose; /// receiver is definitely nil. In this case, check{Pre/Post}ObjCMessage and; /// check{Pre/Post}Call will not be called.; ///; /// check::ObjCMessageNil",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp:336,Testability,test,test,336,"/// Pre-visit an abstract ""call"" event.; ///; /// This is used for checkers that want to check arguments or attributed; /// behavior for functions and methods no matter how they are being invoked.; ///; /// Note that this includes ALL cross-body invocations, so if you want to; /// limit your checks to, say, function calls, you should test for that at the; /// beginning of your callback function.; ///; /// check::PreCall",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp:183,Energy Efficiency,allocate,allocate,183,"/// Post-visit the C++ operator new's allocation call.; ///; /// Execution of C++ operator new consists of the following phases: (1) call; /// default or overridden operator new() to allocate memory (2) cast the; /// return value of operator new() from void pointer type to class pointer; /// type, (3) assuming that the value is non-null, call the object's; /// constructor over this pointer, (4) declare that the value of the; /// new-expression is this pointer. This callback is called between steps; /// (2) and (3). Post-call for the allocator is called after step (1).; /// Pre-statement for the new-expression is called on step (4) when the value; /// of the expression is evaluated.; /// \param NE The C++ new-expression that triggered the allocation.; /// \param Target The allocated region, casted to the class type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp:783,Energy Efficiency,allocate,allocated,783,"/// Post-visit the C++ operator new's allocation call.; ///; /// Execution of C++ operator new consists of the following phases: (1) call; /// default or overridden operator new() to allocate memory (2) cast the; /// return value of operator new() from void pointer type to class pointer; /// type, (3) assuming that the value is non-null, call the object's; /// constructor over this pointer, (4) declare that the value of the; /// new-expression is this pointer. This callback is called between steps; /// (2) and (3). Post-call for the allocator is called after step (1).; /// Pre-statement for the new-expression is called on step (4) when the value; /// of the expression is evaluated.; /// \param NE The C++ new-expression that triggered the allocation.; /// \param Target The allocated region, casted to the class type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp:16,Performance,load,load,16,/// Called on a load from and a store to a location.; ///; /// The method will be called each time a location (pointer) value is; /// accessed.; /// \param Loc The value of the location (pointer).; /// \param IsLoad The flag specifying if the location is a store or a load.; /// \param S The load is performed while processing the statement.; ///; /// check::Location,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp:268,Performance,load,load,268,/// Called on a load from and a store to a location.; ///; /// The method will be called each time a location (pointer) value is; /// accessed.; /// \param Loc The value of the location (pointer).; /// \param IsLoad The flag specifying if the location is a store or a load.; /// \param S The load is performed while processing the statement.; ///; /// check::Location,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp:292,Performance,load,load,292,/// Called on a load from and a store to a location.; ///; /// The method will be called each time a location (pointer) value is; /// accessed.; /// \param Loc The value of the location (pointer).; /// \param IsLoad The flag specifying if the location is a store or a load.; /// \param S The load is performed while processing the statement.; ///; /// check::Location,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp:300,Performance,perform,performed,300,/// Called on a load from and a store to a location.; ///; /// The method will be called each time a location (pointer) value is; /// accessed.; /// \param Loc The value of the location (pointer).; /// \param IsLoad The flag specifying if the location is a store or a load.; /// \param S The load is performed while processing the statement.; ///; /// check::Location,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp:134,Security,access,accessed,134,/// Called on a load from and a store to a location.; ///; /// The method will be called each time a location (pointer) value is; /// accessed.; /// \param Loc The value of the location (pointer).; /// \param IsLoad The flag specifying if the location is a store or a load.; /// \param S The load is performed while processing the statement.; ///; /// check::Location,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp:200,Performance,perform,performed,200,/// Called on binding of a value to a location.; ///; /// \param Loc The value of the location (pointer).; /// \param Val The value which will be stored at the location Loc.; /// \param S The bind is performed while processing the statement S.; ///; /// check::Bind,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp:128,Energy Efficiency,reduce,reduce,128,"/// Called whenever a symbol becomes dead.; ///; /// This callback should be used by the checkers to aggressively clean; /// up/reduce the checker state, which is important for reducing the overall; /// memory usage. Specifically, if a checker keeps symbol specific information; /// in the state, it can and should be dropped after the symbol becomes dead.; /// In addition, reporting a bug as soon as the checker becomes dead leads to; /// more precise diagnostics. (For example, one should report that a malloced; /// variable is not freed right after it goes out of scope.); ///; /// \param SR The SymbolReaper object can be queried to determine which; /// symbols are dead.; ///; /// check::DeadSymbols",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp:520,Modifiability,variab,variable,520,"/// Called whenever a symbol becomes dead.; ///; /// This callback should be used by the checkers to aggressively clean; /// up/reduce the checker state, which is important for reducing the overall; /// memory usage. Specifically, if a checker keeps symbol specific information; /// in the state, it can and should be dropped after the symbol becomes dead.; /// In addition, reporting a bug as soon as the checker becomes dead leads to; /// more precise diagnostics. (For example, one should report that a malloced; /// variable is not freed right after it goes out of scope.); ///; /// \param SR The SymbolReaper object can be queried to determine which; /// symbols are dead.; ///; /// check::DeadSymbols",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp:173,Performance,perform,performed,173,"/// Handles assumptions on symbolic values.; ///; /// This method is called when a symbolic expression is assumed to be true or; /// false. For example, the assumptions are performed when evaluating a; /// condition at a branch. The callback allows checkers track the assumptions; /// performed on the symbols of interest and change the state accordingly.; ///; /// eval::Assume",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp:285,Performance,perform,performed,285,"/// Handles assumptions on symbolic values.; ///; /// This method is called when a symbolic expression is assumed to be true or; /// false. For example, the assumptions are performed when evaluating a; /// condition at a branch. The callback allows checkers track the assumptions; /// performed on the symbols of interest and change the state accordingly.; ///; /// eval::Assume",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp:654,Security,access,accessible,654,"/// Called when the contents of one or more regions change.; ///; /// This can occur in many different ways: an explicit bind, a blanket; /// invalidation of the region contents, or by passing a region to a function; /// call whose behavior the analyzer cannot model perfectly.; ///; /// \param State The current program state.; /// \param Invalidated A set of all symbols potentially touched by the change.; /// \param ExplicitRegions The regions explicitly requested for invalidation.; /// For a function call, this would be the arguments. For a bind, this; /// would be the region being bound to.; /// \param Regions The transitive closure of regions accessible from,; /// \p ExplicitRegions, i.e. all regions that may have been touched; /// by this change. For a simple bind, this list will be the same as; /// \p ExplicitRegions, since a bind does not affect the contents of; /// anything accessible through the base region.; /// \param LCtx LocationContext that is useful for getting various contextual; /// info, like callstack, CFG etc.; /// \param Call The opaque call triggering this invalidation. Will be 0 if the; /// change was not triggered by a call.; ///; /// check::RegionChanges",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp:894,Security,access,accessible,894,"/// Called when the contents of one or more regions change.; ///; /// This can occur in many different ways: an explicit bind, a blanket; /// invalidation of the region contents, or by passing a region to a function; /// call whose behavior the analyzer cannot model perfectly.; ///; /// \param State The current program state.; /// \param Invalidated A set of all symbols potentially touched by the change.; /// \param ExplicitRegions The regions explicitly requested for invalidation.; /// For a function call, this would be the arguments. For a bind, this; /// would be the region being bound to.; /// \param Regions The transitive closure of regions accessible from,; /// \p ExplicitRegions, i.e. all regions that may have been touched; /// by this change. For a simple bind, this list will be the same as; /// \p ExplicitRegions, since a bind does not affect the contents of; /// anything accessible through the base region.; /// \param LCtx LocationContext that is useful for getting various contextual; /// info, like callstack, CFG etc.; /// \param Call The opaque call triggering this invalidation. Will be 0 if the; /// change was not triggered by a call.; ///; /// check::RegionChanges",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp:767,Usability,simpl,simple,767,"/// Called when the contents of one or more regions change.; ///; /// This can occur in many different ways: an explicit bind, a blanket; /// invalidation of the region contents, or by passing a region to a function; /// call whose behavior the analyzer cannot model perfectly.; ///; /// \param State The current program state.; /// \param Invalidated A set of all symbols potentially touched by the change.; /// \param ExplicitRegions The regions explicitly requested for invalidation.; /// For a function call, this would be the arguments. For a bind, this; /// would be the region being bound to.; /// \param Regions The transitive closure of regions accessible from,; /// \p ExplicitRegions, i.e. all regions that may have been touched; /// by this change. For a simple bind, this list will be the same as; /// \p ExplicitRegions, since a bind does not affect the contents of; /// anything accessible through the base region.; /// \param LCtx LocationContext that is useful for getting various contextual; /// info, like callstack, CFG etc.; /// \param Call The opaque call triggering this invalidation. Will be 0 if the; /// change was not triggered by a call.; ///; /// check::RegionChanges",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp:69,Availability,checkPoint,checkPointerEscape,69,/// Called when const pointers escape.; ///; /// Note: in most cases checkPointerEscape callback is sufficient.; /// \sa checkPointerEscape,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp:121,Availability,checkPoint,checkPointerEscape,121,/// Called when const pointers escape.; ///; /// Note: in most cases checkPointerEscape callback is sufficient.; /// \sa checkPointerEscape,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:572,Deployability,release,releases,572,"//==- CheckObjCDealloc.cpp - Check ObjC -dealloc implementation --*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker analyzes Objective-C -dealloc methods and their callees; // to warn about improper releasing of instance variables that back synthesized; // properties. It warns about missing releases in the following cases:; // - When a class has a synthesized instance variable for a 'retain' or 'copy'; // property and lacks a -dealloc method in its implementation.; // - When a class has a synthesized instance variable for a 'retain'/'copy'; // property but the ivar is not released in -dealloc by either -release; // or by nilling out the property.; //; // It warns about extra releases in -dealloc (but not in callees) when a; // synthesized instance variable is released in the following cases:; // - When the property is 'assign' and is not 'readonly'.; // - When the property is 'weak'.; //; // This checker only warns for instance variables synthesized to back; // properties. Handling the more general case would require inferring whether; // an instance variable is stored retained or not. For synthesized properties,; // this is specified in the property declaration itself.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:859,Deployability,release,released,859,"//==- CheckObjCDealloc.cpp - Check ObjC -dealloc implementation --*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker analyzes Objective-C -dealloc methods and their callees; // to warn about improper releasing of instance variables that back synthesized; // properties. It warns about missing releases in the following cases:; // - When a class has a synthesized instance variable for a 'retain' or 'copy'; // property and lacks a -dealloc method in its implementation.; // - When a class has a synthesized instance variable for a 'retain'/'copy'; // property but the ivar is not released in -dealloc by either -release; // or by nilling out the property.; //; // It warns about extra releases in -dealloc (but not in callees) when a; // synthesized instance variable is released in the following cases:; // - When the property is 'assign' and is not 'readonly'.; // - When the property is 'weak'.; //; // This checker only warns for instance variables synthesized to back; // properties. Handling the more general case would require inferring whether; // an instance variable is stored retained or not. For synthesized properties,; // this is specified in the property declaration itself.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:891,Deployability,release,release,891,"//==- CheckObjCDealloc.cpp - Check ObjC -dealloc implementation --*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker analyzes Objective-C -dealloc methods and their callees; // to warn about improper releasing of instance variables that back synthesized; // properties. It warns about missing releases in the following cases:; // - When a class has a synthesized instance variable for a 'retain' or 'copy'; // property and lacks a -dealloc method in its implementation.; // - When a class has a synthesized instance variable for a 'retain'/'copy'; // property but the ivar is not released in -dealloc by either -release; // or by nilling out the property.; //; // It warns about extra releases in -dealloc (but not in callees) when a; // synthesized instance variable is released in the following cases:; // - When the property is 'assign' and is not 'readonly'.; // - When the property is 'weak'.; //; // This checker only warns for instance variables synthesized to back; // properties. Handling the more general case would require inferring whether; // an instance variable is stored retained or not. For synthesized properties,; // this is specified in the property declaration itself.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:964,Deployability,release,releases,964,"//==- CheckObjCDealloc.cpp - Check ObjC -dealloc implementation --*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker analyzes Objective-C -dealloc methods and their callees; // to warn about improper releasing of instance variables that back synthesized; // properties. It warns about missing releases in the following cases:; // - When a class has a synthesized instance variable for a 'retain' or 'copy'; // property and lacks a -dealloc method in its implementation.; // - When a class has a synthesized instance variable for a 'retain'/'copy'; // property but the ivar is not released in -dealloc by either -release; // or by nilling out the property.; //; // It warns about extra releases in -dealloc (but not in callees) when a; // synthesized instance variable is released in the following cases:; // - When the property is 'assign' and is not 'readonly'.; // - When the property is 'weak'.; //; // This checker only warns for instance variables synthesized to back; // properties. Handling the more general case would require inferring whether; // an instance variable is stored retained or not. For synthesized properties,; // this is specified in the property declaration itself.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:1050,Deployability,release,released,1050,"//==- CheckObjCDealloc.cpp - Check ObjC -dealloc implementation --*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker analyzes Objective-C -dealloc methods and their callees; // to warn about improper releasing of instance variables that back synthesized; // properties. It warns about missing releases in the following cases:; // - When a class has a synthesized instance variable for a 'retain' or 'copy'; // property and lacks a -dealloc method in its implementation.; // - When a class has a synthesized instance variable for a 'retain'/'copy'; // property but the ivar is not released in -dealloc by either -release; // or by nilling out the property.; //; // It warns about extra releases in -dealloc (but not in callees) when a; // synthesized instance variable is released in the following cases:; // - When the property is 'assign' and is not 'readonly'.; // - When the property is 'weak'.; //; // This checker only warns for instance variables synthesized to back; // properties. Handling the more general case would require inferring whether; // an instance variable is stored retained or not. For synthesized properties,; // this is specified in the property declaration itself.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:501,Modifiability,variab,variables,501,"//==- CheckObjCDealloc.cpp - Check ObjC -dealloc implementation --*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker analyzes Objective-C -dealloc methods and their callees; // to warn about improper releasing of instance variables that back synthesized; // properties. It warns about missing releases in the following cases:; // - When a class has a synthesized instance variable for a 'retain' or 'copy'; // property and lacks a -dealloc method in its implementation.; // - When a class has a synthesized instance variable for a 'retain'/'copy'; // property but the ivar is not released in -dealloc by either -release; // or by nilling out the property.; //; // It warns about extra releases in -dealloc (but not in callees) when a; // synthesized instance variable is released in the following cases:; // - When the property is 'assign' and is not 'readonly'.; // - When the property is 'weak'.; //; // This checker only warns for instance variables synthesized to back; // properties. Handling the more general case would require inferring whether; // an instance variable is stored retained or not. For synthesized properties,; // this is specified in the property declaration itself.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:651,Modifiability,variab,variable,651,"//==- CheckObjCDealloc.cpp - Check ObjC -dealloc implementation --*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker analyzes Objective-C -dealloc methods and their callees; // to warn about improper releasing of instance variables that back synthesized; // properties. It warns about missing releases in the following cases:; // - When a class has a synthesized instance variable for a 'retain' or 'copy'; // property and lacks a -dealloc method in its implementation.; // - When a class has a synthesized instance variable for a 'retain'/'copy'; // property but the ivar is not released in -dealloc by either -release; // or by nilling out the property.; //; // It warns about extra releases in -dealloc (but not in callees) when a; // synthesized instance variable is released in the following cases:; // - When the property is 'assign' and is not 'readonly'.; // - When the property is 'weak'.; //; // This checker only warns for instance variables synthesized to back; // properties. Handling the more general case would require inferring whether; // an instance variable is stored retained or not. For synthesized properties,; // this is specified in the property declaration itself.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:795,Modifiability,variab,variable,795,"//==- CheckObjCDealloc.cpp - Check ObjC -dealloc implementation --*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker analyzes Objective-C -dealloc methods and their callees; // to warn about improper releasing of instance variables that back synthesized; // properties. It warns about missing releases in the following cases:; // - When a class has a synthesized instance variable for a 'retain' or 'copy'; // property and lacks a -dealloc method in its implementation.; // - When a class has a synthesized instance variable for a 'retain'/'copy'; // property but the ivar is not released in -dealloc by either -release; // or by nilling out the property.; //; // It warns about extra releases in -dealloc (but not in callees) when a; // synthesized instance variable is released in the following cases:; // - When the property is 'assign' and is not 'readonly'.; // - When the property is 'weak'.; //; // This checker only warns for instance variables synthesized to back; // properties. Handling the more general case would require inferring whether; // an instance variable is stored retained or not. For synthesized properties,; // this is specified in the property declaration itself.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:1038,Modifiability,variab,variable,1038,"//==- CheckObjCDealloc.cpp - Check ObjC -dealloc implementation --*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker analyzes Objective-C -dealloc methods and their callees; // to warn about improper releasing of instance variables that back synthesized; // properties. It warns about missing releases in the following cases:; // - When a class has a synthesized instance variable for a 'retain' or 'copy'; // property and lacks a -dealloc method in its implementation.; // - When a class has a synthesized instance variable for a 'retain'/'copy'; // property but the ivar is not released in -dealloc by either -release; // or by nilling out the property.; //; // It warns about extra releases in -dealloc (but not in callees) when a; // synthesized instance variable is released in the following cases:; // - When the property is 'assign' and is not 'readonly'.; // - When the property is 'weak'.; //; // This checker only warns for instance variables synthesized to back; // properties. Handling the more general case would require inferring whether; // an instance variable is stored retained or not. For synthesized properties,; // this is specified in the property declaration itself.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:1222,Modifiability,variab,variables,1222,"//==- CheckObjCDealloc.cpp - Check ObjC -dealloc implementation --*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker analyzes Objective-C -dealloc methods and their callees; // to warn about improper releasing of instance variables that back synthesized; // properties. It warns about missing releases in the following cases:; // - When a class has a synthesized instance variable for a 'retain' or 'copy'; // property and lacks a -dealloc method in its implementation.; // - When a class has a synthesized instance variable for a 'retain'/'copy'; // property but the ivar is not released in -dealloc by either -release; // or by nilling out the property.; //; // It warns about extra releases in -dealloc (but not in callees) when a; // synthesized instance variable is released in the following cases:; // - When the property is 'assign' and is not 'readonly'.; // - When the property is 'weak'.; //; // This checker only warns for instance variables synthesized to back; // properties. Handling the more general case would require inferring whether; // an instance variable is stored retained or not. For synthesized properties,; // this is specified in the property declaration itself.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:1347,Modifiability,variab,variable,1347,"//==- CheckObjCDealloc.cpp - Check ObjC -dealloc implementation --*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker analyzes Objective-C -dealloc methods and their callees; // to warn about improper releasing of instance variables that back synthesized; // properties. It warns about missing releases in the following cases:; // - When a class has a synthesized instance variable for a 'retain' or 'copy'; // property and lacks a -dealloc method in its implementation.; // - When a class has a synthesized instance variable for a 'retain'/'copy'; // property but the ivar is not released in -dealloc by either -release; // or by nilling out the property.; //; // It warns about extra releases in -dealloc (but not in callees) when a; // synthesized instance variable is released in the following cases:; // - When the property is 'assign' and is not 'readonly'.; // - When the property is 'weak'.; //; // This checker only warns for instance variables synthesized to back; // properties. Handling the more general case would require inferring whether; // an instance variable is stored retained or not. For synthesized properties,; // this is specified in the property declaration itself.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:61,Deployability,release,released,61,/// Indicates whether an instance variable is required to be released in; /// -dealloc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:34,Modifiability,variab,variable,34,/// Indicates whether an instance variable is required to be released in; /// -dealloc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:34,Deployability,release,released,34,"/// The instance variable must be released, either by calling; /// -release on it directly or by nilling it out with a property setter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:68,Deployability,release,release,68,"/// The instance variable must be released, either by calling; /// -release on it directly or by nilling it out with a property setter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:17,Modifiability,variab,variable,17,"/// The instance variable must be released, either by calling; /// -release on it directly or by nilling it out with a property setter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:47,Deployability,release,released,47,/// The instance variable must not be directly released with -release.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:62,Deployability,release,release,62,/// The instance variable must not be directly released with -release.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:17,Modifiability,variab,variable,17,/// The instance variable must not be directly released with -release.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:37,Modifiability,variab,variable,37,/// The requirement for the instance variable could not be determined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:125,Deployability,release,released,125,// End anonymous namespace.; /// Maps from the symbol for a class instance to the set of; /// symbols remaining that must be released in -dealloc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:115,Deployability,release,released,115,"/// If this is the beginning of -dealloc, mark the values initially stored in; /// instance variables that must be released by the end of -dealloc; /// as unreleased in the state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:92,Modifiability,variab,variables,92,"/// If this is the beginning of -dealloc, mark the values initially stored in; /// instance variables that must be released by the end of -dealloc; /// as unreleased in the state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:24,Deployability,release,released,24,// Symbols that must be released by the end of the -dealloc;,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:33,Deployability,release,release,33,// Mark the value as requiring a release.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:62,Performance,load,loaded,62,"/// Given a symbol for an ivar, return the ivar region it was loaded from.; /// Returns nullptr if the instance symbol cannot be found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:87,Deployability,release,release,87,"/// If we are in -dealloc or -dealloc is on the stack, handle the call if it is; /// a release or a nilling-out property setter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:35,Deployability,release,released,35,// An instance variable symbol was released with -release:; // [_property release];,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:50,Deployability,release,release,50,// An instance variable symbol was released with -release:; // [_property release];,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:74,Deployability,release,release,74,// An instance variable symbol was released with -release:; // [_property release];,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:15,Modifiability,variab,variable,15,// An instance variable symbol was released with -release:; // [_property release];,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:35,Deployability,release,released,35,// An instance variable symbol was released nilling out its property:; // self.property = nil;,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:15,Modifiability,variab,variable,15,// An instance variable symbol was released nilling out its property:; // self.property = nil;,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:78,Deployability,release,releases,78,"/// If the message was a call to '[super dealloc]', diagnose any missing; /// releases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:11,Integrability,message,message,11,"/// If the message was a call to '[super dealloc]', diagnose any missing; /// releases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:135,Deployability,release,released,135,"// We perform this check post-message so that if the super -dealloc; // calls a helper method and that this class overrides, any ivars released in; // the helper method will be recorded before checking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:30,Integrability,message,message,30,"// We perform this check post-message so that if the super -dealloc; // calls a helper method and that this class overrides, any ivars released in; // the helper method will be recorded before checking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:6,Performance,perform,perform,6,"// We perform this check post-message so that if the super -dealloc; // calls a helper method and that this class overrides, any ivars released in; // the helper method will be recorded before checking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:22,Deployability,release,releases,22,/// Check for missing releases even when -dealloc does not call; /// '[super dealloc]'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:22,Deployability,release,releases,22,/// Check for missing releases on early return.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:58,Deployability,release,released,58,/// If a symbol escapes conservatively assume unseen code released it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:130,Deployability,release,releases,130,"// Don't treat calls to '[super dealloc]' as escaping for the purposes; // of this checker. Because the checker diagnoses missing releases in the; // post-message handler for '[super dealloc], escaping here would cause; // the checker to never warn.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:155,Integrability,message,message,155,"// Don't treat calls to '[super dealloc]' as escaping for the purposes; // of this checker. Because the checker diagnoses missing releases in the; // post-message handler for '[super dealloc], escaping here would cause; // the checker to never warn.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:77,Deployability,release,released,77,"// If Sym is a symbol for an object with instance variables that; // must be released, remove these obligations when the object escapes; // unless via a call to a system function. System functions are; // very unlikely to release instance variables on objects passed to them,; // and are frequently called on 'self' in -dealloc (e.g., to remove; // observers) -- we want to avoid false negatives from escaping on; // them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:222,Deployability,release,release,222,"// If Sym is a symbol for an object with instance variables that; // must be released, remove these obligations when the object escapes; // unless via a call to a system function. System functions are; // very unlikely to release instance variables on objects passed to them,; // and are frequently called on 'self' in -dealloc (e.g., to remove; // observers) -- we want to avoid false negatives from escaping on; // them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:50,Modifiability,variab,variables,50,"// If Sym is a symbol for an object with instance variables that; // must be released, remove these obligations when the object escapes; // unless via a call to a system function. System functions are; // very unlikely to release instance variables on objects passed to them,; // and are frequently called on 'self' in -dealloc (e.g., to remove; // observers) -- we want to avoid false negatives from escaping on; // them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:239,Modifiability,variab,variables,239,"// If Sym is a symbol for an object with instance variables that; // must be released, remove these obligations when the object escapes; // unless via a call to a system function. System functions are; // very unlikely to release instance variables on objects passed to them,; // and are frequently called on 'self' in -dealloc (e.g., to remove; // observers) -- we want to avoid false negatives from escaping on; // them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:374,Safety,avoid,avoid,374,"// If Sym is a symbol for an object with instance variables that; // must be released, remove these obligations when the object escapes; // unless via a call to a system function. System functions are; // very unlikely to release instance variables on objects passed to them,; // and are frequently called on 'self' in -dealloc (e.g., to remove; // observers) -- we want to avoid false negatives from escaping on; // them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:35,Modifiability,variab,variables,35,/// Report any unreleased instance variables for the current instance being; /// dealloced.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:121,Deployability,release,release,121,// Prevent an inlined call to -dealloc in a super class from warning; // about the values the subclass's -dealloc should release.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:60,Modifiability,variab,variable,60,"// Prevents diagnosing multiple times for the same instance variable; // at, for example, both a return and at the end of the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:66,Availability,error,error,66,"// A missing release manifests as a leak, so treat as a non-fatal error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:13,Deployability,release,release,13,"// A missing release manifests as a leak, so treat as a non-fatal error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:121,Deployability,release,releases,121,"// If the class is known to have a lifecycle with teardown that is; // separate from -dealloc, do not warn about missing releases. We; // suppress here (rather than not tracking for instance variables in; // such classes) because these classes are rare.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:191,Modifiability,variab,variables,191,"// If the class is known to have a lifecycle with teardown that is; // separate from -dealloc, do not warn about missing releases. We; // suppress here (rather than not tracking for instance variables in; // such classes) because these classes are rare.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:115,Safety,detect,detect,115,// Make sure that after checking in the top-most frame the list of; // tracked ivars is empty. This is intended to detect accidental leaks in; // the UnreleasedIvarMap program state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:55,Performance,load,loaded,55,// Try to get the region from which the ivar value was loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:54,Performance,load,loaded,54,// Don't try to find the property if the ivar was not loaded from the; // given instance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:59,Deployability,Release,ReleasedValue,59,/// Emits a warning if the current context is -dealloc and ReleasedValue; /// must not be directly released in a -dealloc. Returns true if a diagnostic; /// was emitted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:99,Deployability,release,released,99,/// Emits a warning if the current context is -dealloc and ReleasedValue; /// must not be directly released in a -dealloc. Returns true if a diagnostic; /// was emitted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:257,Availability,error,error,257,"// Try to get the region from which the released value was loaded.; // Note that, unlike diagnosing for missing releases, here we don't track; // values that must not be released in the state. This is because even if; // these values escape, it is still an error under the rules of MRR to; // release them in -dealloc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:40,Deployability,release,released,40,"// Try to get the region from which the released value was loaded.; // Note that, unlike diagnosing for missing releases, here we don't track; // values that must not be released in the state. This is because even if; // these values escape, it is still an error under the rules of MRR to; // release them in -dealloc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:112,Deployability,release,releases,112,"// Try to get the region from which the released value was loaded.; // Note that, unlike diagnosing for missing releases, here we don't track; // values that must not be released in the state. This is because even if; // these values escape, it is still an error under the rules of MRR to; // release them in -dealloc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:170,Deployability,release,released,170,"// Try to get the region from which the released value was loaded.; // Note that, unlike diagnosing for missing releases, here we don't track; // values that must not be released in the state. This is because even if; // these values escape, it is still an error under the rules of MRR to; // release them in -dealloc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:293,Deployability,release,release,293,"// Try to get the region from which the released value was loaded.; // Note that, unlike diagnosing for missing releases, here we don't track; // values that must not be released in the state. This is because even if; // these values escape, it is still an error under the rules of MRR to; // release them in -dealloc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:59,Performance,load,loaded,59,"// Try to get the region from which the released value was loaded.; // Note that, unlike diagnosing for missing releases, here we don't track; // values that must not be released in the state. This is because even if; // these values escape, it is still an error under the rules of MRR to; // release them in -dealloc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:54,Deployability,release,released,54,"// If the ivar belongs to a property that must not be released directly; // in dealloc, emit a warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:88,Integrability,interface,interface,88,"// If the property is readwrite but it shadows a read-only property in its; // external interface, treat the property a read-only. If the outside; // world cannot write to a property then the internal implementation is free; // to make its own convention about whether the value is stored retained; // or not. We look up the shadow here rather than in; // getDeallocReleaseRequirement() because doing so can be expensive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:42,Modifiability,variab,variable,42,// Find the property backing the instance variable that M; // is dealloc'ing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:32,Deployability,release,release,32,/// Add a transition noting the release of the given value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:33,Deployability,release,release,33,/// Remove the Value requiring a release from the tracked set for; /// Instance and return the resultant state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:43,Deployability,release,release,43,// Mark the value as no longer requiring a release.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:86,Deployability,release,released,86,/// Determines whether the instance variable for \p PropImpl must or must not be; /// released in -dealloc or whether it cannot be determined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:36,Modifiability,variab,variable,36,/// Determines whether the instance variable for \p PropImpl must or must not be; /// released in -dealloc or whether it cannot be determined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:124,Deployability,release,released,124,// Retain and copy setters retain/copy their values before storing and so; // the value in their instance variables must be released in -dealloc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:106,Modifiability,variab,variables,106,// Retain and copy setters retain/copy their values before storing and so; // the value in their instance variables must be released in -dealloc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:105,Deployability,release,release,105,"// It is common for the ivars for read-only assign properties to; // always be stored retained, so their release requirement cannot be; // be determined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:16,Deployability,release,released,16,/// Returns the released value if M is a call a setter that releases; /// and nils out its underlying instance variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:60,Deployability,release,releases,60,/// Returns the released value if M is a call a setter that releases; /// and nils out its underlying instance variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:111,Modifiability,variab,variable,111,/// Returns the released value if M is a call a setter that releases; /// and nils out its underlying instance variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:151,Deployability,release,releases,151,"/// Returns true if the ID is a class in which is known to have; /// a separate teardown lifecycle. In this case, -dealloc warnings; /// about missing releases should be suppressed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:143,Availability,down,down,143,"// FIXME: For now, ignore classes that subclass SenTestCase and XCTestCase,; // as these don't need to implement -dealloc. They implement tear down in; // another way, which we should try and catch later.; // http://llvm.org/bugs/show_bug.cgi?id=3187",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:67,Deployability,release,release,67,"/// The -dealloc method in CIFilter highly unusual in that is will release; /// instance variables belonging to its *subclasses* if the variable name; /// starts with ""input"" or backs a property whose name starts with ""input"".; /// Subclasses should not release these ivars in their own -dealloc method --; /// doing so could result in an over release.; ///; /// This method returns true if the property will be released by; /// -[CIFilter dealloc].",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:254,Deployability,release,release,254,"/// The -dealloc method in CIFilter highly unusual in that is will release; /// instance variables belonging to its *subclasses* if the variable name; /// starts with ""input"" or backs a property whose name starts with ""input"".; /// Subclasses should not release these ivars in their own -dealloc method --; /// doing so could result in an over release.; ///; /// This method returns true if the property will be released by; /// -[CIFilter dealloc].",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:344,Deployability,release,release,344,"/// The -dealloc method in CIFilter highly unusual in that is will release; /// instance variables belonging to its *subclasses* if the variable name; /// starts with ""input"" or backs a property whose name starts with ""input"".; /// Subclasses should not release these ivars in their own -dealloc method --; /// doing so could result in an over release.; ///; /// This method returns true if the property will be released by; /// -[CIFilter dealloc].",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:412,Deployability,release,released,412,"/// The -dealloc method in CIFilter highly unusual in that is will release; /// instance variables belonging to its *subclasses* if the variable name; /// starts with ""input"" or backs a property whose name starts with ""input"".; /// Subclasses should not release these ivars in their own -dealloc method --; /// doing so could result in an over release.; ///; /// This method returns true if the property will be released by; /// -[CIFilter dealloc].",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:89,Modifiability,variab,variables,89,"/// The -dealloc method in CIFilter highly unusual in that is will release; /// instance variables belonging to its *subclasses* if the variable name; /// starts with ""input"" or backs a property whose name starts with ""input"".; /// Subclasses should not release these ivars in their own -dealloc method --; /// doing so could result in an over release.; ///; /// This method returns true if the property will be released by; /// -[CIFilter dealloc].",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:136,Modifiability,variab,variable,136,"/// The -dealloc method in CIFilter highly unusual in that is will release; /// instance variables belonging to its *subclasses* if the variable name; /// starts with ""input"" or backs a property whose name starts with ""input"".; /// Subclasses should not release these ivars in their own -dealloc method --; /// doing so could result in an over release.; ///; /// This method returns true if the property will be released by; /// -[CIFilter dealloc].",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:100,Performance,load,loading,100,"/// Returns whether the ivar backing the property is an IBOutlet that; /// has its value set by nib loading code without retaining the value.; ///; /// On macOS, if there is no setter, the nib-loading code sets the ivar; /// directly, without retaining the value,; ///; /// On iOS and its derivatives, the nib-loading code will call; /// -setValue:forKey:, which retains the value before directly setting the ivar.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:193,Performance,load,loading,193,"/// Returns whether the ivar backing the property is an IBOutlet that; /// has its value set by nib loading code without retaining the value.; ///; /// On macOS, if there is no setter, the nib-loading code sets the ivar; /// directly, without retaining the value,; ///; /// On iOS and its derivatives, the nib-loading code will call; /// -setValue:forKey:, which retains the value before directly setting the ivar.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:310,Performance,load,loading,310,"/// Returns whether the ivar backing the property is an IBOutlet that; /// has its value set by nib loading code without retaining the value.; ///; /// On macOS, if there is no setter, the nib-loading code sets the ivar; /// directly, without retaining the value,; ///; /// On iOS and its derivatives, the nib-loading code will call; /// -setValue:forKey:, which retains the value before directly setting the ivar.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCInstMethSignature.cpp:500,Integrability,interface,interface,500,"//===-- CheckObjCInstMethSignature.cpp - Check ObjC method signatures -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a CheckObjCInstMethSignature, a flow-insensitive check; // that determines if an Objective-C class interface incorrectly redefines; // the method signature in a subclass.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCInstMethSignature.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCInstMethSignature.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCInstMethSignature.cpp:126,Deployability,patch,patch,126,// Right now don't compare the compatibility of pointers. That involves; // looking at subtyping relationships. FIXME: Future patch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCInstMethSignature.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCInstMethSignature.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:42,Security,secur,security,42,"//==- CheckSecuritySyntaxOnly.cpp - Basic security checks --------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a set of flow-insensitive security checks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:427,Security,secur,security,427,"//==- CheckSecuritySyntaxOnly.cpp - Basic security checks --------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a set of flow-insensitive security checks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:27,Usability,simpl,simple,27,"// if no identifier, not a simple C function",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:45,Security,secur,security,45,"// If the callee isn't defined, it is not of security concern.; // Check and evaluate the call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:305,Integrability,depend,depending,305,"//===----------------------------------------------------------------------===//; // Check: floating point variable used as loop counter.; // Implements: CERT security coding advisory FLP-30.; //===----------------------------------------------------------------------===//; // Returns either 'x' or 'y', depending on which one of them is incremented; // in 'expr', or nullptr if none of them is incremented.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:107,Modifiability,variab,variable,107,"//===----------------------------------------------------------------------===//; // Check: floating point variable used as loop counter.; // Implements: CERT security coding advisory FLP-30.; //===----------------------------------------------------------------------===//; // Returns either 'x' or 'y', depending on which one of them is incremented; // in 'expr', or nullptr if none of them is incremented.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:159,Security,secur,security,159,"//===----------------------------------------------------------------------===//; // Check: floating point variable used as loop counter.; // Implements: CERT security coding advisory FLP-30.; //===----------------------------------------------------------------------===//; // Returns either 'x' or 'y', depending on which one of them is incremented; // in 'expr', or nullptr if none of them is incremented.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:102,Modifiability,variab,variable,102,"/// CheckLoopConditionForFloat - This check looks for 'for' statements that; /// use a floating point variable as a loop counter.; /// CERT: FLP30-C, FLP30-CPP.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:20,Modifiability,variab,variables,20,// Are we comparing variables?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:28,Modifiability,variab,variables,28,// Does at least one of the variables have a floating point type?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:15,Modifiability,variab,variable,15,// Does either variable appear in increment?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:12,Availability,error,error,12,// Emit the error. First figure out which DeclRefExpr in the condition; // referenced the compared variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:99,Modifiability,variab,variable,99,// Emit the error. First figure out which DeclRefExpr in the condition; // referenced the compared variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:20,Security,secur,security,20,"// Fall back to the security check of looking for enough 'X's in the; // format string, since that is a less severe warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:119,Modifiability,variab,variables,119,"// Currently we only handle string literals. It is possible to do better,; // either by looking at references to const variables, or by doing real; // flow analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:55,Safety,unsafe,unsafe,55,// Issue a warning. ArgIndex == -1: Deprecated but not unsafe (has size; // restrictions).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:130,Modifiability,variab,variables,130,"// Currently we only handle (not wide) string literals. It is possible to do; // better, either by looking at references to const variables, or by doing; // real flow analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:199,Energy Efficiency,Efficient,Efficient,199,"//===----------------------------------------------------------------------===//; // Check: Linear congruent random number generators should not be used,; // i.e. rand(), random().; //; // E. Bach, ""Efficient prediction of Marsaglia-Zaman random number generators,""; // in IEEE Transactions on Information Theory, vol. 44, no. 3, pp. 1253-1257,; // May 1998, https://doi.org/10.1109/18.669305; //; // CWE-338: Use of cryptographically weak prng; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:209,Safety,predict,prediction,209,"//===----------------------------------------------------------------------===//; // Check: Linear congruent random number generators should not be used,; // i.e. rand(), random().; //; // E. Bach, ""Efficient prediction of Marsaglia-Zaman random number generators,""; // in IEEE Transactions on Information Theory, vol. 44, no. 3, pp. 1253-1257,; // May 1998, https://doi.org/10.1109/18.669305; //; // CWE-338: Use of cryptographically weak prng; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:9,Availability,avail,availability,9,"// Check availability of the secure alternative:; // iOS 11+, macOS 10.13+, tvOS 11+, and watchOS 4.0+; // FIXME: We probably shouldn't register the check if it's not available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:167,Availability,avail,available,167,"// Check availability of the secure alternative:; // iOS 11+, macOS 10.13+, tvOS 11+, and watchOS 4.0+; // FIXME: We probably shouldn't register the check if it's not available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:29,Security,secur,secure,29,"// Check availability of the secure alternative:; // iOS 11+, macOS 10.13+, tvOS 11+, and watchOS 4.0+; // FIXME: We probably shouldn't register the check if it's not available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:466,Security,access,access,466,"//===----------------------------------------------------------------------===//; // Check: The caller should always verify that the privileges; // were dropped successfully.; //; // Some library functions, like setuid() and setgid(), should always be used; // with a check of the return value to verify that the function completed; // successfully. If the drop fails, the software will continue to run; // with the raised privileges, which might provide additional access; // to unprivileged users.; //; // (Note that this check predates __attribute__((warn_unused_result)).; // Do we still need it now that we have a compiler warning for this?; // Are these standard functions already annotated this way?); //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:56,Integrability,depend,depending,56,// Verify that the function takes one or two arguments (depending on; // the function).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:85,Security,Secur,SecuritySyntaxChecker,85,//===----------------------------------------------------------------------===//; // SecuritySyntaxChecker; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp:34,Safety,detect,detection,34,"//===--- CloneChecker.cpp - Clone detection checker -------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// CloneChecker is a checker that reports clones in the current translation; /// unit.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp:370,Availability,error,errors,370,"// At this point, every statement in the translation unit has been analyzed by; // the CloneDetector. The only thing left to do is to report the found clones.; // Let the CloneDetector create a list of clones from all the analyzed; // statements. We don't filter for matching variable patterns at this point; // because reportSuspiciousClones() wants to search them for errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp:276,Modifiability,variab,variable,276,"// At this point, every statement in the translation unit has been analyzed by; // the CloneDetector. The only thing left to do is to report the found clones.; // Let the CloneDetector create a list of clones from all the analyzed; // statements. We don't filter for matching variable patterns at this point; // because reportSuspiciousClones() wants to search them for errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp:66,Availability,error,errors,66,"// Now that the suspicious clone detector has checked for pattern errors,; // we also filter all clones who don't have matching patterns",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp:33,Safety,detect,detector,33,"// Now that the suspicious clone detector has checked for pattern errors,; // we also filter all clones who don't have matching patterns",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp:50,Modifiability,variab,variable,50,"// For now, we only report clones which break the variable pattern just; // once because multiple differences in a pattern are an indicator that; // those differences are maybe intended (e.g. because it's actually a; // different algorithm).; // FIXME: In very big clones even multiple variables can be unintended,; // so replacing this number with a percentage could better handle such; // cases. On the other hand it could increase the false-positive rate; // for all clones if the percentage is too high.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp:286,Modifiability,variab,variables,286,"// For now, we only report clones which break the variable pattern just; // once because multiple differences in a pattern are an indicator that; // those differences are maybe intended (e.g. because it's actually a; // different algorithm).; // FIXME: In very big clones even multiple variables can be unintended,; // so replacing this number with a percentage could better handle such; // cases. On the other hand it could increase the false-positive rate; // for all clones if the percentage is too high.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp:189,Performance,perform,perform,189,"// FIXME: We are ignoring the suggestions currently, because they are; // only 50% accurate (even if the second suggestion is unavailable),; // which may confuse the user.; // Think how to perform more accurate suggestions?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ContainerModeling.cpp:58,Availability,alive,alive,58,// Keep symbolic expressions of container begins and ends alive,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ContainerModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ContainerModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ContainerModeling.cpp:7,Usability,clear,clear,7,"// The clear() operation invalidates all the iterators, except the past-end; // iterators of list-like containers",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ContainerModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ContainerModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ContainerModeling.cpp:36,Modifiability,variab,variable,36,// First try to get the name of the variable from the region,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ContainerModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ContainerModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ConversionChecker.cpp:15,Availability,error,error,15,// Generate an error node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ConversionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ConversionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ConversionChecker.cpp:3,Safety,Avoid,Avoid,3,// Avoid overflow in our later calculations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ConversionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ConversionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ConversionChecker.cpp:3,Usability,Simpl,Simple,3,// Simple case: the destination can store all values of the source type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ConversionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ConversionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:8,Security,access,access,8,// read access,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:6,Usability,usab,usable,6,// Re-usable checks,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:49,Availability,failure,failure,49,"// If a previous check has failed, propagate the failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:65,Modifiability,Refactor,Refactor,65,// FIXME: This was originally copied from ArrayBoundChecker.cpp. Refactor?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:49,Availability,failure,failure,49,"// If a previous check has failed, propagate the failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:40,Security,access,access,40,// Check for out of bound array element access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:24,Security,access,accessed,24,// Get the index of the accessed element.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:49,Availability,failure,failure,49,"// If a previous check has failed, propagate the failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:44,Security,access,accessible,44,// Check if the first byte of the buffer is accessible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:11,Security,access,access,11,// Get the access length and make sure it is known.; // FIXME: This assumes the caller has already checked that the access length; // is positive. And that it's unsigned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:116,Security,access,access,116,// Get the access length and make sure it is known.; // FIXME: This assumes the caller has already checked that the access length; // is positive. And that it's unsigned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:48,Security,access,accessed,48,// Compute the offset of the last element to be accessed: size-1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:37,Safety,abort,abort,37,"// If the buffer isn't large enough, abort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:222,Availability,failure,failure,222,"// Do a simple check for overlap: if the two arguments are from the same; // buffer, see if the end of the first is greater than the start of the second; // or vice versa.; // If a previous check has failed, propagate the failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:8,Usability,simpl,simple,8,"// Do a simple check for overlap: if the two arguments are from the same; // buffer, see if the end of the first is greater than the start of the second; // or vice versa.; // If a previous check has failed, propagate the failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:52,Performance,perform,perform,52,"// If we don't know which one comes first, we can't perform this test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:65,Testability,test,test,65,"// If we don't know which one comes first, we can't perform this test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:67,Usability,clear,clear,67,"// FIXME: It would be nice to eventually make this diagnostic more clear,; // e.g., by referencing the original declaration or by saying *why* this; // reference is outside the range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:109,Availability,error,error,109,"// FIXME: This call uses the word ""API"" as the description of the bug;; // it should be replaced by a better error message (if this unlikely; // situation continues to exist as a separate bug type).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:115,Integrability,message,message,115,"// FIXME: This call uses the word ""API"" as the description of the bug;; // it should be replaced by a better error message (if this unlikely; // situation continues to exist as a separate bug type).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:22,Availability,error,error,22,"// This isn't a great error message, but this should never occur in real; // code anyway -- you'd have to create a buffer longer than a size_t can; // represent, which is sort of a contradiction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:28,Integrability,message,message,28,"// This isn't a great error message, but this should never occur in real; // code anyway -- you'd have to create a buffer longer than a size_t can; // represent, which is sort of a contradiction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:49,Availability,failure,failure,49,"// If a previous check has failed, propagate the failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:48,Availability,reliab,reliable,48,"// Other regions (mostly non-data) can't have a reliable C string length.; // For now, just ignore the change.; // FIXME: These are rare but not impossible. We should output some kind of; // warning for things like strcpy((char[]){'a', 0}, ""b"");",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:35,Deployability,update,update,35,"// Otherwise, get a new symbol and update the state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:48,Availability,reliab,reliable,48,"// Other regions (mostly non-data) can't have a reliable C string length.; // In this case, an error is emitted and UndefinedVal is returned.; // The caller should always be prepared to handle this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:95,Availability,error,error,95,"// Other regions (mostly non-data) can't have a reliable C string length.; // In this case, an error is emitted and UndefinedVal is returned.; // The caller should always be prepared to handle this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:68,Security,access,accessed,68,// cf top comment.; // Compute the offset of the last element to be accessed: size-1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:40,Security,access,access,40,// Check for out of bound array element access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:24,Security,access,accessed,24,// Get the index of the accessed element.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:47,Security,access,access,47,"// If destination buffer is a field region and access is in bound, do; // not invalidate its super region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:174,Modifiability,refactor,refactored,174,"// FIXME: This is a simplified version of what's in CFRefCount.cpp -- it makes; // some assumptions about the value that CFRefCount can't. Even so, it should; // probably be refactored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:20,Usability,simpl,simplified,20,"// FIXME: This is a simplified version of what's in CFRefCount.cpp -- it makes; // some assumptions about the value that CFRefCount can't. Even so, it should; // probably be refactored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:21,Modifiability,layers,layers,21,// FIXME: What about layers of ElementRegions?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:57,Security,access,access,57,"// If the size is zero, there won't be any actual memory access, so; // just bind the return value to the destination buffer and return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:14,Security,access,accesses,14,// Ensure the accesses are valid and that the buffers do not overlap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:48,Availability,error,errors,48,// These two values allow checking two kinds of errors:; // - actual overflows caused by a source that doesn't fit in the destination; // - potential overflows caused by a bound that could exceed the destination,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:46,Security,access,access,46,// FIXME: Why do we choose the srcExpr if the access has no size?; // Note that the 3rd argument of the call would be the size parameter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:362,Security,access,accessed,362,"// For strncpy and strlcat, this is just checking; // that lenVal <= sizeof(dst).; // (Yes, strncpy and strncat differ in how they treat termination.; // strncat ALWAYS terminates, but strncpy doesn't.); // We need a special case for when the copy size is zero, in which; // case strncpy will do no work at all. Our bounds check uses n-1; // as the last element accessed, so n == 0 is problematic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:6,Modifiability,extend,extend,6,// we extend the dst string with the src; // finalStrLength >= dstStrLength,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:200,Usability,clear,clear,200,"// Invalidate the destination (regular invalidation without pointer-escaping; // the address of the top-level region). This must happen before we set the; // C string length because invalidation will clear the length.; // FIXME: Even if we can't perfectly model the copy, we should see if we; // can use LazyCompoundVals to copy the source values into the destination.; // This would probably remove any existing bindings past the end of the; // string, but that's still an improvement over blank invalidation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:57,Security,access,access,57,"// If the size is zero, there won't be any actual memory access, so; // just bind the return value to the buffer and return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:57,Security,access,access,57,"// If the size is zero, there won't be any actual memory access,; // In this case we just return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:46,Safety,safe,safe,46,"// Pro-actively check that argument types are safe to do arithmetic upon.; // We do not want to crash if someone accidentally passes a structure; // into, say, a C++ overload of any of these functions. We could not check; // that for std::copy because they may have arguments of other types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:152,Safety,safe,safety,152,"// If the evaluate call resulted in no change, chain to the next eval call; // handler.; // Note, the custom CString evaluation calls assume that basic safety; // properties are held. However, if the user chooses to turn off some of these; // checks, we ignore the issues and leave the call evaluation to a generic; // handler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CXXDeleteChecker.cpp:569,Modifiability,polymorphi,polymorphic,569,"//=== CXXDeleteChecker.cpp -------------------------------------*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the following new checkers for C++ delete expressions:; //; // * DeleteWithNonVirtualDtorChecker; // Defines a checker for the OOP52-CPP CERT rule: Do not delete a; // polymorphic object without a virtual destructor.; //; // Diagnostic flags -Wnon-virtual-dtor and -Wdelete-non-virtual-dtor; // report if an object with a virtual function but a non-virtual; // destructor exists or is deleted, respectively.; //; // This check exceeds them by comparing the dynamic and static types of; // the object at the point of destruction and only warns if it happens; // through a pointer to a base type without a virtual destructor. The; // check places a note at the last point where the conversion from; // derived to base happened.; //; // * CXXArrayDeleteChecker; // Defines a checker for the EXP51-CPP CERT rule: Do not delete an array; // through a pointer of the incorrect type.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CXXDeleteChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CXXDeleteChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CXXSelfAssignmentChecker.cpp:433,Testability,test,tests,433,"//=== CXXSelfAssignmentChecker.cpp -----------------------------*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines CXXSelfAssignmentChecker, which tests all custom defined; // copy and move assignment operators for the case of self assignment, thus; // where the parameter refers to the same location where the this pointer; // points to. The checker itself does not do any checks at all, but it; // causes the analyzer to check every copy and move assignment operator twice:; // once for when 'this' aliases with the parameter and once for when it may not.; // It is the task of the other enabled checkers to find the bugs in these two; // different cases.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CXXSelfAssignmentChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CXXSelfAssignmentChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp:55,Modifiability,variab,variables,55,"//==- DeadStoresChecker.cpp - Check for stores to dead variables -*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a DeadStores, a flow-sensitive checker that looks for; // stores to variables that are no longer live.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp:469,Modifiability,variab,variables,469,"//==- DeadStoresChecker.cpp - Check for stores to dead variables -*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a DeadStores, a flow-sensitive checker that looks for; // stores to variables that are no longer live.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp:6,Usability,simpl,simple,6,/// A simple visitor to record what VarDecls occur in EH-handling code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp:79,Modifiability,variab,variable,79,"// Special case: self-assignments. These are often used to shut up; // ""unused variable"" compiler warnings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp:30,Modifiability,variab,variable,30,// A dead initialization is a variable that is dead after it; // is initialized. We don't flag warnings for those variables; // marked 'unused' or 'objc_precise_lifetime'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp:114,Modifiability,variab,variables,114,// A dead initialization is a variable that is dead after it; // is initialized. We don't flag warnings for those variables; // marked 'unused' or 'objc_precise_lifetime'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp:60,Modifiability,variab,variables,60,// Special case: check for initialization from constant; // variables.; //; // e.g. extern const int MyConstant;; // int x = MyConstant;; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp:146,Availability,error,error,146,// Special case: check for initialization from scalar; // parameters. This is often a form of defensive; // programming. Non-scalars are still an error since; // because it more likely represents an actual algorithmic; // bug.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp:15,Modifiability,variab,variables,15,// Treat local variables captured by reference in C++ lambdas as escaped.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DebugCheckers.cpp:85,Modifiability,Config,ConfigDumper,85,//===----------------------------------------------------------------------===//; // ConfigDumper; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DebugCheckers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DebugCheckers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp:449,Performance,perform,performs,449,"//===-- DereferenceChecker.cpp - Null dereference checker -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines NullDerefChecker, a builtin check in ExprEngine that performs; // checks for null pointers at loads and stores.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp:490,Performance,load,loads,490,"//===-- DereferenceChecker.cpp - Null dereference checker -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines NullDerefChecker, a builtin check in ExprEngine that performs; // checks for null pointers at loads and stores.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp:94,Performance,load,load,94,// Walk through lvalue casts to get the original expression; // that syntactically caused the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp:302,Availability,error,error,302,"// Do not report dereferences on memory that use address space #256, #257,; // and #258. Those address spaces are used when dereferencing address spaces; // relative to the GS, FS, and SS segments on x86/x86-64 targets.; // Dereferencing a null pointer in these address spaces is not defined; // as an error. All other null dereferences in other address spaces; // are defined as an error unless explicitly defined.; // See https://clang.llvm.org/docs/LanguageExtensions.html, the section; // ""X86/X86-64 Language Extensions""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp:383,Availability,error,error,383,"// Do not report dereferences on memory that use address space #256, #257,; // and #258. Those address spaces are used when dereferencing address spaces; // relative to the GS, FS, and SS segments on x86/x86-64 targets.; // Dereferencing a null pointer in these address spaces is not defined; // as an error. All other null dereferences in other address spaces; // are defined as an error unless explicitly defined.; // See https://clang.llvm.org/docs/LanguageExtensions.html, the section; // ""X86/X86-64 Language Extensions""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp:15,Availability,error,error,15,// Generate an error node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp:99,Availability,error,error,99,"// Otherwise, we have the case where the location could either be; // null or not-null. Record the error node as an ""implicit"" null; // dereference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp:213,Safety,safe,safe,213,"// Unlike a regular null dereference, initializing a reference with a; // dereferenced null pointer does not actually cause a runtime exception in; // Clang's implementation of references.; //; // int &r = *p; // safe??; // if (p != NULL) return; // uh-oh; // r = 5; // trap here; //; // The standard says this is invalid as soon as we try to create a ""null; // reference"" (there is no such thing), but turning this into an assumption; // that 'p' is never null will not match our actual runtime behavior.; // So we do not record this assumption, allowing us to warn on the last line; // of this example.; //; // We do need to add a transition because we may have generated a sink for; // the ""implicit"" null dereference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DirectIvarAssignment.cpp:238,Modifiability,variab,variable,238,"/// The default method filter, which is used to filter out the methods on which; /// the check should not be performed.; ///; /// Checks for the init, dealloc, and any other functions that might be allowed; /// to perform direct instance variable assignment based on their name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DirectIvarAssignment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DirectIvarAssignment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DirectIvarAssignment.cpp:109,Performance,perform,performed,109,"/// The default method filter, which is used to filter out the methods on which; /// the check should not be performed.; ///; /// Checks for the init, dealloc, and any other functions that might be allowed; /// to perform direct instance variable assignment based on their name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DirectIvarAssignment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DirectIvarAssignment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DirectIvarAssignment.cpp:214,Performance,perform,perform,214,"/// The default method filter, which is used to filter out the methods on which; /// the check should not be performed.; ///; /// Checks for the init, dealloc, and any other functions that might be allowed; /// to perform direct instance variable assignment based on their name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DirectIvarAssignment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DirectIvarAssignment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DirectIvarAssignment.cpp:47,Security,access,accesses,47,"// Register the checker that checks for direct accesses in functions annotated; // with __attribute__((annotate(""objc_no_direct_instance_variable_assignment""))).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DirectIvarAssignment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DirectIvarAssignment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DirectIvarAssignment.cpp:117,Integrability,rout,routines,117,"// Register the checker that checks for direct accesses in all functions,; // except for the initialization and copy routines.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DirectIvarAssignment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DirectIvarAssignment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DirectIvarAssignment.cpp:47,Security,access,accesses,47,"// Register the checker that checks for direct accesses in all functions,; // except for the initialization and copy routines.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DirectIvarAssignment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DirectIvarAssignment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DivZeroChecker.cpp:447,Performance,perform,performs,447,"//== DivZeroChecker.cpp - Division by zero checker --------------*- C++ -*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines DivZeroChecker, a builtin check in ExprEngine that performs; // checks for division by zeros.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DivZeroChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DivZeroChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypeChecker.cpp:625,Availability,error,error,625,"//== DynamicTypeChecker.cpp ------------------------------------ -*- C++ -*--=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker looks for cases where the dynamic type of an object is unrelated; // to its static type. The type information utilized by this check is collected; // by the DynamicTypePropagation checker. This check does not report any type; // error for ObjC Generic types, in order to avoid duplicate erros from the; // ObjC Generics checker. This checker is not supposed to modify the program; // state, it is just the observer of the type information provided by other; // checkers.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypeChecker.cpp:667,Safety,avoid,avoid,667,"//== DynamicTypeChecker.cpp ------------------------------------ -*- C++ -*--=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker looks for cases where the dynamic type of an object is unrelated; // to its static type. The type information utilized by this check is collected; // by the DynamicTypePropagation checker. This check does not report any type; // error for ObjC Generic types, in order to avoid duplicate erros from the; // ObjC Generics checker. This checker is not supposed to modify the program; // state, it is just the observer of the type information provided by other; // checkers.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypeChecker.cpp:34,Safety,detect,detect,34,// Strip kindeofness to correctly detect subtyping relationships.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:539,Availability,error,errors,539,"//===- DynamicTypePropagation.cpp ------------------------------*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains two checkers. One helps the static analyzer core to track; // types, the other does type inference on Obj-C generics and report type; // errors.; //; // Dynamic Type Propagation:; // This checker defines the rules for dynamic type gathering and propagation.; //; // Generics Checker for Objective-C:; // This checker tries to find type errors that the compiler is not able to catch; // due to the implicit conversions that were introduced for backward; // compatibility.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:738,Availability,error,errors,738,"//===- DynamicTypePropagation.cpp ------------------------------*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains two checkers. One helps the static analyzer core to track; // types, the other does type inference on Obj-C generics and report type; // errors.; //; // Dynamic Type Propagation:; // This checker defines the rules for dynamic type gathering and propagation.; //; // Generics Checker for Objective-C:; // This checker tries to find type errors that the compiler is not able to catch; // due to the implicit conversions that were introduced for backward; // compatibility.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:107,Integrability,message,message,107,// Check if we can statically infer the actual type precisely.; //; // 1. Class is written directly in the message:; // \code; // [ActualClass classMethod];; // \endcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:80,Modifiability,variab,variable,80,"// Another way we can guess what is in Class object, is when it is a; // 'self' variable of the current class method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:151,Integrability,message,message,151,// We assume that the type of the object returned by alloc and new are the; // pointer to the object of the class specified in the receiver of the; // message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:171,Integrability,depend,depends,171,"// We used to assume that whatever type we got from inferring the; // type is actually precise (and it is not exactly correct).; // A big portion of the existing behavior depends on that assumption; // (e.g. certain inlining won't take place). For this reason, we don't; // use ObjTy.Precise flag here.; //; // TODO: We should mitigate this problem some time in the future; // and replace hardcoded 'false' with '!ObjTy.Precise'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:18,Usability,undo,undo,18,// We may need to undo the effects of our pre-call check.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:314,Availability,avail,available,314,"// FIXME: In C++17 classes with non-virtual bases may be treated as; // aggregates, and in such case no top-frame constructor will be called.; // Figure out if we need to do anything in this case.; // FIXME: Instead of relying on the ParentMap, we should have the; // trigger-statement (InitListExpr in this case) available in this; // callback, ideally as part of CallEvent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:198,Modifiability,inherit,inheritance,198,"// Return a better dynamic type if one can be derived from the cast.; // Compare the current dynamic type of the region and the new type to which we; // are casting. If the new type is lower in the inheritance hierarchy, pick it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:6,Availability,down,downcast,6,"/// A downcast may loose specialization information. E. g.:; /// MutableMap<T, U> : Map; /// The downcast to MutableMap looses the information about the types of the; /// Map (due to the type parameters are not being forwarded to Map), and in; /// general there is no way to recover that information from the; /// declaration. In order to have to most information, lets find the most; /// derived type that has all the type parameters forwarded.; ///; /// Get the a subclass of \p From (which has a lower bound \p To) that do not; /// loose information about type parameters. \p To has to be a subclass of; /// \p From. From has to be specialized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:97,Availability,down,downcast,97,"/// A downcast may loose specialization information. E. g.:; /// MutableMap<T, U> : Map; /// The downcast to MutableMap looses the information about the types of the; /// Map (due to the type parameters are not being forwarded to Map), and in; /// general there is no way to recover that information from the; /// declaration. In order to have to most information, lets find the most; /// derived type that has all the type parameters forwarded.; ///; /// Get the a subclass of \p From (which has a lower bound \p To) that do not; /// loose information about type parameters. \p To has to be a subclass of; /// \p From. From has to be specialized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:275,Availability,recover,recover,275,"/// A downcast may loose specialization information. E. g.:; /// MutableMap<T, U> : Map; /// The downcast to MutableMap looses the information about the types of the; /// Map (due to the type parameters are not being forwarded to Map), and in; /// general there is no way to recover that information from the; /// declaration. In order to have to most information, lets find the most; /// derived type that has all the type parameters forwarded.; ///; /// Get the a subclass of \p From (which has a lower bound \p To) that do not; /// loose information about type parameters. \p To has to be a subclass of; /// \p From. From has to be specialized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:275,Safety,recover,recover,275,"/// A downcast may loose specialization information. E. g.:; /// MutableMap<T, U> : Map; /// The downcast to MutableMap looses the information about the types of the; /// Map (due to the type parameters are not being forwarded to Map), and in; /// general there is no way to recover that information from the; /// declaration. In order to have to most information, lets find the most; /// derived type that has all the type parameters forwarded.; ///; /// Get the a subclass of \p From (which has a lower bound \p To) that do not; /// loose information about type parameters. \p To has to be a subclass of; /// \p From. From has to be specialized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:498,Modifiability,rewrite,rewrite,498,"// TODO: The above 4 cases are not exhaustive. In particular, it is possible; // for Current to be incomparable with StaticLowerBound, StaticUpperBound,; // or both.; //; // For example, suppose Foo<T> and Bar<T> are unrelated types.; //; // Foo<T> *f = ...; // Bar<T> *b = ...; //; // id t1 = b;; // f = t1;; // id t2 = f; // StaticLowerBound is Foo<T>, Current is Bar<T>; //; // We should either constrain the callers of this function so that the stated; // preconditions hold (and assert it) or rewrite the function to expicitly; // handle the additional cases.; // Precondition",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:484,Testability,assert,assert,484,"// TODO: The above 4 cases are not exhaustive. In particular, it is possible; // for Current to be incomparable with StaticLowerBound, StaticUpperBound,; // or both.; //; // For example, suppose Foo<T> and Bar<T> are unrelated types.; //; // Foo<T> *f = ...; // Bar<T> *b = ...; //; // id t1 = b;; // f = t1;; // id t2 = f; // StaticLowerBound is Foo<T>, Current is Bar<T>; //; // We should either constrain the callers of this function so that the stated; // preconditions hold (and assert it) or rewrite the function to expicitly; // handle the additional cases.; // Precondition",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:61,Modifiability,inherit,inheritance,61,// The type arguments might not be forwarded at any point of inheritance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:60,Availability,avail,available,60,"/// Type inference based on static type information that is available for the; /// cast and the tracked type information for the given symbol. When the tracked; /// symbol and the destination type of the cast are unrelated, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:234,Availability,error,error,234,"/// Type inference based on static type information that is available for the; /// cast and the tracked type information for the given symbol. When the tracked; /// symbol and the destination type of the cast are unrelated, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:16,Safety,detect,detects,16,// This checker detects the subtyping relationships using the assignment; // rules. In order to be able to do this the kindofness must be stripped; // first. The checker treats every type as kindof type anyways: when the; // tracked type is the subtype of the static type it tries to look up the; // methods in the tracked type first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:493,Availability,down,down,493,"// Treat explicit casts as an indication from the programmer that the; // Objective-C type system is not rich enough to express the needed; // invariant. In such cases, forget any existing information inferred; // about the type arguments. We don't assume the casted-to specialized; // type here because the invariant the programmer specifies in the cast; // may only hold at this particular program point and not later ones.; // We don't want a suppressing cast to require a cascade of casts down the; // line.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:120,Availability,down,downcast,120,"// The tracked type should be the sub or super class of the static destination; // type. When an (implicit) upcast or a downcast happens according to static; // types, and there is no subtyping relationship between the tracked and the; // static destination types, it indicates an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:281,Availability,error,error,281,"// The tracked type should be the sub or super class of the static destination; // type. When an (implicit) upcast or a downcast happens according to static; // types, and there is no subtyping relationship between the tracked and the; // static destination types, it indicates an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:10,Availability,down,downcasts,10,// Handle downcasts and upcasts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:58,Integrability,interface,interface,58,// It is illegal to typedef parameterized types inside an interface. Therefore; // an Objective-C type can only be dependent on a type parameter when the type; // parameter structurally present in the type itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:115,Integrability,depend,dependent,115,// It is illegal to typedef parameterized types inside an interface. Therefore; // an Objective-C type can only be dependent on a type parameter when the type; // parameter structurally present in the type itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:28,Modifiability,parameteriz,parameterized,28,// It is illegal to typedef parameterized types inside an interface. Therefore; // an Objective-C type can only be dependent on a type parameter when the type; // parameter structurally present in the type itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:26,Availability,avail,available,26,"/// A method might not be available in the interface indicated by the static; /// type. However it might be available in the tracked type. In order to; /// properly substitute the type parameters we need the declaration context of; /// the method. The more specialized the enclosing class of the method is, the; /// more likely that the parameter substitution will be successful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:108,Availability,avail,available,108,"/// A method might not be available in the interface indicated by the static; /// type. However it might be available in the tracked type. In order to; /// properly substitute the type parameters we need the declaration context of; /// the method. The more specialized the enclosing class of the method is, the; /// more likely that the parameter substitution will be successful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:43,Integrability,interface,interface,43,"/// A method might not be available in the interface indicated by the static; /// type. However it might be available in the tracked type. In order to; /// properly substitute the type parameters we need the declaration context of; /// the method. The more specialized the enclosing class of the method is, the; /// more likely that the parameter substitution will be successful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:33,Integrability,depend,depends,33,// Check whether the result type depends on a type parameter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:95,Integrability,message,message,95,"/// When the receiver has a tracked type, use that type to validate the; /// argumments of the message expression and the return value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:59,Security,validat,validate,59,"/// When the receiver has a tracked type, use that type to validate the; /// argumments of the message expression and the return value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:129,Performance,perform,performing,129,"// If the method is declared on a class that has a non-invariant; // type parameter, don't warn about parameter mismatches after performing; // substitution. This prevents warning when the programmer has purposely; // casted the receiver to a super type or unspecialized type but the analyzer; // has a more precise tracked type than the programmer intends at the call; // site.; //; // For example, consider NSArray (which has a covariant type parameter); // and NSMutableArray (a subclass of NSArray where the type parameter is; // invariant):; // NSMutableArray *a = [[NSMutableArray<NSString *> alloc] init;; //; // [a containsObject:number]; // Safe: -containsObject is defined on NSArray.; // NSArray<NSObject *> *other = [a arrayByAddingObject:number] // Safe; //; // [a addObject:number] // Unsafe: -addObject: is defined on NSMutableArray; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:650,Safety,Safe,Safe,650,"// If the method is declared on a class that has a non-invariant; // type parameter, don't warn about parameter mismatches after performing; // substitution. This prevents warning when the programmer has purposely; // casted the receiver to a super type or unspecialized type but the analyzer; // has a more precise tracked type than the programmer intends at the call; // site.; //; // For example, consider NSArray (which has a covariant type parameter); // and NSMutableArray (a subclass of NSArray where the type parameter is; // invariant):; // NSMutableArray *a = [[NSMutableArray<NSString *> alloc] init;; //; // [a containsObject:number]; // Safe: -containsObject is defined on NSArray.; // NSArray<NSObject *> *other = [a arrayByAddingObject:number] // Safe; //; // [a addObject:number] // Unsafe: -addObject: is defined on NSMutableArray; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:762,Safety,Safe,Safe,762,"// If the method is declared on a class that has a non-invariant; // type parameter, don't warn about parameter mismatches after performing; // substitution. This prevents warning when the programmer has purposely; // casted the receiver to a super type or unspecialized type but the analyzer; // has a more precise tracked type than the programmer intends at the call; // site.; //; // For example, consider NSArray (which has a covariant type parameter); // and NSMutableArray (a subclass of NSArray where the type parameter is; // invariant):; // NSMutableArray *a = [[NSMutableArray<NSString *> alloc] init;; //; // [a containsObject:number]; // Safe: -containsObject is defined on NSArray.; // NSArray<NSObject *> *other = [a arrayByAddingObject:number] // Safe; //; // [a addObject:number] // Unsafe: -addObject: is defined on NSMutableArray; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:799,Safety,Unsafe,Unsafe,799,"// If the method is declared on a class that has a non-invariant; // type parameter, don't warn about parameter mismatches after performing; // substitution. This prevents warning when the programmer has purposely; // casted the receiver to a super type or unspecialized type but the analyzer; // has a more precise tracked type than the programmer intends at the call; // site.; //; // For example, consider NSArray (which has a covariant type parameter); // and NSMutableArray (a subclass of NSArray where the type parameter is; // invariant):; // NSMutableArray *a = [[NSMutableArray<NSString *> alloc] init;; //; // [a containsObject:number]; // Safe: -containsObject is defined on NSArray.; // NSArray<NSObject *> *other = [a arrayByAddingObject:number] // Safe; //; // [a addObject:number] // Unsafe: -addObject: is defined on NSMutableArray; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:436,Availability,error,errors,436,/// This callback is used to infer the types for Class variables. This info is; /// used later to validate messages that sent to classes. Class variables are; /// initialized with by invoking the 'class' method on a class.; /// This method is also used to infer the type information for the return; /// types.; // TODO: right now it only tracks generic types. Extend this to track every; // type in the DynamicTypeMap and diagnose type errors!,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:107,Integrability,message,messages,107,/// This callback is used to infer the types for Class variables. This info is; /// used later to validate messages that sent to classes. Class variables are; /// initialized with by invoking the 'class' method on a class.; /// This method is also used to infer the type information for the return; /// types.; // TODO: right now it only tracks generic types. Extend this to track every; // type in the DynamicTypeMap and diagnose type errors!,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:55,Modifiability,variab,variables,55,/// This callback is used to infer the types for Class variables. This info is; /// used later to validate messages that sent to classes. Class variables are; /// initialized with by invoking the 'class' method on a class.; /// This method is also used to infer the type information for the return; /// types.; // TODO: right now it only tracks generic types. Extend this to track every; // type in the DynamicTypeMap and diagnose type errors!,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:144,Modifiability,variab,variables,144,/// This callback is used to infer the types for Class variables. This info is; /// used later to validate messages that sent to classes. Class variables are; /// initialized with by invoking the 'class' method on a class.; /// This method is also used to infer the type information for the return; /// types.; // TODO: right now it only tracks generic types. Extend this to track every; // type in the DynamicTypeMap and diagnose type errors!,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:360,Modifiability,Extend,Extend,360,/// This callback is used to infer the types for Class variables. This info is; /// used later to validate messages that sent to classes. Class variables are; /// initialized with by invoking the 'class' method on a class.; /// This method is also used to infer the type information for the return; /// types.; // TODO: right now it only tracks generic types. Extend this to track every; // type in the DynamicTypeMap and diagnose type errors!,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:98,Security,validat,validate,98,/// This callback is used to infer the types for Class variables. This info is; /// used later to validate messages that sent to classes. Class variables are; /// initialized with by invoking the 'class' method on a class.; /// This method is also used to infer the type information for the return; /// types.; // TODO: right now it only tracks generic types. Extend this to track every; // type in the DynamicTypeMap and diagnose type errors!,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:66,Integrability,message,message,66,// We try to figure out the type from the receiver of the 'class' message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:75,Integrability,message,message,75,// We try to figure out the type from the receiver of the 'superclass'; // message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:160,Integrability,message,message,160,// Check if it really had super class.; //; // TODO: we can probably pay closer attention to cases when the class; // object can be 'nil' as the result of such message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:26,Availability,avail,available,26,"// When there is an entry available for the return symbol in DynamicTypeMap,; // the call was inlined, and the information in the DynamicTypeMap is should; // be precise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/EnumCastOutOfRangeChecker.cpp:29,Integrability,message,message,29,// Try to add details to the message:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/EnumCastOutOfRangeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/EnumCastOutOfRangeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/EnumCastOutOfRangeChecker.cpp:8,Performance,perform,perform,8,"// Only perform enum range check on casts where such checks are valid. For; // all other cast kinds (where enum range checks are unnecessary or invalid),; // just return immediately. TODO: The set of casts allowed for enum range; // checking may be incomplete. Better to add a missing cast kind to enable a; // missing check than to generate false negatives and have to remove those; // later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/EnumCastOutOfRangeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/EnumCastOutOfRangeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/EnumCastOutOfRangeChecker.cpp:143,Testability,stub,stub,143,"// If the cast is an enum, get its declaration.; // If the isEnumeralType() returned true, then the declaration must exist; // even if it is a stub declaration. It is up to the getDeclValuesForEnum(); // function to handle this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/EnumCastOutOfRangeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/EnumCastOutOfRangeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoChecker.cpp:424,Safety,detect,detect,424,"//=== ErrnoChecker.cpp ------------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines an ""errno checker"" that can detect some invalid use of the; // system-defined value 'errno'. This checker works together with the; // ErrnoModeling checker and other checkers like StdCLibraryFunctions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoChecker.cpp:25,Performance,load,load,25,"/// Indicates if a read (load) of \c errno is allowed in a non-condition part; /// of \c if, \c switch, loop and conditional statements when the errno; /// value may be undefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoChecker.cpp:32,Performance,load,load,32,"// 'errno' has to be checked. A load is required for this, with no more; // information we can assume that it is checked somehow.; // After this place 'errno' is allowed to be read and written.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoChecker.cpp:160,Safety,avoid,avoid,160,"// If 'errno' must be checked, it should be done as soon as possible, and; // before any other call to a system function (something in a system header).; // To avoid use of a long list of functions that may change 'errno'; // (which may be different with standard library versions) assume that any; // function can change it.; // A list of special functions can be used that are allowed here without; // generation of diagnostic. For now the only such case is 'errno' itself.; // Probably 'strerror'?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp:474,Availability,avail,available,474,"//=== ErrnoModeling.cpp -----------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines a checker `ErrnoModeling`, which is used to make the system; // value 'errno' available to other checkers.; // The 'errno' value is stored at a special memory region that is accessible; // through the `errno_modeling` namespace. The memory region is either the; // region of `errno` itself if it is a variable, otherwise an artifically; // created region (in the system memory space). If `errno` is defined by using; // a function which returns the address of it (this is always the case if it is; // not a variable) this function is recognized and evaluated. In this way; // `errno` becomes visible to the analysis and checkers can change its value.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp:697,Modifiability,variab,variable,697,"//=== ErrnoModeling.cpp -----------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines a checker `ErrnoModeling`, which is used to make the system; // value 'errno' available to other checkers.; // The 'errno' value is stored at a special memory region that is accessible; // through the `errno_modeling` namespace. The memory region is either the; // region of `errno` itself if it is a variable, otherwise an artifically; // created region (in the system memory space). If `errno` is defined by using; // a function which returns the address of it (this is always the case if it is; // not a variable) this function is recognized and evaluated. In this way; // `errno` becomes visible to the analysis and checkers can change its value.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp:903,Modifiability,variab,variable,903,"//=== ErrnoModeling.cpp -----------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines a checker `ErrnoModeling`, which is used to make the system; // value 'errno' available to other checkers.; // The 'errno' value is stored at a special memory region that is accessible; // through the `errno_modeling` namespace. The memory region is either the; // region of `errno` itself if it is a variable, otherwise an artifically; // created region (in the system memory space). If `errno` is defined by using; // a function which returns the address of it (this is always the case if it is; // not a variable) this function is recognized and evaluated. In this way; // `errno` becomes visible to the analysis and checkers can change its value.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp:570,Security,access,accessible,570,"//=== ErrnoModeling.cpp -----------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines a checker `ErrnoModeling`, which is used to make the system; // value 'errno' available to other checkers.; // The 'errno' value is stored at a special memory region that is accessible; // through the `errno_modeling` namespace. The memory region is either the; // region of `errno` itself if it is a variable, otherwise an artifically; // created region (in the system memory space). If `errno` is defined by using; // a function which returns the address of it (this is always the case if it is; // not a variable) this function is recognized and evaluated. In this way; // `errno` becomes visible to the analysis and checkers can change its value.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp:23,Modifiability,variab,variable,23,"// Name of the ""errno"" variable.; // FIXME: Is there a system where it is not called ""errno"" but is a variable?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp:102,Modifiability,variab,variable,102,"// Name of the ""errno"" variable.; // FIXME: Is there a system where it is not called ""errno"" but is a variable?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp:33,Modifiability,variab,variable,33,"// The declaration of an ""errno"" variable or ""errno location"" function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp:216,Integrability,depend,dependent,216,"// Try to find an usable `errno` value.; // It can be an external variable called ""errno"" or a function that returns a; // pointer to the ""errno"" value. This function can have different names.; // The actual case is dependent on the C library implementation, we; // can only search for a match in one of these variations.; // We assume that exactly one of these cases might be true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp:66,Modifiability,variab,variable,66,"// Try to find an usable `errno` value.; // It can be an external variable called ""errno"" or a function that returns a; // pointer to the ""errno"" value. This function can have different names.; // The actual case is dependent on the C library implementation, we; // can only search for a match in one of these variations.; // We assume that exactly one of these cases might be true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp:18,Usability,usab,usable,18,"// Try to find an usable `errno` value.; // It can be an external variable called ""errno"" or a function that returns a; // pointer to the ""errno"" value. This function can have different names.; // The actual case is dependent on the C library implementation, we; // can only search for a match in one of these variations.; // We assume that exactly one of these cases might be true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp:123,Energy Efficiency,allocate,allocated,123,// There is an external 'errno' variable.; // Use its memory region.; // The memory region for an 'errno'-like variable is allocated in system; // space by MemRegionManager.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp:32,Modifiability,variab,variable,32,// There is an external 'errno' variable.; // Use its memory region.; // The memory region for an 'errno'-like variable is allocated in system; // space by MemRegionManager.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp:111,Modifiability,variab,variable,111,// There is an external 'errno' variable.; // Use its memory region.; // The memory region for an 'errno'-like variable is allocated in system; // space by MemRegionManager.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp:53,Availability,avail,available,53,"// First set the errno value, the old state is still available at 'checkBind'; // or 'checkLocation' for errno value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.h:4,Usability,Clear,Clear,4,/// Clear state of errno (make it irrelevant).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.h:101,Modifiability,variab,variable,101,/// Determine if a `Decl` node related to 'errno'.; /// This is true if the declaration is the errno variable or a function; /// that returns a pointer to the 'errno' value (usually the 'errno' macro is; /// defined with this function). \p D is not required to be a canonical; /// declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.h:39,Integrability,message,message,39,"/// Create a NoteTag that displays the message if the 'errno' memory region is; /// marked as interesting, and resets the interestingness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.h:80,Availability,failure,failure,80,"/// Set errno state for the common case when a standard function indicates; /// failure only by \c errno. Sets \c ErrnoCheckState to \c MustBeChecked, and; /// invalidates the errno region (clear of previous value).; /// \arg \c InvalE Expression that causes invalidation of \c errno.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.h:190,Usability,clear,clear,190,"/// Set errno state for the common case when a standard function indicates; /// failure only by \c errno. Sets \c ErrnoCheckState to \c MustBeChecked, and; /// invalidates the errno region (clear of previous value).; /// \arg \c InvalE Expression that causes invalidation of \c errno.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp:433,Testability,test,test,433,"//=== ErrnoTesterChecker.cpp ------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines ErrnoTesterChecker, which is used to test functionality of the; // errno_check API.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp:160,Availability,failure,failure,160,/// Evaluate function \code int ErrnoTesterChecker_setErrnoIfError() \endcode.; /// Simulate a standard library function tha returns 0 on success and 1 on; /// failure. On the success case \c errno is not allowed to be used (may be; /// undefined). On the failure case \c errno is set to a fixed value 11 and; /// is not needed to be checked.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp:256,Availability,failure,failure,256,/// Evaluate function \code int ErrnoTesterChecker_setErrnoIfError() \endcode.; /// Simulate a standard library function tha returns 0 on success and 1 on; /// failure. On the success case \c errno is not allowed to be used (may be; /// undefined). On the failure case \c errno is set to a fixed value 11 and; /// is not needed to be checked.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp:194,Availability,failure,failure,194,/// Evaluate function \code int ErrnoTesterChecker_setErrnoIfErrorRange(); /// \endcode. Same as \c ErrnoTesterChecker_setErrnoIfError but \c errno is; /// set to a range (to be nonzero) at the failure case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp:338,Availability,error,error,338,"/// Evaluate function \code int ErrnoTesterChecker_setErrnoCheckState(); /// \endcode. This function simulates the following:; /// - Return 0 and leave \c errno with undefined value.; /// This is the case of a successful standard function call.; /// For example if \c ftell returns not -1.; /// - Return 1 and sets \c errno to a specific error code (1).; /// This is the case of a failed standard function call.; /// The function indicates the failure by a special return value; /// that is returned only at failure.; /// \c errno can be checked but it is not required.; /// For example if \c ftell returns -1.; /// - Return 2 and may set errno to a value (actually it does not set it).; /// This is the case of a standard function call where the failure can only; /// be checked by reading from \c errno. The value of \c errno is changed by; /// the function only at failure, the user should set \c errno to 0 before; /// the call (\c ErrnoChecker does not check for this rule).; /// \c strtol is an example of this case, if it returns \c LONG_MIN (or; /// \c LONG_MAX). This case applies only if \c LONG_MIN or \c LONG_MAX is; /// returned, otherwise the first case in this list applies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp:444,Availability,failure,failure,444,"/// Evaluate function \code int ErrnoTesterChecker_setErrnoCheckState(); /// \endcode. This function simulates the following:; /// - Return 0 and leave \c errno with undefined value.; /// This is the case of a successful standard function call.; /// For example if \c ftell returns not -1.; /// - Return 1 and sets \c errno to a specific error code (1).; /// This is the case of a failed standard function call.; /// The function indicates the failure by a special return value; /// that is returned only at failure.; /// \c errno can be checked but it is not required.; /// For example if \c ftell returns -1.; /// - Return 2 and may set errno to a value (actually it does not set it).; /// This is the case of a standard function call where the failure can only; /// be checked by reading from \c errno. The value of \c errno is changed by; /// the function only at failure, the user should set \c errno to 0 before; /// the call (\c ErrnoChecker does not check for this rule).; /// \c strtol is an example of this case, if it returns \c LONG_MIN (or; /// \c LONG_MAX). This case applies only if \c LONG_MIN or \c LONG_MAX is; /// returned, otherwise the first case in this list applies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp:508,Availability,failure,failure,508,"/// Evaluate function \code int ErrnoTesterChecker_setErrnoCheckState(); /// \endcode. This function simulates the following:; /// - Return 0 and leave \c errno with undefined value.; /// This is the case of a successful standard function call.; /// For example if \c ftell returns not -1.; /// - Return 1 and sets \c errno to a specific error code (1).; /// This is the case of a failed standard function call.; /// The function indicates the failure by a special return value; /// that is returned only at failure.; /// \c errno can be checked but it is not required.; /// For example if \c ftell returns -1.; /// - Return 2 and may set errno to a value (actually it does not set it).; /// This is the case of a standard function call where the failure can only; /// be checked by reading from \c errno. The value of \c errno is changed by; /// the function only at failure, the user should set \c errno to 0 before; /// the call (\c ErrnoChecker does not check for this rule).; /// \c strtol is an example of this case, if it returns \c LONG_MIN (or; /// \c LONG_MAX). This case applies only if \c LONG_MIN or \c LONG_MAX is; /// returned, otherwise the first case in this list applies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp:747,Availability,failure,failure,747,"/// Evaluate function \code int ErrnoTesterChecker_setErrnoCheckState(); /// \endcode. This function simulates the following:; /// - Return 0 and leave \c errno with undefined value.; /// This is the case of a successful standard function call.; /// For example if \c ftell returns not -1.; /// - Return 1 and sets \c errno to a specific error code (1).; /// This is the case of a failed standard function call.; /// The function indicates the failure by a special return value; /// that is returned only at failure.; /// \c errno can be checked but it is not required.; /// For example if \c ftell returns -1.; /// - Return 2 and may set errno to a value (actually it does not set it).; /// This is the case of a standard function call where the failure can only; /// be checked by reading from \c errno. The value of \c errno is changed by; /// the function only at failure, the user should set \c errno to 0 before; /// the call (\c ErrnoChecker does not check for this rule).; /// \c strtol is an example of this case, if it returns \c LONG_MIN (or; /// \c LONG_MAX). This case applies only if \c LONG_MIN or \c LONG_MAX is; /// returned, otherwise the first case in this list applies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp:868,Availability,failure,failure,868,"/// Evaluate function \code int ErrnoTesterChecker_setErrnoCheckState(); /// \endcode. This function simulates the following:; /// - Return 0 and leave \c errno with undefined value.; /// This is the case of a successful standard function call.; /// For example if \c ftell returns not -1.; /// - Return 1 and sets \c errno to a specific error code (1).; /// This is the case of a failed standard function call.; /// The function indicates the failure by a special return value; /// that is returned only at failure.; /// \c errno can be checked but it is not required.; /// For example if \c ftell returns -1.; /// - Return 2 and may set errno to a value (actually it does not set it).; /// This is the case of a standard function call where the failure can only; /// be checked by reading from \c errno. The value of \c errno is changed by; /// the function only at failure, the user should set \c errno to 0 before; /// the call (\c ErrnoChecker does not check for this rule).; /// \c strtol is an example of this case, if it returns \c LONG_MIN (or; /// \c LONG_MAX). This case applies only if \c LONG_MIN or \c LONG_MAX is; /// returned, otherwise the first case in this list applies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ExprInspectionChecker.cpp:54,Testability,test,tests,54,"//==- ExprInspectionChecker.cpp - Used for regression tests ------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ExprInspectionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ExprInspectionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ExprInspectionChecker.cpp:123,Integrability,message,message,123,"// An inlined function could conceivably also be analyzed as a top-level; // function. We ignore this case and only emit a message (TRUE or FALSE); // when we are analyzing it as an inlined function. This means that; // clang_analyzer_checkInlined(true) should always print TRUE, but; // clang_analyzer_checkInlined(false) should never actually print anything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ExprInspectionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ExprInspectionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ExprInspectionChecker.cpp:17,Availability,error,error,17,// The non-fatal error node should be the same for all reports.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ExprInspectionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ExprInspectionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FixedAddressChecker.cpp:32,Modifiability,portab,portable,32,// Using a fixed address is not portable because that address will probably; // not be valid in all environments or platforms.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FixedAddressChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FixedAddressChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp:523,Deployability,release,released,523,"//=== FuchsiaHandleChecker.cpp - Find handle leaks/double closes -*- C++ -*--=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker checks if the handle of Fuchsia is properly used according to; // following rules.; // - If a handle is acquired, it should be released before execution; // ends.; // - If a handle is released, it should not be released again.; // - If a handle is released, it should not be used for other purposes; // such as I/O.; //; // In this checker, each tracked handle is associated with a state. When the; // handle variable is passed to different function calls or syscalls, its state; // changes. The state changes can be generally represented by following ASCII; // Art:; //; //; // +-------------+ +------------+; // acquire_func succeeded | | Escape | |; // +-----------------> Allocated +---------> Escaped <--+; // | | | | | |; // | +-----+------++ +------------+ |; // | | | |; // acquire_func | release_func | +--+ |; // failed | | | handle +--------+ |; // +---------+ | | | dies | | |; // | | | +----v-----+ +---------> Leaked | |; // | | | | | |(REPORT)| |; // | +----------+--+ | Released | Escape +--------+ |; // | | | | +---------------------------+; // +--> Not tracked | +----+---+-+; // | | | | As argument by value; // +----------+--+ release_func | +------+ in function call; // | | | or by reference in; // | | | use_func call; // unowned | +----v-----+ | +-----------+; // acquire_func | | Double | +-----> Use after |; // succeeded | | released | | released |; // | | (REPORT) | | (REPORT) |; // +---------------+ +----------+ +-----------+; // | Allocated |; // | Unowned | release_func; // | +---------+; // +---------------+ |; // |; // +-----v----------+; // | Release of |; // | unow",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp:580,Deployability,release,released,580,"//=== FuchsiaHandleChecker.cpp - Find handle leaks/double closes -*- C++ -*--=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker checks if the handle of Fuchsia is properly used according to; // following rules.; // - If a handle is acquired, it should be released before execution; // ends.; // - If a handle is released, it should not be released again.; // - If a handle is released, it should not be used for other purposes; // such as I/O.; //; // In this checker, each tracked handle is associated with a state. When the; // handle variable is passed to different function calls or syscalls, its state; // changes. The state changes can be generally represented by following ASCII; // Art:; //; //; // +-------------+ +------------+; // acquire_func succeeded | | Escape | |; // +-----------------> Allocated +---------> Escaped <--+; // | | | | | |; // | +-----+------++ +------------+ |; // | | | |; // acquire_func | release_func | +--+ |; // failed | | | handle +--------+ |; // +---------+ | | | dies | | |; // | | | +----v-----+ +---------> Leaked | |; // | | | | | |(REPORT)| |; // | +----------+--+ | Released | Escape +--------+ |; // | | | | +---------------------------+; // +--> Not tracked | +----+---+-+; // | | | | As argument by value; // +----------+--+ release_func | +------+ in function call; // | | | or by reference in; // | | | use_func call; // unowned | +----v-----+ | +-----------+; // acquire_func | | Double | +-----> Use after |; // succeeded | | released | | released |; // | | (REPORT) | | (REPORT) |; // +---------------+ +----------+ +-----------+; // | Allocated |; // | Unowned | release_func; // | +---------+; // +---------------+ |; // |; // +-----v----------+; // | Release of |; // | unow",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp:607,Deployability,release,released,607,"//=== FuchsiaHandleChecker.cpp - Find handle leaks/double closes -*- C++ -*--=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker checks if the handle of Fuchsia is properly used according to; // following rules.; // - If a handle is acquired, it should be released before execution; // ends.; // - If a handle is released, it should not be released again.; // - If a handle is released, it should not be used for other purposes; // such as I/O.; //; // In this checker, each tracked handle is associated with a state. When the; // handle variable is passed to different function calls or syscalls, its state; // changes. The state changes can be generally represented by following ASCII; // Art:; //; //; // +-------------+ +------------+; // acquire_func succeeded | | Escape | |; // +-----------------> Allocated +---------> Escaped <--+; // | | | | | |; // | +-----+------++ +------------+ |; // | | | |; // acquire_func | release_func | +--+ |; // failed | | | handle +--------+ |; // +---------+ | | | dies | | |; // | | | +----v-----+ +---------> Leaked | |; // | | | | | |(REPORT)| |; // | +----------+--+ | Released | Escape +--------+ |; // | | | | +---------------------------+; // +--> Not tracked | +----+---+-+; // | | | | As argument by value; // +----------+--+ release_func | +------+ in function call; // | | | or by reference in; // | | | use_func call; // unowned | +----v-----+ | +-----------+; // acquire_func | | Double | +-----> Use after |; // succeeded | | released | | released |; // | | (REPORT) | | (REPORT) |; // +---------------+ +----------+ +-----------+; // | Allocated |; // | Unowned | release_func; // | +---------+; // +---------------+ |; // |; // +-----v----------+; // | Release of |; // | unow",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp:644,Deployability,release,released,644,"//=== FuchsiaHandleChecker.cpp - Find handle leaks/double closes -*- C++ -*--=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker checks if the handle of Fuchsia is properly used according to; // following rules.; // - If a handle is acquired, it should be released before execution; // ends.; // - If a handle is released, it should not be released again.; // - If a handle is released, it should not be used for other purposes; // such as I/O.; //; // In this checker, each tracked handle is associated with a state. When the; // handle variable is passed to different function calls or syscalls, its state; // changes. The state changes can be generally represented by following ASCII; // Art:; //; //; // +-------------+ +------------+; // acquire_func succeeded | | Escape | |; // +-----------------> Allocated +---------> Escaped <--+; // | | | | | |; // | +-----+------++ +------------+ |; // | | | |; // acquire_func | release_func | +--+ |; // failed | | | handle +--------+ |; // +---------+ | | | dies | | |; // | | | +----v-----+ +---------> Leaked | |; // | | | | | |(REPORT)| |; // | +----------+--+ | Released | Escape +--------+ |; // | | | | +---------------------------+; // +--> Not tracked | +----+---+-+; // | | | | As argument by value; // +----------+--+ release_func | +------+ in function call; // | | | or by reference in; // | | | use_func call; // unowned | +----v-----+ | +-----------+; // acquire_func | | Double | +-----> Use after |; // succeeded | | released | | released |; // | | (REPORT) | | (REPORT) |; // +---------------+ +----------+ +-----------+; // | Allocated |; // | Unowned | release_func; // | +---------+; // +---------------+ |; // |; // +-----v----------+; // | Release of |; // | unow",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp:1382,Deployability,Release,Released,1382," should be released before execution; // ends.; // - If a handle is released, it should not be released again.; // - If a handle is released, it should not be used for other purposes; // such as I/O.; //; // In this checker, each tracked handle is associated with a state. When the; // handle variable is passed to different function calls or syscalls, its state; // changes. The state changes can be generally represented by following ASCII; // Art:; //; //; // +-------------+ +------------+; // acquire_func succeeded | | Escape | |; // +-----------------> Allocated +---------> Escaped <--+; // | | | | | |; // | +-----+------++ +------------+ |; // | | | |; // acquire_func | release_func | +--+ |; // failed | | | handle +--------+ |; // +---------+ | | | dies | | |; // | | | +----v-----+ +---------> Leaked | |; // | | | | | |(REPORT)| |; // | +----------+--+ | Released | Escape +--------+ |; // | | | | +---------------------------+; // +--> Not tracked | +----+---+-+; // | | | | As argument by value; // +----------+--+ release_func | +------+ in function call; // | | | or by reference in; // | | | use_func call; // unowned | +----v-----+ | +-----------+; // acquire_func | | Double | +-----> Use after |; // succeeded | | released | | released |; // | | (REPORT) | | (REPORT) |; // +---------------+ +----------+ +-----------+; // | Allocated |; // | Unowned | release_func; // | +---------+; // +---------------+ |; // |; // +-----v----------+; // | Release of |; // | unowned handle |; // | (REPORT) |; // +----------------+; //; // acquire_func represents the functions or syscalls that may acquire a handle.; // release_func represents the functions or syscalls that may release a handle.; // use_func represents the functions or syscall that requires an open handle.; //; // If a tracked handle dies in ""Released"" or ""Not Tracked"" state, we assume it; // is properly used. Otherwise a bug and will be reported.; //; // Note that, the analyzer does not always know for sure if a fun",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp:1749,Deployability,release,released,1749," should be released before execution; // ends.; // - If a handle is released, it should not be released again.; // - If a handle is released, it should not be used for other purposes; // such as I/O.; //; // In this checker, each tracked handle is associated with a state. When the; // handle variable is passed to different function calls or syscalls, its state; // changes. The state changes can be generally represented by following ASCII; // Art:; //; //; // +-------------+ +------------+; // acquire_func succeeded | | Escape | |; // +-----------------> Allocated +---------> Escaped <--+; // | | | | | |; // | +-----+------++ +------------+ |; // | | | |; // acquire_func | release_func | +--+ |; // failed | | | handle +--------+ |; // +---------+ | | | dies | | |; // | | | +----v-----+ +---------> Leaked | |; // | | | | | |(REPORT)| |; // | +----------+--+ | Released | Escape +--------+ |; // | | | | +---------------------------+; // +--> Not tracked | +----+---+-+; // | | | | As argument by value; // +----------+--+ release_func | +------+ in function call; // | | | or by reference in; // | | | use_func call; // unowned | +----v-----+ | +-----------+; // acquire_func | | Double | +-----> Use after |; // succeeded | | released | | released |; // | | (REPORT) | | (REPORT) |; // +---------------+ +----------+ +-----------+; // | Allocated |; // | Unowned | release_func; // | +---------+; // +---------------+ |; // |; // +-----v----------+; // | Release of |; // | unowned handle |; // | (REPORT) |; // +----------------+; //; // acquire_func represents the functions or syscalls that may acquire a handle.; // release_func represents the functions or syscalls that may release a handle.; // use_func represents the functions or syscall that requires an open handle.; //; // If a tracked handle dies in ""Released"" or ""Not Tracked"" state, we assume it; // is properly used. Otherwise a bug and will be reported.; //; // Note that, the analyzer does not always know for sure if a fun",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp:1762,Deployability,release,released,1762," should be released before execution; // ends.; // - If a handle is released, it should not be released again.; // - If a handle is released, it should not be used for other purposes; // such as I/O.; //; // In this checker, each tracked handle is associated with a state. When the; // handle variable is passed to different function calls or syscalls, its state; // changes. The state changes can be generally represented by following ASCII; // Art:; //; //; // +-------------+ +------------+; // acquire_func succeeded | | Escape | |; // +-----------------> Allocated +---------> Escaped <--+; // | | | | | |; // | +-----+------++ +------------+ |; // | | | |; // acquire_func | release_func | +--+ |; // failed | | | handle +--------+ |; // +---------+ | | | dies | | |; // | | | +----v-----+ +---------> Leaked | |; // | | | | | |(REPORT)| |; // | +----------+--+ | Released | Escape +--------+ |; // | | | | +---------------------------+; // +--> Not tracked | +----+---+-+; // | | | | As argument by value; // +----------+--+ release_func | +------+ in function call; // | | | or by reference in; // | | | use_func call; // unowned | +----v-----+ | +-----------+; // acquire_func | | Double | +-----> Use after |; // succeeded | | released | | released |; // | | (REPORT) | | (REPORT) |; // +---------------+ +----------+ +-----------+; // | Allocated |; // | Unowned | release_func; // | +---------+; // +---------------+ |; // |; // +-----v----------+; // | Release of |; // | unowned handle |; // | (REPORT) |; // +----------------+; //; // acquire_func represents the functions or syscalls that may acquire a handle.; // release_func represents the functions or syscalls that may release a handle.; // use_func represents the functions or syscall that requires an open handle.; //; // If a tracked handle dies in ""Released"" or ""Not Tracked"" state, we assume it; // is properly used. Otherwise a bug and will be reported.; //; // Note that, the analyzer does not always know for sure if a fun",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp:1978,Deployability,Release,Release,1978," should be released before execution; // ends.; // - If a handle is released, it should not be released again.; // - If a handle is released, it should not be used for other purposes; // such as I/O.; //; // In this checker, each tracked handle is associated with a state. When the; // handle variable is passed to different function calls or syscalls, its state; // changes. The state changes can be generally represented by following ASCII; // Art:; //; //; // +-------------+ +------------+; // acquire_func succeeded | | Escape | |; // +-----------------> Allocated +---------> Escaped <--+; // | | | | | |; // | +-----+------++ +------------+ |; // | | | |; // acquire_func | release_func | +--+ |; // failed | | | handle +--------+ |; // +---------+ | | | dies | | |; // | | | +----v-----+ +---------> Leaked | |; // | | | | | |(REPORT)| |; // | +----------+--+ | Released | Escape +--------+ |; // | | | | +---------------------------+; // +--> Not tracked | +----+---+-+; // | | | | As argument by value; // +----------+--+ release_func | +------+ in function call; // | | | or by reference in; // | | | use_func call; // unowned | +----v-----+ | +-----------+; // acquire_func | | Double | +-----> Use after |; // succeeded | | released | | released |; // | | (REPORT) | | (REPORT) |; // +---------------+ +----------+ +-----------+; // | Allocated |; // | Unowned | release_func; // | +---------+; // +---------------+ |; // |; // +-----v----------+; // | Release of |; // | unowned handle |; // | (REPORT) |; // +----------------+; //; // acquire_func represents the functions or syscalls that may acquire a handle.; // release_func represents the functions or syscalls that may release a handle.; // use_func represents the functions or syscall that requires an open handle.; //; // If a tracked handle dies in ""Released"" or ""Not Tracked"" state, we assume it; // is properly used. Otherwise a bug and will be reported.; //; // Note that, the analyzer does not always know for sure if a fun",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp:2202,Deployability,release,release,2202,"acquire_func | release_func | +--+ |; // failed | | | handle +--------+ |; // +---------+ | | | dies | | |; // | | | +----v-----+ +---------> Leaked | |; // | | | | | |(REPORT)| |; // | +----------+--+ | Released | Escape +--------+ |; // | | | | +---------------------------+; // +--> Not tracked | +----+---+-+; // | | | | As argument by value; // +----------+--+ release_func | +------+ in function call; // | | | or by reference in; // | | | use_func call; // unowned | +----v-----+ | +-----------+; // acquire_func | | Double | +-----> Use after |; // succeeded | | released | | released |; // | | (REPORT) | | (REPORT) |; // +---------------+ +----------+ +-----------+; // | Allocated |; // | Unowned | release_func; // | +---------+; // +---------------+ |; // |; // +-----v----------+; // | Release of |; // | unowned handle |; // | (REPORT) |; // +----------------+; //; // acquire_func represents the functions or syscalls that may acquire a handle.; // release_func represents the functions or syscalls that may release a handle.; // use_func represents the functions or syscall that requires an open handle.; //; // If a tracked handle dies in ""Released"" or ""Not Tracked"" state, we assume it; // is properly used. Otherwise a bug and will be reported.; //; // Note that, the analyzer does not always know for sure if a function failed; // or succeeded. In those cases we use the state MaybeAllocated.; // Thus, the diagram above captures the intent, not implementation details.; //; // Due to the fact that the number of handle related syscalls in Fuchsia; // is large, we adopt the annotation attributes to descript syscalls'; // operations(acquire/release/use) on handles instead of hardcoding; // everything in the checker.; //; // We use following annotation attributes for handle related syscalls or; // functions:; // 1. __attribute__((acquire_handle(""Fuchsia""))) |handle will be acquired; // 2. __attribute__((release_handle(""Fuchsia""))) |handle will be released; // 3. __attribute",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp:2336,Deployability,Release,Released,2336,"RT)| |; // | +----------+--+ | Released | Escape +--------+ |; // | | | | +---------------------------+; // +--> Not tracked | +----+---+-+; // | | | | As argument by value; // +----------+--+ release_func | +------+ in function call; // | | | or by reference in; // | | | use_func call; // unowned | +----v-----+ | +-----------+; // acquire_func | | Double | +-----> Use after |; // succeeded | | released | | released |; // | | (REPORT) | | (REPORT) |; // +---------------+ +----------+ +-----------+; // | Allocated |; // | Unowned | release_func; // | +---------+; // +---------------+ |; // |; // +-----v----------+; // | Release of |; // | unowned handle |; // | (REPORT) |; // +----------------+; //; // acquire_func represents the functions or syscalls that may acquire a handle.; // release_func represents the functions or syscalls that may release a handle.; // use_func represents the functions or syscall that requires an open handle.; //; // If a tracked handle dies in ""Released"" or ""Not Tracked"" state, we assume it; // is properly used. Otherwise a bug and will be reported.; //; // Note that, the analyzer does not always know for sure if a function failed; // or succeeded. In those cases we use the state MaybeAllocated.; // Thus, the diagram above captures the intent, not implementation details.; //; // Due to the fact that the number of handle related syscalls in Fuchsia; // is large, we adopt the annotation attributes to descript syscalls'; // operations(acquire/release/use) on handles instead of hardcoding; // everything in the checker.; //; // We use following annotation attributes for handle related syscalls or; // functions:; // 1. __attribute__((acquire_handle(""Fuchsia""))) |handle will be acquired; // 2. __attribute__((release_handle(""Fuchsia""))) |handle will be released; // 3. __attribute__((use_handle(""Fuchsia""))) |handle will not transit to; // escaped state, it also needs to be open.; //; // For example, an annotated syscall:; // zx_status_t zx_channel_c",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp:2841,Deployability,release,release,2841,"e | +-----> Use after |; // succeeded | | released | | released |; // | | (REPORT) | | (REPORT) |; // +---------------+ +----------+ +-----------+; // | Allocated |; // | Unowned | release_func; // | +---------+; // +---------------+ |; // |; // +-----v----------+; // | Release of |; // | unowned handle |; // | (REPORT) |; // +----------------+; //; // acquire_func represents the functions or syscalls that may acquire a handle.; // release_func represents the functions or syscalls that may release a handle.; // use_func represents the functions or syscall that requires an open handle.; //; // If a tracked handle dies in ""Released"" or ""Not Tracked"" state, we assume it; // is properly used. Otherwise a bug and will be reported.; //; // Note that, the analyzer does not always know for sure if a function failed; // or succeeded. In those cases we use the state MaybeAllocated.; // Thus, the diagram above captures the intent, not implementation details.; //; // Due to the fact that the number of handle related syscalls in Fuchsia; // is large, we adopt the annotation attributes to descript syscalls'; // operations(acquire/release/use) on handles instead of hardcoding; // everything in the checker.; //; // We use following annotation attributes for handle related syscalls or; // functions:; // 1. __attribute__((acquire_handle(""Fuchsia""))) |handle will be acquired; // 2. __attribute__((release_handle(""Fuchsia""))) |handle will be released; // 3. __attribute__((use_handle(""Fuchsia""))) |handle will not transit to; // escaped state, it also needs to be open.; //; // For example, an annotated syscall:; // zx_status_t zx_channel_create(; // uint32_t options,; // zx_handle_t* out0 __attribute__((acquire_handle(""Fuchsia""))) ,; // zx_handle_t* out1 __attribute__((acquire_handle(""Fuchsia""))));; // denotes a syscall which will acquire two handles and save them to 'out0' and; // 'out1' when succeeded.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp:3152,Deployability,release,released,3152,"e | +-----> Use after |; // succeeded | | released | | released |; // | | (REPORT) | | (REPORT) |; // +---------------+ +----------+ +-----------+; // | Allocated |; // | Unowned | release_func; // | +---------+; // +---------------+ |; // |; // +-----v----------+; // | Release of |; // | unowned handle |; // | (REPORT) |; // +----------------+; //; // acquire_func represents the functions or syscalls that may acquire a handle.; // release_func represents the functions or syscalls that may release a handle.; // use_func represents the functions or syscall that requires an open handle.; //; // If a tracked handle dies in ""Released"" or ""Not Tracked"" state, we assume it; // is properly used. Otherwise a bug and will be reported.; //; // Note that, the analyzer does not always know for sure if a function failed; // or succeeded. In those cases we use the state MaybeAllocated.; // Thus, the diagram above captures the intent, not implementation details.; //; // Due to the fact that the number of handle related syscalls in Fuchsia; // is large, we adopt the annotation attributes to descript syscalls'; // operations(acquire/release/use) on handles instead of hardcoding; // everything in the checker.; //; // We use following annotation attributes for handle related syscalls or; // functions:; // 1. __attribute__((acquire_handle(""Fuchsia""))) |handle will be acquired; // 2. __attribute__((release_handle(""Fuchsia""))) |handle will be released; // 3. __attribute__((use_handle(""Fuchsia""))) |handle will not transit to; // escaped state, it also needs to be open.; //; // For example, an annotated syscall:; // zx_status_t zx_channel_create(; // uint32_t options,; // zx_handle_t* out0 __attribute__((acquire_handle(""Fuchsia""))) ,; // zx_handle_t* out1 __attribute__((acquire_handle(""Fuchsia""))));; // denotes a syscall which will acquire two handles and save them to 'out0' and; // 'out1' when succeeded.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp:1072,Energy Efficiency,Allocate,Allocated,1072," should be released before execution; // ends.; // - If a handle is released, it should not be released again.; // - If a handle is released, it should not be used for other purposes; // such as I/O.; //; // In this checker, each tracked handle is associated with a state. When the; // handle variable is passed to different function calls or syscalls, its state; // changes. The state changes can be generally represented by following ASCII; // Art:; //; //; // +-------------+ +------------+; // acquire_func succeeded | | Escape | |; // +-----------------> Allocated +---------> Escaped <--+; // | | | | | |; // | +-----+------++ +------------+ |; // | | | |; // acquire_func | release_func | +--+ |; // failed | | | handle +--------+ |; // +---------+ | | | dies | | |; // | | | +----v-----+ +---------> Leaked | |; // | | | | | |(REPORT)| |; // | +----------+--+ | Released | Escape +--------+ |; // | | | | +---------------------------+; // +--> Not tracked | +----+---+-+; // | | | | As argument by value; // +----------+--+ release_func | +------+ in function call; // | | | or by reference in; // | | | use_func call; // unowned | +----v-----+ | +-----------+; // acquire_func | | Double | +-----> Use after |; // succeeded | | released | | released |; // | | (REPORT) | | (REPORT) |; // +---------------+ +----------+ +-----------+; // | Allocated |; // | Unowned | release_func; // | +---------+; // +---------------+ |; // |; // +-----v----------+; // | Release of |; // | unowned handle |; // | (REPORT) |; // +----------------+; //; // acquire_func represents the functions or syscalls that may acquire a handle.; // release_func represents the functions or syscalls that may release a handle.; // use_func represents the functions or syscall that requires an open handle.; //; // If a tracked handle dies in ""Released"" or ""Not Tracked"" state, we assume it; // is properly used. Otherwise a bug and will be reported.; //; // Note that, the analyzer does not always know for sure if a fun",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp:1860,Energy Efficiency,Allocate,Allocated,1860," should be released before execution; // ends.; // - If a handle is released, it should not be released again.; // - If a handle is released, it should not be used for other purposes; // such as I/O.; //; // In this checker, each tracked handle is associated with a state. When the; // handle variable is passed to different function calls or syscalls, its state; // changes. The state changes can be generally represented by following ASCII; // Art:; //; //; // +-------------+ +------------+; // acquire_func succeeded | | Escape | |; // +-----------------> Allocated +---------> Escaped <--+; // | | | | | |; // | +-----+------++ +------------+ |; // | | | |; // acquire_func | release_func | +--+ |; // failed | | | handle +--------+ |; // +---------+ | | | dies | | |; // | | | +----v-----+ +---------> Leaked | |; // | | | | | |(REPORT)| |; // | +----------+--+ | Released | Escape +--------+ |; // | | | | +---------------------------+; // +--> Not tracked | +----+---+-+; // | | | | As argument by value; // +----------+--+ release_func | +------+ in function call; // | | | or by reference in; // | | | use_func call; // unowned | +----v-----+ | +-----------+; // acquire_func | | Double | +-----> Use after |; // succeeded | | released | | released |; // | | (REPORT) | | (REPORT) |; // +---------------+ +----------+ +-----------+; // | Allocated |; // | Unowned | release_func; // | +---------+; // +---------------+ |; // |; // +-----v----------+; // | Release of |; // | unowned handle |; // | (REPORT) |; // +----------------+; //; // acquire_func represents the functions or syscalls that may acquire a handle.; // release_func represents the functions or syscalls that may release a handle.; // use_func represents the functions or syscall that requires an open handle.; //; // If a tracked handle dies in ""Released"" or ""Not Tracked"" state, we assume it; // is properly used. Otherwise a bug and will be reported.; //; // Note that, the analyzer does not always know for sure if a fun",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp:805,Modifiability,variab,variable,805,"//=== FuchsiaHandleChecker.cpp - Find handle leaks/double closes -*- C++ -*--=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker checks if the handle of Fuchsia is properly used according to; // following rules.; // - If a handle is acquired, it should be released before execution; // ends.; // - If a handle is released, it should not be released again.; // - If a handle is released, it should not be used for other purposes; // such as I/O.; //; // In this checker, each tracked handle is associated with a state. When the; // handle variable is passed to different function calls or syscalls, its state; // changes. The state changes can be generally represented by following ASCII; // Art:; //; //; // +-------------+ +------------+; // acquire_func succeeded | | Escape | |; // +-----------------> Allocated +---------> Escaped <--+; // | | | | | |; // | +-----+------++ +------------+ |; // | | | |; // acquire_func | release_func | +--+ |; // failed | | | handle +--------+ |; // +---------+ | | | dies | | |; // | | | +----v-----+ +---------> Leaked | |; // | | | | | |(REPORT)| |; // | +----------+--+ | Released | Escape +--------+ |; // | | | | +---------------------------+; // +--> Not tracked | +----+---+-+; // | | | | As argument by value; // +----------+--+ release_func | +------+ in function call; // | | | or by reference in; // | | | use_func call; // unowned | +----v-----+ | +-----------+; // acquire_func | | Double | +-----> Use after |; // succeeded | | released | | released |; // | | (REPORT) | | (REPORT) |; // +---------------+ +----------+ +-----------+; // | Allocated |; // | Unowned | release_func; // | +---------+; // +---------------+ |; // |; // +-----v----------+; // | Release of |; // | unow",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp:93,Availability,checkPoint,checkPointerEscape,93,"// Working around integer by-value escapes.; // The by-value escape would not be captured in checkPointerEscape.; // If the function was not analyzed (otherwise wasInlined should be; // true) and there is no annotation on the handle, we assume the handle; // is escaped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp:46,Availability,error,error,46,// Keeping zombie handle symbols. In case the error symbol is dying later; // than the handle symbol we might produce spurious leak warnings (in case; // we find out later from the status code that the handle allocation failed; // in the first place).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp:597,Deployability,release,release,597,"// Acquiring a handle is not always successful. In Fuchsia most functions; // return a status code that determines the status of the handle.; // When we split the path based on this status code we know that on one; // path we do have the handle and on the other path the acquire failed.; // This method helps avoiding false positive leak warnings on paths where; // the function failed.; // Moreover, when a handle is known to be zero (the invalid handle),; // we no longer can follow the symbol on the path, becaue the constant; // zero will be used instead of the symbol. We also do not need to release; // an invalid handle, so we remove the corresponding symbol from the state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp:309,Safety,avoid,avoiding,309,"// Acquiring a handle is not always successful. In Fuchsia most functions; // return a status code that determines the status of the handle.; // When we split the path based on this status code we know that on one; // path we do have the handle and on the other path the acquire failed.; // This method helps avoiding false positive leak warnings on paths where; // the function failed.; // Moreover, when a handle is known to be zero (the invalid handle),; // we no longer can follow the symbol on the path, becaue the constant; // zero will be used instead of the symbol. We also do not need to release; // an invalid handle, so we remove the corresponding symbol from the state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp:950,Availability,avail,available,950,"//===- GCDAntipatternChecker.cpp ---------------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines GCDAntipatternChecker which checks against a common; // antipattern when synchronous API is emulated from asynchronous callbacks; // using a semaphore:; //; // dispatch_semaphore_t sema = dispatch_semaphore_create(0);; //; // AnyCFunctionCall(^{; // // code; // dispatch_semaphore_signal(sema);; // }); // dispatch_semaphore_wait(sema, *); //; // Such code is a common performance problem, due to inability of GCD to; // properly handle QoS when a combination of queues and semaphores is used.; // Good code would either use asynchronous API (when available), or perform; // the necessary action in asynchronous callback.; //; // Currently, the check is performed using a simple heuristical AST pattern; // matching.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp:771,Performance,perform,performance,771,"//===- GCDAntipatternChecker.cpp ---------------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines GCDAntipatternChecker which checks against a common; // antipattern when synchronous API is emulated from asynchronous callbacks; // using a semaphore:; //; // dispatch_semaphore_t sema = dispatch_semaphore_create(0);; //; // AnyCFunctionCall(^{; // // code; // dispatch_semaphore_signal(sema);; // }); // dispatch_semaphore_wait(sema, *); //; // Such code is a common performance problem, due to inability of GCD to; // properly handle QoS when a combination of queues and semaphores is used.; // Good code would either use asynchronous API (when available), or perform; // the necessary action in asynchronous callback.; //; // Currently, the check is performed using a simple heuristical AST pattern; // matching.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp:865,Performance,queue,queues,865,"//===- GCDAntipatternChecker.cpp ---------------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines GCDAntipatternChecker which checks against a common; // antipattern when synchronous API is emulated from asynchronous callbacks; // using a semaphore:; //; // dispatch_semaphore_t sema = dispatch_semaphore_create(0);; //; // AnyCFunctionCall(^{; // // code; // dispatch_semaphore_signal(sema);; // }); // dispatch_semaphore_wait(sema, *); //; // Such code is a common performance problem, due to inability of GCD to; // properly handle QoS when a combination of queues and semaphores is used.; // Good code would either use asynchronous API (when available), or perform; // the necessary action in asynchronous callback.; //; // Currently, the check is performed using a simple heuristical AST pattern; // matching.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp:965,Performance,perform,perform,965,"//===- GCDAntipatternChecker.cpp ---------------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines GCDAntipatternChecker which checks against a common; // antipattern when synchronous API is emulated from asynchronous callbacks; // using a semaphore:; //; // dispatch_semaphore_t sema = dispatch_semaphore_create(0);; //; // AnyCFunctionCall(^{; // // code; // dispatch_semaphore_signal(sema);; // }); // dispatch_semaphore_wait(sema, *); //; // Such code is a common performance problem, due to inability of GCD to; // properly handle QoS when a combination of queues and semaphores is used.; // Good code would either use asynchronous API (when available), or perform; // the necessary action in asynchronous callback.; //; // Currently, the check is performed using a simple heuristical AST pattern; // matching.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp:1056,Performance,perform,performed,1056,"//===- GCDAntipatternChecker.cpp ---------------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines GCDAntipatternChecker which checks against a common; // antipattern when synchronous API is emulated from asynchronous callbacks; // using a semaphore:; //; // dispatch_semaphore_t sema = dispatch_semaphore_create(0);; //; // AnyCFunctionCall(^{; // // code; // dispatch_semaphore_signal(sema);; // }); // dispatch_semaphore_wait(sema, *); //; // Such code is a common performance problem, due to inability of GCD to; // properly handle QoS when a combination of queues and semaphores is used.; // Good code would either use asynchronous API (when available), or perform; // the necessary action in asynchronous callback.; //; // Currently, the check is performed using a simple heuristical AST pattern; // matching.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp:1074,Usability,simpl,simple,1074,"//===- GCDAntipatternChecker.cpp ---------------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines GCDAntipatternChecker which checks against a common; // antipattern when synchronous API is emulated from asynchronous callbacks; // using a semaphore:; //; // dispatch_semaphore_t sema = dispatch_semaphore_create(0);; //; // AnyCFunctionCall(^{; // // code; // dispatch_semaphore_signal(sema);; // }); // dispatch_semaphore_wait(sema, *); //; // Such code is a common performance problem, due to inability of GCD to; // properly handle QoS when a combination of queues and semaphores is used.; // Good code would either use asynchronous API (when available), or perform; // the necessary action in asynchronous callback.; //; // Currently, the check is performed using a simple heuristical AST pattern; // matching.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp:102,Safety,detect,detecting,102,"/// The pattern is very common in tests, and it is OK to use it there.; /// We have to heuristics for detecting tests: method name starts with ""test""; /// (used in XCTest), and a class name contains ""mock"" or ""test"" (used in; /// helpers which are not tests themselves, but used exclusively in tests).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp:34,Testability,test,tests,34,"/// The pattern is very common in tests, and it is OK to use it there.; /// We have to heuristics for detecting tests: method name starts with ""test""; /// (used in XCTest), and a class name contains ""mock"" or ""test"" (used in; /// helpers which are not tests themselves, but used exclusively in tests).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp:112,Testability,test,tests,112,"/// The pattern is very common in tests, and it is OK to use it there.; /// We have to heuristics for detecting tests: method name starts with ""test""; /// (used in XCTest), and a class name contains ""mock"" or ""test"" (used in; /// helpers which are not tests themselves, but used exclusively in tests).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp:144,Testability,test,test,144,"/// The pattern is very common in tests, and it is OK to use it there.; /// We have to heuristics for detecting tests: method name starts with ""test""; /// (used in XCTest), and a class name contains ""mock"" or ""test"" (used in; /// helpers which are not tests themselves, but used exclusively in tests).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp:200,Testability,mock,mock,200,"/// The pattern is very common in tests, and it is OK to use it there.; /// We have to heuristics for detecting tests: method name starts with ""test""; /// (used in XCTest), and a class name contains ""mock"" or ""test"" (used in; /// helpers which are not tests themselves, but used exclusively in tests).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp:210,Testability,test,test,210,"/// The pattern is very common in tests, and it is OK to use it there.; /// We have to heuristics for detecting tests: method name starts with ""test""; /// (used in XCTest), and a class name contains ""mock"" or ""test"" (used in; /// helpers which are not tests themselves, but used exclusively in tests).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp:252,Testability,test,tests,252,"/// The pattern is very common in tests, and it is OK to use it there.; /// We have to heuristics for detecting tests: method name starts with ""test""; /// (used in XCTest), and a class name contains ""mock"" or ""test"" (used in; /// helpers which are not tests themselves, but used exclusively in tests).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp:294,Testability,test,tests,294,"/// The pattern is very common in tests, and it is OK to use it there.; /// We have to heuristics for detecting tests: method name starts with ""test""; /// (used in XCTest), and a class name contains ""mock"" or ""test"" (used in; /// helpers which are not tests themselves, but used exclusively in tests).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:574,Availability,error,errors,574,"//== GenericTaintChecker.cpp ----------------------------------- -*- C++ -*--=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker defines the attack surface for generic taint propagation.; //; // The taint information produced by it might be useful to other checkers. For; // example, checkers should report errors which involve tainted data more; // aggressively, even if the involved symbols are under constrained.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:408,Security,attack,attack,408,"//== GenericTaintChecker.cpp ----------------------------------- -*- C++ -*--=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker defines the attack surface for generic taint propagation.; //; // The taint information produced by it might be useful to other checkers. For; // example, checkers should report errors which involve tainted data more; // aggressively, even if the involved symbols are under constrained.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:93,Availability,Failure,Failure,93,"/// Check for:; /// CERT/STR02-C. ""Sanitize data passed to complex subsystems""; /// CWE-78, ""Failure to Sanitize Data into an OS Command""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:35,Security,Sanitiz,Sanitize,35,"/// Check for:; /// CERT/STR02-C. ""Sanitize data passed to complex subsystems""; /// CWE-78, ""Failure to Sanitize Data into an OS Command""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:104,Security,Sanitiz,Sanitize,104,"/// Check for:; /// CERT/STR02-C. ""Sanitize data passed to complex subsystems""; /// CWE-78, ""Failure to Sanitize Data into an OS Command""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:82,Modifiability,variab,variable,82,"// This region corresponds to a declaration, find out if it's a global/extern; // variable named stdin with the proper type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:60,Safety,detect,detection,60,/// ArgSet is used to describe arguments relevant for taint detection or; /// taint application. A discrete set of argument indexes and a variadic; /// argument list signified by a starting index are supported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:30,Security,sanitiz,sanitized,30,/// Arguments which should be sanitized on function return.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:6,Integrability,message,message,6,/// A message that explains why the call is sensitive to taint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:21,Security,sanitiz,sanitizes,21,/// Make a rule that sanitizes all FilterArgs arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:22,Deployability,configurat,configuration,22,/// Used to parse the configuration file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:22,Modifiability,config,configuration,22,/// Used to parse the configuration file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:25,Deployability,configurat,configuration,25,"/// Validate part of the configuration, which contains a list of argument; /// indexes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:25,Modifiability,config,configuration,25,"/// Validate part of the configuration, which contains a list of argument; /// indexes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:4,Security,Validat,Validate,4,"/// Validate part of the configuration, which contains a list of argument; /// indexes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:13,Modifiability,config,config,13,// Takes the config and creates a CallDescription for it and associates a Rule; // with that.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:81,Security,access,access,81,/// Default taint rules are initalized with the help of a CheckerContext to; /// access the names of built-in functions like memcpy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:293,Testability,log,logic,293,"/// CallDescription currently cannot restrict matches to the global namespace; /// only, which is why multiple CallDescriptionMaps are used, as we want to; /// disambiguate global C functions from functions inside user-defined; /// namespaces.; // TODO: Remove separation to simplify matching logic once CallDescriptions; // are more expressive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:275,Usability,simpl,simplify,275,"/// CallDescription currently cannot restrict matches to the global namespace; /// only, which is why multiple CallDescriptionMaps are used, as we want to; /// disambiguate global C functions from functions inside user-defined; /// namespaces.; // TODO: Remove separation to simplify matching logic once CallDescriptions; // are more expressive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:162,Usability,simpl,simpler,162,"// Sometimes the line between taint sources and propagators is blurry.; // _IO_getc is choosen to be a source, but could also be a propagator.; // This way it is simpler, as modeling it as a propagator would require; // to model the possible sources of _IO_FILE * values, which the _IO_getc; // function takes as parameters.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:23,Deployability,configurat,configuration,23,// User-provided taint configuration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:23,Modifiability,config,configuration,23,// User-provided taint configuration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:32,Modifiability,config,config,32,"// We don't have external taint config, no parsing required.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:30,Usability,simpl,simpler,30,// FIXME: this should be much simpler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:59,Security,access,accessible,59,// Set the marked values as tainted. The return value only accessible from; // checkPostStmt.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:3,Integrability,Depend,Depending,3,"// Depending on what was tainted at pre-visit, we determined a set of; // arguments which should be tainted after the function returns. These are; // stored in the state as TaintArgsOnPostVisit set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:3,Usability,Clear,Clear,3,// Clear up the taint info from the state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:79,Modifiability,variab,variables,79,"/// Check for taint propagation sources.; /// A rule will make the destination variables tainted if PropSrcArgs; /// is empty (taints the destination; /// arguments unconditionally), or if any of its signified; /// args are tainted in context of the current CallEvent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:35,Modifiability,variab,variable,35,// Taint property gets lost if the variable is passed as a; // non-const pointer or reference to a function which is; // not inlined. For matching rules we want to preserve the taintedness.; // TODO: We should traverse all reachable memory regions via the; // escaping parameter. Instead of doing that we simply mark only the; // referred memory region as tainted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:305,Usability,simpl,simply,305,// Taint property gets lost if the variable is passed as a; // non-const pointer or reference to a function which is; // not inlined. For matching rules we want to preserve the taintedness.; // TODO: We should traverse all reachable memory regions via the; // escaping parameter. Instead of doing that we simply mark only the; // referred memory region as tainted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:32,Integrability,protocol,protocols,32,// Allow internal communication protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:455,Safety,avoid,avoid,455,"//==- GTestChecker.cpp - Model gtest API --*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker models the behavior of un-inlined APIs from the gtest; // unit-testing library to avoid false positives when using assertions from; // that library.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:436,Testability,test,testing,436,"//==- GTestChecker.cpp - Model gtest API --*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker models the behavior of un-inlined APIs from the gtest; // unit-testing library to avoid false positives when using assertions from; // that library.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:488,Testability,assert,assertions,488,"//==- GTestChecker.cpp - Model gtest API --*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker models the behavior of un-inlined APIs from the gtest; // unit-testing library to avoid false positives when using assertions from; // that library.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:2106,Availability,reliab,reliably,2106,"tch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (because it is constructed into a temporary and the analyzer; // does not inline these since it does not yet reliably call temporary; // destructors).; //; // This checker compensates for the missing inlining by propagating the; // _success value across the bool and copy constructors so the assertion behaves; // as expected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:728,Integrability,Message,Message,728,"// Modeling of un-inlined AssertionResult constructors; //; // The gtest unit testing API provides macros for assertions that expand; // into an if statement that calls a series of constructors and returns; // when the ""assertion"" is false.; //; // For example,; //; // ASSERT_TRUE(a == b); //; // expands into:; //; // switch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (bec",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:26,Testability,Assert,AssertionResult,26,"// Modeling of un-inlined AssertionResult constructors; //; // The gtest unit testing API provides macros for assertions that expand; // into an if statement that calls a series of constructors and returns; // when the ""assertion"" is false.; //; // For example,; //; // ASSERT_TRUE(a == b); //; // expands into:; //; // switch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (bec",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:78,Testability,test,testing,78,"// Modeling of un-inlined AssertionResult constructors; //; // The gtest unit testing API provides macros for assertions that expand; // into an if statement that calls a series of constructors and returns; // when the ""assertion"" is false.; //; // For example,; //; // ASSERT_TRUE(a == b); //; // expands into:; //; // switch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (bec",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:110,Testability,assert,assertions,110,"// Modeling of un-inlined AssertionResult constructors; //; // The gtest unit testing API provides macros for assertions that expand; // into an if statement that calls a series of constructors and returns; // when the ""assertion"" is false.; //; // For example,; //; // ASSERT_TRUE(a == b); //; // expands into:; //; // switch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (bec",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:220,Testability,assert,assertion,220,"// Modeling of un-inlined AssertionResult constructors; //; // The gtest unit testing API provides macros for assertions that expand; // into an if statement that calls a series of constructors and returns; // when the ""assertion"" is false.; //; // For example,; //; // ASSERT_TRUE(a == b); //; // expands into:; //; // switch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (bec",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:372,Testability,test,testing,372,"// Modeling of un-inlined AssertionResult constructors; //; // The gtest unit testing API provides macros for assertions that expand; // into an if statement that calls a series of constructors and returns; // when the ""assertion"" is false.; //; // For example,; //; // ASSERT_TRUE(a == b); //; // expands into:; //; // switch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (bec",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:381,Testability,Assert,AssertionResult,381,"// Modeling of un-inlined AssertionResult constructors; //; // The gtest unit testing API provides macros for assertions that expand; // into an if statement that calls a series of constructors and returns; // when the ""assertion"" is false.; //; // For example,; //; // ASSERT_TRUE(a == b); //; // expands into:; //; // switch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (bec",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:415,Testability,test,testing,415,"// Modeling of un-inlined AssertionResult constructors; //; // The gtest unit testing API provides macros for assertions that expand; // into an if statement that calls a series of constructors and returns; // when the ""assertion"" is false.; //; // For example,; //; // ASSERT_TRUE(a == b); //; // expands into:; //; // switch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (bec",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:424,Testability,Assert,AssertionResult,424,"// Modeling of un-inlined AssertionResult constructors; //; // The gtest unit testing API provides macros for assertions that expand; // into an if statement that calls a series of constructors and returns; // when the ""assertion"" is false.; //; // For example,; //; // ASSERT_TRUE(a == b); //; // expands into:; //; // switch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (bec",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:479,Testability,test,testing,479,"// Modeling of un-inlined AssertionResult constructors; //; // The gtest unit testing API provides macros for assertions that expand; // into an if statement that calls a series of constructors and returns; // when the ""assertion"" is false.; //; // For example,; //; // ASSERT_TRUE(a == b); //; // expands into:; //; // switch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (bec",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:498,Testability,Assert,AssertHelper,498,"// Modeling of un-inlined AssertionResult constructors; //; // The gtest unit testing API provides macros for assertions that expand; // into an if statement that calls a series of constructors and returns; // when the ""assertion"" is false.; //; // For example,; //; // ASSERT_TRUE(a == b); //; // expands into:; //; // switch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (bec",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:518,Testability,test,testing,518,"// Modeling of un-inlined AssertionResult constructors; //; // The gtest unit testing API provides macros for assertions that expand; // into an if statement that calls a series of constructors and returns; // when the ""assertion"" is false.; //; // For example,; //; // ASSERT_TRUE(a == b); //; // expands into:; //; // switch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (bec",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:527,Testability,Test,TestPartResult,527,"// Modeling of un-inlined AssertionResult constructors; //; // The gtest unit testing API provides macros for assertions that expand; // into an if statement that calls a series of constructors and returns; // when the ""assertion"" is false.; //; // For example,; //; // ASSERT_TRUE(a == b); //; // expands into:; //; // switch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (bec",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:608,Testability,test,testing,608,"// Modeling of un-inlined AssertionResult constructors; //; // The gtest unit testing API provides macros for assertions that expand; // into an if statement that calls a series of constructors and returns; // when the ""assertion"" is false.; //; // For example,; //; // ASSERT_TRUE(a == b); //; // expands into:; //; // switch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (bec",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:719,Testability,test,testing,719,"// Modeling of un-inlined AssertionResult constructors; //; // The gtest unit testing API provides macros for assertions that expand; // into an if statement that calls a series of constructors and returns; // when the ""assertion"" is false.; //; // For example,; //; // ASSERT_TRUE(a == b); //; // expands into:; //; // switch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (bec",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:753,Testability,Assert,AssertionResult,753,"// Modeling of un-inlined AssertionResult constructors; //; // The gtest unit testing API provides macros for assertions that expand; // into an if statement that calls a series of constructors and returns; // when the ""assertion"" is false.; //; // For example,; //; // ASSERT_TRUE(a == b); //; // expands into:; //; // switch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (bec",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:807,Testability,Assert,AssertionResult,807,"// Modeling of un-inlined AssertionResult constructors; //; // The gtest unit testing API provides macros for assertions that expand; // into an if statement that calls a series of constructors and returns; // when the ""assertion"" is false.; //; // For example,; //; // ASSERT_TRUE(a == b); //; // expands into:; //; // switch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (bec",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:841,Testability,Assert,AssertionResult,841,"// Modeling of un-inlined AssertionResult constructors; //; // The gtest unit testing API provides macros for assertions that expand; // into an if statement that calls a series of constructors and returns; // when the ""assertion"" is false.; //; // For example,; //; // ASSERT_TRUE(a == b); //; // expands into:; //; // switch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (bec",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:863,Testability,Assert,AssertionResult,863,"// Modeling of un-inlined AssertionResult constructors; //; // The gtest unit testing API provides macros for assertions that expand; // into an if statement that calls a series of constructors and returns; // when the ""assertion"" is false.; //; // For example,; //; // ASSERT_TRUE(a == b); //; // expands into:; //; // switch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (bec",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:901,Testability,Assert,AssertionResult,901,"// Modeling of un-inlined AssertionResult constructors; //; // The gtest unit testing API provides macros for assertions that expand; // into an if statement that calls a series of constructors and returns; // when the ""assertion"" is false.; //; // For example,; //; // ASSERT_TRUE(a == b); //; // expands into:; //; // switch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (bec",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:1107,Testability,assert,assertion,1107," and returns; // when the ""assertion"" is false.; //; // For example,; //; // ASSERT_TRUE(a == b); //; // expands into:; //; // switch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (because it is constructed into a temporary and the analyzer; // does not inline these since it does not yet reliably call temporary; // destructors).; //; // This checker compensates for the miss",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:1240,Testability,Assert,AssertionResult,1240," and returns; // when the ""assertion"" is false.; //; // For example,; //; // ASSERT_TRUE(a == b); //; // expands into:; //; // switch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (because it is constructed into a temporary and the analyzer; // does not inline these since it does not yet reliably call temporary; // destructors).; //; // This checker compensates for the miss",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:1502,Testability,assert,assertion,1502,"tch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (because it is constructed into a temporary and the analyzer; // does not inline these since it does not yet reliably call temporary; // destructors).; //; // This checker compensates for the missing inlining by propagating the; // _success value across the bool and copy constructors so the assertion behaves; // as expected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:1746,Testability,ASSERT,ASSERT,1746,"tch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (because it is constructed into a temporary and the analyzer; // does not inline these since it does not yet reliably call temporary; // destructors).; //; // This checker compensates for the missing inlining by propagating the; // _success value across the bool and copy constructors so the assertion behaves; // as expected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:2289,Testability,assert,assertion,2289,"tch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (because it is constructed into a temporary and the analyzer; // does not inline these since it does not yet reliably call temporary; // destructors).; //; // This checker compensates for the missing inlining by propagating the; // _success value across the bool and copy constructors so the assertion behaves; // as expected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:63,Testability,Assert,AssertionResult,63,"// End anonymous namespace.; /// Model a call to an un-inlined AssertionResult(bool) or; /// AssertionResult(bool &, ...).; /// To do so, constrain the value of the newly-constructed instance's 'success_'; /// field to be equal to the passed-in boolean value.; ///; /// \param IsRef Whether the boolean parameter is a reference or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:93,Testability,Assert,AssertionResult,93,"// End anonymous namespace.; /// Model a call to an un-inlined AssertionResult(bool) or; /// AssertionResult(bool &, ...).; /// To do so, constrain the value of the newly-constructed instance's 'success_'; /// field to be equal to the passed-in boolean value.; ///; /// \param IsRef Whether the boolean parameter is a reference or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:35,Performance,load,load,35,"// The argument is a reference, so load from it to get the boolean value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:34,Testability,Assert,AssertionResult,34,"/// Model a call to an un-inlined AssertionResult copy constructor:; ///; /// AssertionResult(const &AssertionResult other); ///; /// To do so, constrain the value of the newly-constructed instance's; /// 'success_' field to be equal to the value of the pass-in instance's; /// 'success_' field.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:78,Testability,Assert,AssertionResult,78,"/// Model a call to an un-inlined AssertionResult copy constructor:; ///; /// AssertionResult(const &AssertionResult other); ///; /// To do so, constrain the value of the newly-constructed instance's; /// 'success_' field to be equal to the value of the pass-in instance's; /// 'success_' field.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:101,Testability,Assert,AssertionResult,101,"/// Model a call to an un-inlined AssertionResult copy constructor:; ///; /// AssertionResult(const &AssertionResult other); ///; /// To do so, constrain the value of the newly-constructed instance's; /// 'success_' field to be equal to the value of the pass-in instance's; /// 'success_' field.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:19,Testability,Assert,AssertionResult,19,/// Model calls to AssertionResult constructors that are not inlined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:94,Testability,Assert,AssertionResult,94,// Call the appropriate modeling method based the parameters and their; // types.; // We have AssertionResult(const &AssertionResult),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:117,Testability,Assert,AssertionResult,117,// Call the appropriate modeling method based the parameters and their; // types.; // We have AssertionResult(const &AssertionResult),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:48,Integrability,depend,depending,48,"// There are two possible boolean constructors, depending on which; // version of gtest is being used:; //; // v1.7 and earlier:; // AssertionResult(bool success); //; // v1.8 and greater:; // template <typename T>; // AssertionResult(const T& success,; // typename internal::EnableIf<; // !internal::ImplicitlyConvertible<T,; // AssertionResult>::value>::type*); //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:133,Testability,Assert,AssertionResult,133,"// There are two possible boolean constructors, depending on which; // version of gtest is being used:; //; // v1.7 and earlier:; // AssertionResult(bool success); //; // v1.8 and greater:; // template <typename T>; // AssertionResult(const T& success,; // typename internal::EnableIf<; // !internal::ImplicitlyConvertible<T,; // AssertionResult>::value>::type*); //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:219,Testability,Assert,AssertionResult,219,"// There are two possible boolean constructors, depending on which; // version of gtest is being used:; //; // v1.7 and earlier:; // AssertionResult(bool success); //; // v1.8 and greater:; // template <typename T>; // AssertionResult(const T& success,; // typename internal::EnableIf<; // !internal::ImplicitlyConvertible<T,; // AssertionResult>::value>::type*); //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:330,Testability,Assert,AssertionResult,330,"// There are two possible boolean constructors, depending on which; // version of gtest is being used:; //; // v1.7 and earlier:; // AssertionResult(bool success); //; // v1.8 and greater:; // template <typename T>; // AssertionResult(const T& success,; // typename internal::EnableIf<; // !internal::ImplicitlyConvertible<T,; // AssertionResult>::value>::type*); //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:11,Testability,Assert,AssertionResult,11,// We have AssertionResult(bool),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:11,Testability,Assert,AssertionResult,11,"// We have AssertionResult(bool &, ...)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:75,Testability,Assert,AssertionResult,75,/// Returns the value stored in the 'success_' field of the passed-in; /// AssertionResult instance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IdenticalExprChecker.cpp:320,Modifiability,variab,variables,320,"//; // Special case for floating-point representation.; //; // If expressions on both sides of comparison operator are of type float,; // then for some comparison operators no warning shall be; // reported even if the expressions are identical from a symbolic point of; // view. Comparison between expressions, declared variables and literals; // are treated differently.; //; // != and == between float literals that have the same value should NOT warn.; // < > between float literals that have the same value SHOULD warn.; //; // != and == between the same float declaration should NOT warn.; // < > between the same float declaration SHOULD warn.; //; // != and == between eq. expressions that evaluates into float; // should NOT warn.; // < > between eq. expressions that evaluates into float; // should NOT warn.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IdenticalExprChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IdenticalExprChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InnerPointerChecker.cpp:472,Deployability,release,released,472,"//=== InnerPointerChecker.cpp -------------------------------------*- C++ -*--//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a check that marks a raw pointer to a C++ container's; // inner buffer released when the object is destroyed. This information can; // be used by MallocChecker to detect use-after-free problems.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InnerPointerChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InnerPointerChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InnerPointerChecker.cpp:564,Safety,detect,detect,564,"//=== InnerPointerChecker.cpp -------------------------------------*- C++ -*--//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a check that marks a raw pointer to a C++ container's; // inner buffer released when the object is destroyed. This information can; // be used by MallocChecker to detect use-after-free problems.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InnerPointerChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InnerPointerChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InnerPointerChecker.cpp:65,Deployability,release,released,65,/// Mark pointer symbols associated with the given memory region released; /// in the program state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InnerPointerChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InnerPointerChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InnerPointerChecker.cpp:179,Deployability,release,released,179,/// Standard library functions that take a non-const `basic_string` argument by; /// reference may invalidate its inner pointers. Check for these cases and; /// mark the pointers released.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InnerPointerChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InnerPointerChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InnerPointerChecker.cpp:195,Deployability,release,released,195,/// Record the connection between raw pointers referring to a container; /// object's inner buffer and the object's memory region in the program state.; /// Mark potentially invalidated pointers released.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InnerPointerChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InnerPointerChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InnerPointerChecker.cpp:42,Security,access,access,42,"// NOTE: As of now, we only have one free access function: std::data.; // If we add more functions like this in the list, hardcoded; // argument index should be changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InnerPointerChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InnerPointerChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InterCheckerAPI.h:419,Integrability,depend,dependencies,419,"//==--- InterCheckerAPI.h ---------------------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This file allows introduction of checker dependencies. It contains APIs for; // inter-checker communications.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InterCheckerAPI.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InterCheckerAPI.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InterCheckerAPI.h:104,Security,expose,exposed,104,"// FIXME: This file goes against how a checker should be implemented either in; // a single file, or be exposed in a header file. Let's try to get rid of it!",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InterCheckerAPI.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InterCheckerAPI.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InvalidatedIteratorChecker.cpp:405,Security,access,access,405,"//===-- InvalidatedIteratorChecker.cpp ----------------------------*- C++ -*--//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Defines a checker for access of invalidated iterators.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InvalidatedIteratorChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InvalidatedIteratorChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InvalidatedIteratorChecker.cpp:13,Security,access,access,13,// Check for access of invalidated position,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InvalidatedIteratorChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InvalidatedIteratorChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InvalidatedIteratorChecker.cpp:25,Security,access,access,25,// Check for any kind of access of invalidated iterator positions,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InvalidatedIteratorChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InvalidatedIteratorChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Iterator.cpp:310,Performance,perform,perform,310,"// This function tells the analyzer's engine that symbols produced by our; // checker, most notably iterator positions, are relatively small.; // A distance between items in the container should not be very large.; // By assuming that it is within around 1/8 of the address space,; // we can help the analyzer perform operations on these symbols; // without being afraid of integer overflows.; // FIXME: Should we provide it as an API, so that all checkers could use it?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Iterator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Iterator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IteratorModeling.cpp:796,Availability,avail,available,796,"//===-- IteratorModeling.cpp --------------------------------------*- C++ -*--//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Defines a modeling-checker for modeling STL iterator-like iterators.; //; //===----------------------------------------------------------------------===//; //; // In the code, iterator can be represented as a:; // * type-I: typedef-ed pointer. Operations over such iterator, such as; // comparisons or increments, are modeled straightforwardly by the; // analyzer.; // * type-II: structure with its method bodies available. Operations over such; // iterator are inlined by the analyzer, and results of modeling; // these operations are exposing implementation details of the; // iterators, which is not necessarily helping.; // * type-III: completely opaque structure. Operations over such iterator are; // modeled conservatively, producing conjured symbols everywhere.; //; // To handle all these types in a common way we introduce a structure called; // IteratorPosition which is an abstraction of the position the iterator; // represents using symbolic expressions. The checker handles all the; // operations on this structure.; //; // Additionally, depending on the circumstances, operators of types II and III; // can be represented as:; // * type-IIa, type-IIIa: conjured structure symbols - when returned by value; // from conservatively evaluated methods such as; // `.begin()`.; // * type-IIb, type-IIIb: memory regions of iterator-typed objects, such as; // variables or temporaries, when the iterator object is; // currently treated as an lvalue.; // * type-IIc, type-IIIc: compound values of iterator-typed objects, when the; // iterator object is treated as an rvalue taken of a; // particular lvalue, eg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IteratorModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IteratorModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IteratorModeling.cpp:1436,Integrability,depend,depending,1436,"/; //; // In the code, iterator can be represented as a:; // * type-I: typedef-ed pointer. Operations over such iterator, such as; // comparisons or increments, are modeled straightforwardly by the; // analyzer.; // * type-II: structure with its method bodies available. Operations over such; // iterator are inlined by the analyzer, and results of modeling; // these operations are exposing implementation details of the; // iterators, which is not necessarily helping.; // * type-III: completely opaque structure. Operations over such iterator are; // modeled conservatively, producing conjured symbols everywhere.; //; // To handle all these types in a common way we introduce a structure called; // IteratorPosition which is an abstraction of the position the iterator; // represents using symbolic expressions. The checker handles all the; // operations on this structure.; //; // Additionally, depending on the circumstances, operators of types II and III; // can be represented as:; // * type-IIa, type-IIIa: conjured structure symbols - when returned by value; // from conservatively evaluated methods such as; // `.begin()`.; // * type-IIb, type-IIIb: memory regions of iterator-typed objects, such as; // variables or temporaries, when the iterator object is; // currently treated as an lvalue.; // * type-IIc, type-IIIc: compound values of iterator-typed objects, when the; // iterator object is treated as an rvalue taken of a; // particular lvalue, eg. a copy of ""type-a"" iterator; // object, or an iterator that existed before the; // analysis has started.; //; // To handle any of these three different representations stored in an SVal we; // use setter and getters functions which separate the three cases. To store; // them we use a pointer union of symbol and memory region.; //; // The checker works the following way: We record the begin and the; // past-end iterator for all containers whenever their `.begin()` and `.end()`; // are called. Since the Constraint Manager cannot ha",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IteratorModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IteratorModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IteratorModeling.cpp:1751,Modifiability,variab,variables,1751,"type-II: structure with its method bodies available. Operations over such; // iterator are inlined by the analyzer, and results of modeling; // these operations are exposing implementation details of the; // iterators, which is not necessarily helping.; // * type-III: completely opaque structure. Operations over such iterator are; // modeled conservatively, producing conjured symbols everywhere.; //; // To handle all these types in a common way we introduce a structure called; // IteratorPosition which is an abstraction of the position the iterator; // represents using symbolic expressions. The checker handles all the; // operations on this structure.; //; // Additionally, depending on the circumstances, operators of types II and III; // can be represented as:; // * type-IIa, type-IIIa: conjured structure symbols - when returned by value; // from conservatively evaluated methods such as; // `.begin()`.; // * type-IIb, type-IIIb: memory regions of iterator-typed objects, such as; // variables or temporaries, when the iterator object is; // currently treated as an lvalue.; // * type-IIc, type-IIIc: compound values of iterator-typed objects, when the; // iterator object is treated as an rvalue taken of a; // particular lvalue, eg. a copy of ""type-a"" iterator; // object, or an iterator that existed before the; // analysis has started.; //; // To handle any of these three different representations stored in an SVal we; // use setter and getters functions which separate the three cases. To store; // them we use a pointer union of symbol and memory region.; //; // The checker works the following way: We record the begin and the; // past-end iterator for all containers whenever their `.begin()` and `.end()`; // are called. Since the Constraint Manager cannot handle such SVals we need; // to take over its role. We post-check equality and non-equality comparisons; // and record that the two sides are equal if we are in the 'equal' branch; // (true-branch for `==` and false-bra",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IteratorModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IteratorModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IteratorModeling.cpp:3204,Usability,Simpl,SimpleConstraintManager,3204,"when returned by value; // from conservatively evaluated methods such as; // `.begin()`.; // * type-IIb, type-IIIb: memory regions of iterator-typed objects, such as; // variables or temporaries, when the iterator object is; // currently treated as an lvalue.; // * type-IIc, type-IIIc: compound values of iterator-typed objects, when the; // iterator object is treated as an rvalue taken of a; // particular lvalue, eg. a copy of ""type-a"" iterator; // object, or an iterator that existed before the; // analysis has started.; //; // To handle any of these three different representations stored in an SVal we; // use setter and getters functions which separate the three cases. To store; // them we use a pointer union of symbol and memory region.; //; // The checker works the following way: We record the begin and the; // past-end iterator for all containers whenever their `.begin()` and `.end()`; // are called. Since the Constraint Manager cannot handle such SVals we need; // to take over its role. We post-check equality and non-equality comparisons; // and record that the two sides are equal if we are in the 'equal' branch; // (true-branch for `==` and false-branch for `!=`).; //; // In case of type-I or type-II iterators we get a concrete integer as a result; // of the comparison (1 or 0) but in case of type-III we only get a Symbol. In; // this latter case we record the symbol and reload it in evalAssume() and do; // the propagation there. We also handle (maybe double) negated comparisons; // which are represented in the form of (x == 0 or x != 0) where x is the; // comparison itself.; //; // Since `SimpleConstraintManager` cannot handle complex symbolic expressions; // we only use expressions of the format S, S+n or S-n for iterator positions; // where S is a conjured symbol and n is an unsigned concrete integer. When; // making an assumption e.g. `S1 + n == S2 + m` we store `S1 - S2 == m - n` as; // a constraint which we later retrieve when doing an actual comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IteratorModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IteratorModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IteratorModeling.cpp:51,Availability,alive,alive,51,// Keep symbolic expressions of iterator positions alive,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IteratorModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IteratorModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IteratorModeling.cpp:365,Testability,assert,assertion,365,"// FIXME: `std::advance()` should not create a new iterator position but; // change existing ones. However, in case of iterators implemented as; // pointers the handling of parameters in `std::advance()`-like; // functions is still incomplete which may result in cases where; // the new position is assigned to the wrong pointer. This causes; // crash if we use an assertion here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IteratorModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IteratorModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IteratorRangeChecker.cpp:26,Security,access,access,26,// Check for out of range access,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IteratorRangeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IteratorRangeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:656,Modifiability,variab,variables,656,"//===- IvarInvalidationChecker.cpp ------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker implements annotation driven invalidation checking. If a class; // contains a method annotated with 'objc_instance_variable_invalidator',; // - (void) foo; // __attribute__((annotate(""objc_instance_variable_invalidator"")));; // all the ""ivalidatable"" instance variables of this class should be; // invalidated. We call an instance variable ivalidatable if it is an object of; // a class which contains an invalidation method. There could be multiple; // methods annotated with such annotations per class, either one can be used; // to invalidate the ivar. An ivar or property are considered to be; // invalidated if they are being assigned 'nil' or an invalidation method has; // been called on them. An invalidation method should either invalidate all; // the ivars or call another invalidation method (on self).; //; // Partial invalidor annotation allows to address cases when ivars are; // invalidated by other methods, which might or might not be called from; // the invalidation method. The checker checks that each invalidation; // method and all the partial methods cumulatively invalidate all ivars.; // __attribute__((annotate(""objc_instance_variable_invalidator_partial"")));; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:727,Modifiability,variab,variable,727,"//===- IvarInvalidationChecker.cpp ------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker implements annotation driven invalidation checking. If a class; // contains a method annotated with 'objc_instance_variable_invalidator',; // - (void) foo; // __attribute__((annotate(""objc_instance_variable_invalidator"")));; // all the ""ivalidatable"" instance variables of this class should be; // invalidated. We call an instance variable ivalidatable if it is an object of; // a class which contains an invalidation method. There could be multiple; // methods annotated with such annotations per class, either one can be used; // to invalidate the ivar. An ivar or property are considered to be; // invalidated if they are being assigned 'nil' or an invalidation method has; // been called on them. An invalidation method should either invalidate all; // the ivars or call another invalidation method (on self).; //; // Partial invalidor annotation allows to address cases when ivars are; // invalidated by other methods, which might or might not be called from; // the invalidation method. The checker checks that each invalidation; // method and all the partial methods cumulatively invalidate all ivars.; // __attribute__((annotate(""objc_instance_variable_invalidator_partial"")));; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:35,Integrability,message,message,35,/// Flag is set as the result of a message send to another; /// invalidation method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:110,Deployability,update,update,110,"/// Check if the any of the methods inside the interface are annotated with; /// the invalidation annotation, update the IvarInfo accordingly.; /// \param LookForPartial is set when we are searching for partial; /// invalidators.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:47,Integrability,interface,interface,47,"/// Check if the any of the methods inside the interface are annotated with; /// the invalidation annotation, update the IvarInfo accordingly.; /// \param LookForPartial is set when we are searching for partial; /// invalidators.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:25,Performance,perform,performed,25,/// Filter on the checks performed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:9,Performance,Cache,Cache,9,// TODO: Cache the results.; // Check all methods.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:6,Integrability,interface,interface,6,"// If interface, check all parent protocols and super.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:34,Integrability,protocol,protocols,34,"// If interface, check all parent protocols and super.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:13,Integrability,protocol,protocols,13,// Visit all protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:6,Integrability,protocol,protocol,6,"// If protocol, check all parent protocols.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:33,Integrability,protocol,protocols,33,"// If protocol, check all parent protocols.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:32,Integrability,interface,interfaces,32,// Check that the invalidatable interfaces with ivars/properties implement the; // invalidation methods.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:31,Security,Access,Accessor,31,// Construct Property/Property Accessor to Ivar maps to assist checking if an; // ivar which is backing a property has been reset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:42,Integrability,interface,interface,42,// Find all invalidation methods in this @interface declaration and parents.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:13,Availability,error,error,13,// Report an error in case none of the invalidation methods are declared.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:58,Security,validat,validation,58,"// If there are no invalidation methods, there is no ivar validation work; // to be done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:13,Availability,error,error,13,// Report an error in case none of the invalidation methods are implemented.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:59,Integrability,message,message,59,"// If InvalidationMethod is present, we are processing the message send and; // should ensure we are invalidating with the appropriate method,; // otherwise, we are processing setting to 'nil'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:56,Modifiability,variab,variable,56,"// Do we assign/compare against zero? If yes, check the variable we are; // assigning to.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:39,Integrability,rout,routine,39,// Check if we call the 'invalidation' routine on the ivar.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LLVMConventionsChecker.cpp:107,Integrability,rout,routines,107,//===----------------------------------------------------------------------===//; // Generic type checking routines.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LLVMConventionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LLVMConventionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LLVMConventionsChecker.cpp:28,Availability,error,error,28,"// Okay, badness! Report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LLVMConventionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LLVMConventionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LLVMConventionsChecker.cpp:140,Energy Efficiency,allocate,allocate,140,//===----------------------------------------------------------------------===//; // CHECK: Clang AST nodes should not have fields that can allocate; // memory.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LLVMConventionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LLVMConventionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp:25,Security,hash,hash,25,// LLVMs equivalent of a hash function,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp:164,Integrability,interface,interfaces,164,"/// Returns true when, heuristically, the analyzer may be analyzing debugging; /// code. We use this to suppress localization diagnostics in un-localized user; /// interfaces that are only used for debugging and are therefore not user; /// facing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp:27,Availability,error,error,27,/// Reports a localization error for the passed in method call and SVal,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp:33,Availability,error,errors,33,// Don't warn about localization errors in classes and methods that; // may be debug code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp:50,Integrability,protocol,protocols,50,// Go up each hierarchy of superclasses and their protocols,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp:113,Safety,avoid,avoid,113,// FIXME: We may be able to use PPCallbacks to check for empty context; // comments as part of preprocessing and avoid this re-lexing hack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp:33,Integrability,wrap,wrapped,33,"// If NSLocalizedString macro is wrapped in another macro, we need to; // unwrap the expansion until we get to the NSLocalizedStringMacro.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp:157,Modifiability,variab,variable,157,"// end anonymous namespace; // Checks the condition of the IfStmt and returns true if one; // of the following heuristics are met:; // 1) The conidtion is a variable with ""singular"" or ""plural"" in the name; // 2) The condition is a binary operator with 1 or 2 on the right-hand side",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:459,Energy Efficiency,allocate,allocated,459,"//==--- MacOSKeychainAPIChecker.cpp ------------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This checker flags misuses of KeyChainAPI. In particular, the password data; // allocated/returned by SecKeychainItemCopyContent,; // SecKeychainFindGenericPassword, SecKeychainFindInternetPassword functions has; // to be freed using a call to SecKeychainItemFreeContent.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:441,Security,password,password,441,"//==--- MacOSKeychainAPIChecker.cpp ------------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This checker flags misuses of KeyChainAPI. In particular, the password data; // allocated/returned by SecKeychainItemCopyContent,; // SecKeychainFindGenericPassword, SecKeychainFindInternetPassword functions has; // to be freed using a call to SecKeychainItemFreeContent.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:114,Energy Efficiency,allocate,allocated,114,/// AllocationState is a part of the checker specific state together with the; /// MemRegion corresponding to the allocated data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:28,Energy Efficiency,allocate,allocate,28,/// The functions which may allocate the data. These are tracked to reduce; /// the false alarm rate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:68,Energy Efficiency,reduce,reduce,68,/// The functions which may allocate the data. These are tracked to reduce; /// the false alarm rate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:35,Availability,error,error,35,"/// The value, which represents no error return value for allocator functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:7,Energy Efficiency,allocate,allocated,7,// The allocated region symbol tracked by the main analysis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:47,Energy Efficiency,allocate,allocated,47,/// ProgramState traits to store the currently allocated (and not yet freed); /// symbols. This is a map from the allocated content symbol to the; /// corresponding AllocationState.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:114,Energy Efficiency,allocate,allocated,114,/// ProgramState traits to store the currently allocated (and not yet freed); /// symbols. This is a map from the allocated content symbol to the; /// corresponding AllocationState.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:95,Availability,error,error,95,// Report deallocator mismatch. Remove the region from tracking - reporting a; // missing free error after this one is redundant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:119,Availability,redundant,redundant,119,// Report deallocator mismatch. Remove the region from tracking - reporting a; // missing free error after this one is redundant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:119,Safety,redund,redundant,119,// Report deallocator mismatch. Remove the region from tracking - reporting a; // missing free error after this one is redundant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:50,Energy Efficiency,allocate,allocated,50,"// The call is deallocating a value we previously allocated, so remove it; // from the next state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:23,Energy Efficiency,allocate,allocated,23,"// If a value has been allocated, add it to the set for tracking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:78,Safety,avoid,avoid,78,"// If the argument entered as an enclosing function parameter, skip it to; // avoid false positives.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:368,Availability,alive,alive,368,"// If the argument points to something that's not a symbolic region, it; // can be:; // - unknown (cannot reason about it); // - undefined (already reported by other checker); // - constant (null - should not be tracked,; // other constant will generate a compiler warning); // - goto (should be reported by other checker); // The call return value symbol should stay alive for as long as the; // allocated value symbol, since our diagnostics depend on the value; // returned by the call. Ex: Data should only be freed if noErr was; // returned during allocation.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:397,Energy Efficiency,allocate,allocated,397,"// If the argument points to something that's not a symbolic region, it; // can be:; // - unknown (cannot reason about it); // - undefined (already reported by other checker); // - constant (null - should not be tracked,; // other constant will generate a compiler warning); // - goto (should be reported by other checker); // The call return value symbol should stay alive for as long as the; // allocated value symbol, since our diagnostics depend on the value; // returned by the call. Ex: Data should only be freed if noErr was; // returned during allocation.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:443,Integrability,depend,depend,443,"// If the argument points to something that's not a symbolic region, it; // can be:; // - unknown (cannot reason about it); // - undefined (already reported by other checker); // - constant (null - should not be tracked,; // other constant will generate a compiler warning); // - goto (should be reported by other checker); // The call return value symbol should stay alive for as long as the; // allocated value symbol, since our diagnostics depend on the value; // returned by the call. Ex: Data should only be freed if noErr was; // returned during allocation.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:13,Energy Efficiency,allocate,allocated,13,// Track the allocated value in the checker state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:14,Testability,log,logic,14,// TODO: This logic is the same as in Malloc checker.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:143,Energy Efficiency,allocate,allocated,143,"// Most bug reports are cached at the location where they occurred.; // With leaks, we want to unique them by the location where they were; // allocated, and only report a single path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:24,Performance,cache,cached,24,"// Most bug reports are cached at the location where they occurred.; // With leaks, we want to unique them by the location where they were; // allocated, and only report a single path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:42,Availability,error,error,42,"/// If the return symbol is assumed to be error, remove the allocated info; /// from consideration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:60,Energy Efficiency,allocate,allocated,60,"/// If the return symbol is assumed to be error, remove the allocated info; /// from consideration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:59,Availability,error,error,59,"// Match for a restricted set of patterns for cmparison of error codes.; // Note, the comparisons of type '0 == st' are transformed into SymIntExpr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:10,Energy Efficiency,allocate,allocated,10,// If the allocated symbol is null do not report.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:16,Availability,error,error,16,// Generate the error reports.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp:615,Integrability,interface,interface,615,"// MacOSXAPIChecker.h - Checks proper use of various MacOS X APIs --*- C++ -*-//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines MacOSXAPIChecker, which is an assortment of checks on calls; // to various, widely used Apple APIs.; //; // FIXME: What's currently in BasicObjCFoundationChecks.cpp should be migrated; // to here, using the new Checker interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp:45,Energy Efficiency,allocate,allocated,45,"// Check if the first argument is improperly allocated. If so, issue a; // warning because that's likely to be bad news.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp:10,Modifiability,variab,variables,10,// Global variables are fine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp:115,Integrability,wrap,wraps,115,// Handle _dispatch_once. In some versions of the OS X SDK we have the case; // that dispatch_once is a macro that wraps a call to _dispatch_once.; // _dispatch_once is then a function which then calls the real dispatch_once.; // Users do not care; they just want the warning at the top-level call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp:58,Modifiability,variab,variable,58,"// We filtered out globals earlier, so it must be a local variable; // or a block variable which is under UnknownSpaceRegion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp:82,Modifiability,variab,variable,82,"// We filtered out globals earlier, so it must be a local variable; // or a block variable which is under UnknownSpaceRegion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp:170,Modifiability,variab,variable,170,"// Presence of an IVar superregion has priority over this branch, because; // ObjC objects are on the heap even if the core doesn't realize this.; // Presence of a block variable base region has priority over this branch,; // because block variables are known to be either on stack or on heap; // (might actually move between the two, hence UnknownSpace).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp:240,Modifiability,variab,variables,240,"// Presence of an IVar superregion has priority over this branch, because; // ObjC objects are on the heap even if the core doesn't realize this.; // Presence of a block variable base region has priority over this branch,; // because block variables are known to be either on stack or on heap; // (might actually move between the two, hence UnknownSpace).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:785,Availability,error,errors,785,"//=== MallocChecker.cpp - A malloc/free checker -------------------*- C++ -*--//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a variety of memory management related checkers, such as; // leak, double free, and use-after-free.; //; // The following checkers are defined here:; //; // * MallocChecker; // Despite its name, it models all sorts of memory allocations and; // de- or reallocation, including but not limited to malloc, free,; // relloc, new, delete. It also reports on a variety of memory misuse; // errors.; // Many other checkers interact very closely with this checker, in fact,; // most are merely options to this one. Other checkers may register; // MallocChecker, but do not enable MallocChecker's reports (more details; // to follow around its field, ChecksEnabled).; // It also has a boolean ""Optimistic"" checker option, which if set to true; // will cause the checker to model user defined memory management related; // functions annotated via the attribute ownership_takes, ownership_holds; // and ownership_returns.; //; // * NewDeleteChecker; // Enables the modeling of new, new[], delete, delete[] in MallocChecker,; // and checks for related double-free and use-after-free errors.; //; // * NewDeleteLeaksChecker; // Checks for leaks related to new, new[], delete, delete[].; // Depends on NewDeleteChecker.; //; // * MismatchedDeallocatorChecker; // Enables checking whether memory is deallocated with the correspending; // allocation function in MallocChecker, such as malloc() allocated; // regions are only freed by free(), new by delete, new[] by delete[].; //; // InnerPointerChecker interacts very closely with MallocChecker, but unlike; // the above checkers, it has it's own file, hence the ma",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:1472,Availability,error,errors,1472,"Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a variety of memory management related checkers, such as; // leak, double free, and use-after-free.; //; // The following checkers are defined here:; //; // * MallocChecker; // Despite its name, it models all sorts of memory allocations and; // de- or reallocation, including but not limited to malloc, free,; // relloc, new, delete. It also reports on a variety of memory misuse; // errors.; // Many other checkers interact very closely with this checker, in fact,; // most are merely options to this one. Other checkers may register; // MallocChecker, but do not enable MallocChecker's reports (more details; // to follow around its field, ChecksEnabled).; // It also has a boolean ""Optimistic"" checker option, which if set to true; // will cause the checker to model user defined memory management related; // functions annotated via the attribute ownership_takes, ownership_holds; // and ownership_returns.; //; // * NewDeleteChecker; // Enables the modeling of new, new[], delete, delete[] in MallocChecker,; // and checks for related double-free and use-after-free errors.; //; // * NewDeleteLeaksChecker; // Checks for leaks related to new, new[], delete, delete[].; // Depends on NewDeleteChecker.; //; // * MismatchedDeallocatorChecker; // Enables checking whether memory is deallocated with the correspending; // allocation function in MallocChecker, such as malloc() allocated; // regions are only freed by free(), new by delete, new[] by delete[].; //; // InnerPointerChecker interacts very closely with MallocChecker, but unlike; // the above checkers, it has it's own file, hence the many InnerPointerChecker; // related headers and non-static functions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:1779,Energy Efficiency,allocate,allocated,1779,"Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a variety of memory management related checkers, such as; // leak, double free, and use-after-free.; //; // The following checkers are defined here:; //; // * MallocChecker; // Despite its name, it models all sorts of memory allocations and; // de- or reallocation, including but not limited to malloc, free,; // relloc, new, delete. It also reports on a variety of memory misuse; // errors.; // Many other checkers interact very closely with this checker, in fact,; // most are merely options to this one. Other checkers may register; // MallocChecker, but do not enable MallocChecker's reports (more details; // to follow around its field, ChecksEnabled).; // It also has a boolean ""Optimistic"" checker option, which if set to true; // will cause the checker to model user defined memory management related; // functions annotated via the attribute ownership_takes, ownership_holds; // and ownership_returns.; //; // * NewDeleteChecker; // Enables the modeling of new, new[], delete, delete[] in MallocChecker,; // and checks for related double-free and use-after-free errors.; //; // * NewDeleteLeaksChecker; // Checks for leaks related to new, new[], delete, delete[].; // Depends on NewDeleteChecker.; //; // * MismatchedDeallocatorChecker; // Enables checking whether memory is deallocated with the correspending; // allocation function in MallocChecker, such as malloc() allocated; // regions are only freed by free(), new by delete, new[] by delete[].; //; // InnerPointerChecker interacts very closely with MallocChecker, but unlike; // the above checkers, it has it's own file, hence the many InnerPointerChecker; // related headers and non-static functions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:1578,Integrability,Depend,Depends,1578,"Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a variety of memory management related checkers, such as; // leak, double free, and use-after-free.; //; // The following checkers are defined here:; //; // * MallocChecker; // Despite its name, it models all sorts of memory allocations and; // de- or reallocation, including but not limited to malloc, free,; // relloc, new, delete. It also reports on a variety of memory misuse; // errors.; // Many other checkers interact very closely with this checker, in fact,; // most are merely options to this one. Other checkers may register; // MallocChecker, but do not enable MallocChecker's reports (more details; // to follow around its field, ChecksEnabled).; // It also has a boolean ""Optimistic"" checker option, which if set to true; // will cause the checker to model user defined memory management related; // functions annotated via the attribute ownership_takes, ownership_holds; // and ownership_returns.; //; // * NewDeleteChecker; // Enables the modeling of new, new[], delete, delete[] in MallocChecker,; // and checks for related double-free and use-after-free errors.; //; // * NewDeleteLeaksChecker; // Checks for leaks related to new, new[], delete, delete[].; // Depends on NewDeleteChecker.; //; // * MismatchedDeallocatorChecker; // Enables checking whether memory is deallocated with the correspending; // allocation function in MallocChecker, such as malloc() allocated; // regions are only freed by free(), new by delete, new[] by delete[].; //; // InnerPointerChecker interacts very closely with MallocChecker, but unlike; // the above checkers, it has it's own file, hence the many InnerPointerChecker; // related headers and non-static functions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:173,Energy Efficiency,allocate,allocated,173,"//===----------------------------------------------------------------------===//; // The types of allocation we're modeling. This is used to check whether a; // dynamically allocated object is deallocated with the correct function, like; // not using operator delete on an object created by malloc(), or alloca regions; // aren't ever deallocated manually.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:16,Energy Efficiency,allocate,allocated,16,// Reference to allocated memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:21,Energy Efficiency,allocate,allocated,21,// Reference to zero-allocated memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:16,Deployability,release,released,16,// Reference to released/freed memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:56,Deployability,release,released,56,/// Check if the memory associated with this symbol was released.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:4,Deployability,Update,Update,4,"/// Update the RefState to reflect the new memory allocation.; /// The optional \p RetVal parameter specifies the newly allocated pointer; /// value; if unspecified, the value of expression \p E is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:120,Energy Efficiency,allocate,allocated,120,"/// Update the RefState to reflect the new memory allocation.; /// The optional \p RetVal parameter specifies the newly allocated pointer; /// value; if unspecified, the value of expression \p E is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:94,Energy Efficiency,allocate,allocated,94,"// The symbol doesn't have to freed (e.g.: we aren't sure if, how and where; // 'fromPtr' was allocated:; // void Haha(int *ptr) {; // ptr = realloc(ptr, 67);; // // ...; // }; // ).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:261,Availability,failure,failure,261,"/// Stores information about the 'fromPtr' symbol after reallocation.; ///; /// This is important because realloc may fail, and that needs special modeling.; /// Whether reallocation failed or not will not be known until later, so we'll; /// store whether upon failure 'fromPtr' will be freed, or needs to be freed; /// later, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:101,Performance,perform,perform,101,"/// Many checkers are essentially built into this one, so enabling them will; /// make MallocChecker perform additional modeling and reporting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:84,Energy Efficiency,allocate,allocates,84,"/// Perform a zero-allocation check.; ///; /// \param [in] Call The expression that allocates memory.; /// \param [in] IndexOfSizeArg Index of the argument that specifies the size; /// of the memory that needs to be allocated. E.g. for malloc, this would be; /// 0.; /// \param [in] RetVal Specifies the newly allocated pointer value;; /// if unspecified, the value of expression \p E is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:216,Energy Efficiency,allocate,allocated,216,"/// Perform a zero-allocation check.; ///; /// \param [in] Call The expression that allocates memory.; /// \param [in] IndexOfSizeArg Index of the argument that specifies the size; /// of the memory that needs to be allocated. E.g. for malloc, this would be; /// 0.; /// \param [in] RetVal Specifies the newly allocated pointer value;; /// if unspecified, the value of expression \p E is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:310,Energy Efficiency,allocate,allocated,310,"/// Perform a zero-allocation check.; ///; /// \param [in] Call The expression that allocates memory.; /// \param [in] IndexOfSizeArg Index of the argument that specifies the size; /// of the memory that needs to be allocated. E.g. for malloc, this would be; /// 0.; /// \param [in] RetVal Specifies the newly allocated pointer value;; /// if unspecified, the value of expression \p E is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:4,Performance,Perform,Perform,4,"/// Perform a zero-allocation check.; ///; /// \param [in] Call The expression that allocates memory.; /// \param [in] IndexOfSizeArg Index of the argument that specifies the size; /// of the memory that needs to be allocated. E.g. for malloc, this would be; /// 0.; /// \param [in] RetVal Specifies the newly allocated pointer value;; /// if unspecified, the value of expression \p E is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:203,Energy Efficiency,allocate,allocated,203,"/// Model functions with the ownership_returns attribute.; ///; /// User-defined function may have the ownership_returns attribute, which; /// annotates that the function returns with an object that was allocated on; /// the heap, and passes the ownertship to the callee.; ///; /// void __attribute((ownership_returns(malloc, 1))) *my_malloc(size_t);; ///; /// It has two parameters:; /// - first: name of the resource (e.g. 'malloc'); /// - (OPTIONAL) second: size of the allocated region; ///; /// \param [in] Call The expression that allocates memory.; /// \param [in] Att The ownership_returns attribute.; /// \param [in] State The \c ProgramState right before allocation.; /// \returns The ProgramState right after allocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:473,Energy Efficiency,allocate,allocated,473,"/// Model functions with the ownership_returns attribute.; ///; /// User-defined function may have the ownership_returns attribute, which; /// annotates that the function returns with an object that was allocated on; /// the heap, and passes the ownertship to the callee.; ///; /// void __attribute((ownership_returns(malloc, 1))) *my_malloc(size_t);; ///; /// It has two parameters:; /// - first: name of the resource (e.g. 'malloc'); /// - (OPTIONAL) second: size of the allocated region; ///; /// \param [in] Call The expression that allocates memory.; /// \param [in] Att The ownership_returns attribute.; /// \param [in] State The \c ProgramState right before allocation.; /// \returns The ProgramState right after allocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:537,Energy Efficiency,allocate,allocates,537,"/// Model functions with the ownership_returns attribute.; ///; /// User-defined function may have the ownership_returns attribute, which; /// annotates that the function returns with an object that was allocated on; /// the heap, and passes the ownertship to the callee.; ///; /// void __attribute((ownership_returns(malloc, 1))) *my_malloc(size_t);; ///; /// It has two parameters:; /// - first: name of the resource (e.g. 'malloc'); /// - (OPTIONAL) second: size of the allocated region; ///; /// \param [in] Call The expression that allocates memory.; /// \param [in] Att The ownership_returns attribute.; /// \param [in] State The \c ProgramState right before allocation.; /// \returns The ProgramState right after allocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:77,Energy Efficiency,allocate,allocates,77,"/// Models memory allocation.; ///; /// \param [in] Call The expression that allocates memory.; /// \param [in] SizeEx Size of the memory that needs to be allocated.; /// \param [in] Init The value the allocated memory needs to be initialized.; /// with. For example, \c calloc initializes the allocated memory to 0,; /// malloc leaves it undefined.; /// \param [in] State The \c ProgramState right before allocation.; /// \returns The ProgramState right after allocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:155,Energy Efficiency,allocate,allocated,155,"/// Models memory allocation.; ///; /// \param [in] Call The expression that allocates memory.; /// \param [in] SizeEx Size of the memory that needs to be allocated.; /// \param [in] Init The value the allocated memory needs to be initialized.; /// with. For example, \c calloc initializes the allocated memory to 0,; /// malloc leaves it undefined.; /// \param [in] State The \c ProgramState right before allocation.; /// \returns The ProgramState right after allocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:202,Energy Efficiency,allocate,allocated,202,"/// Models memory allocation.; ///; /// \param [in] Call The expression that allocates memory.; /// \param [in] SizeEx Size of the memory that needs to be allocated.; /// \param [in] Init The value the allocated memory needs to be initialized.; /// with. For example, \c calloc initializes the allocated memory to 0,; /// malloc leaves it undefined.; /// \param [in] State The \c ProgramState right before allocation.; /// \returns The ProgramState right after allocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:294,Energy Efficiency,allocate,allocated,294,"/// Models memory allocation.; ///; /// \param [in] Call The expression that allocates memory.; /// \param [in] SizeEx Size of the memory that needs to be allocated.; /// \param [in] Init The value the allocated memory needs to be initialized.; /// with. For example, \c calloc initializes the allocated memory to 0,; /// malloc leaves it undefined.; /// \param [in] State The \c ProgramState right before allocation.; /// \returns The ProgramState right after allocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:77,Energy Efficiency,allocate,allocates,77,"/// Models memory allocation.; ///; /// \param [in] Call The expression that allocates memory.; /// \param [in] Size Size of the memory that needs to be allocated.; /// \param [in] Init The value the allocated memory needs to be initialized.; /// with. For example, \c calloc initializes the allocated memory to 0,; /// malloc leaves it undefined.; /// \param [in] State The \c ProgramState right before allocation.; /// \returns The ProgramState right after allocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:153,Energy Efficiency,allocate,allocated,153,"/// Models memory allocation.; ///; /// \param [in] Call The expression that allocates memory.; /// \param [in] Size Size of the memory that needs to be allocated.; /// \param [in] Init The value the allocated memory needs to be initialized.; /// with. For example, \c calloc initializes the allocated memory to 0,; /// malloc leaves it undefined.; /// \param [in] State The \c ProgramState right before allocation.; /// \returns The ProgramState right after allocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:200,Energy Efficiency,allocate,allocated,200,"/// Models memory allocation.; ///; /// \param [in] Call The expression that allocates memory.; /// \param [in] Size Size of the memory that needs to be allocated.; /// \param [in] Init The value the allocated memory needs to be initialized.; /// with. For example, \c calloc initializes the allocated memory to 0,; /// malloc leaves it undefined.; /// \param [in] State The \c ProgramState right before allocation.; /// \returns The ProgramState right after allocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:292,Energy Efficiency,allocate,allocated,292,"/// Models memory allocation.; ///; /// \param [in] Call The expression that allocates memory.; /// \param [in] Size Size of the memory that needs to be allocated.; /// \param [in] Init The value the allocated memory needs to be initialized.; /// with. For example, \c calloc initializes the allocated memory to 0,; /// malloc leaves it undefined.; /// \param [in] State The \c ProgramState right before allocation.; /// \returns The ProgramState right after allocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:859,Availability,failure,failure,859,"/// Models memory deallocation.; ///; /// \param [in] Call The expression that frees memory.; /// \param [in] State The \c ProgramState right before allocation.; /// \param [in] Num Index of the argument that needs to be freed. This is; /// normally 0, but for custom free functions it may be different.; /// \param [in] Hold Whether the parameter at \p Index has the ownership_holds; /// attribute.; /// \param [out] IsKnownToBeAllocated Whether the memory to be freed is known; /// to have been allocated, or in other words, the symbol to be freed was; /// registered as allocated by this checker. In the following case, \c ptr; /// isn't known to be allocated.; /// void Haha(int *ptr) {; /// ptr = realloc(ptr, 67);; /// // ...; /// }; /// \param [in] ReturnsNullOnFailure Whether the memory deallocation function; /// we're modeling returns with Null on failure.; /// \returns The ProgramState right after deallocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:497,Energy Efficiency,allocate,allocated,497,"/// Models memory deallocation.; ///; /// \param [in] Call The expression that frees memory.; /// \param [in] State The \c ProgramState right before allocation.; /// \param [in] Num Index of the argument that needs to be freed. This is; /// normally 0, but for custom free functions it may be different.; /// \param [in] Hold Whether the parameter at \p Index has the ownership_holds; /// attribute.; /// \param [out] IsKnownToBeAllocated Whether the memory to be freed is known; /// to have been allocated, or in other words, the symbol to be freed was; /// registered as allocated by this checker. In the following case, \c ptr; /// isn't known to be allocated.; /// void Haha(int *ptr) {; /// ptr = realloc(ptr, 67);; /// // ...; /// }; /// \param [in] ReturnsNullOnFailure Whether the memory deallocation function; /// we're modeling returns with Null on failure.; /// \returns The ProgramState right after deallocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:573,Energy Efficiency,allocate,allocated,573,"/// Models memory deallocation.; ///; /// \param [in] Call The expression that frees memory.; /// \param [in] State The \c ProgramState right before allocation.; /// \param [in] Num Index of the argument that needs to be freed. This is; /// normally 0, but for custom free functions it may be different.; /// \param [in] Hold Whether the parameter at \p Index has the ownership_holds; /// attribute.; /// \param [out] IsKnownToBeAllocated Whether the memory to be freed is known; /// to have been allocated, or in other words, the symbol to be freed was; /// registered as allocated by this checker. In the following case, \c ptr; /// isn't known to be allocated.; /// void Haha(int *ptr) {; /// ptr = realloc(ptr, 67);; /// // ...; /// }; /// \param [in] ReturnsNullOnFailure Whether the memory deallocation function; /// we're modeling returns with Null on failure.; /// \returns The ProgramState right after deallocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:653,Energy Efficiency,allocate,allocated,653,"/// Models memory deallocation.; ///; /// \param [in] Call The expression that frees memory.; /// \param [in] State The \c ProgramState right before allocation.; /// \param [in] Num Index of the argument that needs to be freed. This is; /// normally 0, but for custom free functions it may be different.; /// \param [in] Hold Whether the parameter at \p Index has the ownership_holds; /// attribute.; /// \param [out] IsKnownToBeAllocated Whether the memory to be freed is known; /// to have been allocated, or in other words, the symbol to be freed was; /// registered as allocated by this checker. In the following case, \c ptr; /// isn't known to be allocated.; /// void Haha(int *ptr) {; /// ptr = realloc(ptr, 67);; /// // ...; /// }; /// \param [in] ReturnsNullOnFailure Whether the memory deallocation function; /// we're modeling returns with Null on failure.; /// \returns The ProgramState right after deallocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:859,Availability,failure,failure,859,"/// Models memory deallocation.; ///; /// \param [in] ArgExpr The variable who's pointee needs to be freed.; /// \param [in] Call The expression that frees the memory.; /// \param [in] State The \c ProgramState right before allocation.; /// normally 0, but for custom free functions it may be different.; /// \param [in] Hold Whether the parameter at \p Index has the ownership_holds; /// attribute.; /// \param [out] IsKnownToBeAllocated Whether the memory to be freed is known; /// to have been allocated, or in other words, the symbol to be freed was; /// registered as allocated by this checker. In the following case, \c ptr; /// isn't known to be allocated.; /// void Haha(int *ptr) {; /// ptr = realloc(ptr, 67);; /// // ...; /// }; /// \param [in] ReturnsNullOnFailure Whether the memory deallocation function; /// we're modeling returns with Null on failure.; /// \returns The ProgramState right after deallocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:497,Energy Efficiency,allocate,allocated,497,"/// Models memory deallocation.; ///; /// \param [in] ArgExpr The variable who's pointee needs to be freed.; /// \param [in] Call The expression that frees the memory.; /// \param [in] State The \c ProgramState right before allocation.; /// normally 0, but for custom free functions it may be different.; /// \param [in] Hold Whether the parameter at \p Index has the ownership_holds; /// attribute.; /// \param [out] IsKnownToBeAllocated Whether the memory to be freed is known; /// to have been allocated, or in other words, the symbol to be freed was; /// registered as allocated by this checker. In the following case, \c ptr; /// isn't known to be allocated.; /// void Haha(int *ptr) {; /// ptr = realloc(ptr, 67);; /// // ...; /// }; /// \param [in] ReturnsNullOnFailure Whether the memory deallocation function; /// we're modeling returns with Null on failure.; /// \returns The ProgramState right after deallocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:573,Energy Efficiency,allocate,allocated,573,"/// Models memory deallocation.; ///; /// \param [in] ArgExpr The variable who's pointee needs to be freed.; /// \param [in] Call The expression that frees the memory.; /// \param [in] State The \c ProgramState right before allocation.; /// normally 0, but for custom free functions it may be different.; /// \param [in] Hold Whether the parameter at \p Index has the ownership_holds; /// attribute.; /// \param [out] IsKnownToBeAllocated Whether the memory to be freed is known; /// to have been allocated, or in other words, the symbol to be freed was; /// registered as allocated by this checker. In the following case, \c ptr; /// isn't known to be allocated.; /// void Haha(int *ptr) {; /// ptr = realloc(ptr, 67);; /// // ...; /// }; /// \param [in] ReturnsNullOnFailure Whether the memory deallocation function; /// we're modeling returns with Null on failure.; /// \returns The ProgramState right after deallocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:653,Energy Efficiency,allocate,allocated,653,"/// Models memory deallocation.; ///; /// \param [in] ArgExpr The variable who's pointee needs to be freed.; /// \param [in] Call The expression that frees the memory.; /// \param [in] State The \c ProgramState right before allocation.; /// normally 0, but for custom free functions it may be different.; /// \param [in] Hold Whether the parameter at \p Index has the ownership_holds; /// attribute.; /// \param [out] IsKnownToBeAllocated Whether the memory to be freed is known; /// to have been allocated, or in other words, the symbol to be freed was; /// registered as allocated by this checker. In the following case, \c ptr; /// isn't known to be allocated.; /// void Haha(int *ptr) {; /// ptr = realloc(ptr, 67);; /// // ...; /// }; /// \param [in] ReturnsNullOnFailure Whether the memory deallocation function; /// we're modeling returns with Null on failure.; /// \returns The ProgramState right after deallocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:66,Modifiability,variab,variable,66,"/// Models memory deallocation.; ///; /// \param [in] ArgExpr The variable who's pointee needs to be freed.; /// \param [in] Call The expression that frees the memory.; /// \param [in] State The \c ProgramState right before allocation.; /// normally 0, but for custom free functions it may be different.; /// \param [in] Hold Whether the parameter at \p Index has the ownership_holds; /// attribute.; /// \param [out] IsKnownToBeAllocated Whether the memory to be freed is known; /// to have been allocated, or in other words, the symbol to be freed was; /// registered as allocated by this checker. In the following case, \c ptr; /// isn't known to be allocated.; /// void Haha(int *ptr) {; /// ptr = realloc(ptr, 67);; /// // ...; /// }; /// \param [in] ReturnsNullOnFailure Whether the memory deallocation function; /// we're modeling returns with Null on failure.; /// \returns The ProgramState right after deallocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:20,Modifiability,refactor,refactoring,20,"// TODO: Needs some refactoring, as all other deallocation modeling; // functions are suffering from out parameters and messy code due to how; // realloc is handled.; //; /// Models memory reallocation.; ///; /// \param [in] Call The expression that reallocated memory; /// \param [in] ShouldFreeOnFail Whether if reallocation fails, the supplied; /// memory should be freed.; /// \param [in] State The \c ProgramState right before reallocation.; /// \param [in] SuffixWithN Whether the reallocation function we're modeling; /// has an '_n' suffix, such as g_realloc_n.; /// \returns The ProgramState right after reallocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:47,Energy Efficiency,allocate,allocated,47,/// Evaluates the buffer size that needs to be allocated.; ///; /// \param [in] Blocks The amount of blocks that needs to be allocated.; /// \param [in] BlockBytes The size of a block.; /// \returns The symbolic value of \p Blocks * \p BlockBytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:125,Energy Efficiency,allocate,allocated,125,/// Evaluates the buffer size that needs to be allocated.; ///; /// \param [in] Blocks The amount of blocks that needs to be allocated.; /// \param [in] BlockBytes The size of a block.; /// \returns The symbolic value of \p Blocks * \p BlockBytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:56,Energy Efficiency,allocate,allocated,56,"/// If in \p S \p Sym is used, check whether \p Sym was allocated as a zero; /// sized memory region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:26,Availability,checkPoint,checkPointerEscape,26,/// Implementation of the checkPointerEscape callbacks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:4,Testability,Test,Test,4,/// Test if value in ArgVal equals to value in macro `ZERO_SIZE_PTR`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:39,Energy Efficiency,allocate,allocated,39,"// Collect which entities point to the allocated memory, and could be; // responsible for deallocating it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:445,Testability,test,test,445,"/// Syntactically checks whether the callee is a deallocating function. Since; /// we have no path-sensitive information on this call (we would need a; /// CallEvent instead of a CallExpr for that), its possible that a; /// deallocation function was called indirectly through a function pointer,; /// but we are not able to tell, so this is a best effort analysis.; /// See namespace `memory_passed_to_fn_call_free_through_fn_ptr` in; /// clang/test/Analysis/NewDeleteLeaks.cpp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:61,Energy Efficiency,allocate,allocated,61,"// TODO: Ownership might change with an attempt to store the allocated; // memory, not only through deallocation. Check for attempted stores as; // well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:80,Modifiability,variab,variable,80,"// Owners in the current set may be purged from the analyzer later on.; // If a variable is dead (is not referenced directly or indirectly after; // some point), it will be removed from the Store before the end of its; // actual lifetime.; // This means that if the ownership status didn't change, CurrOwners; // must be a superset of, but not necessarily equal to ExitOwners.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:20,Testability,log,logic,20,"// TODO: Factor the logic of ""what constitutes as an entity being passed; // into a function call"" out by reusing the code in; // NoStoreFuncVisitor::maybeEmitNoteForParameters, maybe by incorporating; // the printing technology in UninitializedObject's FieldChainInfo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:7,Energy Efficiency,allocate,allocated,7,// The allocated region symbol tracked by the main analysis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:52,Deployability,release,released,52,// A C++ destructor stack frame in which memory was released. Used for; // miscellaneous false positive suppression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:45,Deployability,release,released,45,/// Did not track -> allocated. Other state (released) -> allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:21,Energy Efficiency,allocate,allocated,21,/// Did not track -> allocated. Other state (released) -> allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:58,Energy Efficiency,allocate,allocated,58,/// Did not track -> allocated. Other state (released) -> allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:21,Deployability,release,released,21,/// Did not track -> released. Other state (allocated) -> released.; /// The statement associated with the release might be missing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:58,Deployability,release,released,58,/// Did not track -> released. Other state (allocated) -> released.; /// The statement associated with the release might be missing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:107,Deployability,release,release,107,/// Did not track -> released. Other state (allocated) -> released.; /// The statement associated with the release might be missing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:44,Energy Efficiency,allocate,allocated,44,/// Did not track -> released. Other state (allocated) -> released.; /// The statement associated with the release might be missing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:48,Energy Efficiency,allocate,allocated,48,/// Did not track -> relinquished. Other state (allocated) -> relinquished.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:66,Deployability,release,released,66,"/// If the expression is not a call, and the state change is; /// released -> allocated, it must be the realloc return value; /// check. If we have to handle more cases here, it might be cleaner just; /// to track this extra bit in the state itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:78,Energy Efficiency,allocate,allocated,78,"/// If the expression is not a call, and the state change is; /// released -> allocated, it must be the realloc return value; /// check. If we have to handle more cases here, it might be cleaner just; /// to track this extra bit in the state itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:438,Testability,log,logic,438,"// 3-argument malloc(), as commonly used in {Free,Net,Open}BSD Kernels:; //; // void *malloc(unsigned long size, struct malloc_type *mtp, int flags);; //; // One of the possible flags is M_ZERO, which means 'give me back an; // allocation which is already zeroed', like calloc.; // 2-argument kmalloc(), as used in the Linux kernel:; //; // void *kmalloc(size_t size, gfp_t flags);; //; // Has the similar flag value __GFP_ZERO.; // This logic is largely cloned from O_CREAT in UnixAPIChecker, maybe some; // code could be shared.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:12,Availability,mask,maskedFlags,12,// Check if maskedFlags is non-zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:44,Energy Efficiency,allocate,allocate,44,// Should we model this differently? We can allocate a fixed number of; // elements with zeros in the last one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:3,Performance,Perform,Performs,3,// Performs a 0-sized allocations check.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:227,Energy Efficiency,allocate,allocated,227,"// Case of zero-size realloc. Historically 'realloc(ptr, 0)' is treated as; // 'free(ptr)' and the returned value from 'realloc(ptr, 0)' is not; // tracked. Add zero-reallocated Sym to the state to catch references; // to zero-allocated memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:29,Energy Efficiency,Allocate,Allocated,29,// Set the symbol's state to Allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:43,Performance,perform,performed,43,"// The explicit NULL case, no operation is performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:83,Availability,error,error,83,"// NOTE: We detected a bug, but the checker under whose name we would emit the; // error could be disabled. Generally speaking, the MallocChecker family is an; // integral part of the Static Analyzer, and disabling any part of it should; // only be done under exceptional circumstances, such as frequent false; // positives. If this is the case, we can reasonably believe that there are; // serious faults in our understanding of the source code, and even if we; // don't emit an warning, we should terminate further analysis with a sink; // node.; // Nonlocs can't be freed, of course.; // Non-region locations (labels and fixed addresses) also shouldn't be freed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:399,Availability,fault,faults,399,"// NOTE: We detected a bug, but the checker under whose name we would emit the; // error could be disabled. Generally speaking, the MallocChecker family is an; // integral part of the Static Analyzer, and disabling any part of it should; // only be done under exceptional circumstances, such as frequent false; // positives. If this is the case, we can reasonably believe that there are; // serious faults in our understanding of the source code, and even if we; // don't emit an warning, we should terminate further analysis with a sink; // node.; // Nonlocs can't be freed, of course.; // Non-region locations (labels and fixed addresses) also shouldn't be freed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:12,Safety,detect,detected,12,"// NOTE: We detected a bug, but the checker under whose name we would emit the; // error could be disabled. Generally speaking, the MallocChecker family is an; // integral part of the Static Analyzer, and disabling any part of it should; // only be done under exceptional circumstances, such as frequent false; // positives. If this is the case, we can reasonably believe that there are; // serious faults in our understanding of the source code, and even if we; // don't emit an warning, we should terminate further analysis with a sink; // node.; // Nonlocs can't be freed, of course.; // Non-region locations (labels and fixed addresses) also shouldn't be freed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:139,Energy Efficiency,allocate,allocated,139,"// Regions returned by malloc() are represented by SymbolicRegion objects; // within HeapSpaceRegion. Of course, free() can work on memory allocated; // outside the current function, so UnknownSpaceRegion is also a; // possibility here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:21,Energy Efficiency,allocate,allocated,21,"// If the pointer is allocated or escaped, but we are now trying to free it,; // check that the call to free is proper.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:71,Energy Efficiency,allocate,allocated,71,"// Check if the memory location being freed is the actual location; // allocated, or an offset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:38,Availability,alive,alive,38,// The reallocated symbol should stay alive for as long as the new symbol.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:80,Availability,error,error,80,// Do not show local variables belonging to a function other than; // where the error is reported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:21,Modifiability,variab,variables,21,// Do not show local variables belonging to a function other than; // where the error is reported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:224,Testability,assert,assert,224,// Leaks should not be reported if they are post-dominated by a sink:; // (1) Sinks are higher importance bugs.; // (2) NoReturnFunctionChecker uses sink nodes to represent paths ending; // with __noreturn functions such as assert() or exit(). We choose not; // to report leaks on such paths.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:143,Energy Efficiency,allocate,allocated,143,"// Most bug reports are cached at the location where they occurred.; // With leaks, we want to unique them by the location where they were; // allocated, and only report a single path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:24,Performance,cache,cached,24,"// Most bug reports are cached at the location where they occurred.; // With leaks, we want to unique them by the location where they were; // allocated, and only report a single path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:38,Energy Efficiency,allocate,allocated,38,"// If we are returning a field of the allocated struct or an array element,; // the callee could still free the memory.; // TODO: This logic should be a part of generic symbol escape callback.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:135,Testability,log,logic,135,"// If we are returning a field of the allocated struct or an array element,; // the callee could still free the memory.; // TODO: This logic should be a part of generic symbol escape callback.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:21,Integrability,message,messages,21,// Check Objective-C messages by selector name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:78,Integrability,wrap,wrap,78,"// A bunch of other functions which either take ownership of a pointer or; // wrap the result up in a struct or object, meaning it can be freed later.; // (See RetainCountChecker.) Not all the parameters here are invalidated,; // but the Malloc checker cannot differentiate between them. The right way; // of doing this would be to implement a pointer escapes callback.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:98,Deployability,release,released,98,"// If we find an atomic fetch_add or fetch_sub within the destructor in which; // the pointer was released (before the release), this is likely a destructor; // of a shared pointer.; // Because we don't model atomics, and also because we don't know that the; // original reference count is positive, we should not report use-after-frees; // on objects deleted in such destructors. This can probably be improved; // through better shared pointer modeling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:119,Deployability,release,release,119,"// If we find an atomic fetch_add or fetch_sub within the destructor in which; // the pointer was released (before the release), this is likely a destructor; // of a shared pointer.; // Because we don't model atomics, and also because we don't know that the; // original reference count is positive, we should not report use-after-frees; // on objects deleted in such destructors. This can probably be improved; // through better shared pointer modeling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:207,Deployability,release,released,207,"// It is unlikely that releasing memory is delegated to a destructor; // inside a destructor of a shared pointer, because it's fairly hard; // to pass the information that the pointer indeed needs to be; // released into it. So we're only interested in the innermost; // destructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:47,Testability,test,testing,47,// Is it possible to fail two reallocs WITHOUT testing in between?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp:689,Energy Efficiency,allocate,allocate,689,"// MallocOverflowSecurityChecker.cpp - Check for malloc overflows -*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker detects a common memory allocation security flaw.; // Suppose 'unsigned int n' comes from an untrusted source. If the; // code looks like 'malloc (n * 4)', and an attacker can make 'n' be; // say MAX_UINT/4+2, then instead of allocating the correct 'n' 4-byte; // elements, this will actually allocate only two because of overflow.; // Then when the rest of the program attempts to store values past the; // second element, these values will actually overwrite other items in; // the heap, probably allowing the attacker to execute arbitrary code.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp:396,Safety,detect,detects,396,"// MallocOverflowSecurityChecker.cpp - Check for malloc overflows -*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker detects a common memory allocation security flaw.; // Suppose 'unsigned int n' comes from an untrusted source. If the; // code looks like 'malloc (n * 4)', and an attacker can make 'n' be; // say MAX_UINT/4+2, then instead of allocating the correct 'n' 4-byte; // elements, this will actually allocate only two because of overflow.; // Then when the rest of the program attempts to store values past the; // second element, these values will actually overwrite other items in; // the heap, probably allowing the attacker to execute arbitrary code.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp:431,Security,secur,security,431,"// MallocOverflowSecurityChecker.cpp - Check for malloc overflows -*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker detects a common memory allocation security flaw.; // Suppose 'unsigned int n' comes from an untrusted source. If the; // code looks like 'malloc (n * 4)', and an attacker can make 'n' be; // say MAX_UINT/4+2, then instead of allocating the correct 'n' 4-byte; // elements, this will actually allocate only two because of overflow.; // Then when the rest of the program attempts to store values past the; // second element, these values will actually overwrite other items in; // the heap, probably allowing the attacker to execute arbitrary code.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp:559,Security,attack,attacker,559,"// MallocOverflowSecurityChecker.cpp - Check for malloc overflows -*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker detects a common memory allocation security flaw.; // Suppose 'unsigned int n' comes from an untrusted source. If the; // code looks like 'malloc (n * 4)', and an attacker can make 'n' be; // say MAX_UINT/4+2, then instead of allocating the correct 'n' 4-byte; // elements, this will actually allocate only two because of overflow.; // Then when the rest of the program attempts to store values past the; // second element, these values will actually overwrite other items in; // the heap, probably allowing the attacker to execute arbitrary code.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp:908,Security,attack,attacker,908,"// MallocOverflowSecurityChecker.cpp - Check for malloc overflows -*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker detects a common memory allocation security flaw.; // Suppose 'unsigned int n' comes from an untrusted source. If the; // code looks like 'malloc (n * 4)', and an attacker can make 'n' be; // say MAX_UINT/4+2, then instead of allocating the correct 'n' 4-byte; // elements, this will actually allocate only two because of overflow.; // Then when the rest of the program attempts to store values past the; // second element, these values will actually overwrite other items in; // the heap, probably allowing the attacker to execute arbitrary code.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp:205,Energy Efficiency,reduce,reduce,205,"/* Look for a linear combination with a single variable, and at least; one multiplication.; Reject anything that applies to the variable: an explicit cast,; conditional expression, an operation that could reduce the range; of the result, or anything too complicated :-). */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp:47,Modifiability,variab,variable,47,"/* Look for a linear combination with a single variable, and at least; one multiplication.; Reject anything that applies to the variable: an explicit cast,; conditional expression, an operation that could reduce the range; of the result, or anything too complicated :-). */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp:128,Modifiability,variab,variable,128,"/* Look for a linear combination with a single variable, and at least; one multiplication.; Reject anything that applies to the variable: an explicit cast,; conditional expression, an operation that could reduce the range; of the result, or anything too complicated :-). */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp:124,Availability,avail,available,124,"// We've found the right structure of malloc argument, now save; // the data so when the body of the function is completely available; // we can check for comparisons.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp:176,Deployability,a/b,a/b,176,"// Check if the argument to malloc is assigned a value; // which cannot cause an overflow.; // e.g., malloc (mul * x) and,; // case 1: mul = <constant value>; // case 2: mul = a/b, where b > x",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp:74,Availability,error,error,74,"/* We specifically ignore loop conditions, because they're typically; not error checks. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp:316,Safety,detect,detect,316,"// OutputPossibleOverflows - We've found a possible overflow earlier,; // now check whether Body might contain a comparison which might be; // preventing the overflow.; // This doesn't do flow analysis, range analysis, or points-to analysis; it's; // just a dumb ""is there a comparison"" scan. The aim here is to; // detect the most blatent cases of overflow and educate the; // programmer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp:13,Modifiability,variab,variables,13,// A list of variables referenced in possibly overflowing malloc operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:577,Availability,error,error,577,"//== MIGChecker.cpp - MIG calling convention checker ------------*- C++ -*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines MIGChecker, a Mach Interface Generator calling convention; // checker. Namely, in MIG callback implementation the following rules apply:; // - When a server routine returns an error code that represents success, it; // must take ownership of resources passed to it (and eventually release; // them).; // - Additionally, when returning success, all out-parameters must be; // initialized.; // - When it returns any other error code, it must not take ownership,; // because the message and its out-of-line parameters will be destroyed; // by the client that called the function.; // For now we only check the last rule, as its violations lead to dangerous; // use-after-free exploits.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:821,Availability,error,error,821,"//== MIGChecker.cpp - MIG calling convention checker ------------*- C++ -*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines MIGChecker, a Mach Interface Generator calling convention; // checker. Namely, in MIG callback implementation the following rules apply:; // - When a server routine returns an error code that represents success, it; // must take ownership of resources passed to it (and eventually release; // them).; // - Additionally, when returning success, all out-parameters must be; // initialized.; // - When it returns any other error code, it must not take ownership,; // because the message and its out-of-line parameters will be destroyed; // by the client that called the function.; // For now we only check the last rule, as its violations lead to dangerous; // use-after-free exploits.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:682,Deployability,release,release,682,"//== MIGChecker.cpp - MIG calling convention checker ------------*- C++ -*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines MIGChecker, a Mach Interface Generator calling convention; // checker. Namely, in MIG callback implementation the following rules apply:; // - When a server routine returns an error code that represents success, it; // must take ownership of resources passed to it (and eventually release; // them).; // - Additionally, when returning success, all out-parameters must be; // initialized.; // - When it returns any other error code, it must not take ownership,; // because the message and its out-of-line parameters will be destroyed; // by the client that called the function.; // For now we only check the last rule, as its violations lead to dangerous; // use-after-free exploits.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:420,Integrability,Interface,Interface,420,"//== MIGChecker.cpp - MIG calling convention checker ------------*- C++ -*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines MIGChecker, a Mach Interface Generator calling convention; // checker. Namely, in MIG callback implementation the following rules apply:; // - When a server routine returns an error code that represents success, it; // must take ownership of resources passed to it (and eventually release; // them).; // - Additionally, when returning success, all out-parameters must be; // initialized.; // - When it returns any other error code, it must not take ownership,; // because the message and its out-of-line parameters will be destroyed; // by the client that called the function.; // For now we only check the last rule, as its violations lead to dangerous; // use-after-free exploits.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:558,Integrability,rout,routine,558,"//== MIGChecker.cpp - MIG calling convention checker ------------*- C++ -*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines MIGChecker, a Mach Interface Generator calling convention; // checker. Namely, in MIG callback implementation the following rules apply:; // - When a server routine returns an error code that represents success, it; // must take ownership of resources passed to it (and eventually release; // them).; // - Additionally, when returning success, all out-parameters must be; // initialized.; // - When it returns any other error code, it must not take ownership,; // because the message and its out-of-line parameters will be destroyed; // by the client that called the function.; // For now we only check the last rule, as its violations lead to dangerous; // use-after-free exploits.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:877,Integrability,message,message,877,"//== MIGChecker.cpp - MIG calling convention checker ------------*- C++ -*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines MIGChecker, a Mach Interface Generator calling convention; // checker. Namely, in MIG callback implementation the following rules apply:; // - When a server routine returns an error code that represents success, it; // must take ownership of resources passed to it (and eventually release; // them).; // - Additionally, when returning success, all out-parameters must be; // initialized.; // - When it returns any other error code, it must not take ownership,; // because the message and its out-of-line parameters will be destroyed; // by the client that called the function.; // For now we only check the last rule, as its violations lead to dangerous; // use-after-free exploits.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:267,Availability,error,error,267,"// The checker knows that an out-of-line object is deallocated if it is; // passed as an argument to one of these functions. If this object is; // additionally an argument of a MIG routine, the checker keeps track of that; // information and issues a warning when an error is returned from the; // respective routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:181,Integrability,rout,routine,181,"// The checker knows that an out-of-line object is deallocated if it is; // passed as an argument to one of these functions. If this object is; // additionally an argument of a MIG routine, the checker keeps track of that; // information and issues a warning when an error is returned from the; // respective routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:309,Integrability,rout,routine,309,"// The checker knows that an out-of-line object is deallocated if it is; // passed as an argument to one of these functions. If this object is; // additionally an argument of a MIG routine, the checker keeps track of that; // information and issues a warning when an error is returned from the; // respective routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:97,Performance,perform,performed,97,// A set of parameters for which the check is suppressed because; // reference counting is being performed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:44,Integrability,rout,routine,44,"// If we optimistically assume that the MIG routine never re-uses the storage; // that was passed to it as arguments when it invalidates it (but at most when; // it assigns to parameter variables directly), this procedure correctly; // determines if the value was loaded from the transitive closure of MIG; // routine arguments in the heap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:310,Integrability,rout,routine,310,"// If we optimistically assume that the MIG routine never re-uses the storage; // that was passed to it as arguments when it invalidates it (but at most when; // it assigns to parameter variables directly), this procedure correctly; // determines if the value was loaded from the transitive closure of MIG; // routine arguments in the heap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:186,Modifiability,variab,variables,186,"// If we optimistically assume that the MIG routine never re-uses the storage; // that was passed to it as arguments when it invalidates it (but at most when; // it assigns to parameter variables directly), this procedure correctly; // determines if the value was loaded from the transitive closure of MIG; // routine arguments in the heap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:264,Performance,load,loaded,264,"// If we optimistically assume that the MIG routine never re-uses the storage; // that was passed to it as arguments when it invalidates it (but at most when; // it assigns to parameter variables directly), this procedure correctly; // determines if the value was loaded from the transitive closure of MIG; // routine arguments in the heap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:134,Availability,error,error,134,"// Even though there's a Sema warning when the return type of an annotated; // function is not a kern_return_t, this warning isn't an error, so we need; // an extra check here.; // FIXME: AnyCall doesn't support blocks yet, so they remain unchecked; // for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:177,Deployability,release,releases,177,"// If the code is doing reference counting over the parameter,; // it opens up an opportunity for safely calling a destructor function.; // TODO: We should still check for over-releases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:98,Safety,safe,safely,98,"// If the code is doing reference counting over the parameter,; // it opens up an opportunity for safely calling a destructor function.; // TODO: We should still check for over-releases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:44,Availability,error,error,44,"// If none of the above, it's definitely an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:140,Integrability,rout,routine,140,"// It is very unlikely that a MIG callback will be called from anywhere; // within the project under analysis and the caller isn't itself a routine; // that follows the MIG calling convention. Therefore we're safe to believe; // that it's always the top frame that is of interest. There's a slight chance; // that the user would want to enforce the MIG calling convention upon; // a random routine in the middle of nowhere, but given that the convention is; // fairly weird and hard to follow in the first place, there's relatively; // little motivation to spread it this way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:390,Integrability,rout,routine,390,"// It is very unlikely that a MIG callback will be called from anywhere; // within the project under analysis and the caller isn't itself a routine; // that follows the MIG calling convention. Therefore we're safe to believe; // that it's always the top frame that is of interest. There's a slight chance; // that the user would want to enforce the MIG calling convention upon; // a random routine in the middle of nowhere, but given that the convention is; // fairly weird and hard to follow in the first place, there's relatively; // little motivation to spread it this way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:209,Safety,safe,safe,209,"// It is very unlikely that a MIG callback will be called from anywhere; // within the project under analysis and the caller isn't itself a routine; // that follows the MIG calling convention. Therefore we're safe to believe; // that it's always the top frame that is of interest. There's a slight chance; // that the user would want to enforce the MIG calling convention upon; // a random routine in the middle of nowhere, but given that the convention is; // fairly weird and hard to follow in the first place, there's relatively; // little motivation to spread it this way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:124,Availability,error,error,124,"// We know that the function is non-void, but what if the return statement; // is not there in the code? It's not a compile error, we should not crash.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MismatchedIteratorChecker.cpp:329,Safety,safe,safely,329,"// The main purpose of iterators is to abstract away from different; // containers and provide a (maybe limited) uniform access to them.; // This implies that any correctly written template function that; // works on multiple containers using iterators takes different; // template parameters for different containers. So we can safely; // assume that passing iterators of different containers as arguments; // whose type replaces the same template parameter is a bug.; //; // Example:; // template<typename I1, typename I2>; // void f(I1 first1, I1 last1, I2 first2, I2 last2);; //; // In this case the first two arguments to f() must be iterators must belong; // to the same container and the last to also to the same container but; // not necessarily to the same as the first two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MismatchedIteratorChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MismatchedIteratorChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MismatchedIteratorChecker.cpp:121,Security,access,access,121,"// The main purpose of iterators is to abstract away from different; // containers and provide a (maybe limited) uniform access to them.; // This implies that any correctly written template function that; // works on multiple containers using iterators takes different; // template parameters for different containers. So we can safely; // assume that passing iterators of different containers as arguments; // whose type replaces the same template parameter is a bug.; //; // Example:; // template<typename I1, typename I2>; // void f(I1 first1, I1 last1, I2 first2, I2 last2);; //; // In this case the first two arguments to f() must be iterators must belong; // to the same container and the last to also to the same container but; // not necessarily to the same as the first two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MismatchedIteratorChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MismatchedIteratorChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MmapWriteExecChecker.cpp:396,Testability,test,tests,396,"// MmapWriteExecChecker.cpp - Check for the prot argument -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker tests the 3rd argument of mmap's calls to check if; // it is writable and executable in the same time. It's somehow; // an optional checker since for example in JIT libraries it is pretty common.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MmapWriteExecChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MmapWriteExecChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Move.h:455,Integrability,depend,dependent,455,"//=== Move.h - Tracking moved-from objects. ------------------------*- C++ -*-//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Defines inter-checker API for the use-after-move checker. It allows; // dependent checkers to figure out if an object is in a moved-from state.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Move.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Move.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp:30,Safety,unsafe,unsafe,30,// Warn only about known move-unsafe classes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp:19,Modifiability,variab,variable,19,// Is this a local variable or a local rvalue reference?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp:38,Safety,safe,safe,38,"// Not all of these are entirely move-safe, but they do provide *some*; // guarantees, and it means that somebody is using them after move; // in a valid manner.; // TODO: We can still try to identify *unsafe* use after move,; // like we did with smart pointers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp:202,Safety,unsafe,unsafe,202,"// Not all of these are entirely move-safe, but they do provide *some*; // guarantees, and it means that somebody is using them after move; // in a valid manner.; // TODO: We can still try to identify *unsafe* use after move,; // like we did with smart pointers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp:556,Integrability,contract,contracts,556,"// In non-aggressive mode, only warn on use-after-move of local variables; // (or local rvalue references) and of STL objects. The former is possible; // because local variables (or local rvalue references) are not tempting; // their user to re-use the storage. The latter is possible because STL; // objects are known to end up in a valid but unspecified state after the; // move and their state-reset methods are also known, which allows us to; // predict precisely when use-after-move is invalid.; // Some STL objects are known to conform to additional contracts after move,; // so they are not tracked. However, smart pointers specifically are tracked; // because we can perform extra checking over them.; // In aggressive mode, warn on any use-after-move because the user has; // intentionally asked us to completely eliminate use-after-move; // in his code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp:64,Modifiability,variab,variables,64,"// In non-aggressive mode, only warn on use-after-move of local variables; // (or local rvalue references) and of STL objects. The former is possible; // because local variables (or local rvalue references) are not tempting; // their user to re-use the storage. The latter is possible because STL; // objects are known to end up in a valid but unspecified state after the; // move and their state-reset methods are also known, which allows us to; // predict precisely when use-after-move is invalid.; // Some STL objects are known to conform to additional contracts after move,; // so they are not tracked. However, smart pointers specifically are tracked; // because we can perform extra checking over them.; // In aggressive mode, warn on any use-after-move because the user has; // intentionally asked us to completely eliminate use-after-move; // in his code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp:168,Modifiability,variab,variables,168,"// In non-aggressive mode, only warn on use-after-move of local variables; // (or local rvalue references) and of STL objects. The former is possible; // because local variables (or local rvalue references) are not tempting; // their user to re-use the storage. The latter is possible because STL; // objects are known to end up in a valid but unspecified state after the; // move and their state-reset methods are also known, which allows us to; // predict precisely when use-after-move is invalid.; // Some STL objects are known to conform to additional contracts after move,; // so they are not tracked. However, smart pointers specifically are tracked; // because we can perform extra checking over them.; // In aggressive mode, warn on any use-after-move because the user has; // intentionally asked us to completely eliminate use-after-move; // in his code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp:675,Performance,perform,perform,675,"// In non-aggressive mode, only warn on use-after-move of local variables; // (or local rvalue references) and of STL objects. The former is possible; // because local variables (or local rvalue references) are not tempting; // their user to re-use the storage. The latter is possible because STL; // objects are known to end up in a valid but unspecified state after the; // move and their state-reset methods are also known, which allows us to; // predict precisely when use-after-move is invalid.; // Some STL objects are known to conform to additional contracts after move,; // so they are not tracked. However, smart pointers specifically are tracked; // because we can perform extra checking over them.; // In aggressive mode, warn on any use-after-move because the user has; // intentionally asked us to completely eliminate use-after-move; // in his code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp:450,Safety,predict,predict,450,"// In non-aggressive mode, only warn on use-after-move of local variables; // (or local rvalue references) and of STL objects. The former is possible; // because local variables (or local rvalue references) are not tempting; // their user to re-use the storage. The latter is possible because STL; // objects are known to end up in a valid but unspecified state after the; // move and their state-reset methods are also known, which allows us to; // predict precisely when use-after-move is invalid.; // Some STL objects are known to conform to additional contracts after move,; // so they are not tracked. However, smart pointers specifically are tracked; // because we can perform extra checking over them.; // In aggressive mode, warn on any use-after-move because the user has; // intentionally asked us to completely eliminate use-after-move; // in his code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp:37,Usability,user-friendly,user-friendly,37,// Classifies the object and dumps a user-friendly description string to; // the stream.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp:16,Availability,error,error,16,// Creating the error message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp:22,Integrability,message,message,22,// Creating the error message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp:19,Availability,error,error,19,// Don't report an error inside a move related operation.; // We assume that the programmer knows what she does.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp:9,Modifiability,variab,variables,9,"// Local variables and local rvalue references are classified as ""Local"".; // For the purposes of this checker, we classify move-safe STL types; // as not-""STL"" types, because that's how the checker treats them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp:129,Safety,safe,safe,129,"// Local variables and local rvalue references are classified as ""Local"".; // For the purposes of this checker, we classify move-safe STL types; // as not-""STL"" types, because that's how the checker treats them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonnullGlobalConstantsChecker.cpp:36,Performance,cache,cache,36,// namespace; /// Lazily initialize cache for required identifier information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonnullGlobalConstantsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonnullGlobalConstantsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonnullGlobalConstantsChecker.cpp:19,Modifiability,variab,variable,19,// Assume that the variable is non-null.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonnullGlobalConstantsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonnullGlobalConstantsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonnullGlobalConstantsChecker.cpp:13,Performance,load,loaded,13,/// \param V loaded lvalue.; /// \return whether @c val is a string-like const global.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonnullGlobalConstantsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonnullGlobalConstantsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp:50,Performance,perform,perform,50,"// If the value is unknown or undefined, we can't perform this check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp:15,Availability,error,error,15,// Generate an error node. Check for a null node in case; // we cache out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp:64,Performance,cache,cache,64,// Generate an error node. Check for a null node in case; // we cache out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp:61,Availability,error,error,61,// Always return. Either we cached out or we just emitted an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp:28,Performance,cache,cached,28,// Always return. Either we cached out or we just emitted an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp:91,Deployability,update,updated,91,// If we reach here all of the arguments passed the nonnull check.; // If 'state' has been updated generated a new node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp:440,Availability,error,error,440,"/// We want to trust developer annotations and consider all 'nonnull' parameters; /// as non-null indeed. Each marked parameter will get a corresponding; /// constraint.; ///; /// This approach will not only help us to get rid of some false positives, but; /// remove duplicates and shorten warning traces as well.; ///; /// \code; /// void foo(int *x) [[gnu::nonnull]] {; /// // . . .; /// *x = 42; // we don't want to consider this as an error...; /// // . . .; /// }; ///; /// foo(nullptr); // ...and report here instead; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp:109,Integrability,interface,interfaces,109,// AnyCall helps us here to avoid checking for FunctionDecl and ObjCMethodDecl; // separately and aggregates interfaces of these classes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp:28,Safety,avoid,avoid,28,// AnyCall helps us here to avoid checking for FunctionDecl and ObjCMethodDecl; // separately and aggregates interfaces of these classes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NoReturnFunctionChecker.cpp:149,Performance,cache,cache,149,"// HACK: Some functions are not marked noreturn, and don't return.; // Here are a few hardwired ones. If this takes too long, we can; // potentially cache these results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NoReturnFunctionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NoReturnFunctionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NoReturnFunctionChecker.cpp:25,Integrability,wrap,wrapper,25,// FIXME: This is just a wrapper around throwing an exception.; // Eventually inter-procedural analysis should handle this easily.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NoReturnFunctionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NoReturnFunctionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NoReturnFunctionChecker.cpp:44,Integrability,message,messages,44,"// HACK: This entire check is to handle two messages in the Cocoa frameworks:; // -[NSAssertionHandler; // handleFailureInMethod:object:file:lineNumber:description:]; // -[NSAssertionHandler; // handleFailureInFunction:file:lineNumber:description:]; // Eventually these should be annotated with __attribute__((noreturn)).; // Because ObjC messages use dynamic dispatch, it is not generally safe to; // assume certain methods can't return. In cases where it is definitely valid,; // see if you can mark the methods noreturn or analyzer_noreturn instead of; // adding more explicit checks to this method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NoReturnFunctionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NoReturnFunctionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NoReturnFunctionChecker.cpp:339,Integrability,message,messages,339,"// HACK: This entire check is to handle two messages in the Cocoa frameworks:; // -[NSAssertionHandler; // handleFailureInMethod:object:file:lineNumber:description:]; // -[NSAssertionHandler; // handleFailureInFunction:file:lineNumber:description:]; // Eventually these should be annotated with __attribute__((noreturn)).; // Because ObjC messages use dynamic dispatch, it is not generally safe to; // assume certain methods can't return. In cases where it is definitely valid,; // see if you can mark the methods noreturn or analyzer_noreturn instead of; // adding more explicit checks to this method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NoReturnFunctionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NoReturnFunctionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NoReturnFunctionChecker.cpp:390,Safety,safe,safe,390,"// HACK: This entire check is to handle two messages in the Cocoa frameworks:; // -[NSAssertionHandler; // handleFailureInMethod:object:file:lineNumber:description:]; // -[NSAssertionHandler; // handleFailureInFunction:file:lineNumber:description:]; // Eventually these should be annotated with __attribute__((noreturn)).; // Because ObjC messages use dynamic dispatch, it is not generally safe to; // assume certain methods can't return. In cases where it is definitely valid,; // see if you can mark the methods noreturn or analyzer_noreturn instead of; // adding more explicit checks to this method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NoReturnFunctionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NoReturnFunctionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NoReturnFunctionChecker.cpp:35,Integrability,message,messages,35,"// If we got here, it's one of the messages we care about.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NoReturnFunctionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NoReturnFunctionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NSAutoreleasePoolChecker.cpp:739,Integrability,interface,interface,739,"//=- NSAutoreleasePoolChecker.cpp --------------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a NSAutoreleasePoolChecker, a small checker that warns; // about subpar uses of NSAutoreleasePool. Note that while the check itself; // (in its current form) could be written as a flow-insensitive check, in; // can be potentially enhanced in the future with flow-sensitive information.; // It is also a good example of the CheckerVisitor interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NSAutoreleasePoolChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NSAutoreleasePoolChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NSAutoreleasePoolChecker.cpp:631,Modifiability,enhance,enhanced,631,"//=- NSAutoreleasePoolChecker.cpp --------------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a NSAutoreleasePoolChecker, a small checker that warns; // about subpar uses of NSAutoreleasePool. Note that while the check itself; // (in its current form) could be written as a flow-insensitive check, in; // can be potentially enhanced in the future with flow-sensitive information.; // It is also a good example of the CheckerVisitor interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NSAutoreleasePoolChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NSAutoreleasePoolChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NSAutoreleasePoolChecker.cpp:12,Deployability,release,release,12,// Sending 'release' message?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NSAutoreleasePoolChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NSAutoreleasePoolChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NSAutoreleasePoolChecker.cpp:21,Integrability,message,message,21,// Sending 'release' message?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NSAutoreleasePoolChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NSAutoreleasePoolChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NSErrorChecker.cpp:486,Integrability,interface,interface,486,"//=- NSErrorChecker.cpp - Coding conventions for uses of NSError -*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a CheckNSError, a flow-insensitive check; // that determines if an Objective-C class interface correctly returns; // a non-void return type.; //; // File under feature request PR 2600.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NSErrorChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NSErrorChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NSErrorChecker.cpp:35,Integrability,wrap,wraps,35,// We tag the symbol that the SVal wraps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NSErrorChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NSErrorChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NSErrorChecker.cpp:13,Performance,load,loading,13,"// If we are loading from NSError**/CFErrorRef* parameter, mark the resulting; // SVal so that we can later check it when handling the; // ImplicitNullDerefEvent event.; // FIXME: Cumbersome! Maybe add hook at construction of SVals at start of; // function ?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NSErrorChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NSErrorChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:1128,Testability,assert,asserts,1128,"//===-- NullabilityChecker.cpp - Nullability checker ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker tries to find nullability violations. There are several kinds of; // possible violations:; // * Null pointer is passed to a pointer which has a _Nonnull type.; // * Null pointer is returned from a function which has a _Nonnull return type.; // * Nullable pointer is passed to a pointer which has a _Nonnull type.; // * Nullable pointer is returned from a function which has a _Nonnull return; // type.; // * Nullable pointer is dereferenced.; //; // This checker propagates the nullability information of the pointers and looks; // for the patterns that are described above. Explicit casts are trusted and are; // considered a way to suppress false positives for this checker. The other way; // to suppress warnings would be to add asserts or guarding if statements to the; // code. In addition to the nullability propagation this checker also uses some; // heuristics to suppress potential false positives.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:60,Integrability,message,message,60,"/// Returns the most nullable nullability. This is used for message expressions; /// like [receiver method], where the nullability of this expression is either; /// the nullability of the receiver or the nullability of the return type of the; /// method, depending on which is more nullable. Contradicted is considered to; /// be the most nullable, to avoid false positive results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:255,Integrability,depend,depending,255,"/// Returns the most nullable nullability. This is used for message expressions; /// like [receiver method], where the nullability of this expression is either; /// the nullability of the receiver or the nullability of the return type of the; /// method, depending on which is more nullable. Contradicted is considered to; /// be the most nullable, to avoid false positive results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:352,Safety,avoid,avoid,352,"/// Returns the most nullable nullability. This is used for message expressions; /// like [receiver method], where the nullability of this expression is either; /// the nullability of the receiver or the nullability of the return type of the; /// method, depending on which is more nullable. Contradicted is considered to; /// be the most nullable, to avoid false positive results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:39,Availability,Error,ErrorMessages,39,// These enums are used as an index to ErrorMessages array.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:111,Availability,error,errors,111,// When set to false no nullability information will be tracked in; // NullabilityMap. It is possible to catch errors like passing a null pointer; // to a callee that expects nonnull argument without the information that is; // stored in the NullabilityMap. This is an optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:269,Performance,optimiz,optimization,269,// When set to false no nullability information will be tracked in; // NullabilityMap. It is possible to catch errors like passing a null pointer; // to a callee that expects nonnull argument without the information that is; // stored in the NullabilityMap. This is an optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:15,Integrability,wrap,wraps,15,"/// If an SVal wraps a region that should be tracked, it will return a pointer; /// to the wrapped region. Otherwise it will return a nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:91,Integrability,wrap,wrapped,91,"/// If an SVal wraps a region that should be tracked, it will return a pointer; /// to the wrapped region. Otherwise it will return a nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:73,Deployability,configurat,configuration,73,/// Returns true if the call is diagnosable in the current analyzer; /// configuration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:73,Modifiability,config,configuration,73,/// Returns true if the call is diagnosable in the current analyzer; /// configuration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:83,Integrability,message,message,83,"// Source is the expression which determined the nullability. For example in a; // message like [nullable nonnull_returning] has nullable nullability, because; // the receiver is nullable. Here the receiver will be the source of the; // nullability. This is useful information when the diagnostics are generated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:51,Security,access,accesses,51,"// For the purpose of tracking historical property accesses, the key for lookup; // is an object pointer (could be an instance or a class) paired with the unique; // identifier for the property being invoked on that object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:70,Security,access,access,70,// Metadata associated with the return value from a recorded property access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:222,Safety,detect,detected,222,"// We say ""the nullability type invariant is violated"" when a location with a; // non-null type contains NULL or a function with a non-null return type returns; // NULL. Violations of the nullability type invariant can be detected either; // directly (for example, when NULL is passed as an argument to a nonnull; // parameter) or indirectly (for example, when, inside a function, the; // programmer defensively checks whether a nonnull parameter contains NULL and; // finds that it does).; //; // As a matter of policy, the nullability checker typically warns on direct; // violations of the nullability invariant (although it uses various; // heuristics to suppress warnings in some cases) but will not warn if the; // invariant has already been violated along the path (either directly or; // indirectly). As a practical matter, this prevents the analyzer from; // (1) warning on defensive code paths where a nullability precondition is; // determined to have been violated, (2) warning additional times after an; // initial direct violation has been discovered, and (3) warning after a direct; // violation that has been implicitly or explicitly suppressed (for; // example, with a cast of NULL to _Nonnull). In essence, once an invariant; // violation is detected on a path, this checker will be essentially turned off; // for the rest of the analysis; //; // The analyzer takes this approach (rather than generating a sink node) to; // ensure coverage of defensive paths, which may be important for backwards; // compatibility in codebases that were developed without nullability in mind.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:1260,Safety,detect,detected,1260,"// We say ""the nullability type invariant is violated"" when a location with a; // non-null type contains NULL or a function with a non-null return type returns; // NULL. Violations of the nullability type invariant can be detected either; // directly (for example, when NULL is passed as an argument to a nonnull; // parameter) or indirectly (for example, when, inside a function, the; // programmer defensively checks whether a nonnull parameter contains NULL and; // finds that it does).; //; // As a matter of policy, the nullability checker typically warns on direct; // violations of the nullability invariant (although it uses various; // heuristics to suppress warnings in some cases) but will not warn if the; // invariant has already been violated along the path (either directly or; // indirectly). As a practical matter, this prevents the analyzer from; // (1) warning on defensive code paths where a nullability precondition is; // determined to have been violated, (2) warning additional times after an; // initial direct violation has been discovered, and (3) warning after a direct; // violation that has been implicitly or explicitly suppressed (for; // example, with a cast of NULL to _Nonnull). In essence, once an invariant; // violation is detected on a path, this checker will be essentially turned off; // for the rest of the analysis; //; // The analyzer takes this approach (rather than generating a sink node) to; // ensure coverage of defensive paths, which may be important for backwards; // compatibility in codebases that were developed without nullability in mind.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:390,Integrability,depend,depending,390,"// If the value was constrained to null *after* it was passed through that; // location, it could not have been a concrete pointer *when* it was passed.; // In that case we would have handled the situation when the value was; // bound to that location, by emitting (or not emitting) a report.; // Therefore we are only interested in symbolic regions that can be either; // null or non-null depending on the value of their respective symbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:94,Security,access,accesses,94,"// When an object goes out of scope, we can free the history associated; // with any property accesses on that object",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:176,Availability,error,error,176,"// When one of the nonnull arguments are constrained to be null, nullability; // preconditions are violated. It is not enough to check this only when we; // actually report an error, because at that time interesting symbols might be; // reaped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:19,Availability,error,errors,19,"// Do not suppress errors on defensive code paths, because dereferencing; // a nullable pointer is always an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:109,Availability,error,error,109,"// Do not suppress errors on defensive code paths, because dereferencing; // a nullable pointer is always an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:21,Performance,load,load,21,"// Whenever we see a load from a typed memory region that's been annotated as; // 'nonnull', we want to trust the user on that and assume that it is is indeed; // non-null.; //; // We do so even if the value is known to have been assigned to null.; // The user should be warned on assigning the null value to a non-null pointer; // as opposed to warning on the later dereference of this pointer.; //; // \code; // int * _Nonnull var = 0; // we want to warn the user here...; // // . . .; // *var = 42; // ...and not here; // \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:29,Performance,load,loads,29,// We should care only about loads.; // The main idea is to add a constraint whenever we're loading a value from; // an annotated pointer type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:92,Performance,load,loading,92,// We should care only about loads.; // The main idea is to add a constraint whenever we're loading a value from; // an annotated pointer type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:33,Safety,avoid,avoid,33,// HACK: This is a big hammer to avoid warning when there are defensive; // nil checks in -init and -copy methods. We should add more sophisticated; // logic here to suppress on common defensive idioms but still; // warn when there is a likely problem.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:152,Testability,log,logic,152,// HACK: This is a big hammer to avoid warning when there are defensive; // nil checks in -init and -copy methods. We should add more sophisticated; // logic here to suppress on common defensive idioms but still; // warn when there is a likely problem.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:8,Integrability,Message,Messages,8,// ObjC Messages handles in a different callback.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:34,Security,access,access,34,// The return value of a property access is typically a temporary value which; // will not be tracked in a persistent manner by the analyzer. We use; // evalAssume() in order to immediately record constraints on those temporaries; // at the time they are imposed (e.g. by a nil-check conditional).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:9,Performance,optimiz,optimization,9,// Space optimization: no point in tracking constrained-null cases,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:49,Integrability,message,message,49,"/// Calculate the nullability of the result of a message expr based on the; /// nullability of the receiver, the nullability of the return value, and the; /// constraints.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:15,Energy Efficiency,reduce,reduce,15,"// In order to reduce the noise in the diagnostics generated by this checker,; // some framework and programming style based heuristics are used. These; // heuristics are for Cocoa APIs which have NS prefix.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:67,Availability,avail,available,67,"// Developers rely on dynamic invariants such as an item should be available; // in a collection, or a collection is not empty often. Those invariants can; // not be inferred by any static analysis tool. To not to bother the users; // with too many false positives, every item retrieval function should be; // ignored for collections. The instance methods of dictionaries in Cocoa; // are either item retrieval related or not interesting nullability wise.; // Using this fact, to keep the code easier to read just ignore the return; // value of every instance method of dictionaries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:172,Energy Efficiency,reduce,reduced,172,// Encoding related methods of string should not fail when lossless; // encodings are used. Using lossless encodings is so frequent that ignoring; // this class of methods reduced the emitted diagnostics by about 30% on; // some projects (and all of that was false positives).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:450,Energy Efficiency,reduce,reduce,450,"// Properties might be computed, which means the property value could; // theoretically change between calls even in commonly-observed cases like; // this:; //; // if (foo.prop) { // ok, it's nonnull here...; // [bar doStuffWithNonnullVal:foo.prop]; // ...but what about; // here?; // }; //; // If the property is nullable-annotated, a naive analysis would lead to many; // false positives despite the presence of probably-correct nil-checks. To; // reduce the false positive rate, we maintain a history of the most recently; // observed property value. For each property access, if the prior value has; // been constrained to be not nil then we will conservatively assume that the; // next access can be inferred as nonnull.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:572,Security,access,access,572,"// Properties might be computed, which means the property value could; // theoretically change between calls even in commonly-observed cases like; // this:; //; // if (foo.prop) { // ok, it's nonnull here...; // [bar doStuffWithNonnullVal:foo.prop]; // ...but what about; // here?; // }; //; // If the property is nullable-annotated, a naive analysis would lead to many; // false positives despite the presence of probably-correct nil-checks. To; // reduce the false positive rate, we maintain a history of the most recently; // observed property value. For each property access, if the prior value has; // been constrained to be not nil then we will conservatively assume that the; // next access can be inferred as nonnull.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:691,Security,access,access,691,"// Properties might be computed, which means the property value could; // theoretically change between calls even in commonly-observed cases like; // this:; //; // if (foo.prop) { // ok, it's nonnull here...; // [bar doStuffWithNonnullVal:foo.prop]; // ...but what about; // here?; // }; //; // If the property is nullable-annotated, a naive analysis would lead to many; // false positives despite the presence of probably-correct nil-checks. To; // reduce the false positive rate, we maintain a history of the most recently; // observed property value. For each property access, if the prior value has; // been constrained to be not nil then we will conservatively assume that the; // next access can be inferred as nonnull.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:26,Security,access,access,26,"// If a previous property access was constrained as nonnull, we hold; // on to that constraint (effectively inferring that all subsequent; // accesses on that code path can be inferred as nonnull). If the; // previous property access was *not* constrained as nonnull, then; // let's throw it away in favor of keeping the SVal associated with; // this more recent access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:142,Security,access,accesses,142,"// If a previous property access was constrained as nonnull, we hold; // on to that constraint (effectively inferring that all subsequent; // accesses on that code path can be inferred as nonnull). If the; // previous property access was *not* constrained as nonnull, then; // let's throw it away in favor of keeping the SVal associated with; // this more recent access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:227,Security,access,access,227,"// If a previous property access was constrained as nonnull, we hold; // on to that constraint (effectively inferring that all subsequent; // accesses on that code path can be inferred as nonnull). If the; // previous property access was *not* constrained as nonnull, then; // let's throw it away in favor of keeping the SVal associated with; // this more recent access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:363,Security,access,access,363,"// If a previous property access was constrained as nonnull, we hold; // on to that constraint (effectively inferring that all subsequent; // accesses on that code path can be inferred as nonnull). If the; // previous property access was *not* constrained as nonnull, then; // let's throw it away in favor of keeping the SVal associated with; // this more recent access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:26,Performance,perform,performing,26,"/// For a given statement performing a bind, attempt to syntactically; /// match the expression resulting in the bound value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:55,Modifiability,variab,variable,55,/// Returns true if \param S is a DeclStmt for a local variable that; /// ObjC automated reference counting initialized with zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:125,Modifiability,variab,variable,125,// We suppress diagnostics for ARC zero-initialized _Nonnull locals. This; // prevents false positives when a _Nonnull local variable cannot be; // initialized with an initialization expression:; // NSString * _Nonnull s; // no-warning; // @autoreleasepool {; // s = ...; // }; //; // FIXME: We should treat implicitly zero-initialized _Nonnull locals as; // uninitialized in Sema's UninitializedValues analysis to warn when a use of; // the zero-initialized definition will unexpectedly yield nil.; // Locals are only zero-initialized when automated reference counting; // is turned on.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:146,Performance,optimiz,optimization,146,// The checks are likely to be turned on by default and it is possible to do; // them without tracking any nullability related information. As an optimization; // no nullability information will be tracked when only these two checks are; // enables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp:1317,Modifiability,config,config,1317,"//===- NumberObjectConversionChecker.cpp -------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines NumberObjectConversionChecker, which checks for a; // particular common mistake when dealing with numbers represented as objects; // passed around by pointers. Namely, the language allows to reinterpret the; // pointer as a number directly, often without throwing any warnings,; // but in most cases the result of such conversion is clearly unexpected,; // as pointer value, rather than number value represented by the pointee object,; // becomes the result of such operation.; //; // Currently the checker supports the Objective-C NSNumber class,; // and the OSBoolean class found in macOS low-level code; the latter; // can only hold boolean values.; //; // This checker has an option ""Pedantic"" (boolean), which enables detection of; // more conversion patterns (which are most likely more harmless, and therefore; // are more likely to produce false positives) - disabled by default,; // enabled with `-analyzer-config osx.NumberObjectConversion:Pedantic=true'.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp:1124,Safety,detect,detection,1124,"//===- NumberObjectConversionChecker.cpp -------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines NumberObjectConversionChecker, which checks for a; // particular common mistake when dealing with numbers represented as objects; // passed around by pointers. Namely, the language allows to reinterpret the; // pointer as a number directly, often without throwing any warnings,; // but in most cases the result of such conversion is clearly unexpected,; // as pointer value, rather than number value represented by the pointee object,; // becomes the result of such operation.; //; // Currently the checker supports the Objective-C NSNumber class,; // and the OSBoolean class found in macOS low-level code; the latter; // can only hold boolean values.; //; // This checker has an option ""Pedantic"" (boolean), which enables detection of; // more conversion patterns (which are most likely more harmless, and therefore; // are more likely to produce false positives) - disabled by default,; // enabled with `-analyzer-config osx.NumberObjectConversion:Pedantic=true'.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp:734,Usability,clear,clearly,734,"//===- NumberObjectConversionChecker.cpp -------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines NumberObjectConversionChecker, which checks for a; // particular common mistake when dealing with numbers represented as objects; // passed around by pointers. Namely, the language allows to reinterpret the; // pointer as a number directly, often without throwing any warnings,; // but in most cases the result of such conversion is clearly unexpected,; // as pointer value, rather than number value represented by the pointee object,; // becomes the result of such operation.; //; // Currently the checker supports the Objective-C NSNumber class,; // and the OSBoolean class found in macOS low-level code; the latter; // can only hold boolean values.; //; // This checker has an option ""Pedantic"" (boolean), which enables detection of; // more conversion patterns (which are most likely more harmless, and therefore; // are more likely to produce false positives) - disabled by default,; // enabled with `-analyzer-config osx.NumberObjectConversion:Pedantic=true'.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp:98,Safety,avoid,avoid,98,"// Unless the macro indicates that the intended type is clearly not; // a pointer type, we should avoid warning on comparing pointers; // to zero literals in non-pedantic mode.; // FIXME: Introduce an AST matcher to implement the macro-related logic?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp:244,Testability,log,logic,244,"// Unless the macro indicates that the intended type is clearly not; // a pointer type, we should avoid warning on comparing pointers; // to zero literals in non-pedantic mode.; // FIXME: Introduce an AST matcher to implement the macro-related logic?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp:56,Usability,clear,clearly,56,"// Unless the macro indicates that the intended type is clearly not; // a pointer type, we should avoid warning on comparing pointers; // to zero literals in non-pedantic mode.; // FIXME: Introduce an AST matcher to implement the macro-related logic?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp:13,Integrability,message,message,13,// A generic message if we're not sure what API should be called.; // FIXME: Pattern-match the integer type to make a better guess?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp:45,Availability,error,error,45,// The .bind here is in order to compose the error message more accurately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp:51,Integrability,message,message,51,// The .bind here is in order to compose the error message more accurately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp:45,Availability,error,error,45,// The .bind here is in order to compose the error message more accurately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp:51,Integrability,message,message,51,// The .bind here is in order to compose the error message more accurately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp:45,Availability,error,error,45,// The .bind here is in order to compose the error message more accurately.; // Also avoid intptr_t and uintptr_t because they were specifically created; // for storing pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp:51,Integrability,message,message,51,// The .bind here is in order to compose the error message more accurately.; // Also avoid intptr_t and uintptr_t because they were specifically created; // for storing pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp:85,Safety,avoid,avoid,85,// The .bind here is in order to compose the error message more accurately.; // Also avoid intptr_t and uintptr_t because they were specifically created; // for storing pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp:49,Integrability,message,message,49,"// We bind ""check_if_null"" to modify the warning message; // in case it was intended to compare a pointer to 0 with a relatively-ok; // construct ""x == 0"" or ""x != 0"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAtSyncChecker.cpp:52,Integrability,synchroniz,synchronized,52,"//== ObjCAtSyncChecker.cpp - nil mutex checker for @synchronized -*- C++ -*--=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines ObjCAtSyncChecker, a builtin check that checks for null pointers; // used as mutexes for @synchronized.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAtSyncChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAtSyncChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAtSyncChecker.cpp:486,Integrability,synchroniz,synchronized,486,"//== ObjCAtSyncChecker.cpp - nil mutex checker for @synchronized -*- C++ -*--=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines ObjCAtSyncChecker, a builtin check that checks for null pointers; // used as mutexes for @synchronized.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAtSyncChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAtSyncChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAtSyncChecker.cpp:15,Availability,error,error,15,// Generate an error node. This isn't a sink since; // a null mutex just means no synchronization occurs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAtSyncChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAtSyncChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAtSyncChecker.cpp:82,Integrability,synchroniz,synchronization,82,// Generate an error node. This isn't a sink since; // a null mutex just means no synchronization occurs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAtSyncChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAtSyncChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp:570,Availability,error,error,570,"//===- ObjCAutoreleaseWriteChecker.cpp ----------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines ObjCAutoreleaseWriteChecker which warns against writes; // into autoreleased out parameters which cause crashes.; // An example of a problematic write is a write to @c error in the example; // below:; //; // - (BOOL) mymethod:(NSError *__autoreleasing *)error list:(NSArray*) list {; // [list enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {; // NSString *myString = obj;; // if ([myString isEqualToString:@""error""] && error); // *error = [NSError errorWithDomain:@""MyDomain"" code:-1];; // }];; // return false;; // }; //; // Such code will crash on read from `*error` due to the autorelease pool; // in `enumerateObjectsUsingBlock` implementation freeing the error object; // on exit from the function.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp:656,Availability,error,error,656,"//===- ObjCAutoreleaseWriteChecker.cpp ----------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines ObjCAutoreleaseWriteChecker which warns against writes; // into autoreleased out parameters which cause crashes.; // An example of a problematic write is a write to @c error in the example; // below:; //; // - (BOOL) mymethod:(NSError *__autoreleasing *)error list:(NSArray*) list {; // [list enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {; // NSString *myString = obj;; // if ([myString isEqualToString:@""error""] && error); // *error = [NSError errorWithDomain:@""MyDomain"" code:-1];; // }];; // return false;; // }; //; // Such code will crash on read from `*error` due to the autorelease pool; // in `enumerateObjectsUsingBlock` implementation freeing the error object; // on exit from the function.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp:828,Availability,error,error,828,"//===- ObjCAutoreleaseWriteChecker.cpp ----------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines ObjCAutoreleaseWriteChecker which warns against writes; // into autoreleased out parameters which cause crashes.; // An example of a problematic write is a write to @c error in the example; // below:; //; // - (BOOL) mymethod:(NSError *__autoreleasing *)error list:(NSArray*) list {; // [list enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {; // NSString *myString = obj;; // if ([myString isEqualToString:@""error""] && error); // *error = [NSError errorWithDomain:@""MyDomain"" code:-1];; // }];; // return false;; // }; //; // Such code will crash on read from `*error` due to the autorelease pool; // in `enumerateObjectsUsingBlock` implementation freeing the error object; // on exit from the function.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp:839,Availability,error,error,839,"//===- ObjCAutoreleaseWriteChecker.cpp ----------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines ObjCAutoreleaseWriteChecker which warns against writes; // into autoreleased out parameters which cause crashes.; // An example of a problematic write is a write to @c error in the example; // below:; //; // - (BOOL) mymethod:(NSError *__autoreleasing *)error list:(NSArray*) list {; // [list enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {; // NSString *myString = obj;; // if ([myString isEqualToString:@""error""] && error); // *error = [NSError errorWithDomain:@""MyDomain"" code:-1];; // }];; // return false;; // }; //; // Such code will crash on read from `*error` due to the autorelease pool; // in `enumerateObjectsUsingBlock` implementation freeing the error object; // on exit from the function.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp:851,Availability,error,error,851,"//===- ObjCAutoreleaseWriteChecker.cpp ----------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines ObjCAutoreleaseWriteChecker which warns against writes; // into autoreleased out parameters which cause crashes.; // An example of a problematic write is a write to @c error in the example; // below:; //; // - (BOOL) mymethod:(NSError *__autoreleasing *)error list:(NSArray*) list {; // [list enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {; // NSString *myString = obj;; // if ([myString isEqualToString:@""error""] && error); // *error = [NSError errorWithDomain:@""MyDomain"" code:-1];; // }];; // return false;; // }; //; // Such code will crash on read from `*error` due to the autorelease pool; // in `enumerateObjectsUsingBlock` implementation freeing the error object; // on exit from the function.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp:868,Availability,error,errorWithDomain,868,"//===- ObjCAutoreleaseWriteChecker.cpp ----------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines ObjCAutoreleaseWriteChecker which warns against writes; // into autoreleased out parameters which cause crashes.; // An example of a problematic write is a write to @c error in the example; // below:; //; // - (BOOL) mymethod:(NSError *__autoreleasing *)error list:(NSArray*) list {; // [list enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {; // NSString *myString = obj;; // if ([myString isEqualToString:@""error""] && error); // *error = [NSError errorWithDomain:@""MyDomain"" code:-1];; // }];; // return false;; // }; //; // Such code will crash on read from `*error` due to the autorelease pool; // in `enumerateObjectsUsingBlock` implementation freeing the error object; // on exit from the function.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp:982,Availability,error,error,982,"//===- ObjCAutoreleaseWriteChecker.cpp ----------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines ObjCAutoreleaseWriteChecker which warns against writes; // into autoreleased out parameters which cause crashes.; // An example of a problematic write is a write to @c error in the example; // below:; //; // - (BOOL) mymethod:(NSError *__autoreleasing *)error list:(NSArray*) list {; // [list enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {; // NSString *myString = obj;; // if ([myString isEqualToString:@""error""] && error); // *error = [NSError errorWithDomain:@""MyDomain"" code:-1];; // }];; // return false;; // }; //; // Such code will crash on read from `*error` due to the autorelease pool; // in `enumerateObjectsUsingBlock` implementation freeing the error object; // on exit from the function.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp:1080,Availability,error,error,1080,"//===- ObjCAutoreleaseWriteChecker.cpp ----------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines ObjCAutoreleaseWriteChecker which warns against writes; // into autoreleased out parameters which cause crashes.; // An example of a problematic write is a write to @c error in the example; // below:; //; // - (BOOL) mymethod:(NSError *__autoreleasing *)error list:(NSArray*) list {; // [list enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {; // NSString *myString = obj;; // if ([myString isEqualToString:@""error""] && error); // *error = [NSError errorWithDomain:@""MyDomain"" code:-1];; // }];; // return false;; // }; //; // Such code will crash on read from `*error` due to the autorelease pool; // in `enumerateObjectsUsingBlock` implementation freeing the error object; // on exit from the function.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp:39,Availability,avail,available,39,"// Prefer to warn on write, but if not available, warn on capture.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCContainersASTChecker.cpp:86,Safety,avoid,avoid,86,"// If the type is a pointer to an array, check the size of the array; // elements. To avoid false positives coming from assumption that the; // values x and &x are equal when x is an array.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCContainersASTChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCContainersASTChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCContainersASTChecker.cpp:27,Usability,simpl,simple,27,"// if no identifier, not a simple C function",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCContainersASTChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCContainersASTChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCContainersChecker.cpp:383,Performance,Perform,Performs,383,"//== ObjCContainersChecker.cpp - Path sensitive checker for CFArray *- C++ -*=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Performs path sensitive checks of Core Foundation static containers like; // CFArray.; // 1) Check for buffer overflows:; // In CFArrayGetArrayAtIndex( myArray, index), if the index is outside the; // index space of theArray (0 to N-1 inclusive (where N is the count of; // theArray), the behavior is undefined.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCContainersChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCContainersChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCContainersChecker.cpp:19,Security,access,access,19,// Check the array access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCContainersChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCContainersChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCMissingSuperCallChecker.cpp:391,Availability,recover,recovered,391,"/*; ToDo list for expanding this check in the future, the list is not exhaustive.; There are also cases where calling super is suggested but not ""mandatory"".; In addition to be able to check the classes and methods below, architectural; improvements like being able to allow for the super-call to be done in a called; method would be good too. UIDocument subclasses; - finishedHandlingError:recovered: (is multi-arg); - finishedHandlingError:recovered: (is multi-arg). UIViewController subclasses; - loadView (should *never* call super); - transitionFromViewController:toViewController:; duration:options:animations:completion: (is multi-arg). UICollectionViewController subclasses; - loadView (take care because UIViewController subclasses should NOT call super; in loadView, but UICollectionViewController subclasses should). NSObject subclasses; - doesNotRecognizeSelector (it only has to call super if it doesn't throw). UIPopoverBackgroundView subclasses (some of those are class methods); - arrowDirection (should *never* call super); - arrowOffset (should *never* call super); - arrowBase (should *never* call super); - arrowHeight (should *never* call super); - contentViewInsets (should *never* call super). UITextSelectionRect subclasses (some of those are properties); - rect (should *never* call super); - range (should *never* call super); - writingDirection (should *never* call super); - isVertical (should *never* call super); - containsStart (should *never* call super); - containsEnd (should *never* call super); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCMissingSuperCallChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCMissingSuperCallChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCMissingSuperCallChecker.cpp:442,Availability,recover,recovered,442,"/*; ToDo list for expanding this check in the future, the list is not exhaustive.; There are also cases where calling super is suggested but not ""mandatory"".; In addition to be able to check the classes and methods below, architectural; improvements like being able to allow for the super-call to be done in a called; method would be good too. UIDocument subclasses; - finishedHandlingError:recovered: (is multi-arg); - finishedHandlingError:recovered: (is multi-arg). UIViewController subclasses; - loadView (should *never* call super); - transitionFromViewController:toViewController:; duration:options:animations:completion: (is multi-arg). UICollectionViewController subclasses; - loadView (take care because UIViewController subclasses should NOT call super; in loadView, but UICollectionViewController subclasses should). NSObject subclasses; - doesNotRecognizeSelector (it only has to call super if it doesn't throw). UIPopoverBackgroundView subclasses (some of those are class methods); - arrowDirection (should *never* call super); - arrowOffset (should *never* call super); - arrowBase (should *never* call super); - arrowHeight (should *never* call super); - contentViewInsets (should *never* call super). UITextSelectionRect subclasses (some of those are properties); - rect (should *never* call super); - range (should *never* call super); - writingDirection (should *never* call super); - isVertical (should *never* call super); - containsStart (should *never* call super); - containsEnd (should *never* call super); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCMissingSuperCallChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCMissingSuperCallChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCMissingSuperCallChecker.cpp:500,Performance,load,loadView,500,"/*; ToDo list for expanding this check in the future, the list is not exhaustive.; There are also cases where calling super is suggested but not ""mandatory"".; In addition to be able to check the classes and methods below, architectural; improvements like being able to allow for the super-call to be done in a called; method would be good too. UIDocument subclasses; - finishedHandlingError:recovered: (is multi-arg); - finishedHandlingError:recovered: (is multi-arg). UIViewController subclasses; - loadView (should *never* call super); - transitionFromViewController:toViewController:; duration:options:animations:completion: (is multi-arg). UICollectionViewController subclasses; - loadView (take care because UIViewController subclasses should NOT call super; in loadView, but UICollectionViewController subclasses should). NSObject subclasses; - doesNotRecognizeSelector (it only has to call super if it doesn't throw). UIPopoverBackgroundView subclasses (some of those are class methods); - arrowDirection (should *never* call super); - arrowOffset (should *never* call super); - arrowBase (should *never* call super); - arrowHeight (should *never* call super); - contentViewInsets (should *never* call super). UITextSelectionRect subclasses (some of those are properties); - rect (should *never* call super); - range (should *never* call super); - writingDirection (should *never* call super); - isVertical (should *never* call super); - containsStart (should *never* call super); - containsEnd (should *never* call super); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCMissingSuperCallChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCMissingSuperCallChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCMissingSuperCallChecker.cpp:685,Performance,load,loadView,685,"/*; ToDo list for expanding this check in the future, the list is not exhaustive.; There are also cases where calling super is suggested but not ""mandatory"".; In addition to be able to check the classes and methods below, architectural; improvements like being able to allow for the super-call to be done in a called; method would be good too. UIDocument subclasses; - finishedHandlingError:recovered: (is multi-arg); - finishedHandlingError:recovered: (is multi-arg). UIViewController subclasses; - loadView (should *never* call super); - transitionFromViewController:toViewController:; duration:options:animations:completion: (is multi-arg). UICollectionViewController subclasses; - loadView (take care because UIViewController subclasses should NOT call super; in loadView, but UICollectionViewController subclasses should). NSObject subclasses; - doesNotRecognizeSelector (it only has to call super if it doesn't throw). UIPopoverBackgroundView subclasses (some of those are class methods); - arrowDirection (should *never* call super); - arrowOffset (should *never* call super); - arrowBase (should *never* call super); - arrowHeight (should *never* call super); - contentViewInsets (should *never* call super). UITextSelectionRect subclasses (some of those are properties); - rect (should *never* call super); - range (should *never* call super); - writingDirection (should *never* call super); - isVertical (should *never* call super); - containsStart (should *never* call super); - containsEnd (should *never* call super); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCMissingSuperCallChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCMissingSuperCallChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCMissingSuperCallChecker.cpp:767,Performance,load,loadView,767,"/*; ToDo list for expanding this check in the future, the list is not exhaustive.; There are also cases where calling super is suggested but not ""mandatory"".; In addition to be able to check the classes and methods below, architectural; improvements like being able to allow for the super-call to be done in a called; method would be good too. UIDocument subclasses; - finishedHandlingError:recovered: (is multi-arg); - finishedHandlingError:recovered: (is multi-arg). UIViewController subclasses; - loadView (should *never* call super); - transitionFromViewController:toViewController:; duration:options:animations:completion: (is multi-arg). UICollectionViewController subclasses; - loadView (take care because UIViewController subclasses should NOT call super; in loadView, but UICollectionViewController subclasses should). NSObject subclasses; - doesNotRecognizeSelector (it only has to call super if it doesn't throw). UIPopoverBackgroundView subclasses (some of those are class methods); - arrowDirection (should *never* call super); - arrowOffset (should *never* call super); - arrowBase (should *never* call super); - arrowHeight (should *never* call super); - contentViewInsets (should *never* call super). UITextSelectionRect subclasses (some of those are properties); - rect (should *never* call super); - range (should *never* call super); - writingDirection (should *never* call super); - isVertical (should *never* call super); - containsStart (should *never* call super); - containsEnd (should *never* call super); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCMissingSuperCallChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCMissingSuperCallChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCMissingSuperCallChecker.cpp:391,Safety,recover,recovered,391,"/*; ToDo list for expanding this check in the future, the list is not exhaustive.; There are also cases where calling super is suggested but not ""mandatory"".; In addition to be able to check the classes and methods below, architectural; improvements like being able to allow for the super-call to be done in a called; method would be good too. UIDocument subclasses; - finishedHandlingError:recovered: (is multi-arg); - finishedHandlingError:recovered: (is multi-arg). UIViewController subclasses; - loadView (should *never* call super); - transitionFromViewController:toViewController:; duration:options:animations:completion: (is multi-arg). UICollectionViewController subclasses; - loadView (take care because UIViewController subclasses should NOT call super; in loadView, but UICollectionViewController subclasses should). NSObject subclasses; - doesNotRecognizeSelector (it only has to call super if it doesn't throw). UIPopoverBackgroundView subclasses (some of those are class methods); - arrowDirection (should *never* call super); - arrowOffset (should *never* call super); - arrowBase (should *never* call super); - arrowHeight (should *never* call super); - contentViewInsets (should *never* call super). UITextSelectionRect subclasses (some of those are properties); - rect (should *never* call super); - range (should *never* call super); - writingDirection (should *never* call super); - isVertical (should *never* call super); - containsStart (should *never* call super); - containsEnd (should *never* call super); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCMissingSuperCallChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCMissingSuperCallChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCMissingSuperCallChecker.cpp:442,Safety,recover,recovered,442,"/*; ToDo list for expanding this check in the future, the list is not exhaustive.; There are also cases where calling super is suggested but not ""mandatory"".; In addition to be able to check the classes and methods below, architectural; improvements like being able to allow for the super-call to be done in a called; method would be good too. UIDocument subclasses; - finishedHandlingError:recovered: (is multi-arg); - finishedHandlingError:recovered: (is multi-arg). UIViewController subclasses; - loadView (should *never* call super); - transitionFromViewController:toViewController:; duration:options:animations:completion: (is multi-arg). UICollectionViewController subclasses; - loadView (take care because UIViewController subclasses should NOT call super; in loadView, but UICollectionViewController subclasses should). NSObject subclasses; - doesNotRecognizeSelector (it only has to call super if it doesn't throw). UIPopoverBackgroundView subclasses (some of those are class methods); - arrowDirection (should *never* call super); - arrowOffset (should *never* call super); - arrowBase (should *never* call super); - arrowHeight (should *never* call super); - contentViewInsets (should *never* call super). UITextSelectionRect subclasses (some of those are properties); - rect (should *never* call super); - range (should *never* call super); - writingDirection (should *never* call super); - isVertical (should *never* call super); - containsStart (should *never* call super); - containsEnd (should *never* call super); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCMissingSuperCallChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCMissingSuperCallChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp:1312,Availability,down,down,1312,"//== ObjCSelfInitChecker.cpp - Checker for 'self' initialization -*- C++ -*--=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines ObjCSelfInitChecker, a builtin check that checks for uses of; // 'self' before proper initialization.; //; //===----------------------------------------------------------------------===//; // This checks initialization methods to verify that they assign 'self' to the; // result of an initialization call (e.g. [super init], or [self initWith..]); // before using 'self' or any instance variable.; //; // To perform the required checking, values are tagged with flags that indicate; // 1) if the object is the one pointed to by 'self', and 2) if the object; // is the result of an initializer (e.g. [super init]).; //; // Uses of an object that is true for 1) but not 2) trigger a diagnostic.; // The uses that are currently checked are:; // - Using instance variables.; // - Returning the object.; //; // Note that we don't check for an invalid 'self' that is the receiver of an; // obj-c message expression to cut down false positives where logging functions; // get information from self (like its class) or doing ""invalidation"" on self; // when the initialization fails.; //; // Because the object that 'self' points to gets invalidated when a call; // receives a reference to 'self', the checker keeps track and passes the flags; // for 1) and 2) to the new object that 'self' points to after the call.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp:1286,Integrability,message,message,1286,"//== ObjCSelfInitChecker.cpp - Checker for 'self' initialization -*- C++ -*--=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines ObjCSelfInitChecker, a builtin check that checks for uses of; // 'self' before proper initialization.; //; //===----------------------------------------------------------------------===//; // This checks initialization methods to verify that they assign 'self' to the; // result of an initialization call (e.g. [super init], or [self initWith..]); // before using 'self' or any instance variable.; //; // To perform the required checking, values are tagged with flags that indicate; // 1) if the object is the one pointed to by 'self', and 2) if the object; // is the result of an initializer (e.g. [super init]).; //; // Uses of an object that is true for 1) but not 2) trigger a diagnostic.; // The uses that are currently checked are:; // - Using instance variables.; // - Returning the object.; //; // Note that we don't check for an invalid 'self' that is the receiver of an; // obj-c message expression to cut down false positives where logging functions; // get information from self (like its class) or doing ""invalidation"" on self; // when the initialization fails.; //; // Because the object that 'self' points to gets invalidated when a call; // receives a reference to 'self', the checker keeps track and passes the flags; // for 1) and 2) to the new object that 'self' points to after the call.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp:783,Modifiability,variab,variable,783,"//== ObjCSelfInitChecker.cpp - Checker for 'self' initialization -*- C++ -*--=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines ObjCSelfInitChecker, a builtin check that checks for uses of; // 'self' before proper initialization.; //; //===----------------------------------------------------------------------===//; // This checks initialization methods to verify that they assign 'self' to the; // result of an initialization call (e.g. [super init], or [self initWith..]); // before using 'self' or any instance variable.; //; // To perform the required checking, values are tagged with flags that indicate; // 1) if the object is the one pointed to by 'self', and 2) if the object; // is the result of an initializer (e.g. [super init]).; //; // Uses of an object that is true for 1) but not 2) trigger a diagnostic.; // The uses that are currently checked are:; // - Using instance variables.; // - Returning the object.; //; // Note that we don't check for an invalid 'self' that is the receiver of an; // obj-c message expression to cut down false positives where logging functions; // get information from self (like its class) or doing ""invalidation"" on self; // when the initialization fails.; //; // Because the object that 'self' points to gets invalidated when a call; // receives a reference to 'self', the checker keeps track and passes the flags; // for 1) and 2) to the new object that 'self' points to after the call.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp:1155,Modifiability,variab,variables,1155,"//== ObjCSelfInitChecker.cpp - Checker for 'self' initialization -*- C++ -*--=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines ObjCSelfInitChecker, a builtin check that checks for uses of; // 'self' before proper initialization.; //; //===----------------------------------------------------------------------===//; // This checks initialization methods to verify that they assign 'self' to the; // result of an initialization call (e.g. [super init], or [self initWith..]); // before using 'self' or any instance variable.; //; // To perform the required checking, values are tagged with flags that indicate; // 1) if the object is the one pointed to by 'self', and 2) if the object; // is the result of an initializer (e.g. [super init]).; //; // Uses of an object that is true for 1) but not 2) trigger a diagnostic.; // The uses that are currently checked are:; // - Using instance variables.; // - Returning the object.; //; // Note that we don't check for an invalid 'self' that is the receiver of an; // obj-c message expression to cut down false positives where logging functions; // get information from self (like its class) or doing ""invalidation"" on self; // when the initialization fails.; //; // Because the object that 'self' points to gets invalidated when a call; // receives a reference to 'self', the checker keeps track and passes the flags; // for 1) and 2) to the new object that 'self' points to after the call.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp:804,Performance,perform,perform,804,"//== ObjCSelfInitChecker.cpp - Checker for 'self' initialization -*- C++ -*--=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines ObjCSelfInitChecker, a builtin check that checks for uses of; // 'self' before proper initialization.; //; //===----------------------------------------------------------------------===//; // This checks initialization methods to verify that they assign 'self' to the; // result of an initialization call (e.g. [super init], or [self initWith..]); // before using 'self' or any instance variable.; //; // To perform the required checking, values are tagged with flags that indicate; // 1) if the object is the one pointed to by 'self', and 2) if the object; // is the result of an initializer (e.g. [super init]).; //; // Uses of an object that is true for 1) but not 2) trigger a diagnostic.; // The uses that are currently checked are:; // - Using instance variables.; // - Returning the object.; //; // Note that we don't check for an invalid 'self' that is the receiver of an; // obj-c message expression to cut down false positives where logging functions; // get information from self (like its class) or doing ""invalidation"" on self; // when the initialization fails.; //; // Because the object that 'self' points to gets invalidated when a call; // receives a reference to 'self', the checker keeps track and passes the flags; // for 1) and 2) to the new object that 'self' points to after the call.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp:1339,Testability,log,logging,1339,"//== ObjCSelfInitChecker.cpp - Checker for 'self' initialization -*- C++ -*--=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines ObjCSelfInitChecker, a builtin check that checks for uses of; // 'self' before proper initialization.; //; //===----------------------------------------------------------------------===//; // This checks initialization methods to verify that they assign 'self' to the; // result of an initialization call (e.g. [super init], or [self initWith..]); // before using 'self' or any instance variable.; //; // To perform the required checking, values are tagged with flags that indicate; // 1) if the object is the one pointed to by 'self', and 2) if the object; // is the result of an initializer (e.g. [super init]).; //; // Uses of an object that is true for 1) but not 2) trigger a diagnostic.; // The uses that are currently checked are:; // - Using instance variables.; // - Returning the object.; //; // Note that we don't check for an invalid 'self' that is the receiver of an; // obj-c message expression to cut down false positives where logging functions; // get information from self (like its class) or doing ""invalidation"" on self; // when the initialization fails.; //; // Because the object that 'self' points to gets invalidated when a call; // receives a reference to 'self', the checker keeps track and passes the flags; // for 1) and 2) to the new object that 'self' points to after the call.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp:35,Integrability,wrap,wraps,35,// We tag the symbol that the SVal wraps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp:15,Availability,error,error,15,// Generate an error node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp:23,Integrability,message,message,23,"// When encountering a message that does initialization (init rule),; // tag the return value so that we know later on that if self has this value; // then it is properly initialized.; // FIXME: A callback should disable checkers at the start of functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp:82,Availability,down,down,82,"// We don't check for an invalid 'self' in an obj-c message expression to cut; // down false positives where logging functions get information from self; // (like its class) or doing ""invalidation"" on self when the initialization; // fails.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp:52,Integrability,message,message,52,"// We don't check for an invalid 'self' in an obj-c message expression to cut; // down false positives where logging functions get information from self; // (like its class) or doing ""invalidation"" on self when the initialization; // fails.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp:109,Testability,log,logging,109,"// We don't check for an invalid 'self' in an obj-c message expression to cut; // down false positives where logging functions get information from self; // (like its class) or doing ""invalidation"" on self when the initialization; // fails.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp:183,Safety,avoid,avoid,183,"// When a call receives a reference to 'self', [Pre/Post]Call pass; // the SelfFlags from the object 'self' points to before the call to the new; // object after the call. This is to avoid invalidation of 'self' by logging; // functions.; // Another common pattern in classes with multiple initializers is to put the; // subclass's common initialization bits into a static function that receives; // the value of 'self', e.g:; // @code; // if (!(self = [super init])); // return nil;; // if (!(self = _commonInit(self))); // return nil;; // @endcode; // Until we can use inter-procedural analysis, in such a call, transfer the; // SelfFlags to the result of the call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp:215,Testability,log,logging,215,"// When a call receives a reference to 'self', [Pre/Post]Call pass; // the SelfFlags from the object 'self' points to before the call to the new; // object after the call. This is to avoid invalidation of 'self' by logging; // functions.; // Another common pattern in classes with multiple initializers is to put the; // subclass's common initialization bits into a static function that receives; // the value of 'self', e.g:; // @code; // if (!(self = [super init])); // return nil;; // if (!(self = _commonInit(self))); // return nil;; // @endcode; // Until we can use inter-procedural analysis, in such a call, transfer the; // SelfFlags to the result of the call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp:133,Testability,log,log,133,"// If the address of 'self' is being passed to the call, assume that the; // 'self' after the call will have the same flags.; // EX: log(&self)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp:176,Performance,perform,performMoreInitialization,176,"// If 'self' is passed to the call by value, assume that the function; // returns 'self'. So assign the flags, which were set on 'self' to the; // return value.; // EX: self = performMoreInitialization(self)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp:23,Performance,load,load,23,// Tag the result of a load from 'self' so that we can easily know that the; // value is the object that 'self' points to.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp:57,Modifiability,variab,variable,57,"// Allow assignment of anything to self. Self is a local variable in the; // initializer, so it is legal to assign anything to it, like results of; // static functions/method calls. After self is assigned something we cannot; // reason about, stop enforcing the rules.; // (Only continue checking if the assigned value should be treated as self.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSuperDeallocChecker.cpp:53,Safety,avoid,avoid,53,// We add this transition in checkPostObjCMessage to avoid warning when; // we inline a call to [super dealloc] where the inlined call itself; // calls [super dealloc].,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSuperDeallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSuperDeallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSuperDeallocChecker.cpp:101,Availability,error,error,101,// Climb the super regions to find the base symbol while recording; // the second-to-last region for error reporting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSuperDeallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSuperDeallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSuperDeallocChecker.cpp:92,Availability,error,error,92,"/// Report a use-after-dealloc on Sym. If not empty,; /// Desc will be used to describe the error; otherwise,; /// a default warning will be used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSuperDeallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSuperDeallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCUnusedIVarsChecker.cpp:476,Integrability,interface,interface,476,"//==- ObjCUnusedIVarsChecker.cpp - Check for unused ivars --------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a CheckObjCUnusedIvars, a checker that; // analyzes an Objective-C class's interface/implementation to determine if it; // has any ivars that are never accessed.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCUnusedIVarsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCUnusedIVarsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCUnusedIVarsChecker.cpp:553,Security,access,accessed,553,"//==- ObjCUnusedIVarsChecker.cpp - Check for unused ivars --------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a CheckObjCUnusedIvars, a checker that; // analyzes an Objective-C class's interface/implementation to determine if it; // has any ivars that are never accessed.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCUnusedIVarsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCUnusedIVarsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCUnusedIVarsChecker.cpp:36,Modifiability,variab,variable,36,// Blocks can reference an instance variable of a class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCUnusedIVarsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCUnusedIVarsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCUnusedIVarsChecker.cpp:24,Security,access,accesses,24,// Scan the methods for accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCUnusedIVarsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCUnusedIVarsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/OSObjectCStyleCast.cpp:24,Energy Efficiency,allocate,allocates,24,"// 'allocClassWithName' allocates an object with the given type.; // The type is actually provided as a string argument (type's name).; // This makes the following pattern possible:; //; // Foo *object = (Foo *)allocClassWithName(""Foo"");; //; // While OSRequiredCast can be used here, it is still not a useful warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/OSObjectCStyleCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/OSObjectCStyleCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PaddingChecker.cpp:15,Usability,simpl,simplest,15,"// This is the simplest correct case: a class with no fields and one base; // class. Other cases are more complicated because of how the base classes; // & fields might interact, so we don't bother dealing with them.; // TODO: Support other combinations of base classes and fields.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PaddingChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PaddingChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PaddingChecker.cpp:27,Performance,optimiz,optimize,27,// Not going to attempt to optimize unions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PaddingChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PaddingChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PaddingChecker.cpp:3,Modifiability,Variab,Variable,3,// Variable length arrays are tricky too.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PaddingChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PaddingChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerArithChecker.cpp:85,Safety,avoid,avoid,85,// This checker try not to assume anything about placement and overloaded; // new to avoid false positives.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerArithChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerArithChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerArithChecker.cpp:132,Modifiability,Polymorphi,Polymorphic,132,"/// Checks whether a region is the part of an array.; /// In case there is a derived to base cast above the array element, the; /// Polymorphic output value is set to true. AKind output value is set to the; /// allocation kind of the inspected region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerArithChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerArithChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerArithChecker.cpp:112,Safety,avoid,avoid,112,"// When the region is symbolic and we do not have any information about it,; // assume that this is an array to avoid false positives.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerArithChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerArithChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerArithChecker.cpp:38,Energy Efficiency,allocate,allocate,38,// Assume that C allocation functions allocate arrays to avoid false; // positives.; // TODO: Add heuristics to distinguish alloc calls that allocates single; // objecs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerArithChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerArithChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerArithChecker.cpp:141,Energy Efficiency,allocate,allocates,141,// Assume that C allocation functions allocate arrays to avoid false; // positives.; // TODO: Add heuristics to distinguish alloc calls that allocates single; // objecs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerArithChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerArithChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerArithChecker.cpp:57,Safety,avoid,avoid,57,// Assume that C allocation functions allocate arrays to avoid false; // positives.; // TODO: Add heuristics to distinguish alloc calls that allocates single; // objecs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerArithChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerArithChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerSortingChecker.cpp:23,Usability,simpl,simply,23,"// FIXME: Currently we simply check if std::sort is used with pointer-like; // elements. This approach can have a big false positive rate. Using std::sort,; // std::unique and then erase is common technique for deduplicating a container; // (which in some cases might even be quicker than using, let's say std::set).; // In case a container contains arbitrary memory addresses (e.g. multiple; // things give different stuff but might give the same thing multiple times); // which we don't want to do things with more than once, we might use; // sort-unique-erase and the sort call will emit a report.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerSortingChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerSortingChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp:430,Usability,simpl,simple,430,"//===--- PthreadLockChecker.cpp - Check for locking problems ---*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines:; // * PthreadLockChecker, a simple lock -> unlock checker.; // Which also checks for XNU locks, which behave similarly enough to share; // code.; // * FuchsiaLocksChecker, which is also rather similar.; // * C11LockChecker which also closely follows Pthread semantics.; //; // TODO: Path notes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp:3,Deployability,Release,Release,3,// Release.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp:3,Deployability,Release,Release,3,// Release.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp:3,Deployability,Release,Release,3,// Release.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp:3,Deployability,Release,Release,3,// Release.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp:28,Deployability,release,released,28,// Record that the lock was released.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp:60,Performance,perform,performed,60,"// Once the return value symbol dies, no more checks can be performed; // against it. See if the return value was checked before this point.; // This would remove the symbol from the map as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp:3,Safety,Avoid,Avoid,3,// Avoid invalidating mutex state when a known supported function is called.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp:101,Energy Efficiency,efficient,efficiently,101,"// TODO: We need to invalidate the lock stack as well. This is tricky; // to implement correctly and efficiently though, because the effects; // of mutex escapes on lock order may be fairly varied.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ReturnPointerRangeChecker.cpp:66,Modifiability,refactor,refactored,66,// FIXME: All of this out-of-bounds checking should eventually be refactored; // into a common place.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ReturnPointerRangeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ReturnPointerRangeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ReturnUndefChecker.cpp:191,Testability,test,test,191,"// ""return;"" is modeled to evaluate to an UndefinedVal. Allow UndefinedVal; // to be returned in functions returning void to support this pattern:; // void foo() {; // return;; // }; // void test() {; // return foo();; // }",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ReturnUndefChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ReturnUndefChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ReturnUndefChecker.cpp:88,Availability,avail,available,88,"// Not all blocks have explicitly-specified return types; if the return type; // is not available, but the return value expression has 'void' type, assume; // Sema already checked it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ReturnUndefChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ReturnUndefChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ReturnValueChecker.cpp:41,Availability,Error,Error,41,// These are known in the LLVM project: 'Error()',MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ReturnValueChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ReturnValueChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ReturnValueChecker.cpp:4,Availability,error,error,4,// 'error()',MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ReturnValueChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ReturnValueChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RunLoopAutoreleaseLeakChecker.cpp:400,Safety,detect,detecting,400,"//=- RunLoopAutoreleaseLeakChecker.cpp --------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //; //===----------------------------------------------------------------------===//; //; // A checker for detecting leaks resulting from allocating temporary; // autoreleased objects before starting the main run loop.; //; // Checks for two antipatterns:; // 1. ObjCMessageExpr followed by [[NSRunLoop mainRunLoop] run] in the same; // autorelease pool.; // 2. ObjCMessageExpr followed by [[NSRunLoop mainRunLoop] run] in no; // autorelease pool.; //; // Any temporary objects autoreleased in code called in those expressions; // will not be deallocated until the program exits, and are effectively leaks.; //; //===----------------------------------------------------------------------===//; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RunLoopAutoreleaseLeakChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RunLoopAutoreleaseLeakChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RunLoopAutoreleaseLeakChecker.cpp:40,Integrability,message,message-sent,40,// Launch of run loop occurs before the message-sent expression is seen.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RunLoopAutoreleaseLeakChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RunLoopAutoreleaseLeakChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SimpleStreamChecker.cpp:506,Security,access,accessed,506,"//===-- SimpleStreamChecker.cpp -----------------------------------------*- C++ -*--//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Defines a checker for proper use of fopen/fclose APIs.; // - If a file has been closed with fclose, it should not be accessed again.; // Accessing a closed file results in undefined behavior.; // - If a file was opened with fopen, it must be closed with fclose before; // the execution ends. Failing to do so results in a resource leak.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SimpleStreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SimpleStreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SimpleStreamChecker.cpp:526,Security,Access,Accessing,526,"//===-- SimpleStreamChecker.cpp -----------------------------------------*- C++ -*--//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Defines a checker for proper use of fopen/fclose APIs.; // - If a file has been closed with fclose, it should not be accessed again.; // Accessing a closed file results in undefined behavior.; // - If a file was opened with fopen, it must be closed with fclose before; // the execution ends. Failing to do so results in a resource leak.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SimpleStreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SimpleStreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SimpleStreamChecker.cpp:8,Usability,Simpl,SimpleStreamChecker,8,"//===-- SimpleStreamChecker.cpp -----------------------------------------*- C++ -*--//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Defines a checker for proper use of fopen/fclose APIs.; // - If a file has been closed with fclose, it should not be accessed again.; // Accessing a closed file results in undefined behavior.; // - If a file was opened with fopen, it must be closed with fclose before; // the execution ends. Failing to do so results in a resource leak.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SimpleStreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SimpleStreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtr.h:455,Integrability,depend,dependent,455,"//=== SmartPtr.h - Tracking smart pointer state. -------------------*- C++ -*-//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Defines inter-checker API for the smart pointer modeling. It allows; // dependent checkers to figure out if an smart pointer is null or not.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp:44,Safety,avoid,avoid,44,// Helper method to pretty print region and avoid extra spacing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp:9,Deployability,Update,Update,9,"// TODO: Update CallDescription to support anonymous calls?; // TODO: Handle other methods, such as .get() or .release().; // But once we do, we'd need a visitor to explain null dereferences; // that are found via such modeling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp:111,Deployability,release,release,111,"// TODO: Update CallDescription to support anonymous calls?; // TODO: Handle other methods, such as .get() or .release().; // But once we do, we'd need a visitor to explain null dereferences; // that are found via such modeling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp:269,Deployability,update,updateObjectsUnderConstruction,269,"// TODO: ExprEngine should do this for us.; // For a bit more context:; // 1) Why do we need this? Since we are modelling a ""function""; // that returns a constructed object we need to store this information in; // the program state.; //; // 2) Why does this work?; // `updateObjectsUnderConstruction` does exactly as it sounds.; //; // 3) How should it look like when moved to the Engine?; // It would be nice if we can just; // pretend we don't need to know about this - ie, completely automatic work.; // However, realistically speaking, I think we would need to ""signal"" the; // ExprEngine evalCall handler that we are constructing an object with this; // function call (constructors obviously construct, hence can be; // automatically deduced).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp:109,Safety,safe,safe,109,// We don't leave a note here since it is guaranteed the; // unique_ptr from this call is non-null (hence is safe to de-reference).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp:44,Safety,avoid,avoid,44,"// TODO: Model this case as well. At least, avoid invalidation of; // globals.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp:27,Availability,alive,alive,27,// Marking tracked symbols alive,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp:40,Availability,avail,available,40,// In case of inner pointer SVal is not available we create; // conjureSymbolVal for inner pointer value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp:353,Modifiability,variab,variable,353,"// There is a not-too-uncommon idiom; // where a block passed to dispatch_async captures a semaphore; // and then the thread (which called dispatch_async) is blocked on waiting; // for the completion of the execution of the block; // via dispatch_semaphore_wait. To avoid false-positives (for now); // we ignore all the blocks which have captured; // a variable of the type ""dispatch_semaphore_t"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp:266,Safety,avoid,avoid,266,"// There is a not-too-uncommon idiom; // where a block passed to dispatch_async captures a semaphore; // and then the thread (which called dispatch_async) is blocked on waiting; // for the completion of the execution of the block; // via dispatch_semaphore_wait. To avoid false-positives (for now); // we ignore all the blocks which have captured; // a variable of the type ""dispatch_semaphore_t"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp:120,Integrability,wrap,wrapped,120,"// Returning a record by value is fine. (In this case, the returned; // expression will be a copy-constructor, possibly wrapped in an; // ExprWithCleanups node.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp:39,Modifiability,variab,variables,39,// Iterate over all bindings to global variables and see if it contains; // a memory region in the stack space.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp:19,Modifiability,variab,variables,19,/// Look for stack variables referring to popped stack variables.; /// Returns true only if it found some dangling stack variables; /// referred by an other stack variable from different stack frame.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp:55,Modifiability,variab,variables,55,/// Look for stack variables referring to popped stack variables.; /// Returns true only if it found some dangling stack variables; /// referred by an other stack variable from different stack frame.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp:121,Modifiability,variab,variables,121,/// Look for stack variables referring to popped stack variables.; /// Returns true only if it found some dangling stack variables; /// referred by an other stack variable from different stack frame.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp:163,Modifiability,variab,variable,163,/// Look for stack variables referring to popped stack variables.; /// Returns true only if it found some dangling stack variables; /// referred by an other stack variable from different stack frame.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp:15,Availability,error,error,15,// Generate an error node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:1506,Energy Efficiency,reduce,reduces,1506,"es a specification format - `Summary' - and; // contains descriptions of some library functions in this format. Each; // specification contains a list of branches for splitting the program state; // upon call, and range constraints on argument and return-value symbols that; // are satisfied on each branch. This spec can be expanded to include more; // items, like external effects of the function.; //; // The main difference between this approach and the body farms technique is; // in more explicit control over how many branches are produced. For example,; // consider standard C function `ispunct(int x)', which returns a non-zero value; // iff `x' is a punctuation character, that is, when `x' is in range; // ['!', '/'] [':', '@'] U ['[', '\`'] U ['{', '~'].; // `Summary' provides only two branches for this function. However,; // any attempt to describe this range with if-statements in the body farm; // would result in many more branches. Because each branch needs to be analyzed; // independently, this significantly reduces performance. Additionally,; // once we consider a branch on which `x' is in range, say, ['!', '/'],; // we assume that such branch is an important separate path through the program,; // which may lead to false positives because considering this particular path; // was not consciously intended, and therefore it might have been unreachable.; //; // This checker uses eval::Call for modeling pure functions (functions without; // side effets), for which their `Summary' is a precise model. This avoids; // unnecessary invalidation passes. Conflicts with other checkers are unlikely; // because if the function has no other effects, other checkers would probably; // never want to improve upon the modeling done by this checker.; //; // Non-pure functions, for which only partial improvement over the default; // behavior is expected, are modeled via check::PostCall, non-intrusively.; //; //===---------------------------------------------------------------------",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:1514,Performance,perform,performance,1514,"es a specification format - `Summary' - and; // contains descriptions of some library functions in this format. Each; // specification contains a list of branches for splitting the program state; // upon call, and range constraints on argument and return-value symbols that; // are satisfied on each branch. This spec can be expanded to include more; // items, like external effects of the function.; //; // The main difference between this approach and the body farms technique is; // in more explicit control over how many branches are produced. For example,; // consider standard C function `ispunct(int x)', which returns a non-zero value; // iff `x' is a punctuation character, that is, when `x' is in range; // ['!', '/'] [':', '@'] U ['[', '\`'] U ['{', '~'].; // `Summary' provides only two branches for this function. However,; // any attempt to describe this range with if-statements in the body farm; // would result in many more branches. Because each branch needs to be analyzed; // independently, this significantly reduces performance. Additionally,; // once we consider a branch on which `x' is in range, say, ['!', '/'],; // we assume that such branch is an important separate path through the program,; // which may lead to false positives because considering this particular path; // was not consciously intended, and therefore it might have been unreachable.; //; // This checker uses eval::Call for modeling pure functions (functions without; // side effets), for which their `Summary' is a precise model. This avoids; // unnecessary invalidation passes. Conflicts with other checkers are unlikely; // because if the function has no other effects, other checkers would probably; // never want to improve upon the modeling done by this checker.; //; // Non-pure functions, for which only partial improvement over the default; // behavior is expected, are modeled via check::PostCall, non-intrusively.; //; //===---------------------------------------------------------------------",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:2008,Safety,avoid,avoids,2008,"pecification format - `Summary' - and; // contains descriptions of some library functions in this format. Each; // specification contains a list of branches for splitting the program state; // upon call, and range constraints on argument and return-value symbols that; // are satisfied on each branch. This spec can be expanded to include more; // items, like external effects of the function.; //; // The main difference between this approach and the body farms technique is; // in more explicit control over how many branches are produced. For example,; // consider standard C function `ispunct(int x)', which returns a non-zero value; // iff `x' is a punctuation character, that is, when `x' is in range; // ['!', '/'] [':', '@'] U ['[', '\`'] U ['{', '~'].; // `Summary' provides only two branches for this function. However,; // any attempt to describe this range with if-statements in the body farm; // would result in many more branches. Because each branch needs to be analyzed; // independently, this significantly reduces performance. Additionally,; // once we consider a branch on which `x' is in range, say, ['!', '/'],; // we assume that such branch is an important separate path through the program,; // which may lead to false positives because considering this particular path; // was not consciously intended, and therefore it might have been unreachable.; //; // This checker uses eval::Call for modeling pure functions (functions without; // side effets), for which their `Summary' is a precise model. This avoids; // unnecessary invalidation passes. Conflicts with other checkers are unlikely; // because if the function has no other effects, other checkers would probably; // never want to improve upon the modeling done by this checker.; //; // Non-pure functions, for which only partial improvement over the default; // behavior is expected, are modeled via check::PostCall, non-intrusively.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:423,Usability,simpl,simple,423,"//=== StdLibraryFunctionsChecker.cpp - Model standard functions -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker improves modeling of a few simple library functions.; //; // This checker provides a specification format - `Summary' - and; // contains descriptions of some library functions in this format. Each; // specification contains a list of branches for splitting the program state; // upon call, and range constraints on argument and return-value symbols that; // are satisfied on each branch. This spec can be expanded to include more; // items, like external effects of the function.; //; // The main difference between this approach and the body farms technique is; // in more explicit control over how many branches are produced. For example,; // consider standard C function `ispunct(int x)', which returns a non-zero value; // iff `x' is a punctuation character, that is, when `x' is in range; // ['!', '/'] [':', '@'] U ['[', '\`'] U ['{', '~'].; // `Summary' provides only two branches for this function. However,; // any attempt to describe this range with if-statements in the body farm; // would result in many more branches. Because each branch needs to be analyzed; // independently, this significantly reduces performance. Additionally,; // once we consider a branch on which `x' is in range, say, ['!', '/'],; // we assume that such branch is an important separate path through the program,; // which may lead to false positives because considering this particular path; // was not consciously intended, and therefore it might have been unreachable.; //; // This checker uses eval::Call for modeling pure functions (functions without; // side effets), for which their `Summary' is a precise model",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:147,Usability,simpl,simple,147,"/// Print value X of the argument in form "" (which is X)"",; /// if the value is a fixed known value, otherwise print nothing.; /// This is used as simple explanation of values if possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:56,Modifiability,polymorphi,polymorphic,56,"/// Pointer to the ValueConstraint. We need a copyable, polymorphic and; /// default initializable type (vector needs that). A raw pointer was good,; /// however, we cannot default initialize that. unique_ptr makes the Summary; /// class non-copyable, therefore not an option. Releasing the copyability; /// requirement would render the initialization of the Summary map infeasible.; /// Mind that a pointer to a new value constraint is created when the negate; /// function is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:4,Modifiability,Polymorphi,Polymorphic,4,"/// Polymorphic base class that represents a constraint on a given argument; /// (or return value) of a function. Derived classes implement different kind; /// of constraints, e.g range constraints or correlation between two; /// arguments.; /// These are used as argument constraints (preconditions) of functions, in; /// which case a bug report may be emitted if the constraint is not satisfied.; /// Another use is as conditions for summary cases, to create different; /// classes of behavior for a function. In this case no description of the; /// constraint is needed because the summary cases have an own (not generated); /// description string.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:131,Safety,safe,safely,131,"// There are some descendant classes that are not used as argument; // constraints, e.g. ComparisonConstraint. In that case we can safely; // ignore the implementation of this function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:432,Usability,simpl,simple,432,"/// Give a description that explains the actual argument value (where the; /// current ValueConstraint applies to) to the user. This function should be; /// called only when the current constraint is satisfied by the argument.; /// It should produce a more precise description than the constraint itself.; /// The actual value of the argument and the program state can be used to; /// make the description more precise. In the most simple case, if the; /// argument has a fixed known value this value can be printed into \p Out,; /// this is done by default.; /// The function should return true if a description was printed to \p Out,; /// otherwise false.; /// See StdLibraryFunctionsChecker::reportBug about how this function is; /// used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:37,Security,validat,validation,37,// Subclasses may further refine the validation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:27,Security,validat,validation,27,/// Do constraint-specific validation check.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:452,Integrability,depend,dependent,452,"/// Check if a single argument falls into a specific ""range"".; /// A range is formed as a set of intervals.; /// E.g. \code {['A', 'Z'], ['a', 'z'], ['_', '_']} \endcode; /// The intervals are closed intervals that contain one or more values.; ///; /// The default constructed RangeConstraint has an empty range, applying; /// such constraint does not involve any assumptions, thus the State remains; /// unchanged. This is meaningful, if the range is dependent on a looked up; /// type (e.g. [0, Socklen_tMax]). If the type is not found, then the range; /// is default initialized to be empty.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:8,Modifiability,variab,variable,8,// This variable has a role when we negate the constraint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:217,Integrability,depend,depend,217,"/// Check null or non-null-ness of an argument that is of pointer type.; /// The argument is meant to be a buffer that has a size constraint, and it; /// is allowed to have a NULL value if the size is 0. The size can depend on; /// 1 or 2 additional arguments, if one of these is 0 the buffer is allowed to; /// be NULL. This is useful for functions like `fread` which have this special; /// property.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:8,Modifiability,variab,variable,8,// This variable has a role when we negate the constraint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:186,Availability,failure,failure,186,"/// Define how a function affects the system variable 'errno'.; /// This works together with the \c ErrnoModeling and \c ErrnoChecker classes.; /// Currently 3 use cases exist: success, failure, irrelevant.; /// In the future the failure case can be customized to set \c errno to a; /// more specific constraint (for example > 0), or new case can be added; /// for functions which require check of \c errno in both success and failure; /// case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:230,Availability,failure,failure,230,"/// Define how a function affects the system variable 'errno'.; /// This works together with the \c ErrnoModeling and \c ErrnoChecker classes.; /// Currently 3 use cases exist: success, failure, irrelevant.; /// In the future the failure case can be customized to set \c errno to a; /// more specific constraint (for example > 0), or new case can be added; /// for functions which require check of \c errno in both success and failure; /// case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:427,Availability,failure,failure,427,"/// Define how a function affects the system variable 'errno'.; /// This works together with the \c ErrnoModeling and \c ErrnoChecker classes.; /// Currently 3 use cases exist: success, failure, irrelevant.; /// In the future the failure case can be customized to set \c errno to a; /// more specific constraint (for example > 0), or new case can be added; /// for functions which require check of \c errno in both success and failure; /// case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:45,Modifiability,variab,variable,45,"/// Define how a function affects the system variable 'errno'.; /// This works together with the \c ErrnoModeling and \c ErrnoChecker classes.; /// Currently 3 use cases exist: success, failure, irrelevant.; /// In the future the failure case can be customized to set \c errno to a; /// more specific constraint (for example > 0), or new case can be added; /// for functions which require check of \c errno in both success and failure; /// case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:54,Modifiability,variab,variable,54,/// Apply specific state changes related to the errno variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:28,Availability,failure,failure,28,/// Set errno constraint at failure cases of standard functions.; /// Failure case: 'errno' becomes not equal to 0 and may or may not be checked; /// by the program. \c ErrnoChecker does not emit a bug report after such a; /// function call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:70,Availability,Failure,Failure,70,/// Set errno constraint at failure cases of standard functions.; /// Failure case: 'errno' becomes not equal to 0 and may or may not be checked; /// by the program. \c ErrnoChecker does not emit a bug report after such a; /// function call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:52,Availability,failure,failure,52,/// Set errno constraint at functions that indicate failure only with 'errno'.; /// In this case 'errno' is required to be observed.; /// \c ErrnoChecker can emit bug report after such a function call if errno; /// is overwritten without a read before.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:515,Performance,queue,queued,515,"/// A single branch of a function summary.; ///; /// A branch is defined by a series of constraints - ""assumptions"" -; /// that together form a single possible outcome of invoking the function.; /// When static analyzer considers a branch, it tries to introduce; /// a child node in the Exploded Graph. The child node has to include; /// constraints that define the branch. If the constraints contradict; /// existing constraints in the state, the node is not created and the branch; /// is dropped; otherwise it's queued for future exploration.; /// The branch is accompanied by a note text that may be displayed; /// to the user when a bug is found on a path that takes this branch.; ///; /// For example, consider the branches in `isalpha(x)`:; /// Branch 1); /// x is in range ['A', 'Z'] or in ['a', 'z']; /// then the return value is not 0. (I.e. out-of-range [0, 0]); /// and the note may say ""Assuming the character is alphabetical""; /// Branch 2); /// x is out-of-range ['A', 'Z'] and out-of-range ['a', 'z']; /// then the return value is 0; /// and the note may say ""Assuming the character is non-alphabetical"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:307,Availability,error,error,307,"/// A summary includes information about; /// * function prototype (signature); /// * approach to invalidation,; /// * a list of branches - so, a list of list of ranges,; /// * a list of argument constraints, that must be true on every branch.; /// If these constraints are not satisfied that means a fatal error; /// usually resulting in undefined behaviour.; ///; /// Application of a summary:; /// The signature and argument constraints together contain information; /// about which functions are handled by the summary. The signature can use; /// ""wildcards"", i.e. Irrelevant types. Irrelevant type of a parameter in; /// a signature means that type is not compared to the type of the parameter; /// in the found FunctionDecl. Argument constraints may specify additional; /// rules for the given parameter's type, those rules are checked once the; /// signature is matched.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:55,Security,validat,validation,55,// Once we know the exact type of the function then do validation check on; // all the given constraints.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:147,Availability,failure,failure,147,"/// These are the errno constraints that can be passed to summary cases.; /// One of these should fit for a single summary case.; /// Usually if a failure return value exists for function, that function; /// needs different cases for success and failure with different errno; /// constraints (and different return value constraints).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:246,Availability,failure,failure,246,"/// These are the errno constraints that can be passed to summary cases.; /// One of these should fit for a single summary case.; /// Usually if a failure return value exists for function, that function; /// needs different cases for success and failure with different errno; /// constraints (and different return value constraints).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:12,Safety,avoid,avoid,12,// Note: we avoid integral promotion for comparison.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:111,Availability,Failure,FailureSt,111,// We will apply the constraint even if we cannot reason about the; // argument. This means both SuccessSt and FailureSt can be true. If we; // weren't applying the constraint that would mean that symbolic; // execution continues on a code whose behaviour is undefined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:128,Performance,perform,performed,128,"// Try to omit the note if we know in advance which branch is; // taken (this means, only one branch exists).; // This check is performed inside the lambda, after other; // (or this) checkers had a chance to add other successors.; // Dereferencing the saved node object is valid because it's part; // of a bug report call sequence.; // FIXME: This check is not exact. We may be here after a state; // split that was performed by another checker (and can not find; // the successors). This is why this check is only used in the; // EvalCallAsPure case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:416,Performance,perform,performed,416,"// Try to omit the note if we know in advance which branch is; // taken (this means, only one branch exists).; // This check is performed inside the lambda, after other; // (or this) checkers had a chance to add other successors.; // Dereferencing the saved node object is valid because it's part; // of a bug report call sequence.; // FIXME: This check is not exact. We may be here after a state; // split that was performed by another checker (and can not find; // the successors). This is why this check is only used in the; // EvalCallAsPure case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:29,Performance,perform,performing,29,"// Summary tells us to avoid performing eval::Call. The function is possibly; // evaluated by another checker, or evaluated conservatively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:23,Safety,avoid,avoid,23,"// Summary tells us to avoid performing eval::Call. The function is possibly; // evaluated by another checker, or evaluated conservatively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:327,Testability,test,tested,327,"// Set UCharRangeMax to min of int or uchar maximum value.; // The C standard states that the arguments of functions like isalpha must; // be representable as an unsigned char. Their type is 'int', so the max; // value of the argument should be min(UCharMax, IntMax). This just happen; // to be true for commonly used and well tested instruction set; // architectures, but not for others.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:16,Integrability,depend,dependent,16,"// Get platform dependent values of some macros.; // Try our best to parse this from the Preprocessor, otherwise fallback to a; // default value (what is found in a library header).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:66,Performance,perform,performed,66,"// Add a summary to a FunctionDecl found by lookup. The lookup is performed; // by the given Name, and in the global scope. The summary will be attached; // to the found FunctionDecl only if the signatures match.; //; // Returns true if the summary has been added, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:9,Availability,down,down,9,// Boils down to isupper() or islower() or isdigit().,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:58,Availability,error,error,58,// void rewind(FILE *stream);; // This function indicates error only by setting of 'errno'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:8,Usability,clear,clearerr,8,// void clearerr(FILE *stream);,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:7,Security,access,access,7,"// int access(const char *pathname, int amode);",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:219,Availability,failure,failure,219,"// off_t lseek(int fildes, off_t offset, int whence);; // In the first case we can not tell for sure if it failed or not.; // A return value different from of the expected offset (that is unknown; // here) may indicate failure. For this reason we do not enforce the errno; // check (can cause false positive).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:477,Integrability,protocol,protocol,477,"// In 'socket.h' of some libc implementations with C99, sockaddr parameter; // is a transparent union of the underlying sockaddr_ family of pointers; // instead of being a pointer to struct sockaddr. In these cases, the; // standardized signature will not match, thus we try to match with another; // signature that has the joker Irrelevant type. We also remove those; // constraints which require pointer types for the sockaddr param.; // int socket(int domain, int type, int protocol);",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:42,Integrability,message,message,42,"// ssize_t sendto(int socket, const void *message, size_t length,; // int flags, const struct sockaddr *dest_addr,; // socklen_t dest_len);",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:44,Integrability,protocol,protocol,44,"// int socketpair(int domain, int type, int protocol, int sv[2]);",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:17,Testability,test,testing,17,// Functions for testing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:3,Testability,Test,Test,3,// Test inside range constraints.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:3,Testability,Test,Test,3,// Test out of range constraints.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:3,Testability,Test,Test,3,// Test range kind.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:3,Testability,Test,Test,3,// Test the application of cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdVariantChecker.cpp:38,Modifiability,extend,extended,38,// FIXME Later this checker should be extended to handle constructors; // with multiple arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdVariantChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdVariantChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:24,Availability,error,error,24,/// State of the stream error flags.; /// Sometimes it is not known to the checker what error flags are set.; /// This is indicated by setting more than one flag to true.; /// This is an optimization to avoid state splits.; /// A stream can either be in FEOF or FERROR but not both at the same time.; /// Multiple flags are set to handle the corresponding states together.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:88,Availability,error,error,88,/// State of the stream error flags.; /// Sometimes it is not known to the checker what error flags are set.; /// This is indicated by setting more than one flag to true.; /// This is an optimization to avoid state splits.; /// A stream can either be in FEOF or FERROR but not both at the same time.; /// Multiple flags are set to handle the corresponding states together.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:187,Performance,optimiz,optimization,187,/// State of the stream error flags.; /// Sometimes it is not known to the checker what error flags are set.; /// This is indicated by setting more than one flag to true.; /// This is an optimization to avoid state splits.; /// A stream can either be in FEOF or FERROR but not both at the same time.; /// Multiple flags are set to handle the corresponding states together.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:203,Safety,avoid,avoid,203,/// State of the stream error flags.; /// Sometimes it is not known to the checker what error flags are set.; /// This is indicated by setting more than one flag to true.; /// This is an optimization to avoid state splits.; /// A stream can either be in FEOF or FERROR but not both at the same time.; /// Multiple flags are set to handle the corresponding states together.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:49,Availability,error,error,49,/// The stream can be in state where none of the error flags set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:41,Availability,error,error,41,/// The stream can be in state where the error indicator is set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:17,Availability,error,error,17,/// State of the error flags.; /// Ignored in non-opened stream state but must be NoError.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:239,Availability,error,error,239,"/// Indicate if the file has an ""indeterminate file position indicator"".; /// This can be set at a failing read or write or seek operation.; /// If it is set no more read or write is allowed.; /// This value is not dependent on the stream error flags:; /// The error flag may be cleared with `clearerr` but the file position; /// remains still indeterminate.; /// This value applies to all error states in ErrorState except FEOF.; /// An EOF+indeterminate state is the same as EOF state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:261,Availability,error,error,261,"/// Indicate if the file has an ""indeterminate file position indicator"".; /// This can be set at a failing read or write or seek operation.; /// If it is set no more read or write is allowed.; /// This value is not dependent on the stream error flags:; /// The error flag may be cleared with `clearerr` but the file position; /// remains still indeterminate.; /// This value applies to all error states in ErrorState except FEOF.; /// An EOF+indeterminate state is the same as EOF state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:390,Availability,error,error,390,"/// Indicate if the file has an ""indeterminate file position indicator"".; /// This can be set at a failing read or write or seek operation.; /// If it is set no more read or write is allowed.; /// This value is not dependent on the stream error flags:; /// The error flag may be cleared with `clearerr` but the file position; /// remains still indeterminate.; /// This value applies to all error states in ErrorState except FEOF.; /// An EOF+indeterminate state is the same as EOF state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:406,Availability,Error,ErrorState,406,"/// Indicate if the file has an ""indeterminate file position indicator"".; /// This can be set at a failing read or write or seek operation.; /// If it is set no more read or write is allowed.; /// This value is not dependent on the stream error flags:; /// The error flag may be cleared with `clearerr` but the file position; /// remains still indeterminate.; /// This value applies to all error states in ErrorState except FEOF.; /// An EOF+indeterminate state is the same as EOF state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:215,Integrability,depend,dependent,215,"/// Indicate if the file has an ""indeterminate file position indicator"".; /// This can be set at a failing read or write or seek operation.; /// If it is set no more read or write is allowed.; /// This value is not dependent on the stream error flags:; /// The error flag may be cleared with `clearerr` but the file position; /// remains still indeterminate.; /// This value applies to all error states in ErrorState except FEOF.; /// An EOF+indeterminate state is the same as EOF state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:279,Usability,clear,cleared,279,"/// Indicate if the file has an ""indeterminate file position indicator"".; /// This can be set at a failing read or write or seek operation.; /// If it is set no more read or write is allowed.; /// This value is not dependent on the stream error flags:; /// The error flag may be cleared with `clearerr` but the file position; /// remains still indeterminate.; /// This value applies to all error states in ErrorState except FEOF.; /// An EOF+indeterminate state is the same as EOF state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:293,Usability,clear,clearerr,293,"/// Indicate if the file has an ""indeterminate file position indicator"".; /// This can be set at a failing read or write or seek operation.; /// If it is set no more read or write is allowed.; /// This value is not dependent on the stream error flags:; /// The error flag may be cleared with `clearerr` but the file position; /// remains still indeterminate.; /// This value applies to all error states in ErrorState except FEOF.; /// An EOF+indeterminate state is the same as EOF state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:23,Availability,error,error,23,"// In not opened state error state should always NoError, so comparison; // here is no problem.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:30,Testability,test,testing,30,"/// If true, evaluate special testing stream functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:90,Availability,error,error,90,/// Check that the stream (in StreamVal) is not NULL.; /// If it can only be NULL a fatal error is emitted and nullptr returned.; /// Otherwise the return value is a new state where the stream is constrained; /// to be non-null.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:95,Availability,error,error,95,"/// Check that the stream is the opened state.; /// If the stream is known to be not opened an error is generated; /// and nullptr returned, otherwise the original state is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:197,Availability,error,error,197,"/// Check that the stream has not an invalid (""indeterminate"") file position,; /// generate warning for it.; /// (EOF is not an invalid position.); /// The returned state can be nullptr if a fatal error was generated.; /// It can return non-null state if the stream has not an invalid position or; /// there is execution path with non-invalid position.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:74,Availability,error,error,74,"/// Check the legality of the 'whence' argument of 'fseek'.; /// Generate error and return nullptr if it is found to be illegal.; /// Otherwise returns the state.; /// (State is not changed here because the ""whence"" value is already known.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:142,Availability,error,error,142,"/// Generate warning about stream in EOF state.; /// There will be always a state transition into the passed State,; /// by the new non-fatal error node or (if failed) a normal transition,; /// to ensure uniform handling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:80,Availability,error,error,80,"/// Emit resource leak warnings for the given symbols.; /// Createn a non-fatal error node for these, and returns it (if any warnings; /// were generated). Return value is non-null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:15,Integrability,message,message,15,/// Generate a message for BugReporterVisitor if the stored symbol is; /// marked as interesting by the actual bug report.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:168,Availability,error,error,168,"// Generate state for non-failed case.; // Return value is the passed stream pointer.; // According to the documentations, the stream is closed first; // but any close error is ignored. The state changes to (or remains) opened.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:31,Availability,failure,failure,31,"// Return 0 on success, EOF on failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:174,Availability,error,error,174,"// C'99 standard, 7.19.8.1.3, the return value of fread:; // The fread function returns the number of elements successfully read, which; // may be less than nmemb if a read error or end-of-file is encountered. If; // size or nmemb is zero, fread returns zero and the contents of the array and; // the state of the stream remain unchanged.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:95,Availability,error,error,95,"// This is the ""size or nmemb is zero"" case.; // Just return 0, do nothing more (not clear the error flags).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:85,Usability,clear,clear,85,"// This is the ""size or nmemb is zero"" case.; // Just return 0, do nothing more (not clear the error flags).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:18,Availability,error,error,18,"// If a (non-EOF) error occurs, the resulting value of the file position; // indicator for the stream is indeterminate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:18,Availability,error,error,18,"// If a (non-EOF) error occurs, the resulting value of the file position; // indicator for the stream is indeterminate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:96,Availability,error,error,96,"// Add the success state.; // In this context ""success"" means there is not an EOF or other read error; // before any item is matched in 'fscanf'. But there may be match failure,; // therefore return value can be 0 or greater.; // It is not specified what happens if some items (not all) are matched and; // then EOF or read error happens. Now this case is handled like a ""success""; // case, and no error flags are set on the stream. This is probably not; // accurate, and the POSIX documentation does not tell more.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:169,Availability,failure,failure,169,"// Add the success state.; // In this context ""success"" means there is not an EOF or other read error; // before any item is matched in 'fscanf'. But there may be match failure,; // therefore return value can be 0 or greater.; // It is not specified what happens if some items (not all) are matched and; // then EOF or read error happens. Now this case is handled like a ""success""; // case, and no error flags are set on the stream. This is probably not; // accurate, and the POSIX documentation does not tell more.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:324,Availability,error,error,324,"// Add the success state.; // In this context ""success"" means there is not an EOF or other read error; // before any item is matched in 'fscanf'. But there may be match failure,; // therefore return value can be 0 or greater.; // It is not specified what happens if some items (not all) are matched and; // then EOF or read error happens. Now this case is handled like a ""success""; // case, and no error flags are set on the stream. This is probably not; // accurate, and the POSIX documentation does not tell more.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:398,Availability,error,error,398,"// Add the success state.; // In this context ""success"" means there is not an EOF or other read error; // before any item is matched in 'fscanf'. But there may be match failure,; // therefore return value can be 0 or greater.; // It is not specified what happens if some items (not all) are matched and; // then EOF or read error happens. Now this case is handled like a ""success""; // case, and no error flags are set on the stream. This is probably not; // accurate, and the POSIX documentation does not tell more.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:44,Availability,Error,Error,44,"// Add transition for the failed state.; // Error occurs if nothing is matched yet and reading the input fails.; // Error can be EOF, or other error. At ""other error"" FERROR or 'errno' can; // be set but it is not further specified if all are required to be set.; // Documentation does not mention, but file position will be set to; // indeterminate similarly as at 'fread'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:116,Availability,Error,Error,116,"// Add transition for the failed state.; // Error occurs if nothing is matched yet and reading the input fails.; // Error can be EOF, or other error. At ""other error"" FERROR or 'errno' can; // be set but it is not further specified if all are required to be set.; // Documentation does not mention, but file position will be set to; // indeterminate similarly as at 'fread'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:143,Availability,error,error,143,"// Add transition for the failed state.; // Error occurs if nothing is matched yet and reading the input fails.; // Error can be EOF, or other error. At ""other error"" FERROR or 'errno' can; // be set but it is not further specified if all are required to be set.; // Documentation does not mention, but file position will be set to; // indeterminate similarly as at 'fread'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:160,Availability,error,error,160,"// Add transition for the failed state.; // Error occurs if nothing is matched yet and reading the input fails.; // Error can be EOF, or other error. At ""other error"" FERROR or 'errno' can; // be set but it is not further specified if all are required to be set.; // Documentation does not mention, but file position will be set to; // indeterminate similarly as at 'fread'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:44,Availability,Failure,Failure,44,"// Add transition for the failed state.; // Failure of 'ungetc' does not result in feof or ferror state.; // If the PutVal has value of EofVal the function should ""fail"", but this is; // the same transition as the success state.; // In this case only one state transition is added by the analyzer (the two; // new states may be similar).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:232,Availability,error,error,232,"// Upon successful completion, the getline() and getdelim() functions shall; // return the number of bytes written into the buffer.; // If the end-of-file indicator for the stream is set, the function shall; // return -1.; // If an error occurs, the function shall return -1 and set 'errno'.; // Add transition for the successful state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:59,Availability,error,error,59,"// Add transition for the failed state.; // If a (non-EOF) error occurs, the resulting value of the file position; // indicator for the stream is indeterminate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:90,Availability,error,error,90,"// Bifurcate the state into failed and non-failed.; // Return zero on success, nonzero on error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:37,Availability,error,error,37,// Reset the state to opened with no error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:10,Availability,error,error,10,"// We get error.; // It is possible that fseek fails but sets none of the error flags.; // If fseek failed, assume that the file position becomes indeterminate in any; // case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:74,Availability,error,error,74,"// We get error.; // It is possible that fseek fails but sets none of the error flags.; // If fseek failed, assume that the file position becomes indeterminate in any; // case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:60,Availability,error,error,60,// Setting the position to start of file never produces EOF error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:80,Availability,failure,failure,80,// This function does not affect the stream state.; // Still we add success and failure state with the appropriate return value.; // StdLibraryFunctionsChecker can change these states (set the 'errno' state).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:6,Availability,failure,failure,6,// At failure ferror could be set.; // The standards do not tell what happens with the file position at failure.; // But we can assume that it is dangerous to make a next I/O operation after; // the position was not set correctly (similar to 'fseek').,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:104,Availability,failure,failure,104,// At failure ferror could be set.; // The standards do not tell what happens with the file position at failure.; // But we can assume that it is dangerous to make a next I/O operation after; // the position was not set correctly (similar to 'fseek').,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:80,Availability,failure,failure,80,// This function does not affect the stream state.; // Still we add success and failure state with the appropriate return value.; // StdLibraryFunctionsChecker can change these states (set the 'errno' state).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:36,Usability,clear,cleared,36,// FilePositionIndeterminate is not cleared.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:23,Availability,error,error,23,// Execution path with error of ErrorKind.; // Function returns true.; // From now on it is the only one error state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:32,Availability,Error,ErrorKind,32,// Execution path with error of ErrorKind.; // Function returns true.; // From now on it is the only one error state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:105,Availability,error,error,105,// Execution path with error of ErrorKind.; // Function returns true.; // From now on it is the only one error state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:26,Availability,Error,ErrorKind,26,// Execution path(s) with ErrorKind not set.; // Function returns false.; // New error state is everything before minus ErrorKind.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:81,Availability,error,error,81,// Execution path(s) with ErrorKind not set.; // Function returns false.; // New error state is everything before minus ErrorKind.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:120,Availability,Error,ErrorKind,120,// Execution path(s) with ErrorKind not set.; // Function returns false.; // New error state is everything before minus ErrorKind.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:27,Availability,failure,failure,27,"// `fflush` returns EOF on failure, otherwise returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:9,Availability,error,error,9,"// Clear error states if `fflush` returns 0, but retain their EOF flags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:3,Usability,Clear,Clear,3,"// Clear error states if `fflush` returns 0, but retain their EOF flags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:9,Availability,error,error,9,// Clear error states for all streams.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:3,Usability,Clear,Clear,3,// Clear error states for all streams.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:7,Availability,error,error,7,// The error is unknown but may be FEOF.; // Continue analysis with the FEOF error state.; // Report warning because the other possible error states.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:77,Availability,error,error,77,// The error is unknown but may be FEOF.; // Continue analysis with the FEOF error state.; // Report warning because the other possible error states.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:136,Availability,error,error,136,// The error is unknown but may be FEOF.; // Continue analysis with the FEOF error state.; // Report warning because the other possible error states.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:20,Availability,error,error,20,"// Known or unknown error state without FEOF possible.; // Stop analysis, report error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:81,Availability,error,error,81,"// Known or unknown error state without FEOF possible.; // Stop analysis, report error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:96,Availability,error,error,96,"// Resource leaks can result in multiple warning that describe the same kind; // of programming error:; // void f() {; // FILE *F = fopen(""a.txt"");; // if (rand()) // state split; // return; // warning; // } // warning; // While this isn't necessarily true (leaking the same stream could result; // from a different kinds of errors), the reduction in redundant reports; // makes this a worthwhile heuristic.; // FIXME: Add a checker option to turn this uniqueing feature off.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:325,Availability,error,errors,325,"// Resource leaks can result in multiple warning that describe the same kind; // of programming error:; // void f() {; // FILE *F = fopen(""a.txt"");; // if (rand()) // state split; // return; // warning; // } // warning; // While this isn't necessarily true (leaking the same stream could result; // from a different kinds of errors), the reduction in redundant reports; // makes this a worthwhile heuristic.; // FIXME: Add a checker option to turn this uniqueing feature off.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:351,Availability,redundant,redundant,351,"// Resource leaks can result in multiple warning that describe the same kind; // of programming error:; // void f() {; // FILE *F = fopen(""a.txt"");; // if (rand()) // state split; // return; // warning; // } // warning; // While this isn't necessarily true (leaking the same stream could result; // from a different kinds of errors), the reduction in redundant reports; // makes this a worthwhile heuristic.; // FIXME: Add a checker option to turn this uniqueing feature off.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:351,Safety,redund,redundant,351,"// Resource leaks can result in multiple warning that describe the same kind; // of programming error:; // void f() {; // FILE *F = fopen(""a.txt"");; // if (rand()) // state split; // return; // warning; // } // warning; // While this isn't necessarily true (leaking the same stream could result; // from a different kinds of errors), the reduction in redundant reports; // makes this a worthwhile heuristic.; // FIXME: Add a checker option to turn this uniqueing feature off.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:108,Deployability,update,updated,108,// Check for file-handling system call that is not handled by the checker.; // FIXME: The checker should be updated to handle all system calls that take; // 'FILE*' argument. These are now ignored.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StringChecker.cpp:21,Performance,cache,cached,21,// See if we already cached it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StringChecker.cpp:3,Performance,Cache,Cache,3,// Cache the decl of the right overload.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Taint.cpp:116,Energy Efficiency,efficient,efficiently,116,"// If the SVal represents a structure, try to mass-taint all values within the; // structure. For now it only works efficiently on lazy compound values that; // were conjured during a conservative evaluation of a function - either as; // return values of functions that return structures or arrays by value, or as; // values of structures or arrays passed into the function by reference,; // directly or through pointer aliasing. Such lazy compound values are; // characterized by having exactly one binding in their captured store within; // their parent region, which is a conjured symbol default-bound to the base; // region of the parent region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Taint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Taint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Taint.cpp:40,Integrability,depend,depends,40,// Traverse all the symbols this symbol depends on to see if any are tainted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Taint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Taint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Taint.cpp:14,Testability,log,logic,14,"// FIXME: The logic to identify tainted regions could be more; // complete. For example, this would not currently identify; // overlapping fields in a union as tainted. To identify this we can; // check for overlapping/nested byte offsets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Taint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Taint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TaintTesterChecker.cpp:411,Testability,test,testing,411,"//== TaintTesterChecker.cpp ----------------------------------- -*- C++ -*--=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker can be used for testing how taint data is propagated.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TaintTesterChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TaintTesterChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TestAfterDivZeroChecker.cpp:442,Performance,perform,performs,442,"//== TestAfterDivZeroChecker.cpp - Test after division by zero checker --*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines TestAfterDivZeroChecker, a builtin check that performs checks; // for division by zero where the division occurs before comparison with zero.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TestAfterDivZeroChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TestAfterDivZeroChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TestAfterDivZeroChecker.cpp:5,Testability,Test,TestAfterDivZeroChecker,5,"//== TestAfterDivZeroChecker.cpp - Test after division by zero checker --*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines TestAfterDivZeroChecker, a builtin check that performs checks; // for division by zero where the division occurs before comparison with zero.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TestAfterDivZeroChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TestAfterDivZeroChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TestAfterDivZeroChecker.cpp:35,Testability,Test,Test,35,"//== TestAfterDivZeroChecker.cpp - Test after division by zero checker --*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines TestAfterDivZeroChecker, a builtin check that performs checks; // for division by zero where the division occurs before comparison with zero.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TestAfterDivZeroChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TestAfterDivZeroChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TestAfterDivZeroChecker.cpp:396,Testability,Test,TestAfterDivZeroChecker,396,"//== TestAfterDivZeroChecker.cpp - Test after division by zero checker --*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines TestAfterDivZeroChecker, a builtin check that performs checks; // for division by zero where the division occurs before comparison with zero.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TestAfterDivZeroChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TestAfterDivZeroChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TrustNonnullChecker.cpp:53,Integrability,protocol,protocols,53,// Only trust annotations for system headers for non-protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TrustNonnullChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TrustNonnullChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TrustNonnullChecker.cpp:7,Testability,log,logic,7,"// The logic for ObjC instance method calls is more complicated,; // as the return value is nil when the receiver is nil.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TrustNonnullChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TrustNonnullChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TrustNonnullChecker.cpp:12,Integrability,protocol,protocols,12,// Distrust protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TrustNonnullChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TrustNonnullChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TrustNonnullChecker.cpp:13,Integrability,message,messages,13,// For class messages it is sufficient for the declaration to be; // annotated _Nonnull.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TrustNonnullChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TrustNonnullChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UndefBranchChecker.cpp:691,Availability,error,error,691,"// What's going on here: we want to highlight the subexpression of the; // condition that is the most likely source of the ""uninitialized; // branch condition."" We do a recursive walk of the condition's; // subexpressions and roughly look for the most nested subexpression; // that binds to Undefined. We then highlight that expression's range.; // Get the predecessor node and check if is a PostStmt with the Stmt; // being the terminator condition. We want to inspect the state; // of that node instead because it will contain main information about; // the subexpressions.; // Note: any predecessor will do. They should have identical state,; // since all the BlockEdge did was act as an error sink since the value; // had to already be undefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UndefBranchChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UndefBranchChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UndefCapturedBlockVarChecker.cpp:396,Safety,detect,detects,396,"// UndefCapturedBlockVarChecker.cpp - Uninitialized captured vars -*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker detects blocks that capture uninitialized values.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UndefCapturedBlockVarChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UndefCapturedBlockVarChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UndefinedArraySubscriptChecker.cpp:467,Performance,perform,performs,467,"//===--- UndefinedArraySubscriptChecker.h ----------------------*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines UndefinedArraySubscriptChecker, a builtin check in ExprEngine; // that performs checks for undefined array subscripts.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UndefinedArraySubscriptChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UndefinedArraySubscriptChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UndefinedArraySubscriptChecker.cpp:34,Modifiability,variab,variables,34,// Sema generates anonymous array variables for copying array struct fields.; // Don't warn if we're in an implicitly-generated constructor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UndefinedArraySubscriptChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UndefinedArraySubscriptChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UndefResultChecker.cpp:455,Performance,perform,performs,455,"//=== UndefResultChecker.cpp ------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines UndefResultChecker, a builtin check in ExprEngine that; // performs checks for undefined results of non-assignment binary operators.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UndefResultChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UndefResultChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UndefResultChecker.cpp:15,Availability,error,error,15,// Generate an error node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UndefResultChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UndefResultChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp:12,Availability,mask,maskedFlags,12,// Check if maskedFlags is non-zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp:16,Availability,error,error,16,// Only emit an error if the value of 'maskedFlags' is properly; // constrained;,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp:39,Availability,mask,maskedFlags,39,// Only emit an error if the value of 'maskedFlags' is properly; // constrained;,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp:92,Modifiability,refactor,refactored,92,// This is similar to 'CheckDispatchOnce' in the MacOSXAPIChecker.; // They can possibly be refactored.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp:40,Energy Efficiency,allocate,allocated,40,"// Check if the first argument is stack allocated. If so, issue a warning; // because that's likely to be bad news.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp:16,Availability,error,error,16,"// Generates an error report, indicating that the function whose name is given; // will perform a zero byte allocation.; // Returns false if an error occurred, true otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp:144,Availability,error,error,144,"// Generates an error report, indicating that the function whose name is given; // will perform a zero byte allocation.; // Returns false if an error occurred, true otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp:88,Performance,perform,perform,88,"// Generates an error report, indicating that the function whose name is given; // will perform a zero byte allocation.; // Returns false if an error occurred, true otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnreachableCodeChecker.cpp:135,Availability,error,errors,135,"// It is good practice to always have a ""default"" label in a ""switch"", even; // if we should never get there. It can be used to detect errors, for; // instance. Unreachable code directly under a ""default"" label is therefore; // likely to be a false positive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnreachableCodeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnreachableCodeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnreachableCodeChecker.cpp:128,Safety,detect,detect,128,"// It is good practice to always have a ""default"" label in a ""switch"", even; // if we should never get there. It can be used to detect errors, for; // instance. Unreachable code directly under a ""default"" label is therefore; // likely to be a false positive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnreachableCodeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnreachableCodeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnreachableCodeChecker.cpp:69,Modifiability,extend,extended,69,"// Special case for __builtin_unreachable.; // FIXME: This should be extended to include other unreachable markers,; // such as llvm_unreachable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnreachableCodeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnreachableCodeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnreachableCodeChecker.cpp:2,Testability,assert,assert,2,"//assert(cond && ""CFGBlock's predecessor has a terminator condition"");; // The previous assertion is invalid in some cases (eg do/while). Leaving; // reporting of these situations on at the moment to help triage these cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnreachableCodeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnreachableCodeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnreachableCodeChecker.cpp:88,Testability,assert,assertion,88,"//assert(cond && ""CFGBlock's predecessor has a terminator condition"");; // The previous assertion is invalid in some cases (eg do/while). Leaving; // reporting of these situations on at the moment to help triage these cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnreachableCodeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnreachableCodeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ValistChecker.cpp:411,Safety,detect,detect,411,"//== ValistChecker.cpp - stdarg.h macro usage checker -----------*- C++ -*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines checkers which detect usage of uninitialized va_list values; // and va_start calls with no matching va_end.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ValistChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ValistChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VforkChecker.cpp:588,Modifiability,variab,variables,588,"//===- VforkChecker.cpp -------- Vfork usage checks --------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines vfork checker which checks for dangerous uses of vfork.; // Vforked process shares memory (including stack) with parent so it's; // range of actions is significantly limited: can't write variables,; // can't call functions not in the allowed list, etc. For more details, see; // http://man7.org/linux/man-pages/man2/vfork.2.html; //; // This checker checks for prohibited constructs in vforked process.; // The state transition diagram:; // PARENT ---(vfork() == 0)--> CHILD; // |; // --(*p = ...)--> bug; // |; // --foo()--> bug; // |; // --return--> bug; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VforkChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VforkChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VforkChecker.cpp:58,Modifiability,variab,variable,58,// end anonymous namespace; // This trait holds region of variable that is assigned with vfork's; // return value (this is the only region child is allowed to write).; // VFORK_RESULT_INVALID means that we are in parent process.; // VFORK_RESULT_NONE means that vfork's return value hasn't been assigned.; // Other values point to valid regions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VforkChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VforkChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VforkChecker.cpp:3,Safety,Detect,Detect,3,// Detect calls to vfork and split execution appropriately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VforkChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VforkChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VforkChecker.cpp:16,Modifiability,variab,variable,16,// Get assigned variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VforkChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VforkChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VirtualCallChecker.cpp:14,Security,access,access,14,"// The member access is fully qualified (i.e., X::F).; // Treat this as a non-virtual call and do not warn.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VirtualCallChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VirtualCallChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp:451,Performance,perform,performs,451,"//=== VLASizeChecker.cpp - Undefined dereference checker --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines VLASizeChecker, a builtin check in ExprEngine that; // performs checks for declaration of VLA of undefined or zero size.; // In addition, VLASizeChecker is responsible for defining the extent; // of the MemRegion that represents a VLA.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp:159,Security,validat,validated,159,/// Check a VLA for validity.; /// Every dimension of the array and the total size is checked for validity.; /// Returns null or a new state where the size is validated.; /// 'ArraySize' will contain SVal that refers to the total size (in char); /// of the array.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp:83,Modifiability,Variab,VariableArrayType,83,"// Walk over the VLAs for every dimension until a non-VLA is found.; // There is a VariableArrayType for every dimension (fixed or variable) until; // the most inner array that is variably modified.; // Dimension sizes are collected into 'VLASizes'. 'VLALast' is set to the; // innermost VLA that was encountered.; // In ""int vla[x][2][y][3]"" this will be the array for index ""y"" (with type; // int[3]). 'VLASizes' contains 'x', '2', and 'y'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp:131,Modifiability,variab,variable,131,"// Walk over the VLAs for every dimension until a non-VLA is found.; // There is a VariableArrayType for every dimension (fixed or variable) until; // the most inner array that is variably modified.; // Dimension sizes are collected into 'VLASizes'. 'VLALast' is set to the; // innermost VLA that was encountered.; // In ""int vla[x][2][y][3]"" this will be the array for index ""y"" (with type; // int[3]). 'VLASizes' contains 'x', '2', and 'y'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp:180,Modifiability,variab,variably,180,"// Walk over the VLAs for every dimension until a non-VLA is found.; // There is a VariableArrayType for every dimension (fixed or variable) until; // the most inner array that is variably modified.; // Dimension sizes are collected into 'VLASizes'. 'VLALast' is set to the; // innermost VLA that was encountered.; // In ""int vla[x][2][y][3]"" this will be the array for index ""y"" (with type; // int[3]). 'VLASizes' contains 'x', '2', and 'y'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp:150,Safety,detect,detected,150,// Check if the array size will overflow.; // Size overflow check does not work with symbolic expressions because a; // overflow situation can not be detected easily.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp:15,Availability,error,error,15,// Generate an error node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp:15,Availability,error,error,15,// Generate an error node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Yaml.h:441,Deployability,configurat,configuration,441,"//== Yaml.h ---------------------------------------------------- -*- C++ -*--=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines convenience functions for handling YAML configuration files; // for checkers/packages.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Yaml.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Yaml.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Yaml.h:441,Modifiability,config,configuration,441,"//== Yaml.h ---------------------------------------------------- -*- C++ -*--=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines convenience functions for handling YAML configuration files; // for checkers/packages.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Yaml.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Yaml.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Yaml.h:154,Availability,error,error,154,/// Read the given file from the filesystem and parse it as a yaml file. The; /// template parameter must have a yaml MappingTraits.; /// Emit diagnostic error in case of any failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Yaml.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Yaml.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Yaml.h:175,Availability,failure,failure,175,/// Read the given file from the filesystem and parse it as a yaml file. The; /// template parameter must have a yaml MappingTraits.; /// Emit diagnostic error in case of any failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Yaml.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Yaml.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/cert/InvalidPtrChecker.cpp:112,Modifiability,variab,variable,112,"// SEI CERT ENV31-C; // If set to true, consider getenv calls as invalidating operations on the; // environment variable buffer. This is implied in the standard, but in; // practice does not cause problems (in the commonly used environments).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/cert/InvalidPtrChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/cert/InvalidPtrChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/cert/InvalidPtrChecker.cpp:79,Safety,avoid,avoid,79,// Mark all regions that were interesting before as NOT interesting now; // to avoid extra notes coming from invalidation points higher up the; // bugpath. This ensures that only the last invalidation point is marked; // with a note tag.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/cert/InvalidPtrChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/cert/InvalidPtrChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/cert/InvalidPtrChecker.cpp:17,Integrability,message,message,17,// Emit note tag message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/cert/InvalidPtrChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/cert/InvalidPtrChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/cert/InvalidPtrChecker.cpp:33,Usability,Simpl,Simplify,33,// TODO: This seems really ugly. Simplify this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/cert/InvalidPtrChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/cert/InvalidPtrChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/cert/PutenvWithAutoChecker.cpp:483,Modifiability,variab,variable,483,"//== PutenvWithAutoChecker.cpp --------------------------------- -*- C++ -*--=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines PutenvWithAutoChecker which finds calls of ``putenv``; // function with automatic variable as the argument.; // https://wiki.sei.cmu.edu/confluence/x/6NYxBQ; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/cert/PutenvWithAutoChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/cert/PutenvWithAutoChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPIBugReporter.cpp:488,Safety,detect,detected,488,"//===-- MPIBugReporter.cpp - bug reporter -----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines prefabricated reports which are emitted in; /// case of MPI related bugs, detected by path-sensitive analysis.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPIBugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPIBugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPIBugReporter.h:486,Safety,detect,detected,486,"//===-- MPIBugReporter.h - bug reporter -----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines prefabricated reports which are emitted in; /// case of MPI related bugs, detected by path-sensitive analysis.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPIBugReporter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPIBugReporter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPIChecker.cpp:22,Safety,detect,detected,22,// double nonblocking detected,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPIChecker.cpp:6,Availability,error,error,6,// no error,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPIChecker.cpp:17,Deployability,update,update,17,// Transition to update the state regarding removed requests.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPIChecker.h:89,Availability,alive,alive,89,"/// Check if a nonblocking call is not matched by a wait.; /// If a memory region is not alive and the last function using the; /// request was a nonblocking call, this is rated as a missing wait.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPIChecker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPIChecker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPITypes.h:491,Integrability,wrap,wrapper,491,"//===-- MPITypes.h - Functionality to model MPI concepts --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file provides definitions to model concepts of MPI. The mpi::Request; /// class defines a wrapper class, in order to make MPI requests trackable for; /// path-sensitive analysis.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPITypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPITypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPITypes.h:234,Availability,avail,available,234,"// The RequestMap stores MPI requests which are identified by their memory; // region. Requests are used in MPI to complete nonblocking operations with wait; // operations. A custom map implementation is used, in order to make it; // available in an arbitrary amount of translation units.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPITypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPITypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:94,Modifiability,variab,variables,94,"// FIXME: For now we invalidate the tracking of all symbols passed to blocks; // via captured variables, even though captured variables result in a copy; // and in implicit increment/decrement of a retain count.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:126,Modifiability,variab,variables,126,"// FIXME: For now we invalidate the tracking of all symbols passed to blocks; // via captured variables, even though captured variables result in a copy; // and in implicit increment/decrement of a retain count.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:23,Availability,error,error,23,"// FIXME: If we get an error during a bridge cast, should we report it?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:38,Integrability,bridg,bridge,38,"// FIXME: If we get an error during a bridge cast, should we report it?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:3,Security,Access,Accessing,3,"// Accessing an ivar directly is unusual. If we've done that, be more; // forgiving about what the surrounding code is allowed to do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:33,Performance,load,loaded,33,// Note that this value has been loaded from an ivar.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:20,Security,access,accessor,20,"// In a synthesized accessor, the effective retain count is +0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:16,Integrability,message,message,16,"// Check if the message is not consumed, we know it will not be used in; // an assignment, ex: ""self = [super init]"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:53,Integrability,message,message,53,"/// GetReturnType - Used to get the return type of a message expression or; /// function call with the intention of affixing that type to a tracked symbol.; /// While the return type can be queried directly from RetEx, when; /// invoking class methods we augment to the return type to be that of; /// a pointer to the class (as opposed it just being id).; // FIXME: We may be able to do this with related result types instead.; // This function is probably overestimating.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:20,Integrability,message,message,20,"// If RetE is not a message expression just return its type.; // If RetE is a message expression, return its types if it is something; /// more specific than id.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:78,Integrability,message,message,78,"// If RetE is not a message expression just return its type.; // If RetE is a message expression, return its types if it is something; /// more specific than id.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:48,Integrability,message,message,48,"// At this point we know the return type of the message expression is; // id, id<...>, or Class. If we have an ObjCInterfaceDecl, we know this; // is a call to a class method whose type we can resolve. In such; // cases, promote the return type to XXX* (where XXX is the class).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:30,Integrability,message,message,30,// Evaluate the effect on the message receiver.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:190,Modifiability,variab,variable,190,"/// A value escapes in these possible cases:; ///; /// - binding to something that is not a memory region.; /// - binding to a memregion that does not have stack storage; /// - binding to a variable that has a destructor attached using CleanupAttr; ///; /// We do not currently model what happens when a symbol is; /// assigned to a struct field, unless it is a known smart pointer; /// implementation, about which we know that it is inlined.; /// FIXME: This could definitely be improved upon.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:136,Safety,avoid,avoid,136,"// Splitting is required to support out parameters,; // as out parameters might be created only on the ""success"" branch.; // We want to avoid eagerly splitting unless out parameters are actually; // needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:30,Integrability,message,message,30,// Evaluate the effect on the message receiver / `this` argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:15,Availability,error,errors,15,// Process any errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:24,Deployability,release,releases,24,// Handle all use-after-releases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:43,Availability,error,error,43,// NB. we only need to add a note in a non-error case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:45,Deployability,release,released,45,// The object immediately transitions to the released state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:3,Deployability,Update,Update,3,// Update the autorelease counts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:17,Deployability,Release,Released,17,// case 'RefVal::Released' handled above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:28,Modifiability,variab,variable,28,"// Assume that the instance variable was holding on the object at; // +1, and we just didn't know.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:245,Deployability,release,release,245,"// HACK: Ignore retain-count issues on values accessed through ivars,; // because of cases like this:; // [_contentView retain];; // [_contentView removeFromSuperview];; // [self addSubview:_contentView]; // invalidates 'self'; // [_contentView release];",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:46,Security,access,accessed,46,"// HACK: Ignore retain-count issues on values accessed through ivars,; // because of cases like this:; // [_contentView retain];; // [_contentView removeFromSuperview];; // [self addSubview:_contentView]; // invalidates 'self'; // [_contentView release];",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:18,Availability,down,down,18,// We need to dig down to the symbolic base here because various; // custom allocators do sometimes return the symbol with an offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:3,Deployability,Update,Update,3,// Update the binding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:25,Deployability,update,updated,25,// At this point we have updated the state properly.; // Everything after this is merely checking to see if the return value has; // been over- or under-retained.; // Did we cache out?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:174,Performance,cache,cache,174,// At this point we have updated the state properly.; // Everything after this is merely checking to see if the return value has; // been over- or under-retained.; // Did we cache out?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:3,Deployability,Update,Update,3,// Update the autorelease counts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:11,Deployability,update,updated,11,// Get the updated binding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:245,Deployability,release,release,245,"// HACK: Ignore retain-count issues on values accessed through ivars,; // because of cases like this:; // [_contentView retain];; // [_contentView removeFromSuperview];; // [self addSubview:_contentView]; // invalidates 'self'; // [_contentView release];",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:46,Security,access,accessed,46,"// HACK: Ignore retain-count issues on values accessed through ivars,; // because of cases like this:; // [_contentView retain];; // [_contentView removeFromSuperview];; // [self addSubview:_contentView]; // invalidates 'self'; // [_contentView release];",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:22,Availability,error,errors,22,// Any leaks or other errors?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:15,Availability,error,error,15,// Generate an error node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:28,Integrability,interface,interface,28,// FIXME: We may add to the interface of evalAssume the list of symbols; // whose assumptions have changed. For now we just iterate through the; // bindings and check if any of the tracked symbols are NULL. This isn't; // too bad since the number of symbols we will track in practice are; // probably small and evalAssume is only called at branches and a few; // other places.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:50,Deployability,release,released,50,// FIXME: Handle sending 'autorelease' to already released object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:20,Deployability,release,release,20,"// If we would over-release here, but we know the value came from an ivar,; // assume it was a strong ivar that's just been relinquished.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:245,Deployability,release,release,245,"// HACK: Ignore retain-count issues on values accessed through ivars,; // because of cases like this:; // [_contentView retain];; // [_contentView removeFromSuperview];; // [self addSubview:_contentView]; // invalidates 'self'; // [_contentView release];",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:46,Security,access,accessed,46,"// HACK: Ignore retain-count issues on values accessed through ivars,; // because of cases like this:; // [_contentView retain];; // [_contentView removeFromSuperview];; // [self addSubview:_contentView]; // invalidates 'self'; // [_contentView release];",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:72,Availability,error,error,72,// Woah! More autorelease counts then retain counts left.; // Emit hard error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:245,Deployability,release,release,245,"// HACK: Ignore retain-count issues on values accessed through ivars,; // because of cases like this:; // [_contentView retain];; // [_contentView removeFromSuperview];; // [self addSubview:_contentView]; // invalidates 'self'; // [_contentView release];",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:46,Security,access,accessed,46,"// HACK: Ignore retain-count issues on values accessed through ivars,; // because of cases like this:; // [_contentView retain];; // [_contentView removeFromSuperview];; // [self addSubview:_contentView]; // invalidates 'self'; // [_contentView release];",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:17,Performance,cache,cached,17,// Created state cached out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:162,Deployability,release,releases,162,"// If the current LocationContext has a parent, don't check for leaks.; // We will do that later.; // FIXME: we should instead check for imbalances of the retain/releases,; // and suggest annotations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:3,Deployability,Update,Update,3,// Update counts from autorelease pools,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:10,Performance,cache,cache,10,// Did we cache out?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:273,Integrability,depend,depends,273,"// FIXME: We want bug reports to always have the same checker name associated; // with them, yet here, if RetainCountChecker is disabled but; // OSObjectRetainCountChecker is enabled, the checker names will be different.; // This hack will make it so that the checker name depends on which checker is; // enabled rather than on the registration order.; // For the most part, we want **non-hidden checkers** to be associated with; // diagnostics, and **hidden checker options** with the fine-tuning of; // modeling. Following this logic, OSObjectRetainCountChecker should be the; // latter, but we can't just remove it for backward compatibility reasons.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:530,Testability,log,logic,530,"// FIXME: We want bug reports to always have the same checker name associated; // with them, yet here, if RetainCountChecker is disabled but; // OSObjectRetainCountChecker is enabled, the checker names will be different.; // This hack will make it so that the checker name depends on which checker is; // enabled rather than on the registration order.; // For the most part, we want **non-hidden checkers** to be associated with; // diagnostics, and **hidden checker options** with the fine-tuning of; // modeling. Following this logic, OSObjectRetainCountChecker should be the; // latter, but we can't just remove it for backward compatibility reasons.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.h:19,Deployability,release,released,19,// Object has been released.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.h:21,Deployability,release,released,21,// Object used after released.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.h:3,Deployability,Release,Release,3,// Release of an object that was not owned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.h:88,Modifiability,variab,variable,88,"/// Returns what the analyzer knows about direct accesses to a particular; /// instance variable.; ///; /// If the object with this refcount wasn't originally from an Objective-C; /// ivar region, this should always return IvarAccessHistory::None.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.h:49,Security,access,accesses,49,"/// Returns what the analyzer knows about direct accesses to a particular; /// instance variable.; ///; /// If the object with this refcount wasn't originally from an Objective-C; /// ivar region, this should always return IvarAccessHistory::None.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.h:4,Performance,Perform,Perform,4,"/// Perform the necessary checks and state adjustments at the end of the; /// function.; /// \p S Return statement, may be null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp:58,Availability,error,error,58,// We may not have transitioned to 'release' if we hit an error.; // This case is handled elsewhere.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp:36,Deployability,release,release,36,// We may not have transitioned to 'release' if we hit an error.; // This case is handled elsewhere.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp:22,Integrability,message,message,22,// Did an autorelease message get sent?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp:40,Availability,avail,available,40,// Get the name of the callee (if it is available); // from the tracked SVal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp:53,Integrability,interface,interface,53,"// We should always be able to find the boxing class interface,; // but consider this future-proofing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp:35,Performance,perform,performed,35,// Gather up the effects that were performed on the object at this; // program point,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp:79,Availability,avail,available,79,"// The location context of the init method called on the leaked object, if; // available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp:80,Availability,error,error,80,// Do not show local variables belonging to a function other than; // where the error is reported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp:21,Modifiability,variab,variables,21,// Do not show local variables belonging to a function other than; // where the error is reported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp:53,Energy Efficiency,allocate,allocated,53,"// If we are reporting a leak of the object that was allocated with alloc,; // mark its init method as interesting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp:100,Modifiability,variab,variables,100,"// Tell the BugReporterContext to report cases when the tracked symbol is; // assigned to different variables, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp:143,Energy Efficiency,allocate,allocated,143,"// Most bug reports are cached at the location where they occurred.; // With leaks, we want to unique them by the location where they were; // allocated, and only report a single path. To do this, we need to find; // the allocation site of a piece of tracked memory, which we do via a; // call to GetAllocationSite. This will walk the ExplodedGraph backwards.; // Note that this is *not* the trimmed graph; we are guaranteed, however,; // that all ancestor nodes that represent the allocation site have the; // same SourceLocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp:24,Performance,cache,cached,24,"// Most bug reports are cached at the location where they occurred.; // With leaks, we want to unique them by the location where they were; // allocated, and only report a single path. To do this, we need to find; // the allocation site of a piece of tracked memory, which we do via a; // call to GetAllocationSite. This will walk the ExplodedGraph backwards.; // Note that this is *not* the trimmed graph; we are guaranteed, however,; // that all ancestor nodes that represent the allocation site have the; // same SourceLocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp:360,Deployability,release,release,360,"// At this point, we know that the original region doesn't contain the leaking; // when the actual leak happens. It means that it can be confusing for the; // user to see such description in the message.; //; // Let's consider the following example:; // Object *Original = allocate(...);; // Object *New = Original;; // Original = allocate(...);; // Original->release();; //; // Complaining about a leaking object ""stored into Original"" might cause a; // rightful confusion because 'Original' is actually released.; // We should complain about 'New' instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp:505,Deployability,release,released,505,"// At this point, we know that the original region doesn't contain the leaking; // when the actual leak happens. It means that it can be confusing for the; // user to see such description in the message.; //; // Let's consider the following example:; // Object *Original = allocate(...);; // Object *New = Original;; // Original = allocate(...);; // Original->release();; //; // Complaining about a leaking object ""stored into Original"" might cause a; // rightful confusion because 'Original' is actually released.; // We should complain about 'New' instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp:273,Energy Efficiency,allocate,allocate,273,"// At this point, we know that the original region doesn't contain the leaking; // when the actual leak happens. It means that it can be confusing for the; // user to see such description in the message.; //; // Let's consider the following example:; // Object *Original = allocate(...);; // Object *New = Original;; // Original = allocate(...);; // Original->release();; //; // Complaining about a leaking object ""stored into Original"" might cause a; // rightful confusion because 'Original' is actually released.; // We should complain about 'New' instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp:331,Energy Efficiency,allocate,allocate,331,"// At this point, we know that the original region doesn't contain the leaking; // when the actual leak happens. It means that it can be confusing for the; // user to see such description in the message.; //; // Let's consider the following example:; // Object *Original = allocate(...);; // Object *New = Original;; // Original = allocate(...);; // Original->release();; //; // Complaining about a leaking object ""stored into Original"" might cause a; // rightful confusion because 'Original' is actually released.; // We should complain about 'New' instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp:195,Integrability,message,message,195,"// At this point, we know that the original region doesn't contain the leaking; // when the actual leak happens. It means that it can be confusing for the; // user to see such description in the message.; //; // Let's consider the following example:; // Object *Original = allocate(...);; // Object *New = Original;; // Original = allocate(...);; // Original->release();; //; // Complaining about a leaking object ""stored into Original"" might cause a; // rightful confusion because 'Original' is actually released.; // We should complain about 'New' instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.h:50,Energy Efficiency,allocate,allocated,50,// Finds the location where the leaking object is allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:1267,Availability,CheckPoint,CheckPointeeInitialization,1267,"xception; //; //===----------------------------------------------------------------------===//; //; // This file defines helper classes for UninitializedObjectChecker and; // documentation about the logic of it.; //; // The checker reports uninitialized fields in objects created after a; // constructor call.; //; // This checker has several options:; // - ""Pedantic"" (boolean). If its not set or is set to false, the checker; // won't emit warnings for objects that don't have at least one initialized; // field. This may be set with; //; // `-analyzer-config optin.cplusplus.UninitializedObject:Pedantic=true`.; //; // - ""NotesAsWarnings"" (boolean). If set to true, the checker will emit a; // warning for each uninitialized field, as opposed to emitting one warning; // per constructor call, and listing the uninitialized fields that belongs; // to it in notes. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:NotesAsWarnings=true`.; //; // - ""CheckPointeeInitialization"" (boolean). If set to false, the checker will; // not analyze the pointee of pointer/reference fields, and will only check; // whether the object itself is initialized. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:CheckPointeeInitialization=true`.; //; // TODO: With some clever heuristics, some pointers should be dereferenced; // by default. For example, if the pointee is constructed within the; // constructor call, it's reasonable to say that no external object; // references it, and we wouldn't generate multiple report on the same; // pointee.; //; // - ""IgnoreRecordsWithField"" (string). If supplied, the checker will not; // analyze structures that have a field with a name or type name that; // matches the given pattern. Defaults to """".; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:IgnoreRecordsWithField=""[Tt]ag|[Kk]ind""`.; //; // - ""IgnoreGuardedFields"" (boolean). If set to true, the checker will analyze; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:1550,Availability,CheckPoint,CheckPointeeInitialization,1550,"ted after a; // constructor call.; //; // This checker has several options:; // - ""Pedantic"" (boolean). If its not set or is set to false, the checker; // won't emit warnings for objects that don't have at least one initialized; // field. This may be set with; //; // `-analyzer-config optin.cplusplus.UninitializedObject:Pedantic=true`.; //; // - ""NotesAsWarnings"" (boolean). If set to true, the checker will emit a; // warning for each uninitialized field, as opposed to emitting one warning; // per constructor call, and listing the uninitialized fields that belongs; // to it in notes. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:NotesAsWarnings=true`.; //; // - ""CheckPointeeInitialization"" (boolean). If set to false, the checker will; // not analyze the pointee of pointer/reference fields, and will only check; // whether the object itself is initialized. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:CheckPointeeInitialization=true`.; //; // TODO: With some clever heuristics, some pointers should be dereferenced; // by default. For example, if the pointee is constructed within the; // constructor call, it's reasonable to say that no external object; // references it, and we wouldn't generate multiple report on the same; // pointee.; //; // - ""IgnoreRecordsWithField"" (string). If supplied, the checker will not; // analyze structures that have a field with a name or type name that; // matches the given pattern. Defaults to """".; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:IgnoreRecordsWithField=""[Tt]ag|[Kk]ind""`.; //; // - ""IgnoreGuardedFields"" (boolean). If set to true, the checker will analyze; // _syntactically_ whether the found uninitialized object is used without a; // preceding assert call. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:IgnoreGuardedFields=true`.; //; // Most of the following methods as well as the checker",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:2684,Energy Efficiency,reduce,reduce,2684,"// `-analyzer-config optin.cplusplus.UninitializedObject:Pedantic=true`.; //; // - ""NotesAsWarnings"" (boolean). If set to true, the checker will emit a; // warning for each uninitialized field, as opposed to emitting one warning; // per constructor call, and listing the uninitialized fields that belongs; // to it in notes. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:NotesAsWarnings=true`.; //; // - ""CheckPointeeInitialization"" (boolean). If set to false, the checker will; // not analyze the pointee of pointer/reference fields, and will only check; // whether the object itself is initialized. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:CheckPointeeInitialization=true`.; //; // TODO: With some clever heuristics, some pointers should be dereferenced; // by default. For example, if the pointee is constructed within the; // constructor call, it's reasonable to say that no external object; // references it, and we wouldn't generate multiple report on the same; // pointee.; //; // - ""IgnoreRecordsWithField"" (string). If supplied, the checker will not; // analyze structures that have a field with a name or type name that; // matches the given pattern. Defaults to """".; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:IgnoreRecordsWithField=""[Tt]ag|[Kk]ind""`.; //; // - ""IgnoreGuardedFields"" (boolean). If set to true, the checker will analyze; // _syntactically_ whether the found uninitialized object is used without a; // preceding assert call. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:IgnoreGuardedFields=true`.; //; // Most of the following methods as well as the checker itself is defined in; // UninitializedObjectChecker.cpp.; //; // Some methods are implemented in UninitializedPointee.cpp, to reduce the; // complexity of the main checker file.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:835,Modifiability,config,config,835,"//===----- UninitializedObject.h ---------------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines helper classes for UninitializedObjectChecker and; // documentation about the logic of it.; //; // The checker reports uninitialized fields in objects created after a; // constructor call.; //; // This checker has several options:; // - ""Pedantic"" (boolean). If its not set or is set to false, the checker; // won't emit warnings for objects that don't have at least one initialized; // field. This may be set with; //; // `-analyzer-config optin.cplusplus.UninitializedObject:Pedantic=true`.; //; // - ""NotesAsWarnings"" (boolean). If set to true, the checker will emit a; // warning for each uninitialized field, as opposed to emitting one warning; // per constructor call, and listing the uninitialized fields that belongs; // to it in notes. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:NotesAsWarnings=true`.; //; // - ""CheckPointeeInitialization"" (boolean). If set to false, the checker will; // not analyze the pointee of pointer/reference fields, and will only check; // whether the object itself is initialized. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:CheckPointeeInitialization=true`.; //; // TODO: With some clever heuristics, some pointers should be dereferenced; // by default. For example, if the pointee is constructed within the; // constructor call, it's reasonable to say that no external object; // references it, and we wouldn't generate multiple report on the same; // pointee.; //; // - ""IgnoreRecordsWithField"" (string). If supplied, the checker will not; // analyze structures that have a",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:1184,Modifiability,config,config,1184,"llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines helper classes for UninitializedObjectChecker and; // documentation about the logic of it.; //; // The checker reports uninitialized fields in objects created after a; // constructor call.; //; // This checker has several options:; // - ""Pedantic"" (boolean). If its not set or is set to false, the checker; // won't emit warnings for objects that don't have at least one initialized; // field. This may be set with; //; // `-analyzer-config optin.cplusplus.UninitializedObject:Pedantic=true`.; //; // - ""NotesAsWarnings"" (boolean). If set to true, the checker will emit a; // warning for each uninitialized field, as opposed to emitting one warning; // per constructor call, and listing the uninitialized fields that belongs; // to it in notes. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:NotesAsWarnings=true`.; //; // - ""CheckPointeeInitialization"" (boolean). If set to false, the checker will; // not analyze the pointee of pointer/reference fields, and will only check; // whether the object itself is initialized. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:CheckPointeeInitialization=true`.; //; // TODO: With some clever heuristics, some pointers should be dereferenced; // by default. For example, if the pointee is constructed within the; // constructor call, it's reasonable to say that no external object; // references it, and we wouldn't generate multiple report on the same; // pointee.; //; // - ""IgnoreRecordsWithField"" (string). If supplied, the checker will not; // analyze structures that have a field with a name or type name that; // matches the given pattern. Defaults to """".; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:IgnoreRecordsWithField=""[Tt]ag|",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:1501,Modifiability,config,config,1501,"The checker reports uninitialized fields in objects created after a; // constructor call.; //; // This checker has several options:; // - ""Pedantic"" (boolean). If its not set or is set to false, the checker; // won't emit warnings for objects that don't have at least one initialized; // field. This may be set with; //; // `-analyzer-config optin.cplusplus.UninitializedObject:Pedantic=true`.; //; // - ""NotesAsWarnings"" (boolean). If set to true, the checker will emit a; // warning for each uninitialized field, as opposed to emitting one warning; // per constructor call, and listing the uninitialized fields that belongs; // to it in notes. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:NotesAsWarnings=true`.; //; // - ""CheckPointeeInitialization"" (boolean). If set to false, the checker will; // not analyze the pointee of pointer/reference fields, and will only check; // whether the object itself is initialized. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:CheckPointeeInitialization=true`.; //; // TODO: With some clever heuristics, some pointers should be dereferenced; // by default. For example, if the pointee is constructed within the; // constructor call, it's reasonable to say that no external object; // references it, and we wouldn't generate multiple report on the same; // pointee.; //; // - ""IgnoreRecordsWithField"" (string). If supplied, the checker will not; // analyze structures that have a field with a name or type name that; // matches the given pattern. Defaults to """".; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:IgnoreRecordsWithField=""[Tt]ag|[Kk]ind""`.; //; // - ""IgnoreGuardedFields"" (boolean). If set to true, the checker will analyze; // _syntactically_ whether the found uninitialized object is used without a; // preceding assert call. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:IgnoreGuardedFields=true`.; //;",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:2104,Modifiability,config,config,2104,"// `-analyzer-config optin.cplusplus.UninitializedObject:Pedantic=true`.; //; // - ""NotesAsWarnings"" (boolean). If set to true, the checker will emit a; // warning for each uninitialized field, as opposed to emitting one warning; // per constructor call, and listing the uninitialized fields that belongs; // to it in notes. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:NotesAsWarnings=true`.; //; // - ""CheckPointeeInitialization"" (boolean). If set to false, the checker will; // not analyze the pointee of pointer/reference fields, and will only check; // whether the object itself is initialized. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:CheckPointeeInitialization=true`.; //; // TODO: With some clever heuristics, some pointers should be dereferenced; // by default. For example, if the pointee is constructed within the; // constructor call, it's reasonable to say that no external object; // references it, and we wouldn't generate multiple report on the same; // pointee.; //; // - ""IgnoreRecordsWithField"" (string). If supplied, the checker will not; // analyze structures that have a field with a name or type name that; // matches the given pattern. Defaults to """".; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:IgnoreRecordsWithField=""[Tt]ag|[Kk]ind""`.; //; // - ""IgnoreGuardedFields"" (boolean). If set to true, the checker will analyze; // _syntactically_ whether the found uninitialized object is used without a; // preceding assert call. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:IgnoreGuardedFields=true`.; //; // Most of the following methods as well as the checker itself is defined in; // UninitializedObjectChecker.cpp.; //; // Some methods are implemented in UninitializedPointee.cpp, to reduce the; // complexity of the main checker file.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:2421,Modifiability,config,config,2421,"// `-analyzer-config optin.cplusplus.UninitializedObject:Pedantic=true`.; //; // - ""NotesAsWarnings"" (boolean). If set to true, the checker will emit a; // warning for each uninitialized field, as opposed to emitting one warning; // per constructor call, and listing the uninitialized fields that belongs; // to it in notes. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:NotesAsWarnings=true`.; //; // - ""CheckPointeeInitialization"" (boolean). If set to false, the checker will; // not analyze the pointee of pointer/reference fields, and will only check; // whether the object itself is initialized. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:CheckPointeeInitialization=true`.; //; // TODO: With some clever heuristics, some pointers should be dereferenced; // by default. For example, if the pointee is constructed within the; // constructor call, it's reasonable to say that no external object; // references it, and we wouldn't generate multiple report on the same; // pointee.; //; // - ""IgnoreRecordsWithField"" (string). If supplied, the checker will not; // analyze structures that have a field with a name or type name that; // matches the given pattern. Defaults to """".; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:IgnoreRecordsWithField=""[Tt]ag|[Kk]ind""`.; //; // - ""IgnoreGuardedFields"" (boolean). If set to true, the checker will analyze; // _syntactically_ whether the found uninitialized object is used without a; // preceding assert call. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:IgnoreGuardedFields=true`.; //; // Most of the following methods as well as the checker itself is defined in; // UninitializedObjectChecker.cpp.; //; // Some methods are implemented in UninitializedPointee.cpp, to reduce the; // complexity of the main checker file.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:479,Testability,log,logic,479,"//===----- UninitializedObject.h ---------------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines helper classes for UninitializedObjectChecker and; // documentation about the logic of it.; //; // The checker reports uninitialized fields in objects created after a; // constructor call.; //; // This checker has several options:; // - ""Pedantic"" (boolean). If its not set or is set to false, the checker; // won't emit warnings for objects that don't have at least one initialized; // field. This may be set with; //; // `-analyzer-config optin.cplusplus.UninitializedObject:Pedantic=true`.; //; // - ""NotesAsWarnings"" (boolean). If set to true, the checker will emit a; // warning for each uninitialized field, as opposed to emitting one warning; // per constructor call, and listing the uninitialized fields that belongs; // to it in notes. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:NotesAsWarnings=true`.; //; // - ""CheckPointeeInitialization"" (boolean). If set to false, the checker will; // not analyze the pointee of pointer/reference fields, and will only check; // whether the object itself is initialized. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:CheckPointeeInitialization=true`.; //; // TODO: With some clever heuristics, some pointers should be dereferenced; // by default. For example, if the pointee is constructed within the; // constructor call, it's reasonable to say that no external object; // references it, and we wouldn't generate multiple report on the same; // pointee.; //; // - ""IgnoreRecordsWithField"" (string). If supplied, the checker will not; // analyze structures that have a",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:2370,Testability,assert,assert,2370,"// `-analyzer-config optin.cplusplus.UninitializedObject:Pedantic=true`.; //; // - ""NotesAsWarnings"" (boolean). If set to true, the checker will emit a; // warning for each uninitialized field, as opposed to emitting one warning; // per constructor call, and listing the uninitialized fields that belongs; // to it in notes. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:NotesAsWarnings=true`.; //; // - ""CheckPointeeInitialization"" (boolean). If set to false, the checker will; // not analyze the pointee of pointer/reference fields, and will only check; // whether the object itself is initialized. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:CheckPointeeInitialization=true`.; //; // TODO: With some clever heuristics, some pointers should be dereferenced; // by default. For example, if the pointee is constructed within the; // constructor call, it's reasonable to say that no external object; // references it, and we wouldn't generate multiple report on the same; // pointee.; //; // - ""IgnoreRecordsWithField"" (string). If supplied, the checker will not; // analyze structures that have a field with a name or type name that; // matches the given pattern. Defaults to """".; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:IgnoreRecordsWithField=""[Tt]ag|[Kk]ind""`.; //; // - ""IgnoreGuardedFields"" (boolean). If set to true, the checker will analyze; // _syntactically_ whether the found uninitialized object is used without a; // preceding assert call. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:IgnoreGuardedFields=true`.; //; // Most of the following methods as well as the checker itself is defined in; // UninitializedObjectChecker.cpp.; //; // Some methods are implemented in UninitializedPointee.cpp, to reduce the; // complexity of the main checker file.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:30,Integrability,wrap,wrapper,30,"/// A lightweight polymorphic wrapper around FieldRegion *. We'll use this; /// interface to store addinitional information about fields. As described; /// later, a list of these objects (i.e. ""fieldchain"") will be constructed and; /// used for printing note messages should an uninitialized value be found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:80,Integrability,interface,interface,80,"/// A lightweight polymorphic wrapper around FieldRegion *. We'll use this; /// interface to store addinitional information about fields. As described; /// later, a list of these objects (i.e. ""fieldchain"") will be constructed and; /// used for printing note messages should an uninitialized value be found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:259,Integrability,message,messages,259,"/// A lightweight polymorphic wrapper around FieldRegion *. We'll use this; /// interface to store addinitional information about fields. As described; /// later, a list of these objects (i.e. ""fieldchain"") will be constructed and; /// used for printing note messages should an uninitialized value be found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:18,Modifiability,polymorphi,polymorphic,18,"/// A lightweight polymorphic wrapper around FieldRegion *. We'll use this; /// interface to store addinitional information about fields. As described; /// later, a list of these objects (i.e. ""fieldchain"") will be constructed and; /// used for printing note messages should an uninitialized value be found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:85,Integrability,interface,interface,85,// We'll delete all of these special member functions to force the users of; // this interface to only store references to FieldNode objects in containers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:37,Integrability,wrap,wrap,37,// Special FieldNode descendants may wrap nullpointers (for example if they; // describe a special relationship between two elements of the fieldchain); // -- we wouldn't like to unique these objects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:353,Integrability,message,message,353,"// When a fieldchain is printed, it will have the following format (without; // newline, indices are in order of insertion, from 1 to n):; //; // <note_message_n>'<prefix_n><prefix_n-1>...<prefix_1>; // this-><node_1><separator_1><node_2><separator_2>...<node_n>'; /// If this is the last element of the fieldchain, this method will print the; /// note message associated with it.; /// The note message should state something like ""uninitialized field"" or; /// ""uninitialized pointee"" etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:395,Integrability,message,message,395,"// When a fieldchain is printed, it will have the following format (without; // newline, indices are in order of insertion, from 1 to n):; //; // <note_message_n>'<prefix_n><prefix_n-1>...<prefix_1>; // this-><node_1><separator_1><node_2><separator_2>...<node_n>'; /// If this is the last element of the fieldchain, this method will print the; /// note message associated with it.; /// The note message should state something like ""uninitialized field"" or; /// ""uninitialized pointee"" etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:121,Modifiability,variab,variable,121,/// Returns with Field's name. This is a helper function to get the correct name; /// even if Field is a captured lambda variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:319,Integrability,wrap,wrapper,319,"/// Represents a field chain. A field chain is a list of fields where the first; /// element of the chain is the object under checking (not stored), and every; /// other element is a field, and the element that precedes it is the object; /// that contains it.; ///; /// Note that this class is immutable (essentially a wrapper around an; /// ImmutableList), new FieldChainInfo objects may be created by member; /// functions such as add() and replaceHead().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:54,Integrability,message,messages,54,"/// A map for assigning uninitialized regions to note messages. For example,; ///; /// struct A {; /// int x;; /// };; ///; /// A a;; ///; /// After analyzing `a`, the map will contain a pair for `a.x`'s region and; /// the note message ""uninitialized field 'this->x'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:229,Integrability,message,message,229,"/// A map for assigning uninitialized regions to note messages. For example,; ///; /// struct A {; /// int x;; /// };; ///; /// A a;; ///; /// After analyzing `a`, the map will contain a pair for `a.x`'s region and; /// the note message ""uninitialized field 'this->x'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:82,Integrability,message,message,82,"/// Returns with the modified state and a map of (uninitialized region,; /// note message) pairs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:225,Availability,CheckPoint,CheckPointeeInitialization,225,"/// Returns whether the analyzed region contains at least one initialized; /// field. Note that this includes subfields as well, not just direct ones,; /// and will return false if an uninitialized pointee is found with; /// CheckPointeeInitialization enabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp:716,Energy Efficiency,reduce,reduce,716,"//===----- UninitializedObjectChecker.cpp ------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a checker that reports uninitialized fields in objects; // created after a constructor call.; //; // To read about command line options and how the checker works, refer to the; // top of the file and inline comments in UninitializedObject.h.; //; // Some of the logic is implemented in UninitializedPointee.cpp, to reduce the; // complexity of this file.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp:663,Testability,log,logic,663,"//===----- UninitializedObjectChecker.cpp ------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a checker that reports uninitialized fields in objects; // created after a constructor call.; //; // To read about command line options and how the checker works, refer to the; // top of the file and inline comments in UninitializedObject.h.; //; // Some of the logic is implemented in UninitializedPointee.cpp, to reduce the; // complexity of this file.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp:143,Integrability,wrap,wrap,143,"/// Represents that the FieldNode that comes after this is declared in a base; /// of the previous FieldNode. As such, this descendant doesn't wrap a; /// FieldRegion, and is purely a tool to describe a relation between two other; /// FieldRegion wrapping descendants.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp:247,Integrability,wrap,wrapping,247,"/// Represents that the FieldNode that comes after this is declared in a base; /// of the previous FieldNode. As such, this descendant doesn't wrap a; /// FieldRegion, and is purely a tool to describe a relation between two other; /// FieldRegion wrapping descendants.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp:53,Security,access,access,53,"/// Checks _syntactically_ whether it is possible to access FD from the record; /// that contains it without a preceding assert (even if that access happens; /// inside a method). This is mainly used for records that act like unions, like; /// having multiple bit fields, with only a fraction being properly initialized.; /// If these fields are properly guarded with asserts, this method returns; /// false.; ///; /// Since this check is done syntactically, this method could be inaccurate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp:142,Security,access,access,142,"/// Checks _syntactically_ whether it is possible to access FD from the record; /// that contains it without a preceding assert (even if that access happens; /// inside a method). This is mainly used for records that act like unions, like; /// having multiple bit fields, with only a fraction being properly initialized.; /// If these fields are properly guarded with asserts, this method returns; /// false.; ///; /// Since this check is done syntactically, this method could be inaccurate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp:121,Testability,assert,assert,121,"/// Checks _syntactically_ whether it is possible to access FD from the record; /// that contains it without a preceding assert (even if that access happens; /// inside a method). This is mainly used for records that act like unions, like; /// having multiple bit fields, with only a fraction being properly initialized.; /// If these fields are properly guarded with asserts, this method returns; /// false.; ///; /// Since this check is done syntactically, this method could be inaccurate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp:368,Testability,assert,asserts,368,"/// Checks _syntactically_ whether it is possible to access FD from the record; /// that contains it without a preceding assert (even if that access happens; /// inside a method). This is mainly used for records that act like unions, like; /// having multiple bit fields, with only a fraction being properly initialized.; /// If these fields are properly guarded with asserts, this method returns; /// false.; ///; /// Since this check is done syntactically, this method could be inaccurate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp:36,Availability,error,error,36,// This avoids essentially the same error being reported multiple times.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp:8,Safety,avoid,avoids,8,// This avoids essentially the same error being reported multiple times.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp:43,Modifiability,inherit,inherited,43,// Checking bases. The checker will regard inherited data members as direct; // fields.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp:85,Integrability,message,messages,85,"// If the head of the list is also a BaseClass, we'll overwrite it to avoid; // note messages like 'this->A::B::x'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp:70,Safety,avoid,avoid,70,"// If the head of the list is also a BaseClass, we'll overwrite it to avoid; // note messages like 'this->A::B::x'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp:33,Modifiability,variab,variable,33,"// If Field is a captured lambda variable, Field->getName() will return with; // an empty string. We can however acquire it's name from the lambda's; // captures.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedPointee.cpp:467,Energy Efficiency,reduce,reduce,467,"//===----- UninitializedPointee.cpp ------------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines functions and methods for handling pointers and references; // to reduce the size and complexity of UninitializedObjectChecker.cpp.; //; // To read about command line options and documentation about how the checker; // works, refer to UninitializedObjectChecker.h.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedPointee.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedPointee.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedPointee.cpp:149,Integrability,message,message,149,"/// Represents a nonloc::LocAsInteger or void* field, that point to objects, but; /// needs to be casted back to its dynamic type for a correct note message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedPointee.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedPointee.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h:771,Modifiability,variab,variable,771,"/// This function de-facto defines a set of transformations that we consider; /// safe (in heuristical sense). These transformation if passed a safe value as; /// an input should provide a safe value (or an object that provides safe; /// values).; ///; /// For more context see Static Analyzer checkers documentation - specifically; /// webkit.UncountedCallArgsChecker checker. Allowed list of transformations:; /// - constructors of ref-counted types (including factory methods); /// - getters of ref-counted types; /// - member overloaded operators; /// - casts; /// - unary operators like ``&`` or ``*``; ///; /// If passed expression is of type uncounted pointer/reference we try to find; /// the ""origin"" of the pointer value.; /// Origin can be for example a local variable, nullptr, constant or; /// this-pointer.; ///; /// Certain subexpression nodes represent transformations that don't affect; /// where the memory address originates from. We try to traverse such; /// subexpressions to get to the relevant child nodes. Whenever we encounter a; /// subexpression that either can't be ignored, we don't model its semantics or; /// that has multiple children we stop.; ///; /// \p E is an expression of uncounted pointer/reference type.; /// If \p StopAtFirstRefCountedObj is true and we encounter a subexpression that; /// represents ref-counted object during the traversal we return relevant; /// sub-expression and true.; ///; /// \returns subexpression that we traversed to and if \p; /// StopAtFirstRefCountedObj is true we also return whether we stopped early.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h:82,Safety,safe,safe,82,"/// This function de-facto defines a set of transformations that we consider; /// safe (in heuristical sense). These transformation if passed a safe value as; /// an input should provide a safe value (or an object that provides safe; /// values).; ///; /// For more context see Static Analyzer checkers documentation - specifically; /// webkit.UncountedCallArgsChecker checker. Allowed list of transformations:; /// - constructors of ref-counted types (including factory methods); /// - getters of ref-counted types; /// - member overloaded operators; /// - casts; /// - unary operators like ``&`` or ``*``; ///; /// If passed expression is of type uncounted pointer/reference we try to find; /// the ""origin"" of the pointer value.; /// Origin can be for example a local variable, nullptr, constant or; /// this-pointer.; ///; /// Certain subexpression nodes represent transformations that don't affect; /// where the memory address originates from. We try to traverse such; /// subexpressions to get to the relevant child nodes. Whenever we encounter a; /// subexpression that either can't be ignored, we don't model its semantics or; /// that has multiple children we stop.; ///; /// \p E is an expression of uncounted pointer/reference type.; /// If \p StopAtFirstRefCountedObj is true and we encounter a subexpression that; /// represents ref-counted object during the traversal we return relevant; /// sub-expression and true.; ///; /// \returns subexpression that we traversed to and if \p; /// StopAtFirstRefCountedObj is true we also return whether we stopped early.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h:144,Safety,safe,safe,144,"/// This function de-facto defines a set of transformations that we consider; /// safe (in heuristical sense). These transformation if passed a safe value as; /// an input should provide a safe value (or an object that provides safe; /// values).; ///; /// For more context see Static Analyzer checkers documentation - specifically; /// webkit.UncountedCallArgsChecker checker. Allowed list of transformations:; /// - constructors of ref-counted types (including factory methods); /// - getters of ref-counted types; /// - member overloaded operators; /// - casts; /// - unary operators like ``&`` or ``*``; ///; /// If passed expression is of type uncounted pointer/reference we try to find; /// the ""origin"" of the pointer value.; /// Origin can be for example a local variable, nullptr, constant or; /// this-pointer.; ///; /// Certain subexpression nodes represent transformations that don't affect; /// where the memory address originates from. We try to traverse such; /// subexpressions to get to the relevant child nodes. Whenever we encounter a; /// subexpression that either can't be ignored, we don't model its semantics or; /// that has multiple children we stop.; ///; /// \p E is an expression of uncounted pointer/reference type.; /// If \p StopAtFirstRefCountedObj is true and we encounter a subexpression that; /// represents ref-counted object during the traversal we return relevant; /// sub-expression and true.; ///; /// \returns subexpression that we traversed to and if \p; /// StopAtFirstRefCountedObj is true we also return whether we stopped early.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h:189,Safety,safe,safe,189,"/// This function de-facto defines a set of transformations that we consider; /// safe (in heuristical sense). These transformation if passed a safe value as; /// an input should provide a safe value (or an object that provides safe; /// values).; ///; /// For more context see Static Analyzer checkers documentation - specifically; /// webkit.UncountedCallArgsChecker checker. Allowed list of transformations:; /// - constructors of ref-counted types (including factory methods); /// - getters of ref-counted types; /// - member overloaded operators; /// - casts; /// - unary operators like ``&`` or ``*``; ///; /// If passed expression is of type uncounted pointer/reference we try to find; /// the ""origin"" of the pointer value.; /// Origin can be for example a local variable, nullptr, constant or; /// this-pointer.; ///; /// Certain subexpression nodes represent transformations that don't affect; /// where the memory address originates from. We try to traverse such; /// subexpressions to get to the relevant child nodes. Whenever we encounter a; /// subexpression that either can't be ignored, we don't model its semantics or; /// that has multiple children we stop.; ///; /// \p E is an expression of uncounted pointer/reference type.; /// If \p StopAtFirstRefCountedObj is true and we encounter a subexpression that; /// represents ref-counted object during the traversal we return relevant; /// sub-expression and true.; ///; /// \returns subexpression that we traversed to and if \p; /// StopAtFirstRefCountedObj is true we also return whether we stopped early.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h:228,Safety,safe,safe,228,"/// This function de-facto defines a set of transformations that we consider; /// safe (in heuristical sense). These transformation if passed a safe value as; /// an input should provide a safe value (or an object that provides safe; /// values).; ///; /// For more context see Static Analyzer checkers documentation - specifically; /// webkit.UncountedCallArgsChecker checker. Allowed list of transformations:; /// - constructors of ref-counted types (including factory methods); /// - getters of ref-counted types; /// - member overloaded operators; /// - casts; /// - unary operators like ``&`` or ``*``; ///; /// If passed expression is of type uncounted pointer/reference we try to find; /// the ""origin"" of the pointer value.; /// Origin can be for example a local variable, nullptr, constant or; /// this-pointer.; ///; /// Certain subexpression nodes represent transformations that don't affect; /// where the memory address originates from. We try to traverse such; /// subexpressions to get to the relevant child nodes. Whenever we encounter a; /// subexpression that either can't be ignored, we don't model its semantics or; /// that has multiple children we stop.; ///; /// \p E is an expression of uncounted pointer/reference type.; /// If \p StopAtFirstRefCountedObj is true and we encounter a subexpression that; /// represents ref-counted object during the traversal we return relevant; /// sub-expression and true.; ///; /// \returns subexpression that we traversed to and if \p; /// StopAtFirstRefCountedObj is true we also return whether we stopped early.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h:99,Safety,safe,safe,99,/// For \p E referring to a ref-countable/-counted pointer/reference we return; /// whether it's a safe call argument. Examples: function parameter or; /// this-pointer. The logic relies on the set of recursive rules we enforce for; /// WebKit codebase.; ///; /// \returns Whether \p E is a safe call arugment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h:291,Safety,safe,safe,291,/// For \p E referring to a ref-countable/-counted pointer/reference we return; /// whether it's a safe call argument. Examples: function parameter or; /// this-pointer. The logic relies on the set of recursive rules we enforce for; /// WebKit codebase.; ///; /// \returns Whether \p E is a safe call arugment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h:174,Testability,log,logic,174,/// For \p E referring to a ref-countable/-counted pointer/reference we return; /// whether it's a safe call argument. Examples: function parameter or; /// this-pointer. The logic relies on the set of recursive rules we enforce for; /// WebKit codebase.; ///; /// \returns Whether \p E is a safe call arugment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h:77,Testability,assert,assert,77,"// In case F is for example ""operator|"" the getName() method below would; // assert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/UncountedCallArgsChecker.cpp:43,Safety,Safe,SafeRefCntblRawPtrAttr,43,// TODO: attributes.; // if ((*P)->hasAttr<SafeRefCntblRawPtrAttr>()); // continue;,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/UncountedCallArgsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/UncountedCallArgsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/UncountedLocalVarsChecker.cpp:119,Modifiability,variab,variable,119,// We need to skip the first CompoundStmt to avoid situation when guardian is; // defined in the same scope as guarded variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/UncountedLocalVarsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/UncountedLocalVarsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/UncountedLocalVarsChecker.cpp:45,Safety,avoid,avoid,45,// We need to skip the first CompoundStmt to avoid situation when guardian is; // defined in the same scope as guarded variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/UncountedLocalVarsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/UncountedLocalVarsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/UncountedLocalVarsChecker.cpp:35,Safety,safe,safe,35,// Parameters are guaranteed to be safe for the duration of the call; // by another checker.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/UncountedLocalVarsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/UncountedLocalVarsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/AnalyzerOptions.cpp:433,Deployability,configurat,configuration,433,"//===- AnalyzerOptions.cpp - Analysis Engine Options ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains special accessors for analyzer configuration options; // with string representations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/AnalyzerOptions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/AnalyzerOptions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/AnalyzerOptions.cpp:433,Modifiability,config,configuration,433,"//===- AnalyzerOptions.cpp - Analysis Engine Options ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains special accessors for analyzer configuration options; // with string representations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/AnalyzerOptions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/AnalyzerOptions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/AnalyzerOptions.cpp:410,Security,access,accessors,410,"//===- AnalyzerOptions.cpp - Analysis Engine Options ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains special accessors for analyzer configuration options; // with string representations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/AnalyzerOptions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/AnalyzerOptions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/APSIntType.cpp:26,Usability,Simpl,Simple,26,"//===--- APSIntType.cpp - Simple record of the type of APSInts ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/APSIntType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/APSIntType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp:174,Energy Efficiency,allocate,allocated,174,"// Note that the dstor for the contents of APSIntSet will never be called,; // so we iterate over the set and invoke the dstor for each APSInt. This; // frees an aux. memory allocated to represent very large constants.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp:3,Safety,Avoid,Avoid,3,// Avoid division by zero,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp:3,Safety,Avoid,Avoid,3,// Avoid division by zero,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp:15,Testability,log,logic,15,"// FIXME: This logic should probably go higher up, where we can; // test these conditions symbolically.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp:68,Testability,test,test,68,"// FIXME: This logic should probably go higher up, where we can; // test these conditions symbolically.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp:15,Testability,log,logic,15,"// FIXME: This logic should probably go higher up, where we can; // test these conditions symbolically.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp:68,Testability,test,test,68,"// FIXME: This logic should probably go higher up, where we can; // test these conditions symbolically.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp:64,Testability,log,logic,64,"// Note: LAnd, LOr, Comma are handled specially by higher-level logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:126,Integrability,rout,routines,126,//===----------------------------------------------------------------------===//; // PathDiagnosticBuilder and its associated routines and helper objects.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:193,Security,secur,security,193,/// A helper class that contains everything needed to construct a; /// PathDiagnostic object. It does no much more then providing convenient; /// getters and some well placed asserts for extra security.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:175,Testability,assert,asserts,175,/// A helper class that contains everything needed to construct a; /// PathDiagnostic object. It does no much more then providing convenient; /// getters and some well placed asserts for extra security.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:27,Availability,error,error,27,/// A linear path from the error node to the root.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:69,Availability,error,error,69,"/// The leaf of the bug path. This isn't the same as the bug reports error; /// node, which refers to the *original* graph, not the bug path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:153,Integrability,depend,depending,153,"/// This function is responsible for generating diagnostic pieces that are; /// *not* provided by bug report visitors.; /// These diagnostics may differ depending on the consumer's settings,; /// and are therefore constructed separately for each consumer.; ///; /// There are two path diagnostics generation modes: with adding edges (used; /// for plists) and without (used for HTML and text). When edges are added,; /// the path is modified to insert artificially generated edges.; /// Otherwise, more detailed diagnostics is emitted for block edges,; /// explaining the transitions in words.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:16,Modifiability,variab,variable,16,// Check if the variable corresponding to the symbol is passed by value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:54,Availability,redundant,redundant,54,"/// An optimization pass over PathPieces that removes redundant diagnostics; /// generated by both ConditionBRVisitor and TrackConstraintBRVisitor. Both; /// BugReporterVisitors use different methods to generate diagnostics, with; /// one capable of emitting diagnostics in some cases but not in others. This; /// can lead to redundant diagnostic pieces at the same point in a path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:326,Availability,redundant,redundant,326,"/// An optimization pass over PathPieces that removes redundant diagnostics; /// generated by both ConditionBRVisitor and TrackConstraintBRVisitor. Both; /// BugReporterVisitors use different methods to generate diagnostics, with; /// one capable of emitting diagnostics in some cases but not in others. This; /// can lead to redundant diagnostic pieces at the same point in a path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:7,Performance,optimiz,optimization,7,"/// An optimization pass over PathPieces that removes redundant diagnostics; /// generated by both ConditionBRVisitor and TrackConstraintBRVisitor. Both; /// BugReporterVisitors use different methods to generate diagnostics, with; /// one capable of emitting diagnostics in some cases but not in others. This; /// can lead to redundant diagnostic pieces at the same point in a path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:54,Safety,redund,redundant,54,"/// An optimization pass over PathPieces that removes redundant diagnostics; /// generated by both ConditionBRVisitor and TrackConstraintBRVisitor. Both; /// BugReporterVisitors use different methods to generate diagnostics, with; /// one capable of emitting diagnostics in some cases but not in others. This; /// can lead to redundant diagnostic pieces at the same point in a path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:326,Safety,redund,redundant,326,"/// An optimization pass over PathPieces that removes redundant diagnostics; /// generated by both ConditionBRVisitor and TrackConstraintBRVisitor. Both; /// BugReporterVisitors use different methods to generate diagnostics, with; /// one capable of emitting diagnostics in some cases but not in others. This; /// can lead to redundant diagnostic pieces at the same point in a path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:9,Testability,log,logic,9,/// Same logic as above to remove extra pieces.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:340,Energy Efficiency,allocate,allocated,340,"//===----------------------------------------------------------------------===//; // ""Minimal"" path diagnostic generation algorithm.; //===----------------------------------------------------------------------===//; /// If the piece contains a special message, add it to all the call pieces on; /// the active stack. For example, my_malloc allocated memory, so MallocChecker; /// will construct an event at the call to malloc(), and add a stack hint that; /// an allocated memory was returned. We'll use this hint to construct a message; /// when returning from the call to my_malloc; ///; /// void *my_malloc() { return malloc(sizeof(int)); }; /// void fishy() {; /// void *ptr = my_malloc(); // returned allocated memory; /// } // leak",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:463,Energy Efficiency,allocate,allocated,463,"//===----------------------------------------------------------------------===//; // ""Minimal"" path diagnostic generation algorithm.; //===----------------------------------------------------------------------===//; /// If the piece contains a special message, add it to all the call pieces on; /// the active stack. For example, my_malloc allocated memory, so MallocChecker; /// will construct an event at the call to malloc(), and add a stack hint that; /// an allocated memory was returned. We'll use this hint to construct a message; /// when returning from the call to my_malloc; ///; /// void *my_malloc() { return malloc(sizeof(int)); }; /// void fishy() {; /// void *ptr = my_malloc(); // returned allocated memory; /// } // leak",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:706,Energy Efficiency,allocate,allocated,706,"//===----------------------------------------------------------------------===//; // ""Minimal"" path diagnostic generation algorithm.; //===----------------------------------------------------------------------===//; /// If the piece contains a special message, add it to all the call pieces on; /// the active stack. For example, my_malloc allocated memory, so MallocChecker; /// will construct an event at the call to malloc(), and add a stack hint that; /// an allocated memory was returned. We'll use this hint to construct a message; /// when returning from the call to my_malloc; ///; /// void *my_malloc() { return malloc(sizeof(int)); }; /// void fishy() {; /// void *ptr = my_malloc(); // returned allocated memory; /// } // leak",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:252,Integrability,message,message,252,"//===----------------------------------------------------------------------===//; // ""Minimal"" path diagnostic generation algorithm.; //===----------------------------------------------------------------------===//; /// If the piece contains a special message, add it to all the call pieces on; /// the active stack. For example, my_malloc allocated memory, so MallocChecker; /// will construct an event at the call to malloc(), and add a stack hint that; /// an allocated memory was returned. We'll use this hint to construct a message; /// when returning from the call to my_malloc; ///; /// void *my_malloc() { return malloc(sizeof(int)); }; /// void fishy() {; /// void *ptr = my_malloc(); // returned allocated memory; /// } // leak",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:529,Integrability,message,message,529,"//===----------------------------------------------------------------------===//; // ""Minimal"" path diagnostic generation algorithm.; //===----------------------------------------------------------------------===//; /// If the piece contains a special message, add it to all the call pieces on; /// the active stack. For example, my_malloc allocated memory, so MallocChecker; /// will construct an event at the call to malloc(), and add a stack hint that; /// an allocated memory was returned. We'll use this hint to construct a message; /// when returning from the call to my_malloc; ///; /// void *my_malloc() { return malloc(sizeof(int)); }; /// void fishy() {; /// void *ptr = my_malloc(); // returned allocated memory; /// } // leak",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:12,Integrability,message,message,12,"// The last message on the path to final bug is the most important; // one. Since we traverse the path backwards, do not add the message; // if one has been previously added.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:129,Integrability,message,message,129,"// The last message on the path to final bug is the most important; // one. Since we traverse the path backwards, do not add the message; // if one has been previously added.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:34,Testability,assert,assertion,34,// FIXME: Maybe this should be an assertion. Are there cases; // were it is not an EnumConstantDecl?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:11,Security,sanitiz,sanitized,11,/// Adds a sanitized control-flow diagnostic edge to a path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:17,Integrability,wrap,wrapper,17,/// A customized wrapper for CFGBlock::getTerminatorCondition(); /// which returns the element for ObjCForCollectionStmts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:200,Security,access,accessors,200,"// Add the edge only when the callee has body. We jump to the beginning; // of the *declaration*, however we expect it to be followed by the; // body. This isn't the case for autosynthesized property accessors in; // Objective-C. No need for a similar extra check for CallExit points; // because the exit edge comes from a statement (i.e. return),; // not from declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:3,Deployability,Update,Update,3,// Update the previous location in the active path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:91,Safety,avoid,avoids,91,"/// Adds synthetic edges from top-level statements to their subexpressions.; ///; /// This avoids a ""swoosh"" effect, where an edge from a top-level statement A; /// points to a sub-expression B.1 that's not at the start of B. In these cases,; /// we'd like to see an edge from A to B, then another one from B to B.1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:76,Testability,log,logical,76,"// Repeatedly split the edge as necessary.; // This is important for nested logical expressions (||, &&, ?:) where we; // want to show all the levels of context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:3,Deployability,Update,Update,3,// Update the subexpression node to point to the context edge.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:10,Modifiability,extend,extend,10,// Try to extend the previous edge if it's at the same level as the source; // context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:85,Usability,simpl,simple,85,"/// Move edges from a branch condition to a branch target; /// when the condition is simple.; ///; /// This restructures some of the work of addContextEdges. That function; /// creates edges this may destroy, but they work together to create a more; /// aesthetically set of edges around branches. After the call to; /// addContextEdges, we may have (1) an edge to the branch, (2) an edge from; /// the branch to the branch condition, and (3) an edge from the branch; /// condition to the branch target. We keep (1), but may wish to remove (2); /// and move the source of (3) to the branch if the branch condition is simple.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:617,Usability,simpl,simple,617,"/// Move edges from a branch condition to a branch target; /// when the condition is simple.; ///; /// This restructures some of the work of addContextEdges. That function; /// creates edges this may destroy, but they work together to create a more; /// aesthetically set of edges around branches. After the call to; /// addContextEdges, we may have (1) an edge to the branch, (2) an edge from; /// the branch to the branch condition, and (3) an edge from the branch; /// condition to the branch target. We keep (1), but may wish to remove (2); /// and move the source of (3) to the branch if the branch condition is simple.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:11,Performance,perform,perform,11,"// We only perform this transformation for specific branch kinds.; // We don't want to do this for do..while, for example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:3,Performance,Perform,Perform,3,// Perform the hoisting by eliminating (2) and changing the start; // location of (3).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:337,Usability,simpl,simple,337,"/// Eliminate two-edge cycles created by addContextEdges().; ///; /// Once all the context edges are in place, there are plenty of cases where; /// there's a single edge from a top-level statement to a subexpression,; /// followed by a single path note, and then a reverse edge to get back out to; /// the top level. If the statement is simple enough, the subexpression edges; /// just add noise and make it harder to understand what's going on.; ///; /// This function only removes edges in pairs, because removing only one edge; /// might leave other edges dangling.; ///; /// This will not remove edges in more complicated situations:; /// - if there is more than one ""hop"" leading to or from a subexpression.; /// - if there is an inlined call between the edges instead of a single event.; /// - if the whole statement is large enough that having subexpression arrows; /// might be helpful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:51,Integrability,message,message,51,// Erase the second piece if it has the same exact message text.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:3,Performance,Optimiz,Optimize,3,// Optimize subpaths.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:40,Performance,optimiz,optimized,40,// Record the fact that a call has been optimized so we only do the; // effort once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:566,Performance,optimiz,optimization,566,"// Rule I.; //; // If we have two consecutive control edges whose end/begin locations; // are at the same level (e.g. statements or top-level expressions within; // a compound statement, or siblings share a single ancestor expression),; // then merge them if they have no interesting intermediate event.; //; // For example:; //; // (1.1 -> 1.2) -> (1.2 -> 1.3) becomes (1.1 -> 1.3) because the common; // parent is '1'. Here 'x.y.z' represents the hierarchy of statements.; //; // NOTE: this will be limited later in cases where we add barriers; // to prevent this optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:214,Performance,optimiz,optimization,214,// Rule II.; //; // Eliminate edges between subexpressions and parent expressions; // when the subexpression is consumed.; //; // NOTE: this will be limited later in cases where we add barriers; // to prevent this optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:3,Performance,Optimiz,Optimize,3,// Optimize edges for ObjC fast-enumeration loops.; //; // (X -> collection) -> (collection -> element); //; // becomes:; //; // (X -> element),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:70,Usability,simpl,simple,70,// Hoist edges originating from branch conditions to branches; // for simple branches.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:49,Performance,optimiz,optimization,49,// Remove any puny edges left over after primary optimization pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:305,Performance,optimiz,optimizer,305,"/// Drop the very first edge in a path, which should be a function entry edge.; ///; /// If the first edge is not a function entry edge (say, because the first; /// statement had an invalid source location), this function does nothing.; // FIXME: We should just generate invalid edges anyway and have the optimizer; // deal with them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:12,Availability,error,error,12,"// From the error node to the root, ascend the bug path and construct the bug; // report.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:3,Energy Efficiency,Reduce,Reduce,3,// Reduce the number of edges from a very conservative set; // to an aesthetically pleasing subset that conveys the; // necessary information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:10,Integrability,message,messages,10,"// Remove messages that are basically the same, and edges that may not; // make sense.; // We have to do this after edge optimization in the Extensive mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:121,Performance,optimiz,optimization,121,"// Remove messages that are basically the same, and edges that may not; // make sense.; // We have to do this after edge optimization in the Extensive mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:306,Availability,down,downplay,306,"// Even if this symbol/region was already marked as interesting as a; // condition, if we later mark it as interesting again but with; // thorough tracking, overwrite it. Entities marked with thorough; // interestiness are the most important (or most interesting, if you will),; // and we wouldn't like to downplay their importance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:13,Testability,test,tests,13,// FIXME: No tests exist for this code and it is questionable:; // How to handle multiple metadata for the same region?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:85,Availability,down,downplay,85,"// If either is marked with throrough tracking, return that, we wouldn't like; // to downplay a note's importance by 'only' mentioning it as a condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:80,Availability,error,error,80,"// If no custom ranges, add the range of the statement corresponding to; // the error node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:92,Availability,error,error,92,/// A wrapper around an ExplodedGraph that contains a single path from the root; /// to the error node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:6,Integrability,wrap,wrapper,6,/// A wrapper around an ExplodedGraph that contains a single path from the root; /// to the error node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:58,Availability,error,error,58,/// A wrapper around an ExplodedGraph whose leafs are all error nodes. Can; /// conveniently retrieve bug paths from a single error node to the root.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:126,Availability,error,error,126,/// A wrapper around an ExplodedGraph whose leafs are all error nodes. Can; /// conveniently retrieve bug paths from a single error node to the root.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:6,Integrability,wrap,wrapper,6,/// A wrapper around an ExplodedGraph whose leafs are all error nodes. Can; /// conveniently retrieve bug paths from a single error node to the root.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:111,Availability,error,error,111,"/// Since the getErrorNode() or BugReport refers to the original ExplodedGraph,; /// we need to pair it to the error node of the constructed trimmed graph.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:20,Availability,error,error,20,// Find the (first) error node in the trimmed graph. We just need to consult; // the node map which maps from nodes in the original graph to nodes; // in the new graph.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:3,Performance,Perform,Perform,3,// Perform a forward BFS to find all the shortest paths.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:12,Availability,error,error,12,// Sort the error paths from longest to shortest.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:21,Availability,error,error,21,"// Now walk from the error node up the BFS path, always taking the; // predeccessor with the lowest number.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:68,Availability,Error,ErrorNode,68,"/// Generate notes from all visitors.; /// Notes associated with @c ErrorNode are generated using; /// @c getEndPath, and the rest are generated with @c VisitNode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:22,Deployability,release,release,22,"// If we mess up in a release build, we'd still prefer to just drop the bug; // instead of trying to go on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:28,Security,hash,hash,28,// Compute the bug report's hash to determine its equivalence class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:6,Availability,error,error,6,"// An error node must either be a sink or have a tag, otherwise; // it could get reclaimed before the path diagnostic is created.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:96,Usability,simpl,simply,96,"// If we don't need to suppress any of the nodes because they are; // post-dominated by a sink, simply add all the nodes in the equivalence class; // to 'Nodes'. Any of the reports will serve as a ""representative"" report.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:360,Safety,risk,risk,360,"// For bug reports that should be suppressed when all paths are post-dominated; // by a sink node, iterate through the reports in the equivalence class; // until we find one that isn't post-dominated (if one exists). We use a; // DFS traversal of the ExplodedGraph to find a non-sink node. We could write; // this as a recursive function, but we don't want to risk blowing out the; // stack for very long paths.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:30,Usability,clear,cleared,30,// The worklist may have been cleared at this point. First; // check if it is empty before checking the last item.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:3,Deployability,Update,Update,3,// Update the path diagnostic message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:30,Integrability,message,message,30,// Update the path diagnostic message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:3,Safety,Avoid,Avoid,3,// Avoid copying the whole array because there may be a lot of reports.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:458,Modifiability,enhance,enhance,458,"//===- BugReporterVisitors.cpp - Helpers for reporting bugs ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a set of BugReporter ""visitors"" which can be used to; // enhance the diagnostics reported for a bug.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:176,Availability,down,down,176,"/// Given that expression S represents a pointer that would be dereferenced,; /// try to find a sub-expression from which the pointer came from.; /// This is used for tracking down origins of a null or undefined value:; /// ""this is null because that is null because that is null"" etc.; /// We wipe away field and element offsets because they merely add offsets.; /// We also wipe away all casts except lvalue-to-rvalue casts, because the; /// latter represent an actual pointer dereference; however, we remove; /// the final lvalue-to-rvalue cast before returning from this function; /// because it demonstrates more clearly from where the pointer rvalue was; /// loaded. Examples:; /// x->y.z ==> x (lvalue); /// foo()->y.z ==> foo() (rvalue)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:665,Performance,load,loaded,665,"/// Given that expression S represents a pointer that would be dereferenced,; /// try to find a sub-expression from which the pointer came from.; /// This is used for tracking down origins of a null or undefined value:; /// ""this is null because that is null because that is null"" etc.; /// We wipe away field and element offsets because they merely add offsets.; /// We also wipe away all casts except lvalue-to-rvalue casts, because the; /// latter represent an actual pointer dereference; however, we remove; /// the final lvalue-to-rvalue cast before returning from this function; /// because it demonstrates more clearly from where the pointer rvalue was; /// loaded. Examples:; /// x->y.z ==> x (lvalue); /// foo()->y.z ==> foo() (rvalue)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:618,Usability,clear,clearly,618,"/// Given that expression S represents a pointer that would be dereferenced,; /// try to find a sub-expression from which the pointer came from.; /// This is used for tracking down origins of a null or undefined value:; /// ""this is null because that is null because that is null"" etc.; /// We wipe away field and element offsets because they merely add offsets.; /// We also wipe away all casts except lvalue-to-rvalue casts, because the; /// latter represent an actual pointer dereference; however, we remove; /// the final lvalue-to-rvalue cast before returning from this function; /// because it demonstrates more clearly from where the pointer rvalue was; /// loaded. Examples:; /// x->y.z ==> x (lvalue); /// foo()->y.z ==> foo() (rvalue)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:28,Performance,load,load,28,// This cast represents the load we're looking for.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:317,Modifiability,variab,variable,317,"// This handles the case when the dereferencing of a member reference; // happens. This is needed, because the AST for dereferencing a; // member reference looks like the following:; // |-MemberExpr; // `-DeclRefExpr; // Without this special case the notes would refer to the whole object; // (struct, class or union variable) instead of just the relevant member.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:180,Performance,load,loaded,180,"// Special case: remove the final lvalue-to-rvalue cast, but do not recurse; // deeper into the sub-expression. This way we return the lvalue from which; // our pointer rvalue was loaded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:75,Integrability,Wrap,Wrapper,75,"// This handles null references from FieldRegions, for example:; // struct Wrapper { int &ref; };; // Wrapper w = { *(int *)0 };; // w.ref = 1;",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:102,Integrability,Wrap,Wrapper,102,"// This handles null references from FieldRegions, for example:; // struct Wrapper { int &ref; };; // Wrapper w = { *(int *)0 };; // w.ref = 1;",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:129,Deployability,update,updated,129,"/// Comparing internal representations of symbolic values (via; /// SVal::operator==()) is a valid way to check if the value was updated,; /// unless it's a LazyCompoundVal that may have a different internal; /// representation every time it is loaded from the state. In this function we; /// do an approximate comparison for lazy compound values, checking that they; /// are the immediate snapshots of the tracked region's bindings within the; /// node's respective states but not really checking that these snapshots; /// actually contain the same set of bindings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:245,Performance,load,loaded,245,"/// Comparing internal representations of symbolic values (via; /// SVal::operator==()) is a valid way to check if the value was updated,; /// unless it's a LazyCompoundVal that may have a different internal; /// representation every time it is loaded from the state. In this function we; /// do an approximate comparison for lazy compound values, checking that they; /// are the immediate snapshots of the tracked region's bindings within the; /// node's respective states but not really checking that these snapshots; /// actually contain the same set of bindings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:233,Modifiability,variab,variable,233,"// The declaration of the value may rely on a pointer so take its l-value.; // FIXME: As seen in VisitCommonDeclRefExpr, sometimes DeclRefExpr may; // evaluate to a FieldRegion when it refers to a declaration of a lambda; // capture variable. We most likely need to duplicate that logic here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:281,Testability,log,logic,281,"// The declaration of the value may rely on a pointer so take its l-value.; // FIXME: As seen in VisitCommonDeclRefExpr, sometimes DeclRefExpr may; // evaluate to a FieldRegion when it refers to a declaration of a lambda; // capture variable. We most likely need to duplicate that logic here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:94,Safety,avoid,avoid,94,"// Stop calculating at the current function, but always regard it as; // modifying, so we can avoid notes like this:; // void f(Foo &F) {; // F.field = 0; // note: 0 assigned to 'F.field'; // // note: returning without writing to 'F.field'; // }",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:190,Availability,fault,fault,190,"// Optimistically suppress uninitialized value bugs that result; // from system headers having a chance to initialize the value; // but failing to do so. It's too unlikely a system header's fault.; // It's much more likely a situation in which the function has a failure; // mode that the user decided not to check. If we want to hunt such; // omitted checks, we should provide an explicit function-specific note; // describing the precondition under which the function isn't supposed to; // initialize its out-parameter, and additionally check that such; // precondition can actually be fulfilled on the current path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:263,Availability,failure,failure,263,"// Optimistically suppress uninitialized value bugs that result; // from system headers having a chance to initialize the value; // but failing to do so. It's too unlikely a system header's fault.; // It's much more likely a situation in which the function has a failure; // mode that the user decided not to check. If we want to hunt such; // omitted checks, we should provide an explicit function-specific note; // describing the precondition under which the function isn't supposed to; // initialize its out-parameter, and additionally check that such; // precondition can actually be fulfilled on the current path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:133,Modifiability,variab,variable,133,"// We make an exception for system header functions that have no branches.; // Such functions unconditionally fail to initialize the variable.; // If they call other functions that have more paths within them,; // this suppression would still apply when we visit these inner functions.; // One common example of a standard function that doesn't ever initialize; // its out parameter is operator placement new; it's up to the follow-up; // constructor (if any) to initialize the memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:16,Integrability,message,message,16,// Only print a message at the interesting return statement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:82,Availability,avail,available,82,"// Okay, we're at the right return statement, but do we have the return; // value available?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:24,Integrability,message,message,24,// Build an appropriate message based on the return value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:195,Modifiability,variab,variable,195,"// If we ever directly evaluate global DeclStmts, this assertion will be; // invalid, but this still seems preferable to silently accepting an; // initialization that may be for a path-sensitive variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:55,Testability,assert,assertion,55,"// If we ever directly evaluate global DeclStmts, this assertion will be; // invalid, but this still seems preferable to silently accepting an; // initialization that may be for a path-sensitive variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:136,Modifiability,evolve,evolve,136,// Pop the stored field regions and apply them to the origin; // object in the same order we had them on the copy.; // OriginField will evolve like 'b' -> 'b.y' -> 'b.y.e'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:32,Modifiability,variab,variable,32,"// If this is a call entry, the variable should be a parameter.; // FIXME: Handle CXXThisRegion as well. (This is not a priority because; // 'this' should never be NULL, but this visitor isn't just for NULL and; // UndefinedVal.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:82,Integrability,wrap,wrapped,82,"// If this is a CXXTempObjectRegion, the Expr responsible for its creation; // is wrapped inside of it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:71,Modifiability,variab,variable,71,"// If we have init expression, it might be simply a reference; // to a variable, so we can use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:43,Usability,simpl,simply,43,"// If we have init expression, it might be simply a reference; // to a variable, so we can use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:347,Usability,simpl,simple,347,"// Otherwise, if the current region does indeed contain the value; // we are looking for, we can look for a region where this value; // was before.; //; // It can be useful for situations like:; // new = identity(old); // where the analyzer knows that 'identity' returns the value of its; // first argument.; //; // NOTE: If the region R is not a simple var region, it can contain; // V in one of its subregions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:54,Integrability,message,message,54,"// Okay, we've found the binding. Emit an appropriate message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:191,Availability,error,error,191,"/// Tracks the expressions that are a control dependency of the node that was; /// supplied to the constructor.; /// For example:; ///; /// cond = 1;; /// if (cond); /// 10 / 0;; ///; /// An error is emitted at line 3. This visitor realizes that the branch; /// on line 2 is a control dependency of line 3, and tracks it's condition via; /// trackExpressionValue().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:46,Integrability,depend,dependency,46,"/// Tracks the expressions that are a control dependency of the node that was; /// supplied to the constructor.; /// For example:; ///; /// cond = 1;; /// if (cond); /// 10 / 0;; ///; /// An error is emitted at line 3. This visitor realizes that the branch; /// on line 2 is a control dependency of line 3, and tracks it's condition via; /// trackExpressionValue().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:285,Integrability,depend,dependency,285,"/// Tracks the expressions that are a control dependency of the node that was; /// supplied to the constructor.; /// For example:; ///; /// cond = 1;; /// if (cond); /// 10 / 0;; ///; /// An error is emitted at line 3. This visitor realizes that the branch; /// on line 2 is a control dependency of line 3, and tracks it's condition via; /// trackExpressionValue().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:135,Testability,assert,assert,135,"// For the following condition the following CFG would be built:; //; // ------------->; // / \; // [B1] -> [B2] -> [B3] -> [sink]; // assert(A && B || C); \ \; // -----------> [go on with the execution]; //; // It so happens that CFGBlock::getTerminatorCondition returns 'A' for block; // B1, 'A && B' for B2, and 'A && B || C' for B3. Let's check whether we; // reached the end of the condition!",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:36,Integrability,depend,dependencies,36,// We can only reason about control dependencies within the same stack frame.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:9,Performance,Cache,Cache,9,// TODO: Cache CFGBlocks for each ExplodedNode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:178,Security,access,accesses,178,"// FIXME: There's a hack in our Store implementation that always computes; // field offsets around null pointers as if they are always equal to 0.; // The idea here is to report accesses to fields as null dereferences; // even though the pointer value that's being dereferenced is actually; // the offset of the field rather than exactly 0.; // See the FIXME in StoreManager's getLValueFieldOrIvar() method.; // This code interacts heavily with this hack; otherwise the value; // would not be null at all for most fields, so we'd be unable to track it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:54,Integrability,message,message,54,"// Okay, we've found the binding. Emit an appropriate message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:102,Integrability,depend,dependencies,102,"// We only track expressions if we believe that they are important. Chances; // are good that control dependencies to the tracking point are also; // important because of this, let's explain why we believe control reached; // this point.; // TODO: Shouldn't we track control dependencies of every bug location,; // rather than only tracked expressions?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:275,Integrability,depend,dependencies,275,"// We only track expressions if we believe that they are important. Chances; // are good that control dependencies to the tracking point are also; // important because of this, let's explain why we believe control reached; // this point.; // TODO: Shouldn't we track control dependencies of every bug location,; // rather than only tracked expressions?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:7,Integrability,message,message,7,"// The message send could be nil due to the receiver being nil.; // At this point in the path, the receiver should be live since we are at; // the message send expr. If it is nil, start tracking it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:147,Integrability,message,message,147,"// The message send could be nil due to the receiver being nil.; // At this point in the path, the receiver should be live since we are at; // the message send expr. If it is nil, start tracking it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:54,Modifiability,variab,variable,54,"// See if the expression we're interested refers to a variable.; // If so, we can track both its contents and constraints on its value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:17,Modifiability,variab,variable,17,// Mark both the variable region and its contents as interesting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:104,Integrability,message,message,104,"// The receiver was nil, and hence the method was skipped.; // Register a BugReporterVisitor to issue a message telling us how; // the receiver was null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:11,Integrability,message,message,11,// Issue a message saying that the method was skipped.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:23,Testability,log,logical,23,"// When we encounter a logical operator (&& or ||) as a CFG terminator,; // then the condition is actually its LHS; otherwise, we'd encounter; // the parent, such as if-statement, as a terminator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:32,Testability,log,logical,32,"// However, when we encounter a logical operator as a branch condition,; // then the condition is actually its RHS, because LHS would be; // the condition for the logical operator terminator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:163,Testability,log,logical,163,"// However, when we encounter a logical operator as a branch condition,; // then the condition is actually its RHS, because LHS would be; // the condition for the logical operator terminator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:126,Integrability,message,message,126,"// These will be modified in code below, but we need to preserve the original; // values in case we want to throw the generic message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:105,Testability,test,test,105,"// Check if the field name of the MemberExprs is ambiguous. Example:; // "" 'a.d' is equal to 'h.d' "" in 'test/Analysis/null-deref-path-notes.cpp'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:52,Modifiability,variab,variable,52,// Should we invert the strings if the LHS is not a variable name?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:59,Modifiability,variab,variable,59,"// FIXME: If there's already a constraint tracker for this variable,; // we shouldn't emit anything here (c.f. the double note in; // test/Analysis/inlining/path-notes.c)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:134,Testability,test,test,134,"// FIXME: If there's already a constraint tracker for this variable,; // we shouldn't emit anything here (c.f. the double note in; // test/Analysis/inlining/path-notes.c)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:91,Availability,fault,fault,91,"// Skip reports within the 'std' namespace. Although these can sometimes be; // the user's fault, we currently don't report them very well, and; // Note that this will not help for any other data structure libraries, like; // TR1, Boost, or llvm/ADT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:31,Performance,queue,queue,31,// Skip reports within the sys/queue.h macros as we do not have the ability to; // reason about data structure shapes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp:40,Integrability,interface,interface,40,"//===- BugSuppression.cpp - Suppression interface -------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp:73,Security,hash,hashtags,73,"// FIXME: Implement diagnostic identifier arguments; // (checker names, ""hashtags"").",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp:73,Security,hash,hashtags,73,"// FIXME: Implement diagnostic identifier arguments; // (checker names, ""hashtags"").",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp:44,Testability,test,tests,44,"// SourceManager::isBeforeInTranslationUnit tests for strict; // inequality, when we need a non-strict comparison (bug; // can be reported directly on the annotated note).; // For this reason, we use the following equivalence:; //; // A <= B <==> !(B < A); //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp:79,Modifiability,variab,variable,79,"// Bug location could be somewhere in the init value of; // a freshly declared variable. Even though it looks like the; // user applied attribute to a statement, it will apply to a; // variable declaration, and this is where we check for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp:185,Modifiability,variab,variable,185,"// Bug location could be somewhere in the init value of; // a freshly declared variable. Even though it looks like the; // user applied attribute to a statement, it will apply to a; // variable declaration, and this is where we check for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp:69,Integrability,wrap,wrapper,69,"// When we apply attributes to statements, it actually creates; // a wrapper statement that only contains attributes and the wrapped; // statement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp:125,Integrability,wrap,wrapped,125,"// When we apply attributes to statements, it actually creates; // a wrapper statement that only contains attributes and the wrapped; // statement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp:551,Performance,perform,performance,551,"// While some warnings are attached to AST nodes (mostly path-sensitive; // checks), others are simply associated with a plain source location; // or range. Figuring out the node based on locations can be tricky,; // so instead, we traverse the whole body of the declaration and gather; // information on ALL suppressions. After that we can simply check if; // any of those suppressions affect the warning in question.; //; // Traversing AST of a function is not a heavy operation, but for; // large functions with a lot of bugs it can make a dent in performance.; // In order to avoid this scenario, we cache traversal results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp:604,Performance,cache,cache,604,"// While some warnings are attached to AST nodes (mostly path-sensitive; // checks), others are simply associated with a plain source location; // or range. Figuring out the node based on locations can be tricky,; // so instead, we traverse the whole body of the declaration and gather; // information on ALL suppressions. After that we can simply check if; // any of those suppressions affect the warning in question.; //; // Traversing AST of a function is not a heavy operation, but for; // large functions with a lot of bugs it can make a dent in performance.; // In order to avoid this scenario, we cache traversal results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp:580,Safety,avoid,avoid,580,"// While some warnings are attached to AST nodes (mostly path-sensitive; // checks), others are simply associated with a plain source location; // or range. Figuring out the node based on locations can be tricky,; // so instead, we traverse the whole body of the declaration and gather; // information on ALL suppressions. After that we can simply check if; // any of those suppressions affect the warning in question.; //; // Traversing AST of a function is not a heavy operation, but for; // large functions with a lot of bugs it can make a dent in performance.; // In order to avoid this scenario, we cache traversal results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp:96,Usability,simpl,simply,96,"// While some warnings are attached to AST nodes (mostly path-sensitive; // checks), others are simply associated with a plain source location; // or range. Figuring out the node based on locations can be tricky,; // so instead, we traverse the whole body of the declaration and gather; // information on ALL suppressions. After that we can simply check if; // any of those suppressions affect the warning in question.; //; // Traversing AST of a function is not a heavy operation, but for; // large functions with a lot of bugs it can make a dent in performance.; // In order to avoid this scenario, we cache traversal results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp:341,Usability,simpl,simply,341,"// While some warnings are attached to AST nodes (mostly path-sensitive; // checks), others are simply associated with a plain source location; // or range. Figuring out the node based on locations can be tricky,; // so instead, we traverse the whole body of the declaration and gather; // information on ALL suppressions. After that we can simply check if; // any of those suppressions affect the warning in question.; //; // Traversing AST of a function is not a heavy operation, but for; // large functions with a lot of bugs it can make a dent in performance.; // In order to avoid this scenario, we cache traversal results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallDescription.cpp:19,Integrability,Message,Message,19,// FIXME: Add ObjC Message support.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallDescription.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallDescription.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:23,Integrability,Wrap,Wrapper,23,"//===- CallEvent.cpp - Wrapper for all function and method calls ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file This file defines CallEvent and its subclasses, which represent path-; /// sensitive instances of different kinds of function and method calls; /// (C, C++, and Objective-C).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:3,Availability,Recover,Recover,3,"// Recover CFG block via reverse lookup.; // TODO: If we were to keep CFG element information as part of the CallEvent; // instead of doing this reverse lookup, we would be able to build the stack; // frame for non-expression-based calls, and also we wouldn't need the reverse; // lookup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:3,Safety,Recover,Recover,3,"// Recover CFG block via reverse lookup.; // TODO: If we were to keep CFG element information as part of the CallEvent; // instead of doing this reverse lookup, we would be able to build the stack; // frame for non-expression-based calls, and also we wouldn't need the reverse; // lookup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:8,Availability,recover,recover,8,// Also recover CFG index by scanning the CFG block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:8,Safety,recover,recover,8,// Also recover CFG index by scanning the CFG block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:109,Modifiability,extend,extended,109,"// If a function accepts an object by argument (which would of course be a; // temporary that isn't lifetime-extended), invalidate the object itself,; // not only other objects reachable from it. This is necessary because the; // destructor has access to the temporary object after the call.; // TODO: Support placement arguments once we start; // constructing them directly.; // TODO: This is unnecessary when there's no destructor, but that's; // currently hard to figure out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:245,Security,access,access,245,"// If a function accepts an object by argument (which would of course be a; // temporary that isn't lifetime-extended), invalidate the object itself,; // not only other objects reachable from it. This is necessary because the; // destructor has access to the temporary object after the call.; // TODO: Support placement arguments once we start; // constructing them directly.; // TODO: This is unnecessary when there's no destructor, but that's; // currently hard to figure out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:150,Modifiability,variab,variables,150,"// Invalidate designated regions using the batch invalidation API.; // NOTE: Even if RegionsToInvalidate is empty, we may still invalidate; // global variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:453,Integrability,depend,dependent,453,"// Blocks are difficult because the return type may not be stored in the; // BlockDecl itself. The AST should probably be enhanced, but for now we; // just do what we can.; // If the block is declared without an explicit argument list, the; // signature-as-written just includes the return type, not the entire; // function type.; // FIXME: All blocks should have signatures-as-written, even if the return; // type is inferred. (That's signified with a dependent result type.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:122,Modifiability,enhance,enhanced,122,"// Blocks are difficult because the return type may not be stored in the; // BlockDecl itself. The AST should probably be enhanced, but for now we; // just do what we can.; // If the block is declared without an explicit argument list, the; // signature-as-written just includes the return type, not the entire; // function type.; // FIXME: All blocks should have signatures-as-written, even if the return; // type is inferred. (That's signified with a dependent result type.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:3,Integrability,Wrap,Wrap,3,// Wrap it with compound value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:72,Usability,simpl,simply,72,"// If the function has fewer parameters than the call has arguments, we simply; // do not bind any values to them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:42,Availability,error,error,42,"// A newly created definition, but we had error(s) during the import.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:197,Availability,down,down,197,"// We might not even get the original statically-resolved method due to; // some particularly nasty casting (e.g. casts to sister classes).; // However, we should at least be able to search up and down our own class; // hierarchy, and some real bugs have been caught by checking this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:132,Deployability,update,update,132,"// FIXME: This is checking that our DynamicTypeInfo is at least as good as; // the static type. However, because we currently don't update; // DynamicTypeInfo when an object is cast, we can't actually be sure the; // DynamicTypeInfo is up to date. This assert should be re-enabled once; // this is fixed.; //; // assert(!MD->getParent()->isDerivedFrom(RD) && ""Bad DynamicTypeInfo"");",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:253,Testability,assert,assert,253,"// FIXME: This is checking that our DynamicTypeInfo is at least as good as; // the static type. However, because we currently don't update; // DynamicTypeInfo when an object is cast, we can't actually be sure the; // DynamicTypeInfo is up to date. This assert should be re-enabled once; // this is fixed.; //; // assert(!MD->getParent()->isDerivedFrom(RD) && ""Bad DynamicTypeInfo"");",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:313,Testability,assert,assert,313,"// FIXME: This is checking that our DynamicTypeInfo is at least as good as; // the static type. However, because we currently don't update; // DynamicTypeInfo when an object is cast, we can't actually be sure the; // DynamicTypeInfo is up to date. This assert should be re-enabled once; // this is fixed.; //; // assert(!MD->getParent()->isDerivedFrom(RD) && ""Bad DynamicTypeInfo"");",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:48,Security,access,accessing,48,// FIXME: CallEvent maybe shouldn't be directly accessing StoreManager.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:116,Security,access,access,116,"// C++11 [expr.call]p1: ...If the selected function is non-virtual, or if the; // id-expression in the class member access expression is a qualified-id,; // that function is called. Otherwise, its final overrider in the dynamic type; // of the object expression is called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:97,Testability,log,logic,97,// Base destructors are always called non-virtually.; // Skip CXXInstanceCall's devirtualization logic in this case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:85,Modifiability,variab,variable,85,"// If the method call is a setter for property known to be backed by; // an instance variable, don't invalidate the entire receiver, just; // the storage for that instance variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:172,Modifiability,variab,variable,172,"// If the method call is a setter for property known to be backed by; // an instance variable, don't invalidate the entire receiver, just; // the storage for that instance variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:15,Integrability,message,message,15,// An instance message with no expression means we are sending to super.; // In this case the object reference is the same as 'self'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:23,Security,access,accessed,23,// Look for properties accessed with property syntax (foo.bar = ...),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:23,Security,access,accessed,23,// Look for properties accessed with method syntax ([foo setBar:...]).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:16,Integrability,interface,interface,16,"// If the class interface is declared inside the main file, assume it is not; // subcassed.; // TODO: It could actually be subclassed if the subclass is private as well.; // This is probably very rare.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:24,Security,access,accessors,24,// Assume that property accessors are not overridden.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:787,Deployability,release,release,787,"// Repeatedly calling lookupPrivateMethod() is expensive, especially; // when in many cases it returns null. We cache the results so; // that repeated queries on the same ObjCIntefaceDecl and Selector; // don't incur the same cost. On some test cases, we can see the; // same query being issued thousands of times.; //; // NOTE: This cache is essentially a ""global"" variable, but it; // only gets lazily created when we get here. The value of the; // cache probably comes from it being global across ExprEngines,; // where the same queries may get issued. If we are worried about; // concurrency, or possibly loading/unloading ASTs, etc., we may; // need to revisit this someday. In terms of memory, this table; // stays around until clang quits, which also may be bad if we; // need to release memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:366,Modifiability,variab,variable,366,"// Repeatedly calling lookupPrivateMethod() is expensive, especially; // when in many cases it returns null. We cache the results so; // that repeated queries on the same ObjCIntefaceDecl and Selector; // don't incur the same cost. On some test cases, we can see the; // same query being issued thousands of times.; //; // NOTE: This cache is essentially a ""global"" variable, but it; // only gets lazily created when we get here. The value of the; // cache probably comes from it being global across ExprEngines,; // where the same queries may get issued. If we are worried about; // concurrency, or possibly loading/unloading ASTs, etc., we may; // need to revisit this someday. In terms of memory, this table; // stays around until clang quits, which also may be bad if we; // need to release memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:112,Performance,cache,cache,112,"// Repeatedly calling lookupPrivateMethod() is expensive, especially; // when in many cases it returns null. We cache the results so; // that repeated queries on the same ObjCIntefaceDecl and Selector; // don't incur the same cost. On some test cases, we can see the; // same query being issued thousands of times.; //; // NOTE: This cache is essentially a ""global"" variable, but it; // only gets lazily created when we get here. The value of the; // cache probably comes from it being global across ExprEngines,; // where the same queries may get issued. If we are worried about; // concurrency, or possibly loading/unloading ASTs, etc., we may; // need to revisit this someday. In terms of memory, this table; // stays around until clang quits, which also may be bad if we; // need to release memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:334,Performance,cache,cache,334,"// Repeatedly calling lookupPrivateMethod() is expensive, especially; // when in many cases it returns null. We cache the results so; // that repeated queries on the same ObjCIntefaceDecl and Selector; // don't incur the same cost. On some test cases, we can see the; // same query being issued thousands of times.; //; // NOTE: This cache is essentially a ""global"" variable, but it; // only gets lazily created when we get here. The value of the; // cache probably comes from it being global across ExprEngines,; // where the same queries may get issued. If we are worried about; // concurrency, or possibly loading/unloading ASTs, etc., we may; // need to revisit this someday. In terms of memory, this table; // stays around until clang quits, which also may be bad if we; // need to release memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:451,Performance,cache,cache,451,"// Repeatedly calling lookupPrivateMethod() is expensive, especially; // when in many cases it returns null. We cache the results so; // that repeated queries on the same ObjCIntefaceDecl and Selector; // don't incur the same cost. On some test cases, we can see the; // same query being issued thousands of times.; //; // NOTE: This cache is essentially a ""global"" variable, but it; // only gets lazily created when we get here. The value of the; // cache probably comes from it being global across ExprEngines,; // where the same queries may get issued. If we are worried about; // concurrency, or possibly loading/unloading ASTs, etc., we may; // need to revisit this someday. In terms of memory, this table; // stays around until clang quits, which also may be bad if we; // need to release memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:584,Performance,concurren,concurrency,584,"// Repeatedly calling lookupPrivateMethod() is expensive, especially; // when in many cases it returns null. We cache the results so; // that repeated queries on the same ObjCIntefaceDecl and Selector; // don't incur the same cost. On some test cases, we can see the; // same query being issued thousands of times.; //; // NOTE: This cache is essentially a ""global"" variable, but it; // only gets lazily created when we get here. The value of the; // cache probably comes from it being global across ExprEngines,; // where the same queries may get issued. If we are worried about; // concurrency, or possibly loading/unloading ASTs, etc., we may; // need to revisit this someday. In terms of memory, this table; // stays around until clang quits, which also may be bad if we; // need to release memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:609,Performance,load,loading,609,"// Repeatedly calling lookupPrivateMethod() is expensive, especially; // when in many cases it returns null. We cache the results so; // that repeated queries on the same ObjCIntefaceDecl and Selector; // don't incur the same cost. On some test cases, we can see the; // same query being issued thousands of times.; //; // NOTE: This cache is essentially a ""global"" variable, but it; // only gets lazily created when we get here. The value of the; // cache probably comes from it being global across ExprEngines,; // where the same queries may get issued. If we are worried about; // concurrency, or possibly loading/unloading ASTs, etc., we may; // need to revisit this someday. In terms of memory, this table; // stays around until clang quits, which also may be bad if we; // need to release memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:240,Testability,test,test,240,"// Repeatedly calling lookupPrivateMethod() is expensive, especially; // when in many cases it returns null. We cache the results so; // that repeated queries on the same ObjCIntefaceDecl and Selector; // don't incur the same cost. On some test cases, we can see the; // same query being issued thousands of times.; //; // NOTE: This cache is essentially a ""global"" variable, but it; // only gets lazily created when we get here. The value of the; // cache probably comes from it being global across ExprEngines,; // where the same queries may get issued. If we are worried about; // concurrency, or possibly loading/unloading ASTs, etc., we may; // need to revisit this someday. In terms of memory, this table; // stays around until clang quits, which also may be bad if we; // need to release memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:38,Performance,cache,cache,38,// Query lookupPrivateMethod() if the cache does not hit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:93,Integrability,message,messages,93,// It can be actually class methods called with Class object as a; // receiver. This type of messages is treated by the compiler as; // instance (not class).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerContext.cpp:94,Performance,perform,perform,94,"// To avoid false positives (Ex: finding user defined functions with; // similar names), only perform fuzzy name matching when it's a builtin.; // Using a string compare is slow, we might want to switch on BuiltinID here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerContext.cpp:6,Safety,avoid,avoid,6,"// To avoid false positives (Ex: finding user defined functions with; // similar names), only perform fuzzy name matching when it's a builtin.; // Using a string compare is slow, we might want to switch on BuiltinID here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp:55,Performance,cache,cache,55,// Find the checkers that should run for this Decl and cache them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp:3,Deployability,Update,Update,3,// Update which NodeSet is the current one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp:50,Integrability,message,messages,50,// namespace; /// Run checkers for visiting obj-c messages.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp:35,Performance,load,load,35,// namespace; /// Run checkers for load/store of a location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp:6,Deployability,release,release,6,// on release don't check that no other checker also evals.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp:56,Integrability,message,message,56,// Create a temporary stream to see whether we have any message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp:3,Integrability,Inject,Inject,3,// Inject the ending and a new line,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp:3,Security,Inject,Inject,3,// Inject the ending and a new line,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp:23,Integrability,message,message,23,// then begin the next message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp:41,Integrability,message,message,41,// See whether the current checker has a message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp:41,Integrability,message,message,41,// See whether the current checker has a message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp:55,Performance,cache,cache,55,// Find the checkers that should run for this Stmt and cache them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerRegistryData.cpp:41,Availability,avail,available,41,"//===- CheckerRegistry.h - Maintains all available checkers -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerRegistryData.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerRegistryData.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerRegistryData.cpp:16,Availability,avail,available,16,// FIXME: Print available packages.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerRegistryData.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerRegistryData.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ConstraintManager.cpp:405,Integrability,interface,interface,405,"//===- ConstraintManager.cpp - Constraints on symbolic values. ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defined the interface to manage constraints on symbolic values.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ConstraintManager.cpp:176,Safety,avoid,avoid,176,"// Assume functions might recurse (see `reAssume` or `tryRearrange`). During; // the recursion the State might not change anymore, that means we reached a; // fixpoint.; // We avoid infinite recursion of assume calls by checking already visited; // States on the stack of assume function calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ConstraintManager.cpp:34,Integrability,contract,contract,34,"// Checkers might rely on the API contract that both returned states; // cannot be null. Thus, we return StInfeasible for both branches because; // it might happen that a Checker uncoditionally uses one of them if the; // other is a nullptr. This may also happen with the non-dual and; // adjacent `assume(true)` and `assume(false)` calls. By implementing; // assume in therms of assumeDual, we can keep our API contract there as; // well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ConstraintManager.cpp:412,Integrability,contract,contract,412,"// Checkers might rely on the API contract that both returned states; // cannot be null. Thus, we return StInfeasible for both branches because; // it might happen that a Checker uncoditionally uses one of them if the; // other is a nullptr. This may also happen with the non-dual and; // adjacent `assume(true)` and `assume(false)` calls. By implementing; // assume in therms of assumeDual, we can keep our API contract there as; // well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CoreEngine.cpp:3,Performance,Perform,Perform,3,// Perform the transition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CoreEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CoreEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CoreEngine.cpp:54,Usability,simpl,simplify,54,// FIXME: Use constant-folding in CFG construction to simplify this; // case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CoreEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CoreEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CoreEngine.cpp:55,Testability,log,logic,55,// Generate a node for each of the successors.; // Our logic for EH analysis can certainly be improved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CoreEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CoreEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CoreEngine.cpp:152,Modifiability,variab,variable,152,"// In the case of ObjCForCollectionStmt, it appears twice in a CFG:; //; // (1) inside a basic block, which represents the binding of the; // 'element' variable to a value.; // (2) in a terminator, which represents the branch.; //; // For (1), ExprEngine will bind a value (i.e., 0 or 1) indicating; // whether or not collection contains any more elements. We cannot; // just test to see if the element is nil because a container can; // contain nil elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CoreEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CoreEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CoreEngine.cpp:376,Testability,test,test,376,"// In the case of ObjCForCollectionStmt, it appears twice in a CFG:; //; // (1) inside a basic block, which represents the binding of the; // 'element' variable to a value.; // (2) in a terminator, which represents the branch.; //; // For (1), ExprEngine will bind a value (i.e., 0 or 1) indicating; // whether or not collection contains any more elements. We cannot; // just test to see if the element is nil because a container can; // contain nil elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CoreEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CoreEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExplodedGraph.cpp:1176,Safety,safe,safe,1176,"// First, we only consider nodes for reclamation of the following; // conditions apply:; //; // (1) 1 predecessor (that has one successor); // (2) 1 successor (that has one predecessor); //; // If a node has no successor it is on the ""frontier"", while a node; // with no predecessor is a root.; //; // After these prerequisites, we discard all ""filler"" nodes that; // are used only for intermediate processing, and are not essential; // for analyzer history:; //; // (a) PreStmtPurgeDeadSymbols; //; // We then discard all other nodes where *all* of the following conditions; // apply:; //; // (3) The ProgramPoint is for a PostStmt, but not a PostStore.; // (4) There is no 'tag' for the ProgramPoint.; // (5) The 'store' is the same as the predecessor.; // (6) The 'GDM' is the same as the predecessor.; // (7) The LocationContext is the same as the predecessor.; // (8) Expressions that are *not* lvalue expressions.; // (9) The PostStmt isn't for a non-consumed Stmt or Expr.; // (10) The successor is neither a CallExpr StmtPoint nor a CallEnter or; // PreImplicitCall (so that we would be able to find it when retrying a; // call with no inlining).; // FIXME: It may be safe to reclaim PreCall and PostCall nodes as well.; // Conditions 1 and 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExplodedGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExplodedGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExplodedGraph.cpp:347,Energy Efficiency,allocate,allocated,347,"//===----------------------------------------------------------------------===//; // ExplodedNode.; //===----------------------------------------------------------------------===//; // An NodeGroup's storage type is actually very much like a TinyPtrVector:; // it can be either a pointer to a single ExplodedNode, or a pointer to a; // BumpVector allocated with the ExplodedGraph's allocator. This allows the; // common case of single-node NodeGroups to be implemented with no extra memory.; //; // Consequently, each of the NodeGroup methods have up to four cases to handle:; // 1. The flag is set and this group does not actually contain any nodes.; // 2. The group is empty, in which case the storage value is null.; // 3. The group contains a single node.; // 4. The group contains more than one node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExplodedGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExplodedGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExplodedGraph.cpp:89,Modifiability,Refactor,Refactor,89,"// Otherwise, see if the node's program point directly points to a statement.; // FIXME: Refactor into a ProgramPoint method?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExplodedGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExplodedGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExplodedGraph.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate a new node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExplodedGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExplodedGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:616,Security,access,access,616,"// When modeling a C++ constructor, for a variety of reasons we need to track; // the location of the object for the duration of its ConstructionContext.; // ObjectsUnderConstruction maps statements within the construction context; // to the object's location, so that on every such statement the location; // could have been retrieved.; /// ConstructedObjectKey is used for being able to find the path-sensitive; /// memory region of a freshly constructed object while modeling the AST node; /// that syntactically represents the object that is being constructed.; /// Semantics of such nodes may sometimes require access to the region that's; /// not otherwise present in the program state, or to the very fact that; /// the construction context was present and contained references to these; /// AST nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:225,Deployability,continuous,continuous,225,"// This trait is responsible for storing the index of the element that is to be; // constructed in the next iteration. As a result a CXXConstructExpr is only; // stored if it is array type. Also the index is the index of the continuous; // memory region, which is important for multi-dimensional arrays. E.g:: int; // arr[2][2]; assume arr[1][1] will be the next element under construction, so; // the index is 3.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:715,Integrability,rout,route,715,"// MaterializeTemporaryExpr may appear out of place, after a few field and; // base-class accesses have been made to the object, even though semantically; // it is the whole object that gets materialized and lifetime-extended.; //; // For example:; //; // `-MaterializeTemporaryExpr; // `-MemberExpr; // `-CXXTemporaryObjectExpr; //; // instead of the more natural; //; // `-MemberExpr; // `-MaterializeTemporaryExpr; // `-CXXTemporaryObjectExpr; //; // Use the usual methods for obtaining the expression of the base object,; // and record the adjustments that we need to make to obtain the sub-object; // that the whole expression 'Ex' refers to. This trick is usual,; // in the sense that CodeGen takes a similar route.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:217,Modifiability,extend,extended,217,"// MaterializeTemporaryExpr may appear out of place, after a few field and; // base-class accesses have been made to the object, even though semantically; // it is the whole object that gets materialized and lifetime-extended.; //; // For example:; //; // `-MaterializeTemporaryExpr; // `-MemberExpr; // `-CXXTemporaryObjectExpr; //; // instead of the more natural; //; // `-MemberExpr; // `-MaterializeTemporaryExpr; // `-CXXTemporaryObjectExpr; //; // Use the usual methods for obtaining the expression of the base object,; // and record the adjustments that we need to make to obtain the sub-object; // that the whole expression 'Ex' refers to. This trick is usual,; // in the sense that CodeGen takes a similar route.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:90,Security,access,accesses,90,"// MaterializeTemporaryExpr may appear out of place, after a few field and; // base-class accesses have been made to the object, even though semantically; // it is the whole object that gets materialized and lifetime-extended.; //; // For example:; //; // `-MaterializeTemporaryExpr; // `-MemberExpr; // `-CXXTemporaryObjectExpr; //; // instead of the more natural; //; // `-MemberExpr; // `-MaterializeTemporaryExpr; // `-CXXTemporaryObjectExpr; //; // Use the usual methods for obtaining the expression of the base object,; // and record the adjustments that we need to make to obtain the sub-object; // that the whole expression 'Ex' refers to. This trick is usual,; // in the sense that CodeGen takes a similar route.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:10,Availability,recover,recover,10,// Try to recover some path sensitivity in case we couldn't; // compute the value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:10,Safety,recover,recover,10,// Try to recover some path sensitivity in case we couldn't; // compute the value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:113,Testability,log,logic,113,//===----------------------------------------------------------------------===//; // Top-level transfer function logic (Dispatcher).; //===----------------------------------------------------------------------===//; /// evalAssume - Called by ConstraintManager. Used to call checker-specific; /// logic for handling assumptions on symbolic values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:297,Testability,log,logic,297,//===----------------------------------------------------------------------===//; // Top-level transfer function logic (Dispatcher).; //===----------------------------------------------------------------------===//; /// evalAssume - Called by ConstraintManager. Used to call checker-specific; /// logic for handling assumptions on symbolic values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:77,Performance,load,load,77,// Handle arrays of trivial type. We can represent this with a; // primitive load/copy from the base array region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:192,Modifiability,variab,variables,192,"// FIXME: This should not happen. The language guarantees a presence; // of a valid initializer here, so the reference shall not be undefined.; // It seems that we're calling destructors over variables that; // were not initialized yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:43,Testability,assert,assertions,43,// Still handle this case if we don't have assertions enabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:43,Testability,assert,assertions,43,// Still handle this case if we don't have assertions enabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:65,Safety,avoid,avoid,65,"// FIXME: If we have no MR, we still need to unwrap the array to avoid; // destroying the whole array at once.; //; // For this case there is no universal solution as there is no way to; // directly create an array of temporary objects. There are some expressions; // however which can create temporary objects and have an array type.; //; // E.g.: std::initializer_list<S>{S(), S()};; //; // The expression above has a type of 'const struct S[2]' but it's a single; // 'std::initializer_list<>'. The destructors of the 2 temporary 'S()'; // objects will be called anyway, because they are 2 separate objects in 2; // separate clusters, i.e.: not an array.; //; // Now the 'std::initializer_list<>' is not an array either even though it; // has the type of an array. The point is, we only want to invoke the; // destructor for the initializer list once not twice or so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:40,Usability,simpl,simply,40,// Cases that should never be evaluated simply because they shouldn't; // appear in the CFG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:10,Performance,cache,cache,10,// Did we cache out?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:68,Safety,abort,abort,68,// FIXME: This is not complete. We basically treat @throw as; // an abort.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:130,Performance,cache,cache,130,"// Add the special flag to GDM to signal retrying with no inlining.; // Note, changing the state ensures that we are not going to cache out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:6,Performance,cache,cached,6,"// We cached out at this point. Caching out is common due to us backtracking; // from the inlined function, which might spawn several paths.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:21,Deployability,Update,Update,21,/// Block entrance. (Update counters).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:10,Modifiability,Refactor,Refactor,10,// FIXME: Refactor this into a checker.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:191,Availability,Recover,RecoverCastedSymbol,191,//===----------------------------------------------------------------------===//; // Branch processing.; //===----------------------------------------------------------------------===//; /// RecoverCastedSymbol - A helper function for ProcessBranch that is used; /// to try to recover some path-sensitivity for casts of symbolic; /// integers that promote their values (which are currently not tracked well).; /// This function returns the SVal bound to Condition->IgnoreCasts if all the; // cast(s) did was sign-extend the original value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:277,Availability,recover,recover,277,//===----------------------------------------------------------------------===//; // Branch processing.; //===----------------------------------------------------------------------===//; /// RecoverCastedSymbol - A helper function for ProcessBranch that is used; /// to try to recover some path-sensitivity for casts of symbolic; /// integers that promote their values (which are currently not tracked well).; /// This function returns the SVal bound to Condition->IgnoreCasts if all the; // cast(s) did was sign-extend the original value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:513,Modifiability,extend,extend,513,//===----------------------------------------------------------------------===//; // Branch processing.; //===----------------------------------------------------------------------===//; /// RecoverCastedSymbol - A helper function for ProcessBranch that is used; /// to try to recover some path-sensitivity for casts of symbolic; /// integers that promote their values (which are currently not tracked well).; /// This function returns the SVal bound to Condition->IgnoreCasts if all the; // cast(s) did was sign-extend the original value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:191,Safety,Recover,RecoverCastedSymbol,191,//===----------------------------------------------------------------------===//; // Branch processing.; //===----------------------------------------------------------------------===//; /// RecoverCastedSymbol - A helper function for ProcessBranch that is used; /// to try to recover some path-sensitivity for casts of symbolic; /// integers that promote their values (which are currently not tracked well).; /// This function returns the SVal bound to Condition->IgnoreCasts if all the; // cast(s) did was sign-extend the original value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:277,Safety,recover,recover,277,//===----------------------------------------------------------------------===//; // Branch processing.; //===----------------------------------------------------------------------===//; /// RecoverCastedSymbol - A helper function for ProcessBranch that is used; /// to try to recover some path-sensitivity for casts of symbolic; /// integers that promote their values (which are currently not tracked well).; /// This function returns the SVal bound to Condition->IgnoreCasts if all the; // cast(s) did was sign-extend the original value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:54,Integrability,depend,depends,54,"// Returns the condition the branch at the end of 'B' depends on and whose value; // has been evaluated within 'B'.; // In most cases, the terminator condition of 'B' will be evaluated fully in; // the last statement of 'B'; in those cases, the resolved condition is the; // given 'Condition'.; // If the condition of the branch is a logical binary operator tree, the CFG is; // optimized: in that case, we know that the expression formed by all but the; // rightmost leaf of the logical binary operator tree must be true, and thus; // the branch condition is at this point equivalent to the truth value of that; // rightmost leaf; the CFG block thus only evaluates this rightmost leaf; // expression in its final statement. As the full condition in that case was; // not evaluated, and is thus not in the SVal cache, we need to use that leaf; // expression to evaluate the truth value of the condition in the current state; // space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:379,Performance,optimiz,optimized,379,"// Returns the condition the branch at the end of 'B' depends on and whose value; // has been evaluated within 'B'.; // In most cases, the terminator condition of 'B' will be evaluated fully in; // the last statement of 'B'; in those cases, the resolved condition is the; // given 'Condition'.; // If the condition of the branch is a logical binary operator tree, the CFG is; // optimized: in that case, we know that the expression formed by all but the; // rightmost leaf of the logical binary operator tree must be true, and thus; // the branch condition is at this point equivalent to the truth value of that; // rightmost leaf; the CFG block thus only evaluates this rightmost leaf; // expression in its final statement. As the full condition in that case was; // not evaluated, and is thus not in the SVal cache, we need to use that leaf; // expression to evaluate the truth value of the condition in the current state; // space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:811,Performance,cache,cache,811,"// Returns the condition the branch at the end of 'B' depends on and whose value; // has been evaluated within 'B'.; // In most cases, the terminator condition of 'B' will be evaluated fully in; // the last statement of 'B'; in those cases, the resolved condition is the; // given 'Condition'.; // If the condition of the branch is a logical binary operator tree, the CFG is; // optimized: in that case, we know that the expression formed by all but the; // rightmost leaf of the logical binary operator tree must be true, and thus; // the branch condition is at this point equivalent to the truth value of that; // rightmost leaf; the CFG block thus only evaluates this rightmost leaf; // expression in its final statement. As the full condition in that case was; // not evaluated, and is thus not in the SVal cache, we need to use that leaf; // expression to evaluate the truth value of the condition in the current state; // space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:334,Testability,log,logical,334,"// Returns the condition the branch at the end of 'B' depends on and whose value; // has been evaluated within 'B'.; // In most cases, the terminator condition of 'B' will be evaluated fully in; // the last statement of 'B'; in those cases, the resolved condition is the; // given 'Condition'.; // If the condition of the branch is a logical binary operator tree, the CFG is; // optimized: in that case, we know that the expression formed by all but the; // rightmost leaf of the logical binary operator tree must be true, and thus; // the branch condition is at this point equivalent to the truth value of that; // rightmost leaf; the CFG block thus only evaluates this rightmost leaf; // expression in its final statement. As the full condition in that case was; // not evaluated, and is thus not in the SVal cache, we need to use that leaf; // expression to evaluate the truth value of the condition in the current state; // space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:480,Testability,log,logical,480,"// Returns the condition the branch at the end of 'B' depends on and whose value; // has been evaluated within 'B'.; // In most cases, the terminator condition of 'B' will be evaluated fully in; // the last statement of 'B'; in those cases, the resolved condition is the; // given 'Condition'.; // If the condition of the branch is a logical binary operator tree, the CFG is; // optimized: in that case, we know that the expression formed by all but the; // rightmost leaf of the logical binary operator tree must be true, and thus; // the branch condition is at this point equivalent to the truth value of that; // rightmost leaf; the CFG block thus only evaluates this rightmost leaf; // expression in its final statement. As the full condition in that case was; // not evaluated, and is thus not in the SVal cache, we need to use that leaf; // expression to evaluate the truth value of the condition in the current state; // space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:7,Testability,log,logical,7,"// For logical operations, we still have the case where some branches; // use the traditional ""merge"" approach and others sink the branch; // directly into the basic blocks representing the logical operation.; // We need to distinguish between those two cases here.; // The invariants are still shifting, but it is possible that the; // last element in a CFGBlock is not a CFGStmt. Look for the last; // CFGStmt as the value of the condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:190,Testability,log,logical,190,"// For logical operations, we still have the case where some branches; // use the traditional ""merge"" approach and others sink the branch; // directly into the basic blocks representing the logical operation.; // We need to distinguish between those two cases here.; // The invariants are still shifting, but it is possible that the; // last element in a CFGBlock is not a CFGStmt. Look for the last; // CFGStmt as the value of the condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:23,Availability,recover,recover,23,// Give it a chance to recover from unknown.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:23,Safety,recover,recover,23,// Give it a chance to recover from unknown.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:10,Availability,recover,recover,10,"// Try to recover some path-sensitivity. Right now casts of symbolic; // integers that promote their values are currently not tracked well.; // If 'Condition' is such an expression, try and recover the; // underlying value and use that instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:190,Availability,recover,recover,190,"// Try to recover some path-sensitivity. Right now casts of symbolic; // integers that promote their values are currently not tracked well.; // If 'Condition' is such an expression, try and recover the; // underlying value and use that instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:10,Safety,recover,recover,10,"// Try to recover some path-sensitivity. Right now casts of symbolic; // integers that promote their values are currently not tracked well.; // If 'Condition' is such an expression, try and recover the; // underlying value and use that instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:190,Safety,recover,recover,190,"// Try to recover some path-sensitivity. Right now casts of symbolic; // integers that promote their values are currently not tracked well.; // If 'Condition' is such an expression, try and recover the; // underlying value and use that instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:51,Modifiability,variab,variables,51,/// The GDM component containing the set of global variables which have been; /// previously initialized with explicit initializers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:86,Modifiability,extend,extended,86,"// FIXME: We currently cannot assert that temporaries are clear, because; // lifetime extended temporaries are not always modelled correctly. In some; // cases when we materialize the temporary, we do; // createTemporaryRegionIfNeeded(), and the region changes, and also the; // respective destructor becomes automatic from temporary. So for now clean up; // the state manually before asserting. Ideally, this braced block of code; // should go away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:30,Testability,assert,assert,30,"// FIXME: We currently cannot assert that temporaries are clear, because; // lifetime extended temporaries are not always modelled correctly. In some; // cases when we materialize the temporary, we do; // createTemporaryRegionIfNeeded(), and the region changes, and also the; // respective destructor becomes automatic from temporary. So for now clean up; // the state manually before asserting. Ideally, this braced block of code; // should go away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:385,Testability,assert,asserting,385,"// FIXME: We currently cannot assert that temporaries are clear, because; // lifetime extended temporaries are not always modelled correctly. In some; // cases when we materialize the temporary, we do; // createTemporaryRegionIfNeeded(), and the region changes, and also the; // respective destructor becomes automatic from temporary. So for now clean up; // the state manually before asserting. Ideally, this braced block of code; // should go away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:58,Usability,clear,clear,58,"// FIXME: We currently cannot assert that temporaries are clear, because; // lifetime extended temporaries are not always modelled correctly. In some; // cases when we materialize the temporary, we do; // createTemporaryRegionIfNeeded(), and the region changes, and also the; // respective destructor becomes automatic from temporary. So for now clean up; // the state manually before asserting. Ideally, this braced block of code; // should go away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:3,Performance,Perform,Perform,3,// Perform the transition with cleanups.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:105,Performance,Load,Loads,105,//===----------------------------------------------------------------------===//; // Transfer functions: Loads and stores.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:114,Usability,simpl,simply,114,"// C permits ""extern void v"", and if you cast the address to a valid type,; // you can even do things with it. We simply pretend",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:73,Modifiability,variab,variable,73,// Sema follows a sequence of complex rules to determine whether the; // variable should be captured.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:58,Security,access,accesses,58,/// VisitArraySubscriptExpr - Transfer function for array accesses,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:24,Modifiability,variab,variables,24,// Handle static member variables and enum constants accessed via; // member syntax.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:53,Security,access,accessed,53,// Handle static member variables and enum constants accessed via; // member syntax.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:41,Modifiability,variab,variables,41,// Handle regular struct fields / member variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:126,Integrability,wrap,wrapped,126,"// We special-case rvalues of array type because the analyzer cannot; // reason about them, since we expect all regions to be wrapped in Locs.; // We instead treat these as lvalues and assume that they will decay to; // pointers as soon as they are used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:25,Testability,test,test,25,"// Case (4): in order to test that, generate a new state with the binding; // added. If it is the same state, then it escapes (since the store cannot; // represent the binding).; // Do this only if we know that the store is not supposed to generate the; // same state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:20,Performance,load,load,20,// Proceed with the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:20,Performance,perform,performance,20,// Early checks for performance reason.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:262,Modifiability,Variab,Variable,262,"// Associate this new state with an ExplodedNode.; // FIXME: If I pass null tag, the graph is incorrect, e.g for; // int *p;; // p = 0;; // *p = 0xDEADBEEF;; // ""p = 0"" is not noted as ""Null pointer value stored to 'p'"" but; // instead ""int *p"" is noted as; // ""Variable 'p' initialized to a null pointer value""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:153,Performance,optimiz,optimization,153,// Test if the previous node was as the same expression. This can happen; // when the expression fails to evaluate to anything meaningful and; // (as an optimization) we don't generate a node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:3,Testability,Test,Test,3,// Test if the previous node was as the same expression. This can happen; // when the expression fails to evaluate to anything meaningful and; // (as an optimization) we don't generate a node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:191,Modifiability,plug-in,plug-in,191,"// We have processed both the inputs and the outputs. All of the outputs; // should evaluate to Locs. Nuke all of their values.; // FIXME: Some day in the future it would be nice to allow a ""plug-in""; // which interprets the inline asm and stores proper results in the; // outputs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:64,Testability,log,logical,64,// Process non-assignments except commas or short-circuited; // logical expressions (LAnd and LOr).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:3,Performance,Perform,Perform,3,"// Perform a load (the LHS). This performs the checks for; // null dereferences, and so on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:13,Performance,load,load,13,"// Perform a load (the LHS). This performs the checks for; // null dereferences, and so on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:34,Performance,perform,performs,34,"// Perform a load (the LHS). This performs the checks for; // null dereferences, and so on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:91,Modifiability,variab,variables,91,"// If we created a new MemRegion for the block, we should explicitly bind; // the captured variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:191,Modifiability,variab,variables,191,"// If the capture had a copy expression, use the result of evaluating; // that expression, otherwise use the original value.; // We rely on the invariant that the block declaration's capture variables; // are a prefix of the BlockDataRegion's referenced vars (which may include; // referenced globals, etc.) to enable fast lookup of the capture for a; // given referenced var.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:94,Deployability,release,release,94,"// The analyzer doesn't do anything special with these casts,; // since it understands retain/release semantics already.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:57,Modifiability,variab,variable,57,"// C99 6.7.7 ""Any array size expressions associated with variable length; // array declarators are evaluated each time the declaration of the typedef; // name is reached in the order of execution.""; // The checkers should know about typedef to be able to handle VLA size; // expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:43,Modifiability,refactor,refactoring,43,//TODO:AZ: remove explicit insertion after refactoring is done.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:45,Modifiability,variab,variable,45,// We constructed the object directly in the variable.; // No need to bind anything.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:3,Availability,Recover,Recover,3,// Recover some path-sensitivity if a scalar value evaluated to; // UnknownVal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:3,Safety,Recover,Recover,3,// Recover some path-sensitivity if a scalar value evaluated to; // UnknownVal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:822,Availability,reliab,reliable,822,"// This method acts upon CFG elements for logical operators && and ||; // and attaches the value (true or false) to them as expressions.; // It doesn't produce any state splits.; // If we made it that far, we're past the point when we modeled the short; // circuit. It means that we should have precise knowledge about whether; // we've short-circuited. If we did, we already know the value we need to; // bind. If we didn't, the value of the RHS (casted to the boolean type); // is the answer.; // Currently this method tries to figure out whether we've short-circuited; // by looking at the ExplodedGraph. This method is imperfect because there; // could inevitably have been merges that would have resulted in multiple; // potential path traversal histories. We bail out when we fail.; // Due to this ambiguity, a more reliable solution would have been to; // track the short circuit operation history path-sensitively until; // we evaluate the respective logical operator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:42,Testability,log,logical,42,"// This method acts upon CFG elements for logical operators && and ||; // and attaches the value (true or false) to them as expressions.; // It doesn't produce any state splits.; // If we made it that far, we're past the point when we modeled the short; // circuit. It means that we should have precise knowledge about whether; // we've short-circuited. If we did, we already know the value we need to; // bind. If we didn't, the value of the RHS (casted to the boolean type); // is the answer.; // Currently this method tries to figure out whether we've short-circuited; // by looking at the ExplodedGraph. This method is imperfect because there; // could inevitably have been merges that would have resulted in multiple; // potential path traversal histories. We bail out when we fail.; // Due to this ambiguity, a more reliable solution would have been to; // track the short circuit operation history path-sensitively until; // we evaluate the respective logical operator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:959,Testability,log,logical,959,"// This method acts upon CFG elements for logical operators && and ||; // and attaches the value (true or false) to them as expressions.; // It doesn't produce any state splits.; // If we made it that far, we're past the point when we modeled the short; // circuit. It means that we should have precise knowledge about whether; // we've short-circuited. If we did, we already know the value we need to; // bind. If we didn't, the value of the RHS (casted to the boolean type); // is the answer.; // Currently this method tries to figure out whether we've short-circuited; // by looking at the ExplodedGraph. This method is imperfect because there; // could inevitably have been merges that would have resulted in multiple; // potential path traversal histories. We bail out when we fail.; // Due to this ambiguity, a more reliable solution would have been to; // track the short circuit operation history path-sensitively until; // we evaluate the respective logical operator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:151,Testability,log,logical,151,"// FIXME: We do not model vector arithmetic yet. When adding support for; // that, note that the CFG-based reasoning below does not apply, because; // logical operators on vectors are not short-circuit. Currently they are; // modeled as short-circuit in Clang CFG but this is incorrect.; // Do not set the value for the expression. It'd be UnknownVal by default.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:63,Testability,log,logical,63,// The only terminator (if there is one) that makes sense is a logical op.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:251,Availability,robust,robust,251,"// If the state N has multiple predecessors P, it means that successors; // of P are all equivalent.; // In turn, that means that all nodes at P are equivalent in terms; // of observable behavior at N, and we can follow any of them.; // FIXME: a more robust solution which does not walk up the tree.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:108,Modifiability,refactor,refactor,108,"// FIXME: Add support for VLA type arguments and VLA expressions.; // When that happens, we should probably refactor VLASizeChecker's code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:3,Performance,Perform,Perform,3,// Perform a load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:13,Performance,load,load,13,// Perform a load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:3,Performance,Perform,Perform,3,"// Perform the store, so that the uninitialized value detection happens.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:54,Safety,detect,detection,54,"// Perform the store, so that the uninitialized value detection happens.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:40,Availability,recover,recover,40,// Conjure a new symbol if necessary to recover precision.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:40,Safety,recover,recover,40,// Conjure a new symbol if necessary to recover precision.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:3,Performance,Perform,Perform,3,// Perform the store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:3,Security,Validat,Validate,3,// Validate the CFG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:2,Safety,Detect,DetectVirtual,2,/*DetectVirtual=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:155,Safety,safe,safe,155,"// Unfortunately, Objective-C does not enforce that overridden methods have; // covariant return types, so we can't assert that that never happens.; // Be safe and return UnknownVal().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:116,Testability,assert,assert,116,"// Unfortunately, Objective-C does not enforce that overridden methods have; // covariant return types, so we can't assert that that never happens.; // Be safe and return UnknownVal().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:88,Modifiability,variab,variable,88,"// Step 2: generate node with bound return value: CEBNode -> BindedRetNode.; // If this variable is set to 'true' the analyzer will evaluate the call; // statement we are about to exit again, instead of continuing the execution; // from the statement after the call. This is useful for non-POD type array; // construction where the CXXConstructExpr is referenced only once in the CFG,; // but we want to evaluate it as many times as many elements the array has.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:11,Performance,Perform,Perform,11,// Step 5: Perform the post-condition check of the CallExpr and enqueue the; // result onto the work list.; // CEENode -> Dst -> WorkList,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:3,Performance,Perform,Perform,3,// Perform the previsit of the CallExpr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:67,Performance,perform,perform,67,// Get the call in its initial state. We use this as a template to perform; // all the checks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:12,Performance,perform,perform,12,"// Finally, perform the post-condition check of the CallExpr and store; // the created nodes in 'Dst'.; // Note that if the call was inlined, dstCallEvaluated will be empty.; // The post-CallExpr check will occur in processCallExit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:164,Deployability,update,updated,164,"// WARNING: At this time, the state attached to 'Call' may be older than the; // state in 'Pred'. This is a minor optimization since CheckerManager will; // use an updated CallEvent instance when calling checkers, but if 'Call' is; // ever used directly in this function all callers should be updated to pass; // the most recent state. (It is probably not worth doing the work here since; // for some callers this will not be necessary.); // Run any pre-call checks using the generic call interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:293,Deployability,update,updated,293,"// WARNING: At this time, the state attached to 'Call' may be older than the; // state in 'Pred'. This is a minor optimization since CheckerManager will; // use an updated CallEvent instance when calling checkers, but if 'Call' is; // ever used directly in this function all callers should be updated to pass; // the most recent state. (It is probably not worth doing the work here since; // for some callers this will not be necessary.); // Run any pre-call checks using the generic call interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:489,Integrability,interface,interface,489,"// WARNING: At this time, the state attached to 'Call' may be older than the; // state in 'Pred'. This is a minor optimization since CheckerManager will; // use an updated CallEvent instance when calling checkers, but if 'Call' is; // ever used directly in this function all callers should be updated to pass; // the most recent state. (It is probably not worth doing the work here since; // for some callers this will not be necessary.); // Run any pre-call checks using the generic call interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:114,Performance,optimiz,optimization,114,"// WARNING: At this time, the state attached to 'Call' may be older than the; // state in 'Pred'. This is a minor optimization since CheckerManager will; // use an updated CallEvent instance when calling checkers, but if 'Call' is; // ever used directly in this function all callers should be updated to pass; // the most recent state. (It is probably not worth doing the work here since; // for some callers this will not be necessary.); // Run any pre-call checks using the generic call interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:27,Energy Efficiency,allocate,allocated,27,// Store the extent of the allocated object(s).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:45,Safety,safe,safe,45,"// If the destructor is trivial, it's always safe to inline the constructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:116,Usability,simpl,simply,116,"// If we did not find the correct this-region, it would be pointless; // to inline the constructor. Instead we will simply invalidate; // the fake temporary target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:32,Modifiability,extend,extended,32,"// If the temporary is lifetime-extended by binding it to a reference-type; // field within an aggregate, automatic destructors don't work properly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:94,Modifiability,inherit,inherited,94,"// This doesn't really increase the cost of inlining ever, because; // the stack frame of the inherited constructor is trivial.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:115,Usability,simpl,simply,115,"// If we did not find the correct this-region, it would be pointless; // to inline the destructor. Instead we will simply invalidate; // the fake temporary target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:61,Safety,safe,safe,61,"// It is possible that the CFG cannot be constructed.; // Be safe, and check if the CalleeCFG is valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:32,Modifiability,variab,variables,32,"// It is possible that the live variables analysis cannot be; // run. If so, bail out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:184,Performance,cache,cached,184,"// Check if we should inline a call based on its kind.; // FIXME: this checks both static and dynamic properties of the call, which; // means we're redoing a bit of work that could be cached in the function; // summary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:124,Integrability,depend,depends,124,"// This might seem conter-intuitive at first glance, but the functions are; // closely related. Reasoning about destructors depends only on the type; // of the expression that initialized the memory region, which is the; // CXXConstructExpr. So to avoid code repetition, the work is delegated; // to the function that reasons about destructor inlining. Also note that; // if the constructors of the array elements are inlined, the destructors; // can also be inlined and if the destructors can be inline, it's safe to; // inline the constructors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:248,Safety,avoid,avoid,248,"// This might seem conter-intuitive at first glance, but the functions are; // closely related. Reasoning about destructors depends only on the type; // of the expression that initialized the memory region, which is the; // CXXConstructExpr. So to avoid code repetition, the work is delegated; // to the function that reasons about destructor inlining. Also note that; // if the constructors of the array elements are inlined, the destructors; // can also be inlined and if the destructors can be inline, it's safe to; // inline the constructors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:510,Safety,safe,safe,510,"// This might seem conter-intuitive at first glance, but the functions are; // closely related. Reasoning about destructors depends only on the type; // of the expression that initialized the memory region, which is the; // CXXConstructExpr. So to avoid code repetition, the work is delegated; // to the function that reasons about destructor inlining. Also note that; // if the constructors of the array elements are inlined, the destructors; // can also be inlined and if the destructors can be inline, it's safe to; // inline the constructors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:26,Usability,intuit,intuitive,26,"// This might seem conter-intuitive at first glance, but the functions are; // closely related. Reasoning about destructors depends only on the type; // of the expression that initialized the memory region, which is the; // CXXConstructExpr. So to avoid code repetition, the work is delegated; // to the function that reasons about destructor inlining. Also note that; // if the constructors of the array elements are inlined, the destructors; // can also be inlined and if the destructors can be inline, it's safe to; // inline the constructors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:119,Safety,safe,safe,119,// Try to inline the call.; // The origin expression here is just used as a kind of checksum;; // this should still be safe even for CallEvents that don't come from exprs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:84,Security,checksum,checksum,84,// Try to inline the call.; // The origin expression here is just used as a kind of checksum;; // this should still be safe even for CallEvents that don't come from exprs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:18,Performance,perform,performed,18,"// Check if we've performed the split already - note, we only want; // to split the path once per memory region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:55,Integrability,message,message,55,"// If we got here, this is the first time we process a message to this; // region, so split the path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:3,Performance,Load,Load,3,// Load the source value only for non-empty classes.; // Otherwise it'd retrieve an UnknownVal; // and bind it and RegionStore would think that the actual value; // in this region at this offset is unknown.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:45,Performance,load,load,45,"// If the value being copied is not unknown, load from its location to get; // an aggregate rvalue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:78,Usability,Simpl,SimpleReturnedValueKind,78,"// In case when the prvalue is returned from the function (kind is one of; // SimpleReturnedValueKind, CXX17ElidedCopyReturnedValueKind), then; // it's materialization happens in context of the caller.; // We pass BldrCtx explicitly, as currBldrCtx always refers to callee's context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:9,Safety,Detect,Detect,9,// TODO: Detect when the allocator returns a null pointer.; // Constructor shall not be called in this case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:374,Safety,avoid,avoid,374,"// We are on the top frame of the analysis. We do not know where is the; // object returned to. Conjure a symbolic region for the return value.; // TODO: We probably need a new MemRegion kind to represent the storage; // of that SymbolicRegion, so that we cound produce a fancy symbol; // instead of an anonymous conjured symbol.; // TODO: Do we need to track the region to avoid having it dead; // too early? It does die too early, at least in C++17, but because; // putting anything into a SymbolicRegion causes an immediate escape,; // it doesn't cause any leak false positives.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:75,Usability,simpl,simple,75,// Copy elision failed. Revert the changes and proceed as if we have; // a simple temporary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:18,Modifiability,extend,extended,18,// We're lifetime-extended by a surrounding aggregate.; // Automatic destructors aren't quite working in this case; // on the CFG side. We should warn the caller about that.; // FIXME: Is there a better way to retrieve this information from; // the MaterializeTemporaryExpr?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:36,Availability,reliab,reliably,36,// Return early if we are unable to reliably foresee; // the future stack frame.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:129,Availability,failure,failure,129,"// If we couldn't find an existing region to construct into, assume we're; // constructing a temporary. Notify the caller of our failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:72,Usability,simpl,simple,72,"// If we decided not to elide the constructor, proceed as if; // it's a simple temporary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:94,Availability,error,error,94,"// The ctor in this case is guaranteed to be a copy ctor, otherwise we hit a; // compile time error.; //; // -ArrayInitLoopExpr <-- we're here; // |-OpaqueValueExpr; // | `-DeclRefExpr <-- match this; // `-CXXConstructExpr; // `-ImplicitCastExpr; // `-ArraySubscriptExpr; // |-ImplicitCastExpr; // | `-OpaqueValueExpr; // | `-DeclRefExpr; // `-ArrayInitIndexExpr; //; // The resulting expression might look like the one below in an implicit; // copy/move ctor.; //; // ArrayInitLoopExpr <-- we're here; // |-OpaqueValueExpr; // | `-MemberExpr <-- match this; // | (`-CXXStaticCastExpr) <-- move ctor only; // | `-DeclRefExpr; // `-CXXConstructExpr; // `-ArraySubscriptExpr; // |-ImplicitCastExpr; // | `-OpaqueValueExpr; // | `-MemberExpr; // | `-DeclRefExpr; // `-ArrayInitIndexExpr; //; // The resulting expression for a multidimensional array.; // ArrayInitLoopExpr <-- we're here; // |-OpaqueValueExpr; // | `-DeclRefExpr <-- match this; // `-ArrayInitLoopExpr; // |-OpaqueValueExpr; // | `-ArraySubscriptExpr; // | |-ImplicitCastExpr; // | | `-OpaqueValueExpr; // | | `-DeclRefExpr; // | `-ArrayInitIndexExpr; // `-CXXConstructExpr <-- extract this; // ` ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:3,Modifiability,Inherit,Inherited,3,// Inherited constructors are always base class constructors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:659,Availability,down,down,659,"// In C++17, classes with non-virtual bases may be aggregates, so they would; // be initialized as aggregates without a constructor call, so we may have; // a base class constructed directly into an initializer list without; // having the derived-class constructor call on the previous stack frame.; // Initializer lists may be nested into more initializer lists that; // correspond to surrounding aggregate initializations.; // FIXME: For now this code essentially bails out. We need to find the; // correct target region and set it.; // FIXME: Instead of relying on the ParentMap, we should have the; // trigger-statement (InitListExpr in this case) passed down from CFG or; // otherwise always available during construction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:697,Availability,avail,available,697,"// In C++17, classes with non-virtual bases may be aggregates, so they would; // be initialized as aggregates without a constructor call, so we may have; // a base class constructed directly into an initializer list without; // having the derived-class constructor call on the previous stack frame.; // Initializer lists may be nested into more initializer lists that; // correspond to surrounding aggregate initializations.; // FIXME: For now this code essentially bails out. We need to find the; // correct target region and set it.; // FIXME: Instead of relying on the ParentMap, we should have the; // trigger-statement (InitListExpr in this case) passed down from CFG or; // otherwise always available during construction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:378,Modifiability,extend,extended,378,"// If the CFG was constructed without elements for temporary destructors; // and the just-called constructor created a temporary object then; // stop exploration if the temporary object has a noreturn constructor.; // This can lose coverage because the destructor, if it were present; // in the CFG, would be called at the end of the full expression or; // later (for life-time extended temporaries) -- but avoids infeasible; // paths when no-return temporary destructors are used for assertions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:407,Safety,avoid,avoids,407,"// If the CFG was constructed without elements for temporary destructors; // and the just-called constructor created a temporary object then; // stop exploration if the temporary object has a noreturn constructor.; // This can lose coverage because the destructor, if it were present; // in the CFG, would be called at the end of the full expression or; // later (for life-time extended temporaries) -- but avoids infeasible; // paths when no-return temporary destructors are used for assertions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:485,Testability,assert,assertions,485,"// If the CFG was constructed without elements for temporary destructors; // and the just-called constructor created a temporary object then; // stop exploration if the temporary object has a noreturn constructor.; // This can lose coverage because the destructor, if it were present; // in the CFG, would be called at the end of the full expression or; // later (for life-time extended temporaries) -- but avoids infeasible; // paths when no-return temporary destructors are used for assertions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:320,Modifiability,config,config,320,"// If we've inlined the constructor, then DstEvaluated would be empty.; // In this case we still want a sink, which could be implemented; // in processCallExit. But we don't have that implemented at the moment,; // so if you hit this assertion, see if you can avoid inlining; // the respective constructor when analyzer-config cfg-temporary-dtors; // is set to false.; // Otherwise there's nothing wrong with inlining such constructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:260,Safety,avoid,avoid,260,"// If we've inlined the constructor, then DstEvaluated would be empty.; // In this case we still want a sink, which could be implemented; // in processCallExit. But we don't have that implemented at the moment,; // so if you hit this assertion, see if you can avoid inlining; // the respective constructor when analyzer-config cfg-temporary-dtors; // is set to false.; // Otherwise there's nothing wrong with inlining such constructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:234,Testability,assert,assertion,234,"// If we've inlined the constructor, then DstEvaluated would be empty.; // In this case we still want a sink, which could be implemented; // in processCallExit. But we don't have that implemented at the moment,; // so if you hit this assertion, see if you can avoid inlining; // the respective constructor when analyzer-config cfg-temporary-dtors; // is set to false.; // Otherwise there's nothing wrong with inlining such constructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:42,Usability,simpl,simply,42,// Skip the invalid destructor. We cannot simply return because; // it would interrupt the analysis instead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:219,Availability,recover,recover,219,"// We're trying to destroy something that is not a region. This may happen; // for a variety of reasons (unknown target region, concrete integer instead; // of target region, etc.). The current code makes an attempt to recover.; // FIXME: We probably don't really need to recover when we're dealing; // with concrete integers specifically.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:272,Availability,recover,recover,272,"// We're trying to destroy something that is not a region. This may happen; // for a variety of reasons (unknown target region, concrete integer instead; // of target region, etc.). The current code makes an attempt to recover.; // FIXME: We probably don't really need to recover when we're dealing; // with concrete integers specifically.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:219,Safety,recover,recover,219,"// We're trying to destroy something that is not a region. This may happen; // for a variety of reasons (unknown target region, concrete integer instead; // of target region, etc.). The current code makes an attempt to recover.; // FIXME: We probably don't really need to recover when we're dealing; // with concrete integers specifically.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:272,Safety,recover,recover,272,"// We're trying to destroy something that is not a region. This may happen; // for a variety of reasons (unknown target region, concrete integer instead; // of target region, etc.). The current code makes an attempt to recover.; // FIXME: We probably don't really need to recover when we're dealing; // with concrete integers specifically.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:144,Energy Efficiency,allocate,allocated,144,"// [basic.stc.dynamic.allocation] (on the return value of an allocation; // function):; // ""The order, contiguity, and initial value of storage allocated by; // successive calls to an allocation function are unspecified.""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:64,Availability,failure,failures,64,"// If this allocation function is not declared as non-throwing, failures; // /must/ be signalled by exceptions, and thus the return value will never; // be NULL. -fno-exceptions does not influence this semantics.; // FIXME: GCC has a -fcheck-new option, which forces it to consider the case; // where new can return NULL. If we end up supporting that option, we can; // consider adding a check for it here.; // C++11 [basic.stc.dynamic.allocation]p3.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:58,Energy Efficiency,allocate,allocate,58,// We assume all standard global 'operator new' functions allocate memory in; // heap. We realize this is an approximation that might not correctly model; // a custom global allocator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:64,Availability,failure,failures,64,"// If this allocation function is not declared as non-throwing, failures; // /must/ be signalled by exceptions, and thus the return value will never; // be NULL. -fno-exceptions does not influence this semantics.; // FIXME: GCC has a -fcheck-new option, which forces it to consider the case; // where new can return NULL. If we end up supporting that option, we can; // consider adding a check for it here.; // C++11 [basic.stc.dynamic.allocation]p3.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:59,Performance,cache,cached,59,"// Bind the address of the object, then check to see if we cached out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:207,Safety,detect,detecting,207,"// Capturing a 0 length array is a no-op, so we ignore it to get a more; // accurate analysis. If it's not ignored, it would set the default; // binding of the lambda to 'Unknown', which can lead to falsely detecting; // 'Uninitialized' values as 'Unknown' and not reporting a warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:106,Usability,simpl,simple,106,"// With C++17 copy elision the InitExpr can be anything, so instead of; // pattern matching all cases, we simple check if the current field is; // under construction or not, regardless what it's InitExpr is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:45,Modifiability,variab,variable-length,45,// The field stores the length of a captured variable-length array.; // These captures don't have initialization expressions; instead we; // get the length from the VLAType size expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp:3,Performance,Perform,Perform,3,// Perform the post-condition check of the ObjCIvarRefExpr and store; // the created nodes in 'Dst'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp:108,Testability,log,logic,108,"// FIXME: The proper thing to do is to really iterate over the; // container. We will do this with dispatch logic to the store.; // For now, just 'conjure' up a symbolic value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp:984,Integrability,depend,depending,984,"// ObjCForCollectionStmts are processed in two places. This method; // handles the case where an ObjCForCollectionStmt* occurs as one of the; // statements within a basic block. This transfer function does two things:; //; // (1) binds the next container value to 'element'. This creates a new; // node in the ExplodedGraph.; //; // (2) note whether the collection has any more elements (or in other words,; // whether the loop has more iterations). This will be tested in; // processBranch.; //; // FIXME: Eventually this logic should actually do dispatches to; // 'countByEnumeratingWithState:objects:count:' (NSFastEnumeration).; // This will require simulating a temporary NSFastEnumerationState, either; // through an SVal or through the use of MemRegions. This value can; // be affixed to the ObjCForCollectionStmt* instead of 0/1; when the loop; // terminates we reclaim the temporary (it goes out of scope) and we; // we can test if the SVal is 0 or if the MemRegion is null (depending; // on what approach we take).; //; // For now: simulate (1) by assigning either a symbol or nil if the; // container is empty. Thus this transfer function will by default; // result in state splitting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp:463,Testability,test,tested,463,"// ObjCForCollectionStmts are processed in two places. This method; // handles the case where an ObjCForCollectionStmt* occurs as one of the; // statements within a basic block. This transfer function does two things:; //; // (1) binds the next container value to 'element'. This creates a new; // node in the ExplodedGraph.; //; // (2) note whether the collection has any more elements (or in other words,; // whether the loop has more iterations). This will be tested in; // processBranch.; //; // FIXME: Eventually this logic should actually do dispatches to; // 'countByEnumeratingWithState:objects:count:' (NSFastEnumeration).; // This will require simulating a temporary NSFastEnumerationState, either; // through an SVal or through the use of MemRegions. This value can; // be affixed to the ObjCForCollectionStmt* instead of 0/1; when the loop; // terminates we reclaim the temporary (it goes out of scope) and we; // we can test if the SVal is 0 or if the MemRegion is null (depending; // on what approach we take).; //; // For now: simulate (1) by assigning either a symbol or nil if the; // container is empty. Thus this transfer function will by default; // result in state splitting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp:523,Testability,log,logic,523,"// ObjCForCollectionStmts are processed in two places. This method; // handles the case where an ObjCForCollectionStmt* occurs as one of the; // statements within a basic block. This transfer function does two things:; //; // (1) binds the next container value to 'element'. This creates a new; // node in the ExplodedGraph.; //; // (2) note whether the collection has any more elements (or in other words,; // whether the loop has more iterations). This will be tested in; // processBranch.; //; // FIXME: Eventually this logic should actually do dispatches to; // 'countByEnumeratingWithState:objects:count:' (NSFastEnumeration).; // This will require simulating a temporary NSFastEnumerationState, either; // through an SVal or through the use of MemRegions. This value can; // be affixed to the ObjCForCollectionStmt* instead of 0/1; when the loop; // terminates we reclaim the temporary (it goes out of scope) and we; // we can test if the SVal is 0 or if the MemRegion is null (depending; // on what approach we take).; //; // For now: simulate (1) by assigning either a symbol or nil if the; // container is empty. Thus this transfer function will by default; // result in state splitting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp:933,Testability,test,test,933,"// ObjCForCollectionStmts are processed in two places. This method; // handles the case where an ObjCForCollectionStmt* occurs as one of the; // statements within a basic block. This transfer function does two things:; //; // (1) binds the next container value to 'element'. This creates a new; // node in the ExplodedGraph.; //; // (2) note whether the collection has any more elements (or in other words,; // whether the loop has more iterations). This will be tested in; // processBranch.; //; // FIXME: Eventually this logic should actually do dispatches to; // 'countByEnumeratingWithState:objects:count:' (NSFastEnumeration).; // This will require simulating a temporary NSFastEnumerationState, either; // through an SVal or through the use of MemRegions. This value can; // be affixed to the ObjCForCollectionStmt* instead of 0/1; when the loop; // terminates we reclaim the temporary (it goes out of scope) and we; // we can test if the SVal is 0 or if the MemRegion is null (depending; // on what approach we take).; //; // For now: simulate (1) by assigning either a symbol or nil if the; // container is empty. Thus this transfer function will by default; // result in state splitting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp:1209,Integrability,message,message,1209,"// There are three cases for the receiver:; // (1) it is definitely nil,; // (2) it is definitely non-nil, and; // (3) we don't know.; //; // If the receiver is definitely nil, we skip the pre/post callbacks and; // instead call the ObjCMessageNil callbacks and return.; //; // If the receiver is definitely non-nil, we call the pre- callbacks,; // evaluate the call, and call the post- callbacks.; //; // If we don't know, we drop the potential nil flow and instead; // continue from the assumed non-nil state as in (2). This approach; // intentionally drops coverage in order to prevent false alarms; // in the following scenario:; //; // id result = [o someMethod]; // if (result) {; // if (!o) {; // // <-- This program point should be unreachable because if o is nil; // // it must the case that result is nil as well.; // }; // }; //; // However, it also loses coverage of the nil path prematurely,; // leading to missed reports.; //; // It's possible to handle this by performing a state split on every call:; // explore the state where the receiver is non-nil, and independently; // explore the state where it's nil. But this is not only slow, but; // completely unwarranted. The mere presence of the message syntax in the code; // isn't sufficient evidence that nil is a realistic possibility.; //; // An ideal solution would be to add the following constraint that captures; // both possibilities without splitting the state:; //; // ($x == 0) => ($y == 0) (1); //; // where in our case '$x' is the receiver symbol, '$y' is the returned symbol,; // and '=>' is logical implication. But RangeConstraintManager can't handle; // such constraints yet, so for now we go with a simpler, more restrictive; // constraint: $x != 0, from which (1) follows as a vacuous truth.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp:976,Performance,perform,performing,976,"// There are three cases for the receiver:; // (1) it is definitely nil,; // (2) it is definitely non-nil, and; // (3) we don't know.; //; // If the receiver is definitely nil, we skip the pre/post callbacks and; // instead call the ObjCMessageNil callbacks and return.; //; // If the receiver is definitely non-nil, we call the pre- callbacks,; // evaluate the call, and call the post- callbacks.; //; // If we don't know, we drop the potential nil flow and instead; // continue from the assumed non-nil state as in (2). This approach; // intentionally drops coverage in order to prevent false alarms; // in the following scenario:; //; // id result = [o someMethod]; // if (result) {; // if (!o) {; // // <-- This program point should be unreachable because if o is nil; // // it must the case that result is nil as well.; // }; // }; //; // However, it also loses coverage of the nil path prematurely,; // leading to missed reports.; //; // It's possible to handle this by performing a state split on every call:; // explore the state where the receiver is non-nil, and independently; // explore the state where it's nil. But this is not only slow, but; // completely unwarranted. The mere presence of the message syntax in the code; // isn't sufficient evidence that nil is a realistic possibility.; //; // An ideal solution would be to add the following constraint that captures; // both possibilities without splitting the state:; //; // ($x == 0) => ($y == 0) (1); //; // where in our case '$x' is the receiver symbol, '$y' is the returned symbol,; // and '=>' is logical implication. But RangeConstraintManager can't handle; // such constraints yet, so for now we go with a simpler, more restrictive; // constraint: $x != 0, from which (1) follows as a vacuous truth.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp:1571,Testability,log,logical,1571,"// There are three cases for the receiver:; // (1) it is definitely nil,; // (2) it is definitely non-nil, and; // (3) we don't know.; //; // If the receiver is definitely nil, we skip the pre/post callbacks and; // instead call the ObjCMessageNil callbacks and return.; //; // If the receiver is definitely non-nil, we call the pre- callbacks,; // evaluate the call, and call the post- callbacks.; //; // If we don't know, we drop the potential nil flow and instead; // continue from the assumed non-nil state as in (2). This approach; // intentionally drops coverage in order to prevent false alarms; // in the following scenario:; //; // id result = [o someMethod]; // if (result) {; // if (!o) {; // // <-- This program point should be unreachable because if o is nil; // // it must the case that result is nil as well.; // }; // }; //; // However, it also loses coverage of the nil path prematurely,; // leading to missed reports.; //; // It's possible to handle this by performing a state split on every call:; // explore the state where the receiver is non-nil, and independently; // explore the state where it's nil. But this is not only slow, but; // completely unwarranted. The mere presence of the message syntax in the code; // isn't sufficient evidence that nil is a realistic possibility.; //; // An ideal solution would be to add the following constraint that captures; // both possibilities without splitting the state:; //; // ($x == 0) => ($y == 0) (1); //; // where in our case '$x' is the receiver symbol, '$y' is the returned symbol,; // and '=>' is logical implication. But RangeConstraintManager can't handle; // such constraints yet, so for now we go with a simpler, more restrictive; // constraint: $x != 0, from which (1) follows as a vacuous truth.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp:1682,Usability,simpl,simpler,1682,"// There are three cases for the receiver:; // (1) it is definitely nil,; // (2) it is definitely non-nil, and; // (3) we don't know.; //; // If the receiver is definitely nil, we skip the pre/post callbacks and; // instead call the ObjCMessageNil callbacks and return.; //; // If the receiver is definitely non-nil, we call the pre- callbacks,; // evaluate the call, and call the post- callbacks.; //; // If we don't know, we drop the potential nil flow and instead; // continue from the assumed non-nil state as in (2). This approach; // intentionally drops coverage in order to prevent false alarms; // in the following scenario:; //; // id result = [o someMethod]; // if (result) {; // if (!o) {; // // <-- This program point should be unreachable because if o is nil; // // it must the case that result is nil as well.; // }; // }; //; // However, it also loses coverage of the nil path prematurely,; // leading to missed reports.; //; // It's possible to handle this by performing a state split on every call:; // explore the state where the receiver is non-nil, and independently; // explore the state where it's nil. But this is not only slow, but; // completely unwarranted. The mere presence of the message syntax in the code; // isn't sufficient evidence that nil is a realistic possibility.; //; // An ideal solution would be to add the following constraint that captures; // both possibilities without splitting the state:; //; // ($x == 0) => ($y == 0) (1); //; // where in our case '$x' is the receiver symbol, '$y' is the returned symbol,; // and '=>' is logical implication. But RangeConstraintManager can't handle; // such constraints yet, so for now we go with a simpler, more restrictive; // constraint: $x != 0, from which (1) follows as a vacuous truth.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp:29,Integrability,message,message,29,// Proceed with evaluate the message expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp:12,Performance,perform,perform,12,"// Finally, perform the post-condition check of the ObjCMessageExpr and store; // the created nodes in 'Dst'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite the file specified by FID with HTML formatting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:335,Modifiability,config,config-compatibility-mode,335,"// FIXME: HTML is currently our default output type, but if the output; // directory isn't specified, it acts like if it was in the minimal text; // output mode. This doesn't make much sense, we should have the minimal text; // as our default. In the case of backward compatibility concerns, this could; // be preserved with -analyzer-config-compatibility-mode=true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:17,Availability,error,error,17,// TODO: Emit an error here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:17,Availability,error,error,17,// TODO: Emit an error here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:16,Modifiability,rewrite,rewriter,16,// Create a new rewriter to generate HTML.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:142,Modifiability,rewrite,rewrites,142,// FIXME: This causes each file to be re-parsed and syntax-highlighted; // and macro-expanded separately for each report. We could cache such rewrites; // across all reports and only re-do the part that's actually different:; // the warning/note bubbles.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:131,Performance,cache,cache,131,// FIXME: This causes each file to be re-parsed and syntax-highlighted; // and macro-expanded separately for each report. We could cache such rewrites; // across all reports and only re-do the part that's actually different:; // the warning/note bubbles.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:65,Security,hash,hash,65,// FIXME: This code relies on knowing what constitutes the issue hash.; // Otherwise deduplication won't work correctly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:136,Security,hash,hash,136,"// Existence of the file corresponds to the situation where a different; // Clang instance has emitted a bug report with the same issue hash.; // This is an entirely normal situation that does not deserve a warning,; // as apart from hash collisions this can happen because the reports; // are in fact similar enough to be considered duplicates of each other.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:234,Security,hash,hash,234,"// Existence of the file corresponds to the situation where a different; // Clang instance has emitted a bug report with the same issue hash.; // This is an entirely normal situation that does not deserve a warning,; // as apart from hash collisions this can happen because the reports; // are in fact similar enough to be considered duplicates of each other.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite source files as HTML for every new file the path crosses,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:109,Deployability,toggle,toggleHelp,109,"R""<<<(; </table>; <!-- REPORTSUMMARYEXTRA -->; <h3>Annotated Source Code</h3>; <p>Press <a href=""#"" onclick=""toggleHelp(); return false;"">'?'</a>; to see keyboard shortcuts</p>; <input type=""checkbox"" class=""spoilerhider"" id=""showinvocation"" />; <label for=""showinvocation"" >Show analyzer invocation</label>; <div class=""spoiler"">clang -cc1 )<<<""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:205,Deployability,toggle,toggle,205,"R""<<<(; </div>; <div id='tooltiphint' hidden=""true"">; <p>Keyboard shortcuts: </p>; <ul>; <li>Use 'j/k' keys for keyboard navigation</li>; <li>Use 'Shift+S' to show/hide relevant lines</li>; <li>Use '?' to toggle this window</li>; </ul>; <a href=""#"" onclick=""toggleHelp(); return false;"">Close</a>; </div>; )<<<""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:258,Deployability,toggle,toggleHelp,258,"R""<<<(; </div>; <div id='tooltiphint' hidden=""true"">; <p>Keyboard shortcuts: </p>; <ul>; <li>Use 'j/k' keys for keyboard navigation</li>; <li>Use 'Shift+S' to show/hide relevant lines</li>; <li>Use '?' to toggle this window</li>; </ul>; <a href=""#"" onclick=""toggleHelp(); return false;"">Close</a>; </div>; )<<<""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:45,Deployability,toggle,toggleHelp,45,"R""<<<(; <script type='text/javascript'>. var toggleHelp = function() {; var hint = document.querySelector(""#tooltiphint"");; var attributeName = ""hidden"";; if (hint.hasAttribute(attributeName)) {; hint.removeAttribute(attributeName);; } else {; hint.setAttribute(""hidden"", ""true"");; }; };; window.addEventListener(""keydown"", function (event) {; if (event.defaultPrevented) {; return;; }; if (event.key == ""?"") {; toggleHelp();; } else {; return;; }; event.preventDefault();; });; </script>; )<<<""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:412,Deployability,toggle,toggleHelp,412,"R""<<<(; <script type='text/javascript'>. var toggleHelp = function() {; var hint = document.querySelector(""#tooltiphint"");; var attributeName = ""hidden"";; if (hint.hasAttribute(attributeName)) {; hint.removeAttribute(attributeName);; } else {; hint.setAttribute(""hidden"", ""true"");; }; };; window.addEventListener(""keydown"", function (event) {; if (event.defaultPrevented) {; return;; }; if (event.key == ""?"") {; toggleHelp();; } else {; return;; }; event.preventDefault();; });; </script>; )<<<""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:57,Integrability,message,message,57,// Write out the path indices with a right arrow and the message as a row.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:44,Modifiability,variab,variable,44,// If no report made at this range mark the variable and add the end tags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:13,Integrability,inject,inject,13,// Otherwise inject just the new row at the end of the range.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:13,Security,inject,inject,13,// Otherwise inject just the new row at the end of the range.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:8,Testability,assert,assertion,8,// This assertion also guarantees that all indices in are <= NumberOfArrows.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:212,Integrability,message,message,212,"// Pop-up pieces needs the index of the last reported piece and its count; // how many times we report to handle multiple reports on the same range.; // This marks the variable, adds the </table> end tag and the message; // (list element) as a row. The <table> start tag will be added after the; // rows has been written out. Note: It stores every different range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:168,Modifiability,variab,variable,168,"// Pop-up pieces needs the index of the last reported piece and its count; // how many times we report to handle multiple reports on the same range.; // This marks the variable, adds the </table> end tag and the message; // (list element) as a row. The <table> start tag will be added after the; // rows has been written out. Note: It stores every different range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:27,Integrability,message,message,27,// Create the html for the message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:41,Integrability,message,message,41,// Determine the approximate size of the message bubble in em.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:419,Availability,error,error,419,"R""<<<(; <script type='text/javascript'>; // Return range of numbers from a range [lower, upper).; function range(lower, upper) {; var array = [];; for (var i = lower; i <= upper; ++i) {; array.push(i);; }; return array;; }. var getRelatedArrowIndices = function(pathId) {; // HTML numeration of events is a bit different than it is in the path.; // Everything is rotated one step to the right, so the last element; // (error diagnostic) has index 0.; if (pathId == 0) {; // arrowIndices has at least 2 elements; pathId = arrowIndices.length - 1;; }. return range(arrowIndices[pathId], arrowIndices[pathId - 1]);; }. var highlightArrowsForSelectedEvent = function() {; const selectedNum = findNum();; const arrowIndicesToHighlight = getRelatedArrowIndices(selectedNum);; arrowIndicesToHighlight.forEach((index) => {; var arrow = document.querySelector(""#arrow"" + index);; if(arrow) {; classListAdd(arrow, ""selected""); }; });; }. var getAbsoluteBoundingRect = function(element) {; const relative = element.getBoundingClientRect();; return {; left: relative.left + window.pageXOffset,; right: relative.right + window.pageXOffset,; top: relative.top + window.pageYOffset,; bottom: relative.bottom + window.pageYOffset,; height: relative.height,; width: relative.width; };; }. var drawArrow = function(index) {; // This function is based on the great answer from SO:; // https://stackoverflow.com/a/39575674/11582326; var start = document.querySelector(""#start"" + index);; var end = document.querySelector(""#end"" + index);; var arrow = document.querySelector(""#arrow"" + index);. var startRect = getAbsoluteBoundingRect(start);; var endRect = getAbsoluteBoundingRect(end);. // It is an arrow from a token to itself, no need to visualize it.; if (startRect.top == endRect.top &&; startRect.left == endRect.left); return;. // Each arrow is a very simple Bzier curve, with two nodes and; // two handles. So, we need to calculate four points in the window:; // * start node; var posStart = { x: 0, y: 0 };; // ",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:2941,Availability,down,downwards,2941,"eed to calculate four points in the window:; // * start node; var posStart = { x: 0, y: 0 };; // * end node; var posEnd = { x: 0, y: 0 };; // * handle for the start node; var startHandle = { x: 0, y: 0 };; // * handle for the end node; var endHandle = { x: 0, y: 0 };; // One can visualize it as follows:; //; // start handle; // /; // X""""""_.-""""""""X; // .' \; // / start node; // |; // |; // | end node; // \ /; // `->X; // X-'; // \; // end handle; //; // NOTE: (0, 0) is the top left corner of the window. // We have 3 similar, but still different scenarios to cover:; //; // 1. Two tokens on different lines.; // -xxx; // /; // \; // -> xxx; // In this situation, we draw arrow on the left curving to the left.; // 2. Two tokens on the same line, and the destination is on the right.; // ____; // / \; // / V; // xxx xxx; // In this situation, we draw arrow above curving upwards.; // 3. Two tokens on the same line, and the destination is on the left.; // xxx xxx; // ^ /; // \____/; // In this situation, we draw arrow below curving downwards.; const onDifferentLines = startRect.top <= endRect.top - 5 ||; startRect.top >= endRect.top + 5;; const leftToRight = startRect.left < endRect.left;. // NOTE: various magic constants are chosen empirically for; // better positioning and look; if (onDifferentLines) {; // Case #1; const topToBottom = startRect.top < endRect.top;; posStart.x = startRect.left - 1;; // We don't want to start it at the top left corner of the token,; // it doesn't feel like this is where the arrow comes from.; // For this reason, we start it in the middle of the left side; // of the token.; posStart.y = startRect.top + startRect.height / 2;. // End node has arrow head and we give it a bit more space.; posEnd.x = endRect.left - 4;; posEnd.y = endRect.top;. // Utility object with x and y offsets for handles.; var curvature = {; // We want bottom-to-top arrow to curve a bit more, so it doesn't; // overlap much with top-to-bottom curves (much more frequent).; x: topT",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:4368,Availability,down,downwards,4368,"ken,; // it doesn't feel like this is where the arrow comes from.; // For this reason, we start it in the middle of the left side; // of the token.; posStart.y = startRect.top + startRect.height / 2;. // End node has arrow head and we give it a bit more space.; posEnd.x = endRect.left - 4;; posEnd.y = endRect.top;. // Utility object with x and y offsets for handles.; var curvature = {; // We want bottom-to-top arrow to curve a bit more, so it doesn't; // overlap much with top-to-bottom curves (much more frequent).; x: topToBottom ? 15 : 25,; y: Math.min((posEnd.y - posStart.y) / 3, 10); }. // When destination is on the different line, we can make a; // curvier arrow because we have space for it.; // So, instead of using; //; // startHandle.x = posStart.x - curvature.x; // endHandle.x = posEnd.x - curvature.x; //; // We use the leftmost of these two values for both handles.; startHandle.x = Math.min(posStart.x, posEnd.x) - curvature.x;; endHandle.x = startHandle.x;. // Curving downwards from the start node...; startHandle.y = posStart.y + curvature.y;; // ... and upwards from the end node.; endHandle.y = posEnd.y - curvature.y;. } else if (leftToRight) {; // Case #2; // Starting from the top right corner...; posStart.x = startRect.right - 1;; posStart.y = startRect.top;. // ...and ending at the top left corner of the end token.; posEnd.x = endRect.left + 1;; posEnd.y = endRect.top - 1;. // Utility object with x and y offsets for handles.; var curvature = {; x: Math.min((posEnd.x - posStart.x) / 3, 15),; y: 5; }. // Curving to the right...; startHandle.x = posStart.x + curvature.x;; // ... and upwards from the start node.; startHandle.y = posStart.y - curvature.y;. // And to the left...; endHandle.x = posEnd.x - curvature.x;; // ... and upwards from the end node.; endHandle.y = posEnd.y - curvature.y;. } else {; // Case #3; // Starting from the bottom right corner...; posStart.x = startRect.right;; posStart.y = startRect.bottom;. // ...and ending also at the bottom ri",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:5684,Availability,down,downwards,5684,"left corner of the end token.; posEnd.x = endRect.left + 1;; posEnd.y = endRect.top - 1;. // Utility object with x and y offsets for handles.; var curvature = {; x: Math.min((posEnd.x - posStart.x) / 3, 15),; y: 5; }. // Curving to the right...; startHandle.x = posStart.x + curvature.x;; // ... and upwards from the start node.; startHandle.y = posStart.y - curvature.y;. // And to the left...; endHandle.x = posEnd.x - curvature.x;; // ... and upwards from the end node.; endHandle.y = posEnd.y - curvature.y;. } else {; // Case #3; // Starting from the bottom right corner...; posStart.x = startRect.right;; posStart.y = startRect.bottom;. // ...and ending also at the bottom right corner, but of the end token.; posEnd.x = endRect.right - 1;; posEnd.y = endRect.bottom + 1;. // Utility object with x and y offsets for handles.; var curvature = {; x: Math.min((posStart.x - posEnd.x) / 3, 15),; y: 5; }. // Curving to the left...; startHandle.x = posStart.x - curvature.x;; // ... and downwards from the start node.; startHandle.y = posStart.y + curvature.y;. // And to the right...; endHandle.x = posEnd.x + curvature.x;; // ... and downwards from the end node.; endHandle.y = posEnd.y + curvature.y;; }. // Put it all together into a path.; // More information on the format:; // https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths; var pathStr = ""M"" + posStart.x + "","" + posStart.y + "" "" +; ""C"" + startHandle.x + "","" + startHandle.y + "" "" +; endHandle.x + "","" + endHandle.y + "" "" +; posEnd.x + "","" + posEnd.y;. arrow.setAttribute(""d"", pathStr);; };. var drawArrows = function() {; const numOfArrows = document.querySelectorAll(""path[id^=arrow]"").length;; for (var i = 0; i < numOfArrows; ++i) {; drawArrow(i);; }; }. var toggleArrows = function(event) {; const arrows = document.querySelector(""#arrows"");; if (event.target.checked) {; arrows.setAttribute(""visibility"", ""visible"");; } else {; arrows.setAttribute(""visibility"", ""hidden"");; }; }. window.addEventListener(""resize"", drawA",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:5833,Availability,down,downwards,5833,"urvature = {; x: Math.min((posEnd.x - posStart.x) / 3, 15),; y: 5; }. // Curving to the right...; startHandle.x = posStart.x + curvature.x;; // ... and upwards from the start node.; startHandle.y = posStart.y - curvature.y;. // And to the left...; endHandle.x = posEnd.x - curvature.x;; // ... and upwards from the end node.; endHandle.y = posEnd.y - curvature.y;. } else {; // Case #3; // Starting from the bottom right corner...; posStart.x = startRect.right;; posStart.y = startRect.bottom;. // ...and ending also at the bottom right corner, but of the end token.; posEnd.x = endRect.right - 1;; posEnd.y = endRect.bottom + 1;. // Utility object with x and y offsets for handles.; var curvature = {; x: Math.min((posStart.x - posEnd.x) / 3, 15),; y: 5; }. // Curving to the left...; startHandle.x = posStart.x - curvature.x;; // ... and downwards from the start node.; startHandle.y = posStart.y + curvature.y;. // And to the right...; endHandle.x = posEnd.x + curvature.x;; // ... and downwards from the end node.; endHandle.y = posEnd.y + curvature.y;; }. // Put it all together into a path.; // More information on the format:; // https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths; var pathStr = ""M"" + posStart.x + "","" + posStart.y + "" "" +; ""C"" + startHandle.x + "","" + startHandle.y + "" "" +; endHandle.x + "","" + endHandle.y + "" "" +; posEnd.x + "","" + posEnd.y;. arrow.setAttribute(""d"", pathStr);; };. var drawArrows = function() {; const numOfArrows = document.querySelectorAll(""path[id^=arrow]"").length;; for (var i = 0; i < numOfArrows; ++i) {; drawArrow(i);; }; }. var toggleArrows = function(event) {; const arrows = document.querySelector(""#arrows"");; if (event.target.checked) {; arrows.setAttribute(""visibility"", ""visible"");; } else {; arrows.setAttribute(""visibility"", ""hidden"");; }; }. window.addEventListener(""resize"", drawArrows);; document.addEventListener(""DOMContentLoaded"", function() {; // Whenever we show invocation, locations change, i.e. we; // need to redraw ar",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:6435,Deployability,toggle,toggleArrows,6435,"bottom;. // ...and ending also at the bottom right corner, but of the end token.; posEnd.x = endRect.right - 1;; posEnd.y = endRect.bottom + 1;. // Utility object with x and y offsets for handles.; var curvature = {; x: Math.min((posStart.x - posEnd.x) / 3, 15),; y: 5; }. // Curving to the left...; startHandle.x = posStart.x - curvature.x;; // ... and downwards from the start node.; startHandle.y = posStart.y + curvature.y;. // And to the right...; endHandle.x = posEnd.x + curvature.x;; // ... and downwards from the end node.; endHandle.y = posEnd.y + curvature.y;; }. // Put it all together into a path.; // More information on the format:; // https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths; var pathStr = ""M"" + posStart.x + "","" + posStart.y + "" "" +; ""C"" + startHandle.x + "","" + startHandle.y + "" "" +; endHandle.x + "","" + endHandle.y + "" "" +; posEnd.x + "","" + posEnd.y;. arrow.setAttribute(""d"", pathStr);; };. var drawArrows = function() {; const numOfArrows = document.querySelectorAll(""path[id^=arrow]"").length;; for (var i = 0; i < numOfArrows; ++i) {; drawArrow(i);; }; }. var toggleArrows = function(event) {; const arrows = document.querySelector(""#arrows"");; if (event.target.checked) {; arrows.setAttribute(""visibility"", ""visible"");; } else {; arrows.setAttribute(""visibility"", ""hidden"");; }; }. window.addEventListener(""resize"", drawArrows);; document.addEventListener(""DOMContentLoaded"", function() {; // Whenever we show invocation, locations change, i.e. we; // need to redraw arrows.; document; .querySelector('input[id=""showinvocation""]'); .addEventListener(""click"", drawArrows);; // Hiding irrelevant lines also should cause arrow rerender.; document; .querySelector('input[name=""showCounterexample""]'); .addEventListener(""change"", drawArrows);; document; .querySelector('input[name=""showArrows""]'); .addEventListener(""change"", toggleArrows);; drawArrows();; // Default highlighting for the last event.; highlightArrowsForSelectedEvent();; });; </script>; )<<<""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:7197,Deployability,toggle,toggleArrows,7197,"bottom;. // ...and ending also at the bottom right corner, but of the end token.; posEnd.x = endRect.right - 1;; posEnd.y = endRect.bottom + 1;. // Utility object with x and y offsets for handles.; var curvature = {; x: Math.min((posStart.x - posEnd.x) / 3, 15),; y: 5; }. // Curving to the left...; startHandle.x = posStart.x - curvature.x;; // ... and downwards from the start node.; startHandle.y = posStart.y + curvature.y;. // And to the right...; endHandle.x = posEnd.x + curvature.x;; // ... and downwards from the end node.; endHandle.y = posEnd.y + curvature.y;; }. // Put it all together into a path.; // More information on the format:; // https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths; var pathStr = ""M"" + posStart.x + "","" + posStart.y + "" "" +; ""C"" + startHandle.x + "","" + startHandle.y + "" "" +; endHandle.x + "","" + endHandle.y + "" "" +; posEnd.x + "","" + posEnd.y;. arrow.setAttribute(""d"", pathStr);; };. var drawArrows = function() {; const numOfArrows = document.querySelectorAll(""path[id^=arrow]"").length;; for (var i = 0; i < numOfArrows; ++i) {; drawArrow(i);; }; }. var toggleArrows = function(event) {; const arrows = document.querySelector(""#arrows"");; if (event.target.checked) {; arrows.setAttribute(""visibility"", ""visible"");; } else {; arrows.setAttribute(""visibility"", ""hidden"");; }; }. window.addEventListener(""resize"", drawArrows);; document.addEventListener(""DOMContentLoaded"", function() {; // Whenever we show invocation, locations change, i.e. we; // need to redraw arrows.; document; .querySelector('input[id=""showinvocation""]'); .addEventListener(""click"", drawArrows);; // Hiding irrelevant lines also should cause arrow rerender.; document; .querySelector('input[name=""showCounterexample""]'); .addEventListener(""change"", drawArrows);; document; .querySelector('input[name=""showArrows""]'); .addEventListener(""change"", toggleArrows);; drawArrows();; // Default highlighting for the last event.; highlightArrowsForSelectedEvent();; });; </script>; )<<<""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:1839,Usability,simpl,simple,1839,"rrow"" + index);; if(arrow) {; classListAdd(arrow, ""selected""); }; });; }. var getAbsoluteBoundingRect = function(element) {; const relative = element.getBoundingClientRect();; return {; left: relative.left + window.pageXOffset,; right: relative.right + window.pageXOffset,; top: relative.top + window.pageYOffset,; bottom: relative.bottom + window.pageYOffset,; height: relative.height,; width: relative.width; };; }. var drawArrow = function(index) {; // This function is based on the great answer from SO:; // https://stackoverflow.com/a/39575674/11582326; var start = document.querySelector(""#start"" + index);; var end = document.querySelector(""#end"" + index);; var arrow = document.querySelector(""#arrow"" + index);. var startRect = getAbsoluteBoundingRect(start);; var endRect = getAbsoluteBoundingRect(end);. // It is an arrow from a token to itself, no need to visualize it.; if (startRect.top == endRect.top &&; startRect.left == endRect.left); return;. // Each arrow is a very simple Bzier curve, with two nodes and; // two handles. So, we need to calculate four points in the window:; // * start node; var posStart = { x: 0, y: 0 };; // * end node; var posEnd = { x: 0, y: 0 };; // * handle for the start node; var startHandle = { x: 0, y: 0 };; // * handle for the end node; var endHandle = { x: 0, y: 0 };; // One can visualize it as follows:; //; // start handle; // /; // X""""""_.-""""""""X; // .' \; // / start node; // |; // |; // | end node; // \ /; // `->X; // X-'; // \; // end handle; //; // NOTE: (0, 0) is the top left corner of the window. // We have 3 similar, but still different scenarios to cover:; //; // 1. Two tokens on different lines.; // -xxx; // /; // \; // -> xxx; // In this situation, we draw arrow on the left curving to the left.; // 2. Two tokens on the same line, and the destination is on the right.; // ____; // / \; // / V; // xxx xxx; // In this situation, we draw arrow above curving upwards.; // 3. Two tokens on the same line, and the destination is on the le",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/LoopUnrolling.cpp:143,Integrability,depend,depending,143,"// namespace; // The tracked stack of loops. The stack indicates that which loops the; // simulated element contained by. The loops are marked depending if we decided; // to unroll them.; // TODO: The loop stack should not need to be in the program state since it is; // lexical in nature. Instead, the stack of loops should be tracked in the; // LocationContext.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/LoopUnrolling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/LoopUnrolling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/LoopUnrolling.cpp:30,Usability,simpl,simple,30,// Incrementation should be a simple increment or decrement; // operator call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/LoopUnrolling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/LoopUnrolling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/LoopUnrolling.cpp:71,Modifiability,variab,variable,71,// A loop counter is considered escaped if:; // case 1: It is a global variable.; // case 2: It is a reference parameter or a reference capture.; // case 3: It is assigned to a non-const reference variable or parameter.; // case 4: Has its address taken.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/LoopUnrolling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/LoopUnrolling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/LoopUnrolling.cpp:197,Modifiability,variab,variable,197,// A loop counter is considered escaped if:; // case 1: It is a global variable.; // case 2: It is a reference parameter or a reference capture.; // case 3: It is assigned to a non-const reference variable or parameter.; // case 4: Has its address taken.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/LoopUnrolling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/LoopUnrolling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/LoopUnrolling.cpp:3,Deployability,update,updateLoopStack,3,"// updateLoopStack is called on every basic block, therefore it needs to be fast",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/LoopUnrolling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/LoopUnrolling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp:43,Modifiability,variab,variable,43,// Obtain array indices to add them to the variable name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp:43,Modifiability,variab,variable,43,"// If not a ConcreteInt, try to obtain the variable; // name by calling 'getDescriptiveName' recursively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp:7,Modifiability,variab,variable,7,// Get variable name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp:28,Modifiability,flexible,flexible,28,"// We currently don't model flexible array members (FAMs), which are:; // - int array[]; of IncompleteArrayType; // - int array[0]; of ConstantArrayType with size 0; // - int array[1]; of ConstantArrayType with size 1; // https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp:43,Usability,Simpl,SimpleSValBuilder,43,// FIXME: The following are being used in 'SimpleSValBuilder' and in; // 'ArrayBoundChecker::checkLocation' because there is no symbol to; // represent the regions more appropriately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp:146,Modifiability,variab,variable,146,"/// Look through a chain of LocationContexts to either find the; /// StackFrameContext that matches a DeclContext, or find a VarRegion; /// for a variable captured by a block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp:32,Energy Efficiency,efficient,efficient,32,// FIXME: This can be made more efficient.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp:74,Integrability,depend,depending,74,// ARC managed blocks can be initialized on stack or directly in heap; // depending on the implementations. So we initialize them with; // UnknownRegion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp:3,Deployability,Update,Update,3,// Update the offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp:118,Availability,down,down,118,"// Note that we do NOT canonicalize the base class here, because; // ASTRecordLayout doesn't either. If that leads us down the wrong path,; // so be it; at least we won't crash.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp:8,Modifiability,layers,layers,8,"// Base layers on symbolic regions may not be type-correct.; // Double-check the inheritance here, and revert to a symbolic offset; // if it's invalid (e.g. due to a reinterpret_cast).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp:81,Modifiability,inherit,inheritance,81,"// Base layers on symbolic regions may not be type-correct.; // Double-check the inheritance here, and revert to a symbolic offset; // if it's invalid (e.g. due to a reinterpret_cast).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp:219,Integrability,depend,depend,219,"// We cannot compute offset for incomplete type.; // For unions, we could treat everything as offset 0, but we'd rather; // treat each field as a symbolic offset so they aren't stored on top; // of each other, since we depend on things in typed regions actually; // matching their types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PlistDiagnostics.cpp:168,Testability,log,logic,168,// Make the ranges of the start and end point self-consistent with adjacent edges; // by forcing to use only the beginning of the range. This simplifies the layout; // logic for clients.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PlistDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PlistDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PlistDiagnostics.cpp:142,Usability,simpl,simplifies,142,// Make the ranges of the start and end point self-consistent with adjacent edges; // by forcing to use only the beginning of the range. This simplifies the layout; // logic for clients.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PlistDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PlistDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PlistDiagnostics.cpp:17,Availability,error,error,17,// TODO: Emit an error here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PlistDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PlistDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PlistDiagnostics.cpp:17,Availability,error,error,17,// TODO: Emit an error here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PlistDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PlistDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PlistDiagnostics.cpp:18,Security,hash,hash,18,"// Output the bug hash for issue unique-ing. Currently, it's just an; // offset from the beginning of the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PlistDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PlistDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PlistDiagnostics.cpp:56,Security,hash,hash,56,"// If the bug uniqueing location exists, use it for the hash.; // For example, this ensures that two leaks reported on the same line; // will have different issue_hashes and that the hash will identify; // the leak location even after code is added between the allocation; // site and the end of scope (leak report location).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PlistDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PlistDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PlistDiagnostics.cpp:183,Security,hash,hash,183,"// If the bug uniqueing location exists, use it for the hash.; // For example, this ensures that two leaks reported on the same line; // will have different issue_hashes and that the hash will identify; // the leak location even after code is added between the allocation; // site and the end of scope (leak report location).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PlistDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PlistDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PrettyStackTraceLocationContext.h:10,Availability,alive,alive,10,"/// While alive, includes the current analysis stack in a crash trace.; ///; /// Example:; /// \code; /// 0. Program arguments: ...; /// 1. <eof> parser at end of file; /// 2. While analyzing stack:; /// #0 void inlined(); /// #1 void test(); /// 3. crash-trace.c:6:3: Error evaluating statement; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PrettyStackTraceLocationContext.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PrettyStackTraceLocationContext.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PrettyStackTraceLocationContext.h:269,Availability,Error,Error,269,"/// While alive, includes the current analysis stack in a crash trace.; ///; /// Example:; /// \code; /// 0. Program arguments: ...; /// 1. <eof> parser at end of file; /// 2. While analyzing stack:; /// #0 void inlined(); /// #1 void test(); /// 3. crash-trace.c:6:3: Error evaluating statement; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PrettyStackTraceLocationContext.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PrettyStackTraceLocationContext.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PrettyStackTraceLocationContext.h:235,Testability,test,test,235,"/// While alive, includes the current analysis stack in a crash trace.; ///; /// Example:; /// \code; /// 0. Program arguments: ...; /// 1. <eof> parser at end of file; /// 2. While analyzing stack:; /// #0 void inlined(); /// #1 void test(); /// 3. crash-trace.c:6:3: Error evaluating statement; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PrettyStackTraceLocationContext.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PrettyStackTraceLocationContext.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ProgramState.cpp:60,Modifiability,Variab,VariableBindings,60,"// This code essentially performs a ""mark-and-sweep"" of the VariableBindings.; // The roots are any Block-level exprs and Decls that our liveness algorithm; // tells us are live. We then see what Decls they may reference, and keep; // those around. This code more than likely can be made faster, and the; // frequency of which this method is called should be experimented with; // for optimum performance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ProgramState.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ProgramState.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ProgramState.cpp:25,Performance,perform,performs,25,"// This code essentially performs a ""mark-and-sweep"" of the VariableBindings.; // The roots are any Block-level exprs and Decls that our liveness algorithm; // tells us are live. We then see what Decls they may reference, and keep; // those around. This code more than likely can be made faster, and the; // frequency of which this method is called should be experimented with; // for optimum performance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ProgramState.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ProgramState.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ProgramState.cpp:393,Performance,perform,performance,393,"// This code essentially performs a ""mark-and-sweep"" of the VariableBindings.; // The roots are any Block-level exprs and Decls that our liveness algorithm; // tells us are live. We then see what Decls they may reference, and keep; // those around. This code more than likely can be made faster, and the; // frequency of which this method is called should be experimented with; // for optimum performance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ProgramState.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ProgramState.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:445,Usability,simpl,simple,445,"//== RangeConstraintManager.cpp - Manage range constraints.------*- C++ -*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines RangeConstraintManager, a class that tracks simple; // equality and inequality constraints on symbolic values of ProgramState.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:21,Modifiability,extend,extended,21,// This class can be extended with other tables which will help to reason; // about ranges more precisely.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:85,Safety,avoid,avoid,85,"// Handle a corner case first when both range sets start from MIN.; // This helps to avoid complicated conditions below. Specifically, this; // particular check for `MIN` is not needed in the loop below every time; // when we do `Second->From() - One` operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:96,Energy Efficiency,allocate,allocated,96,// It is cheaper to fully construct the resulting range on stack; // and move it to the freshly allocated buffer if we don't have; // a set like this already.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:64,Testability,test,testing,64,"// This function has nine cases, the cartesian product of range-testing; // both the upper and lower bounds against the symbol's type.; // Each case requires a different pinning operation.; // The function returns false if the described range is entirely outside; // the range of values for the associated symbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:25,Integrability,wrap,wraps,25,"// However, if the range wraps around, it spans all possible values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:13,Integrability,wrap,wraps,13,"// The range wraps around, but all lower values are not possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:28,Integrability,wrap,wrap,28,"// The range may or may not wrap around, but both limits are valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:13,Integrability,wrap,wraps,13,// The range wraps but is outside the symbol's set of possible values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:62,Integrability,wrap,wrap,62,// The range starts above what's possible but ends within it (wrap).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:25,Integrability,wrap,wraps,25,"// However, if the range wraps around, it spans all possible values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:14,Performance,optimiz,optimization,14,// This is an optimization for a specific case when this Range covers; // the whole range of the target type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:437,Energy Efficiency,efficient,efficiently,437,"/// This class encapsulates a set of symbols equal to each other.; ///; /// The main idea of the approach requiring such classes is in narrowing; /// and sharing constraints between symbols within the class. Also we can; /// conclude that there is no practical need in storing constraints for; /// every member of the class separately.; ///; /// Main terminology:; ///; /// * ""Equivalence class"" is an object of this class, which can be efficiently; /// compared to other classes. It represents the whole class without; /// storing the actual in it. The members of the class however can be; /// retrieved from the state.; ///; /// * ""Class members"" are the symbols corresponding to the class. This means; /// that A == B for every member symbols A and B from the class. Members of; /// each class are stored in the state.; ///; /// * ""Trivial class"" is a class that has and ever had only one same symbol.; ///; /// * ""Merge operation"" merges two classes into one. It is the main operation; /// to produce non-trivial classes.; /// If, at some point, we can assume that two symbols from two distinct; /// classes are equal, we can merge these classes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:426,Performance,perform,performance,426,"/// Return true if the current class is trivial in the given state.; /// A class is trivial if and only if there is not any member relations stored; /// to it in State/ClassMembers.; /// An equivalence class with one member might seem as it does not hold any; /// meaningful information, i.e. that is a tautology. However, during the; /// removal of dead symbols we do not remove classes with one member for; /// resource and performance reasons. Consequently, a class with one member is; /// not necessarily trivial. It could happen that we have a class with two; /// members and then during the removal of dead symbols we remove one of its; /// members. In this case, the class is still non-trivial (it still has the; /// mappings in ClassMembers), even though it has only one member.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:40,Usability,simpl,simplify,40,/// Iterate over all symbols and try to simplify them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:233,Safety,detect,detecting,233,//===----------------------------------------------------------------------===//; // Equality/diseqiality abstraction; //===----------------------------------------------------------------------===//; /// A small helper function for detecting symbolic (dis)equality.; ///; /// Equality check can have different forms (like a == b or a - b) and this; /// class encapsulates those away if the only thing the user wants to check -; /// whether it's equality/diseqiality or not.; ///; /// \returns true if assuming this Sym to be true means equality of operands; /// false if it means disequality of operands; /// std::nullopt otherwise,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:66,Usability,simpl,simply,66,"// If the list contains only RangeSet or std::optional<RangeSet>, simply; // return that range set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:215,Availability,Avail,Available,215,"/// Main generic intersect function.; /// It intersects all of the given range sets. If some of the given arguments; /// don't hold a range set (nullptr or std::nullopt), the function will skip; /// them.; ///; /// Available representations for the arguments are:; /// * RangeSet; /// * std::optional<RangeSet>; /// * RangeSet *; /// Pointer to a RangeSet is automatically assumed to be nullable and will get; /// checked as well as the optional version. If this behaviour is undesired,; /// please dereference the pointer in the call.; ///; /// Return type depends on the arguments' types. If we can be sure in compile; /// time that there will be a range set as a result, the returning type is; /// simply RangeSet, in other cases we have to back off to; /// std::optional<RangeSet>.; ///; /// Please, prefer optional range sets to raw pointers. If the last argument is; /// a raw pointer and all previous arguments are std::nullopt, it will cost one; /// additional check to convert RangeSet * into std::optional<RangeSet>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:558,Integrability,depend,depends,558,"/// Main generic intersect function.; /// It intersects all of the given range sets. If some of the given arguments; /// don't hold a range set (nullptr or std::nullopt), the function will skip; /// them.; ///; /// Available representations for the arguments are:; /// * RangeSet; /// * std::optional<RangeSet>; /// * RangeSet *; /// Pointer to a RangeSet is automatically assumed to be nullable and will get; /// checked as well as the optional version. If this behaviour is undesired,; /// please dereference the pointer in the call.; ///; /// Return type depends on the arguments' types. If we can be sure in compile; /// time that there will be a range set as a result, the returning type is; /// simply RangeSet, in other cases we have to back off to; /// std::optional<RangeSet>.; ///; /// Please, prefer optional range sets to raw pointers. If the last argument is; /// a raw pointer and all previous arguments are std::nullopt, it will cost one; /// additional check to convert RangeSet * into std::optional<RangeSet>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:701,Usability,simpl,simply,701,"/// Main generic intersect function.; /// It intersects all of the given range sets. If some of the given arguments; /// don't hold a range set (nullptr or std::nullopt), the function will skip; /// them.; ///; /// Available representations for the arguments are:; /// * RangeSet; /// * std::optional<RangeSet>; /// * RangeSet *; /// Pointer to a RangeSet is automatically assumed to be nullable and will get; /// checked as well as the optional version. If this behaviour is undesired,; /// please dereference the pointer in the call.; ///; /// Return type depends on the arguments' types. If we can be sure in compile; /// time that there will be a range set as a result, the returning type is; /// simply RangeSet, in other cases we have to back off to; /// std::optional<RangeSet>.; ///; /// Please, prefer optional range sets to raw pointers. If the last argument is; /// a raw pointer and all previous arguments are std::nullopt, it will cost one; /// additional check to convert RangeSet * into std::optional<RangeSet>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:104,Testability,log,logic,104,"//===----------------------------------------------------------------------===//; // Symbolic reasoning logic; //===----------------------------------------------------------------------===//; /// A little component aggregating all of the reasoning we have about; /// the ranges of symbolic expressions.; ///; /// Even when we don't know the exact values of the operands, we still; /// can get a pretty good estimate of the result's range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:140,Usability,simpl,simply,140,"// If we've reached this line, the actual type of the symbolic; // expression is not supported for advanced inference.; // In this case, we simply backoff to the default ""let's simply; // infer the range from the expression's type"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:177,Usability,simpl,simply,177,"// If we've reached this line, the actual type of the symbolic; // expression is not supported for advanced inference.; // In this case, we simply backoff to the default ""let's simply; // infer the range from the expression's type"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:162,Modifiability,polymorphi,polymorphic,162,"/// Infer range information from the given integer constant.; ///; /// It's not a real ""inference"", but is here for operating with; /// sub-expressions in a more polymorphic manner.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:20,Usability,simpl,simply,20,"// Otherwise, let's simply infer from the destination type.; // We couldn't figure out nothing else about that expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:489,Deployability,continuous,continuously,489,"// TODO #1: VisitBinaryOperator implementation might not make a good; // use of the inferred ranges. In this case, we might be calculating; // everything for nothing. This being said, we should introduce some; // sort of laziness mechanism here.; //; // TODO #2: We didn't go into the nested expressions before, so it; // might cause us spending much more time doing the inference.; // This can be a problem for deeply nested expressions that are; // involved in conditions and get tested continuously. We definitely; // need to address this issue and introduce some sort of caching; // in here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:482,Testability,test,tested,482,"// TODO #1: VisitBinaryOperator implementation might not make a good; // use of the inferred ranges. In this case, we might be calculating; // everything for nothing. This being said, we should introduce some; // sort of laziness mechanism here.; //; // TODO #2: We didn't go into the nested expressions before, so it; // might cause us spending much more time doing the inference.; // This can be a problem for deeply nested expressions that are; // involved in conditions and get tested continuously. We definitely; // need to address this issue and introduce some sort of caching; // in here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:117,Safety,avoid,avoid,117,"// If mini is a minimal signed value, absolute value of it is greater; // than the maximal signed value. In order to avoid these; // complications, we simply return the whole range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:151,Usability,simpl,simply,151,"// If mini is a minimal signed value, absolute value of it is greater; // than the maximal signed value. In order to avoid these; // complications, we simply return the whole range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:65,Safety,safe,safely,65,"// At this point, we are sure that the type is signed and we can safely; // use unary - operator.; //; // While calculating absolute maximum, we can use the following formula; // because of these reasons:; // * If From >= 0 then To >= From and To >= -From.; // AbsMax == To == max(To, -From); // * If To <= 0 then -From >= -To and -From >= From.; // AbsMax == -From == max(-From, To); // * Otherwise, From <= 0, To >= 0, and; // AbsMax == max(abs(From), abs(To))",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:190,Testability,log,logical,190,"// Returns ranges only for binary comparison operators (except <=>); // when left and right operands are symbolic values.; // Finds any other comparisons with the same operands.; // Then do logical calculations and refuse impossible branches.; // E.g. (x < y) and (x > y) at the same time are impossible.; // E.g. (x >= y) and (x != y) at the same time makes (x > y) true only.; // E.g. (x == y) and (y == x) are just reversed but the same.; // It covers all possible combinations (see CmpOpTable description).; // Note that `x` and `y` can also stand for subexpressions,; // not only for actual symbols.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:15,Modifiability,variab,variable,15,"// We use this variable to store the last queried operator (`QueriedOP`); // for which the `getCmpOpState` returned with `Unknown`. If there are two; // different OPs that returned `Unknown` then we have to query the special; // `UnknownX2` column. We assume that `getCmpOpState(CurrentOP, CurrentOP)`; // never returns `Unknown`, so `CurrentOP` is a good initial value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:40,Usability,guid,guided,40,"// If it is a false branch, we shall be guided by opposite operator,; // because the table is made assuming we are in the true branch.; // E.g. when (x <= y) is false, then (x > y) is true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:324,Safety,avoid,avoid,324,"// We can only lose information if we are casting smaller signed type to; // bigger unsigned type. For e.g.,; // LHS (unsigned short): [2, USHRT_MAX]; // RHS (signed short): [SHRT_MIN, 0]; //; // Casting RHS to LHS type will leave us with overlapping values; // CastedRHS : [0, 0] U [SHRT_MAX + 1, USHRT_MAX]; //; // We can avoid this by checking if signed type's maximum value is lesser; // than unsigned type's minimum value.; // If both have different signs then only we can get more information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:122,Usability,simpl,simply,122,"// It is pretty hard to reason about operands with different signs; // (and especially with possibly different signs). We simply check if it; // can be zero. In order to conclude that the result could not be zero,; // at least one of the operands should be definitely not zero itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:142,Usability,simpl,simply,142,// It's an undefined behaviour to divide by 0 and it seems like we know; // for sure that RHS is 0. Let's say that the resulting range is; // simply infeasible for that matter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:100,Integrability,interface,interface,100,//===------------------------------------------------------------------===//; // Implementation for interface from ConstraintManager.; //===------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:29,Usability,simpl,simple,29,"// NOTE: ClassMembers are as simple as back pointers for ClassMap,; // so comparing constraint ranges and class maps should be; // sufficient.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:100,Integrability,interface,interface,100,//===------------------------------------------------------------------===//; // Implementation for interface from RangedConstraintManager.; //===------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:107,Testability,log,logic,107,"//===----------------------------------------------------------------------===//; // Constraint assignment logic; //===----------------------------------------------------------------------===//; /// ConstraintAssignorBase is a small utility class that unifies visitor; /// for ranges with a visitor for constraints (rangeset/range/constant).; ///; /// It is designed to have one derived class, but generally it can have more.; /// Derived class can control which types we handle by defining methods of the; /// following form:; ///; /// bool handle${SYMBOL}To${CONSTRAINT}(const SYMBOL *Sym,; /// CONSTRAINT Constraint);; ///; /// where SYMBOL is the type of the symbol (e.g. SymSymExpr, SymbolCast, etc.); /// CONSTRAINT is the type of constraint (RangeSet/Range/Const); /// return value signifies whether we should try other handle methods; /// (i.e. false would mean to stop right after calling this method)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:43,Deployability,update,update,43,"// There is a chance that we might need to update constraints for the; // classes that are known to be disequal to Class.; //; // In order for this to be even possible, the new constraint should; // be simply a constant because we can't reason about range disequalities.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:202,Usability,simpl,simply,202,"// There is a chance that we might need to update constraints for the; // classes that are known to be disequal to Class.; //; // In order for this to be even possible, the new constraint should; // be simply a constant because we can't reason about range disequalities.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:51,Usability,simpl,simplify,51,// Iterate over all equivalence classes and try to simplify them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:175,Usability,simpl,simplify,175,"// Trivial equivalence classes (those that have only one symbol member) are; // not stored in the State. Thus, we must skim through the constraints as; // well. And we try to simplify symbols in the constraints.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:11,Usability,simpl,simplified,11,// Already simplified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:95,Usability,simpl,simplify,95,"// We may have trivial equivalence classes in the disequality info as; // well, and we need to simplify them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:6,Deployability,Update,Update,6,// 4. Update disequality relations,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:6,Deployability,Update,Update,6,// 5. Update the state,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:201,Testability,log,logic,201,"// 3. If Second is known to be a constant, we can delete this point; // from the constraint asociated with First.; //; // So, if Second == 10, it means that First != 10.; // At the same time, the same logic does not apply to ranges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:13,Usability,clear,clear,13,// It is not clear.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:54,Testability,log,logic,54,// Re-evaluate an SVal with top-level `State->assume` logic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:28,Usability,simpl,simply,28,"// If the SVal is 0, we can simply interpret that as `false`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:39,Usability,simpl,simplify,39,"// Iterate over all symbols and try to simplify them. Once a symbol is; // simplified then we check if we can merge the simplified symbol's equivalence; // class to this class. This way, we simplify not just the symbols but the; // classes as well: we strive to keep the number of the classes to be the; // absolute minimum.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:75,Usability,simpl,simplified,75,"// Iterate over all symbols and try to simplify them. Once a symbol is; // simplified then we check if we can merge the simplified symbol's equivalence; // class to this class. This way, we simplify not just the symbols but the; // classes as well: we strive to keep the number of the classes to be the; // absolute minimum.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:120,Usability,simpl,simplified,120,"// Iterate over all symbols and try to simplify them. Once a symbol is; // simplified then we check if we can merge the simplified symbol's equivalence; // class to this class. This way, we simplify not just the symbols but the; // classes as well: we strive to keep the number of the classes to be the; // absolute minimum.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:190,Usability,simpl,simplify,190,"// Iterate over all symbols and try to simplify them. Once a symbol is; // simplified then we check if we can merge the simplified symbol's equivalence; // class to this class. This way, we simplify not just the symbols but the; // classes as well: we strive to keep the number of the classes to be the; // absolute minimum.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:7,Usability,simpl,simplified,7,"// The simplified symbol should be the member of the original Class,; // however, it might be in another existing class at the moment. We; // have to merge these classes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:436,Availability,alive,alive,436,"// Be aware that `SimplifiedMemberSym` might refer to an already dead; // symbol. In that case, the eqclass of that might not be the same as the; // eqclass of `MemberSym`. This is because the dead symbols are not; // preserved in the `ClassMap`, hence; // `find(State, SimplifiedMemberSym)` will result in a trivial eqclass; // compared to the eqclass of `MemberSym`.; // These eqclasses should be the same if `SimplifiedMemberSym` is alive.; // --> assert(find(State, MemberSym) == find(State, SimplifiedMemberSym)); //; // Note that `MemberSym` must be alive here since that is from the; // `ClassMembers` where all the symbols are alive.; // Remove the old and more complex symbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:556,Availability,alive,alive,556,"// Be aware that `SimplifiedMemberSym` might refer to an already dead; // symbol. In that case, the eqclass of that might not be the same as the; // eqclass of `MemberSym`. This is because the dead symbols are not; // preserved in the `ClassMap`, hence; // `find(State, SimplifiedMemberSym)` will result in a trivial eqclass; // compared to the eqclass of `MemberSym`.; // These eqclasses should be the same if `SimplifiedMemberSym` is alive.; // --> assert(find(State, MemberSym) == find(State, SimplifiedMemberSym)); //; // Note that `MemberSym` must be alive here since that is from the; // `ClassMembers` where all the symbols are alive.; // Remove the old and more complex symbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:635,Availability,alive,alive,635,"// Be aware that `SimplifiedMemberSym` might refer to an already dead; // symbol. In that case, the eqclass of that might not be the same as the; // eqclass of `MemberSym`. This is because the dead symbols are not; // preserved in the `ClassMap`, hence; // `find(State, SimplifiedMemberSym)` will result in a trivial eqclass; // compared to the eqclass of `MemberSym`.; // These eqclasses should be the same if `SimplifiedMemberSym` is alive.; // --> assert(find(State, MemberSym) == find(State, SimplifiedMemberSym)); //; // Note that `MemberSym` must be alive here since that is from the; // `ClassMembers` where all the symbols are alive.; // Remove the old and more complex symbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:451,Testability,assert,assert,451,"// Be aware that `SimplifiedMemberSym` might refer to an already dead; // symbol. In that case, the eqclass of that might not be the same as the; // eqclass of `MemberSym`. This is because the dead symbols are not; // preserved in the `ClassMap`, hence; // `find(State, SimplifiedMemberSym)` will result in a trivial eqclass; // compared to the eqclass of `MemberSym`.; // These eqclasses should be the same if `SimplifiedMemberSym` is alive.; // --> assert(find(State, MemberSym) == find(State, SimplifiedMemberSym)); //; // Note that `MemberSym` must be alive here since that is from the; // `ClassMembers` where all the symbols are alive.; // Remove the old and more complex symbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:18,Usability,Simpl,SimplifiedMemberSym,18,"// Be aware that `SimplifiedMemberSym` might refer to an already dead; // symbol. In that case, the eqclass of that might not be the same as the; // eqclass of `MemberSym`. This is because the dead symbols are not; // preserved in the `ClassMap`, hence; // `find(State, SimplifiedMemberSym)` will result in a trivial eqclass; // compared to the eqclass of `MemberSym`.; // These eqclasses should be the same if `SimplifiedMemberSym` is alive.; // --> assert(find(State, MemberSym) == find(State, SimplifiedMemberSym)); //; // Note that `MemberSym` must be alive here since that is from the; // `ClassMembers` where all the symbols are alive.; // Remove the old and more complex symbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:270,Usability,Simpl,SimplifiedMemberSym,270,"// Be aware that `SimplifiedMemberSym` might refer to an already dead; // symbol. In that case, the eqclass of that might not be the same as the; // eqclass of `MemberSym`. This is because the dead symbols are not; // preserved in the `ClassMap`, hence; // `find(State, SimplifiedMemberSym)` will result in a trivial eqclass; // compared to the eqclass of `MemberSym`.; // These eqclasses should be the same if `SimplifiedMemberSym` is alive.; // --> assert(find(State, MemberSym) == find(State, SimplifiedMemberSym)); //; // Note that `MemberSym` must be alive here since that is from the; // `ClassMembers` where all the symbols are alive.; // Remove the old and more complex symbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:412,Usability,Simpl,SimplifiedMemberSym,412,"// Be aware that `SimplifiedMemberSym` might refer to an already dead; // symbol. In that case, the eqclass of that might not be the same as the; // eqclass of `MemberSym`. This is because the dead symbols are not; // preserved in the `ClassMap`, hence; // `find(State, SimplifiedMemberSym)` will result in a trivial eqclass; // compared to the eqclass of `MemberSym`.; // These eqclasses should be the same if `SimplifiedMemberSym` is alive.; // --> assert(find(State, MemberSym) == find(State, SimplifiedMemberSym)); //; // Note that `MemberSym` must be alive here since that is from the; // `ClassMembers` where all the symbols are alive.; // Remove the old and more complex symbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:496,Usability,Simpl,SimplifiedMemberSym,496,"// Be aware that `SimplifiedMemberSym` might refer to an already dead; // symbol. In that case, the eqclass of that might not be the same as the; // eqclass of `MemberSym`. This is because the dead symbols are not; // preserved in the `ClassMap`, hence; // `find(State, SimplifiedMemberSym)` will result in a trivial eqclass; // compared to the eqclass of `MemberSym`.; // These eqclasses should be the same if `SimplifiedMemberSym` is alive.; // --> assert(find(State, MemberSym) == find(State, SimplifiedMemberSym)); //; // Note that `MemberSym` must be alive here since that is from the; // `ClassMembers` where all the symbols are alive.; // Remove the old and more complex symbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:950,Energy Efficiency,reduce,reduced,950,"// Re-evaluate an SVal with top-level `State->assume`, this ignites; // a RECURSIVE algorithm that will reach a FIXPOINT.; //; // About performance and complexity: Let us assume that in a State we; // have N non-trivial equivalence classes and that all constraints and; // disequality info is related to non-trivial classes. In the worst case,; // we can simplify only one symbol of one class in each iteration. The; // number of symbols in one class cannot grow b/c we replace the old; // symbol with the simplified one. Also, the number of the equivalence; // classes can decrease only, b/c the algorithm does a merge operation; // optionally. We need N iterations in this case to reach the fixpoint.; // Thus, the steps needed to be done in the worst case is proportional to; // N*N.; //; // This worst case scenario can be extended to that case when we have; // trivial classes in the constraints and in the disequality map. This; // case can be reduced to the case with a State where there are only; // non-trivial classes. This is because a merge operation on two trivial; // classes results in one non-trivial class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:827,Modifiability,extend,extended,827,"// Re-evaluate an SVal with top-level `State->assume`, this ignites; // a RECURSIVE algorithm that will reach a FIXPOINT.; //; // About performance and complexity: Let us assume that in a State we; // have N non-trivial equivalence classes and that all constraints and; // disequality info is related to non-trivial classes. In the worst case,; // we can simplify only one symbol of one class in each iteration. The; // number of symbols in one class cannot grow b/c we replace the old; // symbol with the simplified one. Also, the number of the equivalence; // classes can decrease only, b/c the algorithm does a merge operation; // optionally. We need N iterations in this case to reach the fixpoint.; // Thus, the steps needed to be done in the worst case is proportional to; // N*N.; //; // This worst case scenario can be extended to that case when we have; // trivial classes in the constraints and in the disequality map. This; // case can be reduced to the case with a State where there are only; // non-trivial classes. This is because a merge operation on two trivial; // classes results in one non-trivial class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:136,Performance,perform,performance,136,"// Re-evaluate an SVal with top-level `State->assume`, this ignites; // a RECURSIVE algorithm that will reach a FIXPOINT.; //; // About performance and complexity: Let us assume that in a State we; // have N non-trivial equivalence classes and that all constraints and; // disequality info is related to non-trivial classes. In the worst case,; // we can simplify only one symbol of one class in each iteration. The; // number of symbols in one class cannot grow b/c we replace the old; // symbol with the simplified one. Also, the number of the equivalence; // classes can decrease only, b/c the algorithm does a merge operation; // optionally. We need N iterations in this case to reach the fixpoint.; // Thus, the steps needed to be done in the worst case is proportional to; // N*N.; //; // This worst case scenario can be extended to that case when we have; // trivial classes in the constraints and in the disequality map. This; // case can be reduced to the case with a State where there are only; // non-trivial classes. This is because a merge operation on two trivial; // classes results in one non-trivial class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:355,Usability,simpl,simplify,355,"// Re-evaluate an SVal with top-level `State->assume`, this ignites; // a RECURSIVE algorithm that will reach a FIXPOINT.; //; // About performance and complexity: Let us assume that in a State we; // have N non-trivial equivalence classes and that all constraints and; // disequality info is related to non-trivial classes. In the worst case,; // we can simplify only one symbol of one class in each iteration. The; // number of symbols in one class cannot grow b/c we replace the old; // symbol with the simplified one. Also, the number of the equivalence; // classes can decrease only, b/c the algorithm does a merge operation; // optionally. We need N iterations in this case to reach the fixpoint.; // Thus, the steps needed to be done in the worst case is proportional to; // N*N.; //; // This worst case scenario can be extended to that case when we have; // trivial classes in the constraints and in the disequality map. This; // case can be reduced to the case with a State where there are only; // non-trivial classes. This is because a merge operation on two trivial; // classes results in one non-trivial class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:506,Usability,simpl,simplified,506,"// Re-evaluate an SVal with top-level `State->assume`, this ignites; // a RECURSIVE algorithm that will reach a FIXPOINT.; //; // About performance and complexity: Let us assume that in a State we; // have N non-trivial equivalence classes and that all constraints and; // disequality info is related to non-trivial classes. In the worst case,; // we can simplify only one symbol of one class in each iteration. The; // number of symbols in one class cannot grow b/c we replace the old; // symbol with the simplified one. Also, the number of the equivalence; // classes can decrease only, b/c the algorithm does a merge operation; // optionally. We need N iterations in this case to reach the fixpoint.; // Thus, the steps needed to be done in the worst case is proportional to; // N*N.; //; // This worst case scenario can be extended to that case when we have; // trivial classes in the constraints and in the disequality map. This; // case can be reduced to the case with a State where there are only; // non-trivial classes. This is because a merge operation on two trivial; // classes results in one non-trivial class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:287,Availability,alive,alive,287,"//===----------------------------------------------------------------------===//; // Remove dead symbols from existing constraints; //===----------------------------------------------------------------------===//; /// Scan all symbols referenced by the constraints. If the symbol is not alive; /// as marked in LSymbols, mark it as dead in DSymbols.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:3,Deployability,Update,Update,3,// Update disequality information to not hold any information on the; // removed class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:6,Deployability,Update,Update,6,// 4. Update the state with new maps.; //; // Here we try to be humble and update a map only if it really changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:75,Deployability,update,update,75,// 4. Update the state with new maps.; //; // Here we try to be humble and update a map only if it really changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:115,Integrability,interface,interface,115,"//===------------------------------------------------------------------------===; // assumeSymX methods: protected interface for RangeConstraintManager.; //===------------------------------------------------------------------------===/; // The syntax for ranges below is mathematical, using [x, y] for closed ranges; // and (x, y) for open ranges. These ranges are modular, corresponding with; // a common treatment of C integer overflow. This means that these methods; // do not have to worry about overflow; RangeSet::Intersect can handle such a; // ""wraparound"" range.; // As an example, the range [UINT_MAX-1, 3) contains five values: UINT_MAX-1,; // UINT_MAX, 0, 1, and 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:553,Integrability,wrap,wraparound,553,"//===------------------------------------------------------------------------===; // assumeSymX methods: protected interface for RangeConstraintManager.; //===------------------------------------------------------------------------===/; // The syntax for ranges below is mathematical, using [x, y] for closed ranges; // and (x, y) for open ranges. These ranges are modular, corresponding with; // a common treatment of C integer overflow. This means that these methods; // do not have to worry about overflow; RangeSet::Intersect can handle such a; // ""wraparound"" range.; // As an example, the range [UINT_MAX-1, 3) contains five values: UINT_MAX-1,; // UINT_MAX, 0, 1, and 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp:485,Integrability,interface,interface,485,"//== RangedConstraintManager.cpp --------------------------------*- C++ -*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines RangedConstraintManager, a class that provides a; // range-based constraint manager interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp:15,Usability,simpl,simplify,15,// We can only simplify expressions whose RHS is an integer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp:37,Integrability,wrap,wraparound,37,// Get the type used for calculating wraparound.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp:3,Usability,Simpl,Simplification,3,"// Simplification: translate an assume of a constraint of the form; // ""(exp comparison_op expr) != 0"" to true into an assume of; // ""exp comparison_op expr"" to true. (And similarly, an assume of the form; // ""(exp comparison_op expr) == 0"" to true into an assume of; // ""exp comparison_op expr"" to false.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp:37,Integrability,wrap,wraparound,37,// Get the type used for calculating wraparound.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp:18,Usability,simpl,simple,18,"// We only handle simple comparisons of the form ""$sym == constant""; // or ""($sym+constant1) == constant2"".; // The adjustment is ""constant1"" in the above expression. It's used to; // ""slide"" the solution range around for modular arithmetic. For example,; // x < 4 has the solution [0, 3]. x+2 < 4 has the solution [0-2, 3-2], which; // in modular arithmetic is [0, 1] U [UINT_MAX-1, UINT_MAX]. It's up to; // the subclasses of SimpleConstraintManager to handle the adjustment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp:428,Usability,Simpl,SimpleConstraintManager,428,"// We only handle simple comparisons of the form ""$sym == constant""; // or ""($sym+constant1) == constant2"".; // The adjustment is ""constant1"" in the above expression. It's used to; // ""slide"" the solution range around for modular arithmetic. For example,; // x < 4 has the solution [0, 3]. x+2 < 4 has the solution [0-2, 3-2], which; // in modular arithmetic is [0, 1] U [UINT_MAX-1, UINT_MAX]. It's up to; // the subclasses of SimpleConstraintManager to handle the adjustment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:439,Deployability,update,updated,439,"// This flag indicates whether the current bindings are within the analysis; // that has started from main(). It affects how we perform loads from; // global variables that have initializers: if we have observed the; // program execution from the start and we know that these variables; // have not been overwritten yet, we can be sure that their initializers; // are still relevant. This flag never gets changed when the bindings are; // updated, so it could potentially be moved into RegionStoreManager; // (as if it's the same bindings but a different loading procedure); // however that would have made the manager needlessly stateful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:158,Modifiability,variab,variables,158,"// This flag indicates whether the current bindings are within the analysis; // that has started from main(). It affects how we perform loads from; // global variables that have initializers: if we have observed the; // program execution from the start and we know that these variables; // have not been overwritten yet, we can be sure that their initializers; // are still relevant. This flag never gets changed when the bindings are; // updated, so it could potentially be moved into RegionStoreManager; // (as if it's the same bindings but a different loading procedure); // however that would have made the manager needlessly stateful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:276,Modifiability,variab,variables,276,"// This flag indicates whether the current bindings are within the analysis; // that has started from main(). It affects how we perform loads from; // global variables that have initializers: if we have observed the; // program execution from the start and we know that these variables; // have not been overwritten yet, we can be sure that their initializers; // are still relevant. This flag never gets changed when the bindings are; // updated, so it could potentially be moved into RegionStoreManager; // (as if it's the same bindings but a different loading procedure); // however that would have made the manager needlessly stateful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:128,Performance,perform,perform,128,"// This flag indicates whether the current bindings are within the analysis; // that has started from main(). It affects how we perform loads from; // global variables that have initializers: if we have observed the; // program execution from the start and we know that these variables; // have not been overwritten yet, we can be sure that their initializers; // are still relevant. This flag never gets changed when the bindings are; // updated, so it could potentially be moved into RegionStoreManager; // (as if it's the same bindings but a different loading procedure); // however that would have made the manager needlessly stateful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:136,Performance,load,loads,136,"// This flag indicates whether the current bindings are within the analysis; // that has started from main(). It affects how we perform loads from; // global variables that have initializers: if we have observed the; // program execution from the start and we know that these variables; // have not been overwritten yet, we can be sure that their initializers; // are still relevant. This flag never gets changed when the bindings are; // updated, so it could potentially be moved into RegionStoreManager; // (as if it's the same bindings but a different loading procedure); // however that would have made the manager needlessly stateful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:555,Performance,load,loading,555,"// This flag indicates whether the current bindings are within the analysis; // that has started from main(). It affects how we perform loads from; // global variables that have initializers: if we have observed the; // program execution from the start and we know that these variables; // have not been overwritten yet, we can be sure that their initializers; // are still relevant. This flag never gets changed when the bindings are; // updated, so it could potentially be moved into RegionStoreManager; // (as if it's the same bindings but a different loading procedure); // however that would have made the manager needlessly stateful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:102,Testability,log,logic,102,//===----------------------------------------------------------------------===//; // Main RegionStore logic.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:308,Integrability,depend,dependent,308,"/// The largest number of fields a struct can have and still be; /// considered ""small"".; ///; /// This is currently used to decide whether or not it is worth ""forcing"" a; /// LazyCompoundVal on bind.; ///; /// This is controlled by 'region-store-small-struct-limit' option.; /// To disable all small-struct-dependent behavior, set the option to ""0"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:309,Integrability,depend,dependent,309,"/// The largest number of element an array can have and still be; /// considered ""small"".; ///; /// This is currently used to decide whether or not it is worth ""forcing"" a; /// LazyCompoundVal on bind.; ///; /// This is controlled by 'region-store-small-struct-limit' option.; /// To disable all small-struct-dependent behavior, set the option to ""0"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:18,Integrability,interface,interface,18,// Part of public interface to class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:396,Availability,error,error-prone,396,"// FIXME: The offsets of empty bases can be tricky because of; // of the so called ""empty base class optimization"".; // If a base class has been optimized out; // we should not try to create a binding, otherwise we should.; // Unfortunately, at the moment ASTRecordLayout doesn't expose; // the actual sizes of the empty bases; // and trying to infer them from offsets/alignments; // seems to be error-prone and non-trivial because of the trailing padding.; // As a temporary mitigation we don't create bindings for empty bases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:101,Performance,optimiz,optimization,101,"// FIXME: The offsets of empty bases can be tricky because of; // of the so called ""empty base class optimization"".; // If a base class has been optimized out; // we should not try to create a binding, otherwise we should.; // Unfortunately, at the moment ASTRecordLayout doesn't expose; // the actual sizes of the empty bases; // and trying to infer them from offsets/alignments; // seems to be error-prone and non-trivial because of the trailing padding.; // As a temporary mitigation we don't create bindings for empty bases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:145,Performance,optimiz,optimized,145,"// FIXME: The offsets of empty bases can be tricky because of; // of the so called ""empty base class optimization"".; // If a base class has been optimized out; // we should not try to create a binding, otherwise we should.; // Unfortunately, at the moment ASTRecordLayout doesn't expose; // the actual sizes of the empty bases; // and trying to infer them from offsets/alignments; // seems to be error-prone and non-trivial because of the trailing padding.; // As a temporary mitigation we don't create bindings for empty bases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:280,Security,expose,expose,280,"// FIXME: The offsets of empty bases can be tricky because of; // of the so called ""empty base class optimization"".; // If a base class has been optimized out; // we should not try to create a binding, otherwise we should.; // Unfortunately, at the moment ASTRecordLayout doesn't expose; // the actual sizes of the empty bases; // and trying to infer them from offsets/alignments; // seems to be error-prone and non-trivial because of the trailing padding.; // As a temporary mitigation we don't create bindings for empty bases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:431,Deployability,update,updated,431,"/// Attempt to extract the fields of \p LCV and bind them to the struct region; /// \p R.; ///; /// This path is used when it seems advantageous to ""force"" loading the values; /// within a LazyCompoundVal to bind memberwise to the struct region, rather; /// than using a Default binding at the base of the entire region. This is a; /// heuristic attempting to avoid building long chains of LazyCompoundVals.; ///; /// \returns The updated store bindings, or \c std::nullopt if binding; /// non-lazily would be too expensive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:156,Performance,load,loading,156,"/// Attempt to extract the fields of \p LCV and bind them to the struct region; /// \p R.; ///; /// This path is used when it seems advantageous to ""force"" loading the values; /// within a LazyCompoundVal to bind memberwise to the struct region, rather; /// than using a Default binding at the base of the entire region. This is a; /// heuristic attempting to avoid building long chains of LazyCompoundVals.; ///; /// \returns The updated store bindings, or \c std::nullopt if binding; /// non-lazily would be too expensive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:360,Safety,avoid,avoid,360,"/// Attempt to extract the fields of \p LCV and bind them to the struct region; /// \p R.; ///; /// This path is used when it seems advantageous to ""force"" loading the values; /// within a LazyCompoundVal to bind memberwise to the struct region, rather; /// than using a Default binding at the base of the entire region. This is a; /// heuristic attempting to avoid building long chains of LazyCompoundVals.; ///; /// \returns The updated store bindings, or \c std::nullopt if binding; /// non-lazily would be too expensive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:4,Usability,Clear,Clears,4,/// Clears out all bindings in the given region and assigns a new value; /// as a Default binding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:92,Testability,log,logic,92,/// Return the value bound to specified location in a given state.; ///; /// The high level logic for this method is this:; /// getBinding (L); /// if L has binding; /// return L's binding; /// else if L is in killset; /// return unknown; /// else; /// if L is on stack or heap; /// return undefined; /// else; /// return symbolic,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:16,Performance,cache,cached,16,"/// Returns the cached set of interesting SVals contained within a lazy; /// binding.; ///; /// The precise value of ""interesting"" is determined for the purposes of; /// RegionStore's internal analysis. It must always contain all regions and; /// symbols, but may omit constants and other kinds of SVal.; ///; /// In contrast to compound values, LazyCompoundVals are also added; /// to the 'interesting values' list in addition to the child interesting; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:323,Modifiability,extend,extend,323,"/// Collects all bindings in \p Cluster that may refer to bindings within; /// \p Top.; ///; /// Each binding is a pair whose \c first is the key (a BindingKey) and whose; /// \c second is the value (an SVal).; ///; /// The \p IncludeAllDefaultBindings parameter specifies whether to include; /// default bindings that may extend beyond \p Top itself, e.g. if \p Top is; /// an aggregate within a larger aggregate with a default binding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:39,Modifiability,variab,variables,39,// Lambdas can affect all static local variables without explicitly; // capturing those.; // We invalidate all static locals referenced inside the lambda body.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:47,Modifiability,variab,variables,47,"// BlockDataRegion? If so, invalidate captured variables that are passed; // by reference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:69,Safety,detect,detection,69,// Bound symbolic regions need to be invalidated for dead symbol; // detection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:85,Performance,Load,Loading,85,//===----------------------------------------------------------------------===//; // Loading values from regions.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:102,Availability,error,errors,102,"// For access to concrete addresses, return UnknownVal. Checks; // for null dereferences (and similar errors) are done by checkers, not; // the Store.; // FIXME: We can consider lazily symbolicating such memory, but we really; // should defer this when we can reason easily about symbolicating arrays; // of bytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:7,Security,access,access,7,"// For access to concrete addresses, return UnknownVal. Checks; // for null dereferences (and similar errors) are done by checkers, not; // the Store.; // FIXME: We can consider lazily symbolicating such memory, but we really; // should defer this when we can reason easily about symbolicating arrays; // of bytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:8,Safety,detect,detect,8,// Auto-detect the binding type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:27,Performance,perform,perform,27,"// FIXME: Here we actually perform an implicit conversion from the loaded; // value to the element type. Eventually we want to compose these values; // more intelligently. For example, an 'element' can encompass multiple; // bound regions (e.g., several bound bytes), or could be a subset of; // a larger value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:67,Performance,load,loaded,67,"// FIXME: Here we actually perform an implicit conversion from the loaded; // value to the element type. Eventually we want to compose these values; // more intelligently. For example, an 'element' can encompass multiple; // bound regions (e.g., several bound bytes), or could be a subset of; // a larger value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:27,Performance,perform,perform,27,"// FIXME: Here we actually perform an implicit conversion from the loaded; // value to the ivar type. What we should model is stores to ivars; // that blow past the extent of the ivar. If the address of the ivar is; // reinterpretted, it is possible we stored a different value that could; // fit within the ivar. Either we need to cast these when storing them; // or reinterpret them lazily (as we do here).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:67,Performance,load,loaded,67,"// FIXME: Here we actually perform an implicit conversion from the loaded; // value to the ivar type. What we should model is stores to ivars; // that blow past the extent of the ivar. If the address of the ivar is; // reinterpretted, it is possible we stored a different value that could; // fit within the ivar. Either we need to cast these when storing them; // or reinterpret them lazily (as we do here).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:91,Modifiability,variab,variable,91,"// FIXME: Here we actually perform an implicit conversion from the loaded; // value to the variable type. What we should model is stores to variables; // that blow past the extent of the variable. If the address of the; // variable is reinterpretted, it is possible we stored a different value; // that could fit within the variable. Either we need to cast these when; // storing them or reinterpret them lazily (as we do here).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:140,Modifiability,variab,variables,140,"// FIXME: Here we actually perform an implicit conversion from the loaded; // value to the variable type. What we should model is stores to variables; // that blow past the extent of the variable. If the address of the; // variable is reinterpretted, it is possible we stored a different value; // that could fit within the variable. Either we need to cast these when; // storing them or reinterpret them lazily (as we do here).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:187,Modifiability,variab,variable,187,"// FIXME: Here we actually perform an implicit conversion from the loaded; // value to the variable type. What we should model is stores to variables; // that blow past the extent of the variable. If the address of the; // variable is reinterpretted, it is possible we stored a different value; // that could fit within the variable. Either we need to cast these when; // storing them or reinterpret them lazily (as we do here).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:223,Modifiability,variab,variable,223,"// FIXME: Here we actually perform an implicit conversion from the loaded; // value to the variable type. What we should model is stores to variables; // that blow past the extent of the variable. If the address of the; // variable is reinterpretted, it is possible we stored a different value; // that could fit within the variable. Either we need to cast these when; // storing them or reinterpret them lazily (as we do here).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:324,Modifiability,variab,variable,324,"// FIXME: Here we actually perform an implicit conversion from the loaded; // value to the variable type. What we should model is stores to variables; // that blow past the extent of the variable. If the address of the; // variable is reinterpretted, it is possible we stored a different value; // that could fit within the variable. Either we need to cast these when; // storing them or reinterpret them lazily (as we do here).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:27,Performance,perform,perform,27,"// FIXME: Here we actually perform an implicit conversion from the loaded; // value to the variable type. What we should model is stores to variables; // that blow past the extent of the variable. If the address of the; // variable is reinterpretted, it is possible we stored a different value; // that could fit within the variable. Either we need to cast these when; // storing them or reinterpret them lazily (as we do here).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:67,Performance,load,loaded,67,"// FIXME: Here we actually perform an implicit conversion from the loaded; // value to the variable type. What we should model is stores to variables; // that blow past the extent of the variable. If the address of the; // variable is reinterpretted, it is possible we stored a different value; // that could fit within the variable. Either we need to cast these when; // storing them or reinterpret them lazily (as we do here).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:91,Energy Efficiency,allocate,allocated,91,// All stack variables are considered to have undefined values; // upon creation. All heap allocated blocks are considered to; // have undefined values as well unless they are explicitly bound; // to specific values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:13,Modifiability,variab,variables,13,// All stack variables are considered to have undefined values; // upon creation. All heap allocated blocks are considered to; // have undefined values as well unless they are explicitly bound; // to specific values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:662,Performance,perform,performance,662,"/// This is a helper function for `getConstantValFromConstArrayInitializer`.; ///; /// Return an array of offsets from nested ElementRegions and a root base; /// region. The array is never empty and a base region is never null.; ///; /// E.g. for `Element{Element{Element{VarRegion},1},2},3}` returns { 3, 2, 1 }.; /// This represents an access through indirection: `arr[1][2][3];`; ///; /// \param ER The given (possibly nested) ElementRegion.; ///; /// \note The result array is in the reverse order of indirection expression:; /// arr[1][2][3] -> { 3, 2, 1 }. This helps to provide complexity O(n), where n; /// is a number of indirections. It may not affect performance in real-life; /// code, though.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:338,Security,access,access,338,"/// This is a helper function for `getConstantValFromConstArrayInitializer`.; ///; /// Return an array of offsets from nested ElementRegions and a root base; /// region. The array is never empty and a base region is never null.; ///; /// E.g. for `Element{Element{Element{VarRegion},1},2},3}` returns { 3, 2, 1 }.; /// This represents an access through indirection: `arr[1][2][3];`; ///; /// \param ER The given (possibly nested) ElementRegion.; ///; /// \note The result array is in the reverse order of indirection expression:; /// arr[1][2][3] -> { 3, 2, 1 }. This helps to provide complexity O(n), where n; /// is a number of indirections. It may not affect performance in real-life; /// code, though.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:651,Security,access,access,651,"/// This is a helper function for `getConstantValFromConstArrayInitializer`.; ///; /// Convert array of offsets from `SVal` to `uint64_t` in consideration of; /// respective array extents.; /// \param SrcOffsets [in] The array of offsets of type `SVal` in reversed; /// order (expectedly received from `getElementRegionOffsetsWithBase`).; /// \param ArrayExtents [in] The array of extents.; /// \param DstOffsets [out] The array of offsets of type `uint64_t`.; /// \returns:; /// - `std::nullopt` for successful convertion.; /// - `UndefinedVal` or `UnknownVal` otherwise. It's expected that this SVal; /// will be returned as a suitable value of the access operation.; /// which should be returned as a correct; ///; /// \example:; /// const int arr[10][20][30] = {}; // ArrayExtents { 10, 20, 30 }; /// int x1 = arr[4][5][6]; // SrcOffsets { NonLoc(6), NonLoc(5), NonLoc(4) }; /// // DstOffsets { 4, 5, 6 }; /// // returns std::nullopt; /// int x2 = arr[42][5][-6]; // returns UndefinedVal; /// int x3 = arr[4][5][x2]; // returns UnknownVal",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:859,Testability,assert,assertion,859,"/// Returns an SVal, if possible, for the specified position of an; /// initialization list.; ///; /// \param ILE The given initialization list.; /// \param Offsets The array of unsigned offsets. E.g. for the expression; /// `int x = arr[1][2][3];` an array should be { 1, 2, 3 }.; /// \param ElemT The type of the result SVal expression.; /// \return Optional SVal for the particular position in the initialization; /// list. E.g. for the list `{{1, 2},[3, 4],{5, 6}, {}}` offsets:; /// - {1, 1} returns SVal{4}, because it's the second position in the second; /// sublist;; /// - {3, 0} returns SVal{0}, because there's no explicit value at this; /// position in the sublist.; ///; /// NOTE: Inorder to get a valid SVal, a caller shall guarantee valid offsets; /// for the given initialization list. Otherwise SVal can be an equivalent to 0; /// or lead to assertion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:17,Performance,load,loads,17,"// FIXME: Handle loads from strings where the literal is treated as; // an integer, e.g., *((unsigned int*)""hello""). Such loads are UB according; // to C++20 7.2.1.11 [basic.lval].",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:122,Performance,load,loads,122,"// FIXME: Handle loads from strings where the literal is treated as; // an integer, e.g., *((unsigned int*)""hello""). Such loads are UB according; // to C++20 7.2.1.11 [basic.lval].",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:13,Performance,load,loads,13,"// Check for loads from a code text region. For such loads, just give up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:53,Performance,load,loads,53,"// Check for loads from a code text region. For such loads, just give up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:21,Modifiability,variab,variable,21,"// Either the record variable or the field has an initializer that we can; // trust. We trust initializers of constants and, additionally, respect; // initializers of globals when analyzing main().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:32,Security,access,accessing,32,"// Handle the case where we are accessing into a larger scalar object.; // For example, this handles:; // struct header {; // unsigned a : 1;; // unsigned b : 1;; // };; // struct parse_t {; // unsigned bits0 : 1;; // unsigned bits2 : 2; // <-- header; // unsigned bits4 : 4;; // };; // int parse(parse_t *p) {; // unsigned copy = p->bits2;; // header *bits = (header *)&copy;; // return bits->b; <-- here; // }",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:307,Modifiability,variab,variable,307,"// FIXME: This is a hack to deal with RegionStore's inability to distinguish a; // default value for /part/ of an aggregate from a default value for the; // /entire/ aggregate. The most common case of this is when struct Outer; // has as its first member a struct Inner, which is copied in from a stack; // variable. In this case, even if the Outer's default value is symbolic, 0,; // or unknown, it gets overridden by the Inner's default value of undefined.; //; // This is a general problem -- if the Inner is zero-initialized, the Outer; // will now look zero-initialized. The proper way to solve this is with a; // new version of RegionStore that tracks the extent of a binding as well; // as the offset.; //; // This hack only takes care of the undefined case because that can very; // quickly result in a warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:307,Modifiability,variab,variable,307,"// FIXME: This is a hack to deal with RegionStore's inability to distinguish a; // default value for /part/ of an aggregate from a default value for the; // /entire/ aggregate. The most common case of this is when struct Outer; // has as its first member a struct Inner, which is copied in from a stack; // variable. In this case, even if the Outer's default value is symbolic, 0,; // or unknown, it gets overridden by the Inner's default value of undefined.; //; // This is a general problem -- if the Inner is zero-initialized, the Outer; // will now look zero-initialized. The proper way to solve this is with a; // new version of RegionStore that tracks the extent of a binding as well; // as the offset.; //; // This hack only takes care of the undefined case because that can very; // quickly result in a warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:121,Deployability,install,installed,121,"// If our super region is a field or element itself, walk up the region; // hierarchy to see if there is a default value installed in an ancestor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:118,Security,access,accessing,118,"// FIXME: We also need to take ElementRegions with symbolic indexes into; // account. This case handles both directly accessing an ElementRegion; // with a symbolic offset, but also fields within an element with; // a symbolic offset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:10,Modifiability,variab,variable,10,"// If the variable is const qualified and has an initializer but; // we couldn't evaluate initializer to a value, treat the value as; // unknown.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:86,Modifiability,variab,variables,86,// This must come after the check for constants because closure-captured; // constant variables may appear in UnknownSpaceRegion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:26,Modifiability,variab,variables,26,"// Function-scoped static variables are default-initialized to 0; if they; // have an initializer, it would have been processed by now.; // FIXME: This is only true when we're starting analysis from main().; // We're losing a lot of coverage here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:20,Performance,cache,cache,20,"// First, check the cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:37,Performance,cache,cached,37,"// If we don't have a list of values cached, start constructing it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:3,Usability,Clear,Clear,3,// Clear out bindings that may overlap with this binding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:140,Testability,assert,assertion,140,"// We can't represent values of this type, but we still need to set a value; // to record that the region has been initialized.; // If this assertion ever fires, a new case should be added above -- we; // should know how to default-initialize any value we can symbolicate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:75,Modifiability,variab,variable,75,"// If the init list is shorter than the array length (or the array has; // variable length), set the array default value. Values that are already set; // are not overwritten.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:65,Testability,log,logic,65,"// We may get non-CompoundVal accidentally due to imprecise cast logic or; // that we are binding symbolic struct value. Kill the field values, and if; // the value is symbolic go and bind it as a ""default"" binding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:65,Testability,log,logic,65,"// We may get non-CompoundVal accidentally due to imprecise cast logic or; // that we are binding symbolic struct value. Kill the field values, and if; // the value is symbolic go and bind it as a ""default"" binding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:1032,Safety,safe,safer,1032,"// The raw CompoundVal is essentially a symbolic InitListExpr: an (immutable); // list of other values. It appears pretty much only when there's an actual; // initializer list expression in the program, and the analyzer tries to; // unwrap it as soon as possible.; // This code is where such unwrap happens: when the compound value is put into; // the object that it was supposed to initialize (it's an *initializer* list,; // after all), instead of binding the whole value to the whole object, we bind; // sub-values to sub-objects. Sub-values may themselves be compound values,; // and in this case the procedure becomes recursive.; // FIXME: The annoying part about compound values is that they don't carry; // any sort of information about which value corresponds to which sub-object.; // It's simply a list of values in the middle of nowhere; we expect to match; // them to sub-objects, essentially, ""by index"": first value binds to; // the first field, second value binds to the second field, etc.; // It would have been much safer to organize non-lazy compound values as; // a mapping from fields/bases to values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:798,Usability,simpl,simply,798,"// The raw CompoundVal is essentially a symbolic InitListExpr: an (immutable); // list of other values. It appears pretty much only when there's an actual; // initializer list expression in the program, and the analyzer tries to; // unwrap it as soon as possible.; // This code is where such unwrap happens: when the compound value is put into; // the object that it was supposed to initialize (it's an *initializer* list,; // after all), instead of binding the whole value to the whole object, we bind; // sub-values to sub-objects. Sub-values may themselves be compound values,; // and in this case the procedure becomes recursive.; // FIXME: The annoying part about compound values is that they don't carry; // any sort of information about which value corresponds to which sub-object.; // It's simply a list of values in the middle of nowhere; we expect to match; // them to sub-objects, essentially, ""by index"": first value binds to; // the first field, second value binds to the second field, etc.; // It would have been much safer to organize non-lazy compound values as; // a mapping from fields/bases to values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:243,Integrability,message,message,243,"// If the object was constructed with a constructor, its value is a; // LazyCompoundVal. If it's a raw CompoundVal, it means that we're; // performing aggregate initialization. The only exception from this; // rule is sending an Objective-C++ message that returns a C++ object; // to a nil receiver; in this case the semantics is to return a; // zero-initialized object even if it's a C++ object that doesn't have; // this sort of constructor; the CompoundVal is empty in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:140,Performance,perform,performing,140,"// If the object was constructed with a constructor, its value is a; // LazyCompoundVal. If it's a raw CompoundVal, it means that we're; // performing aggregate initialization. The only exception from this; // rule is sending an Objective-C++ message that returns a C++ object; // to a nil receiver; in this case the semantics is to return a; // zero-initialized object even if it's a C++ object that doesn't have; // this sort of constructor; the CompoundVal is empty in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:13,Modifiability,inherit,inheritance,13,// (Multiple inheritance is fine though.),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:3,Deployability,Update,Update,3,// Update the set of live symbols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:159,Deployability,update,update,159,"// We have now scanned the store, marking reachable regions and symbols; // as live. We now remove all the regions that are dead from the store; // as well as update DSymbols with the set symbols that are now dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SarifDiagnostics.cpp:17,Availability,error,error,17,// TODO: Emit an error here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SarifDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SarifDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleConstraintManager.cpp:484,Integrability,interface,interface,484,"//== SimpleConstraintManager.cpp --------------------------------*- C++ -*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines SimpleConstraintManager, a class that provides a; // simplified constraint manager interface, compared to ConstraintManager.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleConstraintManager.cpp:5,Usability,Simpl,SimpleConstraintManager,5,"//== SimpleConstraintManager.cpp --------------------------------*- C++ -*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines SimpleConstraintManager, a class that provides a; // simplified constraint manager interface, compared to ConstraintManager.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleConstraintManager.cpp:401,Usability,Simpl,SimpleConstraintManager,401,"//== SimpleConstraintManager.cpp --------------------------------*- C++ -*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines SimpleConstraintManager, a class that provides a; // simplified constraint manager interface, compared to ConstraintManager.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleConstraintManager.cpp:454,Usability,simpl,simplified,454,"//== SimpleConstraintManager.cpp --------------------------------*- C++ -*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines SimpleConstraintManager, a class that provides a; // simplified constraint manager interface, compared to ConstraintManager.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleConstraintManager.cpp:63,Usability,simpl,simplify,63,// Just add the constraint to the expression without trying to simplify.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleConstraintManager.cpp:63,Usability,simpl,simplify,63,// Just add the constraint to the expression without trying to simplify.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:3,Usability,Simpl,SimpleSValBuilder,3,"// SimpleSValBuilder.cpp - A basic SValBuilder -----------------------*- C++ -*-; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines SimpleSValBuilder, a basic implementation of SValBuilder.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:401,Usability,Simpl,SimpleSValBuilder,401,"// SimpleSValBuilder.cpp - A basic SValBuilder -----------------------*- C++ -*-; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines SimpleSValBuilder, a basic implementation of SValBuilder.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:13,Usability,simpl,simplifySValOnce,13,"// With one `simplifySValOnce` call, a compound symbols might collapse to; // simpler symbol tree that is still possible to further simplify. Thus, we; // do the simplification on a new symbol tree until we reach the simplest; // form, i.e. the fixpoint.; // Consider the following symbol `(b * b) * b * b` which has this tree:; // *; // / \; // * b; // / \; // / b; // (b * b); // Now, if the `b * b == 1` new constraint is added then during the first; // iteration we have the following transformations:; // * *; // / \ / \; // * b --> b b; // / \; // / b; // 1; // We need another iteration to reach the final result `1`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:78,Usability,simpl,simpler,78,"// With one `simplifySValOnce` call, a compound symbols might collapse to; // simpler symbol tree that is still possible to further simplify. Thus, we; // do the simplification on a new symbol tree until we reach the simplest; // form, i.e. the fixpoint.; // Consider the following symbol `(b * b) * b * b` which has this tree:; // *; // / \; // * b; // / \; // / b; // (b * b); // Now, if the `b * b == 1` new constraint is added then during the first; // iteration we have the following transformations:; // * *; // / \ / \; // * b --> b b; // / \; // / b; // 1; // We need another iteration to reach the final result `1`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:132,Usability,simpl,simplify,132,"// With one `simplifySValOnce` call, a compound symbols might collapse to; // simpler symbol tree that is still possible to further simplify. Thus, we; // do the simplification on a new symbol tree until we reach the simplest; // form, i.e. the fixpoint.; // Consider the following symbol `(b * b) * b * b` which has this tree:; // *; // / \; // * b; // / \; // / b; // (b * b); // Now, if the `b * b == 1` new constraint is added then during the first; // iteration we have the following transformations:; // * *; // / \ / \; // * b --> b b; // / \; // / b; // 1; // We need another iteration to reach the final result `1`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:162,Usability,simpl,simplification,162,"// With one `simplifySValOnce` call, a compound symbols might collapse to; // simpler symbol tree that is still possible to further simplify. Thus, we; // do the simplification on a new symbol tree until we reach the simplest; // form, i.e. the fixpoint.; // Consider the following symbol `(b * b) * b * b` which has this tree:; // *; // / \; // * b; // / \; // / b; // (b * b); // Now, if the `b * b == 1` new constraint is added then during the first; // iteration we have the following transformations:; // * *; // / \ / \; // * b --> b b; // / \; // / b; // 1; // We need another iteration to reach the final result `1`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:217,Usability,simpl,simplest,217,"// With one `simplifySValOnce` call, a compound symbols might collapse to; // simpler symbol tree that is still possible to further simplify. Thus, we; // do the simplification on a new symbol tree until we reach the simplest; // form, i.e. the fixpoint.; // Consider the following symbol `(b * b) * b * b` which has this tree:; // *; // / \; // * b; // / \; // / b; // (b * b); // Now, if the `b * b == 1` new constraint is added then during the first; // iteration we have the following transformations:; // * *; // / \ / \; // * b --> b b; // / \; // / b; // 1; // We need another iteration to reach the final result `1`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:62,Usability,simpl,simplifying,62,"/// Evaluates a given SVal by recursively evaluating and; /// simplifying the children SVals. If the SVal has only one possible; /// (integer) value, that value is returned. Otherwise, returns NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:57,Usability,simpl,simplifying,57,"/// Evaluates a given SVal by recursively evaluating and simplifying the; /// children SVals, then returns its minimal possible (integer) value. If the; /// constraint manager cannot provide a meaningful answer, this returns NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:57,Usability,simpl,simplifying,57,"/// Evaluates a given SVal by recursively evaluating and simplifying the; /// children SVals, then returns its maximal possible (integer) value. If the; /// constraint manager cannot provide a meaningful answer, this returns NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:12,Energy Efficiency,reduce,reduce,12,// We can't reduce this case; just treat it normally.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:77,Integrability,Wrap,Wrap,77,// Idempotent ops (like a*1) can still change the type of an expression.; // Wrap the LHS up in a NonLoc again and let evalCast do the; // dirty work.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:52,Usability,simpl,simplified,52,"// If we reach this point, the expression cannot be simplified.; // Make a SymbolVal for the entire expression, after converting the RHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:30,Modifiability,extend,extend,30,"// If the value is too small, extend it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:169,Performance,perform,performed,169,"// See if Sym is known to be within [min/4, max/4], where min and max; // are the bounds of the symbol's integral type. With such symbols,; // some manipulations can be performed without the risk of overflow.; // assume() doesn't cause infinite recursion because we should be dealing; // with simpler symbols on every recursive call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:191,Safety,risk,risk,191,"// See if Sym is known to be within [min/4, max/4], where min and max; // are the bounds of the symbol's integral type. With such symbols,; // some manipulations can be performed without the risk of overflow.; // assume() doesn't cause infinite recursion because we should be dealing; // with simpler symbols on every recursive call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:293,Usability,simpl,simpler,293,"// See if Sym is known to be within [min/4, max/4], where min and max; // are the bounds of the symbol's integral type. With such symbols,; // some manipulations can be performed without the risk of overflow.; // assume() doesn't cause infinite recursion because we should be dealing; // with simpler symbols on every recursive call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:23,Energy Efficiency,reduce,reduce,23,"// Fail to decompose: ""reduce"" the problem to the ""$x + 0"" case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:3,Usability,Simpl,Simplify,3,"// Simplify ""(LSym + LInt) Op (RSym + RInt)"" assuming all values are of the; // same signed integral type and no overflows occur (which should be checked; // by the caller).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:13,Usability,Simpl,Simplify,13,"// Shortcut: Simplify ""$x + 0"" to ""$x"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:99,Usability,simpl,simplified,99,// Constraints may have changed since the creation of a bound SVal. Check if; // the values can be simplified based on those new constraints.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:51,Performance,perform,perform,51,"// If we're dealing with two known constants, just perform the operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:428,Safety,avoid,avoid,428,"// FIXME: At this point the constant folding claims that the result; // of a bitwise shift is undefined. However, constant folding; // relies on the inaccurate type information that is stored in the; // bit size of APSInt objects, and if we reached this point, then; // the checker core.BitwiseShift already determined that the shift; // is valid (in a PreStmt callback, by querying the real type from; // the AST node).; // To avoid embarrassing false positives, let's just say that we; // don't know anything about the result of the shift.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:25,Usability,simpl,simple,25,// We only handle LHS as simple symbols or SymIntExprs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:13,Testability,log,logical,13,// Is this a logical not? (!x is represented as x == 0.),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:46,Usability,Simpl,Simplify,46,// We know how to negate certain expressions. Simplify them here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:102,Usability,simpl,simply,102,"// Next, see if the two FRs have the same super-region.; // FIXME: This doesn't handle casts yet, and simply stripping the casts; // doesn't help.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:107,Modifiability,inherit,inheritance,107,// Make sure the two FRs are from the same kind of record. Just in case!; // FIXME: This is probably where inheritance would be a problem.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:58,Availability,down,downstream,58,"// This is used in debug builds only for now because some downstream users; // may hit this assert in their subsequent merges.; // There are still places in the analyzer where equal bitwidth Locs; // are compared, and need to be found and corrected. Recent previous fixes have; // addressed the known problems of making NULLs with specific bitwidths; // for Loc comparisons along with deprecation of APIs for the same purpose.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:92,Testability,assert,assert,92,"// This is used in debug builds only for now because some downstream users; // may hit this assert in their subsequent merges.; // There are still places in the analyzer where equal bitwidth Locs; // are compared, and need to be found and corrected. Recent previous fixes have; // addressed the known problems of making NULLs with specific bitwidths; // for Loc comparisons along with deprecation of APIs for the same purpose.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:19,Testability,log,logic,19,// FIXME: all this logic will change if/when we have MemRegion::getLocation().,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:3,Testability,Assert,Assert,3,"// Assert that bitwidth of lhs and rhs are the same.; // This can happen if two different address spaces are used,; // and the bitwidths of the address spaces are different.; // See LIT case clang/test/Analysis/cstring-checker-addressspace.c; // FIXME: See comment above in the function assertEqualBitWidths",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:197,Testability,test,test,197,"// Assert that bitwidth of lhs and rhs are the same.; // This can happen if two different address spaces are used,; // and the bitwidths of the address spaces are different.; // See LIT case clang/test/Analysis/cstring-checker-addressspace.c; // FIXME: See comment above in the function assertEqualBitWidths",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:287,Testability,assert,assertEqualBitWidths,287,"// Assert that bitwidth of lhs and rhs are the same.; // This can happen if two different address spaces are used,; // and the bitwidths of the address spaces are different.; // See LIT case clang/test/Analysis/cstring-checker-addressspace.c; // FIXME: See comment above in the function assertEqualBitWidths",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:143,Integrability,depend,depending,143,"// There may be two labels for the same location, and a function region may; // have the same address as a label at the start of the function (depending; // on the ABI).; // FIXME: we can probably do a comparison against other MemRegions, though.; // FIXME: is there a way to tell if two labels refer to the same location?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:40,Performance,perform,perform,40,"// If both operands are constants, just perform the operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:71,Testability,test,test,71,"// Special case comparisons against NULL.; // This must come after the test if the RHS is a symbol, which is used to; // build constraints. The address of any non-symbolic region is guaranteed; // to be non-NULL, as is any label.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:66,Testability,test,test,66,"// Special case comparisons to NULL.; // This must come after the test if the LHS is a symbol, which is used to; // build constraints. The address of any non-symbolic region is guaranteed; // to be non-NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:18,Integrability,wrap,wrap,18,"// If both values wrap regions, see if they're from different base regions.; // Note, heap base symbolic regions are assumed to not alias with; // each other; for example, we assume that malloc returns different address; // on each invocation.; // FIXME: ObjC object pointers always reside on the heap, but currently; // we treat their memory space as unknown, because symbolic pointers; // to ObjC objects may alias. There should be a way to construct; // possibly-aliasing heap-based regions. For instance, MacOSXApiChecker; // guesses memory space for ObjC object pointers manually instead of; // relying on us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:12,Performance,perform,perform,12,// Actually perform the operation.; // evalBinOpNN expects the two indexes to already be the right type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:81,Integrability,Depend,Depending,81,"// We need to know the type of the pointer in order to add an integer to it.; // Depending on the type, different amount of bytes is added.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:26,Availability,reliab,reliable,26,"// TODO: Is this actually reliable? Maybe improving our MemRegion; // hierarchy to provide typed regions for all non-void pointers would be; // better. For instance, we cannot extend this towards LocAsInteger; // operations, where result type of the expression is integer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:176,Modifiability,extend,extend,176,"// TODO: Is this actually reliable? Maybe improving our MemRegion; // hierarchy to provide typed regions for all non-void pointers would be; // better. For instance, we cannot extend this towards LocAsInteger; // operations, where result type of the expression is integer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:117,Usability,simpl,simplifications,117,"// For now, this function tries to constant-fold symbols inside a; // nonloc::SymbolVal, and does nothing else. More simplifications should; // be possible, such as constant-folding an index in an ElementRegion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:3,Performance,Cache,Cache,3,"// Cache results for the lifetime of the Simplifier. Results change every; // time new constraints are added to the program state, which is the whole; // point of simplifying, and for that very reason it's pointless to maintain; // the same cache for the duration of the whole analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:241,Performance,cache,cache,241,"// Cache results for the lifetime of the Simplifier. Results change every; // time new constraints are added to the program state, which is the whole; // point of simplifying, and for that very reason it's pointless to maintain; // the same cache for the duration of the whole analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:41,Usability,Simpl,Simplifier,41,"// Cache results for the lifetime of the Simplifier. Results change every; // time new constraints are added to the program state, which is the whole; // point of simplifying, and for that very reason it's pointless to maintain; // the same cache for the duration of the whole analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:163,Usability,simpl,simplifying,163,"// Cache results for the lifetime of the Simplifier. Results change every; // time new constraints are added to the program state, which is the whole; // point of simplifying, and for that very reason it's pointless to maintain; // the same cache for the duration of the whole analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:47,Availability,avail,available,47,"// Return the known const value for the Sym if available, or return Undef; // otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:6,Performance,cache,cache,6,// No cache here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:24,Usability,simpl,simplify,24,// For now don't try to simplify mixed Loc/NonLoc expressions; // because they often appear from LocAsInteger operations; // and we don't know how to combine a LocAsInteger; // with a concrete value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:3,Usability,Simpl,Simplification,3,"// Simplification is much more costly than computing complexity.; // For high complexity, it may be not worth it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp:19,Integrability,Interface,Interface,19,"//===- Store.cpp - Interface for maps from Locations to Values ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defined the types Store and StoreManager.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp:232,Availability,down,downcasts,232,"// FIXME: We may need different solutions, depending on the symbol; // involved. Blocks can be casted to/from 'id', as they can be treated; // as Objective-C objects. This could possibly be handled by enhancing; // our reasoning of downcasts of symbolic objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp:43,Integrability,depend,depending,43,"// FIXME: We may need different solutions, depending on the symbol; // involved. Blocks can be casted to/from 'id', as they can be treated; // as Objective-C objects. This could possibly be handled by enhancing; // our reasoning of downcasts of symbolic objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp:35,Availability,down,downcasts,35,// FIXME: Need to handle arbitrary downcasts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp:19,Safety,avoid,avoid,19,// Early return to avoid doing the wrong thing in the face of; // reinterpret_cast.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp:9,Availability,down,down,9,"// Drill down the CXXBaseObject chains, which represent upcasts (casts from; // derived to base).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp:115,Modifiability,inherit,inheritance,115,"// Static upcasts are marked as DerivedToBase casts by Sema, so this will; // only happen when multiple or virtual inheritance is involved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp:2,Safety,Detect,DetectVirtual,2,/*DetectVirtual=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp:9,Availability,down,down,9,// Drill down the chain to get the derived classes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp:382,Performance,perform,performance,382,"// Strange use of reinterpret_cast can give us paths we don't reason; // about well, by putting in ElementRegions where we'd expect; // CXXBaseObjectRegions. If it's a valid reinterpret_cast (i.e. if the; // derived class has a zero offset from the base class), then it's safe; // to strip the cast; if it's invalid, -Wreinterpret-base-class should; // catch it. In the interest of performance, the analyzer will silently; // do the wrong thing in the invalid case (because offsets for subregions; // will be wrong).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp:272,Safety,safe,safe,272,"// Strange use of reinterpret_cast can give us paths we don't reason; // about well, by putting in ElementRegions where we'd expect; // CXXBaseObjectRegions. If it's a valid reinterpret_cast (i.e. if the; // derived class has a zero offset from the base class), then it's safe; // to strip the cast; if it's invalid, -Wreinterpret-base-class should; // catch it. In the interest of performance, the analyzer will silently; // do the wrong thing in the invalid case (because offsets for subregions; // will be wrong).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp:33,Safety,avoid,avoid,33,// Fast-path some expressions to avoid the overhead of going through the AST's; // constant evaluator,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp:104,Usability,simpl,simple,104,// If the right operand is a concrete int location then we have nothing; // better but to treat it as a simple nonloc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp:156,Usability,simpl,simplification-ptr-bool,156,// This change is needed for architectures with varying; // pointer widths. See the amdgcn opencl reproducer with; // this change as an example: solver-sym-simplification-ptr-bool.cl,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp:74,Integrability,wrap,wrap,74,"// When retrieving symbolic pointer and expecting a non-void pointer,; // wrap them into element regions of the expected type if necessary.; // It is necessary to make sure that the retrieved value makes sense,; // because there's no other cast in the AST that would tell us to cast; // it to the correct pointer type. We might need to do that for non-void; // pointers as well.; // FIXME: We really need a single good function to perform casts for us; // correctly every time we need it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp:431,Performance,perform,perform,431,"// When retrieving symbolic pointer and expecting a non-void pointer,; // wrap them into element regions of the expected type if necessary.; // It is necessary to make sure that the retrieved value makes sense,; // because there's no other cast in the AST that would tell us to cast; // it to the correct pointer type. We might need to do that for non-void; // pointers as well.; // FIXME: We really need a single good function to perform casts for us; // correctly every time we need it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp:209,Integrability,message,message,209,// FIXME: We should be able to cast NonLoc -> Loc; // (when Loc::isLocType(CastTy) is true); // But it's hard to do as SymbolicRegions can't refer to SymbolCasts holding; // generic SymExprs. Check the commit message for the details.; // Symbol to pointer and whatever else.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp:39,Availability,redundant,redundant,39,"/// Reduce cast expression by removing redundant intermediate casts.; /// E.g.; /// - (char)(short)(int x) -> (char)(int x); /// - (int)(int x) -> int x; ///; /// \param V -- SymbolVal, which pressumably contains SymbolCast or any symbol; /// that is applicable for cast operation.; /// \param CastTy -- QualType, which `V` shall be cast to.; /// \return SVal with simplified cast expression.; /// \note: Currently only support integral casts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp:4,Energy Efficiency,Reduce,Reduce,4,"/// Reduce cast expression by removing redundant intermediate casts.; /// E.g.; /// - (char)(short)(int x) -> (char)(int x); /// - (int)(int x) -> int x; ///; /// \param V -- SymbolVal, which pressumably contains SymbolCast or any symbol; /// that is applicable for cast operation.; /// \param CastTy -- QualType, which `V` shall be cast to.; /// \return SVal with simplified cast expression.; /// \note: Currently only support integral casts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp:39,Safety,redund,redundant,39,"/// Reduce cast expression by removing redundant intermediate casts.; /// E.g.; /// - (char)(short)(int x) -> (char)(int x); /// - (int)(int x) -> int x; ///; /// \param V -- SymbolVal, which pressumably contains SymbolCast or any symbol; /// that is applicable for cast operation.; /// \param CastTy -- QualType, which `V` shall be cast to.; /// \return SVal with simplified cast expression.; /// \note: Currently only support integral casts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp:365,Usability,simpl,simplified,365,"/// Reduce cast expression by removing redundant intermediate casts.; /// E.g.; /// - (char)(short)(int x) -> (char)(int x); /// - (int)(int x) -> int x; ///; /// \param V -- SymbolVal, which pressumably contains SymbolCast or any symbol; /// that is applicable for cast operation.; /// \param CastTy -- QualType, which `V` shall be cast to.; /// \return SVal with simplified cast expression.; /// \note: Currently only support integral casts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp:42,Usability,simpl,simplification,42,"// We use seven conditions to recognize a simplification case.; // For the clarity let `CastTy` be `C`, SE->getType() - `T`, root type -; // `R`, prefix `u` for unsigned, `s` for signed, no prefix - any sign: E.g.; // (char)(short)(uint x); // ( sC )( sT )( uR x); //; // C === R (the same type); // (char)(char x) -> (char x); // (long)(long x) -> (long x); // Note: Comparisons operators below are for bit width.; // C == T; // (short)(short)(int x) -> (short)(int x); // (int)(long)(char x) -> (int)(char x) (sizeof(long) == sizeof(int)); // (long)(ullong)(char x) -> (long)(char x) (sizeof(long) ==; // sizeof(ullong)); // C < T; // (short)(int)(char x) -> (short)(char x); // (char)(int)(short x) -> (char)(short x); // (short)(int)(short x) -> (short x); // C > T > uR; // (int)(short)(uchar x) -> (int)(uchar x); // (uint)(short)(uchar x) -> (uint)(uchar x); // (int)(ushort)(uchar x) -> (int)(uchar x); // C > sT > sR; // (int)(short)(char x) -> (int)(char x); // (uint)(short)(char x) -> (uint)(char x); // C > sT == sR; // (int)(char)(char x) -> (int)(char x); // (uint)(short)(short x) -> (uint)(short x); // C > uT == uR; // (int)(uchar)(uchar x) -> (int)(uchar x); // (uint)(ushort)(ushort x) -> (uint)(ushort x); // (llong)(ulong)(uint x) -> (llong)(uint x) (sizeof(ulong) ==; // sizeof(uint))",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp:17,Usability,simpl,simplification,17,// FIXME support simplification from non-integers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp:330,Performance,perform,performs,330,"// end anonymous namespace; /// Cast a given SVal to another SVal using given QualType's.; /// \param V -- SVal that should be casted.; /// \param CastTy -- QualType that V should be casted according to.; /// \param OriginalTy -- QualType which is associated to V. It provides; /// additional information about what type the cast performs from.; /// \returns the most appropriate casted SVal.; /// Note: Many cases don't use an exact OriginalTy. It can be extracted; /// from SVal or the cast can performs unconditionaly. Always pass OriginalTy!; /// It can be crucial in certain cases and generates different results.; /// FIXME: If `OriginalTy.isNull()` is true, then cast performs based on CastTy; /// only. This behavior is uncertain and should be improved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp:497,Performance,perform,performs,497,"// end anonymous namespace; /// Cast a given SVal to another SVal using given QualType's.; /// \param V -- SVal that should be casted.; /// \param CastTy -- QualType that V should be casted according to.; /// \param OriginalTy -- QualType which is associated to V. It provides; /// additional information about what type the cast performs from.; /// \returns the most appropriate casted SVal.; /// Note: Many cases don't use an exact OriginalTy. It can be extracted; /// from SVal or the cast can performs unconditionaly. Always pass OriginalTy!; /// It can be crucial in certain cases and generates different results.; /// FIXME: If `OriginalTy.isNull()` is true, then cast performs based on CastTy; /// only. This behavior is uncertain and should be improved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp:675,Performance,perform,performs,675,"// end anonymous namespace; /// Cast a given SVal to another SVal using given QualType's.; /// \param V -- SVal that should be casted.; /// \param CastTy -- QualType that V should be casted according to.; /// \param OriginalTy -- QualType which is associated to V. It provides; /// additional information about what type the cast performs from.; /// \returns the most appropriate casted SVal.; /// Note: Many cases don't use an exact OriginalTy. It can be extracted; /// from SVal or the cast can performs unconditionaly. Always pass OriginalTy!; /// It can be crucial in certain cases and generates different results.; /// FIXME: If `OriginalTy.isNull()` is true, then cast performs based on CastTy; /// only. This behavior is uncertain and should be improved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SVals.cpp:52,Integrability,wrap,wraps,52,"/// If this SVal is a location (subclasses Loc) and wraps a symbol,; /// return that SymbolRef. Otherwise return 0.; ///; /// Implicit casts (ex: void* -> char*) can turn Symbolic region into Element; /// region. If that is the case, gets the underlining region.; /// When IncludeBaseRegions is set to true and the SubRegion is non-symbolic,; /// the first symbolic parent region is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SVals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SVals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SVals.cpp:39,Integrability,wrap,wrapped,39,// FIXME: should we consider SymbolRef wrapped in CodeTextRegion?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SVals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SVals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SVals.cpp:17,Integrability,wrap,wraps,17,"/// If this SVal wraps a symbol return that SymbolRef.; /// Otherwise, return 0.; ///; /// Casts are ignored during lookup.; /// \param IncludeBaseRegions The boolean that controls whether the search; /// should continue to the base regions if the region is not symbolic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SVals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SVals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SVals.cpp:39,Integrability,wrap,wrapped,39,// FIXME: should we consider SymbolRef wrapped in CodeTextRegion?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SVals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SVals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SymbolManager.cpp:15,Integrability,depend,dependents,15,// Do not mark dependents more then once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SymbolManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SymbolManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SymbolManager.cpp:273,Modifiability,variab,variable,273,"// TODO: For now, liveness of a memory region is equivalent to liveness of its; // base region. In fact we can do a bit better: say, if a particular FieldDecl; // is not used later in the path, we can diagnose a leak of a value within; // that field earlier than, say, the variable that contains the field dies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SymbolManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SymbolManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SymbolManager.cpp:30,Modifiability,inherit,inheriting,30,// Anonymous parameters of an inheriting constructor are live for the entire; // duration of the constructor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SymbolManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SymbolManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/TextDiagnostics.cpp:103,Availability,error,error,103,"/// Emits minimal diagnostics (report message + notes) for the 'none' output; /// type to the standard error, or to complement many others. Emits detailed; /// diagnostics in textual format for the 'text' output type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/TextDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/TextDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/TextDiagnostics.cpp:38,Integrability,message,message,38,"/// Emits minimal diagnostics (report message + notes) for the 'none' output; /// type to the standard error, or to complement many others. Emits detailed; /// diagnostics in textual format for the 'text' output type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/TextDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/TextDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/WorkList.cpp:74,Safety,unsafe,unsafe,74,// Don't use const reference. The subsequent pop_back() might make it; // unsafe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/WorkList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/WorkList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/WorkList.cpp:78,Performance,queue,queue,78,"// Number of inserted nodes, used to emulate DFS ordering in the priority; // queue when insertions are equal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/WorkList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/WorkList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/WorkList.cpp:78,Performance,queue,queue,78,"// Number of inserted nodes, used to emulate DFS ordering in the priority; // queue when insertions are equal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/WorkList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/WorkList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp:135,Performance,optimiz,optimization,135,"/// Stores the declarations from the local translation unit.; /// Note, we pre-compute the local declarations at parse time as an; /// optimization to make sure we do not deserialize everything from disk.; /// The local declaration to all declarations ratio might be very small when; /// working with a PCH file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp:99,Safety,avoid,avoids,99,/// Store the top level decls in the set to be processed later on.; /// (Doing this pre-processing avoids deserialization of data from PCH.),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp:55,Safety,avoid,avoid,55,"// Skip ObjCMethodDecl, wait for the objc container to avoid; // analyzing twice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp:122,Availability,down,down,122,"// Skip analysis of inheriting constructors as top-level functions. These; // constructors don't even have a body written down in the code, so even if; // we find a bug, we won't be able to display it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp:20,Modifiability,inherit,inheriting,20,"// Skip analysis of inheriting constructors as top-level functions. These; // constructors don't even have a body written down in the code, so even if; // we find a bug, we won't be able to display it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp:294,Availability,error,errors,294,"// We want to re-analyse the functions as top level in the following cases:; // - The 'init' methods should be reanalyzed because; // ObjCNonNilReturnValueChecker assumes that '[super init]' never returns; // 'nil' and unless we analyze the 'init' functions as top level, we will; // not catch errors within defensive code.; // - We want to reanalyze all ObjC methods as top level to report Retain; // Count naming convention errors more aggressively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp:426,Availability,error,errors,426,"// We want to re-analyse the functions as top level in the following cases:; // - The 'init' methods should be reanalyzed because; // ObjCNonNilReturnValueChecker assumes that '[super init]' never returns; // 'nil' and unless we analyze the 'init' functions as top level, we will; // not catch errors within defensive code.; // - We want to reanalyze all ObjC methods as top level to report Retain; // Count naming convention errors more aggressively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp:99,Availability,error,errors,99,// We want to reanalyze all ObjC methods as top level to report Retain; // Count naming convention errors more aggressively. But we should tune down; // inlining when reanalyzing an already inlined function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp:144,Availability,down,down,144,// We want to reanalyze all ObjC methods as top level to report Retain; // Count naming convention errors more aggressively. But we should tune down; // inlining when reanalyzing an already inlined function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp:139,Performance,tune,tune,139,// We want to reanalyze all ObjC methods as top level to report Retain; // Count naming convention errors more aggressively. But we should tune down; // inlining when reanalyzing an already inlined function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp:248,Security,access,access,248,// Build the Call Graph by adding all the top level declarations to the graph.; // Note: CallGraph can trigger deserialization of more items from a pch; // (though HandleInterestingDecl); triggering additions to LocalTUDecls.; // We rely on random access to add the initially processed Decls to CG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp:331,Performance,perform,performance,331,"// Walk over all of the call graph nodes in topological order, so that we; // analyze parents before the children. Skip the functions inlined into; // the previously processed functions. Use external Visited set to identify; // inlined functions. The topological order allows the ""do not reanalyze; // previously inlined function"" performance heuristic to be triggered more; // often.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp:117,Usability,simpl,simplest,117,"// Run the AST-only checks using the order in which functions are defined.; // If inlining is not turned on, use the simplest function order for path; // sensitive analyzes as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp:202,Security,access,access,202,"// Process all the top level declarations.; //; // Note: TraverseDecl may modify LocalTUDecls, but only by appending more; // entries. Thus we don't use an iterator, but rely on LocalTUDecls; // random access. By doing so, we automatically compensate for iterators; // possibly being invalidated, although this is a bit slower.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp:31,Availability,error,error,31,// Don't run the actions if an error has occurred with parsing the file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp:66,Performance,perform,performed,66,// Don't analyze if the user explicitly asked for no checks to be performed; // on this file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp:61,Integrability,depend,depending,61,"// Unless -analyze-all is specified, treat decls differently depending on; // where they came from:; // - Main source file: run both path-sensitive and non-path-sensitive checks.; // - Header files: run non-path-sensitive checks only.; // - System headers: don't run any checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp:3,Usability,Clear,Clear,3,// Clear the AnalysisManager of old AnalysisDeclContexts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp:15,Integrability,message,message,15,"// FIXME: This message sounds scary, should be scary, but incorrectly states; // that all configs are super dangerous. In reality, many of them should be; // accessible to the user. We should create a user-facing subset of config; // options under a different frontend flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp:90,Modifiability,config,configs,90,"// FIXME: This message sounds scary, should be scary, but incorrectly states; // that all configs are super dangerous. In reality, many of them should be; // accessible to the user. We should create a user-facing subset of config; // options under a different frontend flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp:223,Modifiability,config,config,223,"// FIXME: This message sounds scary, should be scary, but incorrectly states; // that all configs are super dangerous. In reality, many of them should be; // accessible to the user. We should create a user-facing subset of config; // options under a different frontend flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp:158,Security,access,accessible,158,"// FIXME: This message sounds scary, should be scary, but incorrectly states; // that all configs are super dangerous. In reality, many of them should be; // accessible to the user. We should create a user-facing subset of config; // options under a different frontend flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp:89,Deployability,configurat,configurations,89,"R""(; OVERVIEW: Clang Static Analyzer -analyzer-config Option List. The following list of configurations are meant for development purposes only, as; some of the variables they define are set to result in the most optimal; analysis. Setting them to other values may drastically change how the analyzer; behaves, and may even result in instabilities, crashes!. USAGE: -analyzer-config <OPTION1=VALUE,OPTION2=VALUE,...>; -analyzer-config OPTION1=VALUE, -analyzer-config OPTION2=VALUE, ...; OPTIONS:; )""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp:47,Modifiability,config,config,47,"R""(; OVERVIEW: Clang Static Analyzer -analyzer-config Option List. The following list of configurations are meant for development purposes only, as; some of the variables they define are set to result in the most optimal; analysis. Setting them to other values may drastically change how the analyzer; behaves, and may even result in instabilities, crashes!. USAGE: -analyzer-config <OPTION1=VALUE,OPTION2=VALUE,...>; -analyzer-config OPTION1=VALUE, -analyzer-config OPTION2=VALUE, ...; OPTIONS:; )""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp:89,Modifiability,config,configurations,89,"R""(; OVERVIEW: Clang Static Analyzer -analyzer-config Option List. The following list of configurations are meant for development purposes only, as; some of the variables they define are set to result in the most optimal; analysis. Setting them to other values may drastically change how the analyzer; behaves, and may even result in instabilities, crashes!. USAGE: -analyzer-config <OPTION1=VALUE,OPTION2=VALUE,...>; -analyzer-config OPTION1=VALUE, -analyzer-config OPTION2=VALUE, ...; OPTIONS:; )""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp:161,Modifiability,variab,variables,161,"R""(; OVERVIEW: Clang Static Analyzer -analyzer-config Option List. The following list of configurations are meant for development purposes only, as; some of the variables they define are set to result in the most optimal; analysis. Setting them to other values may drastically change how the analyzer; behaves, and may even result in instabilities, crashes!. USAGE: -analyzer-config <OPTION1=VALUE,OPTION2=VALUE,...>; -analyzer-config OPTION1=VALUE, -analyzer-config OPTION2=VALUE, ...; OPTIONS:; )""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp:376,Modifiability,config,config,376,"R""(; OVERVIEW: Clang Static Analyzer -analyzer-config Option List. The following list of configurations are meant for development purposes only, as; some of the variables they define are set to result in the most optimal; analysis. Setting them to other values may drastically change how the analyzer; behaves, and may even result in instabilities, crashes!. USAGE: -analyzer-config <OPTION1=VALUE,OPTION2=VALUE,...>; -analyzer-config OPTION1=VALUE, -analyzer-config OPTION2=VALUE, ...; OPTIONS:; )""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp:428,Modifiability,config,config,428,"R""(; OVERVIEW: Clang Static Analyzer -analyzer-config Option List. The following list of configurations are meant for development purposes only, as; some of the variables they define are set to result in the most optimal; analysis. Setting them to other values may drastically change how the analyzer; behaves, and may even result in instabilities, crashes!. USAGE: -analyzer-config <OPTION1=VALUE,OPTION2=VALUE,...>; -analyzer-config OPTION1=VALUE, -analyzer-config OPTION2=VALUE, ...; OPTIONS:; )""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp:460,Modifiability,config,config,460,"R""(; OVERVIEW: Clang Static Analyzer -analyzer-config Option List. The following list of configurations are meant for development purposes only, as; some of the variables they define are set to result in the most optimal; analysis. Setting them to other values may drastically change how the analyzer; behaves, and may even result in instabilities, crashes!. USAGE: -analyzer-config <OPTION1=VALUE,OPTION2=VALUE,...>; -analyzer-config OPTION1=VALUE, -analyzer-config OPTION2=VALUE, ...; OPTIONS:; )""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:43,Availability,avail,available,43,"//===- CheckerRegistry.cpp - Maintains all available checkers -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:54,Modifiability,plugin,plugin,54,"// If the version string is null, its not an analyzer plugin.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:26,Modifiability,plugin,plugins,26,// Register checkers from plugins.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:21,Modifiability,plugin,plugin,21,// Get access to the plugin.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:7,Security,access,access,7,// Get access to the plugin.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:21,Energy Efficiency,efficient,efficient,21,// Sort checkers for efficient collection.; // FIXME: Alphabetical sort puts 'experimental' in the middle.; // Would it be better to name it '~experimental' or something else; // that's ASCIIbetically last?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:42,Integrability,depend,dependencies,42,"// Some assertions to enforce that strong dependencies are relations in; // between purely modeling checkers, and weak dependencies are about; // diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:119,Integrability,depend,dependencies,119,"// Some assertions to enforce that strong dependencies are relations in; // between purely modeling checkers, and weak dependencies are about; // diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:8,Testability,assert,assertions,8,"// Some assertions to enforce that strong dependencies are relations in; // between purely modeling checkers, and weak dependencies are about; // diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:85,Integrability,Depend,Dependency,85,//===----------------------------------------------------------------------===//; // Dependency resolving.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:18,Integrability,depend,dependencies,18,/// Collects weak dependencies in \p enabledData.Checkers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:93,Integrability,depend,dependencies,93,"// First, we calculate the list of enabled checkers as specified by the; // invocation. Weak dependencies will not enable their unspecified strong; // depenencies, but its only after resolving strong dependencies for all; // checkers when we know whether they will be enabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:200,Integrability,depend,dependencies,200,"// First, we calculate the list of enabled checkers as specified by the; // invocation. Weak dependencies will not enable their unspecified strong; // depenencies, but its only after resolving strong dependencies for all; // checkers when we know whether they will be enabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:37,Integrability,depend,dependencies,37,"// If we failed to enable any of the dependencies, don't enable this; // checker.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:140,Availability,error,error,140,"// Calculate enabled checkers with the correct registration order. As this is; // done recursively, its arguably cheaper, but for sure less error prone to; // recalculate from scratch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:37,Integrability,depend,dependencies,37,"// If we failed to enable any of the dependencies, don't enable this; // checker.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:11,Integrability,depend,dependencies,11,// Collect dependencies recursively.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:39,Integrability,depend,dependencies,39,"// Don't enable this checker if strong dependencies are unsatisfied, but; // assume that weak dependencies are transitive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:94,Integrability,depend,dependencies,94,"// Don't enable this checker if strong dependencies are unsatisfied, but; // assume that weak dependencies are transitive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:50,Integrability,depend,dependency,50,// We do allow diagnostics from unit test/example dependency checkers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:37,Testability,test,test,37,// We do allow diagnostics from unit test/example dependency checkers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:267,Modifiability,config,config,267,"//===----------------------------------------------------------------------===//; // Checker option resolving and validating.; //===----------------------------------------------------------------------===//; /// Insert the checker/package option to AnalyzerOptions' config table, and; /// validate it, if the user supplied it on the command line.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:114,Security,validat,validating,114,"//===----------------------------------------------------------------------===//; // Checker option resolving and validating.; //===----------------------------------------------------------------------===//; /// Insert the checker/package option to AnalyzerOptions' config table, and; /// validate it, if the user supplied it on the command line.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:290,Security,validat,validate,290,"//===----------------------------------------------------------------------===//; // Checker option resolving and validating.; //===----------------------------------------------------------------------===//; /// Insert the checker/package option to AnalyzerOptions' config table, and; /// validate it, if the user supplied it on the command line.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:108,Modifiability,plugin,plugins,108,// Insertation was successful -- CmdLineOption's constructor will validate; // whether values received from plugins or TableGen files are correct.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:66,Security,validat,validate,66,// Insertation was successful -- CmdLineOption's constructor will validate; // whether values received from plugins or TableGen files are correct.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:241,Availability,error,error,241,"// Insertion failed, the user supplied this package/checker option on the; // command line. If the supplied value is invalid, we'll restore the option; // to it's default value, and if we're in non-compatibility mode, we'll also; // emit an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:20,Modifiability,config,config,20,"// AnalyzerOptions' config table contains the user input, so an entry could; // look like this:; //; // cor:NoFalsePositives=true; //; // Since lower_bound would look for the first element *not less* than ""cor"",; // it would return with an iterator to the first checker in the core, so we; // we really have to use find here, which uses operator==.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelConsumer.cpp:779,Availability,avail,available,779,"//===--- ModelConsumer.cpp - ASTConsumer for consuming model files --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements an ASTConsumer for consuming model files.; ///; /// This ASTConsumer handles the AST of a parsed model file. All top level; /// function definitions will be collected from that model file for later; /// retrieval during the static analysis. The body of these functions will not; /// be injected into the ASTUnit of the analyzed translation unit. It will be; /// available through the BodyFarm which is utilized by the AnalysisDeclContext; /// class.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelConsumer.cpp:703,Integrability,inject,injected,703,"//===--- ModelConsumer.cpp - ASTConsumer for consuming model files --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements an ASTConsumer for consuming model files.; ///; /// This ASTConsumer handles the AST of a parsed model file. All top level; /// function definitions will be collected from that model file for later; /// retrieval during the static analysis. The body of these functions will not; /// be injected into the ASTUnit of the analyzed translation unit. It will be; /// available through the BodyFarm which is utilized by the AnalysisDeclContext; /// class.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelConsumer.cpp:703,Security,inject,injected,703,"//===--- ModelConsumer.cpp - ASTConsumer for consuming model files --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements an ASTConsumer for consuming model files.; ///; /// This ASTConsumer handles the AST of a parsed model file. All top level; /// function definitions will be collected from that model file for later; /// retrieval during the static analysis. The body of these functions will not; /// be injected into the ASTUnit of the analyzed translation unit. It will be; /// available through the BodyFarm which is utilized by the AnalysisDeclContext; /// class.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.cpp:99,Safety,avoid,avoid,99,"// The instance wants to take ownership, however DisableFree frontend option; // is set to true to avoid double free issues",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.h:497,Integrability,interface,interface,497,"//===-- ModelInjector.h -----------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the clang::ento::ModelInjector class which implements the; /// clang::CodeInjector interface. This class is responsible for injecting; /// function definitions that were synthesized from model files.; ///; /// Model files allow definitions of functions to be lazily constituted for functions; /// which lack bodies in the original source code. This allows the analyzer; /// to more precisely analyze code that calls such functions, analyzing the; /// artificial definitions (which typically approximate the semantics of the; /// called function) when called by client code. These definitions are; /// reconstituted lazily, on-demand, by the static analyzer engine.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.h:538,Integrability,inject,injecting,538,"//===-- ModelInjector.h -----------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the clang::ento::ModelInjector class which implements the; /// clang::CodeInjector interface. This class is responsible for injecting; /// function definitions that were synthesized from model files.; ///; /// Model files allow definitions of functions to be lazily constituted for functions; /// which lack bodies in the original source code. This allows the analyzer; /// to more precisely analyze code that calls such functions, analyzing the; /// artificial definitions (which typically approximate the semantics of the; /// called function) when called by client code. These definitions are; /// reconstituted lazily, on-demand, by the static analyzer engine.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.h:538,Security,inject,injecting,538,"//===-- ModelInjector.h -----------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the clang::ento::ModelInjector class which implements the; /// clang::CodeInjector interface. This class is responsible for injecting; /// function definitions that were synthesized from model files.; ///; /// Model files allow definitions of functions to be lazily constituted for functions; /// which lack bodies in the original source code. This allows the analyzer; /// to more precisely analyze code that calls such functions, analyzing the; /// artificial definitions (which typically approximate the semantics of the; /// called function) when called by client code. These definitions are; /// reconstituted lazily, on-demand, by the static analyzer engine.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.h:133,Deployability,configurat,configuration,133,"/// Synthesize a body for a declaration; ///; /// This method first looks up the appropriate model file based on the; /// model-path configuration option and the name of the declaration that is; /// looked up. If no model were synthesized yet for a function with that name; /// it will create a new compiler instance to parse the model file using the; /// ASTContext, Preprocessor, SourceManager of the original compiler instance.; /// The former resources are shared between the two compiler instance, so the; /// newly created instance have to ""leak"" these objects, since they are owned; /// by the original instance.; ///; /// The model-path should be either an absolute path or relative to the; /// working directory of the compiler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.h:133,Modifiability,config,configuration,133,"/// Synthesize a body for a declaration; ///; /// This method first looks up the appropriate model file based on the; /// model-path configuration option and the name of the declaration that is; /// looked up. If no model were synthesized yet for a function with that name; /// it will create a new compiler instance to parse the model file using the; /// ASTContext, Preprocessor, SourceManager of the original compiler instance.; /// The former resources are shared between the two compiler instance, so the; /// newly created instance have to ""leak"" these objects, since they are owned; /// by the original instance.; ///; /// The model-path should be either an absolute path or relative to the; /// working directory of the compiler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.h:32,Availability,redundant,redundant,32,"// FIXME: double memoization is redundant, with memoization both here and in; // BodyFarm.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.h:32,Safety,redund,redundant,32,"// FIXME: double memoization is redundant, with memoization both here and in; // BodyFarm.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp:48,Performance,load,load,48,// Pointer to vector types. Defined for segment load intrinsics.; // segment load intrinsics have pointer type arguments to store the loaded; // vector values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp:77,Performance,load,load,77,// Pointer to vector types. Defined for segment load intrinsics.; // segment load intrinsics have pointer type arguments to store the loaded; // vector values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp:134,Performance,load,loaded,134,// Pointer to vector types. Defined for segment load intrinsics.; // segment load intrinsics have pointer type arguments to store the loaded; // vector values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp:3,Deployability,Update,Update,3,// Update ElementBitwidth need to update Scale too.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp:34,Deployability,update,update,34,// Update ElementBitwidth need to update Scale too.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp:3,Deployability,update,update,3,// update new elmul = (eew/sew) * lmul,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp:3,Deployability,update,update,3,// update new eew,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp:3,Deployability,Update,Update,3,// Update new SEW,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp:3,Deployability,Update,Update,3,// Update new LMUL,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp:47,Performance,cache,cache,47,"// Compute the hash value of RVVType, used for cache the result of computeType.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp:15,Security,hash,hash,15,"// Compute the hash value of RVVType, used for cache the result of computeType.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp:13,Security,hash,hash,13,// Layout of hash value:; // 0 8 16 24 32 40; // | Log2LMUL + 3 | BT | Proto.PT | Proto.TM | Proto.VTM |,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp:56,Deployability,update,update,56,// IntrinsicTypes is unmasked TA version index. Need to update it; // if there is merge operand (It is always in first operand).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp:131,Availability,mask,mask,131,"// Convert; // (void, op0 address, op1 address, ..., maskedoff0, maskedoff1, ...); // to; // (void, op0 address, op1 address, ..., mask, maskedoff0, maskedoff1,; // ...)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp:43,Availability,Mask,Mask,43,"// If IsMasked, insert PrototypeDescriptor:Mask as first input operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp:28,Performance,load,load,28,"// NF > 1 cases for segment load operations.; // Convert; // (void, op0 address, op1 address, ...); // to; // (void, op0 address, op1 address, maskedoff0, maskedoff1, ...)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp:27,Usability,guid,guideline,27,// This follows the naming guideline under riscv-c-api-doc to add the; // `__riscv_` suffix for all RVV intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Testing/CommandLineArgs.cpp:3,Testability,Test,Test,3,// Test with basic arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Testing/CommandLineArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Testing/CommandLineArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Testing/TestAST.cpp:9,Testability,Test,TestAST,9,"//===--- TestAST.cpp ------------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Testing/TestAST.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Testing/TestAST.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Testing/TestAST.cpp:60,Availability,error,errors,60,"// Captures diagnostics into a vector, optionally reporting errors to gtest.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Testing/TestAST.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Testing/TestAST.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Testing/TestAST.cpp:99,Testability,test,test,99,"// If we don't manage to finish parsing, create CompilerInstance components; // anyway so that the test will see an empty AST instead of crashing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Testing/TestAST.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Testing/TestAST.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Testing/TestAST.cpp:9,Availability,error,error,9,"// Extra error conditions are reported through diagnostics, set that up first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Testing/TestAST.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Testing/TestAST.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Testing/TestAST.cpp:90,Availability,alive,alive,90,"// We notified the preprocessor of EOF already, so detach it first.; // Sema needs the PP alive until after EndSourceFile() though.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Testing/TestAST.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Testing/TestAST.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Testing/TestAST.cpp:11,Availability,alive,alive,11,// Keep PP alive for now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Testing/TestAST.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Testing/TestAST.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Testing/TestAST.cpp:61,Safety,safe,safely,61,"// Destroy ASTContext and Sema.; // Now Sema is gone, PP can safely be destroyed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Testing/TestAST.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Testing/TestAST.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/AllTUsExecution.cpp:72,Performance,concurren,concurrent,72,// Each thread gets an independent copy of a VFS to allow different; // concurrent working directories.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/AllTUsExecution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/AllTUsExecution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/AllTUsExecution.cpp:106,Modifiability,plugin,plugin,106,// This anchor is used to force the linker to link in the generated object file; // and thus register the plugin.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/AllTUsExecution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/AllTUsExecution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp:463,Integrability,interface,interface,463,"//===- ArgumentsAdjusters.cpp - Command line arguments adjuster -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains definitions of classes which implement ArgumentsAdjuster; // interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp:38,Integrability,depend,dependency,38,"// When not using the cl driver mode, dependency file generation options; // begin with -M. These include -MM, -MF, -MG, -MP, -MT, -MQ, -MD, and; // -MMD.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp:32,Integrability,depend,dependency,32,"// Under MSVC's cl driver mode, dependency file generation is controlled; // using /showIncludes",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp:66,Modifiability,plugin,plugin,66,"// According to https://clang.llvm.org/docs/ClangPlugins.html; // plugin arguments are in the form:; // -Xclang {-load, -plugin, -plugin-arg-<plugin-name>, -add-plugin}; // -Xclang <arbitrary-argument>",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp:121,Modifiability,plugin,plugin,121,"// According to https://clang.llvm.org/docs/ClangPlugins.html; // plugin arguments are in the form:; // -Xclang {-load, -plugin, -plugin-arg-<plugin-name>, -add-plugin}; // -Xclang <arbitrary-argument>",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp:130,Modifiability,plugin,plugin-arg,130,"// According to https://clang.llvm.org/docs/ClangPlugins.html; // plugin arguments are in the form:; // -Xclang {-load, -plugin, -plugin-arg-<plugin-name>, -add-plugin}; // -Xclang <arbitrary-argument>",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp:142,Modifiability,plugin,plugin-name,142,"// According to https://clang.llvm.org/docs/ClangPlugins.html; // plugin arguments are in the form:; // -Xclang {-load, -plugin, -plugin-arg-<plugin-name>, -add-plugin}; // -Xclang <arbitrary-argument>",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp:161,Modifiability,plugin,plugin,161,"// According to https://clang.llvm.org/docs/ClangPlugins.html; // plugin arguments are in the form:; // -Xclang {-load, -plugin, -plugin-arg-<plugin-name>, -add-plugin}; // -Xclang <arbitrary-argument>",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp:114,Performance,load,load,114,"// According to https://clang.llvm.org/docs/ClangPlugins.html; // plugin arguments are in the form:; // -Xclang {-load, -plugin, -plugin-arg-<plugin-name>, -add-plugin}; // -Xclang <arbitrary-argument>",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CommonOptionsParser.cpp:588,Integrability,interface,interface,588,"//===--- CommonOptionsParser.cpp - common options for clang tools ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the CommonOptionsParser class used to parse common; // command-line options for clang tools, so that they can be run as separate; // command-line applications with a consistent common interface for handling; // compilation database and input files.; //; // It provides a common subset of command-line options, common algorithm; // for locating a compilation database and source files, and help messages; // for the basic command-line interface.; //; // It creates a CompilationDatabase and reads common command-line options.; //; // This class uses the Clang Tooling infrastructure, see; // http://clang.llvm.org/docs/HowToSetupToolingForLLVM.html; // for details on setting it up with LLVM source tree.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/CommonOptionsParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CommonOptionsParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CommonOptionsParser.cpp:798,Integrability,message,messages,798,"//===--- CommonOptionsParser.cpp - common options for clang tools ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the CommonOptionsParser class used to parse common; // command-line options for clang tools, so that they can be run as separate; // command-line applications with a consistent common interface for handling; // compilation database and input files.; //; // It provides a common subset of command-line options, common algorithm; // for locating a compilation database and source files, and help messages; // for the basic command-line interface.; //; // It creates a CompilationDatabase and reads common command-line options.; //; // This class uses the Clang Tooling infrastructure, see; // http://clang.llvm.org/docs/HowToSetupToolingForLLVM.html; // for details on setting it up with LLVM source tree.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/CommonOptionsParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CommonOptionsParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CommonOptionsParser.cpp:838,Integrability,interface,interface,838,"//===--- CommonOptionsParser.cpp - common options for clang tools ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the CommonOptionsParser class used to parse common; // command-line options for clang tools, so that they can be run as separate; // command-line applications with a consistent common interface for handling; // compilation database and input files.; //; // It provides a common subset of command-line options, common algorithm; // for locating a compilation database and source files, and help messages; // for the basic command-line interface.; //; // It creates a CompilationDatabase and reads common command-line options.; //; // This class uses the Clang Tooling infrastructure, see; // http://clang.llvm.org/docs/HowToSetupToolingForLLVM.html; // for details on setting it up with LLVM source tree.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/CommonOptionsParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CommonOptionsParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp:547,Availability,Error,ErrorMessage,547,"//===- CompilationDatabase.cpp --------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains implementations of the CompilationDatabase base class; // and the FixedCompilationDatabase.; //; // FIXME: Various functions that take a string &ErrorMessage should be upgraded; // to Expected.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp:570,Deployability,upgrade,upgraded,570,"//===- CompilationDatabase.cpp --------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains implementations of the CompilationDatabase base class; // and the FixedCompilationDatabase.; //; // FIXME: Various functions that take a string &ErrorMessage should be upgraded; // to Expected.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp:44,Deployability,integrat,integrated-as,44,"// Filter of tools unused flags such as -no-integrated-as and -Wa,*.; // They are not used for syntax checking, and could confuse targets; // which don't support these options.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp:44,Integrability,integrat,integrated-as,44,"// Filter of tools unused flags such as -no-integrated-as and -Wa,*.; // They are not used for syntax checking, and could confuse targets; // which don't support these options.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp:632,Availability,avail,available,632,// namespace; /// Strips any positional args and possible argv[0] from a command-line; /// provided by the user to construct a FixedCompilationDatabase.; ///; /// FixedCompilationDatabase requires a command line to be in this format as it; /// constructs the command line for each file by appending the name of the file; /// to be compiled. FixedCompilationDatabase also adds its own argv[0] to the; /// start of the command line although its value is not important as it's just; /// ignored by the Driver invoked by the ClangTool using the; /// FixedCompilationDatabase.; ///; /// FIXME: This functionality should probably be made available by; /// clang::driver::Driver although what the interface should look like is not; /// clear.; ///; /// \param[in] Args Args as provided by the user.; /// \return Resulting stripped command line.; /// \li true if successful.; /// \li false if \c Args cannot be used for compilation jobs (e.g.; /// contains an option like -E or -version).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp:690,Integrability,interface,interface,690,// namespace; /// Strips any positional args and possible argv[0] from a command-line; /// provided by the user to construct a FixedCompilationDatabase.; ///; /// FixedCompilationDatabase requires a command line to be in this format as it; /// constructs the command line for each file by appending the name of the file; /// to be compiled. FixedCompilationDatabase also adds its own argv[0] to the; /// start of the command line although its value is not important as it's just; /// ignored by the Driver invoked by the ClangTool using the; /// FixedCompilationDatabase.; ///; /// FIXME: This functionality should probably be made available by; /// clang::driver::Driver although what the interface should look like is not; /// clear.; ///; /// \param[in] Args Args as provided by the user.; /// \return Resulting stripped command line.; /// \li true if successful.; /// \li false if \c Args cannot be used for compilation jobs (e.g.; /// contains an option like -E or -version).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp:729,Usability,clear,clear,729,// namespace; /// Strips any positional args and possible argv[0] from a command-line; /// provided by the user to construct a FixedCompilationDatabase.; ///; /// FixedCompilationDatabase requires a command line to be in this format as it; /// constructs the command line for each file by appending the name of the file; /// to be compiled. FixedCompilationDatabase also adds its own argv[0] to the; /// start of the command line although its value is not important as it's just; /// ignored by the Driver invoked by the ClangTool using the; /// FixedCompilationDatabase.; ///; /// FIXME: This functionality should probably be made available by; /// clang::driver::Driver although what the interface should look like is not; /// clear.; ///; /// \param[in] Args Args as provided by the user.; /// \return Resulting stripped command line.; /// \li true if successful.; /// \li false if \c Args cannot be used for compilation jobs (e.g.; /// contains an option like -E or -version).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp:54,Safety,detect,detect,54,"// This becomes the new argv[0]. The value is used to detect libc++ include; // dirs on Mac, it isn't used for other platforms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp:277,Availability,fault,fault,277,"// Put a dummy C++ file on to ensure there's at least one compile job for the; // driver to construct. If the user specified some other argument that; // prevents compilation, e.g. -E or something like -version, we may still end; // up with no jobs but then this is the user's fault.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/FileMatchTrie.cpp:303,Safety,abort,abort,303,"/// Inserts 'NewPath' into this trie. \c ConsumedLength denotes; /// the number of \c NewPath's trailing characters already consumed during; /// recursion.; ///; /// An insert of a path; /// 'p'starts at the root node and does the following:; /// - If the node is empty, insert 'p' into its storage and abort.; /// - If the node has a path 'p2' but no children, take the last path segment; /// 's' of 'p2', put a new child into the map at 's' an insert the rest of; /// 'p2' there.; /// - Insert a new child for the last segment of 'p' and insert the rest of; /// 'p' there.; ///; /// An insert operation is linear in the number of a path's segments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/FileMatchTrie.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/FileMatchTrie.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/FileMatchTrie.cpp:1225,Availability,error,error,1225,"/// Tries to find the node under this \c FileMatchTrieNode that best; /// matches 'FileName'.; ///; /// If multiple paths fit 'FileName' equally well, \c IsAmbiguous is set to; /// \c true and an empty string is returned. If no path fits 'FileName', an; /// empty string is returned. \c ConsumedLength denotes the number of; /// \c Filename's trailing characters already consumed during recursion.; ///; /// To find the best matching node for a given path 'p', the; /// \c findEquivalent() function is called recursively for each path segment; /// (back to front) of 'p' until a node 'n' is reached that does not ..; /// - .. have children. In this case it is checked; /// whether the stored path is equivalent to 'p'. If yes, the best match is; /// found. Otherwise continue with the parent node as if this node did not; /// exist.; /// - .. a child matching the next path segment. In this case, all children of; /// 'n' are an equally good match for 'p'. All children are of 'n' are found; /// recursively and their equivalence to 'p' is determined. If none are; /// equivalent, continue with the parent node as if 'n' didn't exist. If one; /// is equivalent, the best match is found. Otherwise, report and ambigiuity; /// error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/FileMatchTrie.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/FileMatchTrie.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/FileMatchTrie.cpp:48,Performance,perform,performance,48,// Note: we support only directory symlinks for performance reasons.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/FileMatchTrie.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/FileMatchTrie.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/FileMatchTrie.cpp:76,Safety,avoid,avoid,76,"// As far as we do not support file symlinks, compare; // basenames here to avoid request to file system.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/FileMatchTrie.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/FileMatchTrie.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp:1301,Availability,avail,available,1301,"nother CompilationDatabase and; // attempts to heuristically determine appropriate compile commands for files; // that are not included, such as headers or newly created files.; //; // Motivating cases include:; // Header files that live next to their implementation files. These typically; // share a base filename. (libclang/CXString.h, libclang/CXString.cpp).; // Some projects separate headers from includes. Filenames still typically; // match, maybe other path segments too. (include/llvm/IR/Use.h, lib/IR/Use.cc).; // Matches are sometimes only approximate (Sema.h, SemaDecl.cpp). This goes; // for directories too (Support/Unix/Process.inc, lib/Support/Process.cpp).; // Even if we can't find a ""right"" compile command, even a random one from; // the project will tend to get important flags like -I and -x right.; //; // We ""borrow"" the compile command for the closest available file:; // - points are awarded if the filename matches (ignoring extension); // - points are awarded if the directory structure matches; // - ties are broken by length of path prefix match; //; // The compile command is adjusted, replacing the filename and removing output; // file arguments. The -x and -std flags may be affected too.; //; // Source language is a tricky issue: is it OK to use a .c file's command; // for building a .cc file? What language is a .h file in?; // - We only consider compile commands for c-family languages as candidates.; // - For files whose language is implied by the filename (e.g. .m, .hpp); // we prefer candidates from the same language.; // If we must cross languages, we drop any -x and -std flags.; // - For .h files, candidates from any c-family language are acceptable.; // We use the candidate's language, inserting e.g. -x c++-header.; //; // This class is only useful when wrapping databases that can enumerate all; // their compile commands. If getAllFilenames() is empty, no inference occurs.; //; //===--------------------------------------------------------------",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp:416,Integrability,wrap,wraps,416,"//===- InterpolatingCompilationDatabase.cpp ---------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // InterpolatingCompilationDatabase wraps another CompilationDatabase and; // attempts to heuristically determine appropriate compile commands for files; // that are not included, such as headers or newly created files.; //; // Motivating cases include:; // Header files that live next to their implementation files. These typically; // share a base filename. (libclang/CXString.h, libclang/CXString.cpp).; // Some projects separate headers from includes. Filenames still typically; // match, maybe other path segments too. (include/llvm/IR/Use.h, lib/IR/Use.cc).; // Matches are sometimes only approximate (Sema.h, SemaDecl.cpp). This goes; // for directories too (Support/Unix/Process.inc, lib/Support/Process.cpp).; // Even if we can't find a ""right"" compile command, even a random one from; // the project will tend to get important flags like -I and -x right.; //; // We ""borrow"" the compile command for the closest available file:; // - points are awarded if the filename matches (ignoring extension); // - points are awarded if the directory structure matches; // - ties are broken by length of path prefix match; //; // The compile command is adjusted, replacing the filename and removing output; // file arguments. The -x and -std flags may be affected too.; //; // Source language is a tricky issue: is it OK to use a .c file's command; // for building a .cc file? What language is a .h file in?; // - We only consider compile commands for c-family languages as candidates.; // - For files whose language is implied by the filename (e.g. .m, .hpp); // we prefer candidates from the same language.; // If we must",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp:2230,Integrability,wrap,wrapping,2230,"tionDatabase and; // attempts to heuristically determine appropriate compile commands for files; // that are not included, such as headers or newly created files.; //; // Motivating cases include:; // Header files that live next to their implementation files. These typically; // share a base filename. (libclang/CXString.h, libclang/CXString.cpp).; // Some projects separate headers from includes. Filenames still typically; // match, maybe other path segments too. (include/llvm/IR/Use.h, lib/IR/Use.cc).; // Matches are sometimes only approximate (Sema.h, SemaDecl.cpp). This goes; // for directories too (Support/Unix/Process.inc, lib/Support/Process.cpp).; // Even if we can't find a ""right"" compile command, even a random one from; // the project will tend to get important flags like -I and -x right.; //; // We ""borrow"" the compile command for the closest available file:; // - points are awarded if the filename matches (ignoring extension); // - points are awarded if the directory structure matches; // - ties are broken by length of path prefix match; //; // The compile command is adjusted, replacing the filename and removing output; // file arguments. The -x and -std flags may be affected too.; //; // Source language is a tricky issue: is it OK to use a .c file's command; // for building a .cc file? What language is a .h file in?; // - We only consider compile commands for c-family languages as candidates.; // - For files whose language is implied by the filename (e.g. .m, .hpp); // we prefer candidates from the same language.; // If we must cross languages, we drop any -x and -std flags.; // - For .h files, candidates from any c-family language are acceptable.; // We use the candidate's language, inserting e.g. -x c++-header.; //; // This class is only useful when wrapping databases that can enumerate all; // their compile commands. If getAllFilenames() is empty, no inference occurs.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp:12,Safety,detect,detected,12,// Language detected from -x or the filename. Never TY_INVALID.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp:3,Integrability,Wrap,Wrap,3,// Wrap the old arguments in an InputArgList.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp:7,Integrability,contract,contract,7,// The contract is to store None instead of TY_INVALID.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp:115,Safety,avoid,avoid,115,"// Produce a CompileCommand for \p filename, based on this one.; // (This consumes the TransferableCommand just to avoid copying Cmd).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp:457,Testability,log,log,457,"// Given a filename, FileIndex picks the best matching file from the underlying; // DB. This is the proxy file whose CompileCommand will be reused. The; // heuristics incorporate file name, extension, and directory structure.; // Strategy:; // - Build indexes of each of the substrings we want to look up by.; // These indexes are just sorted lists of the substrings.; // - Each criterion corresponds to a range lookup into the index, so we only; // need O(log N) string comparisons to determine scores.; //; // Apart from path proximity signals, also takes file extensions into account; // when scoring the candidates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp:3,Performance,Perform,Performs,3,"// Performs a point lookup into a nonempty index, returning a longest match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp:34,Integrability,wrap,wrapper,34,"// The actual CompilationDatabase wrapper delegates to its inner database.; // If no match, looks up a proxy file in FileIndex and transfers its; // command to the requested file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp:58,Availability,avail,available,58,// All private methods return true if there is more input available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp:8,Modifiability,plugin,plugin,8,"// This plugin locates a nearby compile_command.json file, and also infers; // compile commands for files not present in the database.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp:141,Modifiability,variab,variable,141,// namespace; // Register the JSONCompilationDatabasePlugin with the; // CompilationDatabasePluginRegistry using this statically initialized variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp:22,Integrability,wrap,wrappers,22,"// There are compiler-wrappers (ccache, distcc, gomacc) that take the ""real""; // compiler as an argument, e.g. distcc gcc -O3 foo.c.; // These end up in compile_commands.json when people set CC=""distcc gcc"".; // Clang's driver doesn't understand this, so we need to unwrap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp:17,Integrability,wrap,wrappers,17,"// Most of these wrappers support being invoked 3 ways:; // `distcc g++ file.c` This is the mode we're trying to match.; // We need to drop `distcc`.; // `distcc file.c` This acts like compiler is cc or similar.; // Clang's driver can handle this, no change needed.; // `g++ file.c` g++ is a symlink to distcc.; // We don't even notice this case, and all is well.; //; // We need to distinguish between the first and second case.; // The wrappers themselves don't take flags, so Args[1] is a compiler flag,; // an input file, or a compiler. Inputs have extensions, compilers don't.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp:438,Integrability,wrap,wrappers,438,"// Most of these wrappers support being invoked 3 ways:; // `distcc g++ file.c` This is the mode we're trying to match.; // We need to drop `distcc`.; // `distcc file.c` This acts like compiler is cc or similar.; // Clang's driver can handle this, no change needed.; // `g++ file.c` g++ is a symlink to distcc.; // We don't even notice this case, and all is well.; //; // We need to distinguish between the first and second case.; // The wrappers themselves don't take flags, so Args[1] is a compiler flag,; // an input file, or a compiler. Inputs have extensions, compilers don't.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp:20,Integrability,wrap,wrappers,20,"// If !HasCompiler, wrappers act like GCC. Fine: so do we.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp:25,Integrability,wrap,wrappers,25,// There may be multiple wrappers: using distcc and ccache together is common.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring.cpp:9,Modifiability,Refactor,Refactoring,9,"//===--- Refactoring.cpp - Framework for clang refactoring tools ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implements tools to support refactorings.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring.cpp:47,Modifiability,refactor,refactoring,47,"//===--- Refactoring.cpp - Framework for clang refactoring tools ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implements tools to support refactorings.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring.cpp:411,Modifiability,refactor,refactorings,411,"//===--- Refactoring.cpp - Framework for clang refactoring tools ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implements tools to support refactorings.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp:9,Modifiability,Refactor,RefactoringCallbacks,9,"//===--- RefactoringCallbacks.cpp - Structural query framework ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp:68,Usability,Clear,Clear,68,// The ASTMatchRefactorer is re-used between translation units.; // Clear the matchers so that each Replacement is only emitted once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp:17,Availability,error,error,17,"// FIXME: better error handling. For now, just print error message in the; // release version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp:53,Availability,error,error,53,"// FIXME: better error handling. For now, just print error message in the; // release version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp:78,Deployability,release,release,78,"// FIXME: better error handling. For now, just print error message in the; // release version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp:59,Integrability,message,message,59,"// FIXME: better error handling. For now, just print error message in the; // release version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp:17,Availability,error,error,17,"// FIXME: better error handling. For now, just print error message in the; // release version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp:53,Availability,error,error,53,"// FIXME: better error handling. For now, just print error message in the; // release version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp:78,Deployability,release,release,78,"// FIXME: better error handling. For now, just print error message in the; // release version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp:59,Integrability,message,message,59,"// FIXME: better error handling. For now, just print error message in the; // release version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp:17,Availability,error,error,17,"// FIXME: better error handling. For now, just print error message in the; // release version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp:53,Availability,error,error,53,"// FIXME: better error handling. For now, just print error message in the; // release version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp:78,Deployability,release,release,78,"// FIXME: better error handling. For now, just print error message in the; // release version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp:59,Integrability,message,message,59,"// FIXME: better error handling. For now, just print error message in the; // release version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp:17,Availability,error,error,17,"// FIXME: better error handling. For now, just print error message in the; // release version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp:53,Availability,error,error,53,"// FIXME: better error handling. For now, just print error message in the; // release version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp:78,Deployability,release,release,78,"// FIXME: better error handling. For now, just print error message in the; // release version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp:59,Integrability,message,message,59,"// FIXME: better error handling. For now, just print error message in the; // release version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/StandaloneExecution.cpp:106,Modifiability,plugin,plugin,106,// This anchor is used to force the linker to link in the generated object file; // and thus register the plugin.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/StandaloneExecution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/StandaloneExecution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp:477,Modifiability,plugin,plugin,477,"//===- Tooling.cpp - Running clang standalone tools -----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements functions to run clang tools standalone instead; // of running them as a plugin.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp:143,Modifiability,refactor,refactor,143,"// FIXME: This file contains structural duplication with other parts of the; // code that sets up a compiler to run tools on it, and we should refactor; // it to be based on the same framework.; /// Builds a clang driver initialized for running clang tools.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp:40,Integrability,depend,depending,40,// Jobs and Actions look very different depending on whether the Clang tool; // injected -fsyntax-only or not. Try to handle both cases here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp:80,Integrability,inject,injected,80,// Jobs and Actions look very different depending on whether the Clang tool; // injected -fsyntax-only or not. Try to handle both cases here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp:80,Security,inject,injected,80,// Jobs and Actions look very different depending on whether the Clang tool; // injected -fsyntax-only or not. Try to handle both cases here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp:43,Integrability,wrap,wrapped,43,// On MacOSX real actions may end up being wrapped in BindArchAction,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp:43,Integrability,wrap,wrapped,43,// On MacOSX real actions may end up being wrapped in; // BindArchAction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp:212,Modifiability,variab,variable,212,"// The FrontendAction can have lifetime requirements for Compiler or its; // members, and we need to ensure it's deleted earlier than Compiler. So we; // pass it to an std::unique_ptr declared after the Compiler variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp:346,Integrability,interface,interface,346,"// Currently implementations of CompilationDatabase::getCompileCommands can; // change the state of the file system (e.g. prepare generated headers), so; // this method needs to run right before we invoke the tool, as the next; // file may require a different (incompatible) state of the file system.; //; // FIXME: Make the compilation database interface more explicit about the; // requirements to the order of invocation of its members.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp:402,Integrability,depend,depends,402,"// FIXME: chdir is thread hostile; on the other hand, creating the same; // behavior as chdir is complex: chdir resolves the path once, thus; // guaranteeing that all subsequent relative path operations work; // on the same path the original chdir resulted in. This makes a; // difference for example on network filesystems, where symlinks might be; // switched during runtime of the tool. Fixing this depends on having a; // file system abstraction that allows openat() style interactions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp:86,Integrability,message,message,86,// FIXME: We need a callback mechanism for the tool writer to output a; // customized message for each file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ASTDiff/ASTDiff.cpp:438,Integrability,interface,interface,438,"//===- ASTDiff.cpp - AST differencing implementation-----------*- C++ -*- -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains definitons for the AST differencing interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/ASTDiff/ASTDiff.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ASTDiff/ASTDiff.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ASTDiff/ASTDiff.cpp:166,Deployability,update,update,166,"/// Implementation of Zhang and Shasha's Algorithm for tree edit distance.; /// Computes an optimal mapping between two trees using only insertion,; /// deletion and update as edit actions (similar to the Levenshtein distance).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/ASTDiff/ASTDiff.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ASTDiff/ASTDiff.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ASTDiff/ASTDiff.cpp:162,Performance,perform,perform,162,"/// We use a simple cost model for edit actions, which seems good enough.; /// Simple cost model for edit actions. This seems to make the matching; /// algorithm perform reasonably well.; /// The values range between 0 and 1, or infinity if this edit action should; /// always be avoided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/ASTDiff/ASTDiff.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ASTDiff/ASTDiff.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ASTDiff/ASTDiff.cpp:280,Safety,avoid,avoided,280,"/// We use a simple cost model for edit actions, which seems good enough.; /// Simple cost model for edit actions. This seems to make the matching; /// algorithm perform reasonably well.; /// The values range between 0 and 1, or infinity if this edit action should; /// always be avoided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/ASTDiff/ASTDiff.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ASTDiff/ASTDiff.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ASTDiff/ASTDiff.cpp:13,Usability,simpl,simple,13,"/// We use a simple cost model for edit actions, which seems good enough.; /// Simple cost model for edit actions. This seems to make the matching; /// algorithm perform reasonably well.; /// The values range between 0 and 1, or infinity if this edit action should; /// always be avoided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/ASTDiff/ASTDiff.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ASTDiff/ASTDiff.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ASTDiff/ASTDiff.cpp:79,Usability,Simpl,Simple,79,"/// We use a simple cost model for edit actions, which seems good enough.; /// Simple cost model for edit actions. This seems to make the matching; /// algorithm perform reasonably well.; /// The values range between 0 and 1, or infinity if this edit action should; /// always be avoided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/ASTDiff/ASTDiff.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ASTDiff/ASTDiff.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ASTDiff/ASTDiff.cpp:12,Performance,queue,queue,12,"// Priority queue for nodes, sorted descendingly by their height.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/ASTDiff/ASTDiff.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ASTDiff/ASTDiff.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Diagnostic.cpp:430,Modifiability,refactor,refactoring,430,"//===--- Diagnostic.cpp - Framework for clang diagnostics tools ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implements classes to support/store diagnostics refactoring.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Core/Diagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Diagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Diagnostic.cpp:99,Integrability,depend,depends,99,"// Don't store offset in the scratch space. It doesn't tell anything to the; // user. Moreover, it depends on the history of macro expansions and thus; // prevents deduplication of warnings in headers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Core/Diagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Diagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp:45,Modifiability,refactor,refactoring,45,"//===- Replacement.cpp - Framework for clang refactoring tools ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implements classes to support/store refactorings.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp:419,Modifiability,refactor,refactorings,419,"//===- Replacement.cpp - Framework for clang refactoring tools ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implements classes to support/store refactorings.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp:167,Deployability,integrat,integrate,167,"// FIXME: This should go into the Lexer, but we need to figure out how; // to handle ranges for refactoring in general first - there is no obvious; // good way how to integrate this into the Lexer yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp:167,Integrability,integrat,integrate,167,"// FIXME: This should go into the Lexer, but we need to figure out how; // to handle ranges for refactoring in general first - there is no obvious; // good way how to integrate this into the Lexer yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp:96,Modifiability,refactor,refactoring,96,"// FIXME: This should go into the Lexer, but we need to figure out how; // to handle ranges for refactoring in general first - there is no obvious; // good way how to integrate this into the Lexer yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp:106,Safety,safe,safe,106,"// Insertion `R` is adjacent to a non-insertion replacement `I`, so they; // are order-independent. It is safe to assume that `R` will not conflict; // with any replacement before `I` since all replacements before `I` must; // either end before `R` or end at `R` but has length > 0 (if the; // replacement before `I` is an insertion at `R`, it would have been `I`; // since it is a lower bound of `AtEnd` and ordered before the current `I`; // in the set).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp:53,Safety,safe,safe,53,"// If `R` and `I` do not have the same offset, it is safe to add `R` since; // it must come after `I`. Otherwise:; // - If `R` is an insertion, `I` must not be an insertion since it would; // have come after `AtEnd`.; // - If `R` is not an insertion, `I` must be an insertion; otherwise, `R`; // and `I` would have overlapped.; // In either case, we can safely insert `R`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp:354,Safety,safe,safely,354,"// If `R` and `I` do not have the same offset, it is safe to add `R` since; // it must come after `I`. Otherwise:; // - If `R` is an insertion, `I` must not be an insertion since it would; // have come after `AtEnd`.; // - If `R` is not an insertion, `I` must be an insertion; otherwise, `R`; // and `I` would have overlapped.; // In either case, we can safely insert `R`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp:939,Modifiability,extend,extend,939,"// Represents a merged replacement, i.e. a replacement consisting of multiple; // overlapping replacements from 'First' and 'Second' in mergeReplacements.; //; // Position projection:; // Offsets and lengths of the replacements can generally refer to two different; // coordinate spaces. Replacements from 'First' refer to the original text; // whereas replacements from 'Second' refer to the text after applying 'First'.; //; // MergedReplacement always operates in the coordinate space of the original; // text, i.e. transforms elements from 'Second' to take into account what was; // changed based on the elements from 'First'.; //; // We can correctly calculate this projection as we look at the replacements in; // order of strictly increasing offsets.; //; // Invariants:; // * We always merge elements from 'First' into elements from 'Second' and vice; // versa. Within each set, the replacements are non-overlapping.; // * We only extend to the right, i.e. merge elements with strictly increasing; // offsets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp:115,Deployability,update,update,115,// Sum of all deltas (text-length - length) of elements from 'First' merged; // into this element. This is used to update 'Delta' once the; // MergedReplacement is completed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp:106,Modifiability,extend,extended,106,// Data of the actually merged replacement. FilePath and Offset aren't changed; // as the element is only extended to the right.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp:7,Integrability,Depend,DependencyScanningFilesystem,7,"//===- DependencyScanningFilesystem.cpp - clang-scan-deps fs --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp:3,Performance,Load,Load,3,// Load the file and its content from the file system.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp:71,Integrability,depend,dependencies,71,// Scan the file for preprocessor directives that might affect the; // dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp:17,Performance,perform,performed,17,"// This function performed double-checked locking using `DepDirectives`.; // Assigning it must be the last thing this function does, otherwise other; // threads may skip the; // critical section (`DepDirectives != nullptr`), leading to a data race.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp:130,Performance,cache,cache,130,// This heuristic was chosen using a empirical testing on a; // reasonably high core machine (iMacPro 18 cores / 36 threads). The cache; // sharding gives a performance edge by reducing the lock contention.; // FIXME: A better heuristic might also consider the OS to account for; // the different cost of lock contention on different OSes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp:157,Performance,perform,performance,157,// This heuristic was chosen using a empirical testing on a; // reasonably high core machine (iMacPro 18 cores / 36 threads). The cache; // sharding gives a performance edge by reducing the lock contention.; // FIXME: A better heuristic might also consider the OS to account for; // the different cost of lock contention on different OSes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp:47,Testability,test,testing,47,// This heuristic was chosen using a empirical testing on a; // reasonably high core machine (iMacPro 18 cores / 36 threads). The cache; // sharding gives a performance edge by reducing the lock contention.; // FIXME: A better heuristic might also consider the OS to account for; // the different cost of lock contention on different OSes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp:63,Availability,failure,failures,63,// This may be the module cache directory.; // Only cache stat failures on files that are not expected to change during; // the build.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp:26,Performance,cache,cache,26,// This may be the module cache directory.; // Only cache stat failures on files that are not expected to change during; // the build.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp:52,Performance,cache,cache,52,// This may be the module cache directory.; // Only cache stat failures on files that are not expected to change during; // the build.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp:50,Performance,Cache,CachedFileSystemEntry,50,/// The VFS that is used by clang consumes the \c CachedFileSystemEntry using; /// this subclass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningService.cpp:7,Integrability,Depend,DependencyScanningService,7,"//===- DependencyScanningService.cpp - clang-scan-deps service ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningService.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningService.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningTool.cpp:7,Integrability,Depend,DependencyScanningTool,7,"//===- DependencyScanningTool.cpp - clang-scan-deps service ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningTool.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningTool.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningTool.cpp:35,Integrability,depend,dependencies,35,/// Prints out all of the gathered dependencies into a string.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningTool.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningTool.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningTool.cpp:9,Safety,Avoid,Avoid,9,// TODO: Avoid handleModuleDependency even being called for modules; // we've already seen.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningTool.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningTool.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningTool.cpp:9,Safety,Avoid,Avoid,9,// TODO: Avoid handleModuleDependency even being called for modules; // we've already seen.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningTool.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningTool.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:7,Integrability,Depend,DependencyScanningWorker,7,"//===- DependencyScanningWorker.cpp - clang-scan-deps worker --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:28,Integrability,depend,dependencies,28,/// Forwards the gatherered dependencies to the consumer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:2,Security,Validat,ValidateDiagnosticOptions,2,/*ValidateDiagnosticOptions=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:15,Integrability,depend,dependency,15,/// Deduce the dependency target based on the output file and input files.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:36,Integrability,depend,dependency,36,/// Sanitize diagnostic options for dependency scan.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:4,Security,Sanitiz,Sanitize,4,/// Sanitize diagnostic options for dependency scan.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:33,Availability,error,errors,33,// Don't print 'X warnings and Y errors generated'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:26,Availability,error,errors,26,// Don't emit warnings as errors (and all other warnings too).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:80,Integrability,depend,dependency,80,/// A clang tool that runs the preprocessor in a mode that's optimized for; /// dependency scanning for the given compiler invocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:61,Performance,optimiz,optimized,61,/// A clang tool that runs the preprocessor in a mode that's optimized for; /// dependency scanning for the given compiler invocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:146,Deployability,update,update,146,"// Scanning runs once for the first -cc1 invocation in a chain of driver; // jobs. For any dependent jobs, reuse the scanning result and just; // update the LastCC1Arguments to correspond to the new invocation.; // FIXME: to support multi-arch builds, each arch requires a separate scan",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:91,Integrability,depend,dependent,91,"// Scanning runs once for the first -cc1 invocation in a chain of driver; // jobs. For any dependent jobs, reuse the scanning result and just; // update the LastCC1Arguments to correspond to the new invocation.; // FIXME: to support multi-arch builds, each arch requires a separate scan",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:11,Integrability,depend,dependency,11,// Use the dependency scanning optimized file system if requested to do so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:31,Performance,optimiz,optimized,31,// Use the dependency scanning optimized file system if requested to do so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:14,Integrability,depend,dependency,14,"// Create the dependency collector that will collect the produced; // dependencies.; //; // This also moves the existing dependency output options from the; // invocation to the collector. The options in the invocation are reset,; // which ensures that the compiler won't create new dependency collectors,; // and thus won't write out the extra '.d' files to disk.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:70,Integrability,depend,dependencies,70,"// Create the dependency collector that will collect the produced; // dependencies.; //; // This also moves the existing dependency output options from the; // invocation to the collector. The options in the invocation are reset,; // which ensures that the compiler won't create new dependency collectors,; // and thus won't write out the extra '.d' files to disk.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:121,Integrability,depend,dependency,121,"// Create the dependency collector that will collect the produced; // dependencies.; //; // This also moves the existing dependency output options from the; // invocation to the collector. The options in the invocation are reset,; // which ensures that the compiler won't create new dependency collectors,; // and thus won't write out the extra '.d' files to disk.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:283,Integrability,depend,dependency,283,"// Create the dependency collector that will collect the produced; // dependencies.; //; // This also moves the existing dependency output options from the; // invocation to the collector. The options in the invocation are reset,; // which ensures that the compiler won't create new dependency collectors,; // and thus won't write out the extra '.d' files to disk.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:65,Integrability,depend,dependency,65,// We need at least one -MT equivalent for the generator of make dependency; // files to work.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:189,Energy Efficiency,reduce,reduce,189,// Consider different header search and diagnostic options to create; // different modules. This avoids the unsound aliasing of module PCMs.; //; // TODO: Implement diagnostic bucketing to reduce the impact of strict; // context hashing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:97,Safety,avoid,avoids,97,// Consider different header search and diagnostic options to create; // different modules. This avoids the unsound aliasing of module PCMs.; //; // TODO: Implement diagnostic bucketing to reduce the impact of strict; // context hashing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:229,Security,hash,hashing,229,// Consider different header search and diagnostic options to create; // different modules. This avoids the unsound aliasing of module PCMs.; //; // TODO: Implement diagnostic bucketing to reduce the impact of strict; // context hashing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:49,Performance,load,loading,49,// Avoid some checks and module map parsing when loading PCM files.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:3,Safety,Avoid,Avoid,3,// Avoid some checks and module map parsing when loading PCM files.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:143,Integrability,depend,dependencies,143,/// Take the cc1 arguments corresponding to the most recent invocation used; /// with this action. Any modifications implied by the discovered dependencies; /// will have already been applied.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:86,Availability,failure,failure,86,// Capture the emitted diagnostics and report them to the client; // in the case of a failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:47,Integrability,depend,dependency,47,// Non-clang command. Just pass through to the dependency; // consumer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:163,Integrability,depend,dependency,163,// Create an invocation that uses the underlying file; // system to ensure that any file system requests that; // are made by the driver do not go through the; // dependency scanning filesystem.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:56,Integrability,depend,dependency,56,// Only preserve search paths that were used during the dependency scan.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:76,Performance,optimiz,optimize,76,"// If this is not a system module or -Wsystem-headers was passed, don't; // optimize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:21,Integrability,depend,dependency,21,"// Fallback to -o as dependency target, as in the driver.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:90,Security,hash,hash,90,"// Map output paths that affect behaviour to ""-"" so their existence is in the; // context hash. The final path will be computed in addOutputPaths.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:42,Usability,simpl,simplify,42,// TODO: Track these as `FileEntryRef` to simplify the equality check below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:54,Integrability,depend,dependency,54,"// Don't report module maps describing eagerly-loaded dependency. This; // information will be deserialized from the PCM.; // TODO: Verify this works fine when modulemap for module A is eagerly; // loaded from A.pcm, and module map passed on the command line contains; // definition of a submodule: ""explicit module A.Private { ... }"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:47,Performance,load,loaded,47,"// Don't report module maps describing eagerly-loaded dependency. This; // information will be deserialized from the PCM.; // TODO: Verify this works fine when modulemap for module A is eagerly; // loaded from A.pcm, and module map passed on the command line contains; // definition of a submodule: ""explicit module A.Private { ... }"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:198,Performance,load,loaded,198,"// Don't report module maps describing eagerly-loaded dependency. This; // information will be deserialized from the PCM.; // TODO: Verify this works fine when modulemap for module A is eagerly; // loaded from A.pcm, and module map passed on the command line contains; // definition of a submodule: ""explicit module A.Private { ... }"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:85,Integrability,depend,dependency,85,// Don't report module map file of the current module unless it also; // describes a dependency (for symmetry).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:31,Integrability,depend,dependencies,31,// Add module file inputs from dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:32,Performance,load,load,32,// Only pcm is needed for eager load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:63,Integrability,depend,dependencies,63,// TODO: Report module maps the same way it's done for modular dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:3,Security,Hash,Hash,3,// Hash the compiler version and serialization version to ensure the module; // will be readable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:3,Security,Hash,Hash,3,// Hash the BuildInvocation without any input files.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:19,Integrability,depend,dependencies,19,"// Hash the module dependencies. These paths may differ even if the invocation; // is identical if they depend on the contents of the files in the TU -- for; // example, case-insensitive paths to modulemap files. Usually such a case; // would indicate a missed optimization to canonicalize, but it may be; // difficult to canonicalize all cases when there is a VFS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:104,Integrability,depend,depend,104,"// Hash the module dependencies. These paths may differ even if the invocation; // is identical if they depend on the contents of the files in the TU -- for; // example, case-insensitive paths to modulemap files. Usually such a case; // would indicate a missed optimization to canonicalize, but it may be; // difficult to canonicalize all cases when there is a VFS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:261,Performance,optimiz,optimization,261,"// Hash the module dependencies. These paths may differ even if the invocation; // is identical if they depend on the contents of the files in the TU -- for; // example, case-insensitive paths to modulemap files. Usually such a case; // would indicate a missed optimization to canonicalize, but it may be; // difficult to canonicalize all cases when there is a VFS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:3,Security,Hash,Hash,3,"// Hash the module dependencies. These paths may differ even if the invocation; // is identical if they depend on the contents of the files in the TU -- for; // example, case-insensitive paths to modulemap files. Usually such a case; // would indicate a missed optimization to canonicalize, but it may be; // difficult to canonicalize all cases when there is a VFS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:41,Security,hash,hash,41,// This has to be delayed as the context hash can change at the start of; // `CompilerInstance::ExecuteAction`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:3,Integrability,Depend,Dependency,3,// Dependency generation really does want to go all the way to the; // file entry for a source location to find out what is depended on.; // We do not want #line markers to affect dependency generation!,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:124,Integrability,depend,depended,124,// Dependency generation really does want to go all the way to the; // file entry for a source location to find out what is depended on.; // We do not want #line markers to affect dependency generation!,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:180,Integrability,depend,dependency,180,// Dependency generation really does want to go all the way to the; // file entry for a source location to find out what is depended on.; // We do not want #line markers to affect dependency generation!,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:22,Integrability,depend,dependencies,22,// Only report direct dependencies that were successfully handled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:215,Integrability,depend,dependencies,215,// A top-level module might not be actually imported as a module when; // -fmodule-name is used to compile a translation unit that imports this; // module. In that case it can be skipped. The appropriate header; // dependencies will still be reported as expected.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:44,Integrability,depend,dependencies,44,// Finish the compiler invocation. Requires dependencies and the context hash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:73,Security,hash,hash,73,// Finish the compiler invocation. Requires dependencies and the context hash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:19,Integrability,depend,depends,19,"// Submodule order depends on order of header includes for inferred submodules; // we don't care about the exact order, so sort so that it's consistent across; // TUs to improve sharing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:125,Integrability,depend,dependencies,125,"// Within P1689 format, we don't want all the paths to be absolute path; // since it may violate the tranditional make style dependencies info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DumpTool/ASTSrcLocProcessor.cpp:187,Safety,avoid,avoid,187,// The clang AST has several methods on base classes which are overriden; // pseudo-virtually by derived classes.; // We record only the pseudo-virtual methods on the base classes to; // avoid duplication.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DumpTool/ASTSrcLocProcessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DumpTool/ASTSrcLocProcessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DumpTool/ClangSrcLocDump.cpp:15,Availability,error,errors,15,"// Suppress ""2 errors generated"" or similar messages",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DumpTool/ClangSrcLocDump.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DumpTool/ClangSrcLocDump.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DumpTool/ClangSrcLocDump.cpp:44,Integrability,message,messages,44,"// Suppress ""2 errors generated"" or similar messages",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DumpTool/ClangSrcLocDump.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DumpTool/ClangSrcLocDump.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Inclusions/HeaderAnalysis.cpp:15,Availability,error,error,15,// Is Line an #error directive mentioning includes?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Inclusions/HeaderAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Inclusions/HeaderAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Inclusions/HeaderAnalysis.cpp:47,Safety,avoid,avoid,47,"// Strip off whitespace and comment markers to avoid confusion. This isn't; // fully-compatible with IWYU, which splits into whitespace-delimited tokens.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Inclusions/HeaderAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Inclusions/HeaderAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Inclusions/HeaderIncludes.cpp:187,Safety,avoid,avoid,187,"// Returns the offset of the last #include directive after which a new; // #include can be inserted. This ignores #include's after the #include block(s); // in the beginning of a file to avoid inserting headers into code sections; // where new #include's should not be added by default.; // These code sections include:; // - raw string literals (containing #include).; // - #if blocks.; // - Special #include's among declarations (e.g. functions).; //; // If no #include after which a new #include can be inserted, this returns the; // offset after skipping all comments from the start of the code.; // Inserting after an #include is not allowed if it comes after code that is not; // #include (e.g. pre-processing directive that is not #include, declarations).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Inclusions/HeaderIncludes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Inclusions/HeaderIncludes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Inclusions/Stdlib/StandardLibrary.cpp:46,Availability,avail,available,46,"// First symbol or new symbol, increment next available index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Inclusions/Stdlib/StandardLibrary.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Inclusions/Stdlib/StandardLibrary.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp:34,Modifiability,refactor,refactoring,34,"//===--- ASTSelection.cpp - Clang refactoring library ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp:3,Safety,Avoid,Avoid,3,// Avoid traversing the semantic expressions. They should be handled by; // looking through the appropriate opaque expressions in order to build; // a meaningful selection tree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp:3,Safety,Avoid,Avoid,3,// Avoid selecting implicit 'this' expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp:111,Testability,test,test,111,"// Select the parent expression when:; // - The string literal in ObjC string literal is selected, e.g.:; // @""test"" becomes @""test""; // ~~~~~~ ~~~~~~~",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp:127,Testability,test,test,127,"// Select the parent expression when:; // - The string literal in ObjC string literal is selected, e.g.:; // @""test"" becomes @""test""; // ~~~~~~ ~~~~~~~",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp:323,Modifiability,Refactor,Refactor,323,"// FIXME (Alex L): First selected SwitchCase means that first case statement.; // is selected actually; // (See https://github.com/apple/swift-clang & CompoundStmtRange).; // FIXME (Alex L): Tweak selection rules for compound statements, see:; // https://github.com/apple/swift-clang/blob/swift-4.1-branch/lib/Tooling/; // Refactor/ASTSlice.cpp#L513; // The user selected multiple statements in a compound statement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp:19,Testability,Test,Test,19,// FIXME (Alex L): Test for BlockDecl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp:46,Safety,avoid,avoid,46,"// Stop the search at any type declaration to avoid returning true for; // expressions in type declarations in functions, like:; // function foo() { struct X {; // int m = /*selection:*/ 1 + 2 /*selection end*/; }; };",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelectionRequirements.cpp:46,Modifiability,refactor,refactoring,46,"//===--- ASTSelectionRequirements.cpp - Clang refactoring library ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelectionRequirements.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelectionRequirements.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/AtomicChange.cpp:76,Security,access,access,76,/// Helper to (de)serialize an AtomicChange since we don't have direct; /// access to its data members.; /// Data members of a normalized AtomicChange can be directly mapped from/to; /// YAML string.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/AtomicChange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/AtomicChange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Lookup.cpp:42,Modifiability,refactor,refactoring,42,"//===--- Lookup.cpp - Framework for clang refactoring tools ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines helper methods for clang tools performing name lookup.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Lookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Lookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Lookup.cpp:432,Performance,perform,performing,432,"//===--- Lookup.cpp - Framework for clang refactoring tools ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines helper methods for clang tools performing name lookup.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Lookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Lookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Lookup.cpp:23,Availability,redundant,redundant,23,// Otherwise strip off redundant namespace qualifications from the new name.; // We use the fully qualified name of the namespace and remove that part; // from NewName if it has an identical prefix.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Lookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Lookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Lookup.cpp:23,Safety,redund,redundant,23,// Otherwise strip off redundant namespace qualifications from the new name.; // We use the fully qualified name of the namespace and remove that part; // from NewName if it has an identical prefix.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Lookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Lookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Lookup.cpp:368,Availability,error,error,368,"// Adds more scope specifier to the spelled name until the spelling is not; // ambiguous. A spelling is ambiguous if the resolution of the symbol is; // ambiguous. For example, if QName is ""::y::bar"", the spelling is ""y::bar"", and; // context contains a nested namespace ""a::y"", then ""y::bar"" can be resolved to; // ::a::y::bar in the context, which can cause compile error.; // FIXME: consider using namespaces.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Lookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Lookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Lookup.cpp:295,Modifiability,refactor,refactor,295,"// We can do a raw name replacement when we are not inside the namespace for; // the original class/function and it is not in the global namespace. The; // assumption is that outside the original namespace we must have a using; // statement that makes this work out and that other parts of this refactor; // will automatically fix using statements to point to the new class/function.; // However, if the `FromDecl` is a class forward declaration, the reference is; // still considered as referring to the original definition, so we can't do a; // raw name replacement in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Lookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Lookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/RefactoringActions.cpp:9,Modifiability,Refactor,RefactoringActions,9,"//===--- RefactoringActions.cpp - Constructs refactoring actions ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/RefactoringActions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/RefactoringActions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/RefactoringActions.cpp:45,Modifiability,refactor,refactoring,45,"//===--- RefactoringActions.cpp - Constructs refactoring actions ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/RefactoringActions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/RefactoringActions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/RefactoringActions.cpp:10,Modifiability,Rewrite,Rewrite,10,// FIXME: Rewrite the Actions to avoid duplication of descriptions/names with; // rules.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/RefactoringActions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/RefactoringActions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/RefactoringActions.cpp:33,Safety,avoid,avoid,33,// FIXME: Rewrite the Actions to avoid duplication of descriptions/names with; // rules.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/RefactoringActions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/RefactoringActions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/RefactoringActions.cpp:21,Modifiability,refactor,refactoring,21,/// Returns a set of refactoring actions rules that are defined by this; /// action.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/RefactoringActions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/RefactoringActions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/RefactoringActions.cpp:10,Modifiability,Rewrite,Rewrite,10,// FIXME: Rewrite the Actions to avoid duplication of descriptions/names with; // rules.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/RefactoringActions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/RefactoringActions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/RefactoringActions.cpp:33,Safety,avoid,avoid,33,// FIXME: Rewrite the Actions to avoid duplication of descriptions/names with; // rules.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/RefactoringActions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/RefactoringActions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/RefactoringActions.cpp:21,Modifiability,refactor,refactoring,21,/// Returns a set of refactoring actions rules that are defined by this; /// action.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/RefactoringActions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/RefactoringActions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp:29,Modifiability,refactor,refactoring,29,"//===--- Extract.cpp - Clang refactoring library --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Implements the ""extract"" refactoring that can pull code into; /// new functions, methods or declare new variables.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp:421,Modifiability,refactor,refactoring,421,"//===--- Extract.cpp - Clang refactoring library --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Implements the ""extract"" refactoring that can pull code into; /// new functions, methods or declare new variables.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp:500,Modifiability,variab,variables,500,"//===--- Extract.cpp - Clang refactoring library --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Implements the ""extract"" refactoring that can pull code into; /// new functions, methods or declare new variables.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp:30,Usability,simpl,simple,30,/// Returns true if \c E is a simple literal or a reference expression that; /// should not be extracted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp:114,Modifiability,variab,variable,114,// We would like to extract code out of functions/methods/blocks.; // Prohibit extraction from things like global variable / field; // initializers and other top-level expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp:3,Safety,Avoid,Avoid,3,// Avoid extraction of simple literals and references.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp:23,Usability,simpl,simple,23,// Avoid extraction of simple literals and references.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp:23,Modifiability,variab,variables,23,// FIXME: Capture used variables.; // Compute the return type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp:30,Usability,user-friendly,user-friendly,30,// FIXME (Alex L): Get a more user-friendly type if needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp:10,Modifiability,Rewrite,Rewrite,10,// FIXME: Rewrite the extracted code performing any required adjustments.; // FIXME: Capture any field if necessary (method -> function extraction).; // FIXME: Sort captured variables by name.; // FIXME: Capture 'this' / 'self' if necessary.; // FIXME: Compute the actual parameter types.; // Compute the location of the extracted declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp:174,Modifiability,variab,variables,174,// FIXME: Rewrite the extracted code performing any required adjustments.; // FIXME: Capture any field if necessary (method -> function extraction).; // FIXME: Sort captured variables by name.; // FIXME: Capture 'this' / 'self' if necessary.; // FIXME: Compute the actual parameter types.; // Compute the location of the extracted declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp:37,Performance,perform,performing,37,// FIXME: Rewrite the extracted code performing any required adjustments.; // FIXME: Capture any field if necessary (method -> function extraction).; // FIXME: Sort captured variables by name.; // FIXME: Capture 'this' / 'self' if necessary.; // FIXME: Compute the actual parameter types.; // Compute the location of the extracted declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/SourceExtraction.cpp:38,Modifiability,refactor,refactoring,38,"//===--- SourceExtraction.cpp - Clang refactoring library -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/SourceExtraction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/SourceExtraction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/RenamingAction.cpp:36,Modifiability,refactor,refactoring,36,"//===--- RenamingAction.cpp - Clang refactoring library -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Provides an action to rename every symbol at a point.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/RenamingAction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/RenamingAction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/RenamingAction.cpp:55,Availability,error,error,55,// FIXME: Support multi-piece names.; // FIXME: better error handling (propagate error out).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/RenamingAction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/RenamingAction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/RenamingAction.cpp:81,Availability,error,error,81,// FIXME: Support multi-piece names.; // FIXME: better error handling (propagate error out).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/RenamingAction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/RenamingAction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/RenamingAction.cpp:48,Modifiability,refactor,refactoring,48,// FIXME: Apply AtomicChanges directly once the refactoring APIs are; // ready.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/RenamingAction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/RenamingAction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/SymbolOccurrences.cpp:39,Modifiability,refactor,refactoring,39,"//===--- SymbolOccurrences.cpp - Clang refactoring library ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/SymbolOccurrences.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/SymbolOccurrences.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRFinder.cpp:31,Modifiability,refactor,refactoring,31,"//===--- USRFinder.cpp - Clang refactoring library ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file Implements a recursive AST visitor that finds the USR of a symbol at a; /// point.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRFinder.cpp:14,Testability,test,tests,14,// FIXME: Add tests for Point == End.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRFinder.cpp:34,Availability,down,down,34,// Try to be clever about pruning down the number of top-level declarations we; // see. If both start and end is either before or after the point we're; // looking for the point cannot be inside of this decl. Don't even look at it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRFinder.cpp:14,Testability,test,test,14,// FIXME: Add test for the nullptr case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRFindingAction.cpp:38,Modifiability,refactor,refactoring,38,"//===--- USRFindingAction.cpp - Clang refactoring library -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Provides an action to find USR for the symbol at <offset>, as well as; /// all additional USRs.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRFindingAction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRFindingAction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRFindingAction.cpp:116,Deployability,update,update,116,"// FIXME: (Alex L): Canonicalize implicit template instantions, just like; // the indexer does it.; // Note: please update the declaration's doc comment every time the; // canonicalization rules are changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRFindingAction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRFindingAction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp:34,Modifiability,refactor,refactoring,34,"//===--- USRLocFinder.cpp - Clang refactoring library ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Methods for finding all instances of a USR. Our strategy is very; /// simple; we just compare the USR at every relevant AST node with the one; /// provided.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp:466,Usability,simpl,simple,466,"//===--- USRLocFinder.cpp - Clang refactoring library ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Methods for finding all instances of a USR. Our strategy is very; /// simple; we just compare the USR at every relevant AST node with the one; /// provided.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp:158,Safety,avoid,avoid,158,"// Determine whether the prefix qualifiers of the NewName should be ignored.; // Normally, we set it to true for the symbol declaration and definition to; // avoid adding prefix qualifiers.; // For example, if it is true and NewName is ""a::b::foo"", then the symbol; // occurrence which the RenameInfo points to will be renamed to ""foo"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp:157,Energy Efficiency,Green,Green,157,"// In case of renaming an enum declaration, we have to explicitly handle; // unscoped enum constants referenced in expressions (e.g.; // ""auto r = ns1::ns2::Green"" where Green is an enum constant of an unscoped; // enum decl ""ns1::ns2::Color"") as these enum constants cannot be caught by; // TypeLoc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp:170,Energy Efficiency,Green,Green,170,"// In case of renaming an enum declaration, we have to explicitly handle; // unscoped enum constants referenced in expressions (e.g.; // ""auto r = ns1::ns2::Green"" where Green is an enum constant of an unscoped; // enum decl ""ns1::ns2::Color"") as these enum constants cannot be caught by; // TypeLoc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp:67,Energy Efficiency,Green,Green,67,// FIXME: Handle the enum constant without prefix qualifiers (`a = Green`); // when renaming an unscoped enum declaration with a new namespace.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp:44,Energy Efficiency,Green,Green,44,"// The current fix would qualify ""ns1::ns2::Green"" as; // ""ns1::ns2::Color::Green"".; //; // Get the EndLoc of the replacement by moving 1 character backward (; // to exclude the last '::').; //; // ns1::ns2::Green;; // ^ ^^; // BeginLoc |EndLoc of the qualifier; // new EndLoc",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp:76,Energy Efficiency,Green,Green,76,"// The current fix would qualify ""ns1::ns2::Green"" as; // ""ns1::ns2::Color::Green"".; //; // Get the EndLoc of the replacement by moving 1 character backward (; // to exclude the last '::').; //; // ns1::ns2::Green;; // ^ ^^; // BeginLoc |EndLoc of the qualifier; // new EndLoc",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp:208,Energy Efficiency,Green,Green,208,"// The current fix would qualify ""ns1::ns2::Green"" as; // ""ns1::ns2::Color::Green"".; //; // Get the EndLoc of the replacement by moving 1 character backward (; // to exclude the last '::').; //; // ns1::ns2::Green;; // ^ ^^; // BeginLoc |EndLoc of the qualifier; // new EndLoc",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp:94,Integrability,interface,interface,94,"// Handle cases of nested name specificier locations.; //; // The VisitNestedNameSpecifierLoc interface is not impelmented in; // RecursiveASTVisitor, we have to handle it explicitly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp:60,Deployability,update,update,60,// Returns a list of using declarations which are needed to update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp:193,Usability,simpl,simply,193,"// This fixes the case where type `T` is a parameter inside a function; // type (e.g. `std::function<void(T)>`) and the DeclContext of `T`; // becomes the translation unit. As a workaround, we simply use; // fully-qualified name here for all references whose `DeclContext` is; // the translation unit and ignore the possible existence of; // using-decls (in the global scope) that can shorten the replaced; // name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:158,Integrability,wrap,wrapping,158,"// Ignores the implicit `CXXConstructExpr` for copy/move constructor calls; // generated by the compiler, as well as in implicit conversions like the one; // wrapping `1` in `X x = 1;`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:110,Integrability,wrap,wraps,110,// In:; // struct X {; // X(int); // };; // X x = X(1);; // Ignores the implicit `CXXFunctionalCastExpr` that wraps; // `CXXConstructExpr X(1)`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:98,Modifiability,inherit,inheritors,98,"// All other cases are not important, as they are either part of declaration; // specifiers (e.g. inheritors of TypeSpecTypeLoc) or introduce modifiers on; // existing declarators (e.g. QualifiedTypeLoc). They cannot start the; // declarator themselves, but their underlying type can.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:3,Safety,avoid,avoid,3,// avoid recursing into the suffix of declarator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:163,Security,expose,expose,163,"/// Maintains a mapping from AST to syntax tree nodes. This class will get more; /// complicated as we support more kinds of AST nodes, e.g. TypeLocs.; /// FIXME: expose this as public API.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:194,Integrability,wrap,wraps,194,"/// Mark the \p Child node with a corresponding \p Role. All marked children; /// should be consumed by foldNode.; /// When called on expressions (clang::Expr is derived from clang::Stmt),; /// wraps expressions into expression statement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:77,Integrability,wrap,wrapping,77,/// Should be called for expressions in non-statement position to avoid; /// wrapping into expression statement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:66,Safety,avoid,avoid,66,/// Should be called for expressions in non-statement position to avoid; /// wrapping into expression statement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:100,Usability,Simpl,SimpleDeclaration,100,/// Returns true if \p D is the last declarator in a chain and is thus; /// reponsible for creating SimpleDeclaration for the whole chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:215,Deployability,update,update,215,"/// A collection of trees covering the input tokens.; /// When created, each tree corresponds to a single token in the file.; /// Clients call 'foldChildren' to attach one or more subtrees to a parent; /// node and update the list of trees accordingly.; ///; /// Ensures that added nodes properly nest and cover the whole token stream.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:47,Usability,Simpl,SimpleDeclaration,47,"// We want to consume the semicolon, make sure SimpleDeclaration does not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:73,Integrability,Depend,DependentTemplateSpecializationType,73,// FIXME: Fix `NestedNameSpecifierLoc::getLocalSourceRange` for the; // `DependentTemplateSpecializationType` case.; /// Given a nested-name-specifier return the range for the last name; /// specifier.; ///; /// e.g. `std::T::template X<U>::` => `template X<U>::`,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:146,Integrability,Depend,DependentTemplateSpecializationType,146,"// The method `NestedNameSpecifierLoc::getLocalSourceRange` *should*; // return the desired `SourceRange`, but there is a corner case. For a; // `DependentTemplateSpecializationType` this method returns its; // qualifiers as well, in other words in the example above this method; // returns `T::template X<U>::` instead of only `template X<U>::`",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:47,Integrability,depend,dependent,47,// The 'template' keyword is always present in dependent template; // specializations. Except in the case of incorrect code; // TODO: Treat the case of incorrect code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:72,Security,access,accessors,72,"// TODO: Build `SimpleTemplateNameSpecifier` children and implement; // accessors to them.; // Be aware, we cannot do that simply by calling `TraverseTypeLoc`,; // some `TypeLoc`s have inside them the previous name specifier and; // we want to treat them independently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:16,Usability,Simpl,SimpleTemplateNameSpecifier,16,"// TODO: Build `SimpleTemplateNameSpecifier` children and implement; // accessors to them.; // Be aware, we cannot do that simply by calling `TraverseTypeLoc`,; // some `TypeLoc`s have inside them the previous name specifier and; // we want to treat them independently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:123,Usability,simpl,simply,123,"// TODO: Build `SimpleTemplateNameSpecifier` children and implement; // accessors to them.; // Be aware, we cannot do that simply by calling `TraverseTypeLoc`,; // some `TypeLoc`s have inside them the previous name specifier and; // we want to treat them independently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:19,Security,access,accessor,19,"// TODO: Implement accessor to `DecltypeNameSpecifier` inner; // `DecltypeTypeLoc`.; // For that add mapping from `TypeLoc` to `syntax::Node*` then:; // Builder.markChild(TypeLoc, syntax::NodeRole);",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:57,Usability,simpl,simple,57,"// For `MemberExpr` with implicit `this->` we generate a simple; // `id-expression` syntax node, beacuse an implicit `member-expression` is; // syntactically undistinguishable from an `id-expression`",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:8,Testability,log,logic,8,// Same logic as DeclRefExpr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:10,Testability,Assert,Assert,10,// FIXME: Assert that `LParenToken` is indeed a `l_paren` once we have fixed; // the test on decltype desctructors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:85,Testability,test,test,85,// FIXME: Assert that `LParenToken` is indeed a `l_paren` once we have fixed; // the test on decltype desctructors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:177,Usability,simpl,simple,177,"// To construct a syntax tree of the same shape for calls to built-in and; // user-defined operators, ignore the `DeclRefExpr` that refers to the; // operator and treat it as a simple token. Do that by traversing; // arguments instead of children.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:10,Testability,Assert,Assert,10,// FIXME: Assert that `LParenToken` is indeed a `l_paren` once we have; // fixed the test on decltype desctructors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:85,Testability,test,test,85,// FIXME: Assert that `LParenToken` is indeed a `l_paren` once we have; // fixed the test on decltype desctructors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:70,Testability,test,test,70,// FIXME: Deleting the `TraverseParenTypeLoc` override doesn't change test; // results. Find test coverage or remove it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:93,Testability,test,test,93,// FIXME: Deleting the `TraverseParenTypeLoc` override doesn't change test; // results. Find test coverage or remove it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:10,Usability,Simpl,SimpleDeclarator,10,/// Folds SimpleDeclarator node (if present) and in case this is the last; /// declarator in the chain it also folds SimpleDeclaration node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:117,Usability,Simpl,SimpleDeclaration,117,/// Folds SimpleDeclarator node (if present) and in case this is the last; /// declarator in the chain it also folds SimpleDeclaration node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/ComputeReplacements.cpp:3,Modifiability,Extend,Extend,3,// Extend the current span.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/ComputeReplacements.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/ComputeReplacements.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Mutations.cpp:18,Security,access,access,18,// This class has access to the internals of tree nodes. Its sole purpose is to; // define helpers that allow implementing the high-level mutation operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/Mutations.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Mutations.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Mutations.cpp:44,Safety,safe,safely,44,// A child of CompoundStatement can just be safely removed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/Mutations.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Mutations.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Synthesis.cpp:4,Security,Expose,Exposes,4,/// Exposes private syntax tree APIs required to implement node synthesis.; /// Should not be used for anything else.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/Synthesis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Synthesis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Synthesis.cpp:3,Energy Efficiency,Allocate,Allocates,3,// Allocates the concrete syntax `Tree` according to its `NodeKind`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/Synthesis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Synthesis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp:118,Security,validat,validating,118,"// There are two main parts to this algorithm:; // - identifying which spelled range covers the expanded tokens; // - validating that this range doesn't cover any extra tokens (First/Last); //; // We do these in order. However as we transform the expanded range into the; // spelled one, we adjust First/Last so the validation remains simple.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp:316,Security,validat,validation,316,"// There are two main parts to this algorithm:; // - identifying which spelled range covers the expanded tokens; // - validating that this range doesn't cover any extra tokens (First/Last); //; // We do these in order. However as we transform the expanded range into the; // spelled one, we adjust First/Last so the validation remains simple.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp:335,Usability,simpl,simple,335,"// There are two main parts to this algorithm:; // - identifying which spelled range covers the expanded tokens; // - validating that this range doesn't cover any extra tokens (First/Last); //; // We do these in order. However as we transform the expanded range into the; // spelled one, we adjust First/Last so the validation remains simple.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp:84,Integrability,wrap,wrapped,84,"// Careful, given:; // #define HIDE ID(ID(a)); // ID(ID(HIDE)); // The token `a` is wrapped in 4 arg-expansions, we only want to unwrap 2.; // We distinguish them by whether the macro expands into the target file.; // Fortunately, the target file ones will always appear first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp:3,Safety,Avoid,Avoid,3,// Avoid returning empty ranges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp:172,Security,access,access,172,/// Disabled instance will stop reporting anything to TokenCollector.; /// This ensures that uses of the preprocessor after TokenCollector::consume(); /// is called do not access the (possibly invalid) collector instance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp:267,Modifiability,rewrite,rewrite,267,"// Only record top-level expansions that directly produce expanded tokens.; // This excludes those where:; // - the macro use is inside a macro body,; // - the macro appears in an argument to another macro.; // However macro expansion isn't really a tree, it's token rewrite rules,; // so there are other cases, e.g.; // #define B(X) X; // #define A 1 + B; // A(2); // Both A and B produce expanded tokens, though the macro name 'B' comes; // from an expansion. The best we can do is merge the mappings for both.; // The *last* token of any top-level macro expansion must be in a file.; // (In the example above, see the closing paren of the expansion of B).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp:12,Safety,detect,detect,12,/// Used to detect recursive macro expansions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp:45,Availability,recover,recover,45,"// And locations of macro calls, to properly recover boundaries of those in; // case of empty expansions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp:45,Safety,recover,recover,45,"// And locations of macro calls, to properly recover boundaries of those in; // case of empty expansions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp:163,Testability,log,logical,163,"// The expanded token stream consists of runs of tokens that came from; // the same source (a macro expansion, part of a file etc).; // Between these runs are the logical positions of spelled tokens that; // didn't expand to anything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp:225,Energy Efficiency,Drain,Drain,225,"// Consume a sequence of spelled tokens that didn't expand to anything.; // In the simplest case, skips spelled tokens until finding one that produced; // the NextExpanded token, and creates an empty mapping for them.; // If Drain is provided, skips remaining tokens from that file instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp:83,Usability,simpl,simplest,83,"// Consume a sequence of spelled tokens that didn't expand to anything.; // In the simplest case, skips spelled tokens until finding one that produced; // the NextExpanded token, and creates an empty mapping for them.; // If Drain is provided, skips remaining tokens from that file instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tree.cpp:10,Security,validat,validate,10,// FIXME: validate the role.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/Tree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tree.cpp:77,Testability,assert,assert,77,// FIXME: re-enable it when there is way to retrieve token kind in Leaf.; // assert(cast<Leaf>(C).getToken()->kind() == L->getDelimiterTokenKind());,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/Tree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp:78,Availability,error,error,78,// The original input. Not modified during parsing; only for reference in; // error reporting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp:26,Availability,Error,ErrorInfo,26,// Required field for all ErrorInfo derivatives.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp:19,Availability,error,error,19,// Position of the error in the input string.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp:40,Availability,error,error,40,// Excerpt of the input starting at the error position.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp:93,Availability,Error,Error,93,"// Parses a single expected character \c c from \c State, skipping preceding; // whitespace. Error if the expected character isn't found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp:163,Availability,error,error,163,"// Parses input for a stencil operator(single arg ops like AsValue, MemberOp or; // Id operator). Returns StencilType representing the operator on success and; // error if it fails to parse input for an operator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RangeSelector.cpp:39,Modifiability,config,configurable,39,// FIXME: handling of macros should be configurable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/RangeSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RangeSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RangeSelector.cpp:105,Modifiability,config,configurable,105,// Finds the start location of the previous token of kind \p TK.; // FIXME: handling of macros should be configurable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/RangeSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RangeSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RangeSelector.cpp:61,Modifiability,extend,extend,61,"// Verify that the range covers exactly the name.; // FIXME: extend this code to support cases like `operator +` or; // `foo<int>` for which this range will be too short. Doing so will; // require subcasing `NamedDecl`, because it doesn't provide virtual; // access to the \c DeclarationNameInfo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/RangeSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RangeSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RangeSelector.cpp:259,Security,access,access,259,"// Verify that the range covers exactly the name.; // FIXME: extend this code to support cases like `operator +` or; // `foo<int>` for which this range will be too short. Doing so will; // require subcasing `NamedDecl`, because it doesn't provide virtual; // access to the \c DeclarationNameInfo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/RangeSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RangeSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RangeSelector.cpp:20,Availability,avail,available,20,"// FIXME: make this available in the public API for users to easily create their; // own selectors.; // Creates a selector from a range-selection function \p Func, which selects a; // range that is relative to a bound node id. \c T is the node type expected by; // \p Func.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/RangeSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RangeSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp:60,Availability,error,error,60,"// FIXME: let user specify whether to treat this case as an error or ignore; // it as is currently done. This behavior is problematic in that it hides; // failures from bad ranges. Also, the behavior here differs from; // `flatten`. Here, we abort (without error), whereas flatten, if it hits an; // empty list, does not abort. As a result, `editList({A,B})` is not; // equivalent to `flatten(edit(A), edit(B))`. The former will abort if `A`; // produces a bad range, whereas the latter will simply ignore A.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp:155,Availability,failure,failures,155,"// FIXME: let user specify whether to treat this case as an error or ignore; // it as is currently done. This behavior is problematic in that it hides; // failures from bad ranges. Also, the behavior here differs from; // `flatten`. Here, we abort (without error), whereas flatten, if it hits an; // empty list, does not abort. As a result, `editList({A,B})` is not; // equivalent to `flatten(edit(A), edit(B))`. The former will abort if `A`; // produces a bad range, whereas the latter will simply ignore A.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp:257,Availability,error,error,257,"// FIXME: let user specify whether to treat this case as an error or ignore; // it as is currently done. This behavior is problematic in that it hides; // failures from bad ranges. Also, the behavior here differs from; // `flatten`. Here, we abort (without error), whereas flatten, if it hits an; // empty list, does not abort. As a result, `editList({A,B})` is not; // equivalent to `flatten(edit(A), edit(B))`. The former will abort if `A`; // produces a bad range, whereas the latter will simply ignore A.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp:242,Safety,abort,abort,242,"// FIXME: let user specify whether to treat this case as an error or ignore; // it as is currently done. This behavior is problematic in that it hides; // failures from bad ranges. Also, the behavior here differs from; // `flatten`. Here, we abort (without error), whereas flatten, if it hits an; // empty list, does not abort. As a result, `editList({A,B})` is not; // equivalent to `flatten(edit(A), edit(B))`. The former will abort if `A`; // produces a bad range, whereas the latter will simply ignore A.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp:321,Safety,abort,abort,321,"// FIXME: let user specify whether to treat this case as an error or ignore; // it as is currently done. This behavior is problematic in that it hides; // failures from bad ranges. Also, the behavior here differs from; // `flatten`. Here, we abort (without error), whereas flatten, if it hits an; // empty list, does not abort. As a result, `editList({A,B})` is not; // equivalent to `flatten(edit(A), edit(B))`. The former will abort if `A`; // produces a bad range, whereas the latter will simply ignore A.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp:429,Safety,abort,abort,429,"// FIXME: let user specify whether to treat this case as an error or ignore; // it as is currently done. This behavior is problematic in that it hides; // failures from bad ranges. Also, the behavior here differs from; // `flatten`. Here, we abort (without error), whereas flatten, if it hits an; // empty list, does not abort. As a result, `editList({A,B})` is not; // equivalent to `flatten(edit(A), edit(B))`. The former will abort if `A`; // produces a bad range, whereas the latter will simply ignore A.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp:492,Usability,simpl,simply,492,"// FIXME: let user specify whether to treat this case as an error or ignore; // it as is currently done. This behavior is problematic in that it hides; // failures from bad ranges. Also, the behavior here differs from; // `flatten`. Here, we abort (without error), whereas flatten, if it hits an; // empty list, does not abort. As a result, `editList({A,B})` is not; // equivalent to `flatten(edit(A), edit(B))`. The former will abort if `A`; // produces a bad range, whereas the latter will simply ignore A.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp:286,Modifiability,Rewrite,RewriteRule,286,"/// Matches nodes of type T that have at least one descendant node for which the; /// given inner matcher matches. Will match for each descendant node that; /// matches. Based on ForEachDescendantMatcher, but takes a dynamic matcher,; /// instead of a static one, because it is used by RewriteRule, which carries; /// (only top-level) dynamic matchers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp:23,Availability,error,error,23,// Initialize to a non-error state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp:3,Usability,Simpl,Simply,3,// Simply gathers the contents of the various rules into a single rule. The; // actual work to combine these into an ordered choice is deferred to matcher; // registration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCode.cpp:51,Integrability,rout,routines,51,"//===--- SourceCode.cpp - Source code manipulation routines -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides functions that simplify extraction of source code.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCode.cpp:417,Usability,simpl,simplify,417,"//===--- SourceCode.cpp - Source code manipulation routines -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides functions that simplify extraction of source code.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCode.cpp:701,Safety,safe,safely,701,"// First, lex to the current token (which is the last token of the range that; // is definitely associated with the decl). Then, we process the first token; // separately from the rest based on conditions that hold specifically for; // that first token.; //; // We do not search for a terminator if none is required or we've already; // encountered it. Otherwise, if the original `EntityLast` location was in a; // macro expansion, we don't have visibility into the text, so we assume we've; // already terminated. However, we note this assumption with; // `TerminatedByMacro`, because we'll want to handle it somewhat differently; // for the terminators semicolon and comma. These terminators can be safely; // associated with the entity when they appear after the macro -- extra; // semicolons have no effect on the program and a well-formed program won't; // have multiple commas in a row, so we're guaranteed that there is only one.; //; // FIXME: This handling of macros is more conservative than necessary. When; // the end of the expansion coincides with the end of the node, we can still; // safely analyze the code. But, it is more complicated, because we need to; // start by lexing the spelling loc for the first token and then switch to the; // expansion loc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCode.cpp:1100,Safety,safe,safely,1100,"// First, lex to the current token (which is the last token of the range that; // is definitely associated with the decl). Then, we process the first token; // separately from the rest based on conditions that hold specifically for; // that first token.; //; // We do not search for a terminator if none is required or we've already; // encountered it. Otherwise, if the original `EntityLast` location was in a; // macro expansion, we don't have visibility into the text, so we assume we've; // already terminated. However, we note this assumption with; // `TerminatedByMacro`, because we'll want to handle it somewhat differently; // for the terminators semicolon and comma. These terminators can be safely; // associated with the entity when they appear after the macro -- extra; // semicolons have no effect on the program and a well-formed program won't; // have multiple commas in a row, so we're guaranteed that there is only one.; //; // FIXME: This handling of macros is more conservative than necessary. When; // the end of the expansion coincides with the end of the node, we can still; // safely analyze the code. But, it is more complicated, because we need to; // start by lexing the spelling loc for the first token and then switch to the; // expansion loc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCode.cpp:3,Modifiability,Extend,Extend,3,"// Extend to the left '[[' or '__attribute((' if we saw the attribute,; // unless it is not a valid location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCodeBuilders.cpp:26,Security,access,access,26,"// Append the appropriate access operation (syntactically) to `E`, assuming `E`; // is a non-pointer value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCodeBuilders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCodeBuilders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCodeBuilders.cpp:26,Security,access,access,26,"// Append the appropriate access operation (syntactically) to `E`, assuming `E`; // is a pointer value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCodeBuilders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCodeBuilders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCodeBuilders.cpp:78,Availability,failure,failure,78,"// Return the empty string, because `std::nullopt` signifies some sort of; // failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCodeBuilders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCodeBuilders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCodeBuilders.cpp:85,Security,access,access,85,"// Strip off operator-> calls. They can only occur inside an actual arrow; // member access, so we treat them as equivalent to an actual object; // expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCodeBuilders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCodeBuilders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp:83,Security,access,access,83,"// Strip off any operator->. This can only occur inside an actual arrow; // member access, so we treat it as equivalent to an actual object; // expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp:83,Security,access,access,83,"// Strip off any operator->. This can only occur inside an actual arrow; // member access, so we treat it as equivalent to an actual object; // expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp:62,Availability,error,error,62,"// Validate the original range to attempt to get a meaningful error; // message. If it's valid, then something else is the cause and we just; // return the generic failure message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp:164,Availability,failure,failure,164,"// Validate the original range to attempt to get a meaningful error; // message. If it's valid, then something else is the cause and we just; // return the generic failure message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp:72,Integrability,message,message,72,"// Validate the original range to attempt to get a meaningful error; // message. If it's valid, then something else is the cause and we just; // return the generic failure message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp:172,Integrability,message,message,172,"// Validate the original range to attempt to get a meaningful error; // message. If it's valid, then something else is the cause and we just; // return the generic failure message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp:3,Security,Validat,Validate,3,"// Validate the original range to attempt to get a meaningful error; // message. If it's valid, then something else is the cause and we just; // return the generic failure message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp:3,Security,Validat,Validate,3,"// Validate `Range`, because `makeFileCharRange` accepts some ranges that; // `validateRange` rejects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp:79,Security,validat,validateRange,79,"// Validate `Range`, because `makeFileCharRange` accepts some ranges that; // `validateRange` rejects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp:41,Security,access,access,41,"// A stencil operation to build a member access `e.m` or `e->m`, as appropriate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp:31,Integrability,wrap,wrap,31,"// Only one argument, so don't wrap in sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArch.cpp:36,Deployability,install,installed,36,"//===- AMDGPUArch.cpp - list AMDGPU installed ----------*- C++ -*---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a tool for detecting name of AMDGPU installed in system.; // This tool is used by AMDGPU OpenMP and HIP driver.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArch.cpp:439,Deployability,install,installed,439,"//===- AMDGPUArch.cpp - list AMDGPU installed ----------*- C++ -*---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a tool for detecting name of AMDGPU installed in system.; // This tool is used by AMDGPU OpenMP and HIP driver.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArch.cpp:414,Safety,detect,detecting,414,"//===- AMDGPUArch.cpp - list AMDGPU installed ----------*- C++ -*---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a tool for detecting name of AMDGPU installed in system.; // This tool is used by AMDGPU OpenMP and HIP driver.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArchByHIP.cpp:36,Deployability,install,installed,36,"//===- AMDGPUArch.cpp - list AMDGPU installed ----------*- C++ -*---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a tool for detecting name of AMDGPU installed in system; // using HIP runtime. This tool is used by AMDGPU OpenMP and HIP driver.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArchByHIP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArchByHIP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArchByHIP.cpp:439,Deployability,install,installed,439,"//===- AMDGPUArch.cpp - list AMDGPU installed ----------*- C++ -*---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a tool for detecting name of AMDGPU installed in system; // using HIP runtime. This tool is used by AMDGPU OpenMP and HIP driver.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArchByHIP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArchByHIP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArchByHIP.cpp:414,Safety,detect,detecting,414,"//===- AMDGPUArch.cpp - list AMDGPU installed ----------*- C++ -*---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a tool for detecting name of AMDGPU installed in system; // using HIP runtime. This tool is used by AMDGPU OpenMP and HIP driver.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArchByHIP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArchByHIP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArchByHSA.cpp:41,Deployability,install,installed,41,"//===- AMDGPUArchLinux.cpp - list AMDGPU installed ------*- C++ -*---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a tool for detecting name of AMDGPU installed in system; // using HSA on Linux. This tool is used by AMDGPU OpenMP and HIP driver.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArchByHSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArchByHSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArchByHSA.cpp:440,Deployability,install,installed,440,"//===- AMDGPUArchLinux.cpp - list AMDGPU installed ------*- C++ -*---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a tool for detecting name of AMDGPU installed in system; // using HSA on Linux. This tool is used by AMDGPU OpenMP and HIP driver.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArchByHSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArchByHSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArchByHSA.cpp:415,Safety,detect,detecting,415,"//===- AMDGPUArchLinux.cpp - list AMDGPU installed ------*- C++ -*---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a tool for detecting name of AMDGPU installed in system; // using HSA on Linux. This tool is used by AMDGPU OpenMP and HIP driver.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArchByHSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArchByHSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArchByHSA.cpp:14,Performance,load,load,14,// Attempt to load the HSA runtime.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArchByHSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArchByHSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/apinotes-test/APINotesTest.cpp:37,Testability,Test,Testing,37,"//===-- APINotesTest.cpp - API Notes Testing Tool ------------------ C++ --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/apinotes-test/APINotesTest.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/apinotes-test/APINotesTest.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/arcmt-test/arcmt-test.cpp:14,Testability,test,test,14,"//===-- arcmt-test.cpp - ARC Migration Tool testbed -----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/arcmt-test/arcmt-test.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/arcmt-test/arcmt-test.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/arcmt-test/arcmt-test.cpp:44,Testability,test,testbed,44,"//===-- arcmt-test.cpp - ARC Migration Tool testbed -----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/arcmt-test/arcmt-test.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/arcmt-test/arcmt-test.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/arcmt-test/arcmt-test.cpp:32,Testability,Test,TestResultForARC,32,"//static llvm::cl::opt<bool>; //TestResultForARC(""test-result"",; //llvm::cl::desc(""Test the result of transformations by parsing it in ARC mode""));",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/arcmt-test/arcmt-test.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/arcmt-test/arcmt-test.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/arcmt-test/arcmt-test.cpp:50,Testability,test,test-result,50,"//static llvm::cl::opt<bool>; //TestResultForARC(""test-result"",; //llvm::cl::desc(""Test the result of transformations by parsing it in ARC mode""));",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/arcmt-test/arcmt-test.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/arcmt-test/arcmt-test.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/arcmt-test/arcmt-test.cpp:83,Testability,Test,Test,83,"//static llvm::cl::opt<bool>; //TestResultForARC(""test-result"",; //llvm::cl::desc(""Test the result of transformations by parsing it in ARC mode""));",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/arcmt-test/arcmt-test.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/arcmt-test/arcmt-test.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/arcmt-test/arcmt-test.cpp:10,Testability,Test,TestResultForARC,10,// FIXME: TestResultForARC,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/arcmt-test/arcmt-test.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/arcmt-test/arcmt-test.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/core_main.cpp:40,Testability,test,testbed,40,"//===-- core_main.cpp - Core Index Tool testbed ---------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/c-index-test/core_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/core_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/core_main.cpp:15,Integrability,depend,dependencies,15,// skip module dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/c-index-test/core_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/core_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/core_main.cpp:40,Integrability,wrap,wrapped,40,// Register the support for object-file-wrapped Clang modules.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/c-index-test/core_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/core_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-check/ClangCheck.cpp:44,Modifiability,Rewrite,Rewrite,44,// FIXME: Move FixItRewriteInPlace from lib/Rewrite/Frontend/FrontendActions.cpp; // into a header file and reuse that.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-check/ClangCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-check/ClangCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-check/ClangCheck.cpp:86,Availability,error,errors,86,// We don't need to do permission checking here since clang will diagnose; // any I/O errors itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-check/ClangCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-check/ClangCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-check/ClangCheck.cpp:58,Availability,error,errors,58,/// Subclasses \c clang::FixItRewriter to not count fixed errors/warnings; /// in the final error counts.; ///; /// This has the side-effect that clang-check -fixit exits with code 0 on; /// successfully fixing all errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-check/ClangCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-check/ClangCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-check/ClangCheck.cpp:92,Availability,error,error,92,/// Subclasses \c clang::FixItRewriter to not count fixed errors/warnings; /// in the final error counts.; ///; /// This has the side-effect that clang-check -fixit exits with code 0 on; /// successfully fixing all errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-check/ClangCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-check/ClangCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-check/ClangCheck.cpp:215,Availability,error,errors,215,/// Subclasses \c clang::FixItRewriter to not count fixed errors/warnings; /// in the final error counts.; ///; /// This has the side-effect that clang-check -fixit exits with code 0 on; /// successfully fixing all errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-check/ClangCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-check/ClangCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-check/ClangCheck.cpp:52,Deployability,install,install,52,/// Subclasses \c clang::FixItAction so that we can install the custom; /// \c FixItRewriter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-check/ClangCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-check/ClangCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-check/ClangCheck.cpp:136,Deployability,install,installed,136,"// Running the analyzer requires --analyze. Other modes can work with the; // -fsyntax-only option.; //; // The syntax-only adjuster is installed by default.; // Good: It also strips options that trigger extra output, like -save-temps.; // Bad: We don't want the -fsyntax-only when executing the static analyzer.; //; // To enable the static analyzer, we first strip all -fsyntax-only options; // and then add an --analyze option to the front.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-check/ClangCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-check/ClangCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp:1839,Availability,down,down,1839,"; }; function highlight(event) {; var id = event.target['id']; doHighlight(id); }; function doHighlight(id) {; clearHighlight(); source = document.getElementById(id); if (!source.attributes['tid']); return; var mapped = source; while (mapped && mapped.parentElement && mapped.attributes['tid'].value.substr(1) === '-1'); mapped = mapped.parentElement; var tid = null, target = null; if (mapped) {; tid = mapped.attributes['tid'].value; target = document.getElementById(tid); }; if (source.parentElement && source.parentElement.classList.contains('code')); return; source.style.backgroundColor = 'lightgrey'; source.scrollIntoView(); if (target) {; if (mapped === source); target.style.backgroundColor = 'lightgrey'; target.scrollIntoView(); }; highlightStack.push([id, tid]); location.hash = '#' + id; }; function scrollToBoth() {; doHighlight(location.hash.substr(1)); }; function changed(elem) {; return elem.classList.length == 0; }; function nextChangedNode(prefix, increment, number) {; do {; number += increment; var elem = document.getElementById(prefix + number); } while(elem && !changed(elem)); return elem ? number : null; }; function handleKey(e) {; var down = e.code === ""KeyJ""; var up = e.code === ""KeyK""; if (!down && !up); return; var id = highlightStack[0] ? highlightStack[0][0] : 'R0'; var oldelem = document.getElementById(id); var number = parseInt(id.substr(1)); var increment = down ? 1 : -1; var lastnumber = number; var prefix = id[0]; do {; number = nextChangedNode(prefix, increment, number); var elem = document.getElementById(prefix + number); if (up && elem) {; while (elem.parentElement && changed(elem.parentElement)); elem = elem.parentElement; number = elem.id.substr(1); }; } while ((down && id !== 'R0' && oldelem.contains(elem))); if (!number); number = lastnumber; elem = document.getElementById(prefix + number); doHighlight(prefix + number); }; window.onload = scrollToBoth; window.onkeydown = handleKey; </script>; <body>; <div onclick='highlight(event)'>; )""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp:1898,Availability,down,down,1898,"; }; function highlight(event) {; var id = event.target['id']; doHighlight(id); }; function doHighlight(id) {; clearHighlight(); source = document.getElementById(id); if (!source.attributes['tid']); return; var mapped = source; while (mapped && mapped.parentElement && mapped.attributes['tid'].value.substr(1) === '-1'); mapped = mapped.parentElement; var tid = null, target = null; if (mapped) {; tid = mapped.attributes['tid'].value; target = document.getElementById(tid); }; if (source.parentElement && source.parentElement.classList.contains('code')); return; source.style.backgroundColor = 'lightgrey'; source.scrollIntoView(); if (target) {; if (mapped === source); target.style.backgroundColor = 'lightgrey'; target.scrollIntoView(); }; highlightStack.push([id, tid]); location.hash = '#' + id; }; function scrollToBoth() {; doHighlight(location.hash.substr(1)); }; function changed(elem) {; return elem.classList.length == 0; }; function nextChangedNode(prefix, increment, number) {; do {; number += increment; var elem = document.getElementById(prefix + number); } while(elem && !changed(elem)); return elem ? number : null; }; function handleKey(e) {; var down = e.code === ""KeyJ""; var up = e.code === ""KeyK""; if (!down && !up); return; var id = highlightStack[0] ? highlightStack[0][0] : 'R0'; var oldelem = document.getElementById(id); var number = parseInt(id.substr(1)); var increment = down ? 1 : -1; var lastnumber = number; var prefix = id[0]; do {; number = nextChangedNode(prefix, increment, number); var elem = document.getElementById(prefix + number); if (up && elem) {; while (elem.parentElement && changed(elem.parentElement)); elem = elem.parentElement; number = elem.id.substr(1); }; } while ((down && id !== 'R0' && oldelem.contains(elem))); if (!number); number = lastnumber; elem = document.getElementById(prefix + number); doHighlight(prefix + number); }; window.onload = scrollToBoth; window.onkeydown = handleKey; </script>; <body>; <div onclick='highlight(event)'>; )""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp:2074,Availability,down,down,2074,"; }; function highlight(event) {; var id = event.target['id']; doHighlight(id); }; function doHighlight(id) {; clearHighlight(); source = document.getElementById(id); if (!source.attributes['tid']); return; var mapped = source; while (mapped && mapped.parentElement && mapped.attributes['tid'].value.substr(1) === '-1'); mapped = mapped.parentElement; var tid = null, target = null; if (mapped) {; tid = mapped.attributes['tid'].value; target = document.getElementById(tid); }; if (source.parentElement && source.parentElement.classList.contains('code')); return; source.style.backgroundColor = 'lightgrey'; source.scrollIntoView(); if (target) {; if (mapped === source); target.style.backgroundColor = 'lightgrey'; target.scrollIntoView(); }; highlightStack.push([id, tid]); location.hash = '#' + id; }; function scrollToBoth() {; doHighlight(location.hash.substr(1)); }; function changed(elem) {; return elem.classList.length == 0; }; function nextChangedNode(prefix, increment, number) {; do {; number += increment; var elem = document.getElementById(prefix + number); } while(elem && !changed(elem)); return elem ? number : null; }; function handleKey(e) {; var down = e.code === ""KeyJ""; var up = e.code === ""KeyK""; if (!down && !up); return; var id = highlightStack[0] ? highlightStack[0][0] : 'R0'; var oldelem = document.getElementById(id); var number = parseInt(id.substr(1)); var increment = down ? 1 : -1; var lastnumber = number; var prefix = id[0]; do {; number = nextChangedNode(prefix, increment, number); var elem = document.getElementById(prefix + number); if (up && elem) {; while (elem.parentElement && changed(elem.parentElement)); elem = elem.parentElement; number = elem.id.substr(1); }; } while ((down && id !== 'R0' && oldelem.contains(elem))); if (!number); number = lastnumber; elem = document.getElementById(prefix + number); doHighlight(prefix + number); }; window.onload = scrollToBoth; window.onkeydown = handleKey; </script>; <body>; <div onclick='highlight(event)'>; )""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp:2392,Availability,down,down,2392,"; }; function highlight(event) {; var id = event.target['id']; doHighlight(id); }; function doHighlight(id) {; clearHighlight(); source = document.getElementById(id); if (!source.attributes['tid']); return; var mapped = source; while (mapped && mapped.parentElement && mapped.attributes['tid'].value.substr(1) === '-1'); mapped = mapped.parentElement; var tid = null, target = null; if (mapped) {; tid = mapped.attributes['tid'].value; target = document.getElementById(tid); }; if (source.parentElement && source.parentElement.classList.contains('code')); return; source.style.backgroundColor = 'lightgrey'; source.scrollIntoView(); if (target) {; if (mapped === source); target.style.backgroundColor = 'lightgrey'; target.scrollIntoView(); }; highlightStack.push([id, tid]); location.hash = '#' + id; }; function scrollToBoth() {; doHighlight(location.hash.substr(1)); }; function changed(elem) {; return elem.classList.length == 0; }; function nextChangedNode(prefix, increment, number) {; do {; number += increment; var elem = document.getElementById(prefix + number); } while(elem && !changed(elem)); return elem ? number : null; }; function handleKey(e) {; var down = e.code === ""KeyJ""; var up = e.code === ""KeyK""; if (!down && !up); return; var id = highlightStack[0] ? highlightStack[0][0] : 'R0'; var oldelem = document.getElementById(id); var number = parseInt(id.substr(1)); var increment = down ? 1 : -1; var lastnumber = number; var prefix = id[0]; do {; number = nextChangedNode(prefix, increment, number); var elem = document.getElementById(prefix + number); if (up && elem) {; while (elem.parentElement && changed(elem.parentElement)); elem = elem.parentElement; number = elem.id.substr(1); }; } while ((down && id !== 'R0' && oldelem.contains(elem))); if (!number); number = lastnumber; elem = document.getElementById(prefix + number); doHighlight(prefix + number); }; window.onload = scrollToBoth; window.onkeydown = handleKey; </script>; <body>; <div onclick='highlight(event)'>; )""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp:123,Energy Efficiency,green,green,123,"R""(; <html>; <head>; <meta charset='utf-8'/>; <style>; span.d { color: red; }; span.u { color: #cc00cc; }; span.i { color: green; }; span.m { font-weight: bold; }; span { font-weight: normal; color: black; }; div.code {; width: 48%;; height: 98%;; overflow: scroll;; float: left;; padding: 0 0 0.5% 0.5%;; border: solid 2px LightGrey;; border-radius: 5px;; }; </style>; </head>; <script type='text/javascript'>; highlightStack = []; function clearHighlight() {; while (highlightStack.length) {; var [l, r] = highlightStack.pop(); document.getElementById(l).style.backgroundColor = 'inherit'; if (r[1] != '-'); document.getElementById(r).style.backgroundColor = 'inherit'; }; }; function highlight(event) {; var id = event.target['id']; doHighlight(id); }; function doHighlight(id) {; clearHighlight(); source = document.getElementById(id); if (!source.attributes['tid']); return; var mapped = source; while (mapped && mapped.parentElement && mapped.attributes['tid'].value.substr(1) === '-1'); mapped = mapped.parentElement; var tid = null, target = null; if (mapped) {; tid = mapped.attributes['tid'].value; target = document.getElementById(tid); }; if (source.parentElement && source.parentElement.classList.contains('code')); return; source.style.backgroundColor = 'lightgrey'; source.scrollIntoView(); if (target) {; if (mapped === source); target.style.backgroundColor = 'lightgrey'; target.scrollIntoView(); }; highlightStack.push([id, tid]); location.hash = '#' + id; }; function scrollToBoth() {; doHighlight(location.hash.substr(1)); }; function changed(elem) {; return elem.classList.length == 0; }; function nextChangedNode(prefix, increment, number) {; do {; number += increment; var elem = document.getElementById(prefix + number); } while(elem && !changed(elem)); return elem ? number : null; }; function handleKey(e) {; var down = e.code === ""KeyJ""; var up = e.code === ""KeyK""; if (!down && !up); return; var id = highlightStack[0] ? highlightStack[0][0] : 'R0'; var oldelem = document.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp:582,Modifiability,inherit,inherit,582,"R""(; <html>; <head>; <meta charset='utf-8'/>; <style>; span.d { color: red; }; span.u { color: #cc00cc; }; span.i { color: green; }; span.m { font-weight: bold; }; span { font-weight: normal; color: black; }; div.code {; width: 48%;; height: 98%;; overflow: scroll;; float: left;; padding: 0 0 0.5% 0.5%;; border: solid 2px LightGrey;; border-radius: 5px;; }; </style>; </head>; <script type='text/javascript'>; highlightStack = []; function clearHighlight() {; while (highlightStack.length) {; var [l, r] = highlightStack.pop(); document.getElementById(l).style.backgroundColor = 'inherit'; if (r[1] != '-'); document.getElementById(r).style.backgroundColor = 'inherit'; }; }; function highlight(event) {; var id = event.target['id']; doHighlight(id); }; function doHighlight(id) {; clearHighlight(); source = document.getElementById(id); if (!source.attributes['tid']); return; var mapped = source; while (mapped && mapped.parentElement && mapped.attributes['tid'].value.substr(1) === '-1'); mapped = mapped.parentElement; var tid = null, target = null; if (mapped) {; tid = mapped.attributes['tid'].value; target = document.getElementById(tid); }; if (source.parentElement && source.parentElement.classList.contains('code')); return; source.style.backgroundColor = 'lightgrey'; source.scrollIntoView(); if (target) {; if (mapped === source); target.style.backgroundColor = 'lightgrey'; target.scrollIntoView(); }; highlightStack.push([id, tid]); location.hash = '#' + id; }; function scrollToBoth() {; doHighlight(location.hash.substr(1)); }; function changed(elem) {; return elem.classList.length == 0; }; function nextChangedNode(prefix, increment, number) {; do {; number += increment; var elem = document.getElementById(prefix + number); } while(elem && !changed(elem)); return elem ? number : null; }; function handleKey(e) {; var down = e.code === ""KeyJ""; var up = e.code === ""KeyK""; if (!down && !up); return; var id = highlightStack[0] ? highlightStack[0][0] : 'R0'; var oldelem = document.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp:662,Modifiability,inherit,inherit,662,"R""(; <html>; <head>; <meta charset='utf-8'/>; <style>; span.d { color: red; }; span.u { color: #cc00cc; }; span.i { color: green; }; span.m { font-weight: bold; }; span { font-weight: normal; color: black; }; div.code {; width: 48%;; height: 98%;; overflow: scroll;; float: left;; padding: 0 0 0.5% 0.5%;; border: solid 2px LightGrey;; border-radius: 5px;; }; </style>; </head>; <script type='text/javascript'>; highlightStack = []; function clearHighlight() {; while (highlightStack.length) {; var [l, r] = highlightStack.pop(); document.getElementById(l).style.backgroundColor = 'inherit'; if (r[1] != '-'); document.getElementById(r).style.backgroundColor = 'inherit'; }; }; function highlight(event) {; var id = event.target['id']; doHighlight(id); }; function doHighlight(id) {; clearHighlight(); source = document.getElementById(id); if (!source.attributes['tid']); return; var mapped = source; while (mapped && mapped.parentElement && mapped.attributes['tid'].value.substr(1) === '-1'); mapped = mapped.parentElement; var tid = null, target = null; if (mapped) {; tid = mapped.attributes['tid'].value; target = document.getElementById(tid); }; if (source.parentElement && source.parentElement.classList.contains('code')); return; source.style.backgroundColor = 'lightgrey'; source.scrollIntoView(); if (target) {; if (mapped === source); target.style.backgroundColor = 'lightgrey'; target.scrollIntoView(); }; highlightStack.push([id, tid]); location.hash = '#' + id; }; function scrollToBoth() {; doHighlight(location.hash.substr(1)); }; function changed(elem) {; return elem.classList.length == 0; }; function nextChangedNode(prefix, increment, number) {; do {; number += increment; var elem = document.getElementById(prefix + number); } while(elem && !changed(elem)); return elem ? number : null; }; function handleKey(e) {; var down = e.code === ""KeyJ""; var up = e.code === ""KeyK""; if (!down && !up); return; var id = highlightStack[0] ? highlightStack[0][0] : 'R0'; var oldelem = document.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp:1458,Security,hash,hash,1458,"{; var [l, r] = highlightStack.pop(); document.getElementById(l).style.backgroundColor = 'inherit'; if (r[1] != '-'); document.getElementById(r).style.backgroundColor = 'inherit'; }; }; function highlight(event) {; var id = event.target['id']; doHighlight(id); }; function doHighlight(id) {; clearHighlight(); source = document.getElementById(id); if (!source.attributes['tid']); return; var mapped = source; while (mapped && mapped.parentElement && mapped.attributes['tid'].value.substr(1) === '-1'); mapped = mapped.parentElement; var tid = null, target = null; if (mapped) {; tid = mapped.attributes['tid'].value; target = document.getElementById(tid); }; if (source.parentElement && source.parentElement.classList.contains('code')); return; source.style.backgroundColor = 'lightgrey'; source.scrollIntoView(); if (target) {; if (mapped === source); target.style.backgroundColor = 'lightgrey'; target.scrollIntoView(); }; highlightStack.push([id, tid]); location.hash = '#' + id; }; function scrollToBoth() {; doHighlight(location.hash.substr(1)); }; function changed(elem) {; return elem.classList.length == 0; }; function nextChangedNode(prefix, increment, number) {; do {; number += increment; var elem = document.getElementById(prefix + number); } while(elem && !changed(elem)); return elem ? number : null; }; function handleKey(e) {; var down = e.code === ""KeyJ""; var up = e.code === ""KeyK""; if (!down && !up); return; var id = highlightStack[0] ? highlightStack[0][0] : 'R0'; var oldelem = document.getElementById(id); var number = parseInt(id.substr(1)); var increment = down ? 1 : -1; var lastnumber = number; var prefix = id[0]; do {; number = nextChangedNode(prefix, increment, number); var elem = document.getElementById(prefix + number); if (up && elem) {; while (elem.parentElement && changed(elem.parentElement)); elem = elem.parentElement; number = elem.id.substr(1); }; } while ((down && id !== 'R0' && oldelem.contains(elem))); if (!number); number = lastnumber; elem = document.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp:1526,Security,hash,hash,1526,"; document.getElementById(l).style.backgroundColor = 'inherit'; if (r[1] != '-'); document.getElementById(r).style.backgroundColor = 'inherit'; }; }; function highlight(event) {; var id = event.target['id']; doHighlight(id); }; function doHighlight(id) {; clearHighlight(); source = document.getElementById(id); if (!source.attributes['tid']); return; var mapped = source; while (mapped && mapped.parentElement && mapped.attributes['tid'].value.substr(1) === '-1'); mapped = mapped.parentElement; var tid = null, target = null; if (mapped) {; tid = mapped.attributes['tid'].value; target = document.getElementById(tid); }; if (source.parentElement && source.parentElement.classList.contains('code')); return; source.style.backgroundColor = 'lightgrey'; source.scrollIntoView(); if (target) {; if (mapped === source); target.style.backgroundColor = 'lightgrey'; target.scrollIntoView(); }; highlightStack.push([id, tid]); location.hash = '#' + id; }; function scrollToBoth() {; doHighlight(location.hash.substr(1)); }; function changed(elem) {; return elem.classList.length == 0; }; function nextChangedNode(prefix, increment, number) {; do {; number += increment; var elem = document.getElementById(prefix + number); } while(elem && !changed(elem)); return elem ? number : null; }; function handleKey(e) {; var down = e.code === ""KeyJ""; var up = e.code === ""KeyK""; if (!down && !up); return; var id = highlightStack[0] ? highlightStack[0][0] : 'R0'; var oldelem = document.getElementById(id); var number = parseInt(id.substr(1)); var increment = down ? 1 : -1; var lastnumber = number; var prefix = id[0]; do {; number = nextChangedNode(prefix, increment, number); var elem = document.getElementById(prefix + number); if (up && elem) {; while (elem.parentElement && changed(elem.parentElement)); elem = elem.parentElement; number = elem.id.substr(1); }; } while ((down && id !== 'R0' && oldelem.contains(elem))); if (!number); number = lastnumber; elem = document.getElementById(prefix + number); doHi",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp:442,Usability,clear,clearHighlight,442,"R""(; <html>; <head>; <meta charset='utf-8'/>; <style>; span.d { color: red; }; span.u { color: #cc00cc; }; span.i { color: green; }; span.m { font-weight: bold; }; span { font-weight: normal; color: black; }; div.code {; width: 48%;; height: 98%;; overflow: scroll;; float: left;; padding: 0 0 0.5% 0.5%;; border: solid 2px LightGrey;; border-radius: 5px;; }; </style>; </head>; <script type='text/javascript'>; highlightStack = []; function clearHighlight() {; while (highlightStack.length) {; var [l, r] = highlightStack.pop(); document.getElementById(l).style.backgroundColor = 'inherit'; if (r[1] != '-'); document.getElementById(r).style.backgroundColor = 'inherit'; }; }; function highlight(event) {; var id = event.target['id']; doHighlight(id); }; function doHighlight(id) {; clearHighlight(); source = document.getElementById(id); if (!source.attributes['tid']); return; var mapped = source; while (mapped && mapped.parentElement && mapped.attributes['tid'].value.substr(1) === '-1'); mapped = mapped.parentElement; var tid = null, target = null; if (mapped) {; tid = mapped.attributes['tid'].value; target = document.getElementById(tid); }; if (source.parentElement && source.parentElement.classList.contains('code')); return; source.style.backgroundColor = 'lightgrey'; source.scrollIntoView(); if (target) {; if (mapped === source); target.style.backgroundColor = 'lightgrey'; target.scrollIntoView(); }; highlightStack.push([id, tid]); location.hash = '#' + id; }; function scrollToBoth() {; doHighlight(location.hash.substr(1)); }; function changed(elem) {; return elem.classList.length == 0; }; function nextChangedNode(prefix, increment, number) {; do {; number += increment; var elem = document.getElementById(prefix + number); } while(elem && !changed(elem)); return elem ? number : null; }; function handleKey(e) {; var down = e.code === ""KeyJ""; var up = e.code === ""KeyK""; if (!down && !up); return; var id = highlightStack[0] ? highlightStack[0][0] : 'R0'; var oldelem = document.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp:784,Usability,clear,clearHighlight,784,"R""(; <html>; <head>; <meta charset='utf-8'/>; <style>; span.d { color: red; }; span.u { color: #cc00cc; }; span.i { color: green; }; span.m { font-weight: bold; }; span { font-weight: normal; color: black; }; div.code {; width: 48%;; height: 98%;; overflow: scroll;; float: left;; padding: 0 0 0.5% 0.5%;; border: solid 2px LightGrey;; border-radius: 5px;; }; </style>; </head>; <script type='text/javascript'>; highlightStack = []; function clearHighlight() {; while (highlightStack.length) {; var [l, r] = highlightStack.pop(); document.getElementById(l).style.backgroundColor = 'inherit'; if (r[1] != '-'); document.getElementById(r).style.backgroundColor = 'inherit'; }; }; function highlight(event) {; var id = event.target['id']; doHighlight(id); }; function doHighlight(id) {; clearHighlight(); source = document.getElementById(id); if (!source.attributes['tid']); return; var mapped = source; while (mapped && mapped.parentElement && mapped.attributes['tid'].value.substr(1) === '-1'); mapped = mapped.parentElement; var tid = null, target = null; if (mapped) {; tid = mapped.attributes['tid'].value; target = document.getElementById(tid); }; if (source.parentElement && source.parentElement.classList.contains('code')); return; source.style.backgroundColor = 'lightgrey'; source.scrollIntoView(); if (target) {; if (mapped === source); target.style.backgroundColor = 'lightgrey'; target.scrollIntoView(); }; highlightStack.push([id, tid]); location.hash = '#' + id; }; function scrollToBoth() {; doHighlight(location.hash.substr(1)); }; function changed(elem) {; return elem.classList.length == 0; }; function nextChangedNode(prefix, increment, number) {; do {; number += increment; var elem = document.getElementById(prefix + number); } while(elem && !changed(elem)); return elem ? number : null; }; function handleKey(e) {; var down = e.code === ""KeyJ""; var up = e.code === ""KeyK""; if (!down && !up); return; var id = highlightStack[0] ? highlightStack[0][0] : 'R0'; var oldelem = document.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-extdef-mapping/ClangExtDefMapGen.cpp:40,Availability,error,errors,40,// Call reset to make sure we don't mix errors,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-extdef-mapping/ClangExtDefMapGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-extdef-mapping/ClangExtDefMapGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-extdef-mapping/ClangExtDefMapGen.cpp:58,Performance,Load,LoadFromASTFile,58,// Retain this one time so it's not destroyed by ASTUnit::LoadFromASTFile,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-extdef-mapping/ClangExtDefMapGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-extdef-mapping/ClangExtDefMapGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format-diff.py:150,Deployability,patch,patch,150,"""""""; This script reads input from a unified diff and reformats all the changed; lines. This is useful to reformat all the lines touched by a specific patch.; Example usage for git/svn users:. git diff -U0 --no-color --relative HEAD^ | {clang_format_diff} -p1 -i; svn diff --diff-cmd=diff -x-U0 | {clang_format_diff} -i. It should be noted that the filename contained in the diff is used unmodified; to determine the source file to update. Users calling this script directly; should be careful to ensure that the path in the diff is correct relative to the; current working directory.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/clang-format-diff.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format-diff.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format-diff.py:431,Deployability,update,update,431,"""""""; This script reads input from a unified diff and reformats all the changed; lines. This is useful to reformat all the lines touched by a specific patch.; Example usage for git/svn users:. git diff -U0 --no-color --relative HEAD^ | {clang_format_diff} -p1 -i; svn diff --diff-cmd=diff -x-U0 | {clang_format_diff} -i. It should be noted that the filename contained in the diff is used unmodified; to determine the source file to update. Users calling this script directly; should be careful to ensure that the path in the diff is correct relative to the; current working directory.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/clang-format-diff.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format-diff.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format-sublime.py:46,Deployability,integrat,integration,46,"# This file is a minimal clang-format sublime-integration. To install:; # - Change 'binary' if clang-format is not on the path (see below).; # - Put this file into your sublime Packages directory, e.g. on Linux:; # ~/.config/sublime-text-2/Packages/User/clang-format-sublime.py; # - Add a key binding:; # { ""keys"": [""ctrl+shift+c""], ""command"": ""clang_format"" },; #; # With this integration you can press the bound key and clang-format will; # format the current lines and selections for all cursor positions. The lines; # or regions are extended to the next bigger syntactic entities.; #; # It operates on the current, potentially unsaved buffer and does not create; # or save any files. To revert a formatting, just undo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/clang-format-sublime.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format-sublime.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format-sublime.py:62,Deployability,install,install,62,"# This file is a minimal clang-format sublime-integration. To install:; # - Change 'binary' if clang-format is not on the path (see below).; # - Put this file into your sublime Packages directory, e.g. on Linux:; # ~/.config/sublime-text-2/Packages/User/clang-format-sublime.py; # - Add a key binding:; # { ""keys"": [""ctrl+shift+c""], ""command"": ""clang_format"" },; #; # With this integration you can press the bound key and clang-format will; # format the current lines and selections for all cursor positions. The lines; # or regions are extended to the next bigger syntactic entities.; #; # It operates on the current, potentially unsaved buffer and does not create; # or save any files. To revert a formatting, just undo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/clang-format-sublime.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format-sublime.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format-sublime.py:378,Deployability,integrat,integration,378,"# This file is a minimal clang-format sublime-integration. To install:; # - Change 'binary' if clang-format is not on the path (see below).; # - Put this file into your sublime Packages directory, e.g. on Linux:; # ~/.config/sublime-text-2/Packages/User/clang-format-sublime.py; # - Add a key binding:; # { ""keys"": [""ctrl+shift+c""], ""command"": ""clang_format"" },; #; # With this integration you can press the bound key and clang-format will; # format the current lines and selections for all cursor positions. The lines; # or regions are extended to the next bigger syntactic entities.; #; # It operates on the current, potentially unsaved buffer and does not create; # or save any files. To revert a formatting, just undo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/clang-format-sublime.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format-sublime.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format-sublime.py:46,Integrability,integrat,integration,46,"# This file is a minimal clang-format sublime-integration. To install:; # - Change 'binary' if clang-format is not on the path (see below).; # - Put this file into your sublime Packages directory, e.g. on Linux:; # ~/.config/sublime-text-2/Packages/User/clang-format-sublime.py; # - Add a key binding:; # { ""keys"": [""ctrl+shift+c""], ""command"": ""clang_format"" },; #; # With this integration you can press the bound key and clang-format will; # format the current lines and selections for all cursor positions. The lines; # or regions are extended to the next bigger syntactic entities.; #; # It operates on the current, potentially unsaved buffer and does not create; # or save any files. To revert a formatting, just undo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/clang-format-sublime.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format-sublime.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format-sublime.py:378,Integrability,integrat,integration,378,"# This file is a minimal clang-format sublime-integration. To install:; # - Change 'binary' if clang-format is not on the path (see below).; # - Put this file into your sublime Packages directory, e.g. on Linux:; # ~/.config/sublime-text-2/Packages/User/clang-format-sublime.py; # - Add a key binding:; # { ""keys"": [""ctrl+shift+c""], ""command"": ""clang_format"" },; #; # With this integration you can press the bound key and clang-format will; # format the current lines and selections for all cursor positions. The lines; # or regions are extended to the next bigger syntactic entities.; #; # It operates on the current, potentially unsaved buffer and does not create; # or save any files. To revert a formatting, just undo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/clang-format-sublime.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format-sublime.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format-sublime.py:218,Modifiability,config,config,218,"# This file is a minimal clang-format sublime-integration. To install:; # - Change 'binary' if clang-format is not on the path (see below).; # - Put this file into your sublime Packages directory, e.g. on Linux:; # ~/.config/sublime-text-2/Packages/User/clang-format-sublime.py; # - Add a key binding:; # { ""keys"": [""ctrl+shift+c""], ""command"": ""clang_format"" },; #; # With this integration you can press the bound key and clang-format will; # format the current lines and selections for all cursor positions. The lines; # or regions are extended to the next bigger syntactic entities.; #; # It operates on the current, potentially unsaved buffer and does not create; # or save any files. To revert a formatting, just undo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/clang-format-sublime.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format-sublime.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format-sublime.py:537,Modifiability,extend,extended,537,"# This file is a minimal clang-format sublime-integration. To install:; # - Change 'binary' if clang-format is not on the path (see below).; # - Put this file into your sublime Packages directory, e.g. on Linux:; # ~/.config/sublime-text-2/Packages/User/clang-format-sublime.py; # - Add a key binding:; # { ""keys"": [""ctrl+shift+c""], ""command"": ""clang_format"" },; #; # With this integration you can press the bound key and clang-format will; # format the current lines and selections for all cursor positions. The lines; # or regions are extended to the next bigger syntactic entities.; #; # It operates on the current, potentially unsaved buffer and does not create; # or save any files. To revert a formatting, just undo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/clang-format-sublime.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format-sublime.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format-sublime.py:717,Usability,undo,undo,717,"# This file is a minimal clang-format sublime-integration. To install:; # - Change 'binary' if clang-format is not on the path (see below).; # - Put this file into your sublime Packages directory, e.g. on Linux:; # ~/.config/sublime-text-2/Packages/User/clang-format-sublime.py; # - Add a key binding:; # { ""keys"": [""ctrl+shift+c""], ""command"": ""clang_format"" },; #; # With this integration you can press the bound key and clang-format will; # format the current lines and selections for all cursor positions. The lines; # or regions are extended to the next bigger syntactic entities.; #; # It operates on the current, potentially unsaved buffer and does not create; # or save any files. To revert a formatting, just undo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/clang-format-sublime.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format-sublime.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py:42,Deployability,integrat,integration,42,"# This file is a minimal clang-format vim-integration. To install:; # - Change 'binary' if clang-format is not on the path (see below).; # - Add to your .vimrc:; #; # if has('python'); # map <C-I> :pyf <path-to-this-file>/clang-format.py<cr>; # imap <C-I> <c-o>:pyf <path-to-this-file>/clang-format.py<cr>; # elseif has('python3'); # map <C-I> :py3f <path-to-this-file>/clang-format.py<cr>; # imap <C-I> <c-o>:py3f <path-to-this-file>/clang-format.py<cr>; # endif; #; # The if-elseif-endif conditional should pick either the python3 or python2; # integration depending on your vim setup.; #; # The first mapping enables clang-format for NORMAL and VISUAL mode, the second; # mapping adds support for INSERT mode. Change ""C-I"" to another binding if you; # need clang-format on a different key (C-I stands for Ctrl+i).; #; # With this integration you can press the bound key and clang-format will; # format the current line in NORMAL and INSERT mode or the selected region in; # VISUAL mode. The line or region is extended to the next bigger syntactic; # entity.; #; # You can also pass in the variable ""l:lines"" to choose the range for; # formatting. This variable can either contain ""<start line>:<end line>"" or; # ""all"" to format the full file. So, to format the full file, write a function; # like:; # :function FormatFile(); # : let l:lines=""all""; # : if has('python'); # : pyf <path-to-this-file>/clang-format.py; # : elseif has('python3'); # : py3f <path-to-this-file>/clang-format.py; # : endif; # :endfunction; #; # It operates on the current, potentially unsaved buffer and does not create; # or save any files. To revert a formatting, just undo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/clang-format.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py:58,Deployability,install,install,58,"# This file is a minimal clang-format vim-integration. To install:; # - Change 'binary' if clang-format is not on the path (see below).; # - Add to your .vimrc:; #; # if has('python'); # map <C-I> :pyf <path-to-this-file>/clang-format.py<cr>; # imap <C-I> <c-o>:pyf <path-to-this-file>/clang-format.py<cr>; # elseif has('python3'); # map <C-I> :py3f <path-to-this-file>/clang-format.py<cr>; # imap <C-I> <c-o>:py3f <path-to-this-file>/clang-format.py<cr>; # endif; #; # The if-elseif-endif conditional should pick either the python3 or python2; # integration depending on your vim setup.; #; # The first mapping enables clang-format for NORMAL and VISUAL mode, the second; # mapping adds support for INSERT mode. Change ""C-I"" to another binding if you; # need clang-format on a different key (C-I stands for Ctrl+i).; #; # With this integration you can press the bound key and clang-format will; # format the current line in NORMAL and INSERT mode or the selected region in; # VISUAL mode. The line or region is extended to the next bigger syntactic; # entity.; #; # You can also pass in the variable ""l:lines"" to choose the range for; # formatting. This variable can either contain ""<start line>:<end line>"" or; # ""all"" to format the full file. So, to format the full file, write a function; # like:; # :function FormatFile(); # : let l:lines=""all""; # : if has('python'); # : pyf <path-to-this-file>/clang-format.py; # : elseif has('python3'); # : py3f <path-to-this-file>/clang-format.py; # : endif; # :endfunction; #; # It operates on the current, potentially unsaved buffer and does not create; # or save any files. To revert a formatting, just undo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/clang-format.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py:547,Deployability,integrat,integration,547,"# This file is a minimal clang-format vim-integration. To install:; # - Change 'binary' if clang-format is not on the path (see below).; # - Add to your .vimrc:; #; # if has('python'); # map <C-I> :pyf <path-to-this-file>/clang-format.py<cr>; # imap <C-I> <c-o>:pyf <path-to-this-file>/clang-format.py<cr>; # elseif has('python3'); # map <C-I> :py3f <path-to-this-file>/clang-format.py<cr>; # imap <C-I> <c-o>:py3f <path-to-this-file>/clang-format.py<cr>; # endif; #; # The if-elseif-endif conditional should pick either the python3 or python2; # integration depending on your vim setup.; #; # The first mapping enables clang-format for NORMAL and VISUAL mode, the second; # mapping adds support for INSERT mode. Change ""C-I"" to another binding if you; # need clang-format on a different key (C-I stands for Ctrl+i).; #; # With this integration you can press the bound key and clang-format will; # format the current line in NORMAL and INSERT mode or the selected region in; # VISUAL mode. The line or region is extended to the next bigger syntactic; # entity.; #; # You can also pass in the variable ""l:lines"" to choose the range for; # formatting. This variable can either contain ""<start line>:<end line>"" or; # ""all"" to format the full file. So, to format the full file, write a function; # like:; # :function FormatFile(); # : let l:lines=""all""; # : if has('python'); # : pyf <path-to-this-file>/clang-format.py; # : elseif has('python3'); # : py3f <path-to-this-file>/clang-format.py; # : endif; # :endfunction; #; # It operates on the current, potentially unsaved buffer and does not create; # or save any files. To revert a formatting, just undo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/clang-format.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py:833,Deployability,integrat,integration,833,"# This file is a minimal clang-format vim-integration. To install:; # - Change 'binary' if clang-format is not on the path (see below).; # - Add to your .vimrc:; #; # if has('python'); # map <C-I> :pyf <path-to-this-file>/clang-format.py<cr>; # imap <C-I> <c-o>:pyf <path-to-this-file>/clang-format.py<cr>; # elseif has('python3'); # map <C-I> :py3f <path-to-this-file>/clang-format.py<cr>; # imap <C-I> <c-o>:py3f <path-to-this-file>/clang-format.py<cr>; # endif; #; # The if-elseif-endif conditional should pick either the python3 or python2; # integration depending on your vim setup.; #; # The first mapping enables clang-format for NORMAL and VISUAL mode, the second; # mapping adds support for INSERT mode. Change ""C-I"" to another binding if you; # need clang-format on a different key (C-I stands for Ctrl+i).; #; # With this integration you can press the bound key and clang-format will; # format the current line in NORMAL and INSERT mode or the selected region in; # VISUAL mode. The line or region is extended to the next bigger syntactic; # entity.; #; # You can also pass in the variable ""l:lines"" to choose the range for; # formatting. This variable can either contain ""<start line>:<end line>"" or; # ""all"" to format the full file. So, to format the full file, write a function; # like:; # :function FormatFile(); # : let l:lines=""all""; # : if has('python'); # : pyf <path-to-this-file>/clang-format.py; # : elseif has('python3'); # : py3f <path-to-this-file>/clang-format.py; # : endif; # :endfunction; #; # It operates on the current, potentially unsaved buffer and does not create; # or save any files. To revert a formatting, just undo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/clang-format.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py:42,Integrability,integrat,integration,42,"# This file is a minimal clang-format vim-integration. To install:; # - Change 'binary' if clang-format is not on the path (see below).; # - Add to your .vimrc:; #; # if has('python'); # map <C-I> :pyf <path-to-this-file>/clang-format.py<cr>; # imap <C-I> <c-o>:pyf <path-to-this-file>/clang-format.py<cr>; # elseif has('python3'); # map <C-I> :py3f <path-to-this-file>/clang-format.py<cr>; # imap <C-I> <c-o>:py3f <path-to-this-file>/clang-format.py<cr>; # endif; #; # The if-elseif-endif conditional should pick either the python3 or python2; # integration depending on your vim setup.; #; # The first mapping enables clang-format for NORMAL and VISUAL mode, the second; # mapping adds support for INSERT mode. Change ""C-I"" to another binding if you; # need clang-format on a different key (C-I stands for Ctrl+i).; #; # With this integration you can press the bound key and clang-format will; # format the current line in NORMAL and INSERT mode or the selected region in; # VISUAL mode. The line or region is extended to the next bigger syntactic; # entity.; #; # You can also pass in the variable ""l:lines"" to choose the range for; # formatting. This variable can either contain ""<start line>:<end line>"" or; # ""all"" to format the full file. So, to format the full file, write a function; # like:; # :function FormatFile(); # : let l:lines=""all""; # : if has('python'); # : pyf <path-to-this-file>/clang-format.py; # : elseif has('python3'); # : py3f <path-to-this-file>/clang-format.py; # : endif; # :endfunction; #; # It operates on the current, potentially unsaved buffer and does not create; # or save any files. To revert a formatting, just undo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/clang-format.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py:547,Integrability,integrat,integration,547,"# This file is a minimal clang-format vim-integration. To install:; # - Change 'binary' if clang-format is not on the path (see below).; # - Add to your .vimrc:; #; # if has('python'); # map <C-I> :pyf <path-to-this-file>/clang-format.py<cr>; # imap <C-I> <c-o>:pyf <path-to-this-file>/clang-format.py<cr>; # elseif has('python3'); # map <C-I> :py3f <path-to-this-file>/clang-format.py<cr>; # imap <C-I> <c-o>:py3f <path-to-this-file>/clang-format.py<cr>; # endif; #; # The if-elseif-endif conditional should pick either the python3 or python2; # integration depending on your vim setup.; #; # The first mapping enables clang-format for NORMAL and VISUAL mode, the second; # mapping adds support for INSERT mode. Change ""C-I"" to another binding if you; # need clang-format on a different key (C-I stands for Ctrl+i).; #; # With this integration you can press the bound key and clang-format will; # format the current line in NORMAL and INSERT mode or the selected region in; # VISUAL mode. The line or region is extended to the next bigger syntactic; # entity.; #; # You can also pass in the variable ""l:lines"" to choose the range for; # formatting. This variable can either contain ""<start line>:<end line>"" or; # ""all"" to format the full file. So, to format the full file, write a function; # like:; # :function FormatFile(); # : let l:lines=""all""; # : if has('python'); # : pyf <path-to-this-file>/clang-format.py; # : elseif has('python3'); # : py3f <path-to-this-file>/clang-format.py; # : endif; # :endfunction; #; # It operates on the current, potentially unsaved buffer and does not create; # or save any files. To revert a formatting, just undo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/clang-format.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py:559,Integrability,depend,depending,559,"# This file is a minimal clang-format vim-integration. To install:; # - Change 'binary' if clang-format is not on the path (see below).; # - Add to your .vimrc:; #; # if has('python'); # map <C-I> :pyf <path-to-this-file>/clang-format.py<cr>; # imap <C-I> <c-o>:pyf <path-to-this-file>/clang-format.py<cr>; # elseif has('python3'); # map <C-I> :py3f <path-to-this-file>/clang-format.py<cr>; # imap <C-I> <c-o>:py3f <path-to-this-file>/clang-format.py<cr>; # endif; #; # The if-elseif-endif conditional should pick either the python3 or python2; # integration depending on your vim setup.; #; # The first mapping enables clang-format for NORMAL and VISUAL mode, the second; # mapping adds support for INSERT mode. Change ""C-I"" to another binding if you; # need clang-format on a different key (C-I stands for Ctrl+i).; #; # With this integration you can press the bound key and clang-format will; # format the current line in NORMAL and INSERT mode or the selected region in; # VISUAL mode. The line or region is extended to the next bigger syntactic; # entity.; #; # You can also pass in the variable ""l:lines"" to choose the range for; # formatting. This variable can either contain ""<start line>:<end line>"" or; # ""all"" to format the full file. So, to format the full file, write a function; # like:; # :function FormatFile(); # : let l:lines=""all""; # : if has('python'); # : pyf <path-to-this-file>/clang-format.py; # : elseif has('python3'); # : py3f <path-to-this-file>/clang-format.py; # : endif; # :endfunction; #; # It operates on the current, potentially unsaved buffer and does not create; # or save any files. To revert a formatting, just undo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/clang-format.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py:833,Integrability,integrat,integration,833,"# This file is a minimal clang-format vim-integration. To install:; # - Change 'binary' if clang-format is not on the path (see below).; # - Add to your .vimrc:; #; # if has('python'); # map <C-I> :pyf <path-to-this-file>/clang-format.py<cr>; # imap <C-I> <c-o>:pyf <path-to-this-file>/clang-format.py<cr>; # elseif has('python3'); # map <C-I> :py3f <path-to-this-file>/clang-format.py<cr>; # imap <C-I> <c-o>:py3f <path-to-this-file>/clang-format.py<cr>; # endif; #; # The if-elseif-endif conditional should pick either the python3 or python2; # integration depending on your vim setup.; #; # The first mapping enables clang-format for NORMAL and VISUAL mode, the second; # mapping adds support for INSERT mode. Change ""C-I"" to another binding if you; # need clang-format on a different key (C-I stands for Ctrl+i).; #; # With this integration you can press the bound key and clang-format will; # format the current line in NORMAL and INSERT mode or the selected region in; # VISUAL mode. The line or region is extended to the next bigger syntactic; # entity.; #; # You can also pass in the variable ""l:lines"" to choose the range for; # formatting. This variable can either contain ""<start line>:<end line>"" or; # ""all"" to format the full file. So, to format the full file, write a function; # like:; # :function FormatFile(); # : let l:lines=""all""; # : if has('python'); # : pyf <path-to-this-file>/clang-format.py; # : elseif has('python3'); # : py3f <path-to-this-file>/clang-format.py; # : endif; # :endfunction; #; # It operates on the current, potentially unsaved buffer and does not create; # or save any files. To revert a formatting, just undo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/clang-format.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py:1012,Modifiability,extend,extended,1012,"# This file is a minimal clang-format vim-integration. To install:; # - Change 'binary' if clang-format is not on the path (see below).; # - Add to your .vimrc:; #; # if has('python'); # map <C-I> :pyf <path-to-this-file>/clang-format.py<cr>; # imap <C-I> <c-o>:pyf <path-to-this-file>/clang-format.py<cr>; # elseif has('python3'); # map <C-I> :py3f <path-to-this-file>/clang-format.py<cr>; # imap <C-I> <c-o>:py3f <path-to-this-file>/clang-format.py<cr>; # endif; #; # The if-elseif-endif conditional should pick either the python3 or python2; # integration depending on your vim setup.; #; # The first mapping enables clang-format for NORMAL and VISUAL mode, the second; # mapping adds support for INSERT mode. Change ""C-I"" to another binding if you; # need clang-format on a different key (C-I stands for Ctrl+i).; #; # With this integration you can press the bound key and clang-format will; # format the current line in NORMAL and INSERT mode or the selected region in; # VISUAL mode. The line or region is extended to the next bigger syntactic; # entity.; #; # You can also pass in the variable ""l:lines"" to choose the range for; # formatting. This variable can either contain ""<start line>:<end line>"" or; # ""all"" to format the full file. So, to format the full file, write a function; # like:; # :function FormatFile(); # : let l:lines=""all""; # : if has('python'); # : pyf <path-to-this-file>/clang-format.py; # : elseif has('python3'); # : py3f <path-to-this-file>/clang-format.py; # : endif; # :endfunction; #; # It operates on the current, potentially unsaved buffer and does not create; # or save any files. To revert a formatting, just undo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/clang-format.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py:1092,Modifiability,variab,variable,1092,"# This file is a minimal clang-format vim-integration. To install:; # - Change 'binary' if clang-format is not on the path (see below).; # - Add to your .vimrc:; #; # if has('python'); # map <C-I> :pyf <path-to-this-file>/clang-format.py<cr>; # imap <C-I> <c-o>:pyf <path-to-this-file>/clang-format.py<cr>; # elseif has('python3'); # map <C-I> :py3f <path-to-this-file>/clang-format.py<cr>; # imap <C-I> <c-o>:py3f <path-to-this-file>/clang-format.py<cr>; # endif; #; # The if-elseif-endif conditional should pick either the python3 or python2; # integration depending on your vim setup.; #; # The first mapping enables clang-format for NORMAL and VISUAL mode, the second; # mapping adds support for INSERT mode. Change ""C-I"" to another binding if you; # need clang-format on a different key (C-I stands for Ctrl+i).; #; # With this integration you can press the bound key and clang-format will; # format the current line in NORMAL and INSERT mode or the selected region in; # VISUAL mode. The line or region is extended to the next bigger syntactic; # entity.; #; # You can also pass in the variable ""l:lines"" to choose the range for; # formatting. This variable can either contain ""<start line>:<end line>"" or; # ""all"" to format the full file. So, to format the full file, write a function; # like:; # :function FormatFile(); # : let l:lines=""all""; # : if has('python'); # : pyf <path-to-this-file>/clang-format.py; # : elseif has('python3'); # : py3f <path-to-this-file>/clang-format.py; # : endif; # :endfunction; #; # It operates on the current, potentially unsaved buffer and does not create; # or save any files. To revert a formatting, just undo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/clang-format.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py:1155,Modifiability,variab,variable,1155,"# This file is a minimal clang-format vim-integration. To install:; # - Change 'binary' if clang-format is not on the path (see below).; # - Add to your .vimrc:; #; # if has('python'); # map <C-I> :pyf <path-to-this-file>/clang-format.py<cr>; # imap <C-I> <c-o>:pyf <path-to-this-file>/clang-format.py<cr>; # elseif has('python3'); # map <C-I> :py3f <path-to-this-file>/clang-format.py<cr>; # imap <C-I> <c-o>:py3f <path-to-this-file>/clang-format.py<cr>; # endif; #; # The if-elseif-endif conditional should pick either the python3 or python2; # integration depending on your vim setup.; #; # The first mapping enables clang-format for NORMAL and VISUAL mode, the second; # mapping adds support for INSERT mode. Change ""C-I"" to another binding if you; # need clang-format on a different key (C-I stands for Ctrl+i).; #; # With this integration you can press the bound key and clang-format will; # format the current line in NORMAL and INSERT mode or the selected region in; # VISUAL mode. The line or region is extended to the next bigger syntactic; # entity.; #; # You can also pass in the variable ""l:lines"" to choose the range for; # formatting. This variable can either contain ""<start line>:<end line>"" or; # ""all"" to format the full file. So, to format the full file, write a function; # like:; # :function FormatFile(); # : let l:lines=""all""; # : if has('python'); # : pyf <path-to-this-file>/clang-format.py; # : elseif has('python3'); # : py3f <path-to-this-file>/clang-format.py; # : endif; # :endfunction; #; # It operates on the current, potentially unsaved buffer and does not create; # or save any files. To revert a formatting, just undo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/clang-format.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py:1649,Usability,undo,undo,1649,"# This file is a minimal clang-format vim-integration. To install:; # - Change 'binary' if clang-format is not on the path (see below).; # - Add to your .vimrc:; #; # if has('python'); # map <C-I> :pyf <path-to-this-file>/clang-format.py<cr>; # imap <C-I> <c-o>:pyf <path-to-this-file>/clang-format.py<cr>; # elseif has('python3'); # map <C-I> :py3f <path-to-this-file>/clang-format.py<cr>; # imap <C-I> <c-o>:py3f <path-to-this-file>/clang-format.py<cr>; # endif; #; # The if-elseif-endif conditional should pick either the python3 or python2; # integration depending on your vim setup.; #; # The first mapping enables clang-format for NORMAL and VISUAL mode, the second; # mapping adds support for INSERT mode. Change ""C-I"" to another binding if you; # need clang-format on a different key (C-I stands for Ctrl+i).; #; # With this integration you can press the bound key and clang-format will; # format the current line in NORMAL and INSERT mode or the selected region in; # VISUAL mode. The line or region is extended to the next bigger syntactic; # entity.; #; # You can also pass in the variable ""l:lines"" to choose the range for; # formatting. This variable can either contain ""<start line>:<end line>"" or; # ""all"" to format the full file. So, to format the full file, write a function; # like:; # :function FormatFile(); # : let l:lines=""all""; # : if has('python'); # : pyf <path-to-this-file>/clang-format.py; # : elseif has('python3'); # : py3f <path-to-this-file>/clang-format.py; # : endif; # :endfunction; #; # It operates on the current, potentially unsaved buffer and does not create; # or save any files. To revert a formatting, just undo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/clang-format.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py:2,Safety,Avoid,Avoid,2,"# Avoid flashing an ugly, ugly cmd prompt on Windows when invoking clang-format.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/clang-format.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp:87,Availability,error,error,87,// Parses <start line>:<end line> input to a pair of line numbers.; // Returns true on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp:19,Availability,error,error,19,// Returns true on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp:27,Modifiability,variab,variable,27,// To format JSON insert a variable to trick the code into thinking its; // JavaScript.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp:12,Deployability,configurat,configuration,12,// Dump the configuration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp:12,Modifiability,config,configuration,12,// Dump the configuration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp:29,Safety,detect,detect,29,// We can't read the code to detect the language if there's no file name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp:63,Safety,detect,detect,63,// Read in the code in case the filename alone isn't enough to detect the; // language.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp:280,Security,hash,hash,280,// Patterns in .clang-format-ignore file.; // Check whether `FilePath` is ignored according to the nearest; // .clang-format-ignore file based on the rules below:; // - A blank line is skipped.; // - Leading and trailing spaces of a line are trimmed.; // - A line starting with a hash (`#`) is a comment.; // - A non-comment line is a single pattern.; // - The slash (`/`) is used as the directory separator.; // - A pattern is relative to the directory of the .clang-format-ignore file (or; // the root directory if the pattern starts with a slash).; // - A pattern is negated if it starts with a bang (`!`).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/ClangFormatPackage.cs:119,Safety,avoid,avoid,119,"// Check if string contains quotes. On Windows, file names cannot contain quotes.; // We do not accept them however to avoid hard-to-debug problems.; // A quote in user input would end the parameter quote and so break the command invocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/ClangFormatPackage.cs,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/ClangFormatPackage.cs
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/ClangFormatPackage.cs:3,Performance,Load,Load,3,// Load package on solution load,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/ClangFormatPackage.cs,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/ClangFormatPackage.cs
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/ClangFormatPackage.cs:28,Performance,load,load,28,// Load package on solution load,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/ClangFormatPackage.cs,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/ClangFormatPackage.cs
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/ClangFormatPackage.cs:56,Availability,down,down,56,"// 5. clang-format is done, wait until it is fully shut down.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/ClangFormatPackage.cs,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/ClangFormatPackage.cs
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/ClangFormatPackage.cs:56,Availability,error,error,56,"// FIXME: If clang-format writes enough to the standard error stream to block,; // we will never reach this point; instead, read the standard error asynchronously.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/ClangFormatPackage.cs,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/ClangFormatPackage.cs
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/ClangFormatPackage.cs:142,Availability,error,error,142,"// FIXME: If clang-format writes enough to the standard error stream to block,; // we will never reach this point; instead, read the standard error asynchronously.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/ClangFormatPackage.cs,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/ClangFormatPackage.cs
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/GlobalSuppressions.cs:327,Availability,Error,Error,327,"// This file is used by Code Analysis to maintain SuppressMessage; // attributes that are applied to this project. Project-level; // suppressions either have no target or are given a specific target; // and scoped to a namespace, type, member, etc.; //; // To add a suppression to this file, right-click the message in the; // Error List, point to ""Suppress Message(s)"", and click ""In Project; // Suppression File"". You do not need to add suppressions to this; // file manually.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/GlobalSuppressions.cs,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/GlobalSuppressions.cs
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/GlobalSuppressions.cs:308,Integrability,message,message,308,"// This file is used by Code Analysis to maintain SuppressMessage; // attributes that are applied to this project. Project-level; // suppressions either have no target or are given a specific target; // and scoped to a namespace, type, member, etc.; //; // To add a suppression to this file, right-click the message in the; // Error List, point to ""Suppress Message(s)"", and click ""In Project; // Suppression File"". You do not need to add suppressions to this; // file manually.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/GlobalSuppressions.cs,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/GlobalSuppressions.cs
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/GlobalSuppressions.cs:358,Integrability,Message,Message,358,"// This file is used by Code Analysis to maintain SuppressMessage; // attributes that are applied to this project. Project-level; // suppressions either have no target or are given a specific target; // and scoped to a namespace, type, member, etc.; //; // To add a suppression to this file, right-click the message in the; // Error List, point to ""Suppress Message(s)"", and click ""In Project; // Suppression File"". You do not need to add suppressions to this; // file manually.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/GlobalSuppressions.cs,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/GlobalSuppressions.cs
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/Resources.Designer.cs:31,Performance,cache,cached,31,/// <summary>; /// Returns the cached ResourceManager instance used by this class.; /// </summary>,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/Resources.Designer.cs,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/Resources.Designer.cs
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/RunningDocTableEventsDispatcher.cs:3,Security,Expose,Exposes,3,// Exposes event sources for IVsRunningDocTableEvents3 events.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/RunningDocTableEventsDispatcher.cs,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/RunningDocTableEventsDispatcher.cs
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/Vsix.cs:60,Integrability,interface,interfaces,60,"// Now we have the active view as IVsTextView, but the text interfaces we need; // are in the IWpfTextView.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/Vsix.cs,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/Vsix.cs
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/DummyClangFuzzer.cpp:46,Safety,sanity check,sanity check,46,"//===-- DummyClangFuzzer.cpp - Entry point to sanity check fuzzers --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Provides a main() to build without linking libFuzzer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-fuzzer/DummyClangFuzzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/DummyClangFuzzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp:468,Performance,optimiz,optimization,468,"//==-- handle_llvm.cpp - Helper function for Clang fuzzers -----------------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implements HandleLLVM for use by the Clang fuzzers. First runs a loop; // vectorizer optimization pass over the given IR code. Then mimics lli on both; // versions to JIT the generated code and execute it. Currently, functions are ; // executed on dummy inputs.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp:59,Performance,optimiz,optimization,59,// Helper function to parse command line args and find the optimization level,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp:12,Performance,optimiz,optimization,12,// Find the optimization level from the command line args,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp:26,Performance,optimiz,optimization,26,"// Helper function to add optimization passes to the TargetMachine at the ; // specified optimization level, OptLevel",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp:89,Performance,optimiz,optimization,89,"// Helper function to add optimization passes to the TargetMachine at the ; // specified optimization level, OptLevel",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp:33,Performance,optimiz,optimization,33,// Mimics the opt tool to run an optimization pass over the provided IR,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp:37,Performance,optimiz,optimization,37,// Create a module that will run the optimization passes,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp:30,Performance,optimiz,optimized,30,// Add a pass that writes the optimized IR to an output stream,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp:89,Performance,optimiz,optimized,89,// Takes a function and runs it on a set of inputs; // First determines whether f is the optimized or unoptimized function,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp:36,Performance,optimiz,optimized,36,// Figure out if we are running the optimized func or the unoptimized func,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp:30,Performance,optimiz,optimization,30,// Parse ExtraArgs to set the optimization level,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp:12,Performance,optimiz,optimize,12,// First we optimize the IR by running a loop vectorizer pass,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/input_arrays.h:403,Modifiability,variab,variables,403,"//==-- input_arrays.h - Helper function for LLVM fuzzer inputs -------------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Define a few static variables used by the LLVM Proto Fuzzer; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/input_arrays.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/input_arrays.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/proto-to-cxx/loop_proto_to_cxx.cpp:483,Integrability,wrap,wrapping,483,"//==-- loop_proto_to_cxx.cpp - Protobuf-C++ conversion ---------------------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implements functions for converting between protobufs and C++. Differs from; // proto_to_cxx.cpp by wrapping all the generated C++ code in either a single; // for loop or two nested loops. Also outputs a different function signature; // that includes a size_t parameter for the loop to use. The C++ code generated; // is meant to stress the LLVM loop vectorizer.; //; // Still a work in progress.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-fuzzer/proto-to-cxx/loop_proto_to_cxx.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/proto-to-cxx/loop_proto_to_cxx.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/proto-to-cxx/loop_proto_to_cxx_main.cpp:396,Usability,simpl,simple,396,"//==-- loop_proto_to_cxx_main.cpp - Driver for protobuf-C++ conversion -----==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implements a simple driver to print a C++ program from a protobuf with loops.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-fuzzer/proto-to-cxx/loop_proto_to_cxx_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/proto-to-cxx/loop_proto_to_cxx_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/proto-to-cxx/proto_to_cxx_main.cpp:396,Usability,simpl,simple,396,"//==-- proto_to_cxx_main.cpp - Driver for protobuf-C++ conversion ----------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implements a simple driver to print a C++ program from a protobuf.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-fuzzer/proto-to-cxx/proto_to_cxx_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/proto-to-cxx/proto_to_cxx_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/proto-to-llvm/loop_proto_to_llvm.cpp:63,Integrability,wrap,wrapper,63,// Counter variable to generate new LLVM IR variable names and wrapper function,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-fuzzer/proto-to-llvm/loop_proto_to_llvm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/proto-to-llvm/loop_proto_to_llvm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/proto-to-llvm/loop_proto_to_llvm.cpp:11,Modifiability,variab,variable,11,// Counter variable to generate new LLVM IR variable names and wrapper function,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-fuzzer/proto-to-llvm/loop_proto_to_llvm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/proto-to-llvm/loop_proto_to_llvm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/proto-to-llvm/loop_proto_to_llvm.cpp:44,Modifiability,variab,variable,44,// Counter variable to generate new LLVM IR variable names and wrapper function,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-fuzzer/proto-to-llvm/loop_proto_to_llvm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/proto-to-llvm/loop_proto_to_llvm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/proto-to-llvm/loop_proto_to_llvm_main.cpp:396,Usability,simpl,simple,396,"//==-- loop_proto_to_llvm_main.cpp - Driver for protobuf-LLVM conversion----==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implements a simple driver to print a LLVM program from a protobuf with loops; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-fuzzer/proto-to-llvm/loop_proto_to_llvm_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/proto-to-llvm/loop_proto_to_llvm_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-import-test/clang-import-test.cpp:21,Testability,test,test,21,"//===-- clang-import-test.cpp - ASTImporter/ExternalASTSource testbed -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-import-test/clang-import-test.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-import-test/clang-import-test.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-import-test/clang-import-test.cpp:62,Testability,test,testbed,62,"//===-- clang-import-test.cpp - ASTImporter/ExternalASTSource testbed -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-import-test/clang-import-test.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-import-test/clang-import-test.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-import-test/clang-import-test.cpp:14,Testability,test,testing,14,// Needed for testing dynamic_cast.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-import-test/clang-import-test.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-import-test/clang-import-test.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-import-test/clang-import-test.cpp:131,Security,access,accessor,131,/// A container for a CompilerInstance (possibly with an ExternalASTMerger; /// attached to its ASTContext).; ///; /// Provides an accessor for the DeclContext origins associated with the; /// ExternalASTMerger (or an empty list of origins if no ExternalASTMerger is; /// attached).; ///; /// This is the main unit of parsed source code maintained by clang-import-test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-import-test/clang-import-test.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-import-test/clang-import-test.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-import-test/clang-import-test.cpp:364,Testability,test,test,364,/// A container for a CompilerInstance (possibly with an ExternalASTMerger; /// attached to its ASTContext).; ///; /// Provides an accessor for the DeclContext origins associated with the; /// ExternalASTMerger (or an empty list of origins if no ExternalASTMerger is; /// attached).; ///; /// This is the main unit of parsed source code maintained by clang-import-test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-import-test/clang-import-test.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-import-test/clang-import-test.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp:21,Integrability,wrap,wrapper,21,"//===-- clang-linker-wrapper/ClangLinkerWrapper.cpp - wrapper over linker-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This tool works as a wrapper over a linking job. This tool is used to create; // linked device images for offloading. It scans the linker's input for embedded; // device offloading data stored in sections `.llvm.offloading` and extracts it; // as a temporary file. The extracted device files will then be passed to a; // device linking job to create a final device image.; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp:54,Integrability,wrap,wrapper,54,"//===-- clang-linker-wrapper/ClangLinkerWrapper.cpp - wrapper over linker-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This tool works as a wrapper over a linking job. This tool is used to create; // linked device images for offloading. It scans the linker's input for embedded; // device offloading data stored in sections `.llvm.offloading` and extracts it; // as a temporary file. The extracted device files will then be passed to a; // device linking job to create a final device image.; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp:402,Integrability,wrap,wrapper,402,"//===-- clang-linker-wrapper/ClangLinkerWrapper.cpp - wrapper over linker-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This tool works as a wrapper over a linking job. This tool is used to create; // linked device images for offloading. It scans the linker's input for embedded; // device offloading data stored in sections `.llvm.offloading` and extracts it; // as a temporary file. The extracted device files will then be passed to a; // device linking job to create a final device image.; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp:29,Deployability,install,installation,29,/// Binary path for the CUDA installation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp:42,Integrability,wrap,wrapper,42,/// Temporary files created by the linker wrapper.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp:59,Availability,error,error,59,/// Global flag to indicate that the LTO pipeline threw an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp:41,Deployability,pipeline,pipeline,41,/// Global flag to indicate that the LTO pipeline threw an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp:35,Integrability,wrap,wrapper,35,// Options only used by the linker wrapper.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp:86,Integrability,wrap,wrap,86,/// Create an extra user-specified \p OffloadFile.; /// TODO: We should find a way to wrap these as libraries instead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp:13,Integrability,wrap,wrapped,13,/// Runs the wrapped linker job with the newly created input.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp:57,Integrability,wrap,wrapper,57,// Do not forward arguments only intended for the linker wrapper.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp:73,Security,sanitiz,sanitizers,73,"// Sometimes needed libraries are passed by name, such as when using; // sanitizers. We need to check the file magic for any libraries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp:127,Usability,simpl,simplified,127,// We need to resolve the symbols so the LTO backend knows which symbols need; // to be kept or can be internalized. This is a simplified symbol resolution; // scheme to approximate the full resolution a linker would do.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp:156,Testability,assert,assertion,156,"// The final definition will reside in this linkage unit if the symbol is; // defined and local to the module. This only checks for bitcode files,; // full assertion will require complete symbol resolution.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp:54,Integrability,wrap,wrap,54,"// We do not support linker redefined symbols (e.g. --wrap) for device; // image linking, so the symbols will not be changed after LTO.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp:3,Deployability,Update,Update,3,"// Update this symbol in the ""table"" with the new information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp:33,Deployability,update,update,33,// If the file gets extracted we update the table with the new symbols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp:3,Deployability,Update,Update,3,"// Update this symbol in the ""table"" with the new information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp:33,Deployability,update,update,33,// If the file gets extracted we update the table with the new symbols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp:12,Integrability,wrap,wrap,12,// Link and wrap the device images extracted from the linker input.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-offload-bundler/ClangOffloadBundler.cpp:42,Availability,error,errors,42,// Process commandline options and report errors,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-offload-bundler/ClangOffloadBundler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-offload-bundler/ClangOffloadBundler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-offload-bundler/ClangOffloadBundler.cpp:101,Modifiability,variab,variables,101,/// Class to store bundler options in standard (non-cl::opt) data structures; // Avoid using cl::opt variables after these assignments when possible,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-offload-bundler/ClangOffloadBundler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-offload-bundler/ClangOffloadBundler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-offload-bundler/ClangOffloadBundler.cpp:81,Safety,Avoid,Avoid,81,/// Class to store bundler options in standard (non-cl::opt) data structures; // Avoid using cl::opt variables after these assignments when possible,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-offload-bundler/ClangOffloadBundler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-offload-bundler/ClangOffloadBundler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-offload-bundler/ClangOffloadBundler.cpp:105,Availability,error,error,105,"// Host triple is not really needed for unbundling operation, so do not; // treat missing host triple as error if we do unbundling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-offload-bundler/ClangOffloadBundler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-offload-bundler/ClangOffloadBundler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:41,Modifiability,refactor,refactoring,41,"//===--- ClangRefactor.cpp - Clang-based refactoring tool -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements a clang-refactor tool that performs various; /// source transformations.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:425,Modifiability,refactor,refactor,425,"//===--- ClangRefactor.cpp - Clang-based refactoring tool -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements a clang-refactor tool that performs various; /// source transformations.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:444,Performance,perform,performs,444,"//===--- ClangRefactor.cpp - Clang-based refactoring tool -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements a clang-refactor tool that performs various; /// source transformations.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:232,Integrability,inject,inject,232,/// Returns a replacement refactoring result consumer (if any) that should; /// consume the results of a refactoring operation.; ///; /// The replacement refactoring result consumer is used by \c; /// TestSourceSelectionArgument to inject a test-specific result handling; /// logic into the refactoring operation. The test-specific consumer; /// ensures that the individual results in a particular test group are; /// identical.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:26,Modifiability,refactor,refactoring,26,/// Returns a replacement refactoring result consumer (if any) that should; /// consume the results of a refactoring operation.; ///; /// The replacement refactoring result consumer is used by \c; /// TestSourceSelectionArgument to inject a test-specific result handling; /// logic into the refactoring operation. The test-specific consumer; /// ensures that the individual results in a particular test group are; /// identical.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:105,Modifiability,refactor,refactoring,105,/// Returns a replacement refactoring result consumer (if any) that should; /// consume the results of a refactoring operation.; ///; /// The replacement refactoring result consumer is used by \c; /// TestSourceSelectionArgument to inject a test-specific result handling; /// logic into the refactoring operation. The test-specific consumer; /// ensures that the individual results in a particular test group are; /// identical.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:154,Modifiability,refactor,refactoring,154,/// Returns a replacement refactoring result consumer (if any) that should; /// consume the results of a refactoring operation.; ///; /// The replacement refactoring result consumer is used by \c; /// TestSourceSelectionArgument to inject a test-specific result handling; /// logic into the refactoring operation. The test-specific consumer; /// ensures that the individual results in a particular test group are; /// identical.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:291,Modifiability,refactor,refactoring,291,/// Returns a replacement refactoring result consumer (if any) that should; /// consume the results of a refactoring operation.; ///; /// The replacement refactoring result consumer is used by \c; /// TestSourceSelectionArgument to inject a test-specific result handling; /// logic into the refactoring operation. The test-specific consumer; /// ensures that the individual results in a particular test group are; /// identical.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:232,Security,inject,inject,232,/// Returns a replacement refactoring result consumer (if any) that should; /// consume the results of a refactoring operation.; ///; /// The replacement refactoring result consumer is used by \c; /// TestSourceSelectionArgument to inject a test-specific result handling; /// logic into the refactoring operation. The test-specific consumer; /// ensures that the individual results in a particular test group are; /// identical.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:201,Testability,Test,TestSourceSelectionArgument,201,/// Returns a replacement refactoring result consumer (if any) that should; /// consume the results of a refactoring operation.; ///; /// The replacement refactoring result consumer is used by \c; /// TestSourceSelectionArgument to inject a test-specific result handling; /// logic into the refactoring operation. The test-specific consumer; /// ensures that the individual results in a particular test group are; /// identical.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:241,Testability,test,test-specific,241,/// Returns a replacement refactoring result consumer (if any) that should; /// consume the results of a refactoring operation.; ///; /// The replacement refactoring result consumer is used by \c; /// TestSourceSelectionArgument to inject a test-specific result handling; /// logic into the refactoring operation. The test-specific consumer; /// ensures that the individual results in a particular test group are; /// identical.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:276,Testability,log,logic,276,/// Returns a replacement refactoring result consumer (if any) that should; /// consume the results of a refactoring operation.; ///; /// The replacement refactoring result consumer is used by \c; /// TestSourceSelectionArgument to inject a test-specific result handling; /// logic into the refactoring operation. The test-specific consumer; /// ensures that the individual results in a particular test group are; /// identical.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:318,Testability,test,test-specific,318,/// Returns a replacement refactoring result consumer (if any) that should; /// consume the results of a refactoring operation.; ///; /// The replacement refactoring result consumer is used by \c; /// TestSourceSelectionArgument to inject a test-specific result handling; /// logic into the refactoring operation. The test-specific consumer; /// ensures that the individual results in a particular test group are; /// identical.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:398,Testability,test,test,398,/// Returns a replacement refactoring result consumer (if any) that should; /// consume the results of a refactoring operation.; ///; /// The replacement refactoring result consumer is used by \c; /// TestSourceSelectionArgument to inject a test-specific result handling; /// logic into the refactoring operation. The test-specific consumer; /// ensures that the individual results in a particular test group are; /// identical.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:99,Availability,error,error,99,"/// Runs the give refactoring function for each specified selection.; ///; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:18,Modifiability,refactor,refactoring,18,"/// Runs the give refactoring function for each specified selection.; ///; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:33,Testability,test,test,33,/// Stores the parsed -selection=test:<filename> option.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:4,Testability,Test,Testing,4,/// Testing support: invokes the selection action for each selection range in; /// the test file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:87,Testability,test,test,87,/// Testing support: invokes the selection action for each selection range in; /// the test file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:13,Availability,error,error,13,// A parsing error was already reported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:75,Modifiability,refactor,refactoring,75,/// A container that stores the command-line options used by a single; /// refactoring option.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:79,Modifiability,refactor,refactoring,79,/// Passes the command-line option values to the options used by a single; /// refactoring action rule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:16,Modifiability,refactor,refactoring,16,/// Creates the refactoring options used by all the rules in a single; /// refactoring action.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:75,Modifiability,refactor,refactoring,75,/// Creates the refactoring options used by all the rules in a single; /// refactoring action.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:48,Modifiability,refactor,refactoring,48,/// A subcommand that corresponds to individual refactoring action.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:14,Modifiability,refactor,refactoring,14,// Create the refactoring options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:78,Availability,error,error,78,"/// Parses the ""-selection"" command-line argument.; ///; /// \returns true on error, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:43,Modifiability,refactor,refactoring,43,// Initializes the selected subcommand and refactoring rule based on the; // command line options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:30,Testability,test,test,30,"// If the selection option is test specific, we use a test-specific; // consumer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:54,Testability,test,test-specific,54,"// If the selection option is test specific, we use a test-specific; // consumer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:23,Modifiability,refactor,refactoring,23,/// Logs an individual refactoring action invocation to STDOUT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:4,Testability,Log,Logs,4,/// Logs an individual refactoring action invocation to STDOUT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:150,Modifiability,refactor,refactor,150,"// Figure out which action is specified by the user. The user must specify the; // action using a command-line subcommand, e.g. the invocation `clang-refactor; // local-rename` corresponds to the `LocalRename` refactoring action. All; // subcommands must have a unique names. This allows us to figure out which; // refactoring action should be invoked by looking at the first subcommand; // that's enabled by LLVM's command-line parser.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:210,Modifiability,refactor,refactoring,210,"// Figure out which action is specified by the user. The user must specify the; // action using a command-line subcommand, e.g. the invocation `clang-refactor; // local-rename` corresponds to the `LocalRename` refactoring action. All; // subcommands must have a unique names. This allows us to figure out which; // refactoring action should be invoked by looking at the first subcommand; // that's enabled by LLVM's command-line parser.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:315,Modifiability,refactor,refactoring,315,"// Figure out which action is specified by the user. The user must specify the; // action using a command-line subcommand, e.g. the invocation `clang-refactor; // local-rename` corresponds to the `LocalRename` refactoring action. All; // subcommands must have a unique names. This allows us to figure out which; // refactoring action should be invoked by looking at the first subcommand; // that's enabled by LLVM's command-line parser.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp:417,Integrability,rout,routines,417,"//===--- TestSupport.cpp - Clang-based refactoring tool -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements routines that provide refactoring testing; /// utilities.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp:39,Modifiability,refactor,refactoring,39,"//===--- TestSupport.cpp - Clang-based refactoring tool -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements routines that provide refactoring testing; /// utilities.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp:439,Modifiability,refactor,refactoring,439,"//===--- TestSupport.cpp - Clang-based refactoring tool -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements routines that provide refactoring testing; /// utilities.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp:9,Testability,Test,TestSupport,9,"//===--- TestSupport.cpp - Clang-based refactoring tool -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements routines that provide refactoring testing; /// utilities.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp:451,Testability,test,testing,451,"//===--- TestSupport.cpp - Clang-based refactoring tool -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements routines that provide refactoring testing; /// utilities.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp:3,Availability,error,error,3,// error has occurred.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp:7,Availability,error,error,7,// The error messages must match.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp:13,Integrability,message,messages,13,// The error messages must match.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp:10,Safety,detect,detect,10,// Try to detect mistyped 'range:' comments to ensure tests don't miss; // anything.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp:54,Testability,test,tests,54,// Try to detect mistyped 'range:' comments to ensure tests don't miss; // anything.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp:17,Modifiability,refactor,refactor,17,// end namespace refactor,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h:419,Integrability,rout,routines,419,"//===--- TestSupport.h - Clang-based refactoring tool -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Declares datatypes and routines that are used by test-specific code; /// in clang-refactor.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h:37,Modifiability,refactor,refactoring,37,"//===--- TestSupport.h - Clang-based refactoring tool -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Declares datatypes and routines that are used by test-specific code; /// in clang-refactor.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h:478,Modifiability,refactor,refactor,478,"//===--- TestSupport.h - Clang-based refactoring tool -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Declares datatypes and routines that are used by test-specific code; /// in clang-refactor.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h:9,Testability,Test,TestSupport,9,"//===--- TestSupport.h - Clang-based refactoring tool -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Declares datatypes and routines that are used by test-specific code; /// in clang-refactor.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h:445,Testability,test,test-specific,445,"//===--- TestSupport.h - Clang-based refactoring tool -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Declares datatypes and routines that are used by test-specific code; /// in clang-refactor.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h:719,Modifiability,refactor,refactor,719,"/// A source selection range that's specified in a test file using an inline; /// command in the comment. These commands can take the following forms:; ///; /// - /*range=*/ will create an empty selection range in the default group; /// right after the comment.; /// - /*range a=*/ will create an empty selection range in the 'a' group right; /// after the comment.; /// - /*range = +1*/ will create an empty selection range at a location that's; /// right after the comment with one offset to the column.; /// - /*range= -> +2:3*/ will create a selection range that starts at the; /// location right after the comment, and ends at column 3 of the 2nd line; /// after the line of the starting location.; ///; /// Clang-refactor will expected all ranges in one test group to produce; /// identical results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h:51,Testability,test,test,51,"/// A source selection range that's specified in a test file using an inline; /// command in the comment. These commands can take the following forms:; ///; /// - /*range=*/ will create an empty selection range in the default group; /// right after the comment.; /// - /*range a=*/ will create an empty selection range in the 'a' group right; /// after the comment.; /// - /*range = +1*/ will create an empty selection range at a location that's; /// right after the comment with one offset to the column.; /// - /*range= -> +2:3*/ will create a selection range that starts at the; /// location right after the comment, and ends at column 3 of the 2nd line; /// after the line of the starting location.; ///; /// Clang-refactor will expected all ranges in one test group to produce; /// identical results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h:760,Testability,test,test,760,"/// A source selection range that's specified in a test file using an inline; /// command in the comment. These commands can take the following forms:; ///; /// - /*range=*/ will create an empty selection range in the default group; /// right after the comment.; /// - /*range a=*/ will create an empty selection range in the 'a' group right; /// after the comment.; /// - /*range = +1*/ will create an empty selection range at a location that's; /// right after the comment with one offset to the column.; /// - /*range= -> +2:3*/ will create a selection range that starts at the; /// location right after the comment, and ends at column 3 of the 2nd line; /// after the line of the starting location.; ///; /// Clang-refactor will expected all ranges in one test group to produce; /// identical results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h:13,Testability,test,test,13,/// A set of test selection ranges specified in one file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h:1051,Availability,error,error,1051,"/// Extracts the grouped selection ranges from the file that's specified in; /// the -selection=test:<filename> option.; ///; /// The grouped ranges are specified in comments using the following syntax:; /// ""range"" [ group-name ] ""="" [ ""+"" starting-column-offset ] [ ""->""; /// ""+"" ending-line-offset "":""; /// ending-column-position ]; ///; /// The selection range is then computed from this command by taking the ending; /// location of the comment, and adding 'starting-column-offset' to the column; /// for that location. That location in turns becomes the whole selection range,; /// unless 'ending-line-offset' and 'ending-column-position' are specified. If; /// they are specified, then the ending location of the selection range is; /// the starting location's line + 'ending-line-offset' and the; /// 'ending-column-position' column.; ///; /// All selection ranges in one group are expected to produce the same; /// refactoring result.; ///; /// When testing, zero is returned from clang-refactor even when a group; /// produces an initiation error, which is different from normal invocation; /// that returns a non-zero value. This is done on purpose, to ensure that group; /// consistency checks can return non-zero, but still print the output of; /// the group. So even if a test matches the output of group, it will still fail; /// because clang-refactor should return zero on exit when the group results are; /// consistent.; ///; /// \returns std::nullopt on failure (errors are emitted to stderr), or a set of; /// grouped source ranges in the given file otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h:1473,Availability,failure,failure,1473,"/// Extracts the grouped selection ranges from the file that's specified in; /// the -selection=test:<filename> option.; ///; /// The grouped ranges are specified in comments using the following syntax:; /// ""range"" [ group-name ] ""="" [ ""+"" starting-column-offset ] [ ""->""; /// ""+"" ending-line-offset "":""; /// ending-column-position ]; ///; /// The selection range is then computed from this command by taking the ending; /// location of the comment, and adding 'starting-column-offset' to the column; /// for that location. That location in turns becomes the whole selection range,; /// unless 'ending-line-offset' and 'ending-column-position' are specified. If; /// they are specified, then the ending location of the selection range is; /// the starting location's line + 'ending-line-offset' and the; /// 'ending-column-position' column.; ///; /// All selection ranges in one group are expected to produce the same; /// refactoring result.; ///; /// When testing, zero is returned from clang-refactor even when a group; /// produces an initiation error, which is different from normal invocation; /// that returns a non-zero value. This is done on purpose, to ensure that group; /// consistency checks can return non-zero, but still print the output of; /// the group. So even if a test matches the output of group, it will still fail; /// because clang-refactor should return zero on exit when the group results are; /// consistent.; ///; /// \returns std::nullopt on failure (errors are emitted to stderr), or a set of; /// grouped source ranges in the given file otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h:1482,Availability,error,errors,1482,"/// Extracts the grouped selection ranges from the file that's specified in; /// the -selection=test:<filename> option.; ///; /// The grouped ranges are specified in comments using the following syntax:; /// ""range"" [ group-name ] ""="" [ ""+"" starting-column-offset ] [ ""->""; /// ""+"" ending-line-offset "":""; /// ending-column-position ]; ///; /// The selection range is then computed from this command by taking the ending; /// location of the comment, and adding 'starting-column-offset' to the column; /// for that location. That location in turns becomes the whole selection range,; /// unless 'ending-line-offset' and 'ending-column-position' are specified. If; /// they are specified, then the ending location of the selection range is; /// the starting location's line + 'ending-line-offset' and the; /// 'ending-column-position' column.; ///; /// All selection ranges in one group are expected to produce the same; /// refactoring result.; ///; /// When testing, zero is returned from clang-refactor even when a group; /// produces an initiation error, which is different from normal invocation; /// that returns a non-zero value. This is done on purpose, to ensure that group; /// consistency checks can return non-zero, but still print the output of; /// the group. So even if a test matches the output of group, it will still fail; /// because clang-refactor should return zero on exit when the group results are; /// consistent.; ///; /// \returns std::nullopt on failure (errors are emitted to stderr), or a set of; /// grouped source ranges in the given file otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h:924,Modifiability,refactor,refactoring,924,"/// Extracts the grouped selection ranges from the file that's specified in; /// the -selection=test:<filename> option.; ///; /// The grouped ranges are specified in comments using the following syntax:; /// ""range"" [ group-name ] ""="" [ ""+"" starting-column-offset ] [ ""->""; /// ""+"" ending-line-offset "":""; /// ending-column-position ]; ///; /// The selection range is then computed from this command by taking the ending; /// location of the comment, and adding 'starting-column-offset' to the column; /// for that location. That location in turns becomes the whole selection range,; /// unless 'ending-line-offset' and 'ending-column-position' are specified. If; /// they are specified, then the ending location of the selection range is; /// the starting location's line + 'ending-line-offset' and the; /// 'ending-column-position' column.; ///; /// All selection ranges in one group are expected to produce the same; /// refactoring result.; ///; /// When testing, zero is returned from clang-refactor even when a group; /// produces an initiation error, which is different from normal invocation; /// that returns a non-zero value. This is done on purpose, to ensure that group; /// consistency checks can return non-zero, but still print the output of; /// the group. So even if a test matches the output of group, it will still fail; /// because clang-refactor should return zero on exit when the group results are; /// consistent.; ///; /// \returns std::nullopt on failure (errors are emitted to stderr), or a set of; /// grouped source ranges in the given file otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h:996,Modifiability,refactor,refactor,996,"/// Extracts the grouped selection ranges from the file that's specified in; /// the -selection=test:<filename> option.; ///; /// The grouped ranges are specified in comments using the following syntax:; /// ""range"" [ group-name ] ""="" [ ""+"" starting-column-offset ] [ ""->""; /// ""+"" ending-line-offset "":""; /// ending-column-position ]; ///; /// The selection range is then computed from this command by taking the ending; /// location of the comment, and adding 'starting-column-offset' to the column; /// for that location. That location in turns becomes the whole selection range,; /// unless 'ending-line-offset' and 'ending-column-position' are specified. If; /// they are specified, then the ending location of the selection range is; /// the starting location's line + 'ending-line-offset' and the; /// 'ending-column-position' column.; ///; /// All selection ranges in one group are expected to produce the same; /// refactoring result.; ///; /// When testing, zero is returned from clang-refactor even when a group; /// produces an initiation error, which is different from normal invocation; /// that returns a non-zero value. This is done on purpose, to ensure that group; /// consistency checks can return non-zero, but still print the output of; /// the group. So even if a test matches the output of group, it will still fail; /// because clang-refactor should return zero on exit when the group results are; /// consistent.; ///; /// \returns std::nullopt on failure (errors are emitted to stderr), or a set of; /// grouped source ranges in the given file otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h:1358,Modifiability,refactor,refactor,1358,"/// Extracts the grouped selection ranges from the file that's specified in; /// the -selection=test:<filename> option.; ///; /// The grouped ranges are specified in comments using the following syntax:; /// ""range"" [ group-name ] ""="" [ ""+"" starting-column-offset ] [ ""->""; /// ""+"" ending-line-offset "":""; /// ending-column-position ]; ///; /// The selection range is then computed from this command by taking the ending; /// location of the comment, and adding 'starting-column-offset' to the column; /// for that location. That location in turns becomes the whole selection range,; /// unless 'ending-line-offset' and 'ending-column-position' are specified. If; /// they are specified, then the ending location of the selection range is; /// the starting location's line + 'ending-line-offset' and the; /// 'ending-column-position' column.; ///; /// All selection ranges in one group are expected to produce the same; /// refactoring result.; ///; /// When testing, zero is returned from clang-refactor even when a group; /// produces an initiation error, which is different from normal invocation; /// that returns a non-zero value. This is done on purpose, to ensure that group; /// consistency checks can return non-zero, but still print the output of; /// the group. So even if a test matches the output of group, it will still fail; /// because clang-refactor should return zero on exit when the group results are; /// consistent.; ///; /// \returns std::nullopt on failure (errors are emitted to stderr), or a set of; /// grouped source ranges in the given file otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h:96,Testability,test,test,96,"/// Extracts the grouped selection ranges from the file that's specified in; /// the -selection=test:<filename> option.; ///; /// The grouped ranges are specified in comments using the following syntax:; /// ""range"" [ group-name ] ""="" [ ""+"" starting-column-offset ] [ ""->""; /// ""+"" ending-line-offset "":""; /// ending-column-position ]; ///; /// The selection range is then computed from this command by taking the ending; /// location of the comment, and adding 'starting-column-offset' to the column; /// for that location. That location in turns becomes the whole selection range,; /// unless 'ending-line-offset' and 'ending-column-position' are specified. If; /// they are specified, then the ending location of the selection range is; /// the starting location's line + 'ending-line-offset' and the; /// 'ending-column-position' column.; ///; /// All selection ranges in one group are expected to produce the same; /// refactoring result.; ///; /// When testing, zero is returned from clang-refactor even when a group; /// produces an initiation error, which is different from normal invocation; /// that returns a non-zero value. This is done on purpose, to ensure that group; /// consistency checks can return non-zero, but still print the output of; /// the group. So even if a test matches the output of group, it will still fail; /// because clang-refactor should return zero on exit when the group results are; /// consistent.; ///; /// \returns std::nullopt on failure (errors are emitted to stderr), or a set of; /// grouped source ranges in the given file otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h:959,Testability,test,testing,959,"/// Extracts the grouped selection ranges from the file that's specified in; /// the -selection=test:<filename> option.; ///; /// The grouped ranges are specified in comments using the following syntax:; /// ""range"" [ group-name ] ""="" [ ""+"" starting-column-offset ] [ ""->""; /// ""+"" ending-line-offset "":""; /// ending-column-position ]; ///; /// The selection range is then computed from this command by taking the ending; /// location of the comment, and adding 'starting-column-offset' to the column; /// for that location. That location in turns becomes the whole selection range,; /// unless 'ending-line-offset' and 'ending-column-position' are specified. If; /// they are specified, then the ending location of the selection range is; /// the starting location's line + 'ending-line-offset' and the; /// 'ending-column-position' column.; ///; /// All selection ranges in one group are expected to produce the same; /// refactoring result.; ///; /// When testing, zero is returned from clang-refactor even when a group; /// produces an initiation error, which is different from normal invocation; /// that returns a non-zero value. This is done on purpose, to ensure that group; /// consistency checks can return non-zero, but still print the output of; /// the group. So even if a test matches the output of group, it will still fail; /// because clang-refactor should return zero on exit when the group results are; /// consistent.; ///; /// \returns std::nullopt on failure (errors are emitted to stderr), or a set of; /// grouped source ranges in the given file otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h:1286,Testability,test,test,1286,"/// Extracts the grouped selection ranges from the file that's specified in; /// the -selection=test:<filename> option.; ///; /// The grouped ranges are specified in comments using the following syntax:; /// ""range"" [ group-name ] ""="" [ ""+"" starting-column-offset ] [ ""->""; /// ""+"" ending-line-offset "":""; /// ending-column-position ]; ///; /// The selection range is then computed from this command by taking the ending; /// location of the comment, and adding 'starting-column-offset' to the column; /// for that location. That location in turns becomes the whole selection range,; /// unless 'ending-line-offset' and 'ending-column-position' are specified. If; /// they are specified, then the ending location of the selection range is; /// the starting location's line + 'ending-line-offset' and the; /// 'ending-column-position' column.; ///; /// All selection ranges in one group are expected to produce the same; /// refactoring result.; ///; /// When testing, zero is returned from clang-refactor even when a group; /// produces an initiation error, which is different from normal invocation; /// that returns a non-zero value. This is done on purpose, to ensure that group; /// consistency checks can return non-zero, but still print the output of; /// the group. So even if a test matches the output of group, it will still fail; /// because clang-refactor should return zero on exit when the group results are; /// consistent.; ///; /// \returns std::nullopt on failure (errors are emitted to stderr), or a set of; /// grouped source ranges in the given file otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h:17,Modifiability,refactor,refactor,17,// end namespace refactor,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ToolRefactoringResultConsumer.h:7,Integrability,interface,interface,7,/// An interface that subclasses the \c RefactoringResultConsumer interface; /// that stores the reference to the TU-specific diagnostics engine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ToolRefactoringResultConsumer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ToolRefactoringResultConsumer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ToolRefactoringResultConsumer.h:66,Integrability,interface,interface,66,/// An interface that subclasses the \c RefactoringResultConsumer interface; /// that stores the reference to the TU-specific diagnostics engine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ToolRefactoringResultConsumer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ToolRefactoringResultConsumer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ToolRefactoringResultConsumer.h:40,Modifiability,Refactor,RefactoringResultConsumer,40,/// An interface that subclasses the \c RefactoringResultConsumer interface; /// that stores the reference to the TU-specific diagnostics engine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ToolRefactoringResultConsumer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ToolRefactoringResultConsumer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ToolRefactoringResultConsumer.h:17,Modifiability,refactor,refactor,17,// end namespace refactor,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ToolRefactoringResultConsumer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ToolRefactoringResultConsumer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-rename/clang-rename.py:26,Deployability,integrat,integration,26,"""""""; Minimal clang-rename integration with Vim. Before installing make sure one of the following is satisfied:. * clang-rename is in your PATH; * `g:clang_rename_path` in ~/.vimrc points to valid clang-rename executable; * `binary` in clang-rename.py points to valid to clang-rename executable. To install, simply put this into your ~/.vimrc for python2 support. noremap <leader>cr :pyf <path-to>/clang-rename.py<cr>. For python3 use the following command (note the change from :pyf to :py3f). noremap <leader>cr :py3f <path-to>/clang-rename.py<cr>. IMPORTANT NOTE: Before running the tool, make sure you saved the file. All you have to do now is to place a cursor on a variable/function/class which; you would like to rename and press '<leader>cr'. You will be prompted for a new; name if the cursor points to a valid symbol.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-rename/clang-rename.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-rename/clang-rename.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-rename/clang-rename.py:55,Deployability,install,installing,55,"""""""; Minimal clang-rename integration with Vim. Before installing make sure one of the following is satisfied:. * clang-rename is in your PATH; * `g:clang_rename_path` in ~/.vimrc points to valid clang-rename executable; * `binary` in clang-rename.py points to valid to clang-rename executable. To install, simply put this into your ~/.vimrc for python2 support. noremap <leader>cr :pyf <path-to>/clang-rename.py<cr>. For python3 use the following command (note the change from :pyf to :py3f). noremap <leader>cr :py3f <path-to>/clang-rename.py<cr>. IMPORTANT NOTE: Before running the tool, make sure you saved the file. All you have to do now is to place a cursor on a variable/function/class which; you would like to rename and press '<leader>cr'. You will be prompted for a new; name if the cursor points to a valid symbol.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-rename/clang-rename.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-rename/clang-rename.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-rename/clang-rename.py:298,Deployability,install,install,298,"""""""; Minimal clang-rename integration with Vim. Before installing make sure one of the following is satisfied:. * clang-rename is in your PATH; * `g:clang_rename_path` in ~/.vimrc points to valid clang-rename executable; * `binary` in clang-rename.py points to valid to clang-rename executable. To install, simply put this into your ~/.vimrc for python2 support. noremap <leader>cr :pyf <path-to>/clang-rename.py<cr>. For python3 use the following command (note the change from :pyf to :py3f). noremap <leader>cr :py3f <path-to>/clang-rename.py<cr>. IMPORTANT NOTE: Before running the tool, make sure you saved the file. All you have to do now is to place a cursor on a variable/function/class which; you would like to rename and press '<leader>cr'. You will be prompted for a new; name if the cursor points to a valid symbol.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-rename/clang-rename.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-rename/clang-rename.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-rename/clang-rename.py:26,Integrability,integrat,integration,26,"""""""; Minimal clang-rename integration with Vim. Before installing make sure one of the following is satisfied:. * clang-rename is in your PATH; * `g:clang_rename_path` in ~/.vimrc points to valid clang-rename executable; * `binary` in clang-rename.py points to valid to clang-rename executable. To install, simply put this into your ~/.vimrc for python2 support. noremap <leader>cr :pyf <path-to>/clang-rename.py<cr>. For python3 use the following command (note the change from :pyf to :py3f). noremap <leader>cr :py3f <path-to>/clang-rename.py<cr>. IMPORTANT NOTE: Before running the tool, make sure you saved the file. All you have to do now is to place a cursor on a variable/function/class which; you would like to rename and press '<leader>cr'. You will be prompted for a new; name if the cursor points to a valid symbol.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-rename/clang-rename.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-rename/clang-rename.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-rename/clang-rename.py:670,Modifiability,variab,variable,670,"""""""; Minimal clang-rename integration with Vim. Before installing make sure one of the following is satisfied:. * clang-rename is in your PATH; * `g:clang_rename_path` in ~/.vimrc points to valid clang-rename executable; * `binary` in clang-rename.py points to valid to clang-rename executable. To install, simply put this into your ~/.vimrc for python2 support. noremap <leader>cr :pyf <path-to>/clang-rename.py<cr>. For python3 use the following command (note the change from :pyf to :py3f). noremap <leader>cr :py3f <path-to>/clang-rename.py<cr>. IMPORTANT NOTE: Before running the tool, make sure you saved the file. All you have to do now is to place a cursor on a variable/function/class which; you would like to rename and press '<leader>cr'. You will be prompted for a new; name if the cursor points to a valid symbol.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-rename/clang-rename.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-rename/clang-rename.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-rename/clang-rename.py:307,Usability,simpl,simply,307,"""""""; Minimal clang-rename integration with Vim. Before installing make sure one of the following is satisfied:. * clang-rename is in your PATH; * `g:clang_rename_path` in ~/.vimrc points to valid clang-rename executable; * `binary` in clang-rename.py points to valid to clang-rename executable. To install, simply put this into your ~/.vimrc for python2 support. noremap <leader>cr :pyf <path-to>/clang-rename.py<cr>. For python3 use the following command (note the change from :pyf to :py3f). noremap <leader>cr :py3f <path-to>/clang-rename.py<cr>. IMPORTANT NOTE: Before running the tool, make sure you saved the file. All you have to do now is to place a cursor on a variable/function/class which; you would like to rename and press '<leader>cr'. You will be prompted for a new; name if the cursor points to a valid symbol.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-rename/clang-rename.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-rename/clang-rename.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-rename/ClangRename.cpp:3,Performance,Perform,Perform,3,// Perform the renaming.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-rename/ClangRename.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-rename/ClangRename.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp:25,Testability,test,test,25,// Disable LSan for this test.; // FIXME: Re-enable once we can assume GCC 13.2 or higher.; // https://llvm.org/github.com/llvm/llvm-project/issues/67586.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp:13,Availability,recover,recover,13,"// We cannot recover from llvm errors. When reporting a fatal error, exit; // with status 70 to generate crash diagnostics. For BSD systems this is; // defined as an internal software error. Otherwise, exit with status 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp:31,Availability,error,errors,31,"// We cannot recover from llvm errors. When reporting a fatal error, exit; // with status 70 to generate crash diagnostics. For BSD systems this is; // defined as an internal software error. Otherwise, exit with status 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp:62,Availability,error,error,62,"// We cannot recover from llvm errors. When reporting a fatal error, exit; // with status 70 to generate crash diagnostics. For BSD systems this is; // defined as an internal software error. Otherwise, exit with status 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp:184,Availability,error,error,184,"// We cannot recover from llvm errors. When reporting a fatal error, exit; // with status 70 to generate crash diagnostics. For BSD systems this is; // defined as an internal software error. Otherwise, exit with status 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp:13,Safety,recover,recover,13,"// We cannot recover from llvm errors. When reporting a fatal error, exit; // with status 70 to generate crash diagnostics. For BSD systems this is; // defined as an internal software error. Otherwise, exit with status 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp:118,Testability,test,test,118,// If we are running with -verify a reported has to be returned as unsuccess.; // This is relevant especially for the test suite.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp:19,Availability,error,error,19,// If there was an error that came from the verifier we must return 1 as; // an exit code for the process. This will make the test fail as expected.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp:126,Testability,test,test,126,// If there was an error that came from the verifier we must return 1 as; // an exit code for the process. This will make the test fail as expected.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp:11,Availability,error,error,11,// log the error and returns an empty vector;,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp:3,Testability,log,log,3,// log the error and returns an empty vector;,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp:10,Availability,error,error,10,"// Set an error handler, so that any LLVM backend diagnostics go through our; // error handler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp:81,Availability,error,error,81,"// Set an error handler, so that any LLVM backend diagnostics go through our; // error handler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp:22,Modifiability,plugin,plugins,22,// Load any requested plugins.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp:3,Performance,Load,Load,3,// Load any requested plugins.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp:4,Usability,undo,undo,4,"R""(%undo)""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp:7,Availability,error,error,7,"// Our error handler depends on the Diagnostics object, which we're; // potentially about to delete. Uninstall the handler now so that any; // later errors use the default handling behavior instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp:149,Availability,error,errors,149,"// Our error handler depends on the Diagnostics object, which we're; // potentially about to delete. Uninstall the handler now so that any; // later errors use the default handling behavior instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp:21,Integrability,depend,depends,21,"// Our error handler depends on the Diagnostics object, which we're; // potentially about to delete. Uninstall the handler now so that any; // later errors use the default handling behavior instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:162,Performance,cache,cache,162,"/// findResourceDir finds the resource directory relative to the clang; /// compiler being used in Args, by running it with ""-print-resource-dir""; /// option and cache the results for reuse. \returns resource directory path; /// associated with the given invocation command or empty string if the; /// compiler path is NOT an absolute path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:81,Availability,error,error,81,// end anonymous namespace; /// Takes the result of a dependency scan and prints error / dependency files; /// based on the result.; ///; /// \returns True on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:159,Availability,error,error,159,// end anonymous namespace; /// Takes the result of a dependency scan and prints error / dependency files; /// based on the result.; ///; /// \returns True on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:54,Integrability,depend,dependency,54,// end anonymous namespace; /// Takes the result of a dependency scan and prints error / dependency files; /// based on the result.; ///; /// \returns True on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:89,Integrability,depend,dependency,89,// end anonymous namespace; /// Takes the result of a dependency scan and prints error / dependency files; /// based on the result.; ///; /// \returns True on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:42,Integrability,depend,dependency,42,"// Technically, we don't need to sort the dependency list to get determinism.; // Leaving these be will simply preserve the import order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:104,Usability,simpl,simply,104,"// Technically, we don't need to sort the dependency list to get determinism.; // Leaving these be will simply preserve the import order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:10,Safety,safe,safe,10,// Thread safe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:50,Deployability,update,updated,50,"// FIXME: This is mutable so that it can still be updated after insertion; // into an unordered associative container. This is ""fine"", since this; // field doesn't contribute to the hash, but it's a brittle hack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:182,Security,hash,hash,182,"// FIXME: This is mutable so that it can still be updated after insertion; // into an unordered associative container. This is ""fine"", since this; // field doesn't contribute to the hash, but it's a brittle hack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:81,Integrability,depend,dependency,81,"/// We need the output of clang-scan-deps to be deterministic. However,; /// the dependency graph may contain two modules with the same name. How; /// do we decide which one to print first? If we made that decision based; /// on the context hash, the ordering would be deterministic, but; /// different across machines. This can happen for example when the inputs; /// or the SDKs (which both contribute to the ""context"" hash) live in; /// different absolute locations. We solve that by tracking the index of; /// the first input TU that (transitively) imports the dependency, which; /// is always the same for the same input, resulting in deterministic; /// sorting that's also reproducible across machines.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:565,Integrability,depend,dependency,565,"/// We need the output of clang-scan-deps to be deterministic. However,; /// the dependency graph may contain two modules with the same name. How; /// do we decide which one to print first? If we made that decision based; /// on the context hash, the ordering would be deterministic, but; /// different across machines. This can happen for example when the inputs; /// or the SDKs (which both contribute to the ""context"" hash) live in; /// different absolute locations. We solve that by tracking the index of; /// the first input TU that (transitively) imports the dependency, which; /// is always the same for the same input, resulting in deterministic; /// sorting that's also reproducible across machines.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:241,Security,hash,hash,241,"/// We need the output of clang-scan-deps to be deterministic. However,; /// the dependency graph may contain two modules with the same name. How; /// do we decide which one to print first? If we made that decision based; /// on the context hash, the ordering would be deterministic, but; /// different across machines. This can happen for example when the inputs; /// or the SDKs (which both contribute to the ""context"" hash) live in; /// different absolute locations. We solve that by tracking the index of; /// the first input TU that (transitively) imports the dependency, which; /// is always the same for the same input, resulting in deterministic; /// sorting that's also reproducible across machines.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:421,Security,hash,hash,421,"/// We need the output of clang-scan-deps to be deterministic. However,; /// the dependency graph may contain two modules with the same name. How; /// do we decide which one to print first? If we made that decision based; /// on the context hash, the ordering would be deterministic, but; /// different across machines. This can happen for example when the inputs; /// or the SDKs (which both contribute to the ""context"" hash) live in; /// different absolute locations. We solve that by tracking the index of; /// the first input TU that (transitively) imports the dependency, which; /// is always the same for the same input, resulting in deterministic; /// sorting that's also reproducible across machines.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:61,Performance,load,load,61,"// getCompilationDataBase - If -compilation-database is set, load the; // compilation database from the specified file. Otherwise if the we're; // generating P1689 format, trying to generate the compilation database; // form specified command line after the positional parameter ""--"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:54,Integrability,Inject,Inject,54,"// The clang-cl driver passes ""-o -"" to the frontend. Inject the real; // file here to ensure ""-MT"" can be deduced if need be.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:54,Security,Inject,Inject,54,"// The clang-cl driver passes ""-o -"" to the frontend. Inject the real; // file here to ensure ""-MT"" can be deduced if need be.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:17,Integrability,depend,dependency,17,// Print out the dependency results to STDOUT by default.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:44,Integrability,depend,dependency,44,// It is useful to generate the make-format dependency output during; // the scanning for P1689. Otherwise the users need to scan again for; // it. We will generate the make-format dependency output if we find; // `-MF` in the command lines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:181,Integrability,depend,dependency,181,// It is useful to generate the make-format dependency output during; // the scanning for P1689. Otherwise the users need to scan again for; // it. We will generate the make-format dependency output if we find; // `-MF` in the command lines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:62,Performance,concurren,concurrently,62,"// With compilation database, we may open different files; // concurrently or we may write the same file concurrently. So we; // use a map here to allow multiple compile commands to write to the; // same file. Also we need a lock here to avoid data race.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:105,Performance,concurren,concurrently,105,"// With compilation database, we may open different files; // concurrently or we may write the same file concurrently. So we; // use a map here to allow multiple compile commands to write to the; // same file. Also we need a lock here to avoid data race.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:238,Safety,avoid,avoid,238,"// With compilation database, we may open different files; // concurrently or we may write the same file concurrently. So we; // use a map here to allow multiple compile commands to write to the; // same file. Also we need a lock here to avoid data race.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/diagtool/ShowEnabledWarnings.cpp:13,Availability,error,errors,13,"// Flush any errors created when initializing everything. This could happen; // for invalid command lines, which will probably give non-sensical results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/diagtool/ShowEnabledWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/diagtool/ShowEnabledWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp:473,Integrability,interface,interface,473,"//===-- cc1as_main.cpp - Clang Assembler ---------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is the entry point to the clang -cc1as functionality, which implements; // the direct interface to the LLVM MC based assembler.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp:53,Deployability,deploy,deployment,53,"/// Darwin target variant triple, the variant of the deployment target; /// for which the code is being compiled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp:30,Availability,error,error,30,// Check for missing argument error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp:9,Availability,error,errors,9,// Issue errors on unknown arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp:36,Security,sanitiz,sanitizer,36,// FIXME: init MCTargetOptions from sanitizer flags here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp:19,Availability,error,error,19,// We have already error checked this in the driver.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp:36,Availability,error,errors,36,// Delete output file if there were errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp:13,Availability,recover,recover,13,// We cannot recover from llvm errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp:31,Availability,error,errors,31,// We cannot recover from llvm errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp:13,Safety,recover,recover,13,// We cannot recover from llvm errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp:10,Availability,error,error,10,"// Set an error handler, so that any LLVM backend diagnostics go through our; // error handler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp:81,Availability,error,error,81,"// Set an error handler, so that any LLVM backend diagnostics go through our; // error handler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp:56,Integrability,message,message,56,// Honor -version.; //; // FIXME: Use a better -version message?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp:53,Availability,error,errors,53,"// Execute the invocation, unless there were parsing errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1gen_reproducer_main.cpp:31,Security,hash,hashes,31,// FIXME: Compare unsaved file hashes and report mismatch in the reproducer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1gen_reproducer_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1gen_reproducer_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp:559,Testability,test,testing,559,"//===-- cc1_main.cpp - Clang CC1 Compiler Frontend ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is the entry point to the clang -cc1 functionality, which implements the; // core compiler functionality along with a number of additional tools for; // demonstration and testing purposes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp:13,Availability,recover,recover,13,"// We cannot recover from llvm errors. When reporting a fatal error, exit; // with status 70 to generate crash diagnostics. For BSD systems this is; // defined as an internal software error. Otherwise, exit with status 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp:31,Availability,error,errors,31,"// We cannot recover from llvm errors. When reporting a fatal error, exit; // with status 70 to generate crash diagnostics. For BSD systems this is; // defined as an internal software error. Otherwise, exit with status 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp:62,Availability,error,error,62,"// We cannot recover from llvm errors. When reporting a fatal error, exit; // with status 70 to generate crash diagnostics. For BSD systems this is; // defined as an internal software error. Otherwise, exit with status 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp:184,Availability,error,error,184,"// We cannot recover from llvm errors. When reporting a fatal error, exit; // with status 70 to generate crash diagnostics. For BSD systems this is; // defined as an internal software error. Otherwise, exit with status 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp:13,Safety,recover,recover,13,"// We cannot recover from llvm errors. When reporting a fatal error, exit; // with status 70 to generate crash diagnostics. For BSD systems this is; // defined as an internal software error. Otherwise, exit with status 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp:28,Modifiability,extend,extends,28,"// We assume that the stack extends from its current address to the end of; // the environment space. In reality, there is another string literal (the; // program name) after the environment, but this is close enough (we only; // need to be within 100K or so).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp:207,Energy Efficiency,allocate,allocate,207,"// Linux kernels prior to 4.1 will sometimes locate the heap of a PIE binary; // relatively close to the stack (they are only guaranteed to be 128MiB; // apart). This results in crashes if we happen to heap-allocate more than; // 128MiB before we reach our stack high-water mark.; //; // To avoid these crashes, ensure that we have sufficient virtual memory; // pages allocated before we start running.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp:368,Energy Efficiency,allocate,allocated,368,"// Linux kernels prior to 4.1 will sometimes locate the heap of a PIE binary; // relatively close to the stack (they are only guaranteed to be 128MiB; // apart). This results in crashes if we happen to heap-allocate more than; // 128MiB before we reach our stack high-water mark.; //; // To avoid these crashes, ensure that we have sufficient virtual memory; // pages allocated before we start running.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp:291,Safety,avoid,avoid,291,"// Linux kernels prior to 4.1 will sometimes locate the heap of a PIE binary; // relatively close to the stack (they are only guaranteed to be 128MiB; // apart). This results in crashes if we happen to heap-allocate more than; // 128MiB before we reach our stack high-water mark.; //; // To avoid these crashes, ensure that we have sufficient virtual memory; // pages allocated before we start running.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp:52,Usability,usab,usable,52,/// Attempt to ensure that we have at least 8MiB of usable stack space.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp:10,Energy Efficiency,allocate,allocate,10,// Try to allocate sufficient stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp:40,Integrability,wrap,wrapped,40,// Register the support for object-file-wrapped Clang modules.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp:10,Availability,error,error,10,"// Set an error handler, so that any LLVM backend diagnostics go through our; // error handler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp:81,Availability,error,error,81,"// Set an error handler, so that any LLVM backend diagnostics go through our; // error handler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp:7,Availability,error,error,7,"// Our error handler depends on the Diagnostics object, which we're; // potentially about to delete. Uninstall the handler now so that any; // later errors use the default handling behavior instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp:149,Availability,error,errors,149,"// Our error handler depends on the Diagnostics object, which we're; // potentially about to delete. Uninstall the handler now so that any; // later errors use the default handling behavior instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp:21,Integrability,depend,depends,21,"// Our error handler depends on the Diagnostics object, which we're; // potentially about to delete. Uninstall the handler now so that any; // later errors use the default handling behavior instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp:441,Integrability,wrap,wrapper,441,"//===-- driver.cpp - Clang GCC-Compatible Driver --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is the entry point to the clang driver; it is a thin wrapper; // for functionality in the Driver clang library.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/driver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp:141,Performance,perform,perform,141,"/// ApplyOneQAOverride - Apply a list of edits to the input argument lists.; ///; /// The input string is a space separated list of edits to perform,; /// they are applied in order to the input argument lists. Edits; /// should be one of the following forms:; ///; /// '#': Silence information about the changes to the command line arguments.; ///; /// '^': Add FOO as a new argument at the beginning of the command line.; ///; /// '+': Add FOO as a new argument at the end of the command line.; ///; /// 's/XXX/YYY/': Substitute the regular expression XXX with YYY in the command; /// line.; ///; /// 'xOPTION': Removes all instances of the literal argument OPTION.; ///; /// 'XOPTION': Removes all instances of the literal argument OPTION,; /// and the following argument.; ///; /// 'Ox': Removes all flags matching 'O' or 'O[sz0-9]' and adds 'Ox'; /// at the end of the command line.; ///; /// \param OS - The stream to write edit information to.; /// \param Args - The vector of command line arguments.; /// \param Edit - The override command to perform.; /// \param SavedStrings - Set to use for storing string representations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/driver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp:1050,Performance,perform,perform,1050,"/// ApplyOneQAOverride - Apply a list of edits to the input argument lists.; ///; /// The input string is a space separated list of edits to perform,; /// they are applied in order to the input argument lists. Edits; /// should be one of the following forms:; ///; /// '#': Silence information about the changes to the command line arguments.; ///; /// '^': Add FOO as a new argument at the beginning of the command line.; ///; /// '+': Add FOO as a new argument at the end of the command line.; ///; /// 's/XXX/YYY/': Substitute the regular expression XXX with YYY in the command; /// line.; ///; /// 'xOPTION': Removes all instances of the literal argument OPTION.; ///; /// 'XOPTION': Removes all instances of the literal argument OPTION,; /// and the following argument.; ///; /// 'Ox': Removes all flags matching 'O' or 'O[sz0-9]' and adds 'Ox'; /// at the end of the command line.; ///; /// \param OS - The stream to write edit information to.; /// \param Args - The vector of command line arguments.; /// \param Edit - The override command to perform.; /// \param SavedStrings - Set to use for storing string representations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/driver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp:28,Energy Efficiency,efficient,efficient,28,// This does not need to be efficient.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/driver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp:28,Energy Efficiency,efficient,efficient,28,// This does not need to be efficient.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/driver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp:132,Safety,Avoid,Avoid,132,"// Put target and mode arguments at the start of argument list so that; // arguments specified in command line could override them. Avoid putting; // them at index 0, as an option like '-cc1' must remain the first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/driver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp:115,Safety,avoid,avoid,115,"// If the clang binary happens to be named cl.exe for compatibility reasons,; // use clang-cl.exe as the prefix to avoid confusion between clang and MSVC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/driver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp:85,Deployability,install,installed,85,"// Attempt to find the original path used to invoke the driver, to determine; // the installed path. We do this manually, because we want to support that; // path being a symlink.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/driver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp:15,Deployability,integrat,integrated,15,// Handle -cc1 integrated tools.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/driver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp:15,Integrability,integrat,integrated,15,// Handle -cc1 integrated tools.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/driver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp:226,Safety,safe,safe,226,"// If -canonical-prefixes is set, GetExecutablePath will have resolved Path; // to the llvm driver binary, not clang. In this case, we need to use; // PrependArg which should be clang-*. Checking just CanonicalPrefixes is; // safe even in the normal case because PrependArg will be null so; // setPrependArg will be a no-op.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/driver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp:65,Availability,error,error,65,"// If result status is < 0, then the driver command signalled an error.; // If result status is 70, then the driver command reported a fatal error.; // On Windows, abort will return an exit code of 3. In these cases,; // generate additional diagnostic information if possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/driver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp
