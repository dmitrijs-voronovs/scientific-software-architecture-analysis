id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html:24115,Testability,log,logger,24115,"ttings.debug:; new_band = sp_bandwidth(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f' %; round(old_band/new_band, 2)). _power_start = time.time(); # Get LU factors; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug and _scipy_check:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; v = lu.solve(v); v = v / la.norm(v, np.inf); it += 1; if it >= maxiter:; raise Exception('Failed to find steady state after ' +; str(maxiter) + ' iterations'). _power_end = time.time(); ss_args['info']['solution_time'] = _power_end-_power_start; ss_args['info']['iterations'] = it; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*v, np.inf); if settings.debug:; logger.debug('Number of iterations: %i' % it). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. # normalise according to type of problem; if sflag:; trow = sp.eye(rhoss.shape[0], rhoss.shape[0], format='coo'); trow = sp_reshape(trow, (1, n)); data = v / sum(trow.dot(v)); else:; data = data / la.norm(v). data = sp.csr_matrix(vec2mat(data)); rhoss.data = 0.5 * (data + data.conj().T); rhoss.isherm = True; if ss_args['return_info']:; return rhoss, ss_args['info']; else:; return rhoss. [docs]def build_preconditioner(A, c_op_list=[], **kwargs):; """"""Constructs a iLU preconditioner necessary for solving for; the steady state density matrix using the iterative linear solvers; in the 'steadystate' function. Parameters; ----------; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. use_rcm : bool, optional, def",MatchSource.WIKI,docs/3.1.0/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html
https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:21971,Availability,error,error,21971,"tore), dtype=complex); data.ss = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.noise = []; data.measurement = []. # pre-compute collapse operator combinations that are commonly needed; # when evaluating the RHS of stochastic Schrodinger equations; sso.A_ops = sso.generate_A_ops(sso.sc_ops, sso.H). map_kwargs = {'progress_bar': progress_bar}; map_kwargs.update(sso.map_kwargs). task = _ssesolve_single_trajectory; task_args = (sso,); task_kwargs = {}. results = sso.map_func(task, list(range(sso.ntraj)),; task_args, task_kwargs, **map_kwargs). for result in results:; states_list, dW, m, expect, ss = result; data.states.append(states_list); data.noise.append(dW); data.measurement.append(m); data.expect += expect; data.ss += ss. # average density matrices; if options.average_states and np.any(data.states):; data.states = [sum([ket2dm(data.states[mm][n]); for mm in range(nt)]).unit(); for n in range(len(data.times))]. # average; data.expect = data.expect / nt. # standard error; if nt > 1:; data.se = (data.ss - nt * (data.expect ** 2)) / (nt * (nt - 1)); else:; data.se = None. # convert complex data to real if hermitian; data.expect = [np.real(data.expect[n, :]); if e.isherm else data.expect[n, :]; for n, e in enumerate(sso.e_ops)]. return data. def _ssesolve_single_trajectory(n, sso):; """"""; Internal function. See ssesolve.; """"""; dt = sso.dt; times = sso.times; d1, d2 = sso.d1, sso.d2; d2_len = sso.d2_len; e_ops = sso.e_ops; H_data = sso.H.data; A_ops = sso.A_ops. expect = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); ss = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex). psi_t = sso.state0.full().ravel(); dims = sso.state0.dims. # reseed the random number generator so that forked; # processes do not get the same sequence of random numbers; np.random.seed((n+1) * np.random.randint(0, 4294967295 // (sso.ntraj+1))). if sso.noise is None:; if sso.homogeneous:; if sso.distribution == 'normal':; dW = np.sqrt(dt) * \; np.random.randn(len(A_ops), sso",MatchSource.WIKI,docs/3.1.0/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html
https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:26597,Availability,error,error,26597,"ations; sso.A_ops = sso.generate_A_ops(sso.sc_ops, sso.L.data, sso.dt). # use .data instead of Qobj ?; sso.s_e_ops = [spre(e) for e in sso.e_ops]. if sso.m_ops:; sso.s_m_ops = [[spre(m) if m else None for m in m_op]; for m_op in sso.m_ops]; else:; sso.s_m_ops = [[spre(c) for _ in range(sso.d2_len)]; for c in sso.sc_ops]. map_kwargs = {'progress_bar': progress_bar}; map_kwargs.update(sso.map_kwargs). task = _smesolve_single_trajectory; task_args = (sso,); task_kwargs = {}. results = sso.map_func(task, list(range(sso.ntraj)),; task_args, task_kwargs, **map_kwargs). for result in results:; states_list, dW, m, expect, ss = result; data.states.append(states_list); data.noise.append(dW); data.measurement.append(m); data.expect += expect; data.ss += ss. # average density matrices; if options.average_states and np.any(data.states):; data.states = [sum([data.states[mm][n] for mm in range(nt)]).unit(); for n in range(len(data.times))]. # average; data.expect = data.expect / nt. # standard error; if nt > 1:; data.se = (data.ss - nt * (data.expect ** 2)) / (nt * (nt - 1)); else:; data.se = None. # convert complex data to real if hermitian; data.expect = [np.real(data.expect[n, :]); if e.isherm else data.expect[n, :]; for n, e in enumerate(sso.e_ops)]. return data. def _smesolve_single_trajectory(n, sso):; """"""; Internal function. See smesolve.; """"""; dt = sso.dt; times = sso.times; d1, d2 = sso.d1, sso.d2; d2_len = sso.d2_len; L_data = sso.L.data; N_substeps = sso.N_substeps; N_store = sso.N_store; A_ops = sso.A_ops. rho_t = mat2vec(sso.state0.full()).ravel(); dims = sso.state0.dims. expect = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); ss = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex). # reseed the random number generator so that forked; # processes do not get the same sequence of random numbers; np.random.seed((n+1) * np.random.randint(0, 4294967295 // (sso.ntraj+1))). if sso.noise is None:; if sso.generate_noise:; dW = sso.generate_noise(len(A_ops), N_stor",MatchSource.WIKI,docs/3.1.0/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html
https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:30731,Availability,error,error,30731," data.solver = ""sepdpsolve""; data.times = sso.tlist; data.expect = np.zeros((len(sso.e_ops), N_store), dtype=complex); data.ss = np.zeros((len(sso.e_ops), N_store), dtype=complex); data.jump_times = []; data.jump_op_idx = []. # effective hamiltonian for deterministic part; Heff = sso.H; for c in sso.c_ops:; Heff += -0.5j * c.dag() * c. progress_bar.start(sso.ntraj); for n in range(sso.ntraj):; progress_bar.update(n); psi_t = sso.state0.full().ravel(). states_list, jump_times, jump_op_idx = \; _ssepdpsolve_single_trajectory(data, Heff, dt, sso.times,; N_store, N_substeps,; psi_t, sso.state0.dims,; sso.c_ops, sso.e_ops). data.states.append(states_list); data.jump_times.append(jump_times); data.jump_op_idx.append(jump_op_idx). progress_bar.finished(). # average density matrices; if options.average_states and np.any(data.states):; data.states = [sum([data.states[m][n] for m in range(nt)]).unit(); for n in range(len(data.times))]. # average; data.expect = data.expect / nt. # standard error; if nt > 1:; data.se = (data.ss - nt * (data.expect ** 2)) / (nt * (nt - 1)); else:; data.se = None. # convert complex data to real if hermitian; data.expect = [np.real(data.expect[n, :]); if e.isherm else data.expect[n, :]; for n, e in enumerate(sso.e_ops)]. return data. def _ssepdpsolve_single_trajectory(data, Heff, dt, times, N_store, N_substeps,; psi_t, dims, c_ops, e_ops):; """"""; Internal function. See ssepdpsolve.; """"""; states_list = []. phi_t = np.copy(psi_t). prng = RandomState() # todo: seed it; r_jump, r_op = prng.rand(2). jump_times = []; jump_op_idx = []. for t_idx, t in enumerate(times):. if e_ops:; for e_idx, e in enumerate(e_ops):; s = cy_expect_psi_csr(; e.data.data, e.data.indices, e.data.indptr, psi_t, 0); data.expect[e_idx, t_idx] += s; data.ss[e_idx, t_idx] += s ** 2; else:; states_list.append(Qobj(psi_t, dims=dims)). for j in range(N_substeps):. if norm(phi_t) ** 2 < r_jump:; # jump occurs; p = np.array([norm(c.data * psi_t) ** 2 for c in c_ops]); p = np.cumsum(p / ",MatchSource.WIKI,docs/3.1.0/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html
https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:33943,Availability,error,error,33943," / N_substeps; nt = sso.ntraj. data = Result(); data.solver = ""smepdpsolve""; data.times = sso.times; data.expect = np.zeros((len(sso.e_ops), N_store), dtype=complex); data.jump_times = []; data.jump_op_idx = []. # Liouvillian for the deterministic part.; # needs to be modified for TD systems; L = liouvillian(sso.H, sso.c_ops). progress_bar.start(sso.ntraj). for n in range(sso.ntraj):; progress_bar.update(n); rho_t = mat2vec(sso.rho0.full()).ravel(). states_list, jump_times, jump_op_idx = \; _smepdpsolve_single_trajectory(data, L, dt, sso.times,; N_store, N_substeps,; rho_t, sso.rho0.dims,; sso.c_ops, sso.e_ops). data.states.append(states_list); data.jump_times.append(jump_times); data.jump_op_idx.append(jump_op_idx). progress_bar.finished(). # average density matrices; if options.average_states and np.any(data.states):; data.states = [sum([data.states[m][n] for m in range(nt)]).unit(); for n in range(len(data.times))]. # average; data.expect = data.expect / sso.ntraj. # standard error; if nt > 1:; data.se = (data.ss - nt * (data.expect ** 2)) / (nt * (nt - 1)); else:; data.se = None. return data. def _smepdpsolve_single_trajectory(data, L, dt, times, N_store, N_substeps,; rho_t, dims, c_ops, e_ops):; """"""; Internal function. See smepdpsolve.; """"""; states_list = []. rho_t = np.copy(rho_t); sigma_t = np.copy(rho_t). prng = RandomState() # todo: seed it; r_jump, r_op = prng.rand(2). jump_times = []; jump_op_idx = []. for t_idx, t in enumerate(times):. if e_ops:; for e_idx, e in enumerate(e_ops):; data.expect[e_idx, t_idx] += expect_rho_vec(e, rho_t); else:; states_list.append(Qobj(vec2mat(rho_t), dims=dims)). for j in range(N_substeps):. if sigma_t.norm() < r_jump:; # jump occurs; p = np.array([expect(c.dag() * c, rho_t) for c in c_ops]); p = np.cumsum(p / np.sum(p)); n = np.where(p >= r_op)[0][0]. # apply jump; rho_t = c_ops[n] * rho_t * c_ops[n].dag(); rho_t /= expect(c_ops[n].dag() * c_ops[n], rho_t); sigma_t = np.copy(rho_t). # store info about jump; jump_times.appe",MatchSource.WIKI,docs/3.1.0/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html
https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:243,Deployability,install,installation,243,"﻿. qutip.stochastic — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.stochastic; # -*- coding: utf-8 -*-; #; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions",MatchSource.WIKI,docs/3.1.0/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html
https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:20643,Deployability,integrat,integration,20643,"n of motion according to how the d1 and d2 functions; are defined. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.SolverResult`. An instance of the class :class:`qutip.solver.SolverResult`. """"""; if debug:; logger.debug(inspect.stack()[0][3]). if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. sso = StochasticSolverOptions(H=H, state0=rho0, times=times, c_ops=c_ops,; e_ops=e_ops, **kwargs). res = _smepdpsolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}; return res. # -----------------------------------------------------------------------------; # Generic parameterized stochastic Schrodinger equation solver; #; def _ssesolve_generic(sso, options, progress_bar):; """"""; Internal function for carrying out a sse integration. Used by ssesolve.; """"""; if debug:; logger.debug(inspect.stack()[0][3]). sso.N_store = len(sso.times); sso.N_substeps = sso.nsubsteps; sso.dt = (sso.times[1] - sso.times[0]) / sso.N_substeps; nt = sso.ntraj. data = Result(); data.solver = ""ssesolve""; data.times = sso.times; data.expect = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.ss = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.noise = []; data.measurement = []. # pre-compute collapse operator combinations that are commonly needed; # when evaluating the RHS of stochastic Schrodinger equations; sso.A_ops = sso.generate_A_ops(sso.sc_ops, sso.H). map_kwargs = {'progress_bar': progress_bar}; map_kwargs.update(sso.map_kwargs). task = _ssesolve_single_trajectory; task_args = (sso,); task_kwargs = {}. results = sso.map_func(task, list(range(sso.ntraj)),; task_args, task_kwargs, **m",MatchSource.WIKI,docs/3.1.0/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html
https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:21347,Deployability,update,update,21347,"n enumerate(e_ops_dict.keys())}; return res. # -----------------------------------------------------------------------------; # Generic parameterized stochastic Schrodinger equation solver; #; def _ssesolve_generic(sso, options, progress_bar):; """"""; Internal function for carrying out a sse integration. Used by ssesolve.; """"""; if debug:; logger.debug(inspect.stack()[0][3]). sso.N_store = len(sso.times); sso.N_substeps = sso.nsubsteps; sso.dt = (sso.times[1] - sso.times[0]) / sso.N_substeps; nt = sso.ntraj. data = Result(); data.solver = ""ssesolve""; data.times = sso.times; data.expect = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.ss = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.noise = []; data.measurement = []. # pre-compute collapse operator combinations that are commonly needed; # when evaluating the RHS of stochastic Schrodinger equations; sso.A_ops = sso.generate_A_ops(sso.sc_ops, sso.H). map_kwargs = {'progress_bar': progress_bar}; map_kwargs.update(sso.map_kwargs). task = _ssesolve_single_trajectory; task_args = (sso,); task_kwargs = {}. results = sso.map_func(task, list(range(sso.ntraj)),; task_args, task_kwargs, **map_kwargs). for result in results:; states_list, dW, m, expect, ss = result; data.states.append(states_list); data.noise.append(dW); data.measurement.append(m); data.expect += expect; data.ss += ss. # average density matrices; if options.average_states and np.any(data.states):; data.states = [sum([ket2dm(data.states[mm][n]); for mm in range(nt)]).unit(); for n in range(len(data.times))]. # average; data.expect = data.expect / nt. # standard error; if nt > 1:; data.se = (data.ss - nt * (data.expect ** 2)) / (nt * (nt - 1)); else:; data.se = None. # convert complex data to real if hermitian; data.expect = [np.real(data.expect[n, :]); if e.isherm else data.expect[n, :]; for n, e in enumerate(sso.e_ops)]. return data. def _ssesolve_single_trajectory(n, sso):; """"""; Internal function. See ssesolve.; """"""; dt = sso.dt; time",MatchSource.WIKI,docs/3.1.0/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html
https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:25982,Deployability,update,update,25982,"re = len(sso.times); sso.N_substeps = sso.nsubsteps; sso.dt = (sso.times[1] - sso.times[0]) / sso.N_substeps; nt = sso.ntraj. data = Result(); data.solver = ""smesolve""; data.times = sso.times; data.expect = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.ss = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.noise = []; data.measurement = []. # Liouvillian for the deterministic part.; # needs to be modified for TD systems; sso.L = liouvillian(sso.H, sso.c_ops). # pre-compute suporoperator operator combinations that are commonly needed; # when evaluating the RHS of stochastic master equations; sso.A_ops = sso.generate_A_ops(sso.sc_ops, sso.L.data, sso.dt). # use .data instead of Qobj ?; sso.s_e_ops = [spre(e) for e in sso.e_ops]. if sso.m_ops:; sso.s_m_ops = [[spre(m) if m else None for m in m_op]; for m_op in sso.m_ops]; else:; sso.s_m_ops = [[spre(c) for _ in range(sso.d2_len)]; for c in sso.sc_ops]. map_kwargs = {'progress_bar': progress_bar}; map_kwargs.update(sso.map_kwargs). task = _smesolve_single_trajectory; task_args = (sso,); task_kwargs = {}. results = sso.map_func(task, list(range(sso.ntraj)),; task_args, task_kwargs, **map_kwargs). for result in results:; states_list, dW, m, expect, ss = result; data.states.append(states_list); data.noise.append(dW); data.measurement.append(m); data.expect += expect; data.ss += ss. # average density matrices; if options.average_states and np.any(data.states):; data.states = [sum([data.states[mm][n] for mm in range(nt)]).unit(); for n in range(len(data.times))]. # average; data.expect = data.expect / nt. # standard error; if nt > 1:; data.se = (data.ss - nt * (data.expect ** 2)) / (nt * (nt - 1)); else:; data.se = None. # convert complex data to real if hermitian; data.expect = [np.real(data.expect[n, :]); if e.isherm else data.expect[n, :]; for n, e in enumerate(sso.e_ops)]. return data. def _smesolve_single_trajectory(n, sso):; """"""; Internal function. See smesolve.; """"""; dt = sso.dt; times = sso.t",MatchSource.WIKI,docs/3.1.0/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html
https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:30147,Deployability,update,update,30147,", t_idx, :, dW_idx].sum() / (dt * N_substeps). if d2_len == 1:; measurements = measurements.squeeze(axis=(2)). return states_list, dW, measurements, expect, ss. # -----------------------------------------------------------------------------; # Generic parameterized stochastic SE PDP solver; #; def _ssepdpsolve_generic(sso, options, progress_bar):; """"""; For internal use. See ssepdpsolve.; """"""; if debug:; logger.debug(inspect.stack()[0][3]). N_store = len(sso.times); N_substeps = sso.nsubsteps; dt = (sso.times[1] - sso.times[0]) / N_substeps; nt = sso.ntraj. data = Result(); data.solver = ""sepdpsolve""; data.times = sso.tlist; data.expect = np.zeros((len(sso.e_ops), N_store), dtype=complex); data.ss = np.zeros((len(sso.e_ops), N_store), dtype=complex); data.jump_times = []; data.jump_op_idx = []. # effective hamiltonian for deterministic part; Heff = sso.H; for c in sso.c_ops:; Heff += -0.5j * c.dag() * c. progress_bar.start(sso.ntraj); for n in range(sso.ntraj):; progress_bar.update(n); psi_t = sso.state0.full().ravel(). states_list, jump_times, jump_op_idx = \; _ssepdpsolve_single_trajectory(data, Heff, dt, sso.times,; N_store, N_substeps,; psi_t, sso.state0.dims,; sso.c_ops, sso.e_ops). data.states.append(states_list); data.jump_times.append(jump_times); data.jump_op_idx.append(jump_op_idx). progress_bar.finished(). # average density matrices; if options.average_states and np.any(data.states):; data.states = [sum([data.states[m][n] for m in range(nt)]).unit(); for n in range(len(data.times))]. # average; data.expect = data.expect / nt. # standard error; if nt > 1:; data.se = (data.ss - nt * (data.expect ** 2)) / (nt * (nt - 1)); else:; data.se = None. # convert complex data to real if hermitian; data.expect = [np.real(data.expect[n, :]); if e.isherm else data.expect[n, :]; for n, e in enumerate(sso.e_ops)]. return data. def _ssepdpsolve_single_trajectory(data, Heff, dt, times, N_store, N_substeps,; psi_t, dims, c_ops, e_ops):; """"""; Internal function. See ssepdpsolve.",MatchSource.WIKI,docs/3.1.0/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html
https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:33350,Deployability,update,update,33350,"hi_t; psi_t += dpsi_t. # ensure that normalized wavefunction remains normalized; # this allows larger time step than otherwise would be possible; psi_t /= norm(psi_t). return states_list, jump_times, jump_op_idx. # -----------------------------------------------------------------------------; # Generic parameterized stochastic ME PDP solver; #; def _smepdpsolve_generic(sso, options, progress_bar):; """"""; For internal use. See smepdpsolve.; """"""; if debug:; logger.debug(inspect.stack()[0][3]). N_store = len(sso.times); N_substeps = sso.nsubsteps; dt = (sso.times[1] - sso.times[0]) / N_substeps; nt = sso.ntraj. data = Result(); data.solver = ""smepdpsolve""; data.times = sso.times; data.expect = np.zeros((len(sso.e_ops), N_store), dtype=complex); data.jump_times = []; data.jump_op_idx = []. # Liouvillian for the deterministic part.; # needs to be modified for TD systems; L = liouvillian(sso.H, sso.c_ops). progress_bar.start(sso.ntraj). for n in range(sso.ntraj):; progress_bar.update(n); rho_t = mat2vec(sso.rho0.full()).ravel(). states_list, jump_times, jump_op_idx = \; _smepdpsolve_single_trajectory(data, L, dt, sso.times,; N_store, N_substeps,; rho_t, sso.rho0.dims,; sso.c_ops, sso.e_ops). data.states.append(states_list); data.jump_times.append(jump_times); data.jump_op_idx.append(jump_op_idx). progress_bar.finished(). # average density matrices; if options.average_states and np.any(data.states):; data.states = [sum([data.states[m][n] for m in range(nt)]).unit(); for n in range(len(data.times))]. # average; data.expect = data.expect / sso.ntraj. # standard error; if nt > 1:; data.se = (data.ss - nt * (data.expect ** 2)) / (nt * (nt - 1)); else:; data.se = None. return data. def _smepdpsolve_single_trajectory(data, L, dt, times, N_store, N_substeps,; rho_t, dims, c_ops, e_ops):; """"""; Internal function. See smepdpsolve.; """"""; states_list = []. rho_t = np.copy(rho_t); sigma_t = np.copy(rho_t). prng = RandomState() # todo: seed it; r_jump, r_op = prng.rand(2). jump_times = []",MatchSource.WIKI,docs/3.1.0/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html
https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:43792,Deployability,update,update,43792,"]. def d1_rho_heterodyne(t, rho_vec, A, args):; """"""; todo: cythonize, docstrings; """"""; return spmv(A[7], rho_vec). def d2_rho_heterodyne(t, rho_vec, A, args):; """"""; todo: cythonize, docstrings; """"""; M = A[0] + A[3]; e1 = cy_expect_rho_vec(M, rho_vec, 0); d1 = spmv(M, rho_vec) - e1 * rho_vec; M = A[0] - A[3]; e1 = cy_expect_rho_vec(M, rho_vec, 0); d2 = spmv(M, rho_vec) - e1 * rho_vec; return [1.0 / np.sqrt(2) * d1, -1.0j / np.sqrt(2) * d2]. def d1_rho_photocurrent(t, rho_vec, A, args):; """"""; Todo: cythonize, add (AdA)_L + AdA_R to precomputed operators; """"""; n_sum = A[4] + A[5]; e1 = cy_expect_rho_vec(n_sum, rho_vec, 0); return 0.5 * (e1 * rho_vec - spmv(n_sum, rho_vec)). def d2_rho_photocurrent(t, rho_vec, A, args):; """"""; Todo: cythonize, add (AdA)_L + AdA_R to precomputed operators; """"""; e1 = cy_expect_rho_vec(A[6], rho_vec, 0); if e1.real > 1e-15:; return [spmv(A[6], rho_vec) / e1 - rho_vec]; else:; return [-rho_vec]. # -----------------------------------------------------------------------------; # Deterministic part of the rho/psi update functions. TODO: Make these; # compatible with qutip's time-dependent hamiltonian and collapse operators; #; def _rhs_psi_deterministic(H, psi_t, t, dt, args):; """"""; Deterministic contribution to the density matrix change; """"""; dpsi_t = (-1.0j * dt) * (H * psi_t). return dpsi_t. def _rhs_rho_deterministic(L, rho_t, t, dt, args):; """"""; Deterministic contribution to the density matrix change; """"""; drho_t = spmv(L, rho_t) * dt. return drho_t. # -----------------------------------------------------------------------------; # Euler-Maruyama rhs functions for the stochastic Schrodinger and master; # equations; #. def _rhs_psi_euler_maruyama(H, psi_t, t, A_ops, dt, dW, d1, d2, args):; """"""; Euler-Maruyama rhs function for wave function solver.; """"""; dW_len = len(dW[0, :]); dpsi_t = _rhs_psi_deterministic(H, psi_t, t, dt, args). for a_idx, A in enumerate(A_ops):; d2_vec = d2(t, psi_t, A, args); dpsi_t += d1(t, psi_t, A, args) * dt + \; np",MatchSource.WIKI,docs/3.1.0/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html
https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:46171,Deployability,update,updated,46171,"([d2_vec[n] * dW[a_idx, n]; for n in range(dW_len) if dW[a_idx, n] != 0], axis=0). return rho_t + drho_t. def _rhs_rho_euler_homodyne_fast(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; Fast Euler-Maruyama for homodyne detection.; """""". dW = ddW[:, 0]. d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2). drho_t = d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]); drho_t += (1.0 - np.inner(np.real(e), dW)) * rho_t; return drho_t. # -----------------------------------------------------------------------------; # Platen method; #; def _rhs_psi_platen(H, psi_t, t, A_ops, dt, dW, d1, d2, args):; """"""; TODO: support multiple stochastic increments. .. note::. Experimental. """""". sqrt_dt = np.sqrt(dt). dpsi_t = _rhs_psi_deterministic(H, psi_t, t, dt, args). for a_idx, A in enumerate(A_ops):; # XXX: This needs to be revised now that; # dpsi_t is the change for all stochastic collapse operators. # TODO: needs to be updated to support mutiple Weiner increments; dpsi_t_H = (-1.0j * dt) * spmv(H, psi_t). psi_t_1 = (psi_t + dpsi_t_H +; d1(A, psi_t) * dt +; d2(A, psi_t)[0] * dW[a_idx, 0]); psi_t_p = (psi_t + dpsi_t_H +; d1(A, psi_t) * dt +; d2(A, psi_t)[0] * sqrt_dt); psi_t_m = (psi_t + dpsi_t_H +; d1(A, psi_t) * dt -; d2(A, psi_t)[0] * sqrt_dt). dpsi_t += (; 0.50 * (d1(A, psi_t_1) + d1(A, psi_t)) * dt +; 0.25 * (d2(A, psi_t_p)[0] + d2(A, psi_t_m)[0] +; 2 * d2(A, psi_t)[0]) * dW[a_idx, 0] +; 0.25 * (d2(A, psi_t_p)[0] - d2(A, psi_t_m)[0]) *; (dW[a_idx, 0] ** 2 - dt) / sqrt_dt; ). return dpsi_t. # -----------------------------------------------------------------------------; # Milstein rhs functions for the stochastic master equation; #; def _rhs_rho_milstein_homodyne_single(L, rho_t, t, A_ops, dt, dW, d1, d2,; args):; """"""; .. note::. Experimental.; Milstein scheme for homodyne detection with single jump operator. """"""; A = A_ops[0]; M = A[0] + A[3]; e1 = cy_expect_rho_vec(M, rho_t, 0). d2_vec = spmv(M, rho_t); d2_vec2 = sp",MatchSource.WIKI,docs/3.1.0/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html
https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:50946,Deployability,update,updated,50946,"n, A_len) if n != m], axis=0). return rho_t + drho_t. def _rhs_rho_milstein_homodyne_single_fast(L, rho_t, t, A, dt, ddW, d1, d2,; args):; """"""; fast Milstein for homodyne detection with 1 stochastic operator; """"""; dW = ddW[:, 0]. d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). e[1] -= 2.0 * e[0] * e[0]. drho_t = (1.0 - np.inner(e, dW)) * rho_t; dW[0] -= 2.0 * e[0] * dW[1]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return drho_t. def _rhs_rho_milstein_homodyne_two_fast(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; fast Milstein for homodyne detection with 2 stochastic operators; """"""; dW = ddW[:, 0]. d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)); d_vec[-2] -= np.dot(e[:2][::-1], d_vec[:2]). e[2:4] -= 2.0 * e[:2] * e[:2]; e[4] -= 2.0 * e[1] * e[0]. drho_t = (1.0 - np.inner(e, dW)) * rho_t; dW[:2] -= 2.0 * e[:2] * dW[2:4]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return drho_t. def _rhs_rho_milstein_homodyne_fast(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; fast Milstein for homodyne detection with >2 stochastic operators; """"""; dW = ddW[:, 0]; sc_len = len(A); sc2_len = 2 * sc_len. d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(d_vec[:-1].reshape(; -1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)); d_vec[sc2_len:-1] -= np.array(; [e[m] * d_vec[n] + e[n] * d_vec[m]; for (n, m) in np.ndindex(sc_len, sc_len) if n > m]). e[sc_len:sc2_len] -= 2.0 * e[:sc_len] * e[:sc_len]; e[sc2_len:] -= 2.0 * np.array(; [e[n] * e[m] for (n, m) in np.ndindex(sc_len, sc_len) if n > m]). drho_t = (1.0 - np.inner(e, dW)) * rho_t; dW[:sc_len] -= 2.0 * e[:sc_len] * dW[sc_len:sc2_len]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return drho_t. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html
https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:10441,Integrability,depend,depending,10441,"lse np.ones(d2_len); self.state0 = state0; self.times = times; self.c_ops = c_ops; self.sc_ops = sc_ops; self.e_ops = e_ops. if m_ops is None:; self.m_ops = [[c for _ in range(d2_len)] for c in sc_ops]; else:; self.m_ops = m_ops. self.ntraj = ntraj; self.nsubsteps = nsubsteps; self.solver = solver; self.method = method; self.distribution = distribution; self.homogeneous = homogeneous; self.rhs = rhs; self.options = options; self.progress_bar = progress_bar; self.store_measurement = store_measurement; self.store_states = options.store_states; self.noise = noise; self.args = args; self.normalize = normalize. self.generate_noise = generate_noise; self.generate_A_ops = generate_A_ops. if self.ntraj > 1 and map_func:; self.map_func = map_func; else:; self.map_func = serial_map. self.map_kwargs = map_kwargs if map_kwargs is not None else {}. [docs]def ssesolve(H, psi0, times, sc_ops, e_ops, **kwargs):; """"""; Solve the stochastic Schrödinger equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian. psi0 : :class:`qutip.Qobj`; Initial state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. sc_ops : list of :class:`qutip.Qobj`; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the equation of motion according to how the d1 and d2 functions; are defined. e_ops : list of :class:`qutip.Qobj`; Single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.SolverResult`; An instance of the class :class:`qutip.solver.SolverResult`.; """"""; if debug:; logger.debug(inspect.stack()[0][3]). if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_di",MatchSource.WIKI,docs/3.1.0/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html
https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:13279,Integrability,depend,depending,13279,"())]; for idx, c in enumerate(sso.sc_ops)]. elif sso.method == 'photocurrent':; sso.d1 = d1_psi_photocurrent; sso.d2 = d2_psi_photocurrent; sso.d2_len = 1; sso.homogeneous = False; sso.distribution = 'poisson'. if ""dW_factors"" not in kwargs:; sso.dW_factors = np.array([1]); if ""m_ops"" not in kwargs:; sso.m_ops = [[None] for c in sso.sc_ops]. else:; raise Exception(""Unrecognized method '%s'."" % sso.method). if sso.distribution == 'poisson':; sso.homogeneous = False. if sso.solver == 'euler-maruyama' or sso.solver is None:; sso.rhs = _rhs_psi_euler_maruyama. elif sso.solver == 'platen':; sso.rhs = _rhs_psi_platen. else:; raise Exception(""Unrecognized solver '%s'."" % sso.solver). res = _ssesolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. [docs]def smesolve(H, rho0, times, c_ops, sc_ops, e_ops, **kwargs):; """"""; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. sc_ops : list of :class:`qutip.Qobj`; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.SolverResult`. An instance of the class :class:`",MatchSource.WIKI,docs/3.1.0/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html
https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:20643,Integrability,integrat,integration,20643,"n of motion according to how the d1 and d2 functions; are defined. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.SolverResult`. An instance of the class :class:`qutip.solver.SolverResult`. """"""; if debug:; logger.debug(inspect.stack()[0][3]). if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. sso = StochasticSolverOptions(H=H, state0=rho0, times=times, c_ops=c_ops,; e_ops=e_ops, **kwargs). res = _smepdpsolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}; return res. # -----------------------------------------------------------------------------; # Generic parameterized stochastic Schrodinger equation solver; #; def _ssesolve_generic(sso, options, progress_bar):; """"""; Internal function for carrying out a sse integration. Used by ssesolve.; """"""; if debug:; logger.debug(inspect.stack()[0][3]). sso.N_store = len(sso.times); sso.N_substeps = sso.nsubsteps; sso.dt = (sso.times[1] - sso.times[0]) / sso.N_substeps; nt = sso.ntraj. data = Result(); data.solver = ""ssesolve""; data.times = sso.times; data.expect = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.ss = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.noise = []; data.measurement = []. # pre-compute collapse operator combinations that are commonly needed; # when evaluating the RHS of stochastic Schrodinger equations; sso.A_ops = sso.generate_A_ops(sso.sc_ops, sso.H). map_kwargs = {'progress_bar': progress_bar}; map_kwargs.update(sso.map_kwargs). task = _ssesolve_single_trajectory; task_args = (sso,); task_kwargs = {}. results = sso.map_func(task, list(range(sso.ntraj)),; task_args, task_kwargs, **m",MatchSource.WIKI,docs/3.1.0/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html
https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:43859,Integrability,depend,dependent,43859,"ocstrings; """"""; M = A[0] + A[3]; e1 = cy_expect_rho_vec(M, rho_vec, 0); d1 = spmv(M, rho_vec) - e1 * rho_vec; M = A[0] - A[3]; e1 = cy_expect_rho_vec(M, rho_vec, 0); d2 = spmv(M, rho_vec) - e1 * rho_vec; return [1.0 / np.sqrt(2) * d1, -1.0j / np.sqrt(2) * d2]. def d1_rho_photocurrent(t, rho_vec, A, args):; """"""; Todo: cythonize, add (AdA)_L + AdA_R to precomputed operators; """"""; n_sum = A[4] + A[5]; e1 = cy_expect_rho_vec(n_sum, rho_vec, 0); return 0.5 * (e1 * rho_vec - spmv(n_sum, rho_vec)). def d2_rho_photocurrent(t, rho_vec, A, args):; """"""; Todo: cythonize, add (AdA)_L + AdA_R to precomputed operators; """"""; e1 = cy_expect_rho_vec(A[6], rho_vec, 0); if e1.real > 1e-15:; return [spmv(A[6], rho_vec) / e1 - rho_vec]; else:; return [-rho_vec]. # -----------------------------------------------------------------------------; # Deterministic part of the rho/psi update functions. TODO: Make these; # compatible with qutip's time-dependent hamiltonian and collapse operators; #; def _rhs_psi_deterministic(H, psi_t, t, dt, args):; """"""; Deterministic contribution to the density matrix change; """"""; dpsi_t = (-1.0j * dt) * (H * psi_t). return dpsi_t. def _rhs_rho_deterministic(L, rho_t, t, dt, args):; """"""; Deterministic contribution to the density matrix change; """"""; drho_t = spmv(L, rho_t) * dt. return drho_t. # -----------------------------------------------------------------------------; # Euler-Maruyama rhs functions for the stochastic Schrodinger and master; # equations; #. def _rhs_psi_euler_maruyama(H, psi_t, t, A_ops, dt, dW, d1, d2, args):; """"""; Euler-Maruyama rhs function for wave function solver.; """"""; dW_len = len(dW[0, :]); dpsi_t = _rhs_psi_deterministic(H, psi_t, t, dt, args). for a_idx, A in enumerate(A_ops):; d2_vec = d2(t, psi_t, A, args); dpsi_t += d1(t, psi_t, A, args) * dt + \; np.sum([d2_vec[n] * dW[a_idx, n]; for n in range(dW_len) if dW[a_idx, n] != 0], axis=0). return psi_t + dpsi_t. def _rhs_rho_euler_maruyama(L, rho_t, t, A_ops, dt, dW, d1, d2, args):; """,MatchSource.WIKI,docs/3.1.0/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html
https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:20488,Modifiability,parameteriz,parameterized,20488,"n of motion according to how the d1 and d2 functions; are defined. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.SolverResult`. An instance of the class :class:`qutip.solver.SolverResult`. """"""; if debug:; logger.debug(inspect.stack()[0][3]). if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. sso = StochasticSolverOptions(H=H, state0=rho0, times=times, c_ops=c_ops,; e_ops=e_ops, **kwargs). res = _smepdpsolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}; return res. # -----------------------------------------------------------------------------; # Generic parameterized stochastic Schrodinger equation solver; #; def _ssesolve_generic(sso, options, progress_bar):; """"""; Internal function for carrying out a sse integration. Used by ssesolve.; """"""; if debug:; logger.debug(inspect.stack()[0][3]). sso.N_store = len(sso.times); sso.N_substeps = sso.nsubsteps; sso.dt = (sso.times[1] - sso.times[0]) / sso.N_substeps; nt = sso.ntraj. data = Result(); data.solver = ""ssesolve""; data.times = sso.times; data.expect = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.ss = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.noise = []; data.measurement = []. # pre-compute collapse operator combinations that are commonly needed; # when evaluating the RHS of stochastic Schrodinger equations; sso.A_ops = sso.generate_A_ops(sso.sc_ops, sso.H). map_kwargs = {'progress_bar': progress_bar}; map_kwargs.update(sso.map_kwargs). task = _ssesolve_single_trajectory; task_args = (sso,); task_kwargs = {}. results = sso.map_func(task, list(range(sso.ntraj)),; task_args, task_kwargs, **m",MatchSource.WIKI,docs/3.1.0/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html
https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:24782,Modifiability,parameteriz,parameterized,24782,"ops):; # dw_expect = norm(spmv(A[0], psi_t)) ** 2 * dt; dw_expect = cy_expect_psi_csr(A[3].data,; A[3].indices,; A[3].indptr, psi_t, 1) * dt; dW[a_idx, t_idx, j, :] = np.random.poisson(dw_expect,; d2_len). psi_t = sso.rhs(H_data, psi_t, t + dt * j,; A_ops, dt, dW[:, t_idx, j, :], d1, d2, sso.args). # optionally renormalize the wave function; if sso.normalize:; psi_t /= norm(psi_t). if sso.store_measurement:; for m_idx, m in enumerate(sso.m_ops):; for dW_idx, dW_factor in enumerate(sso.dW_factors):; if m[dW_idx]:; m_data = m[dW_idx].data; m_expt = cy_expect_psi_csr(m_data.data,; m_data.indices,; m_data.indptr,; psi_t, 0); else:; m_expt = 0; mm = (m_expt + dW_factor *; dW[m_idx, t_idx, :, dW_idx].sum() /; (dt * sso.N_substeps)); measurements[t_idx, m_idx, dW_idx] = mm. if d2_len == 1:; measurements = measurements.squeeze(axis=(2)). return states_list, dW, measurements, expect, ss. # -----------------------------------------------------------------------------; # Generic parameterized stochastic master equation solver; #; def _smesolve_generic(sso, options, progress_bar):; """"""; Internal function. See smesolve.; """"""; if debug:; logger.debug(inspect.stack()[0][3]). sso.N_store = len(sso.times); sso.N_substeps = sso.nsubsteps; sso.dt = (sso.times[1] - sso.times[0]) / sso.N_substeps; nt = sso.ntraj. data = Result(); data.solver = ""smesolve""; data.times = sso.times; data.expect = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.ss = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.noise = []; data.measurement = []. # Liouvillian for the deterministic part.; # needs to be modified for TD systems; sso.L = liouvillian(sso.H, sso.c_ops). # pre-compute suporoperator operator combinations that are commonly needed; # when evaluating the RHS of stochastic master equations; sso.A_ops = sso.generate_A_ops(sso.sc_ops, sso.L.data, sso.dt). # use .data instead of Qobj ?; sso.s_e_ops = [spre(e) for e in sso.e_ops]. if sso.m_ops:; sso.s_m_ops = [[spre(m) if m else N",MatchSource.WIKI,docs/3.1.0/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html
https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:29410,Modifiability,parameteriz,parameterized,29410,"d(Qobj(vec2mat(rho_t), dims=dims)). rho_prev = np.copy(rho_t). for j in range(N_substeps):. if sso.noise is None and not sso.homogeneous:; for a_idx, A in enumerate(A_ops):; dw_expect = cy_expect_rho_vec(A[4], rho_t, 1) * dt; if dw_expect > 0:; dW[a_idx, t_idx, j, :] = np.random.poisson(dw_expect,; d2_len); else:; dW[a_idx, t_idx, j, :] = np.zeros(d2_len). rho_t = sso.rhs(L_data, rho_t, t + dt * j,; A_ops, dt, dW[:, t_idx, j, :], d1, d2, sso.args). if sso.store_measurement:; for m_idx, m in enumerate(sso.s_m_ops):; for dW_idx, dW_factor in enumerate(sso.dW_factors):; if m[dW_idx]:; m_expt = cy_expect_rho_vec(m[dW_idx].data, rho_prev, 0); else:; m_expt = 0; measurements[t_idx, m_idx, dW_idx] = m_expt + dW_factor * \; dW[m_idx, t_idx, :, dW_idx].sum() / (dt * N_substeps). if d2_len == 1:; measurements = measurements.squeeze(axis=(2)). return states_list, dW, measurements, expect, ss. # -----------------------------------------------------------------------------; # Generic parameterized stochastic SE PDP solver; #; def _ssepdpsolve_generic(sso, options, progress_bar):; """"""; For internal use. See ssepdpsolve.; """"""; if debug:; logger.debug(inspect.stack()[0][3]). N_store = len(sso.times); N_substeps = sso.nsubsteps; dt = (sso.times[1] - sso.times[0]) / N_substeps; nt = sso.ntraj. data = Result(); data.solver = ""sepdpsolve""; data.times = sso.tlist; data.expect = np.zeros((len(sso.e_ops), N_store), dtype=complex); data.ss = np.zeros((len(sso.e_ops), N_store), dtype=complex); data.jump_times = []; data.jump_op_idx = []. # effective hamiltonian for deterministic part; Heff = sso.H; for c in sso.c_ops:; Heff += -0.5j * c.dag() * c. progress_bar.start(sso.ntraj); for n in range(sso.ntraj):; progress_bar.update(n); psi_t = sso.state0.full().ravel(). states_list, jump_times, jump_op_idx = \; _ssepdpsolve_single_trajectory(data, Heff, dt, sso.times,; N_store, N_substeps,; psi_t, sso.state0.dims,; sso.c_ops, sso.e_ops). data.states.append(states_list); data.jump_times.append(jump",MatchSource.WIKI,docs/3.1.0/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html
https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:32669,Modifiability,parameteriz,parameterized,32669,"ata * psi_t) ** 2 for c in c_ops]); p = np.cumsum(p / np.sum(p)); n = np.where(p >= r_op)[0][0]. # apply jump; psi_t = c_ops[n].data * psi_t; psi_t /= norm(psi_t); phi_t = np.copy(psi_t). # store info about jump; jump_times.append(times[t_idx] + dt * j); jump_op_idx.append(n). # get new random numbers for next jump; r_jump, r_op = prng.rand(2). # deterministic evolution wihtout correction for norm decay; dphi_t = (-1.0j * dt) * (Heff.data * phi_t). # deterministic evolution with correction for norm decay; dpsi_t = (-1.0j * dt) * (Heff.data * psi_t); A = 0.5 * np.sum([norm(c.data * psi_t) ** 2 for c in c_ops]); dpsi_t += dt * A * psi_t. # increment wavefunctions; phi_t += dphi_t; psi_t += dpsi_t. # ensure that normalized wavefunction remains normalized; # this allows larger time step than otherwise would be possible; psi_t /= norm(psi_t). return states_list, jump_times, jump_op_idx. # -----------------------------------------------------------------------------; # Generic parameterized stochastic ME PDP solver; #; def _smepdpsolve_generic(sso, options, progress_bar):; """"""; For internal use. See smepdpsolve.; """"""; if debug:; logger.debug(inspect.stack()[0][3]). N_store = len(sso.times); N_substeps = sso.nsubsteps; dt = (sso.times[1] - sso.times[0]) / N_substeps; nt = sso.ntraj. data = Result(); data.solver = ""smepdpsolve""; data.times = sso.times; data.expect = np.zeros((len(sso.e_ops), N_store), dtype=complex); data.jump_times = []; data.jump_op_idx = []. # Liouvillian for the deterministic part.; # needs to be modified for TD systems; L = liouvillian(sso.H, sso.c_ops). progress_bar.start(sso.ntraj). for n in range(sso.ntraj):; progress_bar.update(n); rho_t = mat2vec(sso.rho0.full()).ravel(). states_list, jump_times, jump_op_idx = \; _smepdpsolve_single_trajectory(data, L, dt, sso.times,; N_store, N_substeps,; rho_t, sso.rho0.dims,; sso.c_ops, sso.e_ops). data.states.append(states_list); data.jump_times.append(jump_times); data.jump_op_idx.append(jump_op_idx). progres",MatchSource.WIKI,docs/3.1.0/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html
https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:3601,Performance,optimiz,optimizing,3601,"ARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; #; # Significant parts of this code were contributed by Denis Vasilyev.; #; ###############################################################################; """"""; This module contains functions for solving stochastic schrodinger and master; equations. The API should not be considered stable, and is subject to change; when we work more on optimizing this module for performance and features.; """""". __all__ = ['ssesolve', 'ssepdpsolve', 'smesolve', 'smepdpsolve']. import numpy as np; import scipy.sparse as sp; from scipy.linalg.blas import get_blas_funcs; try:; norm = get_blas_funcs(""znrm2"", dtype=np.float64); except:; from scipy.linalg import norm. from numpy.random import RandomState. from qutip.qobj import Qobj, isket; from qutip.states import ket2dm; from qutip.solver import Result; from qutip.expect import expect, expect_rho_vec; from qutip.superoperator import (spre, spost, mat2vec, vec2mat,; liouvillian, lindblad_dissipator); from qutip.cy.spmatfuncs import cy_expect_psi_csr, spmv, cy_expect_rho_vec; from qutip.cy.stochastic import (cy_d1_rho_photocurrent,; cy_d2_rho_photocurrent); from qutip.parallel import serial_map; from qutip.ui.progressbar import TextProgressBar; from qutip.solver import Options; from qutip.settings import debug. if debug:; import qutip.logging; import inspect; logger = qutip",MatchSource.WIKI,docs/3.1.0/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html
https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:3628,Performance,perform,performance,3628,"ARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; #; # Significant parts of this code were contributed by Denis Vasilyev.; #; ###############################################################################; """"""; This module contains functions for solving stochastic schrodinger and master; equations. The API should not be considered stable, and is subject to change; when we work more on optimizing this module for performance and features.; """""". __all__ = ['ssesolve', 'ssepdpsolve', 'smesolve', 'smepdpsolve']. import numpy as np; import scipy.sparse as sp; from scipy.linalg.blas import get_blas_funcs; try:; norm = get_blas_funcs(""znrm2"", dtype=np.float64); except:; from scipy.linalg import norm. from numpy.random import RandomState. from qutip.qobj import Qobj, isket; from qutip.states import ket2dm; from qutip.solver import Result; from qutip.expect import expect, expect_rho_vec; from qutip.superoperator import (spre, spost, mat2vec, vec2mat,; liouvillian, lindblad_dissipator); from qutip.cy.spmatfuncs import cy_expect_psi_csr, spmv, cy_expect_rho_vec; from qutip.cy.stochastic import (cy_d1_rho_photocurrent,; cy_d2_rho_photocurrent); from qutip.parallel import serial_map; from qutip.ui.progressbar import TextProgressBar; from qutip.solver import Options; from qutip.settings import debug. if debug:; import qutip.logging; import inspect; logger = qutip",MatchSource.WIKI,docs/3.1.0/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html
https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:47727,Performance,optimiz,optimizations,47727,"urn dpsi_t. # -----------------------------------------------------------------------------; # Milstein rhs functions for the stochastic master equation; #; def _rhs_rho_milstein_homodyne_single(L, rho_t, t, A_ops, dt, dW, d1, d2,; args):; """"""; .. note::. Experimental.; Milstein scheme for homodyne detection with single jump operator. """"""; A = A_ops[0]; M = A[0] + A[3]; e1 = cy_expect_rho_vec(M, rho_t, 0). d2_vec = spmv(M, rho_t); d2_vec2 = spmv(M, d2_vec); e2 = cy_expect_rho_vec(M, d2_vec, 0). drho_t = _rhs_rho_deterministic(L, rho_t, t, dt, args); drho_t += spmv(A[7], rho_t) * dt; drho_t += (d2_vec - e1 * rho_t) * dW[0, 0]; drho_t += 0.5 * (d2_vec2 - 2 * e1 * d2_vec + (-e2 + 2 * e1 * e1) *; rho_t) * (dW[0, 0] * dW[0, 0] - dt); return rho_t + drho_t. def _rhs_rho_milstein_homodyne(L, rho_t, t, A_ops, dt, dW, d1, d2, args):; """"""; .. note::. Experimental.; Milstein scheme for homodyne detection.; This implementation works for commuting stochastic jump operators.; TODO: optimizations: do calculation for n>m only. """"""; A_len = len(A_ops). M = np.array([A_ops[n][0] + A_ops[n][3] for n in range(A_len)]); e1 = np.array([cy_expect_rho_vec(M[n], rho_t, 0) for n in range(A_len)]). d1_vec = np.sum([spmv(A_ops[n][7], rho_t); for n in range(A_len)], axis=0). d2_vec = np.array([spmv(M[n], rho_t); for n in range(A_len)]). # This calculation is suboptimal. We need only values for m>n in case of; # commuting jump operators.; d2_vec2 = np.array([[spmv(M[n], d2_vec[m]); for m in range(A_len)] for n in range(A_len)]); e2 = np.array([[cy_expect_rho_vec(M[n], d2_vec[m], 0); for m in range(A_len)] for n in range(A_len)]). drho_t = _rhs_rho_deterministic(L, rho_t, t, dt, args); drho_t += d1_vec * dt; drho_t += np.sum([(d2_vec[n] - e1[n] * rho_t) * dW[n, 0]; for n in range(A_len)], axis=0); drho_t += 0.5 * np.sum(; [(d2_vec2[n, n] - 2.0 * e1[n] * d2_vec[n] +; (-e2[n, n] + 2.0 * e1[n] * e1[n]) * rho_t) * (dW[n, 0]*dW[n, 0] - dt); for n in range(A_len)], axis=0). # This calculation is subopti",MatchSource.WIKI,docs/3.1.0/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html
https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:36066,Safety,avoid,avoid,36066,"jump; r_jump, r_op = prng.rand(2). # deterministic evolution wihtout correction for norm decay; dsigma_t = spmv(L.data, sigma_t) * dt. # deterministic evolution with correction for norm decay; drho_t = spmv(L.data, rho_t) * dt. rho_t += drho_t. # increment density matrices; sigma_t += dsigma_t; rho_t += drho_t. return states_list, jump_times, jump_op_idx. # -----------------------------------------------------------------------------; # Helper-functions for stochastic DE; #; # d1 = deterministic part of the contribution to the DE RHS function, to be; # multiplied by the increament dt; #; # d1 = stochastic part of the contribution to the DE RHS function, to be; # multiplied by the increament dW; #. #; # For SSE; #. # Function sigurature:; #; # def d(A, psi):; #; # psi = wave function at the current time step; #; # A[0] = c; # A[1] = c + c.dag(); # A[2] = c - c.dag(); # A[3] = c.dag() * c; #; # where c is a collapse operator. The combinations of c's stored in A are; # precomputed before the time-evolution is started to avoid repeated; # computations. def _generate_psi_A_ops(sc_ops, H):; """"""; pre-compute superoperator operator combinations that are commonly needed; when evaluating the RHS of stochastic schrodinger equations; """""". A_ops = []; for c_idx, c in enumerate(sc_ops):; A_ops.append([c.data,; (c + c.dag()).data,; (c - c.dag()).data,; (c.dag() * c).data]). return A_ops. def d1_psi_homodyne(t, psi, A, args):; """"""; OK; Todo: cythonize. .. math::. D_1(C, \psi) = \\frac{1}{2}(\\langle C + C^\\dagger\\rangle\\C psi -; C^\\dagger C\\psi - \\frac{1}{4}\\langle C + C^\\dagger\\rangle^2\\psi). """""". e1 = cy_expect_psi_csr(A[1].data, A[1].indices, A[1].indptr, psi, 0); return 0.5 * (e1 * spmv(A[0], psi) -; spmv(A[3], psi) -; 0.25 * e1 ** 2 * psi). def d2_psi_homodyne(t, psi, A, args):; """"""; OK; Todo: cythonize. .. math::. D_2(\psi, t) = (C - \\frac{1}{2}\\langle C + C^\\dagger\\rangle)\\psi. """""". e1 = cy_expect_psi_csr(A[1].data, A[1].indices, A[1].indptr, psi, 0); return [s",MatchSource.WIKI,docs/3.1.0/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html
https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:45409,Safety,detect,detection,45409,"r the stochastic Schrodinger and master; # equations; #. def _rhs_psi_euler_maruyama(H, psi_t, t, A_ops, dt, dW, d1, d2, args):; """"""; Euler-Maruyama rhs function for wave function solver.; """"""; dW_len = len(dW[0, :]); dpsi_t = _rhs_psi_deterministic(H, psi_t, t, dt, args). for a_idx, A in enumerate(A_ops):; d2_vec = d2(t, psi_t, A, args); dpsi_t += d1(t, psi_t, A, args) * dt + \; np.sum([d2_vec[n] * dW[a_idx, n]; for n in range(dW_len) if dW[a_idx, n] != 0], axis=0). return psi_t + dpsi_t. def _rhs_rho_euler_maruyama(L, rho_t, t, A_ops, dt, dW, d1, d2, args):; """"""; Euler-Maruyama rhs function for density matrix solver.; """"""; dW_len = len(dW[0, :]). drho_t = _rhs_rho_deterministic(L, rho_t, t, dt, args). for a_idx, A in enumerate(A_ops):; d2_vec = d2(t, rho_t, A, args); drho_t += d1(t, rho_t, A, args) * dt; drho_t += np.sum([d2_vec[n] * dW[a_idx, n]; for n in range(dW_len) if dW[a_idx, n] != 0], axis=0). return rho_t + drho_t. def _rhs_rho_euler_homodyne_fast(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; Fast Euler-Maruyama for homodyne detection.; """""". dW = ddW[:, 0]. d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2). drho_t = d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]); drho_t += (1.0 - np.inner(np.real(e), dW)) * rho_t; return drho_t. # -----------------------------------------------------------------------------; # Platen method; #; def _rhs_psi_platen(H, psi_t, t, A_ops, dt, dW, d1, d2, args):; """"""; TODO: support multiple stochastic increments. .. note::. Experimental. """""". sqrt_dt = np.sqrt(dt). dpsi_t = _rhs_psi_deterministic(H, psi_t, t, dt, args). for a_idx, A in enumerate(A_ops):; # XXX: This needs to be revised now that; # dpsi_t is the change for all stochastic collapse operators. # TODO: needs to be updated to support mutiple Weiner increments; dpsi_t_H = (-1.0j * dt) * spmv(H, psi_t). psi_t_1 = (psi_t + dpsi_t_H +; d1(A, psi_t) * dt +; d2(A, psi_t)[0] * dW[a_idx, 0]); psi_t_p = (psi",MatchSource.WIKI,docs/3.1.0/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html
https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:47044,Safety,detect,detection,47044," # XXX: This needs to be revised now that; # dpsi_t is the change for all stochastic collapse operators. # TODO: needs to be updated to support mutiple Weiner increments; dpsi_t_H = (-1.0j * dt) * spmv(H, psi_t). psi_t_1 = (psi_t + dpsi_t_H +; d1(A, psi_t) * dt +; d2(A, psi_t)[0] * dW[a_idx, 0]); psi_t_p = (psi_t + dpsi_t_H +; d1(A, psi_t) * dt +; d2(A, psi_t)[0] * sqrt_dt); psi_t_m = (psi_t + dpsi_t_H +; d1(A, psi_t) * dt -; d2(A, psi_t)[0] * sqrt_dt). dpsi_t += (; 0.50 * (d1(A, psi_t_1) + d1(A, psi_t)) * dt +; 0.25 * (d2(A, psi_t_p)[0] + d2(A, psi_t_m)[0] +; 2 * d2(A, psi_t)[0]) * dW[a_idx, 0] +; 0.25 * (d2(A, psi_t_p)[0] - d2(A, psi_t_m)[0]) *; (dW[a_idx, 0] ** 2 - dt) / sqrt_dt; ). return dpsi_t. # -----------------------------------------------------------------------------; # Milstein rhs functions for the stochastic master equation; #; def _rhs_rho_milstein_homodyne_single(L, rho_t, t, A_ops, dt, dW, d1, d2,; args):; """"""; .. note::. Experimental.; Milstein scheme for homodyne detection with single jump operator. """"""; A = A_ops[0]; M = A[0] + A[3]; e1 = cy_expect_rho_vec(M, rho_t, 0). d2_vec = spmv(M, rho_t); d2_vec2 = spmv(M, d2_vec); e2 = cy_expect_rho_vec(M, d2_vec, 0). drho_t = _rhs_rho_deterministic(L, rho_t, t, dt, args); drho_t += spmv(A[7], rho_t) * dt; drho_t += (d2_vec - e1 * rho_t) * dW[0, 0]; drho_t += 0.5 * (d2_vec2 - 2 * e1 * d2_vec + (-e2 + 2 * e1 * e1) *; rho_t) * (dW[0, 0] * dW[0, 0] - dt); return rho_t + drho_t. def _rhs_rho_milstein_homodyne(L, rho_t, t, A_ops, dt, dW, d1, d2, args):; """"""; .. note::. Experimental.; Milstein scheme for homodyne detection.; This implementation works for commuting stochastic jump operators.; TODO: optimizations: do calculation for n>m only. """"""; A_len = len(A_ops). M = np.array([A_ops[n][0] + A_ops[n][3] for n in range(A_len)]); e1 = np.array([cy_expect_rho_vec(M[n], rho_t, 0) for n in range(A_len)]). d1_vec = np.sum([spmv(A_ops[n][7], rho_t); for n in range(A_len)], axis=0). d2_vec = np.array([spmv(M[n], rho_t)",MatchSource.WIKI,docs/3.1.0/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html
https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:47641,Safety,detect,detection,47641,"0]) * dW[a_idx, 0] +; 0.25 * (d2(A, psi_t_p)[0] - d2(A, psi_t_m)[0]) *; (dW[a_idx, 0] ** 2 - dt) / sqrt_dt; ). return dpsi_t. # -----------------------------------------------------------------------------; # Milstein rhs functions for the stochastic master equation; #; def _rhs_rho_milstein_homodyne_single(L, rho_t, t, A_ops, dt, dW, d1, d2,; args):; """"""; .. note::. Experimental.; Milstein scheme for homodyne detection with single jump operator. """"""; A = A_ops[0]; M = A[0] + A[3]; e1 = cy_expect_rho_vec(M, rho_t, 0). d2_vec = spmv(M, rho_t); d2_vec2 = spmv(M, d2_vec); e2 = cy_expect_rho_vec(M, d2_vec, 0). drho_t = _rhs_rho_deterministic(L, rho_t, t, dt, args); drho_t += spmv(A[7], rho_t) * dt; drho_t += (d2_vec - e1 * rho_t) * dW[0, 0]; drho_t += 0.5 * (d2_vec2 - 2 * e1 * d2_vec + (-e2 + 2 * e1 * e1) *; rho_t) * (dW[0, 0] * dW[0, 0] - dt); return rho_t + drho_t. def _rhs_rho_milstein_homodyne(L, rho_t, t, A_ops, dt, dW, d1, d2, args):; """"""; .. note::. Experimental.; Milstein scheme for homodyne detection.; This implementation works for commuting stochastic jump operators.; TODO: optimizations: do calculation for n>m only. """"""; A_len = len(A_ops). M = np.array([A_ops[n][0] + A_ops[n][3] for n in range(A_len)]); e1 = np.array([cy_expect_rho_vec(M[n], rho_t, 0) for n in range(A_len)]). d1_vec = np.sum([spmv(A_ops[n][7], rho_t); for n in range(A_len)], axis=0). d2_vec = np.array([spmv(M[n], rho_t); for n in range(A_len)]). # This calculation is suboptimal. We need only values for m>n in case of; # commuting jump operators.; d2_vec2 = np.array([[spmv(M[n], d2_vec[m]); for m in range(A_len)] for n in range(A_len)]); e2 = np.array([[cy_expect_rho_vec(M[n], d2_vec[m], 0); for m in range(A_len)] for n in range(A_len)]). drho_t = _rhs_rho_deterministic(L, rho_t, t, dt, args); drho_t += d1_vec * dt; drho_t += np.sum([(d2_vec[n] - e1[n] * rho_t) * dW[n, 0]; for n in range(A_len)], axis=0); drho_t += 0.5 * np.sum(; [(d2_vec2[n, n] - 2.0 * e1[n] * d2_vec[n] +; (-e2[n, n] + 2.0 * ",MatchSource.WIKI,docs/3.1.0/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html
https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:49171,Safety,detect,detection,49171,"se of; # commuting jump operators.; d2_vec2 = np.array([[spmv(M[n], d2_vec[m]); for m in range(A_len)] for n in range(A_len)]); e2 = np.array([[cy_expect_rho_vec(M[n], d2_vec[m], 0); for m in range(A_len)] for n in range(A_len)]). drho_t = _rhs_rho_deterministic(L, rho_t, t, dt, args); drho_t += d1_vec * dt; drho_t += np.sum([(d2_vec[n] - e1[n] * rho_t) * dW[n, 0]; for n in range(A_len)], axis=0); drho_t += 0.5 * np.sum(; [(d2_vec2[n, n] - 2.0 * e1[n] * d2_vec[n] +; (-e2[n, n] + 2.0 * e1[n] * e1[n]) * rho_t) * (dW[n, 0]*dW[n, 0] - dt); for n in range(A_len)], axis=0). # This calculation is suboptimal. We need only values for m>n in case of; # commuting jump operators.; drho_t += 0.5 * np.sum(; [(d2_vec2[n, m] - e1[m] * d2_vec[n] - e1[n] * d2_vec[m] +; (-e2[n, m] + 2.0 * e1[n] * e1[m]) * rho_t) * (dW[n, 0] * dW[m, 0]); for (n, m) in np.ndindex(A_len, A_len) if n != m], axis=0). return rho_t + drho_t. def _rhs_rho_milstein_homodyne_single_fast(L, rho_t, t, A, dt, ddW, d1, d2,; args):; """"""; fast Milstein for homodyne detection with 1 stochastic operator; """"""; dW = ddW[:, 0]. d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). e[1] -= 2.0 * e[0] * e[0]. drho_t = (1.0 - np.inner(e, dW)) * rho_t; dW[0] -= 2.0 * e[0] * dW[1]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return drho_t. def _rhs_rho_milstein_homodyne_two_fast(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; fast Milstein for homodyne detection with 2 stochastic operators; """"""; dW = ddW[:, 0]. d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)); d_vec[-2] -= np.dot(e[:2][::-1], d_vec[:2]). e[2:4] -= 2.0 * e[:2] * e[:2]; e[4] -= 2.0 * e[1] * e[0]. drho_t = (1.0 - np.inner(e, dW)) * rho_t; dW[:2] -= 2.0 * e[:2] * dW[2:4]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return drho_t. def _rhs_rho_milstein_homodyne_fast(L, rho_t, t, A, ",MatchSource.WIKI,docs/3.1.0/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html
https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:49646,Safety,detect,detection,49646,", n] + 2.0 * e1[n] * e1[n]) * rho_t) * (dW[n, 0]*dW[n, 0] - dt); for n in range(A_len)], axis=0). # This calculation is suboptimal. We need only values for m>n in case of; # commuting jump operators.; drho_t += 0.5 * np.sum(; [(d2_vec2[n, m] - e1[m] * d2_vec[n] - e1[n] * d2_vec[m] +; (-e2[n, m] + 2.0 * e1[n] * e1[m]) * rho_t) * (dW[n, 0] * dW[m, 0]); for (n, m) in np.ndindex(A_len, A_len) if n != m], axis=0). return rho_t + drho_t. def _rhs_rho_milstein_homodyne_single_fast(L, rho_t, t, A, dt, ddW, d1, d2,; args):; """"""; fast Milstein for homodyne detection with 1 stochastic operator; """"""; dW = ddW[:, 0]. d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). e[1] -= 2.0 * e[0] * e[0]. drho_t = (1.0 - np.inner(e, dW)) * rho_t; dW[0] -= 2.0 * e[0] * dW[1]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return drho_t. def _rhs_rho_milstein_homodyne_two_fast(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; fast Milstein for homodyne detection with 2 stochastic operators; """"""; dW = ddW[:, 0]. d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)); d_vec[-2] -= np.dot(e[:2][::-1], d_vec[:2]). e[2:4] -= 2.0 * e[:2] * e[:2]; e[4] -= 2.0 * e[1] * e[0]. drho_t = (1.0 - np.inner(e, dW)) * rho_t; dW[:2] -= 2.0 * e[:2] * dW[2:4]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return drho_t. def _rhs_rho_milstein_homodyne_fast(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; fast Milstein for homodyne detection with >2 stochastic operators; """"""; dW = ddW[:, 0]; sc_len = len(A); sc2_len = 2 * sc_len. d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(d_vec[:-1].reshape(; -1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)); d_vec[sc2_len:-1] -= np.array(; [e[m] * d_vec[n] + e[n] * d_vec[m]; for (n, m) in np.ndindex(sc_len, sc_len) if n > m]). e[sc_len:sc2_len] -= 2.0 * e[:sc_len] * e[:sc_len]; e[sc2_len:] -",MatchSource.WIKI,docs/3.1.0/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html
https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:50198,Safety,detect,detection,50198,"n, A_len) if n != m], axis=0). return rho_t + drho_t. def _rhs_rho_milstein_homodyne_single_fast(L, rho_t, t, A, dt, ddW, d1, d2,; args):; """"""; fast Milstein for homodyne detection with 1 stochastic operator; """"""; dW = ddW[:, 0]. d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). e[1] -= 2.0 * e[0] * e[0]. drho_t = (1.0 - np.inner(e, dW)) * rho_t; dW[0] -= 2.0 * e[0] * dW[1]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return drho_t. def _rhs_rho_milstein_homodyne_two_fast(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; fast Milstein for homodyne detection with 2 stochastic operators; """"""; dW = ddW[:, 0]. d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)); d_vec[-2] -= np.dot(e[:2][::-1], d_vec[:2]). e[2:4] -= 2.0 * e[:2] * e[:2]; e[4] -= 2.0 * e[1] * e[0]. drho_t = (1.0 - np.inner(e, dW)) * rho_t; dW[:2] -= 2.0 * e[:2] * dW[2:4]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return drho_t. def _rhs_rho_milstein_homodyne_fast(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; fast Milstein for homodyne detection with >2 stochastic operators; """"""; dW = ddW[:, 0]; sc_len = len(A); sc2_len = 2 * sc_len. d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(d_vec[:-1].reshape(; -1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)); d_vec[sc2_len:-1] -= np.array(; [e[m] * d_vec[n] + e[n] * d_vec[m]; for (n, m) in np.ndindex(sc_len, sc_len) if n > m]). e[sc_len:sc2_len] -= 2.0 * e[:sc_len] * e[:sc_len]; e[sc2_len:] -= 2.0 * np.array(; [e[n] * e[m] for (n, m) in np.ndindex(sc_len, sc_len) if n > m]). drho_t = (1.0 - np.inner(e, dW)) * rho_t; dW[:sc_len] -= 2.0 * e[:sc_len] * dW[sc_len:sc2_len]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return drho_t. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html
https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:4544,Testability,log,logging,4544,"ject to change; when we work more on optimizing this module for performance and features.; """""". __all__ = ['ssesolve', 'ssepdpsolve', 'smesolve', 'smepdpsolve']. import numpy as np; import scipy.sparse as sp; from scipy.linalg.blas import get_blas_funcs; try:; norm = get_blas_funcs(""znrm2"", dtype=np.float64); except:; from scipy.linalg import norm. from numpy.random import RandomState. from qutip.qobj import Qobj, isket; from qutip.states import ket2dm; from qutip.solver import Result; from qutip.expect import expect, expect_rho_vec; from qutip.superoperator import (spre, spost, mat2vec, vec2mat,; liouvillian, lindblad_dissipator); from qutip.cy.spmatfuncs import cy_expect_psi_csr, spmv, cy_expect_rho_vec; from qutip.cy.stochastic import (cy_d1_rho_photocurrent,; cy_d2_rho_photocurrent); from qutip.parallel import serial_map; from qutip.ui.progressbar import TextProgressBar; from qutip.solver import Options; from qutip.settings import debug. if debug:; import qutip.logging; import inspect; logger = qutip.logging.get_logger(). [docs]class StochasticSolverOptions:; """"""Class of options for stochastic solvers such as; :func:`qutip.stochastic.ssesolve`, :func:`qutip.stochastic.smesolve`, etc.; Options can be specified either as arguments to the constructor::. sso = StochasticSolverOptions(nsubsteps=100, ...). or by changing the class attributes after creation::. sso = StochasticSolverOptions(); sso.nsubsteps = 1000. The stochastic solvers :func:`qutip.stochastic.ssesolve`,; :func:`qutip.stochastic.smesolve`, :func:`qutip.stochastic.ssepdpsolve` and; :func:`qutip.stochastic.smepdpsolve` all take the same keyword arguments as; the constructor of these class, and internally they use these arguments to; construct an instance of this class, so it is rarely needed to explicitly; create an instance of this class. Attributes; ----------. H : :class:`qutip.Qobj`; System Hamiltonian. state0 : :class:`qutip.Qobj`; Initial state vector (ket) or density matrix. times : *list* / *arra",MatchSource.WIKI,docs/3.1.0/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html
https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:4569,Testability,log,logger,4569,"ject to change; when we work more on optimizing this module for performance and features.; """""". __all__ = ['ssesolve', 'ssepdpsolve', 'smesolve', 'smepdpsolve']. import numpy as np; import scipy.sparse as sp; from scipy.linalg.blas import get_blas_funcs; try:; norm = get_blas_funcs(""znrm2"", dtype=np.float64); except:; from scipy.linalg import norm. from numpy.random import RandomState. from qutip.qobj import Qobj, isket; from qutip.states import ket2dm; from qutip.solver import Result; from qutip.expect import expect, expect_rho_vec; from qutip.superoperator import (spre, spost, mat2vec, vec2mat,; liouvillian, lindblad_dissipator); from qutip.cy.spmatfuncs import cy_expect_psi_csr, spmv, cy_expect_rho_vec; from qutip.cy.stochastic import (cy_d1_rho_photocurrent,; cy_d2_rho_photocurrent); from qutip.parallel import serial_map; from qutip.ui.progressbar import TextProgressBar; from qutip.solver import Options; from qutip.settings import debug. if debug:; import qutip.logging; import inspect; logger = qutip.logging.get_logger(). [docs]class StochasticSolverOptions:; """"""Class of options for stochastic solvers such as; :func:`qutip.stochastic.ssesolve`, :func:`qutip.stochastic.smesolve`, etc.; Options can be specified either as arguments to the constructor::. sso = StochasticSolverOptions(nsubsteps=100, ...). or by changing the class attributes after creation::. sso = StochasticSolverOptions(); sso.nsubsteps = 1000. The stochastic solvers :func:`qutip.stochastic.ssesolve`,; :func:`qutip.stochastic.smesolve`, :func:`qutip.stochastic.ssepdpsolve` and; :func:`qutip.stochastic.smepdpsolve` all take the same keyword arguments as; the constructor of these class, and internally they use these arguments to; construct an instance of this class, so it is rarely needed to explicitly; create an instance of this class. Attributes; ----------. H : :class:`qutip.Qobj`; System Hamiltonian. state0 : :class:`qutip.Qobj`; Initial state vector (ket) or density matrix. times : *list* / *arra",MatchSource.WIKI,docs/3.1.0/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html
https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:4584,Testability,log,logging,4584,"work more on optimizing this module for performance and features.; """""". __all__ = ['ssesolve', 'ssepdpsolve', 'smesolve', 'smepdpsolve']. import numpy as np; import scipy.sparse as sp; from scipy.linalg.blas import get_blas_funcs; try:; norm = get_blas_funcs(""znrm2"", dtype=np.float64); except:; from scipy.linalg import norm. from numpy.random import RandomState. from qutip.qobj import Qobj, isket; from qutip.states import ket2dm; from qutip.solver import Result; from qutip.expect import expect, expect_rho_vec; from qutip.superoperator import (spre, spost, mat2vec, vec2mat,; liouvillian, lindblad_dissipator); from qutip.cy.spmatfuncs import cy_expect_psi_csr, spmv, cy_expect_rho_vec; from qutip.cy.stochastic import (cy_d1_rho_photocurrent,; cy_d2_rho_photocurrent); from qutip.parallel import serial_map; from qutip.ui.progressbar import TextProgressBar; from qutip.solver import Options; from qutip.settings import debug. if debug:; import qutip.logging; import inspect; logger = qutip.logging.get_logger(). [docs]class StochasticSolverOptions:; """"""Class of options for stochastic solvers such as; :func:`qutip.stochastic.ssesolve`, :func:`qutip.stochastic.smesolve`, etc.; Options can be specified either as arguments to the constructor::. sso = StochasticSolverOptions(nsubsteps=100, ...). or by changing the class attributes after creation::. sso = StochasticSolverOptions(); sso.nsubsteps = 1000. The stochastic solvers :func:`qutip.stochastic.ssesolve`,; :func:`qutip.stochastic.smesolve`, :func:`qutip.stochastic.ssepdpsolve` and; :func:`qutip.stochastic.smepdpsolve` all take the same keyword arguments as; the constructor of these class, and internally they use these arguments to; construct an instance of this class, so it is rarely needed to explicitly; create an instance of this class. Attributes; ----------. H : :class:`qutip.Qobj`; System Hamiltonian. state0 : :class:`qutip.Qobj`; Initial state vector (ket) or density matrix. times : *list* / *array*; List of times for :m",MatchSource.WIKI,docs/3.1.0/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html
https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:11316,Testability,log,logger,11316," ssesolve(H, psi0, times, sc_ops, e_ops, **kwargs):; """"""; Solve the stochastic Schrödinger equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian. psi0 : :class:`qutip.Qobj`; Initial state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. sc_ops : list of :class:`qutip.Qobj`; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the equation of motion according to how the d1 and d2 functions; are defined. e_ops : list of :class:`qutip.Qobj`; Single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.SolverResult`; An instance of the class :class:`qutip.solver.SolverResult`.; """"""; if debug:; logger.debug(inspect.stack()[0][3]). if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. sso = StochasticSolverOptions(H=H, state0=psi0, times=times,; sc_ops=sc_ops, e_ops=e_ops, **kwargs). if sso.generate_A_ops is None:; sso.generate_A_ops = _generate_psi_A_ops. if (sso.d1 is None) or (sso.d2 is None):. if sso.method == 'homodyne':; sso.d1 = d1_psi_homodyne; sso.d2 = d2_psi_homodyne; sso.d2_len = 1; sso.homogeneous = True; sso.distribution = 'normal'; if ""dW_factors"" not in kwargs:; sso.dW_factors = np.array([1]); if ""m_ops"" not in kwargs:; sso.m_ops = [[c + c.dag()] for c in sso.sc_ops]. elif sso.method == 'heterodyne':; sso.d1 = d1_psi_heterodyne; sso.d2 = d2_psi_heterodyne; sso.d2_len = 2; sso.homogeneous = True; sso.distribution = 'normal'; if ""dW_factors"" not in kwargs:; sso.dW_factors = np.array([np.sqrt(2), np.sqrt(2)]); if ""m_ops"" not in kwargs:; sso.m_ops = [[(c + c.dag()), (-1j) * (c - c.dag())]; for idx, c in ",MatchSource.WIKI,docs/3.1.0/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html
https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:14409,Testability,log,logger,14409,"ho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. sc_ops : list of :class:`qutip.Qobj`; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.SolverResult`. An instance of the class :class:`qutip.solver.SolverResult`. TODO; ----; Add checks for commuting jump operators in Milstein method.; """""". if debug:; logger.debug(inspect.stack()[0][3]). if isket(rho0):; rho0 = ket2dm(rho0). if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. sso = StochasticSolverOptions(H=H, state0=rho0, times=times, c_ops=c_ops,; sc_ops=sc_ops, e_ops=e_ops, **kwargs). if (sso.d1 is None) or (sso.d2 is None):. if sso.method == 'homodyne' or sso.method is None:; sso.d1 = d1_rho_homodyne; sso.d2 = d2_rho_homodyne; sso.d2_len = 1; sso.homogeneous = True; sso.distribution = 'normal'; if ""dW_factors"" not in kwargs:; sso.dW_factors = np.array([np.sqrt(1)]); if ""m_ops"" not in kwargs:; sso.m_ops = [[c + c.dag()] for c in sso.sc_ops]. elif sso.method == 'heterodyne':; sso.d1 = d1_rho_heterodyne; sso.d2 = d2_rho_heterodyne; sso.d2_len = 2; sso.homogeneous = True; sso.distribution = 'normal'; if ""dW_factors"" not in kwargs:; sso.dW_factors = np.array([np.sqrt(2), np.sqrt(2)]); if ""m_ops"" not in kwargs:; sso.m_ops = [[(c + c.dag()), -1j * (c - c.dag())]; for c in ss",MatchSource.WIKI,docs/3.1.0/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html
https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:18432,Testability,log,logger,18432,"ict.keys())}. return res. [docs]def ssepdpsolve(H, psi0, times, c_ops, e_ops, **kwargs):; """"""; A stochastic (piecewse deterministic process) PDP solver for wavefunction; evolution. For most purposes, use :func:`qutip.mcsolve` instead for quantum; trajectory simulations. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian. psi0 : :class:`qutip.Qobj`; Initial state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.SolverResult`. An instance of the class :class:`qutip.solver.SolverResult`. """"""; if debug:; logger.debug(inspect.stack()[0][3]). if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. sso = StochasticSolverOptions(H=H, state0=psi0, times=times, c_ops=c_ops,; e_ops=e_ops, **kwargs). res = _ssepdpsolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}; return res. [docs]def smepdpsolve(H, rho0, times, c_ops, e_ops, **kwargs):; """"""; A stochastic (piecewse deterministic process) PDP solver for density matrix; evolution. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian. rho0 : :class:`qutip.Qobj`; Initial density matrix. times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. sc_ops : list of :class:`qutip.Qobj`; List of stochastic collapse operators. Each s",MatchSource.WIKI,docs/3.1.0/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html
https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:19982,Testability,log,logger,19982,"density matrix; evolution. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian. rho0 : :class:`qutip.Qobj`; Initial density matrix. times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. sc_ops : list of :class:`qutip.Qobj`; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.SolverResult`. An instance of the class :class:`qutip.solver.SolverResult`. """"""; if debug:; logger.debug(inspect.stack()[0][3]). if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. sso = StochasticSolverOptions(H=H, state0=rho0, times=times, c_ops=c_ops,; e_ops=e_ops, **kwargs). res = _smepdpsolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}; return res. # -----------------------------------------------------------------------------; # Generic parameterized stochastic Schrodinger equation solver; #; def _ssesolve_generic(sso, options, progress_bar):; """"""; Internal function for carrying out a sse integration. Used by ssesolve.; """"""; if debug:; logger.debug(inspect.stack()[0][3]). sso.N_store = len(sso.times); sso.N_substeps = sso.nsubsteps; sso.dt = (sso.times[1] - sso.times[0]) / sso.N_substeps; nt = sso.ntraj. data = Result(); data.solver = ""ssesolve""; data.times = sso.times; data.expect = np.zeros((len(sso.e_ops), sso.N_s",MatchSource.WIKI,docs/3.1.0/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html
https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:20691,Testability,log,logger,20691,"erators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.SolverResult`. An instance of the class :class:`qutip.solver.SolverResult`. """"""; if debug:; logger.debug(inspect.stack()[0][3]). if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. sso = StochasticSolverOptions(H=H, state0=rho0, times=times, c_ops=c_ops,; e_ops=e_ops, **kwargs). res = _smepdpsolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}; return res. # -----------------------------------------------------------------------------; # Generic parameterized stochastic Schrodinger equation solver; #; def _ssesolve_generic(sso, options, progress_bar):; """"""; Internal function for carrying out a sse integration. Used by ssesolve.; """"""; if debug:; logger.debug(inspect.stack()[0][3]). sso.N_store = len(sso.times); sso.N_substeps = sso.nsubsteps; sso.dt = (sso.times[1] - sso.times[0]) / sso.N_substeps; nt = sso.ntraj. data = Result(); data.solver = ""ssesolve""; data.times = sso.times; data.expect = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.ss = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.noise = []; data.measurement = []. # pre-compute collapse operator combinations that are commonly needed; # when evaluating the RHS of stochastic Schrodinger equations; sso.A_ops = sso.generate_A_ops(sso.sc_ops, sso.H). map_kwargs = {'progress_bar': progress_bar}; map_kwargs.update(sso.map_kwargs). task = _ssesolve_single_trajectory; task_args = (sso,); task_kwargs = {}. results = sso.map_func(task, list(range(sso.ntraj)),; task_args, task_kwargs, **map_kwargs). for result in results:; states_list, dW, m, expect, ss = result; data.states.append(states_list); data.noise.append(dW); data.measurement.append(m);",MatchSource.WIKI,docs/3.1.0/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html
https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:24941,Testability,log,logger,24941,"* dt; dW[a_idx, t_idx, j, :] = np.random.poisson(dw_expect,; d2_len). psi_t = sso.rhs(H_data, psi_t, t + dt * j,; A_ops, dt, dW[:, t_idx, j, :], d1, d2, sso.args). # optionally renormalize the wave function; if sso.normalize:; psi_t /= norm(psi_t). if sso.store_measurement:; for m_idx, m in enumerate(sso.m_ops):; for dW_idx, dW_factor in enumerate(sso.dW_factors):; if m[dW_idx]:; m_data = m[dW_idx].data; m_expt = cy_expect_psi_csr(m_data.data,; m_data.indices,; m_data.indptr,; psi_t, 0); else:; m_expt = 0; mm = (m_expt + dW_factor *; dW[m_idx, t_idx, :, dW_idx].sum() /; (dt * sso.N_substeps)); measurements[t_idx, m_idx, dW_idx] = mm. if d2_len == 1:; measurements = measurements.squeeze(axis=(2)). return states_list, dW, measurements, expect, ss. # -----------------------------------------------------------------------------; # Generic parameterized stochastic master equation solver; #; def _smesolve_generic(sso, options, progress_bar):; """"""; Internal function. See smesolve.; """"""; if debug:; logger.debug(inspect.stack()[0][3]). sso.N_store = len(sso.times); sso.N_substeps = sso.nsubsteps; sso.dt = (sso.times[1] - sso.times[0]) / sso.N_substeps; nt = sso.ntraj. data = Result(); data.solver = ""smesolve""; data.times = sso.times; data.expect = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.ss = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.noise = []; data.measurement = []. # Liouvillian for the deterministic part.; # needs to be modified for TD systems; sso.L = liouvillian(sso.H, sso.c_ops). # pre-compute suporoperator operator combinations that are commonly needed; # when evaluating the RHS of stochastic master equations; sso.A_ops = sso.generate_A_ops(sso.sc_ops, sso.L.data, sso.dt). # use .data instead of Qobj ?; sso.s_e_ops = [spre(e) for e in sso.e_ops]. if sso.m_ops:; sso.s_m_ops = [[spre(m) if m else None for m in m_op]; for m_op in sso.m_ops]; else:; sso.s_m_ops = [[spre(c) for _ in range(sso.d2_len)]; for c in sso.sc_ops]. map_kwargs",MatchSource.WIKI,docs/3.1.0/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html
https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:29565,Testability,log,logger,29565,"s:; for a_idx, A in enumerate(A_ops):; dw_expect = cy_expect_rho_vec(A[4], rho_t, 1) * dt; if dw_expect > 0:; dW[a_idx, t_idx, j, :] = np.random.poisson(dw_expect,; d2_len); else:; dW[a_idx, t_idx, j, :] = np.zeros(d2_len). rho_t = sso.rhs(L_data, rho_t, t + dt * j,; A_ops, dt, dW[:, t_idx, j, :], d1, d2, sso.args). if sso.store_measurement:; for m_idx, m in enumerate(sso.s_m_ops):; for dW_idx, dW_factor in enumerate(sso.dW_factors):; if m[dW_idx]:; m_expt = cy_expect_rho_vec(m[dW_idx].data, rho_prev, 0); else:; m_expt = 0; measurements[t_idx, m_idx, dW_idx] = m_expt + dW_factor * \; dW[m_idx, t_idx, :, dW_idx].sum() / (dt * N_substeps). if d2_len == 1:; measurements = measurements.squeeze(axis=(2)). return states_list, dW, measurements, expect, ss. # -----------------------------------------------------------------------------; # Generic parameterized stochastic SE PDP solver; #; def _ssepdpsolve_generic(sso, options, progress_bar):; """"""; For internal use. See ssepdpsolve.; """"""; if debug:; logger.debug(inspect.stack()[0][3]). N_store = len(sso.times); N_substeps = sso.nsubsteps; dt = (sso.times[1] - sso.times[0]) / N_substeps; nt = sso.ntraj. data = Result(); data.solver = ""sepdpsolve""; data.times = sso.tlist; data.expect = np.zeros((len(sso.e_ops), N_store), dtype=complex); data.ss = np.zeros((len(sso.e_ops), N_store), dtype=complex); data.jump_times = []; data.jump_op_idx = []. # effective hamiltonian for deterministic part; Heff = sso.H; for c in sso.c_ops:; Heff += -0.5j * c.dag() * c. progress_bar.start(sso.ntraj); for n in range(sso.ntraj):; progress_bar.update(n); psi_t = sso.state0.full().ravel(). states_list, jump_times, jump_op_idx = \; _ssepdpsolve_single_trajectory(data, Heff, dt, sso.times,; N_store, N_substeps,; psi_t, sso.state0.dims,; sso.c_ops, sso.e_ops). data.states.append(states_list); data.jump_times.append(jump_times); data.jump_op_idx.append(jump_op_idx). progress_bar.finished(). # average density matrices; if options.average_states and np.any",MatchSource.WIKI,docs/3.1.0/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html
https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:32824,Testability,log,logger,32824,"psi_t; psi_t /= norm(psi_t); phi_t = np.copy(psi_t). # store info about jump; jump_times.append(times[t_idx] + dt * j); jump_op_idx.append(n). # get new random numbers for next jump; r_jump, r_op = prng.rand(2). # deterministic evolution wihtout correction for norm decay; dphi_t = (-1.0j * dt) * (Heff.data * phi_t). # deterministic evolution with correction for norm decay; dpsi_t = (-1.0j * dt) * (Heff.data * psi_t); A = 0.5 * np.sum([norm(c.data * psi_t) ** 2 for c in c_ops]); dpsi_t += dt * A * psi_t. # increment wavefunctions; phi_t += dphi_t; psi_t += dpsi_t. # ensure that normalized wavefunction remains normalized; # this allows larger time step than otherwise would be possible; psi_t /= norm(psi_t). return states_list, jump_times, jump_op_idx. # -----------------------------------------------------------------------------; # Generic parameterized stochastic ME PDP solver; #; def _smepdpsolve_generic(sso, options, progress_bar):; """"""; For internal use. See smepdpsolve.; """"""; if debug:; logger.debug(inspect.stack()[0][3]). N_store = len(sso.times); N_substeps = sso.nsubsteps; dt = (sso.times[1] - sso.times[0]) / N_substeps; nt = sso.ntraj. data = Result(); data.solver = ""smepdpsolve""; data.times = sso.times; data.expect = np.zeros((len(sso.e_ops), N_store), dtype=complex); data.jump_times = []; data.jump_op_idx = []. # Liouvillian for the deterministic part.; # needs to be modified for TD systems; L = liouvillian(sso.H, sso.c_ops). progress_bar.start(sso.ntraj). for n in range(sso.ntraj):; progress_bar.update(n); rho_t = mat2vec(sso.rho0.full()).ravel(). states_list, jump_times, jump_op_idx = \; _smepdpsolve_single_trajectory(data, L, dt, sso.times,; N_store, N_substeps,; rho_t, sso.rho0.dims,; sso.c_ops, sso.e_ops). data.states.append(states_list); data.jump_times.append(jump_times); data.jump_op_idx.append(jump_op_idx). progress_bar.finished(). # average density matrices; if options.average_states and np.any(data.states):; data.states = [sum([data.states[m][n] ",MatchSource.WIKI,docs/3.1.0/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html
https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:8792,Usability,progress bar,progress bar,8792,"yne', 'photocurrent'); The name of the type of measurement process that give rise to the; stochastic equation to solve. Specifying a method with this keyword; argument is a short-hand notation for using pre-defined d1 and d2; functions for the corresponding stochastic processes. distribution : string ('normal', 'poission'); The name of the distribution used for the stochastic increments. store_measurements : bool (default False); Whether or not to store the measurement results in the; :class:`qutip.solver.SolverResult` instance returned by the solver. noise : array; Vector specifying the noise. normalize : bool (default True); Whether or not to normalize the wave function during the evolution. options : :class:`qutip.solver.Options`; Generic solver options. map_func: function; A map function or managing the calls to single-trajactory solvers. map_kwargs: dictionary; Optional keyword arguments to the map_func function function. progress_bar : :class:`qutip.ui.BaseProgressBar`; Optional progress bar class instance. """"""; def __init__(self, H=None, state0=None, times=None, c_ops=[], sc_ops=[],; e_ops=[], m_ops=None, args=None, ntraj=1, nsubsteps=1,; d1=None, d2=None, d2_len=1, dW_factors=None, rhs=None,; generate_A_ops=None, generate_noise=None, homogeneous=True,; solver=None, method=None, distribution='normal',; store_measurement=False, noise=None, normalize=True,; options=None, progress_bar=None, map_func=None,; map_kwargs=None):. if options is None:; options = Options(). if progress_bar is None:; progress_bar = TextProgressBar(). self.H = H; self.d1 = d1; self.d2 = d2; self.d2_len = d2_len; self.dW_factors = dW_factors if dW_factors else np.ones(d2_len); self.state0 = state0; self.times = times; self.c_ops = c_ops; self.sc_ops = sc_ops; self.e_ops = e_ops. if m_ops is None:; self.m_ops = [[c for _ in range(d2_len)] for c in sc_ops]; else:; self.m_ops = m_ops. self.ntraj = ntraj; self.nsubsteps = nsubsteps; self.solver = solver; self.method = method; self.distribution ",MatchSource.WIKI,docs/3.1.0/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html
https://qutip.org/docs/3.1.0/modules/qutip/superoperator.html:246,Deployability,install,installation,246,"﻿. qutip.superoperator — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.superoperator; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following dis",MatchSource.WIKI,docs/3.1.0/modules/qutip/superoperator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/superoperator.html
https://qutip.org/docs/3.1.0/modules/qutip/superoperator.html:10083,Deployability,update,updated,10083," post-multiplication by operator A. Parameters; ----------; A : qobj; Quantum operator for post multiplication. Returns; -------; super : qobj; Superoperator formed from input qauntum object.; """"""; if not isinstance(A, Qobj):; raise TypeError('Input is not a quantum object'). if not A.isoper:; raise TypeError('Input is not a quantum operator'). S = Qobj(isherm=A.isherm, superrep='super'); S.dims = [[A.dims[0], A.dims[1]], [A.dims[0], A.dims[1]]]; S.data = sp.kron(A.data.T, sp.identity(np.prod(A.shape[0])), format='csr'); return S. [docs]def spre(A):; """"""Superoperator formed from pre-multiplication by operator A. Parameters; ----------; A : qobj; Quantum operator for pre-multiplication. Returns; --------; super :qobj; Superoperator formed from input quantum object.; """"""; if not isinstance(A, Qobj):; raise TypeError('Input is not a quantum object'). if not A.isoper:; raise TypeError('Input is not a quantum operator'). S = Qobj(isherm=A.isherm, superrep='super'); S.dims = [[A.dims[0], A.dims[1]], [A.dims[0], A.dims[1]]]; S.data = sp.kron(sp.identity(np.prod(A.shape[1])), A.data, format='csr'); return S. def _drop_projected_dims(dims):; """"""; Eliminate subsystems that has been collapsed to only one state due to; a projection.; """"""; return [d for d in dims if d != 1]. [docs]def sprepost(A, B):; """"""Superoperator formed from pre-multiplication by operator A and post-; multiplication of operator B. Parameters; ----------; A : Qobj; Quantum operator for pre-multiplication. B : Qobj; Quantum operator for post-multiplication. Returns; --------; super : Qobj; Superoperator formed from input quantum objects.; """""". dims = [[_drop_projected_dims(A.dims[0]), _drop_projected_dims(B.dims[1])],; [_drop_projected_dims(A.dims[1]), _drop_projected_dims(B.dims[0])]]; data = sp.kron(B.data.T, A.data, format='csr'); return Qobj(data, dims=dims, superrep='super'). Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/modules/qutip/superoperator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/superoperator.html
https://qutip.org/docs/3.1.0/modules/qutip/superoperator.html:3864,Safety,avoid,avoids,3864," NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['liouvillian', 'liouvillian_ref', 'lindblad_dissipator',; 'operator_to_vector', 'vector_to_operator', 'mat2vec', 'vec2mat',; 'vec2mat_index', 'mat2vec_index', 'spost', 'spre', 'sprepost']. import scipy.sparse as sp; import numpy as np; from qutip.qobj import Qobj; from qutip.sparse import sp_reshape. [docs]def liouvillian(H, c_ops=[], data_only=False, chi=None):; """"""Assembles the Liouvillian superoperator from a Hamiltonian; and a ``list`` of collapse operators. Like liouvillian, but with an; experimental implementation which avoids creating extra Qobj instances,; which can be advantageous for large systems. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : array_like; A ``list`` or ``array`` of collapse operators. Returns; -------; L : qobj; Liouvillian superoperator. """""". if chi and len(chi) != len(c_ops):; raise ValueError('chi must be a list with same length as c_ops'). if H is not None:; if H.isoper:; op_dims = H.dims; op_shape = H.shape; elif H.issuper:; op_dims = H.dims[0]; op_shape = [np.prod(op_dims[0]), np.prod(op_dims[0])]; else:; raise TypeError(""Invalid type for Hamiltonian.""); else:; # no hamiltonian given, pick system size from a collapse operator; if isinstance(c_ops, list) and len(c_ops) > 0:; c = c_ops[0]; if c.isoper:; op_dims = c.dims; op_shape = c.shape; elif c.issuper:; op_dims = c.dims[0]; op_shape = [np.prod(op_dims[0]), np.prod(op_dims[0])]; else:; raise TypeError(""Invalid type for collapse operator.""); else:; raise TypeError(""Either H or c_ops must be given.""). sop_dims = [[op_d",MatchSource.WIKI,docs/3.1.0/modules/qutip/superoperator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/superoperator.html
https://qutip.org/docs/3.1.0/modules/qutip/superop_reps.html:245,Deployability,install,installation,245,"﻿. qutip.superop_reps — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.superop_reps; # -*- coding: utf-8 -*-; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of condition",MatchSource.WIKI,docs/3.1.0/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/superop_reps.html
https://qutip.org/docs/3.1.0/modules/qutip/superop_reps.html:13976,Deployability,update,updated,13976,"ix representation. Returns; -------; superop : Qobj; A quantum object representing the same map as ``q_oper``, such that; ``superop.superrep == ""super""``. Raises; ------; TypeError: if the given quantum object is not a map, or cannot be converted; to supermatrix representation.; """"""; if q_oper.type == 'super':; # Case 1: Already done.; if q_oper.superrep == ""super"":; return q_oper; # Case 2: Can directly convert.; elif q_oper.superrep == 'choi':; return choi_to_super(q_oper); # Case 3: Need to go through Choi.; elif q_oper.superrep == 'chi':; return to_super(to_choi(q_oper)); # Case 4: Something went wrong.; else:; raise ValueError(; ""Unrecognized superrep '{}'."".format(q_oper.superrep)); elif q_oper.type == 'oper': # Assume unitary; return spre(q_oper) * spost(q_oper.dag()); else:; raise TypeError(; ""Conversion of Qobj with type = {0.type} ""; ""and superrep = {0.superrep} to supermatrix not ""; ""supported."".format(q_oper); ). [docs]def to_kraus(q_oper):; """"""; Converts a Qobj representing a quantum map to a list of quantum objects,; each representing an operator in the Kraus decomposition of the given map. Parameters; ----------; q_oper : Qobj; Superoperator to be converted to Kraus representation. Returns; -------; kraus_ops : list of Qobj; A list of quantum objects, each representing a Kraus operator in the; decomposition of ``q_oper``. Raises; ------; TypeError: if the given quantum object is not a map, or cannot be; decomposed into Kraus operators.; """"""; if q_oper.type == 'super':; if q_oper.superrep in (""super"", ""chi""):; return to_kraus(to_choi(q_oper)); elif q_oper.superrep == 'choi':; return choi_to_kraus(q_oper); elif q_oper.type == 'oper': # Assume unitary; return [q_oper]; else:; raise TypeError(; ""Conversion of Qobj with type = {0.type} ""; ""and superrep = {0.superrep} to Kraus decomposition not ""; ""supported."".format(q_oper); ). Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/superop_reps.html
https://qutip.org/docs/3.1.0/modules/qutip/superop_reps.html:6582,Integrability,wrap,wrap,6582,"s can be.; # TODO: Make this sparse. CSR format was causing problems for the [idx, :]; # slicing below.; B = zeros((4 ** nq, 4 ** nq), dtype=complex); dims = [[[2] * nq] * 2] * 2. for idx, op in enumerate(starmap(tensor,; product(_SINGLE_QUBIT_PAULI_BASIS,; repeat=nq))):; B[:, idx] = operator_to_vector(op).dag().data.todense(). return Qobj(B, dims=dims). # PRIVATE CONVERSION FUNCTIONS ------------------------------------------------; # These functions handle the main work of converting between representations,; # and are exposed below by other functions that add postconditions about types.; #; # TODO: handle type='kraus' as a three-index Qobj, rather than as a list?. def _super_tofrom_choi(q_oper):; """"""; We exploit that the basis transformation between Choi and supermatrix; representations squares to the identity, so that if we munge Qobj.type,; we can use the same function. Since this function doesn't respect :attr:`Qobj.type`, we mark it as; private; only those functions which wrap this in a way so as to preserve; type should be called externally.; """"""; data = q_oper.data.toarray(); sqrt_shape = int(sqrt(data.shape[0])); return Qobj(dims=q_oper.dims,; inpt=data.reshape([sqrt_shape] * 4).; transpose(3, 1, 2, 0).reshape(q_oper.data.shape)). def super_to_choi(q_oper):; # TODO: deprecate and make private in favor of to_choi,; # which looks at Qobj.type to determine the right conversion function.; """"""; Takes a superoperator to a Choi matrix; TODO: Sanitize input, incorporate as method on Qobj if type=='super'; """"""; q_oper = _super_tofrom_choi(q_oper); q_oper.superrep = 'choi'; return q_oper. def choi_to_super(q_oper):; # TODO: deprecate and make private in favor of to_super,; # which looks at Qobj.type to determine the right conversion function.; """"""; Takes a Choi matrix to a superoperator; TODO: Sanitize input, Abstract-ify application of channels to states; """"""; q_oper = super_to_choi(q_oper); q_oper.superrep = 'super'; return q_oper. def choi_to_kraus(q_oper):; """"""; ",MatchSource.WIKI,docs/3.1.0/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/superop_reps.html
https://qutip.org/docs/3.1.0/modules/qutip/superop_reps.html:8810,Modifiability,extend,extend,8810,"rn list(map(lambda x: Qobj(inpt=x),; [sqrt(vals[j]) * vec2mat(vecs[j]); for j in range(len(vals))])). def kraus_to_choi(kraus_list):; """"""; Takes a list of Kraus operators and returns the Choi matrix for the channel; represented by the Kraus operators in `kraus_list`; """"""; kraus_mat_list = list(map(lambda x: matrix(x.data.todense()), kraus_list)); op_len = len(kraus_mat_list[0]); op_rng = range(op_len); choi_blocks = array([[sum([op[:, c_ix] * array([op.H[r_ix, :]]); for op in kraus_mat_list]); for r_ix in op_rng]; for c_ix in op_rng]); return Qobj(inpt=hstack(hstack(choi_blocks)),; dims=[kraus_list[0].dims, kraus_list[0].dims], type='super',; superrep='choi'). def kraus_to_super(kraus_list):; """"""; Converts a list of Kraus operators and returns a super operator.; """"""; return choi_to_super(kraus_to_choi(kraus_list)). def choi_to_chi(q_oper):; """"""; Converts a Choi matrix to a Chi matrix in the Pauli basis. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""; nq = len(q_oper.dims[0][0]); B = _pauli_basis(nq); B.superrep = 'choi'; return Qobj(B * q_oper * B.dag(), superrep='chi'). def chi_to_choi(q_oper):; """"""; Converts a Choi matrix to a Chi matrix in the Pauli basis. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""; nq = len(q_oper.dims[0][0]); B = _pauli_basis(nq). # The Chi matrix has tr(chi) == d², so we need to divide out; # by that to get back to the Choi form.; return Qobj((B.dag() * q_oper * B) / q_oper.shape[0], superrep='choi'). # PUBLIC CONVERSION FUNCTIONS -------------------------------------------------; # These functions handle superoperator conversions in a way that preserves the; # correctness of Qobj.type, and in a way that automatically branches based on; # the input Qobj.type. [docs]def to_choi(q_oper):; """"""; Converts a Qobj representing a quantum map to the Choi representation,; such that the trace of the re",MatchSource.WIKI,docs/3.1.0/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/superop_reps.html
https://qutip.org/docs/3.1.0/modules/qutip/superop_reps.html:9147,Modifiability,extend,extend,9147,"aus_list)); op_len = len(kraus_mat_list[0]); op_rng = range(op_len); choi_blocks = array([[sum([op[:, c_ix] * array([op.H[r_ix, :]]); for op in kraus_mat_list]); for r_ix in op_rng]; for c_ix in op_rng]); return Qobj(inpt=hstack(hstack(choi_blocks)),; dims=[kraus_list[0].dims, kraus_list[0].dims], type='super',; superrep='choi'). def kraus_to_super(kraus_list):; """"""; Converts a list of Kraus operators and returns a super operator.; """"""; return choi_to_super(kraus_to_choi(kraus_list)). def choi_to_chi(q_oper):; """"""; Converts a Choi matrix to a Chi matrix in the Pauli basis. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""; nq = len(q_oper.dims[0][0]); B = _pauli_basis(nq); B.superrep = 'choi'; return Qobj(B * q_oper * B.dag(), superrep='chi'). def chi_to_choi(q_oper):; """"""; Converts a Choi matrix to a Chi matrix in the Pauli basis. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""; nq = len(q_oper.dims[0][0]); B = _pauli_basis(nq). # The Chi matrix has tr(chi) == d², so we need to divide out; # by that to get back to the Choi form.; return Qobj((B.dag() * q_oper * B) / q_oper.shape[0], superrep='choi'). # PUBLIC CONVERSION FUNCTIONS -------------------------------------------------; # These functions handle superoperator conversions in a way that preserves the; # correctness of Qobj.type, and in a way that automatically branches based on; # the input Qobj.type. [docs]def to_choi(q_oper):; """"""; Converts a Qobj representing a quantum map to the Choi representation,; such that the trace of the returned operator is equal to the dimension; of the system. Parameters; ----------; q_oper : Qobj; Superoperator to be converted to Choi representation. Returns; -------; choi : Qobj; A quantum object representing the same map as ``q_oper``, such that; ``choi.superrep == ""choi""``. Raises; ------; TypeError: if the given quantum object is",MatchSource.WIKI,docs/3.1.0/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/superop_reps.html
https://qutip.org/docs/3.1.0/modules/qutip/superop_reps.html:6115,Security,expose,exposed,6115,"., 0., 0., 1. - pe],; [0., pe / 2., 0., 0.],; [0., 0., pe / 2., 0.],; [1. - pe, 0., 0., 1. - pe / 2.]]),; superrep='choi'). # CHANGE OF BASIS FUNCTIONS ---------------------------------------------------; # These functions find change of basis matrices, and are useful in converting; # between (for instance) Choi and chi matrices. At some point, these should; # probably be moved out to another module. _SINGLE_QUBIT_PAULI_BASIS = (identity(2), sigmax(), sigmay(), sigmaz()). def _pauli_basis(nq=1):; # NOTE: This is slow as can be.; # TODO: Make this sparse. CSR format was causing problems for the [idx, :]; # slicing below.; B = zeros((4 ** nq, 4 ** nq), dtype=complex); dims = [[[2] * nq] * 2] * 2. for idx, op in enumerate(starmap(tensor,; product(_SINGLE_QUBIT_PAULI_BASIS,; repeat=nq))):; B[:, idx] = operator_to_vector(op).dag().data.todense(). return Qobj(B, dims=dims). # PRIVATE CONVERSION FUNCTIONS ------------------------------------------------; # These functions handle the main work of converting between representations,; # and are exposed below by other functions that add postconditions about types.; #; # TODO: handle type='kraus' as a three-index Qobj, rather than as a list?. def _super_tofrom_choi(q_oper):; """"""; We exploit that the basis transformation between Choi and supermatrix; representations squares to the identity, so that if we munge Qobj.type,; we can use the same function. Since this function doesn't respect :attr:`Qobj.type`, we mark it as; private; only those functions which wrap this in a way so as to preserve; type should be called externally.; """"""; data = q_oper.data.toarray(); sqrt_shape = int(sqrt(data.shape[0])); return Qobj(dims=q_oper.dims,; inpt=data.reshape([sqrt_shape] * 4).; transpose(3, 1, 2, 0).reshape(q_oper.data.shape)). def super_to_choi(q_oper):; # TODO: deprecate and make private in favor of to_choi,; # which looks at Qobj.type to determine the right conversion function.; """"""; Takes a superoperator to a Choi matrix; TODO: Sanitiz",MatchSource.WIKI,docs/3.1.0/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/superop_reps.html
https://qutip.org/docs/3.1.0/modules/qutip/tensor.html:4776,Availability,error,error,4776,"rs; ----------; args : array_like; ``list`` or ``array`` of quantum objects for tensor product. Returns; -------; obj : qobj; A composite quantum object. Examples; --------; >>> tensor([sigmax(), sigmax()]); Quantum object: dims = [[2, 2], [2, 2]], \; shape = [4, 4], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j 1.+0.j]; [ 0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j 0.+0.j]; [ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]]; """""". if not args:; raise TypeError(""Requires at least one input argument""). if len(args) == 1 and isinstance(args[0], (list, np.ndarray)):; # this is the case when tensor is called on the form:; # tensor([q1, q2, q3, ...]); qlist = args[0]. elif len(args) == 1 and isinstance(args[0], Qobj):; # tensor is called with a single Qobj as an argument, do nothing; return args[0]. else:; # this is the case when tensor is called on the form:; # tensor(q1, q2, q3, ...); qlist = args. if not all([isinstance(q, Qobj) for q in qlist]):; # raise error if one of the inputs is not a quantum object; raise TypeError(""One of inputs is not a quantum object""). out = Qobj(). if qlist[0].issuper:; out.superrep = qlist[0].superrep; if not all([q.superrep == out.superrep for q in qlist]):; raise TypeError(""In tensor products of superroperators, all must"" +; ""have the same representation""). out.isherm = True; for n, q in enumerate(qlist):; if n == 0:; out.data = q.data; out.dims = q.dims; else:; out.data = sp.kron(out.data, q.data, format='csr'); out.dims = [out.dims[0] + q.dims[0], out.dims[1] + q.dims[1]]. out.isherm = out.isherm and q.isherm. if not out.isherm:; out._isherm = None. return out.tidyup() if qutip.settings.auto_tidyup else out. [docs]def super_tensor(*args):; """"""Calculates the tensor product of input superoperators, by tensoring; together the underlying Hilbert spaces on which each vectorized operator; acts. Parameters; ----------; args : array_like; ``list`` or ``array`` of quantum objects with ``type=""super""``. Returns; -------; obj : qobj; A co",MatchSource.WIKI,docs/3.1.0/modules/qutip/tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/tensor.html
https://qutip.org/docs/3.1.0/modules/qutip/tensor.html:9067,Availability,down,down,9067," to_super does nothing to things; # that are already type=super, while it will; # promote unitaries to superunitaries.; return super_tensor(*map(qutip.superop_reps.to_super, args)). else:; # Everything's just an oper, so ordinary tensor products work.; return tensor(*args). elif all(map(_isketlike, args)):; # Ket-likes.; if any(arg.isoperket for arg in args):; # We have a vectorized operator, we we may need to promote; # something.; return super_tensor(*(; arg if arg.isoperket; else operator_to_vector(qutip.states.ket2dm(arg)); for arg in args; )). else:; # Everything's ordinary, so we can use the tensor product here.; return tensor(*args). elif all(map(_isbralike, args)):; # Turn into ket-likes and recurse.; return composite(*(arg.dag() for arg in args)).dag(). else:; raise TypeError(""Unsupported Qobj types [{}]."".format(; "", "".join(arg.type for arg in args); )). def flatten(l):; """"""Flattens a list of lists to the first level. Given a list containing a mix of scalars and lists,; flattens down to a list of the scalars within the original; list. Examples; --------. >>> print(flatten([[[0], 1], 2])); [0, 1, 2]. """"""; if not isinstance(l, list):; return [l]; else:; return sum(map(flatten, l), []). def _enumerate_flat(l, idx=0):; if not isinstance(l, list):; # Found a scalar, so return and increment.; return idx, idx + 1; else:; # Found a list, so append all the scalars; # from it and recurse to keep the increment; # correct.; acc = []; for elem in l:; labels, idx = _enumerate_flat(elem, idx); acc.append(labels); return acc, idx. def enumerate_flat(l):; """"""Labels the indices at which scalars occur in a flattened list. Given a list containing a mix of scalars and lists,; returns a list of the same structure, where each scalar; has been replaced by an index into the flattened list. Examples; --------. >>> print(enumerate_flat([[[10], [20, 30]], 40])); [[[0], [1, 2]], 3]. """"""; return _enumerate_flat(l)[0]. def deep_remove(l, *what):; """"""Removes scalars from all levels of a n",MatchSource.WIKI,docs/3.1.0/modules/qutip/tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/tensor.html
https://qutip.org/docs/3.1.0/modules/qutip/tensor.html:239,Deployability,install,installation,239,"﻿. qutip.tensor — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.tensor; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; #",MatchSource.WIKI,docs/3.1.0/modules/qutip/tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/tensor.html
https://qutip.org/docs/3.1.0/modules/qutip/tensor.html:13315,Deployability,update,updated,13315,"dx not in (i, j) else idxs for idx in range(arr.ndim)); return np.sum(arr[sl], axis=0). def _tensor_contract_dense(arr, *pairs):; """"""; Contracts a dense tensor along one or more index pairs,; keeping track of how the indices are relabeled by the removal; of other indices.; """"""; axis_idxs = list(range(arr.ndim)); for pair in pairs:; # axis_idxs.index effectively evaluates the mapping from; # original index labels to the labels after contraction.; arr = _tensor_contract_single(arr, *map(axis_idxs.index, pair)); list(map(axis_idxs.remove, pair)); return arr. [docs]def tensor_contract(qobj, *pairs):; """"""Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should *not* be used for very large Qobjs. Parameters; ----------. pairs : tuple; One or more tuples ``(i, j)`` indicating that the; ``i`` and ``j`` dimensions of the original qobj; should be contracted. Returns; -------. cqobj : Qobj; The original Qobj with all named index pairs contracted; away. """"""; # Record and label the original dims.; dims = qobj.dims; dims_idxs = enumerate_flat(dims); flat_dims = flatten(dims). # Convert to dense first, since sparse won't support the reshaping we need.; qtens = qobj.data.toarray(). # Reshape by the flattened dims.; qtens = qtens.reshape(flat_dims). # Contract out the indices from the flattened object.; qtens = _tensor_contract_dense(qtens, *pairs). # Remove the contracted indexes from dims so we know how to; # reshape back.; contracted_idxs = deep_remove(dims_idxs, *flatten(list(map(list, pairs)))); contracted_dims = unflatten(flat_dims, contracted_idxs). l_mtx_dims, r_mtx_dims = map(np.product, contracted_dims). # Reshape back into a 2D matrix.; qmtx = qtens.reshape((l_mtx_dims, r_mtx_dims)). # Return back as a qobj.; return Qobj(qmtx, dims=contracted_dims, superrep=qobj.superrep). import qutip.states. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/modules/qutip/tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/tensor.html
https://qutip.org/docs/3.1.0/modules/qutip/tensor.html:3696,Integrability,depend,dependency,3696,"IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; Module for the creation of composite quantum objects via the tensor product.; """""". __all__ = ['tensor', 'super_tensor', 'composite', 'tensor_contract']. import numpy as np; import scipy.sparse as sp. from qutip.qobj import Qobj; from qutip.permute import reshuffle; from qutip.superoperator import operator_to_vector. import qutip.settings; import qutip.superop_reps # Avoid circular dependency here. [docs]def tensor(*args):; """"""Calculates the tensor product of input operators. Parameters; ----------; args : array_like; ``list`` or ``array`` of quantum objects for tensor product. Returns; -------; obj : qobj; A composite quantum object. Examples; --------; >>> tensor([sigmax(), sigmax()]); Quantum object: dims = [[2, 2], [2, 2]], \; shape = [4, 4], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j 1.+0.j]; [ 0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j 0.+0.j]; [ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]]; """""". if not args:; raise TypeError(""Requires at least one input argument""). if len(args) == 1 and isinstance(args[0], (list, np.ndarray)):; # this is the case when tensor is called on the form:; # tensor([q1, q2, q3, ...]); qlist = args[0]. elif len(args) == 1 and isinstance(args[0], Qobj):; # tensor is called with a single Qobj as an argument, do nothing; return args[0]. else:; # this is the case when tensor is called on the form:; # tensor(q1, ",MatchSource.WIKI,docs/3.1.0/modules/qutip/tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/tensor.html
https://qutip.org/docs/3.1.0/modules/qutip/tensor.html:11251,Integrability,contract,contract,11251,"move([[[[0, 1, 2]], [3, 4], [5], [6, 7]]], 0, 5)); [[[[1, 2]], [3, 4], [], [6, 7]]]. """"""; if isinstance(l, list):; # Make a shallow copy at this level.; l = l[:]; for to_remove in what:; if to_remove in l:; l.remove(to_remove); else:; l = list(map(lambda elem: deep_remove(elem, to_remove), l)); return l. def unflatten(l, idxs):; """"""Unflattens a list by a given structure. Given a list of scalars and a deep list of indices; as produced by `flatten`, returns an ""unflattened""; form of the list. This perfectly inverts `flatten`. Examples; --------. >>> l = [[[10, 20, 30], [40, 50, 60]], [[70, 80, 90], [100, 110, 120]]]; >>> idxs = enumerate_flat(l); >>> print(unflatten(flatten(l)), idxs) == l; True. """"""; acc = []; for idx in idxs:; if isinstance(idx, list):; acc.append(unflatten(l, idx)); else:; acc.append(l[idx]); return acc. def _tensor_contract_single(arr, i, j):; """"""; Contracts a dense tensor along a single index pair.; """"""; if arr.shape[i] != arr.shape[j]:; raise ValueError(""Cannot contract over indices of different length.""); idxs = np.arange(arr.shape[i]); sl = tuple(slice(None, None, None); if idx not in (i, j) else idxs for idx in range(arr.ndim)); return np.sum(arr[sl], axis=0). def _tensor_contract_dense(arr, *pairs):; """"""; Contracts a dense tensor along one or more index pairs,; keeping track of how the indices are relabeled by the removal; of other indices.; """"""; axis_idxs = list(range(arr.ndim)); for pair in pairs:; # axis_idxs.index effectively evaluates the mapping from; # original index labels to the labels after contraction.; arr = _tensor_contract_single(arr, *map(axis_idxs.index, pair)); list(map(axis_idxs.remove, pair)); return arr. [docs]def tensor_contract(qobj, *pairs):; """"""Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should *not* be used for very large Qobjs. Parameters; ----------. pairs : tuple; One or more tuples ``(i, j)`` indicating that the; ``i`` and ``j`` dimensions of the original q",MatchSource.WIKI,docs/3.1.0/modules/qutip/tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/tensor.html
https://qutip.org/docs/3.1.0/modules/qutip/tensor.html:11805,Integrability,contract,contraction,11805,"nverts `flatten`. Examples; --------. >>> l = [[[10, 20, 30], [40, 50, 60]], [[70, 80, 90], [100, 110, 120]]]; >>> idxs = enumerate_flat(l); >>> print(unflatten(flatten(l)), idxs) == l; True. """"""; acc = []; for idx in idxs:; if isinstance(idx, list):; acc.append(unflatten(l, idx)); else:; acc.append(l[idx]); return acc. def _tensor_contract_single(arr, i, j):; """"""; Contracts a dense tensor along a single index pair.; """"""; if arr.shape[i] != arr.shape[j]:; raise ValueError(""Cannot contract over indices of different length.""); idxs = np.arange(arr.shape[i]); sl = tuple(slice(None, None, None); if idx not in (i, j) else idxs for idx in range(arr.ndim)); return np.sum(arr[sl], axis=0). def _tensor_contract_dense(arr, *pairs):; """"""; Contracts a dense tensor along one or more index pairs,; keeping track of how the indices are relabeled by the removal; of other indices.; """"""; axis_idxs = list(range(arr.ndim)); for pair in pairs:; # axis_idxs.index effectively evaluates the mapping from; # original index labels to the labels after contraction.; arr = _tensor_contract_single(arr, *map(axis_idxs.index, pair)); list(map(axis_idxs.remove, pair)); return arr. [docs]def tensor_contract(qobj, *pairs):; """"""Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should *not* be used for very large Qobjs. Parameters; ----------. pairs : tuple; One or more tuples ``(i, j)`` indicating that the; ``i`` and ``j`` dimensions of the original qobj; should be contracted. Returns; -------. cqobj : Qobj; The original Qobj with all named index pairs contracted; away. """"""; # Record and label the original dims.; dims = qobj.dims; dims_idxs = enumerate_flat(dims); flat_dims = flatten(dims). # Convert to dense first, since sparse won't support the reshaping we need.; qtens = qobj.data.toarray(). # Reshape by the flattened dims.; qtens = qtens.reshape(flat_dims). # Contract out the indices from the flattened object.; qtens = _tensor_contract_dense(qtens, ",MatchSource.WIKI,docs/3.1.0/modules/qutip/tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/tensor.html
https://qutip.org/docs/3.1.0/modules/qutip/tensor.html:12269,Integrability,contract,contracted,12269,"arr.shape[j]:; raise ValueError(""Cannot contract over indices of different length.""); idxs = np.arange(arr.shape[i]); sl = tuple(slice(None, None, None); if idx not in (i, j) else idxs for idx in range(arr.ndim)); return np.sum(arr[sl], axis=0). def _tensor_contract_dense(arr, *pairs):; """"""; Contracts a dense tensor along one or more index pairs,; keeping track of how the indices are relabeled by the removal; of other indices.; """"""; axis_idxs = list(range(arr.ndim)); for pair in pairs:; # axis_idxs.index effectively evaluates the mapping from; # original index labels to the labels after contraction.; arr = _tensor_contract_single(arr, *map(axis_idxs.index, pair)); list(map(axis_idxs.remove, pair)); return arr. [docs]def tensor_contract(qobj, *pairs):; """"""Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should *not* be used for very large Qobjs. Parameters; ----------. pairs : tuple; One or more tuples ``(i, j)`` indicating that the; ``i`` and ``j`` dimensions of the original qobj; should be contracted. Returns; -------. cqobj : Qobj; The original Qobj with all named index pairs contracted; away. """"""; # Record and label the original dims.; dims = qobj.dims; dims_idxs = enumerate_flat(dims); flat_dims = flatten(dims). # Convert to dense first, since sparse won't support the reshaping we need.; qtens = qobj.data.toarray(). # Reshape by the flattened dims.; qtens = qtens.reshape(flat_dims). # Contract out the indices from the flattened object.; qtens = _tensor_contract_dense(qtens, *pairs). # Remove the contracted indexes from dims so we know how to; # reshape back.; contracted_idxs = deep_remove(dims_idxs, *flatten(list(map(list, pairs)))); contracted_dims = unflatten(flat_dims, contracted_idxs). l_mtx_dims, r_mtx_dims = map(np.product, contracted_dims). # Reshape back into a 2D matrix.; qmtx = qtens.reshape((l_mtx_dims, r_mtx_dims)). # Return back as a qobj.; return Qobj(qmtx, dims=contracted_dims, superrep=qobj.super",MatchSource.WIKI,docs/3.1.0/modules/qutip/tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/tensor.html
https://qutip.org/docs/3.1.0/modules/qutip/tensor.html:12358,Integrability,contract,contracted,12358,"ple(slice(None, None, None); if idx not in (i, j) else idxs for idx in range(arr.ndim)); return np.sum(arr[sl], axis=0). def _tensor_contract_dense(arr, *pairs):; """"""; Contracts a dense tensor along one or more index pairs,; keeping track of how the indices are relabeled by the removal; of other indices.; """"""; axis_idxs = list(range(arr.ndim)); for pair in pairs:; # axis_idxs.index effectively evaluates the mapping from; # original index labels to the labels after contraction.; arr = _tensor_contract_single(arr, *map(axis_idxs.index, pair)); list(map(axis_idxs.remove, pair)); return arr. [docs]def tensor_contract(qobj, *pairs):; """"""Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should *not* be used for very large Qobjs. Parameters; ----------. pairs : tuple; One or more tuples ``(i, j)`` indicating that the; ``i`` and ``j`` dimensions of the original qobj; should be contracted. Returns; -------. cqobj : Qobj; The original Qobj with all named index pairs contracted; away. """"""; # Record and label the original dims.; dims = qobj.dims; dims_idxs = enumerate_flat(dims); flat_dims = flatten(dims). # Convert to dense first, since sparse won't support the reshaping we need.; qtens = qobj.data.toarray(). # Reshape by the flattened dims.; qtens = qtens.reshape(flat_dims). # Contract out the indices from the flattened object.; qtens = _tensor_contract_dense(qtens, *pairs). # Remove the contracted indexes from dims so we know how to; # reshape back.; contracted_idxs = deep_remove(dims_idxs, *flatten(list(map(list, pairs)))); contracted_dims = unflatten(flat_dims, contracted_idxs). l_mtx_dims, r_mtx_dims = map(np.product, contracted_dims). # Reshape back into a 2D matrix.; qmtx = qtens.reshape((l_mtx_dims, r_mtx_dims)). # Return back as a qobj.; return Qobj(qmtx, dims=contracted_dims, superrep=qobj.superrep). import qutip.states. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 201",MatchSource.WIKI,docs/3.1.0/modules/qutip/tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/tensor.html
https://qutip.org/docs/3.1.0/modules/qutip/tensor.html:12788,Integrability,contract,contracted,12788,"dx not in (i, j) else idxs for idx in range(arr.ndim)); return np.sum(arr[sl], axis=0). def _tensor_contract_dense(arr, *pairs):; """"""; Contracts a dense tensor along one or more index pairs,; keeping track of how the indices are relabeled by the removal; of other indices.; """"""; axis_idxs = list(range(arr.ndim)); for pair in pairs:; # axis_idxs.index effectively evaluates the mapping from; # original index labels to the labels after contraction.; arr = _tensor_contract_single(arr, *map(axis_idxs.index, pair)); list(map(axis_idxs.remove, pair)); return arr. [docs]def tensor_contract(qobj, *pairs):; """"""Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should *not* be used for very large Qobjs. Parameters; ----------. pairs : tuple; One or more tuples ``(i, j)`` indicating that the; ``i`` and ``j`` dimensions of the original qobj; should be contracted. Returns; -------. cqobj : Qobj; The original Qobj with all named index pairs contracted; away. """"""; # Record and label the original dims.; dims = qobj.dims; dims_idxs = enumerate_flat(dims); flat_dims = flatten(dims). # Convert to dense first, since sparse won't support the reshaping we need.; qtens = qobj.data.toarray(). # Reshape by the flattened dims.; qtens = qtens.reshape(flat_dims). # Contract out the indices from the flattened object.; qtens = _tensor_contract_dense(qtens, *pairs). # Remove the contracted indexes from dims so we know how to; # reshape back.; contracted_idxs = deep_remove(dims_idxs, *flatten(list(map(list, pairs)))); contracted_dims = unflatten(flat_dims, contracted_idxs). l_mtx_dims, r_mtx_dims = map(np.product, contracted_dims). # Reshape back into a 2D matrix.; qmtx = qtens.reshape((l_mtx_dims, r_mtx_dims)). # Return back as a qobj.; return Qobj(qmtx, dims=contracted_dims, superrep=qobj.superrep). import qutip.states. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/modules/qutip/tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/tensor.html
https://qutip.org/docs/3.1.0/modules/qutip/three_level_atom.html:249,Deployability,install,installation,249,"﻿. qutip.three_level_atom — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.three_level_atom; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the followi",MatchSource.WIKI,docs/3.1.0/modules/qutip/three_level_atom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/three_level_atom.html
https://qutip.org/docs/3.1.0/modules/qutip/three_level_atom.html:3614,Deployability,configurat,configuration,3614,"DING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; '''; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations::. Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; ----------; The naming of qutip operators follows the convention in [1]_ . .. [1] Shore, B. W., ""The Theory of Coherent Atomic Excitation"",; Wiley, 1990. Notes; -----; Contributed by Markus Baden, Oct. 07, 2011. '''. __all__ = ['three_level_basis', 'three_level_ops']. from qutip.states import qutrit_basis; from numpy import array. [docs]def three_level_basis():; ''' Basis states for a three level atom. Returns; -------; states : array; `array` of three level atom basis vectors. '''; # A three level atom has the same representation as a qutrit, i.e.; # three states; return qutrit_basis(). [docs]def three_level_ops():;",MatchSource.WIKI,docs/3.1.0/modules/qutip/three_level_atom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/three_level_atom.html
https://qutip.org/docs/3.1.0/modules/qutip/three_level_atom.html:3703,Deployability,configurat,configurations,3703,"PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; '''; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations::. Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; ----------; The naming of qutip operators follows the convention in [1]_ . .. [1] Shore, B. W., ""The Theory of Coherent Atomic Excitation"",; Wiley, 1990. Notes; -----; Contributed by Markus Baden, Oct. 07, 2011. '''. __all__ = ['three_level_basis', 'three_level_ops']. from qutip.states import qutrit_basis; from numpy import array. [docs]def three_level_basis():; ''' Basis states for a three level atom. Returns; -------; states : array; `array` of three level atom basis vectors. '''; # A three level atom has the same representation as a qutrit, i.e.; # three states; return qutrit_basis(). [docs]def three_level_ops():; ''' Operators for a three level system (qutrit). Returns; --------; ops : array; `array` of",MatchSource.WIKI,docs/3.1.0/modules/qutip/three_level_atom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/three_level_atom.html
https://qutip.org/docs/3.1.0/modules/qutip/three_level_atom.html:5212,Deployability,update,updated,5212,"###########################################################; '''; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations::. Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; ----------; The naming of qutip operators follows the convention in [1]_ . .. [1] Shore, B. W., ""The Theory of Coherent Atomic Excitation"",; Wiley, 1990. Notes; -----; Contributed by Markus Baden, Oct. 07, 2011. '''. __all__ = ['three_level_basis', 'three_level_ops']. from qutip.states import qutrit_basis; from numpy import array. [docs]def three_level_basis():; ''' Basis states for a three level atom. Returns; -------; states : array; `array` of three level atom basis vectors. '''; # A three level atom has the same representation as a qutrit, i.e.; # three states; return qutrit_basis(). [docs]def three_level_ops():; ''' Operators for a three level system (qutrit). Returns; --------; ops : array; `array` of three level operators. '''; one, two, three = qutrit_basis(); # Note that the three level operators are different; # from the qutrit operators. A three level atom only; # has transitions 1 <-> 2 <-> 3, so we define the; # operators seperately from the qutrit code; sig11 = one * one.dag(); sig22 = two * two.dag(); sig33 = three * three.dag(); sig12 = one * two.dag(); sig32 = three * two.dag(); return array([sig11, sig22, sig33, sig12, sig32], dtype=object). Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/modules/qutip/three_level_atom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/three_level_atom.html
https://qutip.org/docs/3.1.0/modules/qutip/three_level_atom.html:3614,Modifiability,config,configuration,3614,"DING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; '''; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations::. Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; ----------; The naming of qutip operators follows the convention in [1]_ . .. [1] Shore, B. W., ""The Theory of Coherent Atomic Excitation"",; Wiley, 1990. Notes; -----; Contributed by Markus Baden, Oct. 07, 2011. '''. __all__ = ['three_level_basis', 'three_level_ops']. from qutip.states import qutrit_basis; from numpy import array. [docs]def three_level_basis():; ''' Basis states for a three level atom. Returns; -------; states : array; `array` of three level atom basis vectors. '''; # A three level atom has the same representation as a qutrit, i.e.; # three states; return qutrit_basis(). [docs]def three_level_ops():;",MatchSource.WIKI,docs/3.1.0/modules/qutip/three_level_atom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/three_level_atom.html
https://qutip.org/docs/3.1.0/modules/qutip/three_level_atom.html:3703,Modifiability,config,configurations,3703,"PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; '''; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations::. Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; ----------; The naming of qutip operators follows the convention in [1]_ . .. [1] Shore, B. W., ""The Theory of Coherent Atomic Excitation"",; Wiley, 1990. Notes; -----; Contributed by Markus Baden, Oct. 07, 2011. '''. __all__ = ['three_level_basis', 'three_level_ops']. from qutip.states import qutrit_basis; from numpy import array. [docs]def three_level_basis():; ''' Basis states for a three level atom. Returns; -------; states : array; `array` of three level atom basis vectors. '''; # A three level atom has the same representation as a qutrit, i.e.; # three states; return qutrit_basis(). [docs]def three_level_ops():; ''' Operators for a three level system (qutrit). Returns; --------; ops : array; `array` of",MatchSource.WIKI,docs/3.1.0/modules/qutip/three_level_atom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/three_level_atom.html
https://qutip.org/docs/3.1.0/modules/qutip/tomography.html:243,Deployability,install,installation,243,"﻿. qutip.tomography — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.tomography; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaime",MatchSource.WIKI,docs/3.1.0/modules/qutip/tomography.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/tomography.html
https://qutip.org/docs/3.1.0/modules/qutip/tomography.html:7898,Deployability,update,updated,7898,"igure axis instance used for generating QPT plot; (alternative to the fig argument). threshold: float (None); Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure.; """""". if ax is None:; if fig is None:; fig = plt.figure(figsize=figsize); ax = fig.add_subplot(1, 1, 1, projection='3d', position=[0, 0, 1, 1]). xlabels = []; for inds in _index_permutations([len(lbls) for lbls in lbls_list]):; xlabels.append("""".join(; [lbls_list[k][inds[k]] for k in range(len(lbls_list))])). if not title:; title = r""$\chi$"". matrix_histogram_complex(chi, xlabels, xlabels, title=title, ax=ax,; threshold=threshold). return fig, ax. [docs]def qpt(U, op_basis_list):; """"""; Calculate the quantum process tomography chi matrix for a given (possibly; nonunitary) transformation matrix U, which transforms a density matrix in; vector form according to:. vec(rho) = U * vec(rho0). or. rho = vec2mat(U * mat2vec(rho0)). U can be calculated for an open quantum system using the QuTiP propagator; function. Parameters; ----------; U : Qobj; Transformation operator. Can be calculated using QuTiP propagator; function. op_basis_list : list; A list of Qobj's representing the basis states. Returns; -------; chi : array; QPT chi matrix. """""". E_ops = []; # loop over all index permutations; for inds in _index_permutations([len(ops) for ops in op_basis_list]):; # loop over all composite systems; E_op_list = [op_basis_list[k][inds[k]] for k in range(len(; op_basis_list))]; E_ops.append(tensor(E_op_list)). EE_ops = [spre(E1) * spost(E2.dag()) for E1 in E_ops for E2 in E_ops]. M = hstack([mat2vec(EE.full()) for EE in EE_ops]). Uvec = mat2vec(U.full()). chi_vec = la.solve(M, Uvec). return vec2mat(chi_vec). Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/modules/qutip/tomography.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/tomography.html
https://qutip.org/docs/3.1.0/modules/qutip/utilities.html:242,Deployability,install,installation,242,"﻿. qutip.utilities — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.utilities; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.",MatchSource.WIKI,docs/3.1.0/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/utilities.html
https://qutip.org/docs/3.1.0/modules/qutip/utilities.html:10640,Deployability,update,updated,10640,"740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def view_methods(Q):; """"""; View the methods and corresponding doc strings; for a Qobj class. Parameters; ----------; Q : Qobj; Input Quantum object. """"""; meth = dir(Q); qobj_props = ['data', 'dims', 'isherm', 'shape', 'type']; pub_meth = [x for x in meth if x.find('_') and x not in qobj_props]; ml = max([len(x) for x in pub_meth]); nl = len(Q.__class__.__name__ + 'Class Methods:'); print(Q.__class__.__name__ + ' Class Methods:'); print('-' * nl); for ii in range(len(pub_meth)):; m = getattr(Q, pub_meth[ii]); meth_str = m.__doc__; ind = meth_str.find('\n'); pub_len = len(pub_meth[ii] + ': '); print(pub_meth[ii] + ':' + ' ' * (ml+3-pub_len) + meth_str[:ind]). def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/utilities.html
https://qutip.org/docs/3.1.0/modules/qutip/utilities.html:6684,Energy Efficiency,energy,energy,6684,".min([j2 + j3 + m1, j3 - j1 + j2, j3 + m3])). C = np.sqrt((2.0 * j3 + 1.0) * factorial(j3 + j1 - j2) *; factorial(j3 - j1 + j2) * factorial(j1 + j2 - j3) *; factorial(j3 + m3) * factorial(j3 - m3) /; (factorial(j1 + j2 + j3 + 1) *; factorial(j1 - m1) * factorial(j1 + m1) *; factorial(j2 - m2) * factorial(j2 + m2))); S = 0; for v in range(vmin, vmax + 1):; S += (-1.0) ** (v + j2 + m2) / factorial(v) * \; factorial(j2 + j3 + m1 - v) * factorial(j1 - m1 + v) / \; factorial(j3 - j1 + j2 - v) / factorial(j3 + m3 - v) / \; factorial(v + j1 - j2 - m3); C = C * S; return C. # -----------------------------------------------------------------------------; # Functions for unit conversions; #; _e = 1.602176565e-19 # C; _kB = 1.3806488e-23 # J/K; _h = 6.62606957e-34 # Js. _unit_factor_tbl = {; # ""unit"": ""factor that convert argument from unit 'unit' to Joule""; ""J"": 1.0,; ""eV"": _e,; ""meV"": 1.0e-3 * _e,; ""GHz"": 1.0e9 * _h,; ""mK"": 1.0e-3 * _kB,; }. [docs]def convert_unit(value, orig=""meV"", to=""GHz""):; """"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : flo",MatchSource.WIKI,docs/3.1.0/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/utilities.html
https://qutip.org/docs/3.1.0/modules/qutip/utilities.html:6773,Energy Efficiency,energy,energy,6773," j1 - j2) *; factorial(j3 - j1 + j2) * factorial(j1 + j2 - j3) *; factorial(j3 + m3) * factorial(j3 - m3) /; (factorial(j1 + j2 + j3 + 1) *; factorial(j1 - m1) * factorial(j1 + m1) *; factorial(j2 - m2) * factorial(j2 + m2))); S = 0; for v in range(vmin, vmax + 1):; S += (-1.0) ** (v + j2 + m2) / factorial(v) * \; factorial(j2 + j3 + m1 - v) * factorial(j1 - m1 + v) / \; factorial(j3 - j1 + j2 - v) / factorial(j3 + m3 - v) / \; factorial(v + j1 - j2 - m3); C = C * S; return C. # -----------------------------------------------------------------------------; # Functions for unit conversions; #; _e = 1.602176565e-19 # C; _kB = 1.3806488e-23 # J/K; _h = 6.62606957e-34 # Js. _unit_factor_tbl = {; # ""unit"": ""factor that convert argument from unit 'unit' to Joule""; ""J"": 1.0,; ""eV"": _e,; ""meV"": 1.0e-3 * _e,; ""GHz"": 1.0e9 * _h,; ""mK"": 1.0e-3 * _kB,; }. [docs]def convert_unit(value, orig=""meV"", to=""GHz""):; """"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The en",MatchSource.WIKI,docs/3.1.0/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/utilities.html
https://qutip.org/docs/3.1.0/modules/qutip/utilities.html:7000,Energy Efficiency,energy,energy,7000," S = 0; for v in range(vmin, vmax + 1):; S += (-1.0) ** (v + j2 + m2) / factorial(v) * \; factorial(j2 + j3 + m1 - v) * factorial(j1 - m1 + v) / \; factorial(j3 - j1 + j2 - v) / factorial(j3 + m3 - v) / \; factorial(v + j1 - j2 - m3); C = C * S; return C. # -----------------------------------------------------------------------------; # Functions for unit conversions; #; _e = 1.602176565e-19 # C; _kB = 1.3806488e-23 # J/K; _h = 6.62606957e-34 # Js. _unit_factor_tbl = {; # ""unit"": ""factor that convert argument from unit 'unit' to Joule""; ""J"": 1.0,; ""eV"": _e,; ""meV"": 1.0e-3 * _e,; ""GHz"": 1.0e9 * _h,; ""mK"": 1.0e-3 * _kB,; }. [docs]def convert_unit(value, orig=""meV"", to=""GHz""):; """"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in ",MatchSource.WIKI,docs/3.1.0/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/utilities.html
https://qutip.org/docs/3.1.0/modules/qutip/utilities.html:7296,Energy Efficiency,energy,energy,7296,"-----------------------------; # Functions for unit conversions; #; _e = 1.602176565e-19 # C; _kB = 1.3806488e-23 # J/K; _h = 6.62606957e-34 # Js. _unit_factor_tbl = {; # ""unit"": ""factor that convert argument from unit 'unit' to Joule""; ""J"": 1.0,; ""eV"": _e,; ""meV"": 1.0e-3 * _e,; ""GHz"": 1.0e9 * _h,; ""mK"": 1.0e-3 * _kB,; }. [docs]def convert_unit(value, orig=""meV"", to=""GHz""):; """"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Return",MatchSource.WIKI,docs/3.1.0/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/utilities.html
https://qutip.org/docs/3.1.0/modules/qutip/utilities.html:7377,Energy Efficiency,energy,energy,7377,".602176565e-19 # C; _kB = 1.3806488e-23 # J/K; _h = 6.62606957e-34 # Js. _unit_factor_tbl = {; # ""unit"": ""factor that convert argument from unit 'unit' to Joule""; ""J"": 1.0,; ""eV"": _e,; ""meV"": 1.0e-3 * _e,; ""GHz"": 1.0e9 * _h,; ""mK"": 1.0e-3 * _kB,; }. [docs]def convert_unit(value, orig=""meV"", to=""GHz""):; """"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; #",MatchSource.WIKI,docs/3.1.0/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/utilities.html
https://qutip.org/docs/3.1.0/modules/qutip/utilities.html:7451,Energy Efficiency,energy,energy,7451,"_unit_factor_tbl = {; # ""unit"": ""factor that convert argument from unit 'unit' to Joule""; ""J"": 1.0,; ""eV"": _e,; ""meV"": 1.0e-3 * _e,; ""GHz"": 1.0e9 * _h,; ""mK"": 1.0e-3 * _kB,; }. [docs]def convert_unit(value, orig=""meV"", to=""GHz""):; """"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_t",MatchSource.WIKI,docs/3.1.0/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/utilities.html
https://qutip.org/docs/3.1.0/modules/qutip/utilities.html:7602,Energy Efficiency,energy,energy,7602,"1.0e-3 * _kB,; }. [docs]def convert_unit(value, orig=""meV"", to=""GHz""):; """"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit ",MatchSource.WIKI,docs/3.1.0/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/utilities.html
https://qutip.org/docs/3.1.0/modules/qutip/utilities.html:7683,Energy Efficiency,energy,energy,7683,"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 me",MatchSource.WIKI,docs/3.1.0/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/utilities.html
https://qutip.org/docs/3.1.0/modules/qutip/utilities.html:7757,Energy Efficiency,energy,energy,7757,"-; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """""";",MatchSource.WIKI,docs/3.1.0/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/utilities.html
https://qutip.org/docs/3.1.0/modules/qutip/utilities.html:7895,Energy Efficiency,energy,energy,7895,"he name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit :",MatchSource.WIKI,docs/3.1.0/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/utilities.html
https://qutip.org/docs/3.1.0/modules/qutip/utilities.html:7974,Energy Efficiency,energy,energy,7974,"-; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 m",MatchSource.WIKI,docs/3.1.0/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/utilities.html
https://qutip.org/docs/3.1.0/modules/qutip/utilities.html:8048,Energy Efficiency,energy,energy,8048,"rig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """,MatchSource.WIKI,docs/3.1.0/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/utilities.html
https://qutip.org/docs/3.1.0/modules/qutip/utilities.html:8181,Energy Efficiency,energy,energy,8181,"t %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_ne",MatchSource.WIKI,docs/3.1.0/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/utilities.html
https://qutip.org/docs/3.1.0/modules/qutip/utilities.html:8260,Energy Efficiency,energy,energy,8260,"o]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB",MatchSource.WIKI,docs/3.1.0/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/utilities.html
https://qutip.org/docs/3.1.0/modules/qutip/utilities.html:8334,Energy Efficiency,energy,energy,8334,"unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [",MatchSource.WIKI,docs/3.1.0/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/utilities.html
https://qutip.org/docs/3.1.0/modules/qutip/utilities.html:8463,Energy Efficiency,energy,energy,8463," in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters",MatchSource.WIKI,docs/3.1.0/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/utilities.html
https://qutip.org/docs/3.1.0/modules/qutip/utilities.html:8543,Energy Efficiency,energy,energy,8543," * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; ----",MatchSource.WIKI,docs/3.1.0/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/utilities.html
https://qutip.org/docs/3.1.0/modules/qutip/utilities.html:8617,Energy Efficiency,energy,energy,8617,"nergy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz ",MatchSource.WIKI,docs/3.1.0/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/utilities.html
https://qutip.org/docs/3.1.0/modules/qutip/utilities.html:8755,Energy Efficiency,energy,energy,8755,"ay; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def view_methods(Q):; """"""; View the methods and corresponding doc strings; for a Qobj class. Parameters;",MatchSource.WIKI,docs/3.1.0/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/utilities.html
https://qutip.org/docs/3.1.0/modules/qutip/utilities.html:8835,Energy Efficiency,energy,energy,8835,"= w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def view_methods(Q):; """"""; View the methods and corresponding doc strings; for a Qobj class. Parameters; ----------; Q : Qobj; Input Quantum object. """"""; meth = dir(Q); qobj_prop",MatchSource.WIKI,docs/3.1.0/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/utilities.html
https://qutip.org/docs/3.1.0/modules/qutip/utilities.html:8909,Energy Efficiency,energy,energy,8909,"energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def view_methods(Q):; """"""; View the methods and corresponding doc strings; for a Qobj class. Parameters; ----------; Q : Qobj; Input Quantum object. """"""; meth = dir(Q); qobj_props = ['data', 'dims', 'isherm', 'shape', 'type']; pub_meth = [x for x in ",MatchSource.WIKI,docs/3.1.0/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/utilities.html
https://qutip.org/docs/3.1.0/modules/qutip/utilities.html:9049,Energy Efficiency,energy,energy,9049," The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def view_methods(Q):; """"""; View the methods and corresponding doc strings; for a Qobj class. Parameters; ----------; Q : Qobj; Input Quantum object. """"""; meth = dir(Q); qobj_props = ['data', 'dims', 'isherm', 'shape', 'type']; pub_meth = [x for x in meth if x.find('_') and x not in qobj_props]; ml = max([len(x) for x in pub_meth]); nl = len(Q.__class__.__name__ + 'Class Methods:'); print(Q.__cla",MatchSource.WIKI,docs/3.1.0/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/utilities.html
https://qutip.org/docs/3.1.0/modules/qutip/utilities.html:9129,Energy Efficiency,energy,energy,9129," w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def view_methods(Q):; """"""; View the methods and corresponding doc strings; for a Qobj class. Parameters; ----------; Q : Qobj; Input Quantum object. """"""; meth = dir(Q); qobj_props = ['data', 'dims', 'isherm', 'shape', 'type']; pub_meth = [x for x in meth if x.find('_') and x not in qobj_props]; ml = max([len(x) for x in pub_meth]); nl = len(Q.__class__.__name__ + 'Class Methods:'); print(Q.__class__.__name__ + ' Class Methods:'); print('-' * nl); for ii in range(len(p",MatchSource.WIKI,docs/3.1.0/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/utilities.html
https://qutip.org/docs/3.1.0/modules/qutip/utilities.html:9203,Energy Efficiency,energy,energy,9203,"rom unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def view_methods(Q):; """"""; View the methods and corresponding doc strings; for a Qobj class. Parameters; ----------; Q : Qobj; Input Quantum object. """"""; meth = dir(Q); qobj_props = ['data', 'dims', 'isherm', 'shape', 'type']; pub_meth = [x for x in meth if x.find('_') and x not in qobj_props]; ml = max([len(x) for x in pub_meth]); nl = len(Q.__class__.__name__ + 'Class Methods:'); print(Q.__class__.__name__ + ' Class Methods:'); print('-' * nl); for ii in range(len(pub_meth)):; m = getattr(Q, pub_meth[ii]); meth_str = m.__doc__; ind = me",MatchSource.WIKI,docs/3.1.0/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/utilities.html
https://qutip.org/docs/3.1.0/modules/qutip/utilities.html:9414,Energy Efficiency,energy,energy,9414,"return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def view_methods(Q):; """"""; View the methods and corresponding doc strings; for a Qobj class. Parameters; ----------; Q : Qobj; Input Quantum object. """"""; meth = dir(Q); qobj_props = ['data', 'dims', 'isherm', 'shape', 'type']; pub_meth = [x for x in meth if x.find('_') and x not in qobj_props]; ml = max([len(x) for x in pub_meth]); nl = len(Q.__class__.__name__ + 'Class Methods:'); print(Q.__class__.__name__ + ' Class Methods:'); print('-' * nl); for ii in range(len(pub_meth)):; m = getattr(Q, pub_meth[ii]); meth_str = m.__doc__; ind = meth_str.find('\n'); pub_len = len(pub_meth[ii] + ': '); print(pub_meth[ii] + ':' + ' ' * (ml+3-pub_len) + meth_str[:ind]). def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].sp",MatchSource.WIKI,docs/3.1.0/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/utilities.html
https://qutip.org/docs/3.1.0/modules/qutip/utilities.html:9494,Energy Efficiency,energy,energy,9494,"eV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def view_methods(Q):; """"""; View the methods and corresponding doc strings; for a Qobj class. Parameters; ----------; Q : Qobj; Input Quantum object. """"""; meth = dir(Q); qobj_props = ['data', 'dims', 'isherm', 'shape', 'type']; pub_meth = [x for x in meth if x.find('_') and x not in qobj_props]; ml = max([len(x) for x in pub_meth]); nl = len(Q.__class__.__name__ + 'Class Methods:'); print(Q.__class__.__name__ + ' Class Methods:'); print('-' * nl); for ii in range(len(pub_meth)):; m = getattr(Q, pub_meth[ii]); meth_str = m.__doc__; ind = meth_str.find('\n'); pub_len = len(pub_meth[ii] + ': '); print(pub_meth[ii] + ':' + ' ' * (ml+3-pub_len) + meth_str[:ind]). def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d",MatchSource.WIKI,docs/3.1.0/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/utilities.html
https://qutip.org/docs/3.1.0/modules/qutip/utilities.html:9568,Energy Efficiency,energy,energy,9568,"he old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def view_methods(Q):; """"""; View the methods and corresponding doc strings; for a Qobj class. Parameters; ----------; Q : Qobj; Input Quantum object. """"""; meth = dir(Q); qobj_props = ['data', 'dims', 'isherm', 'shape', 'type']; pub_meth = [x for x in meth if x.find('_') and x not in qobj_props]; ml = max([len(x) for x in pub_meth]); nl = len(Q.__class__.__name__ + 'Class Methods:'); print(Q.__class__.__name__ + ' Class Methods:'); print('-' * nl); for ii in range(len(pub_meth)):; m = getattr(Q, pub_meth[ii]); meth_str = m.__doc__; ind = meth_str.find('\n'); pub_len = len(pub_meth[ii] + ': '); print(pub_meth[ii] + ':' + ' ' * (ml+3-pub_len) + meth_str[:ind]). def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_lis",MatchSource.WIKI,docs/3.1.0/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/utilities.html
https://qutip.org/docs/3.1.0/modules/qutip/utilities.html:5171,Modifiability,coupling,coupling,5171,"n 1.0 / (np.exp(w / w_th) - 1.0). else:; if (w_th > 0) and np.exp(w / w_th) != 1.0:; return 1.0 / (np.exp(w / w_th) - 1.0); else:; return 0.0. [docs]def linspace_with(start, stop, num=50, elems=[]):; """"""; Return an array of numbers sampled over specified interval; with additional elements added. Returns `num` spaced array with elements from `elems` inserted; if not already included in set. Returned sample array is not evenly spaced if addtional elements; are added. Parameters; ----------; start : int; The starting value of the sequence.; stop : int; The stoping values of the sequence.; num : int, optional; Number of samples to generate.; elems : list/ndarray, optional; Requested elements to include in array. Returns; -------; samples : ndadrray; Original equally spaced sample array with additional; elements added.; """"""; elems = np.array(elems); lspace = np.linspace(start, stop, num); return np.union1d(lspace, elems). [docs]def clebsch(j1, j2, j3, m1, m2, m3):; """"""Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters; ----------; j1 : float; Total angular momentum 1. j2 : float; Total angular momentum 2. j3 : float; Total angular momentum 3. m1 : float; z-component of angular momentum 1. m2 : float; z-component of angular momentum 2. m3 : float; z-component of angular momentum 3. Returns; -------; cg_coeff : float; Requested Clebsch-Gordan coefficient. """"""; if m3 != m1 + m2:; return 0; vmin = int(np.max([-j1 + j2 + m3, -j1 + m1, 0])); vmax = int(np.min([j2 + j3 + m1, j3 - j1 + j2, j3 + m3])). C = np.sqrt((2.0 * j3 + 1.0) * factorial(j3 + j1 - j2) *; factorial(j3 - j1 + j2) * factorial(j1 + j2 - j3) *; factorial(j3 + m3) * factorial(j3 - m3) /; (factorial(j1 + j2 + j3 + 1) *; factorial(j1 - m1) * factorial(j1 + m1) *; factorial(j2 - m2) * factorial(j2 + m2))); S = 0; for v in range(vmin, vmax + 1):; S += (-1.0) ** (v + j2 + m2) / factorial(v) * \; factorial(j2 + j3 + m1 - v) * factorial(j1 - m1 + v) / \; factorial(j3 -",MatchSource.WIKI,docs/3.1.0/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/utilities.html
https://qutip.org/docs/3.1.0/modules/qutip/visualization.html:246,Deployability,install,installation,246,"﻿. qutip.visualization — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.visualization; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following dis",MatchSource.WIKI,docs/3.1.0/modules/qutip/visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/visualization.html
https://qutip.org/docs/3.1.0/modules/qutip/visualization.html:40837,Deployability,update,updated,40837,"ure instance; The figure canvas on which the plot will be drawn. ax : a matplotlib axis instance; The axis context in which the plot will be drawn. figsize : (width, height); The size of the matplotlib figure (in inches) if it is to be created; (that is, if no 'fig' and 'ax' arguments are passed). Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. """"""; if not isket(ket):; raise Exception(""Schmidt plot works only for pure states, i.e. kets.""). if not fig and not ax:; fig, ax = plt.subplots(1, 1, figsize=figsize). dim_list = ket.dims[0]. if splitting is None:; splitting = (len(dim_list) + 1) // 2. if isinstance(labels_iteration, int):; labels_iteration = labels_iteration, labels_iteration. ketdata = ket.full(). dim_list_y = dim_list[:splitting]; dim_list_x = dim_list[splitting:]. size_x = np.prod(dim_list_x); size_y = np.prod(dim_list_y). ketdata = ketdata.reshape((size_y, size_x)). dim_list_small_x = dim_list_x[:labels_iteration[1]]; dim_list_small_y = dim_list_y[:labels_iteration[0]]. quadrants_x = np.prod(dim_list_small_x); quadrants_y = np.prod(dim_list_small_y). ticks_x = [size_x / quadrants_x * (i + 0.5); for i in range(quadrants_x)]; ticks_y = [size_y / quadrants_y * (quadrants_y - i - 0.5); for i in range(quadrants_y)]. labels_x = [_sequence_to_latex(_index_to_sequence(i*size_x // quadrants_x,; dim_list=dim_list_x)); for i in range(quadrants_x)]; labels_y = [_sequence_to_latex(_index_to_sequence(i*size_y // quadrants_y,; dim_list=dim_list_y)); for i in range(quadrants_y)]. ax.set_xticks(ticks_x); ax.set_xticklabels(labels_x); ax.set_yticks(ticks_y); ax.set_yticklabels(labels_y); ax.set_xlabel(""last particles""); ax.set_ylabel(""first particles""). ax.imshow(complex_array_to_rgb(ketdata, theme=theme),; interpolation=""none"",; extent=(0, size_x, 0, size_y)). return fig, ax. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/modules/qutip/visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/visualization.html
https://qutip.org/docs/3.1.0/modules/qutip/visualization.html:4943,Energy Efficiency,power,powers,4943,"rt numpy as np; from numpy import pi, array, sin, cos, angle. try:; import matplotlib.pyplot as plt; import matplotlib as mpl; from matplotlib import cm; from mpl_toolkits.mplot3d import Axes3D; except:; pass. from qutip.qobj import Qobj, isket; from qutip.states import ket2dm; from qutip.wigner import wigner; from qutip.tensor import tensor; from qutip.matplotlib_utilities import complex_phase_cmap; from qutip.superoperator import vector_to_operator; from qutip.superop_reps import _pauli_basis, to_super; from qutip.tensor import flatten. from qutip import settings. # Adopted from the SciPy Cookbook.; def _blob(x, y, w, w_max, area, cmap=None):; """"""; Draws a square-shaped blob with the given area (< 1) at; the given coordinates.; """"""; hs = np.sqrt(area) / 2; xcorners = array([x - hs, x + hs, x + hs, x - hs]); ycorners = array([y - hs, y - hs, y + hs, y + hs]). plt.fill(xcorners, ycorners,; color=cmap(int((w + w_max) * 256 / (2 * w_max)))). def _isqubitdims(dims):; """"""Checks whether all entries in a dims list are integer powers of 2. Parameters; ----------; dims : nested list of ints; Dimensions to be checked. Returns; -------; isqubitdims : bool; True if and only if every member of the flattened dims; list is an integer power of 2.; """"""; return all([; 2**np.floor(np.log2(dim)) == dim; for dim in flatten(dims); ]). def _cb_labels(left_dims):; """"""Creates plot labels for matrix elements in the computational basis. Parameters; ----------; left_dims : flat list of ints; Dimensions of the left index of a density operator. E. g.; [2, 3] for a qubit tensored with a qutrit. Returns; -------; left_labels, right_labels : lists of strings; Labels for the left and right indices of a density operator; (kets and bras, respectively).; """"""; # FIXME: assumes dims, such that we only need left_dims == dims[0].; basis_labels = list(map("","".join, it.product(*[; map(str, range(dim)); for dim in left_dims; ]))); return [; map(fmt.format, basis_labels) for fmt in; (; r""$|{}\rangle$"",; r""$\la",MatchSource.WIKI,docs/3.1.0/modules/qutip/visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/visualization.html
https://qutip.org/docs/3.1.0/modules/qutip/visualization.html:5147,Energy Efficiency,power,power,5147,"xes3D; except:; pass. from qutip.qobj import Qobj, isket; from qutip.states import ket2dm; from qutip.wigner import wigner; from qutip.tensor import tensor; from qutip.matplotlib_utilities import complex_phase_cmap; from qutip.superoperator import vector_to_operator; from qutip.superop_reps import _pauli_basis, to_super; from qutip.tensor import flatten. from qutip import settings. # Adopted from the SciPy Cookbook.; def _blob(x, y, w, w_max, area, cmap=None):; """"""; Draws a square-shaped blob with the given area (< 1) at; the given coordinates.; """"""; hs = np.sqrt(area) / 2; xcorners = array([x - hs, x + hs, x + hs, x - hs]); ycorners = array([y - hs, y - hs, y + hs, y + hs]). plt.fill(xcorners, ycorners,; color=cmap(int((w + w_max) * 256 / (2 * w_max)))). def _isqubitdims(dims):; """"""Checks whether all entries in a dims list are integer powers of 2. Parameters; ----------; dims : nested list of ints; Dimensions to be checked. Returns; -------; isqubitdims : bool; True if and only if every member of the flattened dims; list is an integer power of 2.; """"""; return all([; 2**np.floor(np.log2(dim)) == dim; for dim in flatten(dims); ]). def _cb_labels(left_dims):; """"""Creates plot labels for matrix elements in the computational basis. Parameters; ----------; left_dims : flat list of ints; Dimensions of the left index of a density operator. E. g.; [2, 3] for a qubit tensored with a qutrit. Returns; -------; left_labels, right_labels : lists of strings; Labels for the left and right indices of a density operator; (kets and bras, respectively).; """"""; # FIXME: assumes dims, such that we only need left_dims == dims[0].; basis_labels = list(map("","".join, it.product(*[; map(str, range(dim)); for dim in left_dims; ]))); return [; map(fmt.format, basis_labels) for fmt in; (; r""$|{}\rangle$"",; r""$\langle{}|$""; ); ]. # Adopted from the SciPy Cookbook.; [docs]def hinton(rho, xlabels=None, ylabels=None, title=None, ax=None, cmap=None,; label_top=True):; """"""Draws a Hinton diagram for visu",MatchSource.WIKI,docs/3.1.0/modules/qutip/visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/visualization.html
https://qutip.org/docs/3.1.0/modules/qutip/visualization.html:16169,Energy Efficiency,energy,energy,16169,"None:; fig = plt.figure(); ax = Axes3D(fig, azim=-35, elev=35). ax.bar3d(xpos, ypos, zpos, dx, dy, dz, color=colors). if title and fig:; ax.set_title(title). # x axis; ax.axes.w_xaxis.set_major_locator(plt.IndexLocator(1, -0.5)); if xlabels:; ax.set_xticklabels(xlabels); ax.tick_params(axis='x', labelsize=12). # y axis; ax.axes.w_yaxis.set_major_locator(plt.IndexLocator(1, -0.5)); if ylabels:; ax.set_yticklabels(ylabels); ax.tick_params(axis='y', labelsize=12). # z axis; if limits and isinstance(limits, list):; ax.set_zlim3d(limits); else:; ax.set_zlim3d([0, 1]) # use min/max; # ax.set_zlabel('abs'). # color axis; if colorbar:; cax, kw = mpl.colorbar.make_axes(ax, shrink=.75, pad=.0); cb = mpl.colorbar.ColorbarBase(cax, cmap=cmap, norm=norm); cb.set_ticks([-pi, -pi / 2, 0, pi / 2, pi]); cb.set_ticklabels(; (r'$-\pi$', r'$-\pi/2$', r'$0$', r'$\pi/2$', r'$\pi$')); cb.set_label('arg'). return fig, ax. [docs]def plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False,; figsize=(8, 12), fig=None, ax=None):; """"""; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters; ----------. H_list : List of Qobj; A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises; ------. ValueError; Input argument is not valid. """""". if not isi",MatchSource.WIKI,docs/3.1.0/modules/qutip/visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/visualization.html
https://qutip.org/docs/3.1.0/modules/qutip/visualization.html:16236,Energy Efficiency,energy,energy,16236,"lor=colors). if title and fig:; ax.set_title(title). # x axis; ax.axes.w_xaxis.set_major_locator(plt.IndexLocator(1, -0.5)); if xlabels:; ax.set_xticklabels(xlabels); ax.tick_params(axis='x', labelsize=12). # y axis; ax.axes.w_yaxis.set_major_locator(plt.IndexLocator(1, -0.5)); if ylabels:; ax.set_yticklabels(ylabels); ax.tick_params(axis='y', labelsize=12). # z axis; if limits and isinstance(limits, list):; ax.set_zlim3d(limits); else:; ax.set_zlim3d([0, 1]) # use min/max; # ax.set_zlabel('abs'). # color axis; if colorbar:; cax, kw = mpl.colorbar.make_axes(ax, shrink=.75, pad=.0); cb = mpl.colorbar.ColorbarBase(cax, cmap=cmap, norm=norm); cb.set_ticks([-pi, -pi / 2, 0, pi / 2, pi]); cb.set_ticklabels(; (r'$-\pi$', r'$-\pi/2$', r'$0$', r'$\pi/2$', r'$\pi$')); cb.set_label('arg'). return fig, ax. [docs]def plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False,; figsize=(8, 12), fig=None, ax=None):; """"""; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters; ----------. H_list : List of Qobj; A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises; ------. ValueError; Input argument is not valid. """""". if not isinstance(H_list, list):; raise ValueError(""H_list must be a list of Qobj instances""). if not fig and not a",MatchSource.WIKI,docs/3.1.0/modules/qutip/visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/visualization.html
https://qutip.org/docs/3.1.0/modules/qutip/visualization.html:16283,Energy Efficiency,energy,energy,16283,"plt.IndexLocator(1, -0.5)); if xlabels:; ax.set_xticklabels(xlabels); ax.tick_params(axis='x', labelsize=12). # y axis; ax.axes.w_yaxis.set_major_locator(plt.IndexLocator(1, -0.5)); if ylabels:; ax.set_yticklabels(ylabels); ax.tick_params(axis='y', labelsize=12). # z axis; if limits and isinstance(limits, list):; ax.set_zlim3d(limits); else:; ax.set_zlim3d([0, 1]) # use min/max; # ax.set_zlabel('abs'). # color axis; if colorbar:; cax, kw = mpl.colorbar.make_axes(ax, shrink=.75, pad=.0); cb = mpl.colorbar.ColorbarBase(cax, cmap=cmap, norm=norm); cb.set_ticks([-pi, -pi / 2, 0, pi / 2, pi]); cb.set_ticklabels(; (r'$-\pi$', r'$-\pi/2$', r'$0$', r'$\pi/2$', r'$\pi$')); cb.set_label('arg'). return fig, ax. [docs]def plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False,; figsize=(8, 12), fig=None, ax=None):; """"""; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters; ----------. H_list : List of Qobj; A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises; ------. ValueError; Input argument is not valid. """""". if not isinstance(H_list, list):; raise ValueError(""H_list must be a list of Qobj instances""). if not fig and not ax:; fig, ax = plt.subplots(1, 1, figsize=figsize). H = H_list[0]; N = H.shape[0] if N == 0 else mi",MatchSource.WIKI,docs/3.1.0/modules/qutip/visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/visualization.html
https://qutip.org/docs/3.1.0/modules/qutip/visualization.html:16615,Energy Efficiency,energy,energy,16615,"s; if limits and isinstance(limits, list):; ax.set_zlim3d(limits); else:; ax.set_zlim3d([0, 1]) # use min/max; # ax.set_zlabel('abs'). # color axis; if colorbar:; cax, kw = mpl.colorbar.make_axes(ax, shrink=.75, pad=.0); cb = mpl.colorbar.ColorbarBase(cax, cmap=cmap, norm=norm); cb.set_ticks([-pi, -pi / 2, 0, pi / 2, pi]); cb.set_ticklabels(; (r'$-\pi$', r'$-\pi/2$', r'$0$', r'$\pi/2$', r'$\pi$')); cb.set_label('arg'). return fig, ax. [docs]def plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False,; figsize=(8, 12), fig=None, ax=None):; """"""; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters; ----------. H_list : List of Qobj; A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises; ------. ValueError; Input argument is not valid. """""". if not isinstance(H_list, list):; raise ValueError(""H_list must be a list of Qobj instances""). if not fig and not ax:; fig, ax = plt.subplots(1, 1, figsize=figsize). H = H_list[0]; N = H.shape[0] if N == 0 else min(H.shape[0], N). xticks = []; yticks = []. x = 0; evals0 = H.eigenenergies(eigvals=N) / (2 * np.pi); for e_idx, e in enumerate(evals0[:N]):; ax.plot([x, x + 2], np.array([1, 1]) * e, 'b', linewidth=2); yticks.append(e); xticks.append(x + 1); x += 2. for H1 in H_list[1:]",MatchSource.WIKI,docs/3.1.0/modules/qutip/visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/visualization.html
https://qutip.org/docs/3.1.0/modules/qutip/visualization.html:16681,Energy Efficiency,energy,energy,16681,"et_zlim3d([0, 1]) # use min/max; # ax.set_zlabel('abs'). # color axis; if colorbar:; cax, kw = mpl.colorbar.make_axes(ax, shrink=.75, pad=.0); cb = mpl.colorbar.ColorbarBase(cax, cmap=cmap, norm=norm); cb.set_ticks([-pi, -pi / 2, 0, pi / 2, pi]); cb.set_ticklabels(; (r'$-\pi$', r'$-\pi/2$', r'$0$', r'$\pi/2$', r'$\pi$')); cb.set_label('arg'). return fig, ax. [docs]def plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False,; figsize=(8, 12), fig=None, ax=None):; """"""; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters; ----------. H_list : List of Qobj; A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises; ------. ValueError; Input argument is not valid. """""". if not isinstance(H_list, list):; raise ValueError(""H_list must be a list of Qobj instances""). if not fig and not ax:; fig, ax = plt.subplots(1, 1, figsize=figsize). H = H_list[0]; N = H.shape[0] if N == 0 else min(H.shape[0], N). xticks = []; yticks = []. x = 0; evals0 = H.eigenenergies(eigvals=N) / (2 * np.pi); for e_idx, e in enumerate(evals0[:N]):; ax.plot([x, x + 2], np.array([1, 1]) * e, 'b', linewidth=2); yticks.append(e); xticks.append(x + 1); x += 2. for H1 in H_list[1:]:. H = H + H1; evals1 = H.eigenenergies() / (2 * np.pi). for e_idx, e in enum",MatchSource.WIKI,docs/3.1.0/modules/qutip/visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/visualization.html
https://qutip.org/docs/3.1.0/modules/qutip/visualization.html:19531,Energy Efficiency,green,green,19531,"_fock_distribution(rho, offset=0, fig=None, ax=None,; figsize=(8, 6), title=None, unit_y_range=True):; """"""; Plot the Fock distribution for a density matrix (or ket) that describes; an oscillator mode. Parameters; ----------; rho : :class:`qutip.qobj.Qobj`; The density matrix (or ket) of the state to visualize. fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. title : string; An optional title for the figure. figsize : (width, height); The size of the matplotlib figure (in inches) if it is to be created; (that is, if no 'fig' and 'ax' arguments are passed). Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure.; """""". if not fig and not ax:; fig, ax = plt.subplots(1, 1, figsize=figsize). if isket(rho):; rho = ket2dm(rho). N = rho.shape[0]. ax.bar(np.arange(offset, offset + N) - .4, np.real(rho.diag()),; color=""green"", alpha=0.6, width=0.8); if unit_y_range:; ax.set_ylim(0, 1). ax.set_xlim(-.5 + offset, N + offset); ax.set_xlabel('Fock number', fontsize=12); ax.set_ylabel('Occupation probability', fontsize=12). if title:; ax.set_title(title). return fig, ax. def fock_distribution(rho, offset=0, fig=None, ax=None,; figsize=(8, 6), title=None, unit_y_range=True):; warnings.warn(""Deprecated: Use plot_fock_distribution""); return plot_fock_distribution(rho, offset=offset, fig=fig, ax=ax,; figsize=figsize, title=title,; unit_y_range=unit_y_range). [docs]def plot_wigner(rho, fig=None, ax=None, figsize=(8, 4),; cmap=None, alpha_max=7.5, colorbar=False,; method='iterative', projection='2d'):; """"""; Plot the the Wigner function for a density matrix (or ket) that describes; an oscillator mode. Parameters; ----------; rho : :class:`qutip.qobj.Qobj`; The density matrix (or ket) of the state to visualize. fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotli",MatchSource.WIKI,docs/3.1.0/modules/qutip/visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/visualization.html
https://qutip.org/docs/3.1.0/modules/qutip/visualization.html:14706,Safety,avoid,avoid,14706,"gs; list of y labels. title : string; title of the plot (optional). limits : list/array with two float numbers; The z-axis limits [min, max] (optional). phase_limits : list/array with two float numbers; The phase-axis (colorbar) limits [min, max] (optional). ax : a matplotlib axes instance; The axes context in which the plot will be drawn. threshold: float (None); Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises; ------; ValueError; Input argument is not valid. """""". if isinstance(M, Qobj):; # extract matrix data from Qobj; M = M.full(). n = np.size(M); xpos, ypos = np.meshgrid(range(M.shape[0]), range(M.shape[1])); xpos = xpos.T.flatten() - 0.5; ypos = ypos.T.flatten() - 0.5; zpos = np.zeros(n); dx = dy = 0.8 * np.ones(n); Mvec = M.flatten(); dz = abs(Mvec). # make small numbers real, to avoid random colors; idx, = np.where(abs(Mvec) < 0.001); Mvec[idx] = abs(Mvec[idx]). if phase_limits: # check that limits is a list type; phase_min = phase_limits[0]; phase_max = phase_limits[1]; else:; phase_min = -pi; phase_max = pi. norm = mpl.colors.Normalize(phase_min, phase_max); cmap = complex_phase_cmap(). colors = cmap(norm(angle(Mvec))); if threshold is not None:; colors[:, 3] = 1 * (dz > threshold). if ax is None:; fig = plt.figure(); ax = Axes3D(fig, azim=-35, elev=35). ax.bar3d(xpos, ypos, zpos, dx, dy, dz, color=colors). if title and fig:; ax.set_title(title). # x axis; ax.axes.w_xaxis.set_major_locator(plt.IndexLocator(1, -0.5)); if xlabels:; ax.set_xticklabels(xlabels); ax.tick_params(axis='x', labelsize=12). # y axis; ax.axes.w_yaxis.set_major_locator(plt.IndexLocator(1, -0.5)); if ylabels:; ax.set_yticklabels(ylabels); ax.tick_params(axis='y', labelsize=12). # z axis; if limits and isinstance(limits, list):; ax.set_zlim3d(limits); else:; ax.set_zlim3d([0, 1]) # use mi",MatchSource.WIKI,docs/3.1.0/modules/qutip/visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/visualization.html
https://qutip.org/docs/3.1.0/modules/qutip/visualization.html:33758,Security,access,access,33758,"cle. style : 'ket' (default), 'bra' or 'bare'; Style of LaTeX (i.e. |01> or <01| or 01, respectively). Returns; -------; latex : str; LaTeX output. """"""; if style == 'ket':; latex = ""$\\left|{0}\\right\\rangle$""; elif style == 'bra':; latex = ""$\\left\\langle{0}\\right|$""; elif style == 'bare':; latex = ""${0}$""; else:; raise Exception(""No such style.""); return latex.format("""".join(map(str, seq))). [docs]def plot_qubism(ket, theme='light', how='pairs',; grid_iteration=1, legend_iteration=0,; fig=None, ax=None, figsize=(6, 6)):; """"""; Qubism plot for pure states of many qudits.; Works best for spin chains, especially with even number of particles; of the same dimension.; Allows to see entanglement between first 2*k particles and the rest. More information:; J. Rodriguez-Laguna, P. Migdal,; M. Ibanez Berganza, M. Lewenstein, G. Sierra,; ""Qubism: self-similar visualization of many-body wavefunctions"",; New J. Phys. 14 053028 (2012), arXiv:1112.3560,; http://dx.doi.org/10.1088/1367-2630/14/5/053028 (open access). Parameters; ----------; ket : Qobj; Pure state for plotting. theme : 'light' (default) or 'dark'; Set coloring theme for mapping complex values into colors.; See: complex_array_to_rgb. how : 'pairs' (default), 'pairs_skewed' or 'before_after'; Type of Qubism plotting.; Options:; 'pairs' - typical coordinates,; 'pairs_skewed' - for ferromagnetic/antriferromagnetic plots,; 'before_after' - related to Schmidt plot (see also: plot_schmidt). grid_iteration : int (default 1); Helper lines to be drawn on plot.; Show tiles for 2*grid_iteration particles vs all others. legend_iteration : int (default 0) or 'grid_iteration' or 'all'; Show labels for first 2*legend_iteration particles.; Option 'grid_iteration' sets the same number of particles; as for grid_iteration.; Option 'all' makes label for all particles.; Typically it should be 0, 1, 2 or perhaps 3. fig : a matplotlib figure instance; The figure canvas on which the plot will be drawn. ax : a matplotlib axis instance; T",MatchSource.WIKI,docs/3.1.0/modules/qutip/visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/visualization.html
https://qutip.org/docs/3.1.0/modules/qutip/wigner.html:239,Deployability,install,installation,239,"﻿. qutip.wigner — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.wigner; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; #",MatchSource.WIKI,docs/3.1.0/modules/qutip/wigner.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/wigner.html
https://qutip.org/docs/3.1.0/modules/qutip/wigner.html:15415,Deployability,update,updated,15415,"s at which to calculate the Q function. phi : array_like; phi-coordinates at which to calculate the Q function. Returns; -------. Q, THETA, PHI : 2d-array; Values representing the spin Q function at the values specified; by THETA and PHI. """""". if rho.type == 'bra':; rho = rho.dag(). if rho.type == 'ket':; rho = ket2dm(rho). J = rho.shape[0]; j = (J - 1) / 2. THETA, PHI = meshgrid(theta, phi). Q = np.zeros_like(THETA, dtype=complex). for m1 in arange(-j, j+1):. Q += binom(2*j, j+m1) * cos(THETA/2) ** (2*(j-m1)) * sin(THETA/2) ** (2*(j+m1)) * \; rho.data[int(j-m1), int(j-m1)]. for m2 in arange(m1+1, j+1):. Q += (sqrt(binom(2*j, j+m1)) * sqrt(binom(2*j, j+m2)) *; cos(THETA/2) ** (2*j-m1-m2) * sin(THETA/2) ** (2*j+m1+m2)) * \; (exp(1j * (m2-m1) * PHI) * rho.data[int(j-m1), int(j-m2)] +; exp(1j * (m1-m2) * PHI) * rho.data[int(j-m2), int(j-m1)]). return Q.real, THETA, PHI. def _rho_kq(rho, j, k, q):; v = 0j. for m1 in arange(-j, j+1):; for m2 in arange(-j, j+1):; v += (-1)**(j - m1 - q) * clebsch(j, j, k, m1, -m2,; q) * rho.data[m1 + j, m2 + j]. return v. def spin_wigner(rho, theta, phi):; """"""Wigner function for spins. Parameters; ----------. state : qobj; A state vector or density matrix for a spin-j quantum system. theta : array_like; theta-coordinates at which to calculate the Q function. phi : array_like; phi-coordinates at which to calculate the Q function. Returns; -------. W, THETA, PHI : 2d-array; Values representing the spin Wigner function at the values specified; by THETA and PHI. .. note::. Experimental. """""". if rho.type == 'bra':; rho = rho.dag(). if rho.type == 'ket':; rho = ket2dm(rho). J = rho.shape[0]; j = (J - 1) / 2. THETA, PHI = meshgrid(theta, phi). W = np.zeros_like(THETA, dtype=complex). for k in range(int(2 * j)+1):; for q in range(-k, k+1):; W += _rho_kq(rho, j, k, q) * sph_harm(q, k, PHI, THETA). return W, THETA, PHI. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/modules/qutip/wigner.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/wigner.html
https://qutip.org/docs/3.1.0/modules/qutip/wigner.html:4864,Energy Efficiency,efficient,efficient,4864,"ilities import clebsch; from scipy.misc import factorial. [docs]def wigner(psi, xvec, yvec, method='iterative', g=sqrt(2), parfor=False):; """"""Wigner function for a state vector or density matrix at points; `xvec + i * yvec`. Parameters; ----------. state : qobj; A state vector or density matrix. xvec : array_like; x-coordinates at which to calculate the Wigner function. yvec : array_like; y-coordinates at which to calculate the Wigner function. Does not; apply to the 'fft' method. g : float; Scaling factor for `a = 0.5 * g * (x + iy)`, default `g = sqrt(2)`. method : string {'iterative', 'laguerre', 'fft'}; Select method 'iterative', 'laguerre', or 'fft', where 'iterative' uses; an iterative method to evaluate the Wigner functions for density; matrices :math:`|m><n|`, while 'laguerre' uses the Laguerre polynomials; in scipy for the same task. The 'fft' method evaluates the Fourier; transform of the density matrix. The 'iterative' method is default, and; in general recommended, but the 'laguerre' method is more efficient for; very sparse density matrices (e.g., superpositions of Fock states in a; large Hilbert space). The 'fft' method is the preferred method for; dealing with density matrices that have a large number of excitations; (>~50). parfor : bool {False, True}; Flag for calculating the Laguerre polynomial based Wigner function; method='laguerre' in parallel using the parfor function. Returns; -------. W : array; Values representing the Wigner function calculated over the specified; range [xvec,yvec]. yvex : array; FFT ONLY. Returns the y-coordinate values calculated via the Fourier; transform. Notes; -----; The 'fft' method accepts only an xvec input for the x-coordinate.; The y-coordinates are calculated internally. References; ----------. Ulf Leonhardt,; Measuring the Quantum State of Light, (Cambridge University Press, 1997). """""". if not (psi.type == 'ket' or psi.type == 'oper' or psi.type == 'bra'):; raise TypeError('Input state is not a valid operator.')",MatchSource.WIKI,docs/3.1.0/modules/qutip/wigner.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/wigner.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:4498,Availability,error,errors,4498,"asses that define the dynamics of the (quantum) system and target evolution; to be optimised.; The contols are also defined here, i.e. the dynamics generators (Hamiltonians,; Limbladians etc). The dynamics for the time slices are calculated here, along; with the evolution as determined by the control amplitudes. See the subclass descriptions and choose the appropriate class for the; application. The choice depends on the type of matrix used to define; the dynamics. These class implement functions for getting the dynamics generators for; the combined (drift + ctrls) dynamics with the approriate operator applied. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """"""; import os; import numpy as np; import scipy.linalg as la; from six import string_types; # QuTiP logging; import qutip.logging as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl. [docs]class Dynamics:; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before any of the methods; can be used. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; Note value should be set using set_log_level. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of c",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:4508,Availability,error,errors,4508,"asses that define the dynamics of the (quantum) system and target evolution; to be optimised.; The contols are also defined here, i.e. the dynamics generators (Hamiltonians,; Limbladians etc). The dynamics for the time slices are calculated here, along; with the evolution as determined by the control amplitudes. See the subclass descriptions and choose the appropriate class for the; application. The choice depends on the type of matrix used to define; the dynamics. These class implement functions for getting the dynamics generators for; the combined (drift + ctrls) dynamics with the approriate operator applied. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """"""; import os; import numpy as np; import scipy.linalg as la; from six import string_types; # QuTiP logging; import qutip.logging as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl. [docs]class Dynamics:; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before any of the methods; can be used. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; Note value should be set using set_log_level. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of c",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:5930,Availability,error,error,5930,"tributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; Note value should be set using set_log_level. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer : PropagatorComputer (subclass instance); Used to compute the propagators and their gradients. fid_computer : FidelityComputer (subclass instance); Used to computer the fidelity error and the fidelity error; gradient. num_tslots : integer; Number of timeslots, aka timeslices. num_ctrls : integer; Number of controls.; Note this is set when get_num_ctrls is called based on the; length of ctrl_dyn_gen. evo_time : float; Total time for the evolution. tau : array[num_tslots] of float; Duration of each timeslot; Note that if this is set before initialize_controls is called; then num_tslots and evo_time are calculated from tau, otherwise; tau is generated from num_tslots and evo_time, that is; equal size time slices. time : array[num_tslots+1] of float; Cumulative time for the evolution, that is the time at the start; of each time slice. drift_dyn_gen : Qobj; Drift or system dynamics generator; Matrix defining the underlying dynamics of the system. ctrl_dyn_gen : List of Qobj; Control dynamics generator: ctrl_dyn_gen (); List of matrices defining the control dynamics. initial : Qobj; Starting state / gate; The matrix giving the initial state / g",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:5953,Availability,error,error,5953,"tributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; Note value should be set using set_log_level. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer : PropagatorComputer (subclass instance); Used to compute the propagators and their gradients. fid_computer : FidelityComputer (subclass instance); Used to computer the fidelity error and the fidelity error; gradient. num_tslots : integer; Number of timeslots, aka timeslices. num_ctrls : integer; Number of controls.; Note this is set when get_num_ctrls is called based on the; length of ctrl_dyn_gen. evo_time : float; Total time for the evolution. tau : array[num_tslots] of float; Duration of each timeslot; Note that if this is set before initialize_controls is called; then num_tslots and evo_time are calculated from tau, otherwise; tau is generated from num_tslots and evo_time, that is; equal size time slices. time : array[num_tslots+1] of float; Cumulative time for the evolution, that is the time at the start; of each time slice. drift_dyn_gen : Qobj; Drift or system dynamics generator; Matrix defining the underlying dynamics of the system. ctrl_dyn_gen : List of Qobj; Control dynamics generator: ctrl_dyn_gen (); List of matrices defining the control dynamics. initial : Qobj; Starting state / gate; The matrix giving the initial state / g",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:15123,Availability,error,errors,15123,"r = [False for x in range(n_ts)]; self.prop_eigen = \; [np.empty(shp[0], dtype=complex) for x in range(n_ts)]; self.dyn_gen_eigenvectors = \; [np.empty(shp, dtype=complex) for x in range(n_ts)]; self.dyn_gen_factormatrix = \; [np.empty(shp, dtype=complex) for x in range(n_ts)]. def _check_test_out_files(self):; cfg = self.config; if cfg.any_test_files():; if not cfg.check_create_test_out_dir():; cfg.reset_test_out_files(); else:; if self.stats is None:; logger.warn(""Cannot output test files when stats""; "" attribute is not set.""); self.config.test_out_amps = False; self.config.test_out_prop = False; self.config.test_out_prop_grad = False; self.config.test_out_evo = False. [docs] def initialize_controls(self, amps, init_tslots=True):; """"""; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated; """"""; self._check_test_out_files(). if not isinstance(self.prop_computer, propcomp.PropagatorComputer):; raise errors.UsageError(; ""No prop_computer (propagator computer) ""; ""set. A default should be assigned by the Dynamics subclass""). if not isinstance(self.tslot_computer, tslotcomp.TimeslotComputer):; raise errors.UsageError(; ""No tslot_computer (Timeslot computer)""; "" set. A default should be assigned by the Dynamics class""). if not isinstance(self.fid_computer, fidcomp.FideliyComputer):; raise errors.UsageError(; ""No fid_computer (Fidelity computer)""; "" set. A default should be assigned by the Dynamics subclass""). self.ctrl_amps = None; # Note this call is made just to initialise the num_ctrls attrib; self.get_num_ctrls(). if init_tslots:; self.init_time_slots(); self._init_lists(); self.tslot_computer.init_comp(); self.fid_computer.init_comp(); self._ctrls_initialized = True; self.update_ctrl_amps(amps). def check_ctrls_initialized(self):; if not self._ctrls_initialized:; raise errors.UsageError(; ""Controls not initialised. ""; ""Ensure Dynamics.initialize_controls has been ""; ""ex",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:15324,Availability,error,errors,15324,"n_gen_factormatrix = \; [np.empty(shp, dtype=complex) for x in range(n_ts)]. def _check_test_out_files(self):; cfg = self.config; if cfg.any_test_files():; if not cfg.check_create_test_out_dir():; cfg.reset_test_out_files(); else:; if self.stats is None:; logger.warn(""Cannot output test files when stats""; "" attribute is not set.""); self.config.test_out_amps = False; self.config.test_out_prop = False; self.config.test_out_prop_grad = False; self.config.test_out_evo = False. [docs] def initialize_controls(self, amps, init_tslots=True):; """"""; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated; """"""; self._check_test_out_files(). if not isinstance(self.prop_computer, propcomp.PropagatorComputer):; raise errors.UsageError(; ""No prop_computer (propagator computer) ""; ""set. A default should be assigned by the Dynamics subclass""). if not isinstance(self.tslot_computer, tslotcomp.TimeslotComputer):; raise errors.UsageError(; ""No tslot_computer (Timeslot computer)""; "" set. A default should be assigned by the Dynamics class""). if not isinstance(self.fid_computer, fidcomp.FideliyComputer):; raise errors.UsageError(; ""No fid_computer (Fidelity computer)""; "" set. A default should be assigned by the Dynamics subclass""). self.ctrl_amps = None; # Note this call is made just to initialise the num_ctrls attrib; self.get_num_ctrls(). if init_tslots:; self.init_time_slots(); self._init_lists(); self.tslot_computer.init_comp(); self.fid_computer.init_comp(); self._ctrls_initialized = True; self.update_ctrl_amps(amps). def check_ctrls_initialized(self):; if not self._ctrls_initialized:; raise errors.UsageError(; ""Controls not initialised. ""; ""Ensure Dynamics.initialize_controls has been ""; ""executed with the initial control amplitudes.""). def get_amp_times(self):; return self.time[:self.num_tslots]. [docs] def save_amps(self, file_name=None, times=None, amps=None, verbose=False):; """"""; Save ",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:15516,Availability,error,errors,15516,"):; cfg.reset_test_out_files(); else:; if self.stats is None:; logger.warn(""Cannot output test files when stats""; "" attribute is not set.""); self.config.test_out_amps = False; self.config.test_out_prop = False; self.config.test_out_prop_grad = False; self.config.test_out_evo = False. [docs] def initialize_controls(self, amps, init_tslots=True):; """"""; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated; """"""; self._check_test_out_files(). if not isinstance(self.prop_computer, propcomp.PropagatorComputer):; raise errors.UsageError(; ""No prop_computer (propagator computer) ""; ""set. A default should be assigned by the Dynamics subclass""). if not isinstance(self.tslot_computer, tslotcomp.TimeslotComputer):; raise errors.UsageError(; ""No tslot_computer (Timeslot computer)""; "" set. A default should be assigned by the Dynamics class""). if not isinstance(self.fid_computer, fidcomp.FideliyComputer):; raise errors.UsageError(; ""No fid_computer (Fidelity computer)""; "" set. A default should be assigned by the Dynamics subclass""). self.ctrl_amps = None; # Note this call is made just to initialise the num_ctrls attrib; self.get_num_ctrls(). if init_tslots:; self.init_time_slots(); self._init_lists(); self.tslot_computer.init_comp(); self.fid_computer.init_comp(); self._ctrls_initialized = True; self.update_ctrl_amps(amps). def check_ctrls_initialized(self):; if not self._ctrls_initialized:; raise errors.UsageError(; ""Controls not initialised. ""; ""Ensure Dynamics.initialize_controls has been ""; ""executed with the initial control amplitudes.""). def get_amp_times(self):; return self.time[:self.num_tslots]. [docs] def save_amps(self, file_name=None, times=None, amps=None, verbose=False):; """"""; Save a file with the current control amplitudes in each timeslot; The first column in the file will be the start time of the slot. Parameters; ----------; file_name : string; Name of the file; If N",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:16011,Availability,error,errors,16011,"calculated; """"""; self._check_test_out_files(). if not isinstance(self.prop_computer, propcomp.PropagatorComputer):; raise errors.UsageError(; ""No prop_computer (propagator computer) ""; ""set. A default should be assigned by the Dynamics subclass""). if not isinstance(self.tslot_computer, tslotcomp.TimeslotComputer):; raise errors.UsageError(; ""No tslot_computer (Timeslot computer)""; "" set. A default should be assigned by the Dynamics class""). if not isinstance(self.fid_computer, fidcomp.FideliyComputer):; raise errors.UsageError(; ""No fid_computer (Fidelity computer)""; "" set. A default should be assigned by the Dynamics subclass""). self.ctrl_amps = None; # Note this call is made just to initialise the num_ctrls attrib; self.get_num_ctrls(). if init_tslots:; self.init_time_slots(); self._init_lists(); self.tslot_computer.init_comp(); self.fid_computer.init_comp(); self._ctrls_initialized = True; self.update_ctrl_amps(amps). def check_ctrls_initialized(self):; if not self._ctrls_initialized:; raise errors.UsageError(; ""Controls not initialised. ""; ""Ensure Dynamics.initialize_controls has been ""; ""executed with the initial control amplitudes.""). def get_amp_times(self):; return self.time[:self.num_tslots]. [docs] def save_amps(self, file_name=None, times=None, amps=None, verbose=False):; """"""; Save a file with the current control amplitudes in each timeslot; The first column in the file will be the start time of the slot. Parameters; ----------; file_name : string; Name of the file; If None given the def_amps_fname attribuite will be used. times : List type (or string); List / array of the start times for each slot; If None given this will be retrieved through get_amp_times(); If 'exclude' then times will not be saved in the file, just; the amplitudes. amps : Array[num_tslots, num_ctrls]; Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verbose : Boolean; If True then an info message will be logged; """"""; self.check_ctrls_initialized(). inctimes ",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:17681,Availability,error,error,17681," then times will not be saved in the file, just; the amplitudes. amps : Array[num_tslots, num_ctrls]; Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verbose : Boolean; If True then an info message will be logged; """"""; self.check_ctrls_initialized(). inctimes = True; if file_name is None:; file_name = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if isinstance(times, string_types):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). if not self.tslot_computer.compare_amps(new_amps):; if self.config.test_out_amps:; fname = ""amps_{}_{}_{}_call{}{}"".format(; self.id_text,; self.prop_computer.id_text,; self.fid_computer.id_text,; self.stats.num_ctrl_amp_updates,; self.config.test_out_f_ext). fpath = os.path.join(self.config.test_out_dir, fname); self.save_amps(fpath, verbose=True). [docs] def flag_system_changed(self):; """"""; Flag eveolution, fidelity and gradients as needing recalculation; """"""; self.evo_current = False; self.fi",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:17735,Availability,error,error,17735," then times will not be saved in the file, just; the amplitudes. amps : Array[num_tslots, num_ctrls]; Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verbose : Boolean; If True then an info message will be logged; """"""; self.check_ctrls_initialized(). inctimes = True; if file_name is None:; file_name = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if isinstance(times, string_types):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). if not self.tslot_computer.compare_amps(new_amps):; if self.config.test_out_amps:; fname = ""amps_{}_{}_{}_call{}{}"".format(; self.id_text,; self.prop_computer.id_text,; self.fid_computer.id_text,; self.stats.num_ctrl_amp_updates,; self.config.test_out_f_ext). fpath = os.path.join(self.config.test_out_dir, fname); self.save_amps(fpath, verbose=True). [docs] def flag_system_changed(self):; """"""; Flag eveolution, fidelity and gradients as needing recalculation; """"""; self.evo_current = False; self.fi",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:19945,Availability,error,errors,19945,".drift_dyn_gen, np.ndarray):; raise TypeError(""Cannot get drift dimension, ""; ""as drift not set (correctly).""); return self.drift_dyn_gen.shape[0]. [docs] def get_num_ctrls(self):; """"""; calculate the of controls from the length of the control list; sets the num_ctrls property, which can be used alternatively; subsequently; """"""; self.num_ctrls = len(self.ctrl_dyn_gen); return self.num_ctrls. [docs] def get_owd_evo_target(self):; """"""; Get the inverse of the target.; Used for calculating the 'backward' evolution; """"""; return la.inv(self.target). [docs] def combine_dyn_gen(self, k):; """"""; Computes the dynamics generator for a given timeslot; The is the combined Hamiltion for unitary systems; """"""; dg = np.asarray(self.drift_dyn_gen); for j in range(self.get_num_ctrls()):; dg = dg + self.ctrl_amps[k, j]*np.asarray(self.ctrl_dyn_gen[j]); return dg. [docs] def get_dyn_gen(self, k):; """"""; Get the combined dynamics generator for the timeslot; Not implemented in the base class. Choose a subclass; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs] def get_ctrl_dyn_gen(self, j):; """"""; Get the dynamics generator for the control; Not implemented in the base class. Choose a subclass; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs] def compute_evolution(self):; """"""; Recalculate the time evolution operators; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; Actual work is completed by the recompute_evolution method; of the timeslot computer; """""". # Check if values are already current, otherwise calculate all values; if not self.evo_current:; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Computing evolution""); self.tslot_computer.recompute_evolution(); self.evo_current = True; return True; else:; return False. [docs] def ensure_decomp_curr(self, k):; """"""; Checks to see if the diagonalisation has been completed since; t",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:20176,Availability,error,errors,20176,"the control list; sets the num_ctrls property, which can be used alternatively; subsequently; """"""; self.num_ctrls = len(self.ctrl_dyn_gen); return self.num_ctrls. [docs] def get_owd_evo_target(self):; """"""; Get the inverse of the target.; Used for calculating the 'backward' evolution; """"""; return la.inv(self.target). [docs] def combine_dyn_gen(self, k):; """"""; Computes the dynamics generator for a given timeslot; The is the combined Hamiltion for unitary systems; """"""; dg = np.asarray(self.drift_dyn_gen); for j in range(self.get_num_ctrls()):; dg = dg + self.ctrl_amps[k, j]*np.asarray(self.ctrl_dyn_gen[j]); return dg. [docs] def get_dyn_gen(self, k):; """"""; Get the combined dynamics generator for the timeslot; Not implemented in the base class. Choose a subclass; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs] def get_ctrl_dyn_gen(self, j):; """"""; Get the dynamics generator for the control; Not implemented in the base class. Choose a subclass; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs] def compute_evolution(self):; """"""; Recalculate the time evolution operators; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; Actual work is completed by the recompute_evolution method; of the timeslot computer; """""". # Check if values are already current, otherwise calculate all values; if not self.evo_current:; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Computing evolution""); self.tslot_computer.recompute_evolution(); self.evo_current = True; return True; else:; return False. [docs] def ensure_decomp_curr(self, k):; """"""; Checks to see if the diagonalisation has been completed since; the last update of the dynamics generators; (after the amplitude update); If not then the diagonlisation is completed; """"""; if self.decomp_curr is None:; raise errors.UsageError(""Decomp lists have not been created""); if not self.dec",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:21092,Availability,error,errors,21092,"cs generator for the control; Not implemented in the base class. Choose a subclass; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs] def compute_evolution(self):; """"""; Recalculate the time evolution operators; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; Actual work is completed by the recompute_evolution method; of the timeslot computer; """""". # Check if values are already current, otherwise calculate all values; if not self.evo_current:; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Computing evolution""); self.tslot_computer.recompute_evolution(); self.evo_current = True; return True; else:; return False. [docs] def ensure_decomp_curr(self, k):; """"""; Checks to see if the diagonalisation has been completed since; the last update of the dynamics generators; (after the amplitude update); If not then the diagonlisation is completed; """"""; if self.decomp_curr is None:; raise errors.UsageError(""Decomp lists have not been created""); if not self.decomp_curr[k]:; self.spectral_decomp(k). [docs] def spectral_decomp(self, k):; """"""; Calculate the diagonalization of the dynamics generator; generating lists of eigenvectors, propagators in the diagonalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; Not implemented in this base class, because the method is specific; to the matrix type; """"""; raise errors.UsageError(""Decomposition cannot be completed by ""; ""this class. Try a(nother) subclass""). class DynamicsGenMat(Dynamics):; """"""; This sub class can be used for any system where no additional; operator is applied to the dynamics generator before calculating; the propagator, e.g. classical dynamics, Limbladian; """"""; def reset(self):; Dynamics.reset(self); self.id_text = 'GEN_MAT'. def get_dyn_gen(self, k):; """"""; Get the combined dynamics generator for the timeslot; This base class method simply returns dyn_gen[k]; other subcla",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:21545,Availability,error,errors,21545,"and; prop (propagators) are calculated as necessary; Actual work is completed by the recompute_evolution method; of the timeslot computer; """""". # Check if values are already current, otherwise calculate all values; if not self.evo_current:; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Computing evolution""); self.tslot_computer.recompute_evolution(); self.evo_current = True; return True; else:; return False. [docs] def ensure_decomp_curr(self, k):; """"""; Checks to see if the diagonalisation has been completed since; the last update of the dynamics generators; (after the amplitude update); If not then the diagonlisation is completed; """"""; if self.decomp_curr is None:; raise errors.UsageError(""Decomp lists have not been created""); if not self.decomp_curr[k]:; self.spectral_decomp(k). [docs] def spectral_decomp(self, k):; """"""; Calculate the diagonalization of the dynamics generator; generating lists of eigenvectors, propagators in the diagonalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; Not implemented in this base class, because the method is specific; to the matrix type; """"""; raise errors.UsageError(""Decomposition cannot be completed by ""; ""this class. Try a(nother) subclass""). class DynamicsGenMat(Dynamics):; """"""; This sub class can be used for any system where no additional; operator is applied to the dynamics generator before calculating; the propagator, e.g. classical dynamics, Limbladian; """"""; def reset(self):; Dynamics.reset(self); self.id_text = 'GEN_MAT'. def get_dyn_gen(self, k):; """"""; Get the combined dynamics generator for the timeslot; This base class method simply returns dyn_gen[k]; other subclass methods will include some factor; """"""; return self.dyn_gen[k]. def get_ctrl_dyn_gen(self, j):; """"""; Get the dynamics generator for the control; This base class method simply returns ctrl_dyn_gen[j]; other subclass methods will include some factor; """"""; return self.ctrl_dyn_gen[j]. [docs]clas",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:25737,Availability,down,down,25737,"f.dyn_gen[k]. [docs] def get_ctrl_dyn_gen(self, j):; """"""; Get the dynamics generator for the control; including the -i factor; """"""; return -1j*self.ctrl_dyn_gen[j]. def get_num_ctrls(self):; if not self._dyn_gen_mapped:; self._map_dyn_gen_to_ham(); return Dynamics.get_num_ctrls(self). def get_owd_evo_target(self):; return self.target.conj().T. [docs] def spectral_decomp(self, k):; """"""; Calculates the diagonalization of the dynamics generator; generating lists of eigenvectors, propagators in the diagonalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; """"""; H = self.H[k]; # assuming H is an nxn matrix, find n; n = H.shape[0]; # returns row vector of eigen values,; # columns with the eigenvectors; eig_val, eig_vec = np.linalg.eig(H). # Calculate the propagator in the diagonalised basis; eig_val_tau = -1j*eig_val*self.tau[k]; prop_eig = np.exp(eig_val_tau). # Generate the factor matrix through the differences; # between each of the eigenvectors and the exponentiations; # create nxn matrix where each eigen val is repeated n times; # down the columns; o = np.ones([n, n]); eig_val_cols = eig_val_tau*o; # calculate all the differences by subtracting it from its transpose; eig_val_diffs = eig_val_cols - eig_val_cols.T; # repeat for the propagator; prop_eig_cols = prop_eig*o; prop_eig_diffs = prop_eig_cols - prop_eig_cols.T; # the factor matrix is the elementwise quotient of the; # differeneces between the exponentiated eigen vals and the; # differences between the eigen vals; # need to avoid division by zero that would arise due to denegerate; # eigenvalues and the diagonals; degen_mask = np.abs(eig_val_diffs) < self.fact_mat_round_prec; eig_val_diffs[degen_mask] = 1; factors = prop_eig_diffs / eig_val_diffs; # for degenerate eigenvalues the factor is just the exponent; factors[degen_mask] = prop_eig_cols[degen_mask]. # Store eigenvals and eigenvectors for use by other functions, e.g.; # gradient_exact; self.decomp_curr[k] = True; self.prop_e",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:249,Deployability,install,installation,249,"﻿. qutip.control.dynamics — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.control.dynamics; # -*- coding: utf-8 -*-; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2014 and later, Alexander J G Pitchford; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and th",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:5729,Deployability,update,updated,5729,"rol.symplectic as sympl. [docs]class Dynamics:; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before any of the methods; can be used. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; Note value should be set using set_log_level. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer : PropagatorComputer (subclass instance); Used to compute the propagators and their gradients. fid_computer : FidelityComputer (subclass instance); Used to computer the fidelity error and the fidelity error; gradient. num_tslots : integer; Number of timeslots, aka timeslices. num_ctrls : integer; Number of controls.; Note this is set when get_num_ctrls is called based on the; length of ctrl_dyn_gen. evo_time : float; Total time for the evolution. tau : array[num_tslots] of float; Duration of each timeslot; Note that if this is set before initialize_controls is called; then num_tslots and evo_time are calculated from tau, otherwise; tau is generated from num_tslots and evo_time, that is; equal size time slices. time : array[num_tslots+1] of float; Cumulative time for the evolution, that is the time at the start; of each time slice. drift_dyn_gen : Qobj; Drift or system dynamics generator; Matrix de",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:11383,Deployability,configurat,configuration,11383,"None; self.prop = None; self.prop_grad = None; self.evo_init2t = None; self.evo_t2end = None; self.evo_t2targ = None; # Atrributes used in diagonalisation; self.decomp_curr = None; self.prop_eigen = None; self.dyn_gen_eigenvectors = None; self.dyn_gen_factormatrix = None; self.fact_mat_round_prec = 1e-10. # Debug and information attribs; self.stats = None; self.id_text = 'DYN_BASE'; self.def_amps_fname = ""ctrl_amps.txt""; self.set_log_level(self.config.log_level); # Internal flags; self._dyn_gen_mapped = False; self._ctrls_initialized = False. # Create the computing objects; self._create_computers(). self.clear(). [docs] def set_log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; self.log_level = lvl; logger.setLevel(lvl). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to UpdateAll; # can be set to DynUpdate in the configuration; # (see class file for details); if self.config.amp_update_mode == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). def clear(self):; self.ctrl_amps = None; self.evo_current = False; if self.fid_computer is not None:; self.fid_computer.clear(). [docs] def init_time_slots(self):; """"""; Generate the timeslot duration array 'tau' based on the evo_time; and num_tslots attributes, unless the tau attribute is already set; in which case this step in ignored; Generate the cumulative time array 'time' based on the tau values; """"""; # set the time intervals to be equal timeslices of the total if; # the have not been set already (as part of user config); if self.tau is None:; self.tau = np.ones(self.num_tslots, dtype='f') * \; self.evo_time/self.num_tslots; self.time = np.zeros(self.num_tsl",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:14947,Deployability,configurat,configuration,14947,"will hold the eigen decomposition; used in calculating propagators and gradients; Note: used with PropCompDiag propagator calcs; """"""; shp = self.drift_dyn_gen.shape; n_ts = self.num_tslots; self.decomp_curr = [False for x in range(n_ts)]; self.prop_eigen = \; [np.empty(shp[0], dtype=complex) for x in range(n_ts)]; self.dyn_gen_eigenvectors = \; [np.empty(shp, dtype=complex) for x in range(n_ts)]; self.dyn_gen_factormatrix = \; [np.empty(shp, dtype=complex) for x in range(n_ts)]. def _check_test_out_files(self):; cfg = self.config; if cfg.any_test_files():; if not cfg.check_create_test_out_dir():; cfg.reset_test_out_files(); else:; if self.stats is None:; logger.warn(""Cannot output test files when stats""; "" attribute is not set.""); self.config.test_out_amps = False; self.config.test_out_prop = False; self.config.test_out_prop_grad = False; self.config.test_out_evo = False. [docs] def initialize_controls(self, amps, init_tslots=True):; """"""; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated; """"""; self._check_test_out_files(). if not isinstance(self.prop_computer, propcomp.PropagatorComputer):; raise errors.UsageError(; ""No prop_computer (propagator computer) ""; ""set. A default should be assigned by the Dynamics subclass""). if not isinstance(self.tslot_computer, tslotcomp.TimeslotComputer):; raise errors.UsageError(; ""No tslot_computer (Timeslot computer)""; "" set. A default should be assigned by the Dynamics class""). if not isinstance(self.fid_computer, fidcomp.FideliyComputer):; raise errors.UsageError(; ""No fid_computer (Fidelity computer)""; "" set. A default should be assigned by the Dynamics subclass""). self.ctrl_amps = None; # Note this call is made just to initialise the num_ctrls attrib; self.get_num_ctrls(). if init_tslots:; self.init_time_slots(); self._init_lists(); self.tslot_computer.init_comp(); self.fid_computer.init_comp(); self._ctrls_initialized = True; ",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:20941,Deployability,update,update,20941,"e errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs] def get_ctrl_dyn_gen(self, j):; """"""; Get the dynamics generator for the control; Not implemented in the base class. Choose a subclass; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs] def compute_evolution(self):; """"""; Recalculate the time evolution operators; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; Actual work is completed by the recompute_evolution method; of the timeslot computer; """""". # Check if values are already current, otherwise calculate all values; if not self.evo_current:; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Computing evolution""); self.tslot_computer.recompute_evolution(); self.evo_current = True; return True; else:; return False. [docs] def ensure_decomp_curr(self, k):; """"""; Checks to see if the diagonalisation has been completed since; the last update of the dynamics generators; (after the amplitude update); If not then the diagonlisation is completed; """"""; if self.decomp_curr is None:; raise errors.UsageError(""Decomp lists have not been created""); if not self.decomp_curr[k]:; self.spectral_decomp(k). [docs] def spectral_decomp(self, k):; """"""; Calculate the diagonalization of the dynamics generator; generating lists of eigenvectors, propagators in the diagonalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; Not implemented in this base class, because the method is specific; to the matrix type; """"""; raise errors.UsageError(""Decomposition cannot be completed by ""; ""this class. Try a(nother) subclass""). class DynamicsGenMat(Dynamics):; """"""; This sub class can be used for any system where no additional; operator is applied to the dynamics generator before calculating; the propagator, e.g. classical dynamics, Limbladian; """"""; def reset(self):; Dynamics.reset(self); self.id_text = 'GEN_MAT'. def get_d",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:20997,Deployability,update,update,20997,"e errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs] def get_ctrl_dyn_gen(self, j):; """"""; Get the dynamics generator for the control; Not implemented in the base class. Choose a subclass; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs] def compute_evolution(self):; """"""; Recalculate the time evolution operators; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; Actual work is completed by the recompute_evolution method; of the timeslot computer; """""". # Check if values are already current, otherwise calculate all values; if not self.evo_current:; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Computing evolution""); self.tslot_computer.recompute_evolution(); self.evo_current = True; return True; else:; return False. [docs] def ensure_decomp_curr(self, k):; """"""; Checks to see if the diagonalisation has been completed since; the last update of the dynamics generators; (after the amplitude update); If not then the diagonlisation is completed; """"""; if self.decomp_curr is None:; raise errors.UsageError(""Decomp lists have not been created""); if not self.decomp_curr[k]:; self.spectral_decomp(k). [docs] def spectral_decomp(self, k):; """"""; Calculate the diagonalization of the dynamics generator; generating lists of eigenvectors, propagators in the diagonalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; Not implemented in this base class, because the method is specific; to the matrix type; """"""; raise errors.UsageError(""Decomposition cannot be completed by ""; ""this class. Try a(nother) subclass""). class DynamicsGenMat(Dynamics):; """"""; This sub class can be used for any system where no additional; operator is applied to the dynamics generator before calculating; the propagator, e.g. classical dynamics, Limbladian; """"""; def reset(self):; Dynamics.reset(self); self.id_text = 'GEN_MAT'. def get_d",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:23546,Deployability,configurat,configuration,23546,"tonians; Note a matrix diagonalisation is used to compute the exponent; The eigen decomposition is also used to calculate the propagator gradient.; The method is taken from DYNAMO (see file header). Attributes; ----------; drift_ham : Qobj; This is the drift Hamiltonian for unitary dynamics; It is mapped to drift_dyn_gen during initialize_controls. ctrl_ham : List of Qobj; These are the control Hamiltonians for unitary dynamics; It is mapped to ctrl_dyn_gen during initialize_controls. H : List of Qobj; The combined drift and control Hamiltonians for each timeslot; These are the dynamics generators for unitary dynamics.; It is mapped to dyn_gen during initialize_controls; """""". def reset(self):; Dynamics.reset(self); self.id_text = 'UNIT'; self.drift_ham = None; self.ctrl_ham = None; self.H = None. def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.amp_update_mode == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). # set the default fidelity computer; self.fid_computer = fidcomp.FidCompUnitary(self); # set the default propagator computer; self.prop_computer = propcomp.PropCompDiag(self). def initialize_controls(self, amplitudes, init_tslots=True):; # Either the _dyn_gen or _ham names can be used; # This assumes that one or other has been set in the configuration. self._map_dyn_gen_to_ham(); Dynamics.initialize_controls(self, amplitudes, init_tslots=init_tslots); self.H = self.dyn_gen. def _map_dyn_gen_to_ham(self):; if self.drift_dyn_gen is None:; self.drift_dyn_gen = self.drift_ham; else:; self.drift_ham = self.drift_dyn_gen. if self.ctrl_dyn_gen is None:; self.ctrl_dyn_gen = self.ctrl_ham; else:; self.ctrl_ham = self.ctrl_dyn_gen. self._dyn_gen_mapped = True. [docs] def get_",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:24102,Deployability,configurat,configuration,24102,". H : List of Qobj; The combined drift and control Hamiltonians for each timeslot; These are the dynamics generators for unitary dynamics.; It is mapped to dyn_gen during initialize_controls; """""". def reset(self):; Dynamics.reset(self); self.id_text = 'UNIT'; self.drift_ham = None; self.ctrl_ham = None; self.H = None. def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.amp_update_mode == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). # set the default fidelity computer; self.fid_computer = fidcomp.FidCompUnitary(self); # set the default propagator computer; self.prop_computer = propcomp.PropCompDiag(self). def initialize_controls(self, amplitudes, init_tslots=True):; # Either the _dyn_gen or _ham names can be used; # This assumes that one or other has been set in the configuration. self._map_dyn_gen_to_ham(); Dynamics.initialize_controls(self, amplitudes, init_tslots=init_tslots); self.H = self.dyn_gen. def _map_dyn_gen_to_ham(self):; if self.drift_dyn_gen is None:; self.drift_dyn_gen = self.drift_ham; else:; self.drift_ham = self.drift_dyn_gen. if self.ctrl_dyn_gen is None:; self.ctrl_dyn_gen = self.ctrl_ham; else:; self.ctrl_ham = self.ctrl_dyn_gen. self._dyn_gen_mapped = True. [docs] def get_dyn_gen(self, k):; """"""; Get the combined dynamics generator for the timeslot; including the -i factor; """"""; return -1j*self.dyn_gen[k]. [docs] def get_ctrl_dyn_gen(self, j):; """"""; Get the dynamics generator for the control; including the -i factor; """"""; return -1j*self.ctrl_dyn_gen[j]. def get_num_ctrls(self):; if not self._dyn_gen_mapped:; self._map_dyn_gen_to_ham(); return Dynamics.get_num_ctrls(self). def get_owd_evo_target(self):; return self.target.conj().T. [docs] def spectral_d",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:27429,Deployability,configurat,configuration,27429,"fs[degen_mask] = 1; factors = prop_eig_diffs / eig_val_diffs; # for degenerate eigenvalues the factor is just the exponent; factors[degen_mask] = prop_eig_cols[degen_mask]. # Store eigenvals and eigenvectors for use by other functions, e.g.; # gradient_exact; self.decomp_curr[k] = True; self.prop_eigen[k] = prop_eig; self.dyn_gen_eigenvectors[k] = eig_vec; self.dyn_gen_factormatrix[k] = factors. [docs]class DynamicsSymplectic(Dynamics):; """"""; Symplectic systems; This is the subclass to use for systems where the dynamics is described; by symplectic matrices, e.g. coupled oscillators, quantum optics. Attributes; ----------; omega : array[drift_dyn_gen.shape]; matrix used in the calculation of propagators (time evolution); with symplectic systems.; """""". def reset(self):; Dynamics.reset(self); self.id_text = 'SYMPL'; self.omega = None; self.grad_exact = True. def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.amp_update_mode == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). def get_omega(self):; if self.omega is None:; n = self.drift_dyn_gen.shape[0] // 2; self.omega = sympl.calc_omega(n). return self.omega. [docs] def get_dyn_gen(self, k):; """"""; Get the combined dynamics generator for the timeslot; multiplied by omega; """"""; o = self.get_omega(); return self.dyn_gen[k].dot(o). [docs] def get_ctrl_dyn_gen(self, j):; """"""; Get the dynamics generator for the control; multiplied by omega; """"""; o = self.get_omega(); return self.ctrl_dyn_gen[j].dot(o). Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:28307,Deployability,update,updated,28307,"fs[degen_mask] = 1; factors = prop_eig_diffs / eig_val_diffs; # for degenerate eigenvalues the factor is just the exponent; factors[degen_mask] = prop_eig_cols[degen_mask]. # Store eigenvals and eigenvectors for use by other functions, e.g.; # gradient_exact; self.decomp_curr[k] = True; self.prop_eigen[k] = prop_eig; self.dyn_gen_eigenvectors[k] = eig_vec; self.dyn_gen_factormatrix[k] = factors. [docs]class DynamicsSymplectic(Dynamics):; """"""; Symplectic systems; This is the subclass to use for systems where the dynamics is described; by symplectic matrices, e.g. coupled oscillators, quantum optics. Attributes; ----------; omega : array[drift_dyn_gen.shape]; matrix used in the calculation of propagators (time evolution); with symplectic systems.; """""". def reset(self):; Dynamics.reset(self); self.id_text = 'SYMPL'; self.omega = None; self.grad_exact = True. def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.amp_update_mode == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). def get_omega(self):; if self.omega is None:; n = self.drift_dyn_gen.shape[0] // 2; self.omega = sympl.calc_omega(n). return self.omega. [docs] def get_dyn_gen(self, k):; """"""; Get the combined dynamics generator for the timeslot; multiplied by omega; """"""; o = self.get_omega(); return self.dyn_gen[k].dot(o). [docs] def get_ctrl_dyn_gen(self, j):; """"""; Get the dynamics generator for the control; multiplied by omega; """"""; o = self.get_omega(); return self.ctrl_dyn_gen[j].dot(o). Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:5494,Energy Efficiency,reduce,reduce,5494,"rol modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl. [docs]class Dynamics:; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before any of the methods; can be used. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; Note value should be set using set_log_level. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer : PropagatorComputer (subclass instance); Used to compute the propagators and their gradients. fid_computer : FidelityComputer (subclass instance); Used to computer the fidelity error and the fidelity error; gradient. num_tslots : integer; Number of timeslots, aka timeslices. num_ctrls : integer; Number of controls.; Note this is set when get_num_ctrls is called based on the; length of ctrl_dyn_gen. evo_time : float; Total time for the evolution. tau : array[num_tslots] of float; Duration of each timeslot; Note that if this is set before initialize_controls is called; then num_tslots and evo_time are calculated from tau, otherwise; tau is generated from num_tslots and evo_time, that is; equal size time s",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:3923,Integrability,depend,depends,3923,"ICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes that define the dynamics of the (quantum) system and target evolution; to be optimised.; The contols are also defined here, i.e. the dynamics generators (Hamiltonians,; Limbladians etc). The dynamics for the time slices are calculated here, along; with the evolution as determined by the control amplitudes. See the subclass descriptions and choose the appropriate class for the; application. The choice depends on the type of matrix used to define; the dynamics. These class implement functions for getting the dynamics generators for; the combined (drift + ctrls) dynamics with the approriate operator applied. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """"""; import os; import numpy as np; import scipy.linalg as la; from six import string_types; # QuTiP logging; import qutip.logging as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl. [docs]class Dynamics:; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before any of the methods; can be used. Attributes; ----------; log_level : intege",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:16931,Integrability,message,message,16931,"s(amps). def check_ctrls_initialized(self):; if not self._ctrls_initialized:; raise errors.UsageError(; ""Controls not initialised. ""; ""Ensure Dynamics.initialize_controls has been ""; ""executed with the initial control amplitudes.""). def get_amp_times(self):; return self.time[:self.num_tslots]. [docs] def save_amps(self, file_name=None, times=None, amps=None, verbose=False):; """"""; Save a file with the current control amplitudes in each timeslot; The first column in the file will be the start time of the slot. Parameters; ----------; file_name : string; Name of the file; If None given the def_amps_fname attribuite will be used. times : List type (or string); List / array of the start times for each slot; If None given this will be retrieved through get_amp_times(); If 'exclude' then times will not be saved in the file, just; the amplitudes. amps : Array[num_tslots, num_ctrls]; Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verbose : Boolean; If True then an info message will be logged; """"""; self.check_ctrls_initialized(). inctimes = True; if file_name is None:; file_name = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if isinstance(times, string_types):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is ",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:10020,Modifiability,config,config,10020," : List of array[drift_dyn_gen.shape]; Eigenvectors of the dynamics generators; Used for calculating the propagators and their gradients; Only used when the PropagatorComputer uses diagonalisation. prop_eigen : List of array[drift_dyn_gen.shape]; Propagator in diagonalised basis of the combined dynamics generator; Used for calculating the propagators and their gradients; Only used when the PropagatorComputer uses diagonalisation. dyn_gen_factormatrix : List of array[drift_dyn_gen.shape]; Matrix of scaling factors calculated duing the decomposition; Used for calculating the propagator gradients; Only used when the PropagatorComputer uses diagonalisation. fact_mat_round_prec : float; Rounding precision used when calculating the factor matrix; to determine if two eigenvalues are equivalent; Only used when the PropagatorComputer uses diagonalisation. def_amps_fname : string; Default name for the output used when save_amps is called. """"""; def __init__(self, optimconfig):; self.config = optimconfig; self.reset(). def reset(self):; # Main functional attributes; self.evo_time = 0; self.num_tslots = 0; self.tau = None; self.time = None; self.initial = None; self.target = None; self.ctrl_amps = None; self.initial_ctrl_scaling = 1.0; self.initial_ctrl_offset = 0.0; self.drift_dyn_gen = None; self.ctrl_dyn_gen = None; self.dyn_gen = None; self.prop = None; self.prop_grad = None; self.evo_init2t = None; self.evo_t2end = None; self.evo_t2targ = None; # Atrributes used in diagonalisation; self.decomp_curr = None; self.prop_eigen = None; self.dyn_gen_eigenvectors = None; self.dyn_gen_factormatrix = None; self.fact_mat_round_prec = 1e-10. # Debug and information attribs; self.stats = None; self.id_text = 'DYN_BASE'; self.def_amps_fname = ""ctrl_amps.txt""; self.set_log_level(self.config.log_level); # Internal flags; self._dyn_gen_mapped = False; self._ctrls_initialized = False. # Create the computing objects; self._create_computers(). self.clear(). [docs] def set_log_level(self, lvl):;",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:10825,Modifiability,config,config,10825,"nt; Only used when the PropagatorComputer uses diagonalisation. def_amps_fname : string; Default name for the output used when save_amps is called. """"""; def __init__(self, optimconfig):; self.config = optimconfig; self.reset(). def reset(self):; # Main functional attributes; self.evo_time = 0; self.num_tslots = 0; self.tau = None; self.time = None; self.initial = None; self.target = None; self.ctrl_amps = None; self.initial_ctrl_scaling = 1.0; self.initial_ctrl_offset = 0.0; self.drift_dyn_gen = None; self.ctrl_dyn_gen = None; self.dyn_gen = None; self.prop = None; self.prop_grad = None; self.evo_init2t = None; self.evo_t2end = None; self.evo_t2targ = None; # Atrributes used in diagonalisation; self.decomp_curr = None; self.prop_eigen = None; self.dyn_gen_eigenvectors = None; self.dyn_gen_factormatrix = None; self.fact_mat_round_prec = 1e-10. # Debug and information attribs; self.stats = None; self.id_text = 'DYN_BASE'; self.def_amps_fname = ""ctrl_amps.txt""; self.set_log_level(self.config.log_level); # Internal flags; self._dyn_gen_mapped = False; self._ctrls_initialized = False. # Create the computing objects; self._create_computers(). self.clear(). [docs] def set_log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; self.log_level = lvl; logger.setLevel(lvl). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to UpdateAll; # can be set to DynUpdate in the configuration; # (see class file for details); if self.config.amp_update_mode == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). def clear(self):; self.ctrl_amps = None; self.evo_current = False; if self.fid_computer is not None:; self.fid_computer.clear",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:11383,Modifiability,config,configuration,11383,"None; self.prop = None; self.prop_grad = None; self.evo_init2t = None; self.evo_t2end = None; self.evo_t2targ = None; # Atrributes used in diagonalisation; self.decomp_curr = None; self.prop_eigen = None; self.dyn_gen_eigenvectors = None; self.dyn_gen_factormatrix = None; self.fact_mat_round_prec = 1e-10. # Debug and information attribs; self.stats = None; self.id_text = 'DYN_BASE'; self.def_amps_fname = ""ctrl_amps.txt""; self.set_log_level(self.config.log_level); # Internal flags; self._dyn_gen_mapped = False; self._ctrls_initialized = False. # Create the computing objects; self._create_computers(). self.clear(). [docs] def set_log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; self.log_level = lvl; logger.setLevel(lvl). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to UpdateAll; # can be set to DynUpdate in the configuration; # (see class file for details); if self.config.amp_update_mode == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). def clear(self):; self.ctrl_amps = None; self.evo_current = False; if self.fid_computer is not None:; self.fid_computer.clear(). [docs] def init_time_slots(self):; """"""; Generate the timeslot duration array 'tau' based on the evo_time; and num_tslots attributes, unless the tau attribute is already set; in which case this step in ignored; Generate the cumulative time array 'time' based on the tau values; """"""; # set the time intervals to be equal timeslices of the total if; # the have not been set already (as part of user config); if self.tau is None:; self.tau = np.ones(self.num_tslots, dtype='f') * \; self.evo_time/self.num_tslots; self.time = np.zeros(self.num_tsl",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:11438,Modifiability,config,config,11438,"None; self.evo_t2end = None; self.evo_t2targ = None; # Atrributes used in diagonalisation; self.decomp_curr = None; self.prop_eigen = None; self.dyn_gen_eigenvectors = None; self.dyn_gen_factormatrix = None; self.fact_mat_round_prec = 1e-10. # Debug and information attribs; self.stats = None; self.id_text = 'DYN_BASE'; self.def_amps_fname = ""ctrl_amps.txt""; self.set_log_level(self.config.log_level); # Internal flags; self._dyn_gen_mapped = False; self._ctrls_initialized = False. # Create the computing objects; self._create_computers(). self.clear(). [docs] def set_log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; self.log_level = lvl; logger.setLevel(lvl). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to UpdateAll; # can be set to DynUpdate in the configuration; # (see class file for details); if self.config.amp_update_mode == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). def clear(self):; self.ctrl_amps = None; self.evo_current = False; if self.fid_computer is not None:; self.fid_computer.clear(). [docs] def init_time_slots(self):; """"""; Generate the timeslot duration array 'tau' based on the evo_time; and num_tslots attributes, unless the tau attribute is already set; in which case this step in ignored; Generate the cumulative time array 'time' based on the tau values; """"""; # set the time intervals to be equal timeslices of the total if; # the have not been set already (as part of user config); if self.tau is None:; self.tau = np.ones(self.num_tslots, dtype='f') * \; self.evo_time/self.num_tslots; self.time = np.zeros(self.num_tslots+1, dtype=float); # set the cumulative time by summing the time",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:12229,Modifiability,config,config,12229," Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; self.log_level = lvl; logger.setLevel(lvl). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to UpdateAll; # can be set to DynUpdate in the configuration; # (see class file for details); if self.config.amp_update_mode == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). def clear(self):; self.ctrl_amps = None; self.evo_current = False; if self.fid_computer is not None:; self.fid_computer.clear(). [docs] def init_time_slots(self):; """"""; Generate the timeslot duration array 'tau' based on the evo_time; and num_tslots attributes, unless the tau attribute is already set; in which case this step in ignored; Generate the cumulative time array 'time' based on the tau values; """"""; # set the time intervals to be equal timeslices of the total if; # the have not been set already (as part of user config); if self.tau is None:; self.tau = np.ones(self.num_tslots, dtype='f') * \; self.evo_time/self.num_tslots; self.time = np.zeros(self.num_tslots+1, dtype=float); # set the cumulative time by summing the time intervals; for t in range(self.num_tslots):; self.time[t+1] = self.time[t] + self.tau[t]. def _init_lists(self):; """"""; Create the container lists / arrays for the:; dynamics generations, propagators, and evolutions etc; Set the time slices and cumulative time; """""". # Create containers for control Hamiltonian etc; shp = self.drift_dyn_gen.shape; # set H to be just empty float arrays with the shape of H; self.dyn_gen = [np.empty(shp, dtype=complex); for x in range(self.num_tslots)]; # the exponetiation of H. Just empty float arrays with the shape of H; self.prop = [np.empty(shp, dtype=comple",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:14436,Modifiability,config,config,14436,"ropagation); self.evo_t2end = [np.empty(shp, dtype=complex); for x in range(self.num_tslots)]; if self.fid_computer.uses_evo_t2targ:; # Onward propagation overlap with inverse target; self.evo_t2targ = [np.empty(shp, dtype=complex); for x in range(self.num_tslots + 1)]; self.evo_t2targ[-1] = self.get_owd_evo_target(). if isinstance(self.prop_computer, propcomp.PropCompDiag):; self._create_decomp_lists(). def _create_decomp_lists(self):; """"""; Create lists that will hold the eigen decomposition; used in calculating propagators and gradients; Note: used with PropCompDiag propagator calcs; """"""; shp = self.drift_dyn_gen.shape; n_ts = self.num_tslots; self.decomp_curr = [False for x in range(n_ts)]; self.prop_eigen = \; [np.empty(shp[0], dtype=complex) for x in range(n_ts)]; self.dyn_gen_eigenvectors = \; [np.empty(shp, dtype=complex) for x in range(n_ts)]; self.dyn_gen_factormatrix = \; [np.empty(shp, dtype=complex) for x in range(n_ts)]. def _check_test_out_files(self):; cfg = self.config; if cfg.any_test_files():; if not cfg.check_create_test_out_dir():; cfg.reset_test_out_files(); else:; if self.stats is None:; logger.warn(""Cannot output test files when stats""; "" attribute is not set.""); self.config.test_out_amps = False; self.config.test_out_prop = False; self.config.test_out_prop_grad = False; self.config.test_out_evo = False. [docs] def initialize_controls(self, amps, init_tslots=True):; """"""; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated; """"""; self._check_test_out_files(). if not isinstance(self.prop_computer, propcomp.PropagatorComputer):; raise errors.UsageError(; ""No prop_computer (propagator computer) ""; ""set. A default should be assigned by the Dynamics subclass""). if not isinstance(self.tslot_computer, tslotcomp.TimeslotComputer):; raise errors.UsageError(; ""No tslot_computer (Timeslot computer)""; "" set. A default should be assigned by the Dynamics class"")",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:14653,Modifiability,config,config,14653,"hp, dtype=complex); for x in range(self.num_tslots + 1)]; self.evo_t2targ[-1] = self.get_owd_evo_target(). if isinstance(self.prop_computer, propcomp.PropCompDiag):; self._create_decomp_lists(). def _create_decomp_lists(self):; """"""; Create lists that will hold the eigen decomposition; used in calculating propagators and gradients; Note: used with PropCompDiag propagator calcs; """"""; shp = self.drift_dyn_gen.shape; n_ts = self.num_tslots; self.decomp_curr = [False for x in range(n_ts)]; self.prop_eigen = \; [np.empty(shp[0], dtype=complex) for x in range(n_ts)]; self.dyn_gen_eigenvectors = \; [np.empty(shp, dtype=complex) for x in range(n_ts)]; self.dyn_gen_factormatrix = \; [np.empty(shp, dtype=complex) for x in range(n_ts)]. def _check_test_out_files(self):; cfg = self.config; if cfg.any_test_files():; if not cfg.check_create_test_out_dir():; cfg.reset_test_out_files(); else:; if self.stats is None:; logger.warn(""Cannot output test files when stats""; "" attribute is not set.""); self.config.test_out_amps = False; self.config.test_out_prop = False; self.config.test_out_prop_grad = False; self.config.test_out_evo = False. [docs] def initialize_controls(self, amps, init_tslots=True):; """"""; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated; """"""; self._check_test_out_files(). if not isinstance(self.prop_computer, propcomp.PropagatorComputer):; raise errors.UsageError(; ""No prop_computer (propagator computer) ""; ""set. A default should be assigned by the Dynamics subclass""). if not isinstance(self.tslot_computer, tslotcomp.TimeslotComputer):; raise errors.UsageError(; ""No tslot_computer (Timeslot computer)""; "" set. A default should be assigned by the Dynamics class""). if not isinstance(self.fid_computer, fidcomp.FideliyComputer):; raise errors.UsageError(; ""No fid_computer (Fidelity computer)""; "" set. A default should be assigned by the Dynamics subclass""). self.ctrl_amps = N",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:14688,Modifiability,config,config,14688,"self.num_tslots + 1)]; self.evo_t2targ[-1] = self.get_owd_evo_target(). if isinstance(self.prop_computer, propcomp.PropCompDiag):; self._create_decomp_lists(). def _create_decomp_lists(self):; """"""; Create lists that will hold the eigen decomposition; used in calculating propagators and gradients; Note: used with PropCompDiag propagator calcs; """"""; shp = self.drift_dyn_gen.shape; n_ts = self.num_tslots; self.decomp_curr = [False for x in range(n_ts)]; self.prop_eigen = \; [np.empty(shp[0], dtype=complex) for x in range(n_ts)]; self.dyn_gen_eigenvectors = \; [np.empty(shp, dtype=complex) for x in range(n_ts)]; self.dyn_gen_factormatrix = \; [np.empty(shp, dtype=complex) for x in range(n_ts)]. def _check_test_out_files(self):; cfg = self.config; if cfg.any_test_files():; if not cfg.check_create_test_out_dir():; cfg.reset_test_out_files(); else:; if self.stats is None:; logger.warn(""Cannot output test files when stats""; "" attribute is not set.""); self.config.test_out_amps = False; self.config.test_out_prop = False; self.config.test_out_prop_grad = False; self.config.test_out_evo = False. [docs] def initialize_controls(self, amps, init_tslots=True):; """"""; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated; """"""; self._check_test_out_files(). if not isinstance(self.prop_computer, propcomp.PropagatorComputer):; raise errors.UsageError(; ""No prop_computer (propagator computer) ""; ""set. A default should be assigned by the Dynamics subclass""). if not isinstance(self.tslot_computer, tslotcomp.TimeslotComputer):; raise errors.UsageError(; ""No tslot_computer (Timeslot computer)""; "" set. A default should be assigned by the Dynamics class""). if not isinstance(self.fid_computer, fidcomp.FideliyComputer):; raise errors.UsageError(; ""No fid_computer (Fidelity computer)""; "" set. A default should be assigned by the Dynamics subclass""). self.ctrl_amps = None; # Note this call is made just ",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:14723,Modifiability,config,config,14723,"arg[-1] = self.get_owd_evo_target(). if isinstance(self.prop_computer, propcomp.PropCompDiag):; self._create_decomp_lists(). def _create_decomp_lists(self):; """"""; Create lists that will hold the eigen decomposition; used in calculating propagators and gradients; Note: used with PropCompDiag propagator calcs; """"""; shp = self.drift_dyn_gen.shape; n_ts = self.num_tslots; self.decomp_curr = [False for x in range(n_ts)]; self.prop_eigen = \; [np.empty(shp[0], dtype=complex) for x in range(n_ts)]; self.dyn_gen_eigenvectors = \; [np.empty(shp, dtype=complex) for x in range(n_ts)]; self.dyn_gen_factormatrix = \; [np.empty(shp, dtype=complex) for x in range(n_ts)]. def _check_test_out_files(self):; cfg = self.config; if cfg.any_test_files():; if not cfg.check_create_test_out_dir():; cfg.reset_test_out_files(); else:; if self.stats is None:; logger.warn(""Cannot output test files when stats""; "" attribute is not set.""); self.config.test_out_amps = False; self.config.test_out_prop = False; self.config.test_out_prop_grad = False; self.config.test_out_evo = False. [docs] def initialize_controls(self, amps, init_tslots=True):; """"""; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated; """"""; self._check_test_out_files(). if not isinstance(self.prop_computer, propcomp.PropagatorComputer):; raise errors.UsageError(; ""No prop_computer (propagator computer) ""; ""set. A default should be assigned by the Dynamics subclass""). if not isinstance(self.tslot_computer, tslotcomp.TimeslotComputer):; raise errors.UsageError(; ""No tslot_computer (Timeslot computer)""; "" set. A default should be assigned by the Dynamics class""). if not isinstance(self.fid_computer, fidcomp.FideliyComputer):; raise errors.UsageError(; ""No fid_computer (Fidelity computer)""; "" set. A default should be assigned by the Dynamics subclass""). self.ctrl_amps = None; # Note this call is made just to initialise the num_ctrls attrib;",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:14763,Modifiability,config,config,14763,"isinstance(self.prop_computer, propcomp.PropCompDiag):; self._create_decomp_lists(). def _create_decomp_lists(self):; """"""; Create lists that will hold the eigen decomposition; used in calculating propagators and gradients; Note: used with PropCompDiag propagator calcs; """"""; shp = self.drift_dyn_gen.shape; n_ts = self.num_tslots; self.decomp_curr = [False for x in range(n_ts)]; self.prop_eigen = \; [np.empty(shp[0], dtype=complex) for x in range(n_ts)]; self.dyn_gen_eigenvectors = \; [np.empty(shp, dtype=complex) for x in range(n_ts)]; self.dyn_gen_factormatrix = \; [np.empty(shp, dtype=complex) for x in range(n_ts)]. def _check_test_out_files(self):; cfg = self.config; if cfg.any_test_files():; if not cfg.check_create_test_out_dir():; cfg.reset_test_out_files(); else:; if self.stats is None:; logger.warn(""Cannot output test files when stats""; "" attribute is not set.""); self.config.test_out_amps = False; self.config.test_out_prop = False; self.config.test_out_prop_grad = False; self.config.test_out_evo = False. [docs] def initialize_controls(self, amps, init_tslots=True):; """"""; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated; """"""; self._check_test_out_files(). if not isinstance(self.prop_computer, propcomp.PropagatorComputer):; raise errors.UsageError(; ""No prop_computer (propagator computer) ""; ""set. A default should be assigned by the Dynamics subclass""). if not isinstance(self.tslot_computer, tslotcomp.TimeslotComputer):; raise errors.UsageError(; ""No tslot_computer (Timeslot computer)""; "" set. A default should be assigned by the Dynamics class""). if not isinstance(self.fid_computer, fidcomp.FideliyComputer):; raise errors.UsageError(; ""No fid_computer (Fidelity computer)""; "" set. A default should be assigned by the Dynamics subclass""). self.ctrl_amps = None; # Note this call is made just to initialise the num_ctrls attrib; self.get_num_ctrls(). if init_tslots:; ",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:14947,Modifiability,config,configuration,14947,"will hold the eigen decomposition; used in calculating propagators and gradients; Note: used with PropCompDiag propagator calcs; """"""; shp = self.drift_dyn_gen.shape; n_ts = self.num_tslots; self.decomp_curr = [False for x in range(n_ts)]; self.prop_eigen = \; [np.empty(shp[0], dtype=complex) for x in range(n_ts)]; self.dyn_gen_eigenvectors = \; [np.empty(shp, dtype=complex) for x in range(n_ts)]; self.dyn_gen_factormatrix = \; [np.empty(shp, dtype=complex) for x in range(n_ts)]. def _check_test_out_files(self):; cfg = self.config; if cfg.any_test_files():; if not cfg.check_create_test_out_dir():; cfg.reset_test_out_files(); else:; if self.stats is None:; logger.warn(""Cannot output test files when stats""; "" attribute is not set.""); self.config.test_out_amps = False; self.config.test_out_prop = False; self.config.test_out_prop_grad = False; self.config.test_out_evo = False. [docs] def initialize_controls(self, amps, init_tslots=True):; """"""; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated; """"""; self._check_test_out_files(). if not isinstance(self.prop_computer, propcomp.PropagatorComputer):; raise errors.UsageError(; ""No prop_computer (propagator computer) ""; ""set. A default should be assigned by the Dynamics subclass""). if not isinstance(self.tslot_computer, tslotcomp.TimeslotComputer):; raise errors.UsageError(; ""No tslot_computer (Timeslot computer)""; "" set. A default should be assigned by the Dynamics class""). if not isinstance(self.fid_computer, fidcomp.FideliyComputer):; raise errors.UsageError(; ""No fid_computer (Fidelity computer)""; "" set. A default should be assigned by the Dynamics subclass""). self.ctrl_amps = None; # Note this call is made just to initialise the num_ctrls attrib; self.get_num_ctrls(). if init_tslots:; self.init_time_slots(); self._init_lists(); self.tslot_computer.init_comp(); self.fid_computer.init_comp(); self._ctrls_initialized = True; ",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:18274,Modifiability,config,config,18274,"option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). if not self.tslot_computer.compare_amps(new_amps):; if self.config.test_out_amps:; fname = ""amps_{}_{}_{}_call{}{}"".format(; self.id_text,; self.prop_computer.id_text,; self.fid_computer.id_text,; self.stats.num_ctrl_amp_updates,; self.config.test_out_f_ext). fpath = os.path.join(self.config.test_out_dir, fname); self.save_amps(fpath, verbose=True). [docs] def flag_system_changed(self):; """"""; Flag eveolution, fidelity and gradients as needing recalculation; """"""; self.evo_current = False; self.fid_computer.flag_system_changed(). [docs] def get_drift_dim(self):; """"""; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N; """"""; if not isinstance(self.drift_dyn_gen, np.ndarray):; raise TypeError(""Cannot get drift dimension, ""; ""as drift not set (correctly).""); return self.drift_dyn_gen.shape[0]. [docs] def get_num_ctrls(self):; """"""; calculate the of controls from the length of the control list; sets the num_ctrls property, which can be used alternatively; subsequently; """"""; self.num_ctrls ",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:18450,Modifiability,config,config,18450,"e=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). if not self.tslot_computer.compare_amps(new_amps):; if self.config.test_out_amps:; fname = ""amps_{}_{}_{}_call{}{}"".format(; self.id_text,; self.prop_computer.id_text,; self.fid_computer.id_text,; self.stats.num_ctrl_amp_updates,; self.config.test_out_f_ext). fpath = os.path.join(self.config.test_out_dir, fname); self.save_amps(fpath, verbose=True). [docs] def flag_system_changed(self):; """"""; Flag eveolution, fidelity and gradients as needing recalculation; """"""; self.evo_current = False; self.fid_computer.flag_system_changed(). [docs] def get_drift_dim(self):; """"""; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N; """"""; if not isinstance(self.drift_dyn_gen, np.ndarray):; raise TypeError(""Cannot get drift dimension, ""; ""as drift not set (correctly).""); return self.drift_dyn_gen.shape[0]. [docs] def get_num_ctrls(self):; """"""; calculate the of controls from the length of the control list; sets the num_ctrls property, which can be used alternatively; subsequently; """"""; self.num_ctrls = len(self.ctrl_dyn_gen); return self.num_ctrls. [docs] def get_owd_evo_target(self):; """"""; Get the inverse of the target.; Used for calculating the 'backward' evolution; """"""; ",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:18500,Modifiability,config,config,18500,"else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). if not self.tslot_computer.compare_amps(new_amps):; if self.config.test_out_amps:; fname = ""amps_{}_{}_{}_call{}{}"".format(; self.id_text,; self.prop_computer.id_text,; self.fid_computer.id_text,; self.stats.num_ctrl_amp_updates,; self.config.test_out_f_ext). fpath = os.path.join(self.config.test_out_dir, fname); self.save_amps(fpath, verbose=True). [docs] def flag_system_changed(self):; """"""; Flag eveolution, fidelity and gradients as needing recalculation; """"""; self.evo_current = False; self.fid_computer.flag_system_changed(). [docs] def get_drift_dim(self):; """"""; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N; """"""; if not isinstance(self.drift_dyn_gen, np.ndarray):; raise TypeError(""Cannot get drift dimension, ""; ""as drift not set (correctly).""); return self.drift_dyn_gen.shape[0]. [docs] def get_num_ctrls(self):; """"""; calculate the of controls from the length of the control list; sets the num_ctrls property, which can be used alternatively; subsequently; """"""; self.num_ctrls = len(self.ctrl_dyn_gen); return self.num_ctrls. [docs] def get_owd_evo_target(self):; """"""; Get the inverse of the target.; Used for calculating the 'backward' evolution; """"""; return la.inv(self.target). [docs] def combine_dyn",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:23546,Modifiability,config,configuration,23546,"tonians; Note a matrix diagonalisation is used to compute the exponent; The eigen decomposition is also used to calculate the propagator gradient.; The method is taken from DYNAMO (see file header). Attributes; ----------; drift_ham : Qobj; This is the drift Hamiltonian for unitary dynamics; It is mapped to drift_dyn_gen during initialize_controls. ctrl_ham : List of Qobj; These are the control Hamiltonians for unitary dynamics; It is mapped to ctrl_dyn_gen during initialize_controls. H : List of Qobj; The combined drift and control Hamiltonians for each timeslot; These are the dynamics generators for unitary dynamics.; It is mapped to dyn_gen during initialize_controls; """""". def reset(self):; Dynamics.reset(self); self.id_text = 'UNIT'; self.drift_ham = None; self.ctrl_ham = None; self.H = None. def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.amp_update_mode == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). # set the default fidelity computer; self.fid_computer = fidcomp.FidCompUnitary(self); # set the default propagator computer; self.prop_computer = propcomp.PropCompDiag(self). def initialize_controls(self, amplitudes, init_tslots=True):; # Either the _dyn_gen or _ham names can be used; # This assumes that one or other has been set in the configuration. self._map_dyn_gen_to_ham(); Dynamics.initialize_controls(self, amplitudes, init_tslots=init_tslots); self.H = self.dyn_gen. def _map_dyn_gen_to_ham(self):; if self.drift_dyn_gen is None:; self.drift_dyn_gen = self.drift_ham; else:; self.drift_ham = self.drift_dyn_gen. if self.ctrl_dyn_gen is None:; self.ctrl_dyn_gen = self.ctrl_ham; else:; self.ctrl_ham = self.ctrl_dyn_gen. self._dyn_gen_mapped = True. [docs] def get_",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:23601,Modifiability,config,config,23601,"nent; The eigen decomposition is also used to calculate the propagator gradient.; The method is taken from DYNAMO (see file header). Attributes; ----------; drift_ham : Qobj; This is the drift Hamiltonian for unitary dynamics; It is mapped to drift_dyn_gen during initialize_controls. ctrl_ham : List of Qobj; These are the control Hamiltonians for unitary dynamics; It is mapped to ctrl_dyn_gen during initialize_controls. H : List of Qobj; The combined drift and control Hamiltonians for each timeslot; These are the dynamics generators for unitary dynamics.; It is mapped to dyn_gen during initialize_controls; """""". def reset(self):; Dynamics.reset(self); self.id_text = 'UNIT'; self.drift_ham = None; self.ctrl_ham = None; self.H = None. def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.amp_update_mode == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). # set the default fidelity computer; self.fid_computer = fidcomp.FidCompUnitary(self); # set the default propagator computer; self.prop_computer = propcomp.PropCompDiag(self). def initialize_controls(self, amplitudes, init_tslots=True):; # Either the _dyn_gen or _ham names can be used; # This assumes that one or other has been set in the configuration. self._map_dyn_gen_to_ham(); Dynamics.initialize_controls(self, amplitudes, init_tslots=init_tslots); self.H = self.dyn_gen. def _map_dyn_gen_to_ham(self):; if self.drift_dyn_gen is None:; self.drift_dyn_gen = self.drift_ham; else:; self.drift_ham = self.drift_dyn_gen. if self.ctrl_dyn_gen is None:; self.ctrl_dyn_gen = self.ctrl_ham; else:; self.ctrl_ham = self.ctrl_dyn_gen. self._dyn_gen_mapped = True. [docs] def get_dyn_gen(self, k):; """"""; Get the combined dynamics generator for the",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:24102,Modifiability,config,configuration,24102,". H : List of Qobj; The combined drift and control Hamiltonians for each timeslot; These are the dynamics generators for unitary dynamics.; It is mapped to dyn_gen during initialize_controls; """""". def reset(self):; Dynamics.reset(self); self.id_text = 'UNIT'; self.drift_ham = None; self.ctrl_ham = None; self.H = None. def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.amp_update_mode == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). # set the default fidelity computer; self.fid_computer = fidcomp.FidCompUnitary(self); # set the default propagator computer; self.prop_computer = propcomp.PropCompDiag(self). def initialize_controls(self, amplitudes, init_tslots=True):; # Either the _dyn_gen or _ham names can be used; # This assumes that one or other has been set in the configuration. self._map_dyn_gen_to_ham(); Dynamics.initialize_controls(self, amplitudes, init_tslots=init_tslots); self.H = self.dyn_gen. def _map_dyn_gen_to_ham(self):; if self.drift_dyn_gen is None:; self.drift_dyn_gen = self.drift_ham; else:; self.drift_ham = self.drift_dyn_gen. if self.ctrl_dyn_gen is None:; self.ctrl_dyn_gen = self.ctrl_ham; else:; self.ctrl_ham = self.ctrl_dyn_gen. self._dyn_gen_mapped = True. [docs] def get_dyn_gen(self, k):; """"""; Get the combined dynamics generator for the timeslot; including the -i factor; """"""; return -1j*self.dyn_gen[k]. [docs] def get_ctrl_dyn_gen(self, j):; """"""; Get the dynamics generator for the control; including the -i factor; """"""; return -1j*self.ctrl_dyn_gen[j]. def get_num_ctrls(self):; if not self._dyn_gen_mapped:; self._map_dyn_gen_to_ham(); return Dynamics.get_num_ctrls(self). def get_owd_evo_target(self):; return self.target.conj().T. [docs] def spectral_d",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:27429,Modifiability,config,configuration,27429,"fs[degen_mask] = 1; factors = prop_eig_diffs / eig_val_diffs; # for degenerate eigenvalues the factor is just the exponent; factors[degen_mask] = prop_eig_cols[degen_mask]. # Store eigenvals and eigenvectors for use by other functions, e.g.; # gradient_exact; self.decomp_curr[k] = True; self.prop_eigen[k] = prop_eig; self.dyn_gen_eigenvectors[k] = eig_vec; self.dyn_gen_factormatrix[k] = factors. [docs]class DynamicsSymplectic(Dynamics):; """"""; Symplectic systems; This is the subclass to use for systems where the dynamics is described; by symplectic matrices, e.g. coupled oscillators, quantum optics. Attributes; ----------; omega : array[drift_dyn_gen.shape]; matrix used in the calculation of propagators (time evolution); with symplectic systems.; """""". def reset(self):; Dynamics.reset(self); self.id_text = 'SYMPL'; self.omega = None; self.grad_exact = True. def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.amp_update_mode == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). def get_omega(self):; if self.omega is None:; n = self.drift_dyn_gen.shape[0] // 2; self.omega = sympl.calc_omega(n). return self.omega. [docs] def get_dyn_gen(self, k):; """"""; Get the combined dynamics generator for the timeslot; multiplied by omega; """"""; o = self.get_omega(); return self.dyn_gen[k].dot(o). [docs] def get_ctrl_dyn_gen(self, j):; """"""; Get the dynamics generator for the control; multiplied by omega; """"""; o = self.get_omega(); return self.ctrl_dyn_gen[j].dot(o). Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:27484,Modifiability,config,config,27484,"fs[degen_mask] = 1; factors = prop_eig_diffs / eig_val_diffs; # for degenerate eigenvalues the factor is just the exponent; factors[degen_mask] = prop_eig_cols[degen_mask]. # Store eigenvals and eigenvectors for use by other functions, e.g.; # gradient_exact; self.decomp_curr[k] = True; self.prop_eigen[k] = prop_eig; self.dyn_gen_eigenvectors[k] = eig_vec; self.dyn_gen_factormatrix[k] = factors. [docs]class DynamicsSymplectic(Dynamics):; """"""; Symplectic systems; This is the subclass to use for systems where the dynamics is described; by symplectic matrices, e.g. coupled oscillators, quantum optics. Attributes; ----------; omega : array[drift_dyn_gen.shape]; matrix used in the calculation of propagators (time evolution); with symplectic systems.; """""". def reset(self):; Dynamics.reset(self); self.id_text = 'SYMPL'; self.omega = None; self.grad_exact = True. def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.amp_update_mode == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). def get_omega(self):; if self.omega is None:; n = self.drift_dyn_gen.shape[0] // 2; self.omega = sympl.calc_omega(n). return self.omega. [docs] def get_dyn_gen(self, k):; """"""; Get the combined dynamics generator for the timeslot; multiplied by omega; """"""; o = self.get_omega(); return self.dyn_gen[k].dot(o). [docs] def get_ctrl_dyn_gen(self, j):; """"""; Get the dynamics generator for the control; multiplied by omega; """"""; o = self.get_omega(); return self.ctrl_dyn_gen[j].dot(o). Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:5439,Performance,perform,performance,5439,"rol modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl. [docs]class Dynamics:; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before any of the methods; can be used. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; Note value should be set using set_log_level. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer : PropagatorComputer (subclass instance); Used to compute the propagators and their gradients. fid_computer : FidelityComputer (subclass instance); Used to computer the fidelity error and the fidelity error; gradient. num_tslots : integer; Number of timeslots, aka timeslices. num_ctrls : integer; Number of controls.; Note this is set when get_num_ctrls is called based on the; length of ctrl_dyn_gen. evo_time : float; Total time for the evolution. tau : array[num_tslots] of float; Duration of each timeslot; Note that if this is set before initialize_controls is called; then num_tslots and evo_time are calculated from tau, otherwise; tau is generated from num_tslots and evo_time, that is; equal size time s",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:26195,Safety,avoid,avoid,26195,"nalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; """"""; H = self.H[k]; # assuming H is an nxn matrix, find n; n = H.shape[0]; # returns row vector of eigen values,; # columns with the eigenvectors; eig_val, eig_vec = np.linalg.eig(H). # Calculate the propagator in the diagonalised basis; eig_val_tau = -1j*eig_val*self.tau[k]; prop_eig = np.exp(eig_val_tau). # Generate the factor matrix through the differences; # between each of the eigenvectors and the exponentiations; # create nxn matrix where each eigen val is repeated n times; # down the columns; o = np.ones([n, n]); eig_val_cols = eig_val_tau*o; # calculate all the differences by subtracting it from its transpose; eig_val_diffs = eig_val_cols - eig_val_cols.T; # repeat for the propagator; prop_eig_cols = prop_eig*o; prop_eig_diffs = prop_eig_cols - prop_eig_cols.T; # the factor matrix is the elementwise quotient of the; # differeneces between the exponentiated eigen vals and the; # differences between the eigen vals; # need to avoid division by zero that would arise due to denegerate; # eigenvalues and the diagonals; degen_mask = np.abs(eig_val_diffs) < self.fact_mat_round_prec; eig_val_diffs[degen_mask] = 1; factors = prop_eig_diffs / eig_val_diffs; # for degenerate eigenvalues the factor is just the exponent; factors[degen_mask] = prop_eig_cols[degen_mask]. # Store eigenvals and eigenvectors for use by other functions, e.g.; # gradient_exact; self.decomp_curr[k] = True; self.prop_eigen[k] = prop_eig; self.dyn_gen_eigenvectors[k] = eig_vec; self.dyn_gen_factormatrix[k] = factors. [docs]class DynamicsSymplectic(Dynamics):; """"""; Symplectic systems; This is the subclass to use for systems where the dynamics is described; by symplectic matrices, e.g. coupled oscillators, quantum optics. Attributes; ----------; omega : array[drift_dyn_gen.shape]; matrix used in the calculation of propagators (time evolution); with symplectic systems.; """""". def reset(self):; Dynamics.reset(self); sel",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:4379,Testability,log,logging,4379,"rd; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes that define the dynamics of the (quantum) system and target evolution; to be optimised.; The contols are also defined here, i.e. the dynamics generators (Hamiltonians,; Limbladians etc). The dynamics for the time slices are calculated here, along; with the evolution as determined by the control amplitudes. See the subclass descriptions and choose the appropriate class for the; application. The choice depends on the type of matrix used to define; the dynamics. These class implement functions for getting the dynamics generators for; the combined (drift + ctrls) dynamics with the approriate operator applied. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """"""; import os; import numpy as np; import scipy.linalg as la; from six import string_types; # QuTiP logging; import qutip.logging as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl. [docs]class Dynamics:; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before any of the methods; can be used. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; Note value ",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:4401,Testability,log,logging,4401,"rd@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes that define the dynamics of the (quantum) system and target evolution; to be optimised.; The contols are also defined here, i.e. the dynamics generators (Hamiltonians,; Limbladians etc). The dynamics for the time slices are calculated here, along; with the evolution as determined by the control amplitudes. See the subclass descriptions and choose the appropriate class for the; application. The choice depends on the type of matrix used to define; the dynamics. These class implement functions for getting the dynamics generators for; the combined (drift + ctrls) dynamics with the approriate operator applied. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """"""; import os; import numpy as np; import scipy.linalg as la; from six import string_types; # QuTiP logging; import qutip.logging as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl. [docs]class Dynamics:; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before any of the methods; can be used. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; Note value should be set using set_log_level. stats : Stats; Attrib",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:4412,Testability,log,logging,4412,"rd@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes that define the dynamics of the (quantum) system and target evolution; to be optimised.; The contols are also defined here, i.e. the dynamics generators (Hamiltonians,; Limbladians etc). The dynamics for the time slices are calculated here, along; with the evolution as determined by the control amplitudes. See the subclass descriptions and choose the appropriate class for the; application. The choice depends on the type of matrix used to define; the dynamics. These class implement functions for getting the dynamics generators for; the combined (drift + ctrls) dynamics with the approriate operator applied. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """"""; import os; import numpy as np; import scipy.linalg as la; from six import string_types; # QuTiP logging; import qutip.logging as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl. [docs]class Dynamics:; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before any of the methods; can be used. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; Note value should be set using set_log_level. stats : Stats; Attrib",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:4421,Testability,log,logger,4421,"rd@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes that define the dynamics of the (quantum) system and target evolution; to be optimised.; The contols are also defined here, i.e. the dynamics generators (Hamiltonians,; Limbladians etc). The dynamics for the time slices are calculated here, along; with the evolution as determined by the control amplitudes. See the subclass descriptions and choose the appropriate class for the; application. The choice depends on the type of matrix used to define; the dynamics. These class implement functions for getting the dynamics generators for; the combined (drift + ctrls) dynamics with the approriate operator applied. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """"""; import os; import numpy as np; import scipy.linalg as la; from six import string_types; # QuTiP logging; import qutip.logging as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl. [docs]class Dynamics:; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before any of the methods; can be used. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; Note value should be set using set_log_level. stats : Stats; Attrib",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:4430,Testability,log,logging,4430,"rd@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes that define the dynamics of the (quantum) system and target evolution; to be optimised.; The contols are also defined here, i.e. the dynamics generators (Hamiltonians,; Limbladians etc). The dynamics for the time slices are calculated here, along; with the evolution as determined by the control amplitudes. See the subclass descriptions and choose the appropriate class for the; application. The choice depends on the type of matrix used to define; the dynamics. These class implement functions for getting the dynamics generators for; the combined (drift + ctrls) dynamics with the approriate operator applied. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """"""; import os; import numpy as np; import scipy.linalg as la; from six import string_types; # QuTiP logging; import qutip.logging as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl. [docs]class Dynamics:; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before any of the methods; can be used. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; Note value should be set using set_log_level. stats : Stats; Attrib",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:4985,Testability,log,logger,4985,"trix used to define; the dynamics. These class implement functions for getting the dynamics generators for; the combined (drift + ctrls) dynamics with the approriate operator applied. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """"""; import os; import numpy as np; import scipy.linalg as la; from six import string_types; # QuTiP logging; import qutip.logging as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl. [docs]class Dynamics:; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before any of the methods; can be used. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; Note value should be set using set_log_level. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer : PropagatorComputer (subclass instance); Used to compute the propagators and their gradients. fid_computer : FidelityComputer (subclass instance); Used to computer the fidelity error and the fide",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:5026,Testability,log,logging,5026,"Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """"""; import os; import numpy as np; import scipy.linalg as la; from six import string_types; # QuTiP logging; import qutip.logging as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl. [docs]class Dynamics:; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before any of the methods; can be used. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; Note value should be set using set_log_level. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer : PropagatorComputer (subclass instance); Used to compute the propagators and their gradients. fid_computer : FidelityComputer (subclass instance); Used to computer the fidelity error and the fidelity error; gradient. num_tslots : integer; Number of timeslots, aka timeslices. num_ctrls : integer; Number of controls.; Note this is set when get_num_ctrls is called based on the; l",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:11093,Testability,log,logger,11093,"f reset(self):; # Main functional attributes; self.evo_time = 0; self.num_tslots = 0; self.tau = None; self.time = None; self.initial = None; self.target = None; self.ctrl_amps = None; self.initial_ctrl_scaling = 1.0; self.initial_ctrl_offset = 0.0; self.drift_dyn_gen = None; self.ctrl_dyn_gen = None; self.dyn_gen = None; self.prop = None; self.prop_grad = None; self.evo_init2t = None; self.evo_t2end = None; self.evo_t2targ = None; # Atrributes used in diagonalisation; self.decomp_curr = None; self.prop_eigen = None; self.dyn_gen_eigenvectors = None; self.dyn_gen_factormatrix = None; self.fact_mat_round_prec = 1e-10. # Debug and information attribs; self.stats = None; self.id_text = 'DYN_BASE'; self.def_amps_fname = ""ctrl_amps.txt""; self.set_log_level(self.config.log_level); # Internal flags; self._dyn_gen_mapped = False; self._ctrls_initialized = False. # Create the computing objects; self._create_computers(). self.clear(). [docs] def set_log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; self.log_level = lvl; logger.setLevel(lvl). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to UpdateAll; # can be set to DynUpdate in the configuration; # (see class file for details); if self.config.amp_update_mode == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). def clear(self):; self.ctrl_amps = None; self.evo_current = False; if self.fid_computer is not None:; self.fid_computer.clear(). [docs] def init_time_slots(self):; """"""; Generate the timeslot duration array 'tau' based on the evo_time; and num_tslots attributes, unless the tau attribute is already set; in which case this step in ignored; Generate the cum",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:11114,Testability,log,logger,11114,"f reset(self):; # Main functional attributes; self.evo_time = 0; self.num_tslots = 0; self.tau = None; self.time = None; self.initial = None; self.target = None; self.ctrl_amps = None; self.initial_ctrl_scaling = 1.0; self.initial_ctrl_offset = 0.0; self.drift_dyn_gen = None; self.ctrl_dyn_gen = None; self.dyn_gen = None; self.prop = None; self.prop_grad = None; self.evo_init2t = None; self.evo_t2end = None; self.evo_t2targ = None; # Atrributes used in diagonalisation; self.decomp_curr = None; self.prop_eigen = None; self.dyn_gen_eigenvectors = None; self.dyn_gen_factormatrix = None; self.fact_mat_round_prec = 1e-10. # Debug and information attribs; self.stats = None; self.id_text = 'DYN_BASE'; self.def_amps_fname = ""ctrl_amps.txt""; self.set_log_level(self.config.log_level); # Internal flags; self._dyn_gen_mapped = False; self._ctrls_initialized = False. # Create the computing objects; self._create_computers(). self.clear(). [docs] def set_log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; self.log_level = lvl; logger.setLevel(lvl). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to UpdateAll; # can be set to DynUpdate in the configuration; # (see class file for details); if self.config.amp_update_mode == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). def clear(self):; self.ctrl_amps = None; self.evo_current = False; if self.fid_computer is not None:; self.fid_computer.clear(). [docs] def init_time_slots(self):; """"""; Generate the timeslot duration array 'tau' based on the evo_time; and num_tslots attributes, unless the tau attribute is already set; in which case this step in ignored; Generate the cum",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:11163,Testability,log,logger,11163,"e; self.time = None; self.initial = None; self.target = None; self.ctrl_amps = None; self.initial_ctrl_scaling = 1.0; self.initial_ctrl_offset = 0.0; self.drift_dyn_gen = None; self.ctrl_dyn_gen = None; self.dyn_gen = None; self.prop = None; self.prop_grad = None; self.evo_init2t = None; self.evo_t2end = None; self.evo_t2targ = None; # Atrributes used in diagonalisation; self.decomp_curr = None; self.prop_eigen = None; self.dyn_gen_eigenvectors = None; self.dyn_gen_factormatrix = None; self.fact_mat_round_prec = 1e-10. # Debug and information attribs; self.stats = None; self.id_text = 'DYN_BASE'; self.def_amps_fname = ""ctrl_amps.txt""; self.set_log_level(self.config.log_level); # Internal flags; self._dyn_gen_mapped = False; self._ctrls_initialized = False. # Create the computing objects; self._create_computers(). self.clear(). [docs] def set_log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; self.log_level = lvl; logger.setLevel(lvl). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to UpdateAll; # can be set to DynUpdate in the configuration; # (see class file for details); if self.config.amp_update_mode == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). def clear(self):; self.ctrl_amps = None; self.evo_current = False; if self.fid_computer is not None:; self.fid_computer.clear(). [docs] def init_time_slots(self):; """"""; Generate the timeslot duration array 'tau' based on the evo_time; and num_tslots attributes, unless the tau attribute is already set; in which case this step in ignored; Generate the cumulative time array 'time' based on the tau values; """"""; # set the time intervals to be equal timesl",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:14570,Testability,log,logger,14570,"vo_t2targ:; # Onward propagation overlap with inverse target; self.evo_t2targ = [np.empty(shp, dtype=complex); for x in range(self.num_tslots + 1)]; self.evo_t2targ[-1] = self.get_owd_evo_target(). if isinstance(self.prop_computer, propcomp.PropCompDiag):; self._create_decomp_lists(). def _create_decomp_lists(self):; """"""; Create lists that will hold the eigen decomposition; used in calculating propagators and gradients; Note: used with PropCompDiag propagator calcs; """"""; shp = self.drift_dyn_gen.shape; n_ts = self.num_tslots; self.decomp_curr = [False for x in range(n_ts)]; self.prop_eigen = \; [np.empty(shp[0], dtype=complex) for x in range(n_ts)]; self.dyn_gen_eigenvectors = \; [np.empty(shp, dtype=complex) for x in range(n_ts)]; self.dyn_gen_factormatrix = \; [np.empty(shp, dtype=complex) for x in range(n_ts)]. def _check_test_out_files(self):; cfg = self.config; if cfg.any_test_files():; if not cfg.check_create_test_out_dir():; cfg.reset_test_out_files(); else:; if self.stats is None:; logger.warn(""Cannot output test files when stats""; "" attribute is not set.""); self.config.test_out_amps = False; self.config.test_out_prop = False; self.config.test_out_prop_grad = False; self.config.test_out_evo = False. [docs] def initialize_controls(self, amps, init_tslots=True):; """"""; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated; """"""; self._check_test_out_files(). if not isinstance(self.prop_computer, propcomp.PropagatorComputer):; raise errors.UsageError(; ""No prop_computer (propagator computer) ""; ""set. A default should be assigned by the Dynamics subclass""). if not isinstance(self.tslot_computer, tslotcomp.TimeslotComputer):; raise errors.UsageError(; ""No tslot_computer (Timeslot computer)""; "" set. A default should be assigned by the Dynamics class""). if not isinstance(self.fid_computer, fidcomp.FideliyComputer):; raise errors.UsageError(; ""No fid_computer (Fidelity com",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:14597,Testability,test,test,14597," inverse target; self.evo_t2targ = [np.empty(shp, dtype=complex); for x in range(self.num_tslots + 1)]; self.evo_t2targ[-1] = self.get_owd_evo_target(). if isinstance(self.prop_computer, propcomp.PropCompDiag):; self._create_decomp_lists(). def _create_decomp_lists(self):; """"""; Create lists that will hold the eigen decomposition; used in calculating propagators and gradients; Note: used with PropCompDiag propagator calcs; """"""; shp = self.drift_dyn_gen.shape; n_ts = self.num_tslots; self.decomp_curr = [False for x in range(n_ts)]; self.prop_eigen = \; [np.empty(shp[0], dtype=complex) for x in range(n_ts)]; self.dyn_gen_eigenvectors = \; [np.empty(shp, dtype=complex) for x in range(n_ts)]; self.dyn_gen_factormatrix = \; [np.empty(shp, dtype=complex) for x in range(n_ts)]. def _check_test_out_files(self):; cfg = self.config; if cfg.any_test_files():; if not cfg.check_create_test_out_dir():; cfg.reset_test_out_files(); else:; if self.stats is None:; logger.warn(""Cannot output test files when stats""; "" attribute is not set.""); self.config.test_out_amps = False; self.config.test_out_prop = False; self.config.test_out_prop_grad = False; self.config.test_out_evo = False. [docs] def initialize_controls(self, amps, init_tslots=True):; """"""; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated; """"""; self._check_test_out_files(). if not isinstance(self.prop_computer, propcomp.PropagatorComputer):; raise errors.UsageError(; ""No prop_computer (propagator computer) ""; ""set. A default should be assigned by the Dynamics subclass""). if not isinstance(self.tslot_computer, tslotcomp.TimeslotComputer):; raise errors.UsageError(; ""No tslot_computer (Timeslot computer)""; "" set. A default should be assigned by the Dynamics class""). if not isinstance(self.fid_computer, fidcomp.FideliyComputer):; raise errors.UsageError(; ""No fid_computer (Fidelity computer)""; "" set. A default should be assigned ",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:16947,Testability,log,logged,16947,"s(amps). def check_ctrls_initialized(self):; if not self._ctrls_initialized:; raise errors.UsageError(; ""Controls not initialised. ""; ""Ensure Dynamics.initialize_controls has been ""; ""executed with the initial control amplitudes.""). def get_amp_times(self):; return self.time[:self.num_tslots]. [docs] def save_amps(self, file_name=None, times=None, amps=None, verbose=False):; """"""; Save a file with the current control amplitudes in each timeslot; The first column in the file will be the start time of the slot. Parameters; ----------; file_name : string; Name of the file; If None given the def_amps_fname attribuite will be used. times : List type (or string); List / array of the start times for each slot; If None given this will be retrieved through get_amp_times(); If 'exclude' then times will not be saved in the file, just; the amplitudes. amps : Array[num_tslots, num_ctrls]; Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verbose : Boolean; If True then an info message will be logged; """"""; self.check_ctrls_initialized(). inctimes = True; if file_name is None:; file_name = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if isinstance(times, string_types):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is ",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:17256,Testability,log,logger,17256,"ve_amps(self, file_name=None, times=None, amps=None, verbose=False):; """"""; Save a file with the current control amplitudes in each timeslot; The first column in the file will be the start time of the slot. Parameters; ----------; file_name : string; Name of the file; If None given the def_amps_fname attribuite will be used. times : List type (or string); List / array of the start times for each slot; If None given this will be retrieved through get_amp_times(); If 'exclude' then times will not be saved in the file, just; the amplitudes. amps : Array[num_tslots, num_ctrls]; Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verbose : Boolean; If True then an info message will be logged; """"""; self.check_ctrls_initialized(). inctimes = True; if file_name is None:; file_name = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if isinstance(times, string_types):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). if not self.tslot_comp",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:17595,Testability,log,logger,17595," List / array of the start times for each slot; If None given this will be retrieved through get_amp_times(); If 'exclude' then times will not be saved in the file, just; the amplitudes. amps : Array[num_tslots, num_ctrls]; Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verbose : Boolean; If True then an info message will be logged; """"""; self.check_ctrls_initialized(). inctimes = True; if file_name is None:; file_name = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if isinstance(times, string_types):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). if not self.tslot_computer.compare_amps(new_amps):; if self.config.test_out_amps:; fname = ""amps_{}_{}_{}_call{}{}"".format(; self.id_text,; self.prop_computer.id_text,; self.fid_computer.id_text,; self.stats.num_ctrl_amp_updates,; self.config.test_out_f_ext). fpath = os.path.join(self.config.test_out_dir, fname); self.save_amps(fpath, verbose=True). [docs] def flag_system_cha",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:17674,Testability,log,logger,17674," None given this will be retrieved through get_amp_times(); If 'exclude' then times will not be saved in the file, just; the amplitudes. amps : Array[num_tslots, num_ctrls]; Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verbose : Boolean; If True then an info message will be logged; """"""; self.check_ctrls_initialized(). inctimes = True; if file_name is None:; file_name = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if isinstance(times, string_types):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). if not self.tslot_computer.compare_amps(new_amps):; if self.config.test_out_amps:; fname = ""amps_{}_{}_{}_call{}{}"".format(; self.id_text,; self.prop_computer.id_text,; self.fid_computer.id_text,; self.stats.num_ctrl_amp_updates,; self.config.test_out_f_ext). fpath = os.path.join(self.config.test_out_dir, fname); self.save_amps(fpath, verbose=True). [docs] def flag_system_changed(self):; """"""; Flag eveolution, fidelity and gr",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:18018,Testability,log,logging,18018,"e_name is None:; file_name = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if isinstance(times, string_types):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). if not self.tslot_computer.compare_amps(new_amps):; if self.config.test_out_amps:; fname = ""amps_{}_{}_{}_call{}{}"".format(; self.id_text,; self.prop_computer.id_text,; self.fid_computer.id_text,; self.stats.num_ctrl_amp_updates,; self.config.test_out_f_ext). fpath = os.path.join(self.config.test_out_dir, fname); self.save_amps(fpath, verbose=True). [docs] def flag_system_changed(self):; """"""; Flag eveolution, fidelity and gradients as needing recalculation; """"""; self.evo_current = False; self.fid_computer.flag_system_changed(). [docs] def get_drift_dim(self):; """"""; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N; """"""; if not isinstance(self.drift_dyn_gen, np.ndarray):; raise TypeError(""Cannot get drift dimension, ""; ""as d",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:18042,Testability,log,logger,18042,"name = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if isinstance(times, string_types):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). if not self.tslot_computer.compare_amps(new_amps):; if self.config.test_out_amps:; fname = ""amps_{}_{}_{}_call{}{}"".format(; self.id_text,; self.prop_computer.id_text,; self.fid_computer.id_text,; self.stats.num_ctrl_amp_updates,; self.config.test_out_f_ext). fpath = os.path.join(self.config.test_out_dir, fname); self.save_amps(fpath, verbose=True). [docs] def flag_system_changed(self):; """"""; Flag eveolution, fidelity and gradients as needing recalculation; """"""; self.evo_current = False; self.fid_computer.flag_system_changed(). [docs] def get_drift_dim(self):; """"""; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N; """"""; if not isinstance(self.drift_dyn_gen, np.ndarray):; raise TypeError(""Cannot get drift dimension, ""; ""as drift not set (correctl",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:18049,Testability,log,log,18049,"ps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if isinstance(times, string_types):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). if not self.tslot_computer.compare_amps(new_amps):; if self.config.test_out_amps:; fname = ""amps_{}_{}_{}_call{}{}"".format(; self.id_text,; self.prop_computer.id_text,; self.fid_computer.id_text,; self.stats.num_ctrl_amp_updates,; self.config.test_out_f_ext). fpath = os.path.join(self.config.test_out_dir, fname); self.save_amps(fpath, verbose=True). [docs] def flag_system_changed(self):; """"""; Flag eveolution, fidelity and gradients as needing recalculation; """"""; self.evo_current = False; self.fid_computer.flag_system_changed(). [docs] def get_drift_dim(self):; """"""; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N; """"""; if not isinstance(self.drift_dyn_gen, np.ndarray):; raise TypeError(""Cannot get drift dimension, ""; ""as drift not set (correctly).""); return sel",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:18053,Testability,log,logging,18053,"ps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if isinstance(times, string_types):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). if not self.tslot_computer.compare_amps(new_amps):; if self.config.test_out_amps:; fname = ""amps_{}_{}_{}_call{}{}"".format(; self.id_text,; self.prop_computer.id_text,; self.fid_computer.id_text,; self.stats.num_ctrl_amp_updates,; self.config.test_out_f_ext). fpath = os.path.join(self.config.test_out_dir, fname); self.save_amps(fpath, verbose=True). [docs] def flag_system_changed(self):; """"""; Flag eveolution, fidelity and gradients as needing recalculation; """"""; self.evo_current = False; self.fid_computer.flag_system_changed(). [docs] def get_drift_dim(self):; """"""; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N; """"""; if not isinstance(self.drift_dyn_gen, np.ndarray):; raise TypeError(""Cannot get drift dimension, ""; ""as drift not set (correctly).""); return sel",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:20639,Testability,log,logging,20639,"g = np.asarray(self.drift_dyn_gen); for j in range(self.get_num_ctrls()):; dg = dg + self.ctrl_amps[k, j]*np.asarray(self.ctrl_dyn_gen[j]); return dg. [docs] def get_dyn_gen(self, k):; """"""; Get the combined dynamics generator for the timeslot; Not implemented in the base class. Choose a subclass; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs] def get_ctrl_dyn_gen(self, j):; """"""; Get the dynamics generator for the control; Not implemented in the base class. Choose a subclass; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs] def compute_evolution(self):; """"""; Recalculate the time evolution operators; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; Actual work is completed by the recompute_evolution method; of the timeslot computer; """""". # Check if values are already current, otherwise calculate all values; if not self.evo_current:; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Computing evolution""); self.tslot_computer.recompute_evolution(); self.evo_current = True; return True; else:; return False. [docs] def ensure_decomp_curr(self, k):; """"""; Checks to see if the diagonalisation has been completed since; the last update of the dynamics generators; (after the amplitude update); If not then the diagonlisation is completed; """"""; if self.decomp_curr is None:; raise errors.UsageError(""Decomp lists have not been created""); if not self.decomp_curr[k]:; self.spectral_decomp(k). [docs] def spectral_decomp(self, k):; """"""; Calculate the diagonalization of the dynamics generator; generating lists of eigenvectors, propagators in the diagonalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; Not implemented in this base class, because the method is specific; to the matrix type; """"""; raise errors.UsageError(""Decomposition cannot be completed by ""; ""this class. Try a(nother) subcla",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:20663,Testability,log,logger,20663,"ift_dyn_gen); for j in range(self.get_num_ctrls()):; dg = dg + self.ctrl_amps[k, j]*np.asarray(self.ctrl_dyn_gen[j]); return dg. [docs] def get_dyn_gen(self, k):; """"""; Get the combined dynamics generator for the timeslot; Not implemented in the base class. Choose a subclass; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs] def get_ctrl_dyn_gen(self, j):; """"""; Get the dynamics generator for the control; Not implemented in the base class. Choose a subclass; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs] def compute_evolution(self):; """"""; Recalculate the time evolution operators; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; Actual work is completed by the recompute_evolution method; of the timeslot computer; """""". # Check if values are already current, otherwise calculate all values; if not self.evo_current:; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Computing evolution""); self.tslot_computer.recompute_evolution(); self.evo_current = True; return True; else:; return False. [docs] def ensure_decomp_curr(self, k):; """"""; Checks to see if the diagonalisation has been completed since; the last update of the dynamics generators; (after the amplitude update); If not then the diagonlisation is completed; """"""; if self.decomp_curr is None:; raise errors.UsageError(""Decomp lists have not been created""); if not self.decomp_curr[k]:; self.spectral_decomp(k). [docs] def spectral_decomp(self, k):; """"""; Calculate the diagonalization of the dynamics generator; generating lists of eigenvectors, propagators in the diagonalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; Not implemented in this base class, because the method is specific; to the matrix type; """"""; raise errors.UsageError(""Decomposition cannot be completed by ""; ""this class. Try a(nother) subclass""). class DynamicsGe",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:20670,Testability,log,log,20670,"j in range(self.get_num_ctrls()):; dg = dg + self.ctrl_amps[k, j]*np.asarray(self.ctrl_dyn_gen[j]); return dg. [docs] def get_dyn_gen(self, k):; """"""; Get the combined dynamics generator for the timeslot; Not implemented in the base class. Choose a subclass; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs] def get_ctrl_dyn_gen(self, j):; """"""; Get the dynamics generator for the control; Not implemented in the base class. Choose a subclass; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs] def compute_evolution(self):; """"""; Recalculate the time evolution operators; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; Actual work is completed by the recompute_evolution method; of the timeslot computer; """""". # Check if values are already current, otherwise calculate all values; if not self.evo_current:; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Computing evolution""); self.tslot_computer.recompute_evolution(); self.evo_current = True; return True; else:; return False. [docs] def ensure_decomp_curr(self, k):; """"""; Checks to see if the diagonalisation has been completed since; the last update of the dynamics generators; (after the amplitude update); If not then the diagonlisation is completed; """"""; if self.decomp_curr is None:; raise errors.UsageError(""Decomp lists have not been created""); if not self.decomp_curr[k]:; self.spectral_decomp(k). [docs] def spectral_decomp(self, k):; """"""; Calculate the diagonalization of the dynamics generator; generating lists of eigenvectors, propagators in the diagonalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; Not implemented in this base class, because the method is specific; to the matrix type; """"""; raise errors.UsageError(""Decomposition cannot be completed by ""; ""this class. Try a(nother) subclass""). class DynamicsGenMat(Dynamics):; ",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:20674,Testability,log,logging,20674,"j in range(self.get_num_ctrls()):; dg = dg + self.ctrl_amps[k, j]*np.asarray(self.ctrl_dyn_gen[j]); return dg. [docs] def get_dyn_gen(self, k):; """"""; Get the combined dynamics generator for the timeslot; Not implemented in the base class. Choose a subclass; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs] def get_ctrl_dyn_gen(self, j):; """"""; Get the dynamics generator for the control; Not implemented in the base class. Choose a subclass; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs] def compute_evolution(self):; """"""; Recalculate the time evolution operators; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; Actual work is completed by the recompute_evolution method; of the timeslot computer; """""". # Check if values are already current, otherwise calculate all values; if not self.evo_current:; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Computing evolution""); self.tslot_computer.recompute_evolution(); self.evo_current = True; return True; else:; return False. [docs] def ensure_decomp_curr(self, k):; """"""; Checks to see if the diagonalisation has been completed since; the last update of the dynamics generators; (after the amplitude update); If not then the diagonlisation is completed; """"""; if self.decomp_curr is None:; raise errors.UsageError(""Decomp lists have not been created""); if not self.decomp_curr[k]:; self.spectral_decomp(k). [docs] def spectral_decomp(self, k):; """"""; Calculate the diagonalization of the dynamics generator; generating lists of eigenvectors, propagators in the diagonalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; Not implemented in this base class, because the method is specific; to the matrix type; """"""; raise errors.UsageError(""Decomposition cannot be completed by ""; ""this class. Try a(nother) subclass""). class DynamicsGenMat(Dynamics):; ",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:10988,Usability,clear,clear,10988,"_(self, optimconfig):; self.config = optimconfig; self.reset(). def reset(self):; # Main functional attributes; self.evo_time = 0; self.num_tslots = 0; self.tau = None; self.time = None; self.initial = None; self.target = None; self.ctrl_amps = None; self.initial_ctrl_scaling = 1.0; self.initial_ctrl_offset = 0.0; self.drift_dyn_gen = None; self.ctrl_dyn_gen = None; self.dyn_gen = None; self.prop = None; self.prop_grad = None; self.evo_init2t = None; self.evo_t2end = None; self.evo_t2targ = None; # Atrributes used in diagonalisation; self.decomp_curr = None; self.prop_eigen = None; self.dyn_gen_eigenvectors = None; self.dyn_gen_factormatrix = None; self.fact_mat_round_prec = 1e-10. # Debug and information attribs; self.stats = None; self.id_text = 'DYN_BASE'; self.def_amps_fname = ""ctrl_amps.txt""; self.set_log_level(self.config.log_level); # Internal flags; self._dyn_gen_mapped = False; self._ctrls_initialized = False. # Create the computing objects; self._create_computers(). self.clear(). [docs] def set_log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; self.log_level = lvl; logger.setLevel(lvl). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to UpdateAll; # can be set to DynUpdate in the configuration; # (see class file for details); if self.config.amp_update_mode == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). def clear(self):; self.ctrl_amps = None; self.evo_current = False; if self.fid_computer is not None:; self.fid_computer.clear(). [docs] def init_time_slots(self):; """"""; Generate the timeslot duration array 'tau' based on the evo_time; and num_tslots attributes, unless the tau attribute i",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:11708,Usability,clear,clear,11708," self.stats = None; self.id_text = 'DYN_BASE'; self.def_amps_fname = ""ctrl_amps.txt""; self.set_log_level(self.config.log_level); # Internal flags; self._dyn_gen_mapped = False; self._ctrls_initialized = False. # Create the computing objects; self._create_computers(). self.clear(). [docs] def set_log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; self.log_level = lvl; logger.setLevel(lvl). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to UpdateAll; # can be set to DynUpdate in the configuration; # (see class file for details); if self.config.amp_update_mode == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). def clear(self):; self.ctrl_amps = None; self.evo_current = False; if self.fid_computer is not None:; self.fid_computer.clear(). [docs] def init_time_slots(self):; """"""; Generate the timeslot duration array 'tau' based on the evo_time; and num_tslots attributes, unless the tau attribute is already set; in which case this step in ignored; Generate the cumulative time array 'time' based on the tau values; """"""; # set the time intervals to be equal timeslices of the total if; # the have not been set already (as part of user config); if self.tau is None:; self.tau = np.ones(self.num_tslots, dtype='f') * \; self.evo_time/self.num_tslots; self.time = np.zeros(self.num_tslots+1, dtype=float); # set the cumulative time by summing the time intervals; for t in range(self.num_tslots):; self.time[t+1] = self.time[t] + self.tau[t]. def _init_lists(self):; """"""; Create the container lists / arrays for the:; dynamics generations, propagators, and evolutions etc; Set the time slices and cumulative time; """""". # Crea",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:11824,Usability,clear,clear,11824,"fig.log_level); # Internal flags; self._dyn_gen_mapped = False; self._ctrls_initialized = False. # Create the computing objects; self._create_computers(). self.clear(). [docs] def set_log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; self.log_level = lvl; logger.setLevel(lvl). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to UpdateAll; # can be set to DynUpdate in the configuration; # (see class file for details); if self.config.amp_update_mode == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). def clear(self):; self.ctrl_amps = None; self.evo_current = False; if self.fid_computer is not None:; self.fid_computer.clear(). [docs] def init_time_slots(self):; """"""; Generate the timeslot duration array 'tau' based on the evo_time; and num_tslots attributes, unless the tau attribute is already set; in which case this step in ignored; Generate the cumulative time array 'time' based on the tau values; """"""; # set the time intervals to be equal timeslices of the total if; # the have not been set already (as part of user config); if self.tau is None:; self.tau = np.ones(self.num_tslots, dtype='f') * \; self.evo_time/self.num_tslots; self.time = np.zeros(self.num_tslots+1, dtype=float); # set the cumulative time by summing the time intervals; for t in range(self.num_tslots):; self.time[t+1] = self.time[t] + self.tau[t]. def _init_lists(self):; """"""; Create the container lists / arrays for the:; dynamics generations, propagators, and evolutions etc; Set the time slices and cumulative time; """""". # Create containers for control Hamiltonian etc; shp = self.drift_dyn_gen.shape; # set H to be just empty float arrays ",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:22043,Usability,simpl,simply,22043,"on is completed; """"""; if self.decomp_curr is None:; raise errors.UsageError(""Decomp lists have not been created""); if not self.decomp_curr[k]:; self.spectral_decomp(k). [docs] def spectral_decomp(self, k):; """"""; Calculate the diagonalization of the dynamics generator; generating lists of eigenvectors, propagators in the diagonalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; Not implemented in this base class, because the method is specific; to the matrix type; """"""; raise errors.UsageError(""Decomposition cannot be completed by ""; ""this class. Try a(nother) subclass""). class DynamicsGenMat(Dynamics):; """"""; This sub class can be used for any system where no additional; operator is applied to the dynamics generator before calculating; the propagator, e.g. classical dynamics, Limbladian; """"""; def reset(self):; Dynamics.reset(self); self.id_text = 'GEN_MAT'. def get_dyn_gen(self, k):; """"""; Get the combined dynamics generator for the timeslot; This base class method simply returns dyn_gen[k]; other subclass methods will include some factor; """"""; return self.dyn_gen[k]. def get_ctrl_dyn_gen(self, j):; """"""; Get the dynamics generator for the control; This base class method simply returns ctrl_dyn_gen[j]; other subclass methods will include some factor; """"""; return self.ctrl_dyn_gen[j]. [docs]class DynamicsUnitary(Dynamics):; """"""; This is the subclass to use for systems with dynamics described by; unitary matrices. E.g. closed systems with Hermitian Hamiltonians; Note a matrix diagonalisation is used to compute the exponent; The eigen decomposition is also used to calculate the propagator gradient.; The method is taken from DYNAMO (see file header). Attributes; ----------; drift_ham : Qobj; This is the drift Hamiltonian for unitary dynamics; It is mapped to drift_dyn_gen during initialize_controls. ctrl_ham : List of Qobj; These are the control Hamiltonians for unitary dynamics; It is mapped to ctrl_dyn_gen during initialize_controls. H : Lis",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:22252,Usability,simpl,simply,22252,"lculate the diagonalization of the dynamics generator; generating lists of eigenvectors, propagators in the diagonalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; Not implemented in this base class, because the method is specific; to the matrix type; """"""; raise errors.UsageError(""Decomposition cannot be completed by ""; ""this class. Try a(nother) subclass""). class DynamicsGenMat(Dynamics):; """"""; This sub class can be used for any system where no additional; operator is applied to the dynamics generator before calculating; the propagator, e.g. classical dynamics, Limbladian; """"""; def reset(self):; Dynamics.reset(self); self.id_text = 'GEN_MAT'. def get_dyn_gen(self, k):; """"""; Get the combined dynamics generator for the timeslot; This base class method simply returns dyn_gen[k]; other subclass methods will include some factor; """"""; return self.dyn_gen[k]. def get_ctrl_dyn_gen(self, j):; """"""; Get the dynamics generator for the control; This base class method simply returns ctrl_dyn_gen[j]; other subclass methods will include some factor; """"""; return self.ctrl_dyn_gen[j]. [docs]class DynamicsUnitary(Dynamics):; """"""; This is the subclass to use for systems with dynamics described by; unitary matrices. E.g. closed systems with Hermitian Hamiltonians; Note a matrix diagonalisation is used to compute the exponent; The eigen decomposition is also used to calculate the propagator gradient.; The method is taken from DYNAMO (see file header). Attributes; ----------; drift_ham : Qobj; This is the drift Hamiltonian for unitary dynamics; It is mapped to drift_dyn_gen during initialize_controls. ctrl_ham : List of Qobj; These are the control Hamiltonians for unitary dynamics; It is mapped to ctrl_dyn_gen during initialize_controls. H : List of Qobj; The combined drift and control Hamiltonians for each timeslot; These are the dynamics generators for unitary dynamics.; It is mapped to dyn_gen during initialize_controls; """""". def reset(self):; Dynamics",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html
https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html:246,Deployability,install,installation,246,"﻿. qutip.control.grape — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.control.grape; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following dis",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/grape.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html
https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html:7240,Deployability,update,update,7240,"art : array; Optional array with initial control pulse values. Returns; -------; Instance of GRAPEResult, which contains the control pulses calculated; with GRAPE, a time-dependent Hamiltonian that is defined by the; control pulses, as well as the resulting propagator.; """""". if eps is None:; eps = 0.1 * (2 * np.pi) / (times[-1]). M = len(times); J = len(H_ops). u = np.zeros((R, J, M)). if u_limits and len(u_limits) != 2:; raise ValueError(""u_limits must be a list with two values""). if u_limits:; warnings.warn(""Caution: Using experimental feature u_limits""). if u_limits and u_start:; # make sure that no values in u0 violates the u_limits conditions; u_start = np.array(u_start); u_start[u_start < u_limits[0]] = u_limits[0]; u_start[u_start > u_limits[1]] = u_limits[1]. if u_start is not None:; for idx, u0 in enumerate(u_start):; u[0, idx, :] = u0. if beta:; warnings.warn(""Causion: Using experimental feature time-penalty""). progress_bar.start(R); for r in range(R - 1):; progress_bar.update(r). dt = times[1] - times[0]. if use_interp:; ip_funcs = [interp1d(times, u[r, j, :], kind=interp_kind,; bounds_error=False, fill_value=u[r, j, -1]); for j in range(J)]. def _H_t(t, args=None):; return H0 + sum([float(ip_funcs[j](t)) * H_ops[j]; for j in range(J)]). U_list = [(-1j * _H_t(times[idx]) * dt).expm(); for idx in range(M-1)]. else:; def _H_idx(idx):; return H0 + sum([u[r, j, idx] * H_ops[j] for j in range(J)]). U_list = [(-1j * _H_idx(idx) * dt).expm() for idx in range(M-1)]. U_f_list = []; U_b_list = []. U_f = 1; U_b = 1; for n in range(M - 1):. U_f = U_list[n] * U_f; U_f_list.append(U_f). U_b_list.insert(0, U_b); U_b = U_list[M - 2 - n].dag() * U_b. for j in range(J):; for m in range(M-1):; P = U_b_list[m] * U; Q = 1j * dt * H_ops[j] * U_f_list[m]. if phase_sensitive:; du = - _overlap(P, Q); else:; du = - 2 * _overlap(P, Q) * _overlap(U_f_list[m], P). if alpha:; # penalty term for high power control signals u; du += -2 * alpha * u[r, j, m] * dt. if beta:; # penalty term ",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/grape.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html
https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html:10908,Deployability,update,update,10908," as the resulting propagator.; """""". if eps is None:; eps = 0.1 * (2 * np.pi) / (times[-1]). M = len(times); J = len(H_ops). u = np.zeros((R, J, M)). H_ops_data = [H_op.data for H_op in H_ops]. if u_limits and len(u_limits) != 2:; raise ValueError(""u_limits must be a list with two values""). if u_limits:; warnings.warn(""Causion: Using experimental feature u_limits""). if u_limits and u_start:; # make sure that no values in u0 violates the u_limits conditions; u_start = np.array(u_start); u_start[u_start < u_limits[0]] = u_limits[0]; u_start[u_start > u_limits[1]] = u_limits[1]. if u_limits:; use_u_limits = 1; u_min = u_limits[0]; u_max = u_limits[1]; else:; use_u_limits = 0; u_min = 0.0; u_max = 0.0. if u_start is not None:; for idx, u0 in enumerate(u_start):; u[0, idx, :] = u0. if beta:; warnings.warn(""Causion: Using experimental feature time-penalty""). alpha_val = alpha if alpha else 0.0; beta_val = beta if beta else 0.0. progress_bar.start(R); for r in range(R - 1):; progress_bar.update(r). dt = times[1] - times[0]. if use_interp:; ip_funcs = [interp1d(times, u[r, j, :], kind=interp_kind,; bounds_error=False, fill_value=u[r, j, -1]); for j in range(J)]. def _H_t(t, args=None):; return H0 + sum([float(ip_funcs[j](t)) * H_ops[j]; for j in range(J)]). U_list = [(-1j * _H_t(times[idx]) * dt).expm().data; for idx in range(M-1)]. else:; def _H_idx(idx):; return H0 + sum([u[r, j, idx] * H_ops[j] for j in range(J)]). U_list = [(-1j * _H_idx(idx) * dt).expm().data; for idx in range(M-1)]. U_f_list = []; U_b_list = []. U_f = 1; U_b = sp.eye(*(U.shape)); for n in range(M - 1):. U_f = U_list[n] * U_f; U_f_list.append(U_f). U_b_list.insert(0, U_b); U_b = U_list[M - 2 - n].T.conj().tocsr() * U_b. cy_grape_inner(U.data, u, r, J, M, U_b_list, U_f_list, H_ops_data,; dt, eps, alpha_val, beta_val, phase_sensitive,; use_u_limits, u_min, u_max). if use_interp:; ip_funcs = [interp1d(times, u[R - 1, j, :], kind=interp_kind,; bounds_error=False, fill_value=u[R - 1, j, -1]); for j in range(",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/grape.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html
https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html:14290,Deployability,update,update,14290," * eps]); eps_log = np.zeros(R); overlap_log = np.zeros(R). best_k = 0; _k_overlap = np.array([0.0, 0.0, 0.0]). M = len(times); J = len(H_ops); K = len(eps_vec); Uf = [None for _ in range(K)]. u = np.zeros((R, J, M, K)). if u_limits and len(u_limits) != 2:; raise ValueError(""u_limits must be a list with two values""). if u_limits:; warnings.warn(""Causion: Using experimental feature u_limits""). if u_limits and u_start:; # make sure that no values in u0 violates the u_limits conditions; u_start = np.array(u_start); u_start[u_start < u_limits[0]] = u_limits[0]; u_start[u_start > u_limits[1]] = u_limits[1]. if u_start is not None:; for idx, u0 in enumerate(u_start):; for k in range(K):; u[0, idx, :, k] = u0. if beta:; warnings.warn(""Causion: Using experimental feature time-penalty""). if phase_sensitive:; _fidelity_function = lambda x: x; else:; _fidelity_function = lambda x: abs(x) ** 2. best_k = 1; _r = 0; _prev_overlap = 0. progress_bar.start(R); for r in range(R - 1):; progress_bar.update(r). _r = r; eps_log[r] = eps_vec[best_k]. logger.debug(""eps_vec: {}"".format(eps_vec)). _t0 = time.time(). dt = times[1] - times[0]. if use_interp:; ip_funcs = [interp1d(times, u[r, j, :, best_k], kind=interp_kind,; bounds_error=False,; fill_value=u[r, j, -1, best_k]); for j in range(J)]. def _H_t(t, args=None):; return H0 + sum([float(ip_funcs[j](t)) * H_ops[j]; for j in range(J)]). U_list = [(-1j * _H_t(times[idx]) * dt).expm(); for idx in range(M-1)]. else:; def _H_idx(idx):; return H0 + sum([u[r, j, idx, best_k] * H_ops[j]; for j in range(J)]). U_list = [(-1j * _H_idx(idx) * dt).expm() for idx in range(M-1)]. logger.debug(""Time 1: %fs"" % (time.time() - _t0)); _t0 = time.time(). U_f_list = []; U_b_list = []. U_f = 1; U_b = 1; for m in range(M - 1):. U_f = U_list[m] * U_f; U_f_list.append(U_f). U_b_list.insert(0, U_b); U_b = U_list[M - 2 - m].dag() * U_b. logger.debug(""Time 2: %fs"" % (time.time() - _t0)); _t0 = time.time(). for j in range(J):; for m in range(M-1):; P = U_b_list[m] *",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/grape.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html
https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html:17495,Deployability,update,updated,17495," * alpha * u[r, j, m, best_k] * dt. if beta:; # penalty term for late control signals u; du += -2 * beta * k ** 2 * u[r, j, k] * dt. for k, eps_val in enumerate(eps_vec):; u[r + 1, j, m, k] = u[r, j, m, k] + eps_val * du.real. if u_limits:; if u[r + 1, j, m, k] < u_limits[0]:; u[r + 1, j, m, k] = u_limits[0]; elif u[r + 1, j, m, k] > u_limits[1]:; u[r + 1, j, m, k] = u_limits[1]. u[r + 1, j, -1, :] = u[r + 1, j, -2, :]. logger.debug(""Time 3: %fs"" % (time.time() - _t0)); _t0 = time.time(). for k, eps_val in enumerate(eps_vec):. def _H_idx(idx):; return H0 + sum([u[r + 1, j, idx, k] * H_ops[j]; for j in range(J)]). U_list = [(-1j * _H_idx(idx) * dt).expm() for idx in range(M-1)]. Uf[k] = gate_sequence_product(U_list); _k_overlap[k] = _fidelity_function(cy_overlap(Uf[k].data,; U.data)).real. best_k = np.argmax(_k_overlap); logger.debug(""k_overlap: "", _k_overlap, best_k). if _prev_overlap > _k_overlap[best_k]:; logger.debug(""Regression, stepping back with smaller eps.""). u[r + 1, :, :, :] = u[r, :, :, :]; eps_vec /= 2; else:. if best_k == 0:; eps_vec /= 2. elif best_k == 2:; eps_vec *= 2. _prev_overlap = _k_overlap[best_k]. overlap_log[r] = _k_overlap[best_k]. if overlap_terminate < 1.0:; if _k_overlap[best_k] > overlap_terminate:; logger.info(""Reached target fidelity, terminating.""); break. logger.debug(""Time 4: %fs"" % (time.time() - _t0)); _t0 = time.time(). if use_interp:; ip_funcs = [interp1d(times, u[_r, j, :, best_k], kind=interp_kind,; bounds_error=False, fill_value=u[R - 1, j, -1]); for j in range(J)]. H_td_func = [H0] + [[H_ops[j], lambda t, args, j=j: ip_funcs[j](t)]; for j in range(J)]; else:; H_td_func = [H0] + [[H_ops[j], u[_r, j, :, best_k]] for j in range(J)]. progress_bar.finished(). result = GRAPEResult(u=u[:_r, :, :, best_k], U_f=Uf[best_k],; H_t=H_td_func). result.eps = eps_log; result.overlap = overlap_log. return result. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/grape.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html
https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html:8159,Energy Efficiency,power,power,8159,"nalty""). progress_bar.start(R); for r in range(R - 1):; progress_bar.update(r). dt = times[1] - times[0]. if use_interp:; ip_funcs = [interp1d(times, u[r, j, :], kind=interp_kind,; bounds_error=False, fill_value=u[r, j, -1]); for j in range(J)]. def _H_t(t, args=None):; return H0 + sum([float(ip_funcs[j](t)) * H_ops[j]; for j in range(J)]). U_list = [(-1j * _H_t(times[idx]) * dt).expm(); for idx in range(M-1)]. else:; def _H_idx(idx):; return H0 + sum([u[r, j, idx] * H_ops[j] for j in range(J)]). U_list = [(-1j * _H_idx(idx) * dt).expm() for idx in range(M-1)]. U_f_list = []; U_b_list = []. U_f = 1; U_b = 1; for n in range(M - 1):. U_f = U_list[n] * U_f; U_f_list.append(U_f). U_b_list.insert(0, U_b); U_b = U_list[M - 2 - n].dag() * U_b. for j in range(J):; for m in range(M-1):; P = U_b_list[m] * U; Q = 1j * dt * H_ops[j] * U_f_list[m]. if phase_sensitive:; du = - _overlap(P, Q); else:; du = - 2 * _overlap(P, Q) * _overlap(U_f_list[m], P). if alpha:; # penalty term for high power control signals u; du += -2 * alpha * u[r, j, m] * dt. if beta:; # penalty term for late control signals u; du += -2 * beta * m * u[r, j, m] * dt. u[r + 1, j, m] = u[r, j, m] + eps * du.real. if u_limits:; if u[r + 1, j, m] < u_limits[0]:; u[r + 1, j, m] = u_limits[0]; elif u[r + 1, j, m] > u_limits[1]:; u[r + 1, j, m] = u_limits[1]. u[r + 1, j, -1] = u[r + 1, j, -2]. if use_interp:; ip_funcs = [interp1d(times, u[R - 1, j, :], kind=interp_kind,; bounds_error=False, fill_value=u[R - 1, j, -1]); for j in range(J)]. H_td_func = [H0] + [[H_ops[j], lambda t, args, j=j: ip_funcs[j](t)]; for j in range(J)]; else:; H_td_func = [H0] + [[H_ops[j], u[-1, j, :]] for j in range(J)]. progress_bar.finished(). # return U_f_list[-1], H_td_func, u; return GRAPEResult(u=u, U_f=U_f_list[-1], H_t=H_td_func). def cy_grape_unitary(U, H0, H_ops, R, times, eps=None, u_start=None,; u_limits=None, interp_kind='linear', use_interp=False,; alpha=None, beta=None, phase_sensitive=True,; progress_bar=BaseProgressBar()):; """,MatchSource.WIKI,docs/3.1.0/modules/qutip/control/grape.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html
https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html:15516,Energy Efficiency,power,power,15516," fill_value=u[r, j, -1, best_k]); for j in range(J)]. def _H_t(t, args=None):; return H0 + sum([float(ip_funcs[j](t)) * H_ops[j]; for j in range(J)]). U_list = [(-1j * _H_t(times[idx]) * dt).expm(); for idx in range(M-1)]. else:; def _H_idx(idx):; return H0 + sum([u[r, j, idx, best_k] * H_ops[j]; for j in range(J)]). U_list = [(-1j * _H_idx(idx) * dt).expm() for idx in range(M-1)]. logger.debug(""Time 1: %fs"" % (time.time() - _t0)); _t0 = time.time(). U_f_list = []; U_b_list = []. U_f = 1; U_b = 1; for m in range(M - 1):. U_f = U_list[m] * U_f; U_f_list.append(U_f). U_b_list.insert(0, U_b); U_b = U_list[M - 2 - m].dag() * U_b. logger.debug(""Time 2: %fs"" % (time.time() - _t0)); _t0 = time.time(). for j in range(J):; for m in range(M-1):; P = U_b_list[m] * U; Q = 1j * dt * H_ops[j] * U_f_list[m]. if phase_sensitive:; du = - cy_overlap(P.data, Q.data); else:; du = (- 2 * cy_overlap(P.data, Q.data) *; cy_overlap(U_f_list[m].data, P.data)). if alpha:; # penalty term for high power control signals u; du += -2 * alpha * u[r, j, m, best_k] * dt. if beta:; # penalty term for late control signals u; du += -2 * beta * k ** 2 * u[r, j, k] * dt. for k, eps_val in enumerate(eps_vec):; u[r + 1, j, m, k] = u[r, j, m, k] + eps_val * du.real. if u_limits:; if u[r + 1, j, m, k] < u_limits[0]:; u[r + 1, j, m, k] = u_limits[0]; elif u[r + 1, j, m, k] > u_limits[1]:; u[r + 1, j, m, k] = u_limits[1]. u[r + 1, j, -1, :] = u[r + 1, j, -2, :]. logger.debug(""Time 3: %fs"" % (time.time() - _t0)); _t0 = time.time(). for k, eps_val in enumerate(eps_vec):. def _H_idx(idx):; return H0 + sum([u[r + 1, j, idx, k] * H_ops[j]; for j in range(J)]). U_list = [(-1j * _H_idx(idx) * dt).expm() for idx in range(M-1)]. Uf[k] = gate_sequence_product(U_list); _k_overlap[k] = _fidelity_function(cy_overlap(Uf[k].data,; U.data)).real. best_k = np.argmax(_k_overlap); logger.debug(""k_overlap: "", _k_overlap, best_k). if _prev_overlap > _k_overlap[best_k]:; logger.debug(""Regression, stepping back with smaller eps.""). u",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/grape.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html
https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html:4088,Integrability,depend,dependent,4088,"ISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module contains functions that implement the GRAPE algorithm for; calculating pulse sequences for quantum systems.; """""". __all__ = ['plot_grape_control_fields',; 'grape_unitary', 'cy_grape_unitary', 'grape_unitary_adaptive']. import warnings; import time; import numpy as np; from scipy.interpolate import interp1d; import scipy.sparse as sp. from qutip.qobj import Qobj; from qutip.ui.progressbar import BaseProgressBar; from qutip.control.cy_grape import cy_overlap, cy_grape_inner; from qutip.qip.gates import gate_sequence_product. import qutip.logging; logger = qutip.logging.get_logger(). [docs]class GRAPEResult:; """"""; Class for representing the result of a GRAPE simulation. Attributes; ----------; u : array; GRAPE control pulse matrix. H_t : time-dependent Hamiltonian; The time-dependent Hamiltonian that realize the GRAPE pulse sequence. U_f : Qobj; The final unitary transformation that is realized by the evolution; of the system with the GRAPE generated pulse sequences.; """"""; def __init__(self, u=None, H_t=None, U_f=None):. self.u = u; self.H_t = H_t; self.U_f = U_f. [docs]def plot_grape_control_fields(times, u, labels, uniform_axes=False):; """"""; Plot a series of plots showing the GRAPE control fields given in the; given control pulse matrix u. Parameters; ----------; times : array; Time coordinate array. u : array; Control pulse matrix. labels : list; List of labels for each control pulse sequence in the control pulse; matrix. uniform_axes : bool; Whether or not to plot all pulse sequences using the same y-axis scale.; """"""; import matplotlib.pyplot as plt. R, J, M = u.shape. fig, axes = plt.subplots(J, 1, figsize=(8, 2 * J), squeeze=False). y_max = abs(u).max(). for r in range(R):; for j in range(J):. if r == R - 1:; lw, lc, alpha = 2.0, 'k', 1.0. axes[j, 0].set_yl",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/grape.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html
https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html:4120,Integrability,depend,dependent,4120,"ISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module contains functions that implement the GRAPE algorithm for; calculating pulse sequences for quantum systems.; """""". __all__ = ['plot_grape_control_fields',; 'grape_unitary', 'cy_grape_unitary', 'grape_unitary_adaptive']. import warnings; import time; import numpy as np; from scipy.interpolate import interp1d; import scipy.sparse as sp. from qutip.qobj import Qobj; from qutip.ui.progressbar import BaseProgressBar; from qutip.control.cy_grape import cy_overlap, cy_grape_inner; from qutip.qip.gates import gate_sequence_product. import qutip.logging; logger = qutip.logging.get_logger(). [docs]class GRAPEResult:; """"""; Class for representing the result of a GRAPE simulation. Attributes; ----------; u : array; GRAPE control pulse matrix. H_t : time-dependent Hamiltonian; The time-dependent Hamiltonian that realize the GRAPE pulse sequence. U_f : Qobj; The final unitary transformation that is realized by the evolution; of the system with the GRAPE generated pulse sequences.; """"""; def __init__(self, u=None, H_t=None, U_f=None):. self.u = u; self.H_t = H_t; self.U_f = U_f. [docs]def plot_grape_control_fields(times, u, labels, uniform_axes=False):; """"""; Plot a series of plots showing the GRAPE control fields given in the; given control pulse matrix u. Parameters; ----------; times : array; Time coordinate array. u : array; Control pulse matrix. labels : list; List of labels for each control pulse sequence in the control pulse; matrix. uniform_axes : bool; Whether or not to plot all pulse sequences using the same y-axis scale.; """"""; import matplotlib.pyplot as plt. R, J, M = u.shape. fig, axes = plt.subplots(J, 1, figsize=(8, 2 * J), squeeze=False). y_max = abs(u).max(). for r in range(R):; for j in range(J):. if r == R - 1:; lw, lc, alpha = 2.0, 'k', 1.0. axes[j, 0].set_yl",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/grape.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html
https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html:6416,Integrability,depend,dependent,6416,"ut(). return fig, axes. def _overlap(A, B):; return (A.dag() * B).tr() / A.shape[0]; # return cy_overlap(A.data, B.data). [docs]def grape_unitary(U, H0, H_ops, R, times, eps=None, u_start=None,; u_limits=None, interp_kind='linear', use_interp=False,; alpha=None, beta=None, phase_sensitive=True,; progress_bar=BaseProgressBar()):; """"""; Calculate control pulses for the Hamiltonian operators in H_ops so that the; unitary U is realized. Experimental: Work in progress. Parameters; ----------; U : Qobj; Target unitary evolution operator. H0 : Qobj; Static Hamiltonian (that cannot be tuned by the control fields). H_ops: list of Qobj; A list of operators that can be tuned in the Hamiltonian via the; control fields. R : int; Number of GRAPE iterations. time : array / list; Array of time coordinates for control pulse evalutation. u_start : array; Optional array with initial control pulse values. Returns; -------; Instance of GRAPEResult, which contains the control pulses calculated; with GRAPE, a time-dependent Hamiltonian that is defined by the; control pulses, as well as the resulting propagator.; """""". if eps is None:; eps = 0.1 * (2 * np.pi) / (times[-1]). M = len(times); J = len(H_ops). u = np.zeros((R, J, M)). if u_limits and len(u_limits) != 2:; raise ValueError(""u_limits must be a list with two values""). if u_limits:; warnings.warn(""Caution: Using experimental feature u_limits""). if u_limits and u_start:; # make sure that no values in u0 violates the u_limits conditions; u_start = np.array(u_start); u_start[u_start < u_limits[0]] = u_limits[0]; u_start[u_start > u_limits[1]] = u_limits[1]. if u_start is not None:; for idx, u0 in enumerate(u_start):; u[0, idx, :] = u0. if beta:; warnings.warn(""Causion: Using experimental feature time-penalty""). progress_bar.start(R); for r in range(R - 1):; progress_bar.update(r). dt = times[1] - times[0]. if use_interp:; ip_funcs = [interp1d(times, u[r, j, :], kind=interp_kind,; bounds_error=False, fill_value=u[r, j, -1]); for j in range",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/grape.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html
https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html:9844,Integrability,depend,dependent,9844,"(J)]. progress_bar.finished(). # return U_f_list[-1], H_td_func, u; return GRAPEResult(u=u, U_f=U_f_list[-1], H_t=H_td_func). def cy_grape_unitary(U, H0, H_ops, R, times, eps=None, u_start=None,; u_limits=None, interp_kind='linear', use_interp=False,; alpha=None, beta=None, phase_sensitive=True,; progress_bar=BaseProgressBar()):; """"""; Calculate control pulses for the Hamitonian operators in H_ops so that the; unitary U is realized. Experimental: Work in progress. Parameters; ----------; U : Qobj; Target unitary evolution operator. H0 : Qobj; Static Hamiltonian (that cannot be tuned by the control fields). H_ops: list of Qobj; A list of operators that can be tuned in the Hamiltonian via the; control fields. R : int; Number of GRAPE iterations. time : array / list; Array of time coordinates for control pulse evalutation. u_start : array; Optional array with initial control pulse values. Returns; -------; Instance of GRAPEResult, which contains the control pulses calculated; with GRAPE, a time-dependent Hamiltonian that is defined by the; control pulses, as well as the resulting propagator.; """""". if eps is None:; eps = 0.1 * (2 * np.pi) / (times[-1]). M = len(times); J = len(H_ops). u = np.zeros((R, J, M)). H_ops_data = [H_op.data for H_op in H_ops]. if u_limits and len(u_limits) != 2:; raise ValueError(""u_limits must be a list with two values""). if u_limits:; warnings.warn(""Causion: Using experimental feature u_limits""). if u_limits and u_start:; # make sure that no values in u0 violates the u_limits conditions; u_start = np.array(u_start); u_start[u_start < u_limits[0]] = u_limits[0]; u_start[u_start > u_limits[1]] = u_limits[1]. if u_limits:; use_u_limits = 1; u_min = u_limits[0]; u_max = u_limits[1]; else:; use_u_limits = 0; u_min = 0.0; u_max = 0.0. if u_start is not None:; for idx, u0 in enumerate(u_start):; u[0, idx, :] = u0. if beta:; warnings.warn(""Causion: Using experimental feature time-penalty""). alpha_val = alpha if alpha else 0.0; beta_val = beta if beta e",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/grape.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html
https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html:13099,Integrability,depend,dependent,13099,"nished(). return GRAPEResult(u=u, U_f=Qobj(U_f_list[-1], dims=U.dims),; H_t=H_td_func). [docs]def grape_unitary_adaptive(U, H0, H_ops, R, times, eps=None, u_start=None,; u_limits=None, interp_kind='linear',; use_interp=False, alpha=None, beta=None,; phase_sensitive=False, overlap_terminate=1.0,; progress_bar=BaseProgressBar()):; """"""; Calculate control pulses for the Hamiltonian operators in H_ops so that; the unitary U is realized. Experimental: Work in progress. Parameters; ----------; U : Qobj; Target unitary evolution operator. H0 : Qobj; Static Hamiltonian (that cannot be tuned by the control fields). H_ops: list of Qobj; A list of operators that can be tuned in the Hamiltonian via the; control fields. R : int; Number of GRAPE iterations. time : array / list; Array of time coordinates for control pulse evalutation. u_start : array; Optional array with initial control pulse values. Returns; -------; Instance of GRAPEResult, which contains the control pulses calculated; with GRAPE, a time-dependent Hamiltonian that is defined by the; control pulses, as well as the resulting propagator.; """""". if eps is None:; eps = 0.1 * (2 * np.pi) / (times[-1]). eps_vec = np.array([eps / 2, eps, 2 * eps]); eps_log = np.zeros(R); overlap_log = np.zeros(R). best_k = 0; _k_overlap = np.array([0.0, 0.0, 0.0]). M = len(times); J = len(H_ops); K = len(eps_vec); Uf = [None for _ in range(K)]. u = np.zeros((R, J, M, K)). if u_limits and len(u_limits) != 2:; raise ValueError(""u_limits must be a list with two values""). if u_limits:; warnings.warn(""Causion: Using experimental feature u_limits""). if u_limits and u_start:; # make sure that no values in u0 violates the u_limits conditions; u_start = np.array(u_start); u_start[u_start < u_limits[0]] = u_limits[0]; u_start[u_start > u_limits[1]] = u_limits[1]. if u_start is not None:; for idx, u0 in enumerate(u_start):; for k in range(K):; u[0, idx, :, k] = u0. if beta:; warnings.warn(""Causion: Using experimental feature time-penalty""). if phase_",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/grape.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html
https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html:5993,Performance,tune,tuned,5993,", squeeze=False). y_max = abs(u).max(). for r in range(R):; for j in range(J):. if r == R - 1:; lw, lc, alpha = 2.0, 'k', 1.0. axes[j, 0].set_ylabel(labels[j], fontsize=18); axes[j, 0].set_xlabel(r'$t$', fontsize=18); axes[j, 0].set_xlim(0, times[-1]). else:; lw, lc, alpha = 0.5, 'b', 0.25. axes[j, 0].step(times, u[r, j, :], lw=lw, color=lc, alpha=alpha). if uniform_axes:; axes[j, 0].set_ylim(-y_max, y_max). fig.tight_layout(). return fig, axes. def _overlap(A, B):; return (A.dag() * B).tr() / A.shape[0]; # return cy_overlap(A.data, B.data). [docs]def grape_unitary(U, H0, H_ops, R, times, eps=None, u_start=None,; u_limits=None, interp_kind='linear', use_interp=False,; alpha=None, beta=None, phase_sensitive=True,; progress_bar=BaseProgressBar()):; """"""; Calculate control pulses for the Hamiltonian operators in H_ops so that the; unitary U is realized. Experimental: Work in progress. Parameters; ----------; U : Qobj; Target unitary evolution operator. H0 : Qobj; Static Hamiltonian (that cannot be tuned by the control fields). H_ops: list of Qobj; A list of operators that can be tuned in the Hamiltonian via the; control fields. R : int; Number of GRAPE iterations. time : array / list; Array of time coordinates for control pulse evalutation. u_start : array; Optional array with initial control pulse values. Returns; -------; Instance of GRAPEResult, which contains the control pulses calculated; with GRAPE, a time-dependent Hamiltonian that is defined by the; control pulses, as well as the resulting propagator.; """""". if eps is None:; eps = 0.1 * (2 * np.pi) / (times[-1]). M = len(times); J = len(H_ops). u = np.zeros((R, J, M)). if u_limits and len(u_limits) != 2:; raise ValueError(""u_limits must be a list with two values""). if u_limits:; warnings.warn(""Caution: Using experimental feature u_limits""). if u_limits and u_start:; # make sure that no values in u0 violates the u_limits conditions; u_start = np.array(u_start); u_start[u_start < u_limits[0]] = u_limits[0]; u_start",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/grape.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html
https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html:6076,Performance,tune,tuned,6076," - 1:; lw, lc, alpha = 2.0, 'k', 1.0. axes[j, 0].set_ylabel(labels[j], fontsize=18); axes[j, 0].set_xlabel(r'$t$', fontsize=18); axes[j, 0].set_xlim(0, times[-1]). else:; lw, lc, alpha = 0.5, 'b', 0.25. axes[j, 0].step(times, u[r, j, :], lw=lw, color=lc, alpha=alpha). if uniform_axes:; axes[j, 0].set_ylim(-y_max, y_max). fig.tight_layout(). return fig, axes. def _overlap(A, B):; return (A.dag() * B).tr() / A.shape[0]; # return cy_overlap(A.data, B.data). [docs]def grape_unitary(U, H0, H_ops, R, times, eps=None, u_start=None,; u_limits=None, interp_kind='linear', use_interp=False,; alpha=None, beta=None, phase_sensitive=True,; progress_bar=BaseProgressBar()):; """"""; Calculate control pulses for the Hamiltonian operators in H_ops so that the; unitary U is realized. Experimental: Work in progress. Parameters; ----------; U : Qobj; Target unitary evolution operator. H0 : Qobj; Static Hamiltonian (that cannot be tuned by the control fields). H_ops: list of Qobj; A list of operators that can be tuned in the Hamiltonian via the; control fields. R : int; Number of GRAPE iterations. time : array / list; Array of time coordinates for control pulse evalutation. u_start : array; Optional array with initial control pulse values. Returns; -------; Instance of GRAPEResult, which contains the control pulses calculated; with GRAPE, a time-dependent Hamiltonian that is defined by the; control pulses, as well as the resulting propagator.; """""". if eps is None:; eps = 0.1 * (2 * np.pi) / (times[-1]). M = len(times); J = len(H_ops). u = np.zeros((R, J, M)). if u_limits and len(u_limits) != 2:; raise ValueError(""u_limits must be a list with two values""). if u_limits:; warnings.warn(""Caution: Using experimental feature u_limits""). if u_limits and u_start:; # make sure that no values in u0 violates the u_limits conditions; u_start = np.array(u_start); u_start[u_start < u_limits[0]] = u_limits[0]; u_start[u_start > u_limits[1]] = u_limits[1]. if u_start is not None:; for idx, u0 in enumerate(u",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/grape.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html
https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html:9421,Performance,tune,tuned,9421,", j, m] = u_limits[0]; elif u[r + 1, j, m] > u_limits[1]:; u[r + 1, j, m] = u_limits[1]. u[r + 1, j, -1] = u[r + 1, j, -2]. if use_interp:; ip_funcs = [interp1d(times, u[R - 1, j, :], kind=interp_kind,; bounds_error=False, fill_value=u[R - 1, j, -1]); for j in range(J)]. H_td_func = [H0] + [[H_ops[j], lambda t, args, j=j: ip_funcs[j](t)]; for j in range(J)]; else:; H_td_func = [H0] + [[H_ops[j], u[-1, j, :]] for j in range(J)]. progress_bar.finished(). # return U_f_list[-1], H_td_func, u; return GRAPEResult(u=u, U_f=U_f_list[-1], H_t=H_td_func). def cy_grape_unitary(U, H0, H_ops, R, times, eps=None, u_start=None,; u_limits=None, interp_kind='linear', use_interp=False,; alpha=None, beta=None, phase_sensitive=True,; progress_bar=BaseProgressBar()):; """"""; Calculate control pulses for the Hamitonian operators in H_ops so that the; unitary U is realized. Experimental: Work in progress. Parameters; ----------; U : Qobj; Target unitary evolution operator. H0 : Qobj; Static Hamiltonian (that cannot be tuned by the control fields). H_ops: list of Qobj; A list of operators that can be tuned in the Hamiltonian via the; control fields. R : int; Number of GRAPE iterations. time : array / list; Array of time coordinates for control pulse evalutation. u_start : array; Optional array with initial control pulse values. Returns; -------; Instance of GRAPEResult, which contains the control pulses calculated; with GRAPE, a time-dependent Hamiltonian that is defined by the; control pulses, as well as the resulting propagator.; """""". if eps is None:; eps = 0.1 * (2 * np.pi) / (times[-1]). M = len(times); J = len(H_ops). u = np.zeros((R, J, M)). H_ops_data = [H_op.data for H_op in H_ops]. if u_limits and len(u_limits) != 2:; raise ValueError(""u_limits must be a list with two values""). if u_limits:; warnings.warn(""Causion: Using experimental feature u_limits""). if u_limits and u_start:; # make sure that no values in u0 violates the u_limits conditions; u_start = np.array(u_start); u_start[u",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/grape.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html
https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html:9504,Performance,tune,tuned,9504,"u[r + 1, j, -1] = u[r + 1, j, -2]. if use_interp:; ip_funcs = [interp1d(times, u[R - 1, j, :], kind=interp_kind,; bounds_error=False, fill_value=u[R - 1, j, -1]); for j in range(J)]. H_td_func = [H0] + [[H_ops[j], lambda t, args, j=j: ip_funcs[j](t)]; for j in range(J)]; else:; H_td_func = [H0] + [[H_ops[j], u[-1, j, :]] for j in range(J)]. progress_bar.finished(). # return U_f_list[-1], H_td_func, u; return GRAPEResult(u=u, U_f=U_f_list[-1], H_t=H_td_func). def cy_grape_unitary(U, H0, H_ops, R, times, eps=None, u_start=None,; u_limits=None, interp_kind='linear', use_interp=False,; alpha=None, beta=None, phase_sensitive=True,; progress_bar=BaseProgressBar()):; """"""; Calculate control pulses for the Hamitonian operators in H_ops so that the; unitary U is realized. Experimental: Work in progress. Parameters; ----------; U : Qobj; Target unitary evolution operator. H0 : Qobj; Static Hamiltonian (that cannot be tuned by the control fields). H_ops: list of Qobj; A list of operators that can be tuned in the Hamiltonian via the; control fields. R : int; Number of GRAPE iterations. time : array / list; Array of time coordinates for control pulse evalutation. u_start : array; Optional array with initial control pulse values. Returns; -------; Instance of GRAPEResult, which contains the control pulses calculated; with GRAPE, a time-dependent Hamiltonian that is defined by the; control pulses, as well as the resulting propagator.; """""". if eps is None:; eps = 0.1 * (2 * np.pi) / (times[-1]). M = len(times); J = len(H_ops). u = np.zeros((R, J, M)). H_ops_data = [H_op.data for H_op in H_ops]. if u_limits and len(u_limits) != 2:; raise ValueError(""u_limits must be a list with two values""). if u_limits:; warnings.warn(""Causion: Using experimental feature u_limits""). if u_limits and u_start:; # make sure that no values in u0 violates the u_limits conditions; u_start = np.array(u_start); u_start[u_start < u_limits[0]] = u_limits[0]; u_start[u_start > u_limits[1]] = u_limits[1]. if u_li",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/grape.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html
https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html:12676,Performance,tune,tuned,12676,"t, U_f_list, H_ops_data,; dt, eps, alpha_val, beta_val, phase_sensitive,; use_u_limits, u_min, u_max). if use_interp:; ip_funcs = [interp1d(times, u[R - 1, j, :], kind=interp_kind,; bounds_error=False, fill_value=u[R - 1, j, -1]); for j in range(J)]. H_td_func = [H0] + [[H_ops[j], lambda t, args, j=j: ip_funcs[j](t)]; for j in range(J)]; else:; H_td_func = [H0] + [[H_ops[j], u[-1, j, :]] for j in range(J)]. progress_bar.finished(). return GRAPEResult(u=u, U_f=Qobj(U_f_list[-1], dims=U.dims),; H_t=H_td_func). [docs]def grape_unitary_adaptive(U, H0, H_ops, R, times, eps=None, u_start=None,; u_limits=None, interp_kind='linear',; use_interp=False, alpha=None, beta=None,; phase_sensitive=False, overlap_terminate=1.0,; progress_bar=BaseProgressBar()):; """"""; Calculate control pulses for the Hamiltonian operators in H_ops so that; the unitary U is realized. Experimental: Work in progress. Parameters; ----------; U : Qobj; Target unitary evolution operator. H0 : Qobj; Static Hamiltonian (that cannot be tuned by the control fields). H_ops: list of Qobj; A list of operators that can be tuned in the Hamiltonian via the; control fields. R : int; Number of GRAPE iterations. time : array / list; Array of time coordinates for control pulse evalutation. u_start : array; Optional array with initial control pulse values. Returns; -------; Instance of GRAPEResult, which contains the control pulses calculated; with GRAPE, a time-dependent Hamiltonian that is defined by the; control pulses, as well as the resulting propagator.; """""". if eps is None:; eps = 0.1 * (2 * np.pi) / (times[-1]). eps_vec = np.array([eps / 2, eps, 2 * eps]); eps_log = np.zeros(R); overlap_log = np.zeros(R). best_k = 0; _k_overlap = np.array([0.0, 0.0, 0.0]). M = len(times); J = len(H_ops); K = len(eps_vec); Uf = [None for _ in range(K)]. u = np.zeros((R, J, M, K)). if u_limits and len(u_limits) != 2:; raise ValueError(""u_limits must be a list with two values""). if u_limits:; warnings.warn(""Causion: Using experimen",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/grape.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html
https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html:12759,Performance,tune,tuned,12759,"_min, u_max). if use_interp:; ip_funcs = [interp1d(times, u[R - 1, j, :], kind=interp_kind,; bounds_error=False, fill_value=u[R - 1, j, -1]); for j in range(J)]. H_td_func = [H0] + [[H_ops[j], lambda t, args, j=j: ip_funcs[j](t)]; for j in range(J)]; else:; H_td_func = [H0] + [[H_ops[j], u[-1, j, :]] for j in range(J)]. progress_bar.finished(). return GRAPEResult(u=u, U_f=Qobj(U_f_list[-1], dims=U.dims),; H_t=H_td_func). [docs]def grape_unitary_adaptive(U, H0, H_ops, R, times, eps=None, u_start=None,; u_limits=None, interp_kind='linear',; use_interp=False, alpha=None, beta=None,; phase_sensitive=False, overlap_terminate=1.0,; progress_bar=BaseProgressBar()):; """"""; Calculate control pulses for the Hamiltonian operators in H_ops so that; the unitary U is realized. Experimental: Work in progress. Parameters; ----------; U : Qobj; Target unitary evolution operator. H0 : Qobj; Static Hamiltonian (that cannot be tuned by the control fields). H_ops: list of Qobj; A list of operators that can be tuned in the Hamiltonian via the; control fields. R : int; Number of GRAPE iterations. time : array / list; Array of time coordinates for control pulse evalutation. u_start : array; Optional array with initial control pulse values. Returns; -------; Instance of GRAPEResult, which contains the control pulses calculated; with GRAPE, a time-dependent Hamiltonian that is defined by the; control pulses, as well as the resulting propagator.; """""". if eps is None:; eps = 0.1 * (2 * np.pi) / (times[-1]). eps_vec = np.array([eps / 2, eps, 2 * eps]); eps_log = np.zeros(R); overlap_log = np.zeros(R). best_k = 0; _k_overlap = np.array([0.0, 0.0, 0.0]). M = len(times); J = len(H_ops); K = len(eps_vec); Uf = [None for _ in range(K)]. u = np.zeros((R, J, M, K)). if u_limits and len(u_limits) != 2:; raise ValueError(""u_limits must be a list with two values""). if u_limits:; warnings.warn(""Causion: Using experimental feature u_limits""). if u_limits and u_start:; # make sure that no values in u0 violate",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/grape.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html
https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html:3880,Testability,log,logging,3880,"PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module contains functions that implement the GRAPE algorithm for; calculating pulse sequences for quantum systems.; """""". __all__ = ['plot_grape_control_fields',; 'grape_unitary', 'cy_grape_unitary', 'grape_unitary_adaptive']. import warnings; import time; import numpy as np; from scipy.interpolate import interp1d; import scipy.sparse as sp. from qutip.qobj import Qobj; from qutip.ui.progressbar import BaseProgressBar; from qutip.control.cy_grape import cy_overlap, cy_grape_inner; from qutip.qip.gates import gate_sequence_product. import qutip.logging; logger = qutip.logging.get_logger(). [docs]class GRAPEResult:; """"""; Class for representing the result of a GRAPE simulation. Attributes; ----------; u : array; GRAPE control pulse matrix. H_t : time-dependent Hamiltonian; The time-dependent Hamiltonian that realize the GRAPE pulse sequence. U_f : Qobj; The final unitary transformation that is realized by the evolution; of the system with the GRAPE generated pulse sequences.; """"""; def __init__(self, u=None, H_t=None, U_f=None):. self.u = u; self.H_t = H_t; self.U_f = U_f. [docs]def plot_grape_control_fields(times, u, labels, uniform_axes=False):; """"""; Plot a series of plots showing the GRAPE control fields given in the; given control pulse matrix u. Parameters; ----------; times : array; Time coordinate array. u : array; Control pulse matrix. labels : list; List of labels for each control pulse sequence in the control pulse; matrix. uniform_axes : bool; Whether or not to plot all pulse sequences using the same y-axis scale.; """"""; import ma",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/grape.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html
https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html:3889,Testability,log,logger,3889,"PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module contains functions that implement the GRAPE algorithm for; calculating pulse sequences for quantum systems.; """""". __all__ = ['plot_grape_control_fields',; 'grape_unitary', 'cy_grape_unitary', 'grape_unitary_adaptive']. import warnings; import time; import numpy as np; from scipy.interpolate import interp1d; import scipy.sparse as sp. from qutip.qobj import Qobj; from qutip.ui.progressbar import BaseProgressBar; from qutip.control.cy_grape import cy_overlap, cy_grape_inner; from qutip.qip.gates import gate_sequence_product. import qutip.logging; logger = qutip.logging.get_logger(). [docs]class GRAPEResult:; """"""; Class for representing the result of a GRAPE simulation. Attributes; ----------; u : array; GRAPE control pulse matrix. H_t : time-dependent Hamiltonian; The time-dependent Hamiltonian that realize the GRAPE pulse sequence. U_f : Qobj; The final unitary transformation that is realized by the evolution; of the system with the GRAPE generated pulse sequences.; """"""; def __init__(self, u=None, H_t=None, U_f=None):. self.u = u; self.H_t = H_t; self.U_f = U_f. [docs]def plot_grape_control_fields(times, u, labels, uniform_axes=False):; """"""; Plot a series of plots showing the GRAPE control fields given in the; given control pulse matrix u. Parameters; ----------; times : array; Time coordinate array. u : array; Control pulse matrix. labels : list; List of labels for each control pulse sequence in the control pulse; matrix. uniform_axes : bool; Whether or not to plot all pulse sequences using the same y-axis scale.; """"""; import ma",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/grape.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html
https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html:3904,Testability,log,logging,3904,"UBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module contains functions that implement the GRAPE algorithm for; calculating pulse sequences for quantum systems.; """""". __all__ = ['plot_grape_control_fields',; 'grape_unitary', 'cy_grape_unitary', 'grape_unitary_adaptive']. import warnings; import time; import numpy as np; from scipy.interpolate import interp1d; import scipy.sparse as sp. from qutip.qobj import Qobj; from qutip.ui.progressbar import BaseProgressBar; from qutip.control.cy_grape import cy_overlap, cy_grape_inner; from qutip.qip.gates import gate_sequence_product. import qutip.logging; logger = qutip.logging.get_logger(). [docs]class GRAPEResult:; """"""; Class for representing the result of a GRAPE simulation. Attributes; ----------; u : array; GRAPE control pulse matrix. H_t : time-dependent Hamiltonian; The time-dependent Hamiltonian that realize the GRAPE pulse sequence. U_f : Qobj; The final unitary transformation that is realized by the evolution; of the system with the GRAPE generated pulse sequences.; """"""; def __init__(self, u=None, H_t=None, U_f=None):. self.u = u; self.H_t = H_t; self.U_f = U_f. [docs]def plot_grape_control_fields(times, u, labels, uniform_axes=False):; """"""; Plot a series of plots showing the GRAPE control fields given in the; given control pulse matrix u. Parameters; ----------; times : array; Time coordinate array. u : array; Control pulse matrix. labels : list; List of labels for each control pulse sequence in the control pulse; matrix. uniform_axes : bool; Whether or not to plot all pulse sequences using the same y-axis scale.; """"""; import matplotlib.pyplot ",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/grape.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html
https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html:14339,Testability,log,logger,14339,"np.zeros(R). best_k = 0; _k_overlap = np.array([0.0, 0.0, 0.0]). M = len(times); J = len(H_ops); K = len(eps_vec); Uf = [None for _ in range(K)]. u = np.zeros((R, J, M, K)). if u_limits and len(u_limits) != 2:; raise ValueError(""u_limits must be a list with two values""). if u_limits:; warnings.warn(""Causion: Using experimental feature u_limits""). if u_limits and u_start:; # make sure that no values in u0 violates the u_limits conditions; u_start = np.array(u_start); u_start[u_start < u_limits[0]] = u_limits[0]; u_start[u_start > u_limits[1]] = u_limits[1]. if u_start is not None:; for idx, u0 in enumerate(u_start):; for k in range(K):; u[0, idx, :, k] = u0. if beta:; warnings.warn(""Causion: Using experimental feature time-penalty""). if phase_sensitive:; _fidelity_function = lambda x: x; else:; _fidelity_function = lambda x: abs(x) ** 2. best_k = 1; _r = 0; _prev_overlap = 0. progress_bar.start(R); for r in range(R - 1):; progress_bar.update(r). _r = r; eps_log[r] = eps_vec[best_k]. logger.debug(""eps_vec: {}"".format(eps_vec)). _t0 = time.time(). dt = times[1] - times[0]. if use_interp:; ip_funcs = [interp1d(times, u[r, j, :, best_k], kind=interp_kind,; bounds_error=False,; fill_value=u[r, j, -1, best_k]); for j in range(J)]. def _H_t(t, args=None):; return H0 + sum([float(ip_funcs[j](t)) * H_ops[j]; for j in range(J)]). U_list = [(-1j * _H_t(times[idx]) * dt).expm(); for idx in range(M-1)]. else:; def _H_idx(idx):; return H0 + sum([u[r, j, idx, best_k] * H_ops[j]; for j in range(J)]). U_list = [(-1j * _H_idx(idx) * dt).expm() for idx in range(M-1)]. logger.debug(""Time 1: %fs"" % (time.time() - _t0)); _t0 = time.time(). U_f_list = []; U_b_list = []. U_f = 1; U_b = 1; for m in range(M - 1):. U_f = U_list[m] * U_f; U_f_list.append(U_f). U_b_list.insert(0, U_b); U_b = U_list[M - 2 - m].dag() * U_b. logger.debug(""Time 2: %fs"" % (time.time() - _t0)); _t0 = time.time(). for j in range(J):; for m in range(M-1):; P = U_b_list[m] * U; Q = 1j * dt * H_ops[j] * U_f_list[m]. if ph",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/grape.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html
https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html:14917,Testability,log,logger,14917,"ot None:; for idx, u0 in enumerate(u_start):; for k in range(K):; u[0, idx, :, k] = u0. if beta:; warnings.warn(""Causion: Using experimental feature time-penalty""). if phase_sensitive:; _fidelity_function = lambda x: x; else:; _fidelity_function = lambda x: abs(x) ** 2. best_k = 1; _r = 0; _prev_overlap = 0. progress_bar.start(R); for r in range(R - 1):; progress_bar.update(r). _r = r; eps_log[r] = eps_vec[best_k]. logger.debug(""eps_vec: {}"".format(eps_vec)). _t0 = time.time(). dt = times[1] - times[0]. if use_interp:; ip_funcs = [interp1d(times, u[r, j, :, best_k], kind=interp_kind,; bounds_error=False,; fill_value=u[r, j, -1, best_k]); for j in range(J)]. def _H_t(t, args=None):; return H0 + sum([float(ip_funcs[j](t)) * H_ops[j]; for j in range(J)]). U_list = [(-1j * _H_t(times[idx]) * dt).expm(); for idx in range(M-1)]. else:; def _H_idx(idx):; return H0 + sum([u[r, j, idx, best_k] * H_ops[j]; for j in range(J)]). U_list = [(-1j * _H_idx(idx) * dt).expm() for idx in range(M-1)]. logger.debug(""Time 1: %fs"" % (time.time() - _t0)); _t0 = time.time(). U_f_list = []; U_b_list = []. U_f = 1; U_b = 1; for m in range(M - 1):. U_f = U_list[m] * U_f; U_f_list.append(U_f). U_b_list.insert(0, U_b); U_b = U_list[M - 2 - m].dag() * U_b. logger.debug(""Time 2: %fs"" % (time.time() - _t0)); _t0 = time.time(). for j in range(J):; for m in range(M-1):; P = U_b_list[m] * U; Q = 1j * dt * H_ops[j] * U_f_list[m]. if phase_sensitive:; du = - cy_overlap(P.data, Q.data); else:; du = (- 2 * cy_overlap(P.data, Q.data) *; cy_overlap(U_f_list[m].data, P.data)). if alpha:; # penalty term for high power control signals u; du += -2 * alpha * u[r, j, m, best_k] * dt. if beta:; # penalty term for late control signals u; du += -2 * beta * k ** 2 * u[r, j, k] * dt. for k, eps_val in enumerate(eps_vec):; u[r + 1, j, m, k] = u[r, j, m, k] + eps_val * du.real. if u_limits:; if u[r + 1, j, m, k] < u_limits[0]:; u[r + 1, j, m, k] = u_limits[0]; elif u[r + 1, j, m, k] > u_limits[1]:; u[r + 1, j, m, k] = u",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/grape.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html
https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html:15166,Testability,log,logger,15166,"ambda x: abs(x) ** 2. best_k = 1; _r = 0; _prev_overlap = 0. progress_bar.start(R); for r in range(R - 1):; progress_bar.update(r). _r = r; eps_log[r] = eps_vec[best_k]. logger.debug(""eps_vec: {}"".format(eps_vec)). _t0 = time.time(). dt = times[1] - times[0]. if use_interp:; ip_funcs = [interp1d(times, u[r, j, :, best_k], kind=interp_kind,; bounds_error=False,; fill_value=u[r, j, -1, best_k]); for j in range(J)]. def _H_t(t, args=None):; return H0 + sum([float(ip_funcs[j](t)) * H_ops[j]; for j in range(J)]). U_list = [(-1j * _H_t(times[idx]) * dt).expm(); for idx in range(M-1)]. else:; def _H_idx(idx):; return H0 + sum([u[r, j, idx, best_k] * H_ops[j]; for j in range(J)]). U_list = [(-1j * _H_idx(idx) * dt).expm() for idx in range(M-1)]. logger.debug(""Time 1: %fs"" % (time.time() - _t0)); _t0 = time.time(). U_f_list = []; U_b_list = []. U_f = 1; U_b = 1; for m in range(M - 1):. U_f = U_list[m] * U_f; U_f_list.append(U_f). U_b_list.insert(0, U_b); U_b = U_list[M - 2 - m].dag() * U_b. logger.debug(""Time 2: %fs"" % (time.time() - _t0)); _t0 = time.time(). for j in range(J):; for m in range(M-1):; P = U_b_list[m] * U; Q = 1j * dt * H_ops[j] * U_f_list[m]. if phase_sensitive:; du = - cy_overlap(P.data, Q.data); else:; du = (- 2 * cy_overlap(P.data, Q.data) *; cy_overlap(U_f_list[m].data, P.data)). if alpha:; # penalty term for high power control signals u; du += -2 * alpha * u[r, j, m, best_k] * dt. if beta:; # penalty term for late control signals u; du += -2 * beta * k ** 2 * u[r, j, k] * dt. for k, eps_val in enumerate(eps_vec):; u[r + 1, j, m, k] = u[r, j, m, k] + eps_val * du.real. if u_limits:; if u[r + 1, j, m, k] < u_limits[0]:; u[r + 1, j, m, k] = u_limits[0]; elif u[r + 1, j, m, k] > u_limits[1]:; u[r + 1, j, m, k] = u_limits[1]. u[r + 1, j, -1, :] = u[r + 1, j, -2, :]. logger.debug(""Time 3: %fs"" % (time.time() - _t0)); _t0 = time.time(). for k, eps_val in enumerate(eps_vec):. def _H_idx(idx):; return H0 + sum([u[r + 1, j, idx, k] * H_ops[j]; for j in range(J)]).",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/grape.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html
https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html:15973,Testability,log,logger,15973,"me.time(). U_f_list = []; U_b_list = []. U_f = 1; U_b = 1; for m in range(M - 1):. U_f = U_list[m] * U_f; U_f_list.append(U_f). U_b_list.insert(0, U_b); U_b = U_list[M - 2 - m].dag() * U_b. logger.debug(""Time 2: %fs"" % (time.time() - _t0)); _t0 = time.time(). for j in range(J):; for m in range(M-1):; P = U_b_list[m] * U; Q = 1j * dt * H_ops[j] * U_f_list[m]. if phase_sensitive:; du = - cy_overlap(P.data, Q.data); else:; du = (- 2 * cy_overlap(P.data, Q.data) *; cy_overlap(U_f_list[m].data, P.data)). if alpha:; # penalty term for high power control signals u; du += -2 * alpha * u[r, j, m, best_k] * dt. if beta:; # penalty term for late control signals u; du += -2 * beta * k ** 2 * u[r, j, k] * dt. for k, eps_val in enumerate(eps_vec):; u[r + 1, j, m, k] = u[r, j, m, k] + eps_val * du.real. if u_limits:; if u[r + 1, j, m, k] < u_limits[0]:; u[r + 1, j, m, k] = u_limits[0]; elif u[r + 1, j, m, k] > u_limits[1]:; u[r + 1, j, m, k] = u_limits[1]. u[r + 1, j, -1, :] = u[r + 1, j, -2, :]. logger.debug(""Time 3: %fs"" % (time.time() - _t0)); _t0 = time.time(). for k, eps_val in enumerate(eps_vec):. def _H_idx(idx):; return H0 + sum([u[r + 1, j, idx, k] * H_ops[j]; for j in range(J)]). U_list = [(-1j * _H_idx(idx) * dt).expm() for idx in range(M-1)]. Uf[k] = gate_sequence_product(U_list); _k_overlap[k] = _fidelity_function(cy_overlap(Uf[k].data,; U.data)).real. best_k = np.argmax(_k_overlap); logger.debug(""k_overlap: "", _k_overlap, best_k). if _prev_overlap > _k_overlap[best_k]:; logger.debug(""Regression, stepping back with smaller eps.""). u[r + 1, :, :, :] = u[r, :, :, :]; eps_vec /= 2; else:. if best_k == 0:; eps_vec /= 2. elif best_k == 2:; eps_vec *= 2. _prev_overlap = _k_overlap[best_k]. overlap_log[r] = _k_overlap[best_k]. if overlap_terminate < 1.0:; if _k_overlap[best_k] > overlap_terminate:; logger.info(""Reached target fidelity, terminating.""); break. logger.debug(""Time 4: %fs"" % (time.time() - _t0)); _t0 = time.time(). if use_interp:; ip_funcs = [interp1d(times, u[_r",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/grape.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html
https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html:16381,Testability,log,logger,16381,"p(P.data, Q.data); else:; du = (- 2 * cy_overlap(P.data, Q.data) *; cy_overlap(U_f_list[m].data, P.data)). if alpha:; # penalty term for high power control signals u; du += -2 * alpha * u[r, j, m, best_k] * dt. if beta:; # penalty term for late control signals u; du += -2 * beta * k ** 2 * u[r, j, k] * dt. for k, eps_val in enumerate(eps_vec):; u[r + 1, j, m, k] = u[r, j, m, k] + eps_val * du.real. if u_limits:; if u[r + 1, j, m, k] < u_limits[0]:; u[r + 1, j, m, k] = u_limits[0]; elif u[r + 1, j, m, k] > u_limits[1]:; u[r + 1, j, m, k] = u_limits[1]. u[r + 1, j, -1, :] = u[r + 1, j, -2, :]. logger.debug(""Time 3: %fs"" % (time.time() - _t0)); _t0 = time.time(). for k, eps_val in enumerate(eps_vec):. def _H_idx(idx):; return H0 + sum([u[r + 1, j, idx, k] * H_ops[j]; for j in range(J)]). U_list = [(-1j * _H_idx(idx) * dt).expm() for idx in range(M-1)]. Uf[k] = gate_sequence_product(U_list); _k_overlap[k] = _fidelity_function(cy_overlap(Uf[k].data,; U.data)).real. best_k = np.argmax(_k_overlap); logger.debug(""k_overlap: "", _k_overlap, best_k). if _prev_overlap > _k_overlap[best_k]:; logger.debug(""Regression, stepping back with smaller eps.""). u[r + 1, :, :, :] = u[r, :, :, :]; eps_vec /= 2; else:. if best_k == 0:; eps_vec /= 2. elif best_k == 2:; eps_vec *= 2. _prev_overlap = _k_overlap[best_k]. overlap_log[r] = _k_overlap[best_k]. if overlap_terminate < 1.0:; if _k_overlap[best_k] > overlap_terminate:; logger.info(""Reached target fidelity, terminating.""); break. logger.debug(""Time 4: %fs"" % (time.time() - _t0)); _t0 = time.time(). if use_interp:; ip_funcs = [interp1d(times, u[_r, j, :, best_k], kind=interp_kind,; bounds_error=False, fill_value=u[R - 1, j, -1]); for j in range(J)]. H_td_func = [H0] + [[H_ops[j], lambda t, args, j=j: ip_funcs[j](t)]; for j in range(J)]; else:; H_td_func = [H0] + [[H_ops[j], u[_r, j, :, best_k]] for j in range(J)]. progress_bar.finished(). result = GRAPEResult(u=u[:_r, :, :, best_k], U_f=Uf[best_k],; H_t=H_td_func). result.eps = eps_log; r",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/grape.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html
https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html:16470,Testability,log,logger,16470,"U_f_list[m].data, P.data)). if alpha:; # penalty term for high power control signals u; du += -2 * alpha * u[r, j, m, best_k] * dt. if beta:; # penalty term for late control signals u; du += -2 * beta * k ** 2 * u[r, j, k] * dt. for k, eps_val in enumerate(eps_vec):; u[r + 1, j, m, k] = u[r, j, m, k] + eps_val * du.real. if u_limits:; if u[r + 1, j, m, k] < u_limits[0]:; u[r + 1, j, m, k] = u_limits[0]; elif u[r + 1, j, m, k] > u_limits[1]:; u[r + 1, j, m, k] = u_limits[1]. u[r + 1, j, -1, :] = u[r + 1, j, -2, :]. logger.debug(""Time 3: %fs"" % (time.time() - _t0)); _t0 = time.time(). for k, eps_val in enumerate(eps_vec):. def _H_idx(idx):; return H0 + sum([u[r + 1, j, idx, k] * H_ops[j]; for j in range(J)]). U_list = [(-1j * _H_idx(idx) * dt).expm() for idx in range(M-1)]. Uf[k] = gate_sequence_product(U_list); _k_overlap[k] = _fidelity_function(cy_overlap(Uf[k].data,; U.data)).real. best_k = np.argmax(_k_overlap); logger.debug(""k_overlap: "", _k_overlap, best_k). if _prev_overlap > _k_overlap[best_k]:; logger.debug(""Regression, stepping back with smaller eps.""). u[r + 1, :, :, :] = u[r, :, :, :]; eps_vec /= 2; else:. if best_k == 0:; eps_vec /= 2. elif best_k == 2:; eps_vec *= 2. _prev_overlap = _k_overlap[best_k]. overlap_log[r] = _k_overlap[best_k]. if overlap_terminate < 1.0:; if _k_overlap[best_k] > overlap_terminate:; logger.info(""Reached target fidelity, terminating.""); break. logger.debug(""Time 4: %fs"" % (time.time() - _t0)); _t0 = time.time(). if use_interp:; ip_funcs = [interp1d(times, u[_r, j, :, best_k], kind=interp_kind,; bounds_error=False, fill_value=u[R - 1, j, -1]); for j in range(J)]. H_td_func = [H0] + [[H_ops[j], lambda t, args, j=j: ip_funcs[j](t)]; for j in range(J)]; else:; H_td_func = [H0] + [[H_ops[j], u[_r, j, :, best_k]] for j in range(J)]. progress_bar.finished(). result = GRAPEResult(u=u[:_r, :, :, best_k], U_f=Uf[best_k],; H_t=H_td_func). result.eps = eps_log; result.overlap = overlap_log. return result. Back to top. © Copyright 2011 and ",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/grape.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html
https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html:16797,Testability,log,logger,16797," * alpha * u[r, j, m, best_k] * dt. if beta:; # penalty term for late control signals u; du += -2 * beta * k ** 2 * u[r, j, k] * dt. for k, eps_val in enumerate(eps_vec):; u[r + 1, j, m, k] = u[r, j, m, k] + eps_val * du.real. if u_limits:; if u[r + 1, j, m, k] < u_limits[0]:; u[r + 1, j, m, k] = u_limits[0]; elif u[r + 1, j, m, k] > u_limits[1]:; u[r + 1, j, m, k] = u_limits[1]. u[r + 1, j, -1, :] = u[r + 1, j, -2, :]. logger.debug(""Time 3: %fs"" % (time.time() - _t0)); _t0 = time.time(). for k, eps_val in enumerate(eps_vec):. def _H_idx(idx):; return H0 + sum([u[r + 1, j, idx, k] * H_ops[j]; for j in range(J)]). U_list = [(-1j * _H_idx(idx) * dt).expm() for idx in range(M-1)]. Uf[k] = gate_sequence_product(U_list); _k_overlap[k] = _fidelity_function(cy_overlap(Uf[k].data,; U.data)).real. best_k = np.argmax(_k_overlap); logger.debug(""k_overlap: "", _k_overlap, best_k). if _prev_overlap > _k_overlap[best_k]:; logger.debug(""Regression, stepping back with smaller eps.""). u[r + 1, :, :, :] = u[r, :, :, :]; eps_vec /= 2; else:. if best_k == 0:; eps_vec /= 2. elif best_k == 2:; eps_vec *= 2. _prev_overlap = _k_overlap[best_k]. overlap_log[r] = _k_overlap[best_k]. if overlap_terminate < 1.0:; if _k_overlap[best_k] > overlap_terminate:; logger.info(""Reached target fidelity, terminating.""); break. logger.debug(""Time 4: %fs"" % (time.time() - _t0)); _t0 = time.time(). if use_interp:; ip_funcs = [interp1d(times, u[_r, j, :, best_k], kind=interp_kind,; bounds_error=False, fill_value=u[R - 1, j, -1]); for j in range(J)]. H_td_func = [H0] + [[H_ops[j], lambda t, args, j=j: ip_funcs[j](t)]; for j in range(J)]; else:; H_td_func = [H0] + [[H_ops[j], u[_r, j, :, best_k]] for j in range(J)]. progress_bar.finished(). result = GRAPEResult(u=u[:_r, :, :, best_k], U_f=Uf[best_k],; H_t=H_td_func). result.eps = eps_log; result.overlap = overlap_log. return result. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/grape.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html
https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html:16858,Testability,log,logger,16858," * alpha * u[r, j, m, best_k] * dt. if beta:; # penalty term for late control signals u; du += -2 * beta * k ** 2 * u[r, j, k] * dt. for k, eps_val in enumerate(eps_vec):; u[r + 1, j, m, k] = u[r, j, m, k] + eps_val * du.real. if u_limits:; if u[r + 1, j, m, k] < u_limits[0]:; u[r + 1, j, m, k] = u_limits[0]; elif u[r + 1, j, m, k] > u_limits[1]:; u[r + 1, j, m, k] = u_limits[1]. u[r + 1, j, -1, :] = u[r + 1, j, -2, :]. logger.debug(""Time 3: %fs"" % (time.time() - _t0)); _t0 = time.time(). for k, eps_val in enumerate(eps_vec):. def _H_idx(idx):; return H0 + sum([u[r + 1, j, idx, k] * H_ops[j]; for j in range(J)]). U_list = [(-1j * _H_idx(idx) * dt).expm() for idx in range(M-1)]. Uf[k] = gate_sequence_product(U_list); _k_overlap[k] = _fidelity_function(cy_overlap(Uf[k].data,; U.data)).real. best_k = np.argmax(_k_overlap); logger.debug(""k_overlap: "", _k_overlap, best_k). if _prev_overlap > _k_overlap[best_k]:; logger.debug(""Regression, stepping back with smaller eps.""). u[r + 1, :, :, :] = u[r, :, :, :]; eps_vec /= 2; else:. if best_k == 0:; eps_vec /= 2. elif best_k == 2:; eps_vec *= 2. _prev_overlap = _k_overlap[best_k]. overlap_log[r] = _k_overlap[best_k]. if overlap_terminate < 1.0:; if _k_overlap[best_k] > overlap_terminate:; logger.info(""Reached target fidelity, terminating.""); break. logger.debug(""Time 4: %fs"" % (time.time() - _t0)); _t0 = time.time(). if use_interp:; ip_funcs = [interp1d(times, u[_r, j, :, best_k], kind=interp_kind,; bounds_error=False, fill_value=u[R - 1, j, -1]); for j in range(J)]. H_td_func = [H0] + [[H_ops[j], lambda t, args, j=j: ip_funcs[j](t)]; for j in range(J)]; else:; H_td_func = [H0] + [[H_ops[j], u[_r, j, :, best_k]] for j in range(J)]. progress_bar.finished(). result = GRAPEResult(u=u[:_r, :, :, best_k], U_f=Uf[best_k],; H_t=H_td_func). result.eps = eps_log; result.overlap = overlap_log. return result. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/grape.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulsegen.html:3850,Availability,error,errors,3850,"NTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details; """""". import numpy as np; import qutip.control.dynamics as dynamics; import qutip.control.errors as errors. [docs]def create_pulse_gen(pulse_type='RND', dyn=None):; """"""; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:; RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot; These are the other non-periodic options:; LIN - Linear, i.e. contant gradient over the time; ZERO - special case of the LIN pulse, where the gradient is 0; These are the periodic options; SINE - Sine wave; SQUARE - Square wave; SAW - Saw tooth wave; TRIANGLE - Triangular wave; If a Dynamics object is passed in then this is used in instantiate; the PulseGen, meaning that some timeslot and amplitude properties; are copied over.; """""". if pulse_type == 'RND",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulsegen.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulsegen.html:3860,Availability,error,errors,3860,"NTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details; """""". import numpy as np; import qutip.control.dynamics as dynamics; import qutip.control.errors as errors. [docs]def create_pulse_gen(pulse_type='RND', dyn=None):; """"""; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:; RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot; These are the other non-periodic options:; LIN - Linear, i.e. contant gradient over the time; ZERO - special case of the LIN pulse, where the gradient is 0; These are the periodic options; SINE - Sine wave; SQUARE - Square wave; SAW - Saw tooth wave; TRIANGLE - Triangular wave; If a Dynamics object is passed in then this is used in instantiate; the PulseGen, meaning that some timeslot and amplitude properties; are copied over.; """""". if pulse_type == 'RND",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulsegen.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulsegen.html:7911,Availability,error,errors,7911," used to fully; bound the pulse for all generators except some of the random ones; This bound (if set) may result in additional shifting / scaling; Default is Inf. periodic : boolean; True if the pulse generator produces periodic pulses. random : boolean; True if the pulse generator produces random pulses. """"""; def __init__(self, dyn=None):; self.parent = dyn; self.reset(). [docs] def reset(self):; """"""; reset attributes to default values; """"""; if isinstance(self.parent, dynamics.Dynamics):; dyn = self.parent; self.num_tslots = dyn.num_tslots; self.pulse_time = dyn.evo_time; self.scaling = dyn.initial_ctrl_scaling; self.offset = dyn.initial_ctrl_offset; self.tau = dyn.tau; else:; self.num_tslots = 100; self.pulse_time = 1.0; self.scaling = 1.0; self.tau = None; self.offset = 0.0. self._pulse_initialised = False; self.periodic = False; self.random = False; self.lbound = -np.Inf; self.ubound = np.Inf. [docs] def gen_pulse(self):; """"""; returns the pulse as an array of vales for each timeslot; Must be implemented by subclass; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for generating a pulse. ""; "" Suspect base class was used where sub class should have been""). [docs] def init_pulse(self):; """"""; Initialise the pulse parameters; """"""; if self.tau is None:; self.tau = np.ones(self.num_tslots, dtype='f') * \; self.pulse_time/self.num_tslots; self._pulse_initialised = True. if self.ubound < self.lbound:; raise ValueError(""ubound cannot be less the lbound""). def _apply_bounds_and_offset(self, pulse):; """"""; Ensure that the randomly generated pulse fits within the bounds; (after applying the offset); Assumes that pulses passed are centered around zero (on average); """"""; if np.isinf(self.lbound) and np.isinf(self.ubound):; return pulse + self.offset. max_amp = max(pulse); min_amp = min(pulse); if (max_amp + self.offset <= self.ubound and; min_amp + self.offset >= self.lbound):; return pulse + self.offset. # Some shifting / scaling is require",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulsegen.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulsegen.html:249,Deployability,install,installation,249,"﻿. qutip.control.pulsegen — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.control.pulsegen; # -*- coding: utf-8 -*-; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2014 and later, Alexander J G Pitchford; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and th",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulsegen.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulsegen.html:24070,Deployability,update,updated,24070,"floor(2*x) + 1; pulse[k] = self.scaling*y; t = t + self.tau[k]; return self._apply_bounds_and_offset(pulse). [docs]class PulseGenSaw(PulseGenPeriodic):; """"""; Generates saw tooth wave pulses; """"""; [docs] def gen_pulse(self, num_waves=None, wavelen=None,; freq=None, start_phase=None):; """"""; Generate a saw tooth wave pulse; If no parameters are pavided then the class object attributes are used.; If they are provided, then these will reinitialise the object attribs; """"""; if start_phase is not None:; self.start_phase = start_phase. if num_waves is not None or wavelen is not None or freq is not None:; self.init_pulse(num_waves, wavelen, freq, start_phase). if not self._pulse_initialised:; self.init_pulse(). pulse = np.empty(self.num_tslots); t = 0.0; for k in range(self.num_tslots):; phase = 2*np.pi*self.freq*t + self.start_phase; x = phase/(2*np.pi); y = 2*(x - np.floor(0.5 + x)); pulse[k] = self.scaling*y; t = t + self.tau[k]; return self._apply_bounds_and_offset(pulse). [docs]class PulseGenTriangle(PulseGenPeriodic):; """"""; Generates triangular wave pulses; """"""; [docs] def gen_pulse(self, num_waves=None, wavelen=None,; freq=None, start_phase=None):; """"""; Generate a sine wave pulse; If no parameters are pavided then the class object attributes are used.; If they are provided, then these will reinitialise the object attribs; """"""; if start_phase is not None:; self.start_phase = start_phase. if num_waves is not None or wavelen is not None or freq is not None:; self.init_pulse(num_waves, wavelen, freq, start_phase). if not self._pulse_initialised:; self.init_pulse(). pulse = np.empty(self.num_tslots); t = 0.0; for k in range(self.num_tslots):; phase = 2*np.pi*self.freq*t + self.start_phase; x = phase/(2*np.pi); y = 2*np.abs(2*(x - np.floor(0.5 + x))) - 1; pulse[k] = self.scaling*y; t = t + self.tau[k]. return self._apply_bounds_and_offset(pulse). Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulsegen.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulsegen.html:11354,Safety,avoid,avoid,11354,"random coefficients. Attributes; ----------; scaling : float; The pulses should fit approximately within -/+scaling; (before the offset is applied); as it is used to set a maximum for each component wave; Use bounds to be sure; (copied from Dynamics.initial_ctrl_scaling if given). min_wavelen : float; Minimum wavelength of any component wave; Set by default to 1/10th of the pulse time; """""". def reset(self):; """"""; reset attributes to default values; """"""; PulseGen.reset(self); self.random = True; try:; self.min_wavelen = self.pulse_time / 10.0; except:; self.min_wavelen = 0.1. def gen_pulse(self, min_wavelen=None):; """"""; Generate a random pulse based on a Fourier series with a minimum; wavelength; """""". if min_wavelen is not None:; self.min_wavelen = min_wavelen; min_wavelen = self.min_wavelen. if min_wavelen > self.pulse_time:; raise ValueError(""Minimum wavelength cannot be greater than ""; ""the pulse time""); if not self._pulse_initialised:; self.init_pulse(). # use some phase to avoid the first pulse being always 0. sum_wave = np.zeros(self.tau.shape); wavelen = 2.0*self.pulse_time. t = np.zeros(self.num_tslots, dtype=float); for k in range(self.num_tslots-1):; t[k+1] = t[k] + self.tau[k]. wl = []; while wavelen > min_wavelen:; wl.append(wavelen); wavelen = wavelen/2.0. num_comp_waves = len(wl); amp_scale = np.sqrt(8)*self.scaling / float(num_comp_waves). for wavelen in wl:; amp = amp_scale*(np.random.rand()*2 - 1); phase_off = np.random.rand()*np.pi/2.0; curr_wave = amp*np.sin(2*np.pi*t/wavelen + phase_off); sum_wave += curr_wave. return self._apply_bounds_and_offset(sum_wave). class PulseGenRndWaves(PulseGen):; """"""; Generates pulses by summing sine waves with random frequencies; amplitudes and phase offset. Attributes; ----------; scaling : float; The pulses should fit approximately within -/+scaling; (before the offset is applied); as it is used to set a maximum for each component wave; Use bounds to be sure; (copied from Dynamics.initial_ctrl_scaling if given). nu",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulsegen.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulsegen.html:13799,Safety,avoid,avoid,13799,"self.random = True; self.num_comp_waves = 20; try:; self.min_wavelen = self.pulse_time / 10.0; except:; self.min_wavelen = 0.1; try:; self.max_wavelen = 2*self.pulse_time; except:; self.max_wavelen = 10.0. def gen_pulse(self, num_comp_waves=None,; min_wavelen=None, max_wavelen=None):; """"""; Generate a random pulse by summing sine waves with random freq,; amplitude and phase offset; """""". if num_comp_waves is not None:; self.num_comp_waves = num_comp_waves; if min_wavelen is not None:; self.min_wavelen = min_wavelen; if max_wavelen is not None:; self.max_wavelen = max_wavelen. num_comp_waves = self.num_comp_waves; min_wavelen = self.min_wavelen; max_wavelen = self.max_wavelen. if min_wavelen > self.pulse_time:; raise ValueError(""Minimum wavelength cannot be greater than ""; ""the pulse time""); if max_wavelen <= min_wavelen:; raise ValueError(""Maximum wavelength must be greater than ""; ""the minimum wavelength""). if not self._pulse_initialised:; self.init_pulse(). # use some phase to avoid the first pulse being always 0. sum_wave = np.zeros(self.tau.shape). t = np.zeros(self.num_tslots, dtype=float); for k in range(self.num_tslots-1):; t[k+1] = t[k] + self.tau[k]. wl_range = max_wavelen - min_wavelen; amp_scale = np.sqrt(8)*self.scaling / float(num_comp_waves); for n in range(num_comp_waves):; amp = amp_scale*(np.random.rand()*2 - 1); phase_off = np.random.rand()*np.pi/2.0; wavelen = min_wavelen + np.random.rand()*wl_range; curr_wave = amp*np.sin(2*np.pi*t/wavelen + phase_off); sum_wave += curr_wave. return self._apply_bounds_and_offset(sum_wave). class PulseGenRndWalk1(PulseGen):; """"""; Generates pulses by using a random walk algorithm. Attributes; ----------; scaling : float; Used as the range for the starting amplitude; Note must used bounds if values must be restricted.; Also scales the max_d_amp value; (copied from Dynamics.initial_ctrl_scaling if given). max_d_amp : float; Maximum amount amplitude will change between timeslots; Note this is also factored by the scalin",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulsegen.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulsegen.html:9805,Usability,simpl,simply,9805,"ing / scaling is required.; bound_range = self.ubound - self.lbound; if np.isinf(bound_range):; # One of the bounds is inf, so just shift the pulse; if np.isinf(self.lbound):; # max_amp + offset must exceed the ubound; return pulse + self.ubound - max_amp; else:; # min_amp + offset must exceed the lbound; return pulse + self.lbound - min_amp; else:; amp_range = max_amp - min_amp; if max_amp - min_amp > bound_range:; # pulse range is too high, it must be scaled; pulse = pulse * bound_range / amp_range. # otherwise the pulse should fit anyway; return pulse + self.lbound - min(pulse). [docs]class PulseGenZero(PulseGen):; """"""; Generates a flat pulse; """"""; [docs] def gen_pulse(self):; """"""; Generate a pulse with the same value in every timeslot.; The value will be zero, unless the offset is not zero,; in which case it will be the offset; """"""; pulse = np.zeros(self.num_tslots); return self._apply_bounds_and_offset(pulse). [docs]class PulseGenRandom(PulseGen):; """"""; Generates random pulses as simply random values for each timeslot; """"""; def reset(self):; PulseGen.reset(self); self.random = True. [docs] def gen_pulse(self):; """"""; Generate a pulse of random values between 1 and -1; Values are scaled using the scaling property; and shifted using the offset property; Returns the pulse as an array of vales for each timeslot; """"""; pulse = (2*np.random.random(self.num_tslots) - 1) * self.scaling. return self._apply_bounds_and_offset(pulse). class PulseGenRndFourier(PulseGen):; """"""; Generates pulses by summing sine waves as a Fourier series; with random coefficients. Attributes; ----------; scaling : float; The pulses should fit approximately within -/+scaling; (before the offset is applied); as it is used to set a maximum for each component wave; Use bounds to be sure; (copied from Dynamics.initial_ctrl_scaling if given). min_wavelen : float; Minimum wavelength of any component wave; Set by default to 1/10th of the pulse time; """""". def reset(self):; """"""; reset attributes to defaul",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulsegen.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:3718,Availability,error,error,3718,"TORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; """"""; import numpy as np; # QuTiP; from qutip import Qobj; import qutip.logging as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen. [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=-np.Inf, amp_ubound=np.Inf,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; optim_alg='LBFGSB', max_metric_corr=10, accuracy_factor=1e7,; dyn_type='GEN_MAT', pr",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:3886,Availability,error,error,3886,"UTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; """"""; import numpy as np; # QuTiP; from qutip import Qobj; import qutip.logging as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen. [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=-np.Inf, amp_ubound=np.Inf,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; optim_alg='LBFGSB', max_metric_corr=10, accuracy_factor=1e7,; dyn_type='GEN_MAT', prop_type='DEF',; fid_type='DEF', phase_option=None, fid_err_scale_factor=None,; amp_update_mode='ALL',; init_pulse_type='RND', pulse_scaling=1.0, pulse_offset=",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:4333,Availability,error,errors,4333,"r: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; """"""; import numpy as np; # QuTiP; from qutip import Qobj; import qutip.logging as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen. [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=-np.Inf, amp_ubound=np.Inf,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; optim_alg='LBFGSB', max_metric_corr=10, accuracy_factor=1e7,; dyn_type='GEN_MAT', prop_type='DEF',; fid_type='DEF', phase_option=None, fid_err_scale_factor=None,; amp_update_mode='ALL',; init_pulse_type='RND', pulse_scaling=1.0, pulse_offset=0.0,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multiva",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:4343,Availability,error,errors,4343,"r: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; """"""; import numpy as np; # QuTiP; from qutip import Qobj; import qutip.logging as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen. [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=-np.Inf, amp_ubound=np.Inf,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; optim_alg='LBFGSB', max_metric_corr=10, accuracy_factor=1e7,; dyn_type='GEN_MAT', prop_type='DEF',; fid_type='DEF', phase_option=None, fid_err_scale_factor=None,; amp_update_mode='ALL',; init_pulse_type='RND', pulse_scaling=1.0, pulse_offset=0.0,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multiva",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:5058,Availability,error,error,5058,"rt qutip.logging as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen. [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=-np.Inf, amp_ubound=np.Inf,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; optim_alg='LBFGSB', max_metric_corr=10, accuracy_factor=1e7,; dyn_type='GEN_MAT', prop_type='DEF',; fid_type='DEF', phase_option=None, fid_err_scale_factor=None,; amp_update_mode='ALL',; init_pulse_type='RND', pulse_scaling=1.0, pulse_offset=0.0,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------. drift : Qobj; the underlying dynamics generator of the system. ctrls : List of Qobj; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : ",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:5469,Availability,error,error,5469,"port qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen. [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=-np.Inf, amp_ubound=np.Inf,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; optim_alg='LBFGSB', max_metric_corr=10, accuracy_factor=1e7,; dyn_type='GEN_MAT', prop_type='DEF',; fid_type='DEF', phase_option=None, fid_err_scale_factor=None,; amp_update_mode='ALL',; init_pulse_type='RND', pulse_scaling=1.0, pulse_offset=0.0,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------. drift : Qobj; the underlying dynamics generator of the system. ctrls : List of Qobj; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:5489,Availability,error,error,5489,"port qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen. [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=-np.Inf, amp_ubound=np.Inf,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; optim_alg='LBFGSB', max_metric_corr=10, accuracy_factor=1e7,; dyn_type='GEN_MAT', prop_type='DEF',; fid_type='DEF', phase_option=None, fid_err_scale_factor=None,; amp_update_mode='ALL',; init_pulse_type='RND', pulse_scaling=1.0, pulse_offset=0.0,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------. drift : Qobj; the underlying dynamics generator of the system. ctrls : List of Qobj; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:6826,Availability,error,error,6826,"overall dynamics. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. optim_alg : string; Multi-variable optimisation algorithm; options are BFGS, LBFGSB; (see Optimizer classes for details). max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument; (used only in L-BFGS-B). accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor a",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:6893,Availability,error,error,6893,"on.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. optim_alg : string; Multi-variable optimisation algorithm; options are BFGS, LBFGSB; (see Optimizer classes for details). max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument; (used only in L-BFGS-B). accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for ",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:8440,Availability,error,error,8440,"is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument; (used only in L-BFGS-B). accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; (used only in L-BFGS-B). dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FideliyComputer classes for details). phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. fid_err_scale_factor : float; (used in TRACEDIFF FidelityComputer and subclasses only); The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift. amp_update_mode : string; determines whether propagators are calculated; Options: DEF, ALL, DYNAMIC (needs work); DEF will use the default for the specific dyn_type; (See TimeslotComputer classes for details). init_pulse_type : string; type / shape of pulse(s) used to initialise the; the control amplitudes. Options include:; RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW; (",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:8460,Availability,error,error,8460,"is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument; (used only in L-BFGS-B). accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; (used only in L-BFGS-B). dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FideliyComputer classes for details). phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. fid_err_scale_factor : float; (used in TRACEDIFF FidelityComputer and subclasses only); The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift. amp_update_mode : string; determines whether propagators are calculated; Options: DEF, ALL, DYNAMIC (needs work); DEF will use the default for the specific dyn_type; (See TimeslotComputer classes for details). init_pulse_type : string; type / shape of pulse(s) used to initialise the; the control amplitudes. Options include:; RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW; (",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:8915,Availability,error,error,8915,"emely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; (used only in L-BFGS-B). dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FideliyComputer classes for details). phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. fid_err_scale_factor : float; (used in TRACEDIFF FidelityComputer and subclasses only); The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift. amp_update_mode : string; determines whether propagators are calculated; Options: DEF, ALL, DYNAMIC (needs work); DEF will use the default for the specific dyn_type; (See TimeslotComputer classes for details). init_pulse_type : string; type / shape of pulse(s) used to initialise the; the control amplitudes. Options include:; RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW; (see PulseGen classes for details). pulse_scaling : float; Linear scale factor for generated pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Line offset for the pulse. That is this value will be added; to any initial pulses generated. log_level : integer; lev",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:9006,Availability,error,error,9006,"the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FideliyComputer classes for details). phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. fid_err_scale_factor : float; (used in TRACEDIFF FidelityComputer and subclasses only); The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift. amp_update_mode : string; determines whether propagators are calculated; Options: DEF, ALL, DYNAMIC (needs work); DEF will use the default for the specific dyn_type; (See TimeslotComputer classes for details). init_pulse_type : string; type / shape of pulse(s) used to initialise the; the control amplitudes. Options include:; RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW; (see PulseGen classes for details). pulse_scaling : float; Linear scale factor for generated pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Line offset for the pulse. That is this value will be added; to any initial pulses generated. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, W",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:10804,Availability,error,error,10804,"offset for the pulse. That is this value will be added; to any initial pulses generated. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). optim = create_pulse_optimizer(; drift, ctrls, initial, target,; num_tslots=num_tslots, evo_time=evo_time, tau=tau,; amp_lbound=amp_lbound, amp_ubound=amp_ubound,; fid_err_targ=fid_err_targ, min_grad=min_grad,; max_iter=max_iter, max_wall_time=max_wall_time,; optim_alg=optim_alg, max_metric_corr=max_metric_corr,; accuracy_factor=accuracy_factor,; dyn_type=dyn_type, prop_type=prop_type,; fid_type=fid_type, phase_option=phase_option,; fid_err_scale_factor=fid_err_scale_factor,; amp_update_mode=amp_update_mode, init_pulse_type=init_pulse_type,; pulse_scaling=pulse_scaling, pulse_offset=pulse_offset,; log_level=log_level, gen_stats=gen_stats). dyn = optim.dynamics; p_gen = optim.pulse_generator. if log_level ",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:13505,Availability,error,error,13505,"; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=-np.Inf, amp_ubound=np.Inf,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; optim_alg='LBFGSB', max_metric_corr=10, accuracy_factor=1e7,; phase_option='PSU',; amp_update_mode='ALL',; init_pulse_type='RND', pulse_scaling=1.0, pulse_offset=0.0,; log_level=logging.NOTSET, out_file_ext='.txt', gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters; ----------. H_d : Qobj; Drift (aka system) the underlying Hamiltonian of the system. H_c : Qobj; a list of control Hamiltonians. These are sca",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:14175,Availability,error,error,14175,"targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=-np.Inf, amp_ubound=np.Inf,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; optim_alg='LBFGSB', max_metric_corr=10, accuracy_factor=1e7,; phase_option='PSU',; amp_update_mode='ALL',; init_pulse_type='RND', pulse_scaling=1.0, pulse_offset=0.0,; log_level=logging.NOTSET, out_file_ext='.txt', gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters; ----------. H_d : Qobj; Drift (aka system) the underlying Hamiltonian of the system. H_c : Qobj; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:14342,Availability,error,error,14342,"='RND', pulse_scaling=1.0, pulse_offset=0.0,; log_level=logging.NOTSET, out_file_ext='.txt', gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters; ----------. H_d : Qobj; Drift (aka system) the underlying Hamiltonian of the system. H_c : Qobj; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bo",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:15561,Availability,error,error,15561,"the overall dynamics. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. optim_alg : string; Multi-variable optimisation algorithm; options are BFGS, LBFGSB; (see Optimizer classes for details). max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument; (used only in L-BFGS-B). accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor a",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:15628,Availability,error,error,15628,"on.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. optim_alg : string; Multi-variable optimisation algorithm; options are BFGS, LBFGSB; (see Optimizer classes for details). max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument; (used only in L-BFGS-B). accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for ",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:18544,Availability,error,error,18544,"offset for the pulse. That is this value will be added; to any initial pulses generated. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; """""". # check parameters here, as names are different than in; # create_pulse_optimizer, so TypeErrors would be confusing. if not isinstance(H_d, Qobj):; raise TypeError(""H_d must be a Qobj""). if not isinstance(H_c, (list, tuple)):; raise TypeError(""H_c should be a list of Qobj""); else:; for ctrl in H_c:; if not isinstance(ctrl, Qobj):; raise TypeError(""H_c should be a list of Qobj""). if not isinstance(U_0, Qobj):; raise TypeError(""U_0 must be a Qobj""). if not isinstance(U_targ, Qobj):; raise TypeError(""U_targ must be a Qobj""). return optimize_pulse(drift=H_d, ctrls=H_c, initial=U_0, target=U_targ,; num_tslots=num_tslots, evo_time=evo_time, tau=tau,; amp_lbound=amp_lbound, amp_ubound=amp_ubound,; fid_err_targ=fid_err_targ, min_grad=min_grad,; max_iter=max_iter, max_wall_time=max_wall_time,; optim_alg=optim_alg, max_metric_corr=max_metric_corr,; accuracy_factor=accuracy_factor,; dyn_type='UNIT', phas",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:21855,Availability,error,error,21855,"overall dynamics. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. optim_alg : string; Multi-variable optimisation algorithm; options are BFGS, LBFGSB; (see Optimizer classes for details). max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument; (used only in L-BFGS-B). accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor a",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:21922,Availability,error,error,21922,"on.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. optim_alg : string; Multi-variable optimisation algorithm; options are BFGS, LBFGSB; (see Optimizer classes for details). max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument; (used only in L-BFGS-B). accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for ",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:23469,Availability,error,error,23469,"is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument; (used only in L-BFGS-B). accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; (used only in L-BFGS-B). dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FideliyComputer classes for details). phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. fid_err_scale_factor : float; (used in TRACEDIFF FidelityComputer and subclasses only); The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift. amp_update_mode : string; determines whether propagators are calculated; Options: DEF, ALL, DYNAMIC (needs work); DEF will use the default for the specific dyn_type; (See TimeslotComputer classes for details). init_pulse_type : string; type / shape of pulse(s) used to initialise the; the control amplitudes. Options include:; RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW; (",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:23489,Availability,error,error,23489,"is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument; (used only in L-BFGS-B). accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; (used only in L-BFGS-B). dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FideliyComputer classes for details). phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. fid_err_scale_factor : float; (used in TRACEDIFF FidelityComputer and subclasses only); The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift. amp_update_mode : string; determines whether propagators are calculated; Options: DEF, ALL, DYNAMIC (needs work); DEF will use the default for the specific dyn_type; (See TimeslotComputer classes for details). init_pulse_type : string; type / shape of pulse(s) used to initialise the; the control amplitudes. Options include:; RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW; (",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:23944,Availability,error,error,23944,"emely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; (used only in L-BFGS-B). dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FideliyComputer classes for details). phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. fid_err_scale_factor : float; (used in TRACEDIFF FidelityComputer and subclasses only); The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift. amp_update_mode : string; determines whether propagators are calculated; Options: DEF, ALL, DYNAMIC (needs work); DEF will use the default for the specific dyn_type; (See TimeslotComputer classes for details). init_pulse_type : string; type / shape of pulse(s) used to initialise the; the control amplitudes. Options include:; RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW; (see PulseGen classes for details). pulse_scaling : float; Linear scale factor for generated pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Line offset for the pulse. That is this value will be added; to any initial pulses generated. log_level : integer; lev",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:24035,Availability,error,error,24035,"the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FideliyComputer classes for details). phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. fid_err_scale_factor : float; (used in TRACEDIFF FidelityComputer and subclasses only); The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift. amp_update_mode : string; determines whether propagators are calculated; Options: DEF, ALL, DYNAMIC (needs work); DEF will use the default for the specific dyn_type; (See TimeslotComputer classes for details). init_pulse_type : string; type / shape of pulse(s) used to initialise the; the control amplitudes. Options include:; RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW; (see PulseGen classes for details). pulse_scaling : float; Linear scale factor for generated pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Line offset for the pulse. That is this value will be added; to any initial pulses generated. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, W",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:27286,Availability,error,errors,27286,"j += 1. if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""); else:; initial = initial.full(). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""); else:; target = target.full(). cfg = optimconfig.OptimConfig(); cfg.optim_alg = optim_alg; cfg.max_metric_corr = max_metric_corr; cfg.accuracy_factor = accuracy_factor; cfg.amp_update_mode = amp_update_mode; cfg.dyn_type = dyn_type; cfg.prop_type = prop_type; cfg.fid_type = fid_type; cfg.pulse_type = init_pulse_type; cfg.phase_option = phase_option; cfg.amp_lbound = amp_lbound; cfg.amp_ubound = amp_ubound. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). cfg.log_level = log_level. # Create the Dynamics instance; if dyn_type == 'GEN_MAT' or dyn_type is None or dyn_type == '':; dyn = dynamics.DynamicsGenMat(cfg); elif dyn_type == 'UNIT':; dyn = dynamics.DynamicsUnitary(cfg); elif dyn_type == 'SYMPL':; dyn = dynamics.DynamicsSymplectic(cfg); else:; raise errors.UsageError(""No option for dyn_type: "" + dyn_type). # Create the PropagatorComputer instance; # The default will be typically be the best option; if prop_type == 'DEF' or prop_type is None or prop_type == '':; # Do nothing use the default for the Dynamics; pass; elif prop_type == 'APPROX':; if not isinstance(dyn.prop_computer, propcomp.PropCompApproxGrad):; dyn.prop_computer = propcomp.PropCompApproxGrad(dyn); elif prop_type == 'DIAG':; if not isinstance(dyn.prop_computer, propcomp.PropCompDiag):; dyn.prop_computer = propcomp.PropCompDiag(dyn); elif prop_type == 'AUG_MAT':; if not isinstance(dyn.prop_computer, propcomp.PropCompAugMat):; dyn.prop_computer = propcomp.PropCompAugMat(dyn); elif prop_type == 'FRECHET':; if not isinstance(dyn.prop_computer, propcomp.PropCompFrechet):; dyn.prop_computer = propcomp.PropCompFrechet(dyn); else:; raise errors.UsageError(""No option for prop_type: "" + prop_type). # Create the FideliyComputer instance; # The default will be typi",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:28146,Availability,error,errors,28146,"nMat(cfg); elif dyn_type == 'UNIT':; dyn = dynamics.DynamicsUnitary(cfg); elif dyn_type == 'SYMPL':; dyn = dynamics.DynamicsSymplectic(cfg); else:; raise errors.UsageError(""No option for dyn_type: "" + dyn_type). # Create the PropagatorComputer instance; # The default will be typically be the best option; if prop_type == 'DEF' or prop_type is None or prop_type == '':; # Do nothing use the default for the Dynamics; pass; elif prop_type == 'APPROX':; if not isinstance(dyn.prop_computer, propcomp.PropCompApproxGrad):; dyn.prop_computer = propcomp.PropCompApproxGrad(dyn); elif prop_type == 'DIAG':; if not isinstance(dyn.prop_computer, propcomp.PropCompDiag):; dyn.prop_computer = propcomp.PropCompDiag(dyn); elif prop_type == 'AUG_MAT':; if not isinstance(dyn.prop_computer, propcomp.PropCompAugMat):; dyn.prop_computer = propcomp.PropCompAugMat(dyn); elif prop_type == 'FRECHET':; if not isinstance(dyn.prop_computer, propcomp.PropCompFrechet):; dyn.prop_computer = propcomp.PropCompFrechet(dyn); else:; raise errors.UsageError(""No option for prop_type: "" + prop_type). # Create the FideliyComputer instance; # The default will be typically be the best option; # Note: the FidCompTraceDiffApprox is a subclass of FidCompTraceDiff; # so need to check this type first; if fid_type == 'DEF' or fid_type is None or fid_type == '':; # None given, use the default for the Dynamics; pass; elif fid_type == 'TDAPPROX':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiffApprox):; dyn.fid_computer = fidcomp.FidCompTraceDiffApprox(dyn); elif fid_type == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type). if isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer.set_phase_option(phase_option).",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:28968,Availability,error,errors,28968," = propcomp.PropCompAugMat(dyn); elif prop_type == 'FRECHET':; if not isinstance(dyn.prop_computer, propcomp.PropCompFrechet):; dyn.prop_computer = propcomp.PropCompFrechet(dyn); else:; raise errors.UsageError(""No option for prop_type: "" + prop_type). # Create the FideliyComputer instance; # The default will be typically be the best option; # Note: the FidCompTraceDiffApprox is a subclass of FidCompTraceDiff; # so need to check this type first; if fid_type == 'DEF' or fid_type is None or fid_type == '':; # None given, use the default for the Dynamics; pass; elif fid_type == 'TDAPPROX':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiffApprox):; dyn.fid_computer = fidcomp.FidCompTraceDiffApprox(dyn); elif fid_type == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type). if isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer.set_phase_option(phase_option). if isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer.scale_factor = fid_err_scale_factor. # Create the Optimiser instance; # The class of the object will determine which multivar optimisation; # algorithm is used; if optim_alg == 'BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_alg == 'LBFGSB':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_alg is None:; raise errors.UsageError(""Optimisation algorithm must be specified ""; ""via 'optim_alg' parameter""); else:; raise errors.UsageError(""No option for optim_alg: "" + optim_alg). # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = t",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:29544,Availability,error,errors,29544,"elif fid_type == 'TDAPPROX':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiffApprox):; dyn.fid_computer = fidcomp.FidCompTraceDiffApprox(dyn); elif fid_type == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type). if isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer.set_phase_option(phase_option). if isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer.scale_factor = fid_err_scale_factor. # Create the Optimiser instance; # The class of the object will determine which multivar optimisation; # algorithm is used; if optim_alg == 'BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_alg == 'LBFGSB':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_alg is None:; raise errors.UsageError(""Optimisation algorithm must be specified ""; ""via 'optim_alg' parameter""); else:; raise errors.UsageError(""No option for optim_alg: "" + optim_alg). # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc. if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; dyn.ctrl_dyn_gen = ctrls; dyn.initial = initial; dyn.target = target; if tau is None:; # Check that parameters have been supplied to generate the; # timeslot durations; try",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:29650,Availability,error,errors,29650,"DiffApprox):; dyn.fid_computer = fidcomp.FidCompTraceDiffApprox(dyn); elif fid_type == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type). if isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer.set_phase_option(phase_option). if isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer.scale_factor = fid_err_scale_factor. # Create the Optimiser instance; # The class of the object will determine which multivar optimisation; # algorithm is used; if optim_alg == 'BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_alg == 'LBFGSB':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_alg is None:; raise errors.UsageError(""Optimisation algorithm must be specified ""; ""via 'optim_alg' parameter""); else:; raise errors.UsageError(""No option for optim_alg: "" + optim_alg). # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc. if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; dyn.ctrl_dyn_gen = ctrls; dyn.initial = initial; dyn.target = target; if tau is None:; # Check that parameters have been supplied to generate the; # timeslot durations; try:; evo_time / num_tslots; except:; raise errors.UsageError(; ""Either the timeslot dur",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:30560,Availability,error,errors,30560,"er.OptimizerLBFGSB(cfg, dyn); elif optim_alg is None:; raise errors.UsageError(""Optimisation algorithm must be specified ""; ""via 'optim_alg' parameter""); else:; raise errors.UsageError(""No option for optim_alg: "" + optim_alg). # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc. if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; dyn.ctrl_dyn_gen = ctrls; dyn.initial = initial; dyn.target = target; if tau is None:; # Check that parameters have been supplied to generate the; # timeslot durations; try:; evo_time / num_tslots; except:; raise errors.UsageError(; ""Either the timeslot durations should be supplied as an ""; ""array 'tau' or the number of timeslots 'num_tslots' ""; ""and the evolution time 'evo_time' must be given.""). dyn.num_tslots = num_tslots; dyn.evo_time = evo_time; else:; dyn.tau = tau. # this function is called, so that the num_ctrls attribute will be set; dyn.get_num_ctrls(). # Create a pulse generator of the type specified; p_gen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn); p_gen.scaling = pulse_scaling; p_gen.offset = pulse_offset; p_gen.lbound = amp_lbound; p_gen.ubound = amp_ubound. # If the pulse is a periodic type, then set the pulse to be one complete; # wave; if isinstance(p_gen, pulsegen.PulseGenPeriodic):; p_gen.num_waves = 1.0; optim.pulse_generator = p_gen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name_",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:251,Deployability,install,installation,251,"﻿. qutip.control.pulseoptim — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.control.pulseoptim; # -*- coding: utf-8 -*-; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2014 and later, Alexander J G Pitchford; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions an",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:3590,Deployability,configurat,configuration,3590,"OT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; """"""; import numpy as np; # QuTiP; from qutip import Qobj; import qutip.logging as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen. [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=-np.Inf, amp_ub",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:11805,Deployability,configurat,configuration,11805,"s etc; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). optim = create_pulse_optimizer(; drift, ctrls, initial, target,; num_tslots=num_tslots, evo_time=evo_time, tau=tau,; amp_lbound=amp_lbound, amp_ubound=amp_ubound,; fid_err_targ=fid_err_targ, min_grad=min_grad,; max_iter=max_iter, max_wall_time=max_wall_time,; optim_alg=optim_alg, max_metric_corr=max_metric_corr,; accuracy_factor=accuracy_factor,; dyn_type=dyn_type, prop_type=prop_type,; fid_type=fid_type, phase_option=phase_option,; fid_err_scale_factor=fid_err_scale_factor,; amp_update_mode=amp_update_mode, init_pulse_type=init_pulse_type,; pulse_scaling=pulse_scaling, pulse_offset=pulse_offset,; log_level=log_level, gen_stats=gen_stats). dyn = optim.dynamics; p_gen = optim.pulse_generator. if log_level <= logging.INFO:; msg = ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial operator:\n""; msg += str(dyn.initial); msg += ""\nTarget operator:\n""; msg += str(dyn.target); logger.info(msg). # Generate pulses for each control; init_amps = np.zeros([num_tslots, dyn.num_ctrls]); for j in range(dyn.num_ctrls):; init_amps[:, j] = p_gen.gen_pulse(). # Initialise the starting amplitudes; dyn.initialize_controls(init_amps). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + ",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:20450,Deployability,configurat,configuration,20450,"ric_corr,; accuracy_factor=accuracy_factor,; dyn_type='UNIT', phase_option=phase_option,; amp_update_mode=amp_update_mode,; init_pulse_type=init_pulse_type,; pulse_scaling=pulse_scaling,; pulse_offset=pulse_offset,; log_level=log_level, out_file_ext=out_file_ext,; gen_stats=gen_stats). [docs]def create_pulse_optimizer(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=-np.Inf, amp_ubound=np.Inf,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; optim_alg='LBFGSB', max_metric_corr=10, accuracy_factor=1e7,; dyn_type='GEN_MAT', prop_type='DEF',; fid_type='DEF', phase_option=None, fid_err_scale_factor=None,; amp_update_mode='ALL',; init_pulse_type='RND', pulse_scaling=1.0, pulse_offset=0.0,; log_level=logging.NOTSET, gen_stats=False):. """"""; Generate the objects of the appropriate subclasses; required for the pulse optmisation based on the parameters given; Note this method may be preferable to calling optimize_pulse; if more detailed configuration is required before running the; optmisation algorthim, or the algorithm will be run many times,; for instances when trying to finding global the optimum or; minimum time optimisation. Parameters; ----------. drift : Qobj; the underlying dynamics generator of the system. ctrls : List of Qobj; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:31842,Deployability,update,updated,31842,"wall_time = max_wall_time; optim.termination_conditions = tc. if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; dyn.ctrl_dyn_gen = ctrls; dyn.initial = initial; dyn.target = target; if tau is None:; # Check that parameters have been supplied to generate the; # timeslot durations; try:; evo_time / num_tslots; except:; raise errors.UsageError(; ""Either the timeslot durations should be supplied as an ""; ""array 'tau' or the number of timeslots 'num_tslots' ""; ""and the evolution time 'evo_time' must be given.""). dyn.num_tslots = num_tslots; dyn.evo_time = evo_time; else:; dyn.tau = tau. # this function is called, so that the num_ctrls attribute will be set; dyn.get_num_ctrls(). # Create a pulse generator of the type specified; p_gen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn); p_gen.scaling = pulse_scaling; p_gen.offset = pulse_offset; p_gen.lbound = amp_lbound; p_gen.ubound = amp_ubound. # If the pulse is a periodic type, then set the pulse to be one complete; # wave; if isinstance(p_gen, pulsegen.PulseGenPeriodic):; p_gen.num_waves = 1.0; optim.pulse_generator = p_gen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + p_gen.__class__.__name__). return optim. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:13617,Integrability,wrap,wrapper,13617,"run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=-np.Inf, amp_ubound=np.Inf,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; optim_alg='LBFGSB', max_metric_corr=10, accuracy_factor=1e7,; phase_option='PSU',; amp_update_mode='ALL',; init_pulse_type='RND', pulse_scaling=1.0, pulse_offset=0.0,; log_level=logging.NOTSET, out_file_ext='.txt', gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters; ----------. H_d : Qobj; Drift (aka system) the underlying Hamiltonian of the system. H_c : Qobj; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. ",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:3590,Modifiability,config,configuration,3590,"OT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; """"""; import numpy as np; # QuTiP; from qutip import Qobj; import qutip.logging as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen. [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=-np.Inf, amp_ub",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:7302,Modifiability,variab,variable,7302,"evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. optim_alg : string; Multi-variable optimisation algorithm; options are BFGS, LBFGSB; (see Optimizer classes for details). max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument; (used only in L-BFGS-B). accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; (used only in L-BFGS-B). dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the defau",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:7447,Modifiability,variab,variable,7447,". amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. optim_alg : string; Multi-variable optimisation algorithm; options are BFGS, LBFGSB; (see Optimizer classes for details). max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument; (used only in L-BFGS-B). accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; (used only in L-BFGS-B). dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). fid_type : string; Fidelity error (and fideli",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:11805,Modifiability,config,configuration,11805,"s etc; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). optim = create_pulse_optimizer(; drift, ctrls, initial, target,; num_tslots=num_tslots, evo_time=evo_time, tau=tau,; amp_lbound=amp_lbound, amp_ubound=amp_ubound,; fid_err_targ=fid_err_targ, min_grad=min_grad,; max_iter=max_iter, max_wall_time=max_wall_time,; optim_alg=optim_alg, max_metric_corr=max_metric_corr,; accuracy_factor=accuracy_factor,; dyn_type=dyn_type, prop_type=prop_type,; fid_type=fid_type, phase_option=phase_option,; fid_err_scale_factor=fid_err_scale_factor,; amp_update_mode=amp_update_mode, init_pulse_type=init_pulse_type,; pulse_scaling=pulse_scaling, pulse_offset=pulse_offset,; log_level=log_level, gen_stats=gen_stats). dyn = optim.dynamics; p_gen = optim.pulse_generator. if log_level <= logging.INFO:; msg = ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial operator:\n""; msg += str(dyn.initial); msg += ""\nTarget operator:\n""; msg += str(dyn.target); logger.info(msg). # Generate pulses for each control; init_amps = np.zeros([num_tslots, dyn.num_ctrls]); for j in range(dyn.num_ctrls):; init_amps[:, j] = p_gen.gen_pulse(). # Initialise the starting amplitudes; dyn.initialize_controls(init_amps). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + ",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:16037,Modifiability,variab,variable,16037,"evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. optim_alg : string; Multi-variable optimisation algorithm; options are BFGS, LBFGSB; (see Optimizer classes for details). max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument; (used only in L-BFGS-B). accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; (used only in L-BFGS-B). phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. amp_update_mode : string; determines whether propagators are calculated; Options: DEF, ALL, DYNAMIC (needs work); DEF will use the default for the specific dyn_type; (See TimeslotCo",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:16182,Modifiability,variab,variable,16182,". amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. optim_alg : string; Multi-variable optimisation algorithm; options are BFGS, LBFGSB; (see Optimizer classes for details). max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument; (used only in L-BFGS-B). accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; (used only in L-BFGS-B). phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. amp_update_mode : string; determines whether propagators are calculated; Options: DEF, ALL, DYNAMIC (needs work); DEF will use the default for the specific dyn_type; (See TimeslotComputer classes for details). init_pulse_type : string; type / shape of pulse(s) used to initialise the; the control ampli",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:20450,Modifiability,config,configuration,20450,"ric_corr,; accuracy_factor=accuracy_factor,; dyn_type='UNIT', phase_option=phase_option,; amp_update_mode=amp_update_mode,; init_pulse_type=init_pulse_type,; pulse_scaling=pulse_scaling,; pulse_offset=pulse_offset,; log_level=log_level, out_file_ext=out_file_ext,; gen_stats=gen_stats). [docs]def create_pulse_optimizer(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=-np.Inf, amp_ubound=np.Inf,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; optim_alg='LBFGSB', max_metric_corr=10, accuracy_factor=1e7,; dyn_type='GEN_MAT', prop_type='DEF',; fid_type='DEF', phase_option=None, fid_err_scale_factor=None,; amp_update_mode='ALL',; init_pulse_type='RND', pulse_scaling=1.0, pulse_offset=0.0,; log_level=logging.NOTSET, gen_stats=False):. """"""; Generate the objects of the appropriate subclasses; required for the pulse optmisation based on the parameters given; Note this method may be preferable to calling optimize_pulse; if more detailed configuration is required before running the; optmisation algorthim, or the algorithm will be run many times,; for instances when trying to finding global the optimum or; minimum time optimisation. Parameters; ----------. drift : Qobj; the underlying dynamics generator of the system. ctrls : List of Qobj; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:22331,Modifiability,variab,variable,22331,"evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. optim_alg : string; Multi-variable optimisation algorithm; options are BFGS, LBFGSB; (see Optimizer classes for details). max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument; (used only in L-BFGS-B). accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; (used only in L-BFGS-B). dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the defau",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:22476,Modifiability,variab,variable,22476,". amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. optim_alg : string; Multi-variable optimisation algorithm; options are BFGS, LBFGSB; (see Optimizer classes for details). max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument; (used only in L-BFGS-B). accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; (used only in L-BFGS-B). dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). fid_type : string; Fidelity error (and fideli",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:31400,Modifiability,config,config,31400,"wall_time = max_wall_time; optim.termination_conditions = tc. if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; dyn.ctrl_dyn_gen = ctrls; dyn.initial = initial; dyn.target = target; if tau is None:; # Check that parameters have been supplied to generate the; # timeslot durations; try:; evo_time / num_tslots; except:; raise errors.UsageError(; ""Either the timeslot durations should be supplied as an ""; ""array 'tau' or the number of timeslots 'num_tslots' ""; ""and the evolution time 'evo_time' must be given.""). dyn.num_tslots = num_tslots; dyn.evo_time = evo_time; else:; dyn.tau = tau. # this function is called, so that the num_ctrls attribute will be set; dyn.get_num_ctrls(). # Create a pulse generator of the type specified; p_gen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn); p_gen.scaling = pulse_scaling; p_gen.offset = pulse_offset; p_gen.lbound = amp_lbound; p_gen.ubound = amp_ubound. # If the pulse is a periodic type, then set the pulse to be one complete; # wave; if isinstance(p_gen, pulsegen.PulseGenPeriodic):; p_gen.num_waves = 1.0; optim.pulse_generator = p_gen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + p_gen.__class__.__name__). return optim. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:4251,Performance,optimiz,optimizer,4251,"#####################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; """"""; import numpy as np; # QuTiP; from qutip import Qobj; import qutip.logging as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen. [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=-np.Inf, amp_ubound=np.Inf,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; optim_alg='LBFGSB', max_metric_corr=10, accuracy_factor=1e7,; dyn_type='GEN_MAT', prop_type='DEF',; fid_type='DEF', phase_option=None, fid_err_scale_factor=None,; amp_update_mode='ALL',; init_pulse_type='RND', pulse_scaling=1.0, pulse_offset=0.0,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, len(ctrls)] array of piec",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:4264,Performance,optimiz,optimizer,4264,"#####################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; """"""; import numpy as np; # QuTiP; from qutip import Qobj; import qutip.logging as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen. [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=-np.Inf, amp_ubound=np.Inf,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; optim_alg='LBFGSB', max_metric_corr=10, accuracy_factor=1e7,; dyn_type='GEN_MAT', prop_type='DEF',; fid_type='DEF', phase_option=None, fid_err_scale_factor=None,; amp_update_mode='ALL',; init_pulse_type='RND', pulse_scaling=1.0, pulse_offset=0.0,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, len(ctrls)] array of piec",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:7622,Performance,optimiz,optimize,7622," amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. optim_alg : string; Multi-variable optimisation algorithm; options are BFGS, LBFGSB; (see Optimizer classes for details). max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument; (used only in L-BFGS-B). accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; (used only in L-BFGS-B). dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FideliyComputer classes for d",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:7912,Performance,optimiz,optimize,7912,"value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. optim_alg : string; Multi-variable optimisation algorithm; options are BFGS, LBFGSB; (see Optimizer classes for details). max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument; (used only in L-BFGS-B). accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; (used only in L-BFGS-B). dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FideliyComputer classes for details). phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. fid_err_scale_factor : float; (used in TRACEDIFF FidelityComputer and subclasses only); The fidelity er",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:16357,Performance,optimiz,optimize,16357," amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. optim_alg : string; Multi-variable optimisation algorithm; options are BFGS, LBFGSB; (see Optimizer classes for details). max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument; (used only in L-BFGS-B). accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; (used only in L-BFGS-B). phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. amp_update_mode : string; determines whether propagators are calculated; Options: DEF, ALL, DYNAMIC (needs work); DEF will use the default for the specific dyn_type; (See TimeslotComputer classes for details). init_pulse_type : string; type / shape of pulse(s) used to initialise the; the control amplitudes. Options include:; RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW; (see PulseGen classes for details). pulse_scaling : float; Linear scale factor for generated pulses;",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:16647,Performance,optimiz,optimize,16647,"value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. optim_alg : string; Multi-variable optimisation algorithm; options are BFGS, LBFGSB; (see Optimizer classes for details). max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument; (used only in L-BFGS-B). accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; (used only in L-BFGS-B). phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. amp_update_mode : string; determines whether propagators are calculated; Options: DEF, ALL, DYNAMIC (needs work); DEF will use the default for the specific dyn_type; (See TimeslotComputer classes for details). init_pulse_type : string; type / shape of pulse(s) used to initialise the; the control amplitudes. Options include:; RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW; (see PulseGen classes for details). pulse_scaling : float; Linear scale factor for generated pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Line offset for the pulse. That is this value will be added; to any initial pulses generated. log_level : integer; level of messaging output fro",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:22651,Performance,optimiz,optimize,22651," amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. optim_alg : string; Multi-variable optimisation algorithm; options are BFGS, LBFGSB; (see Optimizer classes for details). max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument; (used only in L-BFGS-B). accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; (used only in L-BFGS-B). dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FideliyComputer classes for d",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:22941,Performance,optimiz,optimize,22941,"value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. optim_alg : string; Multi-variable optimisation algorithm; options are BFGS, LBFGSB; (see Optimizer classes for details). max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument; (used only in L-BFGS-B). accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; (used only in L-BFGS-B). dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FideliyComputer classes for details). phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. fid_err_scale_factor : float; (used in TRACEDIFF FidelityComputer and subclasses only); The fidelity er",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:25800,Performance,optimiz,optimizer,25800,"fset for the pulse. That is this value will be added; to any initial pulses generated. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; Note value should be set using set_log_level. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------. Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g.; optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; """""". # check parameters; if not isinstance(drift, Qobj):; raise TypeError(""drift must be a Qobj""); else:; drift = drift.full(). if not isinstance(ctrls, (list, tuple)):; raise TypeError(""ctrls should be a list of Qobj""); else:; j = 0; for ctrl in ctrls:; if not isinstance(ctrl, Qobj):; raise TypeError(""ctrls should be a list of Qobj""); else:; ctrls[j] = ctrl.full(); j += 1. if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""); else:; initial = initial.full(). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""); else:; target = target.full(). cfg = optimconfig.OptimConfig(); cfg.optim_alg = optim_alg; cfg.max_metric_corr = max_metric_corr; cfg.accuracy_factor = accuracy_factor; cfg.amp_update_mode = amp_update_mode; cfg.dyn_type = dyn_type; cfg.prop_type = prop_type; cfg.fid_type = fid_type; cfg.pulse_type = init_pulse_type; cfg.phase_option = p",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:25873,Performance,optimiz,optimizer,25873,"added; to any initial pulses generated. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; Note value should be set using set_log_level. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------. Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g.; optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; """""". # check parameters; if not isinstance(drift, Qobj):; raise TypeError(""drift must be a Qobj""); else:; drift = drift.full(). if not isinstance(ctrls, (list, tuple)):; raise TypeError(""ctrls should be a list of Qobj""); else:; j = 0; for ctrl in ctrls:; if not isinstance(ctrl, Qobj):; raise TypeError(""ctrls should be a list of Qobj""); else:; ctrls[j] = ctrl.full(); j += 1. if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""); else:; initial = initial.full(). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""); else:; target = target.full(). cfg = optimconfig.OptimConfig(); cfg.optim_alg = optim_alg; cfg.max_metric_corr = max_metric_corr; cfg.accuracy_factor = accuracy_factor; cfg.amp_update_mode = amp_update_mode; cfg.dyn_type = dyn_type; cfg.prop_type = prop_type; cfg.fid_type = fid_type; cfg.pulse_type = init_pulse_type; cfg.phase_option = phase_option; cfg.amp_lbound = amp_lbound; cfg.a",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:29404,Performance,optimiz,optimizer,29404,"x is a subclass of FidCompTraceDiff; # so need to check this type first; if fid_type == 'DEF' or fid_type is None or fid_type == '':; # None given, use the default for the Dynamics; pass; elif fid_type == 'TDAPPROX':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiffApprox):; dyn.fid_computer = fidcomp.FidCompTraceDiffApprox(dyn); elif fid_type == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type). if isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer.set_phase_option(phase_option). if isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer.scale_factor = fid_err_scale_factor. # Create the Optimiser instance; # The class of the object will determine which multivar optimisation; # algorithm is used; if optim_alg == 'BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_alg == 'LBFGSB':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_alg is None:; raise errors.UsageError(""Optimisation algorithm must be specified ""; ""via 'optim_alg' parameter""); else:; raise errors.UsageError(""No option for optim_alg: "" + optim_alg). # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc. if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:29476,Performance,optimiz,optimizer,29476,"_type == '':; # None given, use the default for the Dynamics; pass; elif fid_type == 'TDAPPROX':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiffApprox):; dyn.fid_computer = fidcomp.FidCompTraceDiffApprox(dyn); elif fid_type == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type). if isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer.set_phase_option(phase_option). if isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer.scale_factor = fid_err_scale_factor. # Create the Optimiser instance; # The class of the object will determine which multivar optimisation; # algorithm is used; if optim_alg == 'BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_alg == 'LBFGSB':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_alg is None:; raise errors.UsageError(""Optimisation algorithm must be specified ""; ""via 'optim_alg' parameter""); else:; raise errors.UsageError(""No option for optim_alg: "" + optim_alg). # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc. if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; dyn.ctrl_dyn_gen = ctrls; dyn.initial = initial; dyn.target = target; if tau is None:; # Check that par",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:30151,Performance,perform,performance,30151," dyn.fid_computer.set_phase_option(phase_option). if isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer.scale_factor = fid_err_scale_factor. # Create the Optimiser instance; # The class of the object will determine which multivar optimisation; # algorithm is used; if optim_alg == 'BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_alg == 'LBFGSB':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_alg is None:; raise errors.UsageError(""Optimisation algorithm must be specified ""; ""via 'optim_alg' parameter""); else:; raise errors.UsageError(""No option for optim_alg: "" + optim_alg). # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc. if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; dyn.ctrl_dyn_gen = ctrls; dyn.initial = initial; dyn.target = target; if tau is None:; # Check that parameters have been supplied to generate the; # timeslot durations; try:; evo_time / num_tslots; except:; raise errors.UsageError(; ""Either the timeslot durations should be supplied as an ""; ""array 'tau' or the number of timeslots 'num_tslots' ""; ""and the evolution time 'evo_time' must be given.""). dyn.num_tslots = num_tslots; dyn.evo_time = evo_time; else:; dyn.tau = tau. # this function is called, so that the num_ctrls attribute will be set; dyn.get_num_ctrls(). # Create a pulse generator of the type specified; p_gen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn); p_gen.scaling = pulse_scaling; p_gen.offset =",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:31446,Performance,optimiz,optimizer,31446,"wall_time = max_wall_time; optim.termination_conditions = tc. if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; dyn.ctrl_dyn_gen = ctrls; dyn.initial = initial; dyn.target = target; if tau is None:; # Check that parameters have been supplied to generate the; # timeslot durations; try:; evo_time / num_tslots; except:; raise errors.UsageError(; ""Either the timeslot durations should be supplied as an ""; ""array 'tau' or the number of timeslots 'num_tslots' ""; ""and the evolution time 'evo_time' must be given.""). dyn.num_tslots = num_tslots; dyn.evo_time = evo_time; else:; dyn.tau = tau. # this function is called, so that the num_ctrls attribute will be set; dyn.get_num_ctrls(). # Create a pulse generator of the type specified; p_gen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn); p_gen.scaling = pulse_scaling; p_gen.offset = pulse_offset; p_gen.lbound = amp_lbound; p_gen.ubound = amp_ubound. # If the pulse is a periodic type, then set the pulse to be one complete; # wave; if isinstance(p_gen, pulsegen.PulseGenPeriodic):; p_gen.num_waves = 1.0; optim.pulse_generator = p_gen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + p_gen.__class__.__name__). return optim. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:10629,Security,access,accessible,10629,"generated pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Line offset for the pulse. That is this value will be added; to any initial pulses generated. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). optim = create_pulse_optimizer(; drift, ctrls, initial, target,; num_tslots=num_tslots, evo_time=evo_time, tau=tau,; amp_lbound=amp_lbound, amp_ubound=amp_ubound,; fid_err_targ=fid_err_targ, min_grad=min_grad,; max_iter=max_iter, max_wall_time=max_wall_time,; optim_alg=optim_alg, max_metric_corr=max_metric_corr,; accuracy_factor=accuracy_factor,; dyn_type=dyn_type, prop_type=prop_type,; fid_type=fid_type, phase_option=phase_option,; fid_err_scale_factor=fid_err_scale_factor,; amp_update_mode=amp_update_mode, init_pulse_type=init_pulse_type,",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:18369,Security,access,accessible,18369,"generated pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Line offset for the pulse. That is this value will be added; to any initial pulses generated. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; """""". # check parameters here, as names are different than in; # create_pulse_optimizer, so TypeErrors would be confusing. if not isinstance(H_d, Qobj):; raise TypeError(""H_d must be a Qobj""). if not isinstance(H_c, (list, tuple)):; raise TypeError(""H_c should be a list of Qobj""); else:; for ctrl in H_c:; if not isinstance(ctrl, Qobj):; raise TypeError(""H_c should be a list of Qobj""). if not isinstance(U_0, Qobj):; raise TypeError(""U_0 must be a Qobj""). if not isinstance(U_targ, Qobj):; raise TypeError(""U_targ must be a Qobj""). return optimize_pulse(drift=H_d, ctrls=H_c, initial=U_0, target=U_targ,; num_tslots=num_tslots, evo_time=evo_time, tau=tau,; amp_lbound=amp_lbound, amp_ubound=amp_ubound,; fid_err_targ=fid_err_targ, min_grad=mi",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:25459,Security,access,accessible,25459,"e(s) used to initialise the; the control amplitudes. Options include:; RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW; (see PulseGen classes for details). pulse_scaling : float; Linear scale factor for generated pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Line offset for the pulse. That is this value will be added; to any initial pulses generated. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; Note value should be set using set_log_level. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------. Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g.; optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; """""". # check parameters; if not isinstance(drift, Qobj):; raise TypeError(""drift must be a Qobj""); else:; drift = drift.full(). if not isinstance(ctrls, (list, tuple)):; raise TypeError(""ctrls should be a list of Qobj""); else:; j = 0; for ctrl in ctrls:; if not isinstance(ctrl, Qobj):; raise TypeError(""ctrls should be a list of Qobj""); else:; ctrls[j] = ctrl.full(); j += 1. if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""); else:; initial = initial.full(). if not isinstance(target, Qobj):; raise TypeEr",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:25644,Security,access,accessed,25644,"ing : float; Linear scale factor for generated pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Line offset for the pulse. That is this value will be added; to any initial pulses generated. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; Note value should be set using set_log_level. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------. Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g.; optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; """""". # check parameters; if not isinstance(drift, Qobj):; raise TypeError(""drift must be a Qobj""); else:; drift = drift.full(). if not isinstance(ctrls, (list, tuple)):; raise TypeError(""ctrls should be a list of Qobj""); else:; j = 0; for ctrl in ctrls:; if not isinstance(ctrl, Qobj):; raise TypeError(""ctrls should be a list of Qobj""); else:; ctrls[j] = ctrl.full(); j += 1. if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""); else:; initial = initial.full(). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""); else:; target = target.full(). cfg = optimconfig.OptimConfig(); cfg.optim_alg = optim_alg; cfg.max_metric_corr = max_metric_corr; cfg",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:25747,Security,access,accessed,25747,"0). These will be scaled by this parameter. pulse_offset : float; Line offset for the pulse. That is this value will be added; to any initial pulses generated. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; Note value should be set using set_log_level. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------. Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g.; optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; """""". # check parameters; if not isinstance(drift, Qobj):; raise TypeError(""drift must be a Qobj""); else:; drift = drift.full(). if not isinstance(ctrls, (list, tuple)):; raise TypeError(""ctrls should be a list of Qobj""); else:; j = 0; for ctrl in ctrls:; if not isinstance(ctrl, Qobj):; raise TypeError(""ctrls should be a list of Qobj""); else:; ctrls[j] = ctrl.full(); j += 1. if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""); else:; initial = initial.full(). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""); else:; target = target.full(). cfg = optimconfig.OptimConfig(); cfg.optim_alg = optim_alg; cfg.max_metric_corr = max_metric_corr; cfg.accuracy_factor = accuracy_factor; cfg.amp_update_mode = amp_update_mode; cfg.dyn_type = dyn_type; cfg.prop_type = prop_type; cfg.fid",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:4019,Testability,log,logging,4019," ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; """"""; import numpy as np; # QuTiP; from qutip import Qobj; import qutip.logging as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen. [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=-np.Inf, amp_ubound=np.Inf,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; optim_alg='LBFGSB', max_metric_corr=10, accuracy_factor=1e7,; dyn_type='GEN_MAT', prop_type='DEF',; fid_type='DEF', phase_option=None, fid_err_scale_factor=None,; amp_update_mode='ALL',; init_pulse_type='RND', pulse_scaling=1.0, pulse_offset=0.0,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to mi",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:4030,Testability,log,logging,4030," ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; """"""; import numpy as np; # QuTiP; from qutip import Qobj; import qutip.logging as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen. [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=-np.Inf, amp_ubound=np.Inf,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; optim_alg='LBFGSB', max_metric_corr=10, accuracy_factor=1e7,; dyn_type='GEN_MAT', prop_type='DEF',; fid_type='DEF', phase_option=None, fid_err_scale_factor=None,; amp_update_mode='ALL',; init_pulse_type='RND', pulse_scaling=1.0, pulse_offset=0.0,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to mi",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:4039,Testability,log,logger,4039," ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; """"""; import numpy as np; # QuTiP; from qutip import Qobj; import qutip.logging as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen. [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=-np.Inf, amp_ubound=np.Inf,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; optim_alg='LBFGSB', max_metric_corr=10, accuracy_factor=1e7,; dyn_type='GEN_MAT', prop_type='DEF',; fid_type='DEF', phase_option=None, fid_err_scale_factor=None,; amp_update_mode='ALL',; init_pulse_type='RND', pulse_scaling=1.0, pulse_offset=0.0,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to mi",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:4048,Testability,log,logging,4048," ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; """"""; import numpy as np; # QuTiP; from qutip import Qobj; import qutip.logging as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen. [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=-np.Inf, amp_ubound=np.Inf,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; optim_alg='LBFGSB', max_metric_corr=10, accuracy_factor=1e7,; dyn_type='GEN_MAT', prop_type='DEF',; fid_type='DEF', phase_option=None, fid_err_scale_factor=None,; amp_update_mode='ALL',; init_pulse_type='RND', pulse_scaling=1.0, pulse_offset=0.0,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to mi",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:4949,Testability,log,logging,4949,"; """"""; import numpy as np; # QuTiP; from qutip import Qobj; import qutip.logging as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen. [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=-np.Inf, amp_ubound=np.Inf,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; optim_alg='LBFGSB', max_metric_corr=10, accuracy_factor=1e7,; dyn_type='GEN_MAT', prop_type='DEF',; fid_type='DEF', phase_option=None, fid_err_scale_factor=None,; amp_update_mode='ALL',; init_pulse_type='RND', pulse_scaling=1.0, pulse_offset=0.0,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------. drift : Qobj; the underlying dynamics generator of the system. ctrls : List of Qobj; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transfor",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:9918,Testability,log,logger,9918,"s only); The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift. amp_update_mode : string; determines whether propagators are calculated; Options: DEF, ALL, DYNAMIC (needs work); DEF will use the default for the specific dyn_type; (See TimeslotComputer classes for details). init_pulse_type : string; type / shape of pulse(s) used to initialise the; the control amplitudes. Options include:; RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW; (see PulseGen classes for details). pulse_scaling : float; Linear scale factor for generated pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Line offset for the pulse. That is this value will be added; to any initial pulses generated. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; """""". # The parameters are check",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:9959,Testability,log,logging,9959," None is given then it is caculated as 1/2N, where N; is the dimension of the drift. amp_update_mode : string; determines whether propagators are calculated; Options: DEF, ALL, DYNAMIC (needs work); DEF will use the default for the specific dyn_type; (See TimeslotComputer classes for details). init_pulse_type : string; type / shape of pulse(s) used to initialise the; the control amplitudes. Options include:; RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW; (see PulseGen classes for details). pulse_scaling : float; Linear scale factor for generated pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Line offset for the pulse. That is this value will be added; to any initial pulses generated. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). optim ",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:10967,Testability,log,logging,10967,"ging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). optim = create_pulse_optimizer(; drift, ctrls, initial, target,; num_tslots=num_tslots, evo_time=evo_time, tau=tau,; amp_lbound=amp_lbound, amp_ubound=amp_ubound,; fid_err_targ=fid_err_targ, min_grad=min_grad,; max_iter=max_iter, max_wall_time=max_wall_time,; optim_alg=optim_alg, max_metric_corr=max_metric_corr,; accuracy_factor=accuracy_factor,; dyn_type=dyn_type, prop_type=prop_type,; fid_type=fid_type, phase_option=phase_option,; fid_err_scale_factor=fid_err_scale_factor,; amp_update_mode=amp_update_mode, init_pulse_type=init_pulse_type,; pulse_scaling=pulse_scaling, pulse_offset=pulse_offset,; log_level=log_level, gen_stats=gen_stats). dyn = optim.dynamics; p_gen = optim.pulse_generator. if log_level <= logging.INFO:; msg = ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:10996,Testability,log,logger,10996," of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). optim = create_pulse_optimizer(; drift, ctrls, initial, target,; num_tslots=num_tslots, evo_time=evo_time, tau=tau,; amp_lbound=amp_lbound, amp_ubound=amp_ubound,; fid_err_targ=fid_err_targ, min_grad=min_grad,; max_iter=max_iter, max_wall_time=max_wall_time,; optim_alg=optim_alg, max_metric_corr=max_metric_corr,; accuracy_factor=accuracy_factor,; dyn_type=dyn_type, prop_type=prop_type,; fid_type=fid_type, phase_option=phase_option,; fid_err_scale_factor=fid_err_scale_factor,; amp_update_mode=amp_update_mode, init_pulse_type=init_pulse_type,; pulse_scaling=pulse_scaling, pulse_offset=pulse_offset,; log_level=log_level, gen_stats=gen_stats). dyn = optim.dynamics; p_gen = optim.pulse_generator. if log_level <= logging.INFO:; msg = ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:11031,Testability,log,logger,11031,"NSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). optim = create_pulse_optimizer(; drift, ctrls, initial, target,; num_tslots=num_tslots, evo_time=evo_time, tau=tau,; amp_lbound=amp_lbound, amp_ubound=amp_ubound,; fid_err_targ=fid_err_targ, min_grad=min_grad,; max_iter=max_iter, max_wall_time=max_wall_time,; optim_alg=optim_alg, max_metric_corr=max_metric_corr,; accuracy_factor=accuracy_factor,; dyn_type=dyn_type, prop_type=prop_type,; fid_type=fid_type, phase_option=phase_option,; fid_err_scale_factor=fid_err_scale_factor,; amp_update_mode=amp_update_mode, init_pulse_type=init_pulse_type,; pulse_scaling=pulse_scaling, pulse_offset=pulse_offset,; log_level=log_level, gen_stats=gen_stats). dyn = optim.dynamics; p_gen = optim.pulse_generator. if log_level <= logging.INFO:; msg = ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nContr",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:11776,Testability,log,logging,11776," for termination, final fidelity error, final evolution; final amplitudes, statistics etc; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). optim = create_pulse_optimizer(; drift, ctrls, initial, target,; num_tslots=num_tslots, evo_time=evo_time, tau=tau,; amp_lbound=amp_lbound, amp_ubound=amp_ubound,; fid_err_targ=fid_err_targ, min_grad=min_grad,; max_iter=max_iter, max_wall_time=max_wall_time,; optim_alg=optim_alg, max_metric_corr=max_metric_corr,; accuracy_factor=accuracy_factor,; dyn_type=dyn_type, prop_type=prop_type,; fid_type=fid_type, phase_option=phase_option,; fid_err_scale_factor=fid_err_scale_factor,; amp_update_mode=amp_update_mode, init_pulse_type=init_pulse_type,; pulse_scaling=pulse_scaling, pulse_offset=pulse_offset,; log_level=log_level, gen_stats=gen_stats). dyn = optim.dynamics; p_gen = optim.pulse_generator. if log_level <= logging.INFO:; msg = ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial operator:\n""; msg += str(dyn.initial); msg += ""\nTarget operator:\n""; msg += str(dyn.target); logger.info(msg). # Generate pulses for each control; init_amps = np.zeros([num_tslots, dyn.num_ctrls]); for j in range(dyn.num_ctrls):; init_amps[:, j] = p_gen.gen_pulse(). # Initialise the starting amplitudes; dyn.initialize_controls(init_amps). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is n",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:12201,Testability,log,logger,12201,"mp_ubound=amp_ubound,; fid_err_targ=fid_err_targ, min_grad=min_grad,; max_iter=max_iter, max_wall_time=max_wall_time,; optim_alg=optim_alg, max_metric_corr=max_metric_corr,; accuracy_factor=accuracy_factor,; dyn_type=dyn_type, prop_type=prop_type,; fid_type=fid_type, phase_option=phase_option,; fid_err_scale_factor=fid_err_scale_factor,; amp_update_mode=amp_update_mode, init_pulse_type=init_pulse_type,; pulse_scaling=pulse_scaling, pulse_offset=pulse_offset,; log_level=log_level, gen_stats=gen_stats). dyn = optim.dynamics; p_gen = optim.pulse_generator. if log_level <= logging.INFO:; msg = ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial operator:\n""; msg += str(dyn.initial); msg += ""\nTarget operator:\n""; msg += str(dyn.target); logger.info(msg). # Generate pulses for each control; init_amps = np.zeros([num_tslots, dyn.num_ctrls]); for j in range(dyn.num_ctrls):; init_amps[:, j] = p_gen.gen_pulse(). # Initialise the starting amplitudes; dyn.initialize_controls(init_amps). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=-np.Inf, amp_ubound=np.Inf,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:12612,Testability,log,logging,12612,"se_type,; pulse_scaling=pulse_scaling, pulse_offset=pulse_offset,; log_level=log_level, gen_stats=gen_stats). dyn = optim.dynamics; p_gen = optim.pulse_generator. if log_level <= logging.INFO:; msg = ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial operator:\n""; msg += str(dyn.initial); msg += ""\nTarget operator:\n""; msg += str(dyn.target); logger.info(msg). # Generate pulses for each control; init_amps = np.zeros([num_tslots, dyn.num_ctrls]); for j in range(dyn.num_ctrls):; init_amps[:, j] = p_gen.gen_pulse(). # Initialise the starting amplitudes; dyn.initialize_controls(init_amps). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=-np.Inf, amp_ubound=np.Inf,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; optim_alg='LBFGSB', max_metric_corr=10, accuracy_factor=1e7,; phase_option='PSU',; amp_update_mode='ALL',; init_pulse_type='RND', pulse_scaling=1.0, pulse_offset=0.0,; log_level=logging.NOTSET, out_file_ext='.txt', gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This f",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:12627,Testability,log,logger,12627,"scaling, pulse_offset=pulse_offset,; log_level=log_level, gen_stats=gen_stats). dyn = optim.dynamics; p_gen = optim.pulse_generator. if log_level <= logging.INFO:; msg = ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial operator:\n""; msg += str(dyn.initial); msg += ""\nTarget operator:\n""; msg += str(dyn.target); logger.info(msg). # Generate pulses for each control; init_amps = np.zeros([num_tslots, dyn.num_ctrls]); for j in range(dyn.num_ctrls):; init_amps[:, j] = p_gen.gen_pulse(). # Initialise the starting amplitudes; dyn.initialize_controls(init_amps). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=-np.Inf, amp_ubound=np.Inf,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; optim_alg='LBFGSB', max_metric_corr=10, accuracy_factor=1e7,; phase_option='PSU',; amp_update_mode='ALL',; init_pulse_type='RND', pulse_scaling=1.0, pulse_offset=0.0,; log_level=logging.NOTSET, out_file_ext='.txt', gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper fo",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:12911,Testability,log,logging,12911,"tonian""; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial operator:\n""; msg += str(dyn.initial); msg += ""\nTarget operator:\n""; msg += str(dyn.target); logger.info(msg). # Generate pulses for each control; init_amps = np.zeros([num_tslots, dyn.num_ctrls]); for j in range(dyn.num_ctrls):; init_amps[:, j] = p_gen.gen_pulse(). # Initialise the starting amplitudes; dyn.initialize_controls(init_amps). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=-np.Inf, amp_ubound=np.Inf,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; optim_alg='LBFGSB', max_metric_corr=10, accuracy_factor=1e7,; phase_option='PSU',; amp_update_mode='ALL',; init_pulse_type='RND', pulse_scaling=1.0, pulse_offset=0.0,; log_level=logging.NOTSET, out_file_ext='.txt', gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:12926,Testability,log,logger,12926,"format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial operator:\n""; msg += str(dyn.initial); msg += ""\nTarget operator:\n""; msg += str(dyn.target); logger.info(msg). # Generate pulses for each control; init_amps = np.zeros([num_tslots, dyn.num_ctrls]); for j in range(dyn.num_ctrls):; init_amps[:, j] = p_gen.gen_pulse(). # Initialise the starting amplitudes; dyn.initialize_controls(init_amps). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=-np.Inf, amp_ubound=np.Inf,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; optim_alg='LBFGSB', max_metric_corr=10, accuracy_factor=1e7,; phase_option='PSU',; amp_update_mode='ALL',; init_pulse_type='RND', pulse_scaling=1.0, pulse_offset=0.0,; log_level=logging.NOTSET, out_file_ext='.txt', gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The co",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:13394,Testability,log,logging,13394," starting amplitudes; dyn.initialize_controls(init_amps). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=-np.Inf, amp_ubound=np.Inf,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; optim_alg='LBFGSB', max_metric_corr=10, accuracy_factor=1e7,; phase_option='PSU',; amp_update_mode='ALL',; init_pulse_type='RND', pulse_scaling=1.0, pulse_offset=0.0,; log_level=logging.NOTSET, out_file_ext='.txt', gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters; ----------. H_",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:17658,Testability,log,logger,17658,"curacy; scipy.optimize.fmin_l_bfgs_b factr argument.; (used only in L-BFGS-B). phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. amp_update_mode : string; determines whether propagators are calculated; Options: DEF, ALL, DYNAMIC (needs work); DEF will use the default for the specific dyn_type; (See TimeslotComputer classes for details). init_pulse_type : string; type / shape of pulse(s) used to initialise the; the control amplitudes. Options include:; RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW; (see PulseGen classes for details). pulse_scaling : float; Linear scale factor for generated pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Line offset for the pulse. That is this value will be added; to any initial pulses generated. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; """""". # check parameters here, a",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:17699,Testability,log,logging,17699,"type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. amp_update_mode : string; determines whether propagators are calculated; Options: DEF, ALL, DYNAMIC (needs work); DEF will use the default for the specific dyn_type; (See TimeslotComputer classes for details). init_pulse_type : string; type / shape of pulse(s) used to initialise the; the control amplitudes. Options include:; RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW; (see PulseGen classes for details). pulse_scaling : float; Linear scale factor for generated pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Line offset for the pulse. That is this value will be added; to any initial pulses generated. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; """""". # check parameters here, as names are different than in; # create_pulse_optimizer, so TypeErrors would be confusing. if not isinstance(H_d, Qobj):; raise TypeError(""H_d must be a Qobj""). if not isin",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:20213,Testability,log,logging,20213,"m_tslots=num_tslots, evo_time=evo_time, tau=tau,; amp_lbound=amp_lbound, amp_ubound=amp_ubound,; fid_err_targ=fid_err_targ, min_grad=min_grad,; max_iter=max_iter, max_wall_time=max_wall_time,; optim_alg=optim_alg, max_metric_corr=max_metric_corr,; accuracy_factor=accuracy_factor,; dyn_type='UNIT', phase_option=phase_option,; amp_update_mode=amp_update_mode,; init_pulse_type=init_pulse_type,; pulse_scaling=pulse_scaling,; pulse_offset=pulse_offset,; log_level=log_level, out_file_ext=out_file_ext,; gen_stats=gen_stats). [docs]def create_pulse_optimizer(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=-np.Inf, amp_ubound=np.Inf,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; optim_alg='LBFGSB', max_metric_corr=10, accuracy_factor=1e7,; dyn_type='GEN_MAT', prop_type='DEF',; fid_type='DEF', phase_option=None, fid_err_scale_factor=None,; amp_update_mode='ALL',; init_pulse_type='RND', pulse_scaling=1.0, pulse_offset=0.0,; log_level=logging.NOTSET, gen_stats=False):. """"""; Generate the objects of the appropriate subclasses; required for the pulse optmisation based on the parameters given; Note this method may be preferable to calling optimize_pulse; if more detailed configuration is required before running the; optmisation algorthim, or the algorithm will be run many times,; for instances when trying to finding global the optimum or; minimum time optimisation. Parameters; ----------. drift : Qobj; the underlying dynamics generator of the system. ctrls : List of Qobj; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies th",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:24947,Testability,log,logger,24947,"s only); The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift. amp_update_mode : string; determines whether propagators are calculated; Options: DEF, ALL, DYNAMIC (needs work); DEF will use the default for the specific dyn_type; (See TimeslotComputer classes for details). init_pulse_type : string; type / shape of pulse(s) used to initialise the; the control amplitudes. Options include:; RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW; (see PulseGen classes for details). pulse_scaling : float; Linear scale factor for generated pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Line offset for the pulse. That is this value will be added; to any initial pulses generated. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; Note value should be set using set_log_level. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------. Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g.; optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; """""". # check paramete",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:24988,Testability,log,logging,24988," None is given then it is caculated as 1/2N, where N; is the dimension of the drift. amp_update_mode : string; determines whether propagators are calculated; Options: DEF, ALL, DYNAMIC (needs work); DEF will use the default for the specific dyn_type; (See TimeslotComputer classes for details). init_pulse_type : string; type / shape of pulse(s) used to initialise the; the control amplitudes. Options include:; RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW; (see PulseGen classes for details). pulse_scaling : float; Linear scale factor for generated pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Line offset for the pulse. That is this value will be added; to any initial pulses generated. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; Note value should be set using set_log_level. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------. Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g.; optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; """""". # check parameters; if not isinstance(drift, Qobj):; raise TypeError(""drift must be a Qobj""); else:; drift = drift.full(). if not isinstance(ctrls, (list, tuple)):; raise TypeError(""ctrls ",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:26891,Testability,log,logging,26891,"_optimization; """""". # check parameters; if not isinstance(drift, Qobj):; raise TypeError(""drift must be a Qobj""); else:; drift = drift.full(). if not isinstance(ctrls, (list, tuple)):; raise TypeError(""ctrls should be a list of Qobj""); else:; j = 0; for ctrl in ctrls:; if not isinstance(ctrl, Qobj):; raise TypeError(""ctrls should be a list of Qobj""); else:; ctrls[j] = ctrl.full(); j += 1. if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""); else:; initial = initial.full(). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""); else:; target = target.full(). cfg = optimconfig.OptimConfig(); cfg.optim_alg = optim_alg; cfg.max_metric_corr = max_metric_corr; cfg.accuracy_factor = accuracy_factor; cfg.amp_update_mode = amp_update_mode; cfg.dyn_type = dyn_type; cfg.prop_type = prop_type; cfg.fid_type = fid_type; cfg.pulse_type = init_pulse_type; cfg.phase_option = phase_option; cfg.amp_lbound = amp_lbound; cfg.amp_ubound = amp_ubound. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). cfg.log_level = log_level. # Create the Dynamics instance; if dyn_type == 'GEN_MAT' or dyn_type is None or dyn_type == '':; dyn = dynamics.DynamicsGenMat(cfg); elif dyn_type == 'UNIT':; dyn = dynamics.DynamicsUnitary(cfg); elif dyn_type == 'SYMPL':; dyn = dynamics.DynamicsSymplectic(cfg); else:; raise errors.UsageError(""No option for dyn_type: "" + dyn_type). # Create the PropagatorComputer instance; # The default will be typically be the best option; if prop_type == 'DEF' or prop_type is None or prop_type == '':; # Do nothing use the default for the Dynamics; pass; elif prop_type == 'APPROX':; if not isinstance(dyn.prop_computer, propcomp.PropCompApproxGrad):; dyn.prop_computer = propcomp.PropCompApproxGrad(dyn); elif prop_type == 'DIAG':; if not isinstance(dyn.prop_computer, propcomp.PropCompDiag):; dyn.prop_computer = propcomp.PropCompDiag(dyn); elif prop_type == 'AUG_MAT':; if not isinsta",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:26920,Testability,log,logger,26920," parameters; if not isinstance(drift, Qobj):; raise TypeError(""drift must be a Qobj""); else:; drift = drift.full(). if not isinstance(ctrls, (list, tuple)):; raise TypeError(""ctrls should be a list of Qobj""); else:; j = 0; for ctrl in ctrls:; if not isinstance(ctrl, Qobj):; raise TypeError(""ctrls should be a list of Qobj""); else:; ctrls[j] = ctrl.full(); j += 1. if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""); else:; initial = initial.full(). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""); else:; target = target.full(). cfg = optimconfig.OptimConfig(); cfg.optim_alg = optim_alg; cfg.max_metric_corr = max_metric_corr; cfg.accuracy_factor = accuracy_factor; cfg.amp_update_mode = amp_update_mode; cfg.dyn_type = dyn_type; cfg.prop_type = prop_type; cfg.fid_type = fid_type; cfg.pulse_type = init_pulse_type; cfg.phase_option = phase_option; cfg.amp_lbound = amp_lbound; cfg.amp_ubound = amp_ubound. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). cfg.log_level = log_level. # Create the Dynamics instance; if dyn_type == 'GEN_MAT' or dyn_type is None or dyn_type == '':; dyn = dynamics.DynamicsGenMat(cfg); elif dyn_type == 'UNIT':; dyn = dynamics.DynamicsUnitary(cfg); elif dyn_type == 'SYMPL':; dyn = dynamics.DynamicsSymplectic(cfg); else:; raise errors.UsageError(""No option for dyn_type: "" + dyn_type). # Create the PropagatorComputer instance; # The default will be typically be the best option; if prop_type == 'DEF' or prop_type is None or prop_type == '':; # Do nothing use the default for the Dynamics; pass; elif prop_type == 'APPROX':; if not isinstance(dyn.prop_computer, propcomp.PropCompApproxGrad):; dyn.prop_computer = propcomp.PropCompApproxGrad(dyn); elif prop_type == 'DIAG':; if not isinstance(dyn.prop_computer, propcomp.PropCompDiag):; dyn.prop_computer = propcomp.PropCompDiag(dyn); elif prop_type == 'AUG_MAT':; if not isinstance(dyn.prop_computer, pro",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:26955,Testability,log,logger,26955,"drift, Qobj):; raise TypeError(""drift must be a Qobj""); else:; drift = drift.full(). if not isinstance(ctrls, (list, tuple)):; raise TypeError(""ctrls should be a list of Qobj""); else:; j = 0; for ctrl in ctrls:; if not isinstance(ctrl, Qobj):; raise TypeError(""ctrls should be a list of Qobj""); else:; ctrls[j] = ctrl.full(); j += 1. if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""); else:; initial = initial.full(). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""); else:; target = target.full(). cfg = optimconfig.OptimConfig(); cfg.optim_alg = optim_alg; cfg.max_metric_corr = max_metric_corr; cfg.accuracy_factor = accuracy_factor; cfg.amp_update_mode = amp_update_mode; cfg.dyn_type = dyn_type; cfg.prop_type = prop_type; cfg.fid_type = fid_type; cfg.pulse_type = init_pulse_type; cfg.phase_option = phase_option; cfg.amp_lbound = amp_lbound; cfg.amp_ubound = amp_ubound. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). cfg.log_level = log_level. # Create the Dynamics instance; if dyn_type == 'GEN_MAT' or dyn_type is None or dyn_type == '':; dyn = dynamics.DynamicsGenMat(cfg); elif dyn_type == 'UNIT':; dyn = dynamics.DynamicsUnitary(cfg); elif dyn_type == 'SYMPL':; dyn = dynamics.DynamicsSymplectic(cfg); else:; raise errors.UsageError(""No option for dyn_type: "" + dyn_type). # Create the PropagatorComputer instance; # The default will be typically be the best option; if prop_type == 'DEF' or prop_type is None or prop_type == '':; # Do nothing use the default for the Dynamics; pass; elif prop_type == 'APPROX':; if not isinstance(dyn.prop_computer, propcomp.PropCompApproxGrad):; dyn.prop_computer = propcomp.PropCompApproxGrad(dyn); elif prop_type == 'DIAG':; if not isinstance(dyn.prop_computer, propcomp.PropCompDiag):; dyn.prop_computer = propcomp.PropCompDiag(dyn); elif prop_type == 'AUG_MAT':; if not isinstance(dyn.prop_computer, propcomp.PropCompAugMat):; dyn.prop",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:31355,Testability,log,logging,31355,"wall_time = max_wall_time; optim.termination_conditions = tc. if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; dyn.ctrl_dyn_gen = ctrls; dyn.initial = initial; dyn.target = target; if tau is None:; # Check that parameters have been supplied to generate the; # timeslot durations; try:; evo_time / num_tslots; except:; raise errors.UsageError(; ""Either the timeslot durations should be supplied as an ""; ""array 'tau' or the number of timeslots 'num_tslots' ""; ""and the evolution time 'evo_time' must be given.""). dyn.num_tslots = num_tslots; dyn.evo_time = evo_time; else:; dyn.tau = tau. # this function is called, so that the num_ctrls attribute will be set; dyn.get_num_ctrls(). # Create a pulse generator of the type specified; p_gen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn); p_gen.scaling = pulse_scaling; p_gen.offset = pulse_offset; p_gen.lbound = amp_lbound; p_gen.ubound = amp_ubound. # If the pulse is a periodic type, then set the pulse to be one complete; # wave; if isinstance(p_gen, pulsegen.PulseGenPeriodic):; p_gen.num_waves = 1.0; optim.pulse_generator = p_gen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + p_gen.__class__.__name__). return optim. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:31371,Testability,log,logger,31371,"wall_time = max_wall_time; optim.termination_conditions = tc. if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; dyn.ctrl_dyn_gen = ctrls; dyn.initial = initial; dyn.target = target; if tau is None:; # Check that parameters have been supplied to generate the; # timeslot durations; try:; evo_time / num_tslots; except:; raise errors.UsageError(; ""Either the timeslot durations should be supplied as an ""; ""array 'tau' or the number of timeslots 'num_tslots' ""; ""and the evolution time 'evo_time' must be given.""). dyn.num_tslots = num_tslots; dyn.evo_time = evo_time; else:; dyn.tau = tau. # this function is called, so that the num_ctrls attribute will be set; dyn.get_num_ctrls(). # Create a pulse generator of the type specified; p_gen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn); p_gen.scaling = pulse_scaling; p_gen.offset = pulse_offset; p_gen.lbound = amp_lbound; p_gen.ubound = amp_ubound. # If the pulse is a periodic type, then set the pulse to be one complete; # wave; if isinstance(p_gen, pulsegen.PulseGenPeriodic):; p_gen.num_waves = 1.0; optim.pulse_generator = p_gen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + p_gen.__class__.__name__). return optim. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:13608,Usability,simpl,simply,13608,"run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=-np.Inf, amp_ubound=np.Inf,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; optim_alg='LBFGSB', max_metric_corr=10, accuracy_factor=1e7,; phase_option='PSU',; amp_update_mode='ALL',; init_pulse_type='RND', pulse_scaling=1.0, pulse_offset=0.0,; log_level=logging.NOTSET, out_file_ext='.txt', gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters; ----------. H_d : Qobj; Drift (aka system) the underlying Hamiltonian of the system. H_c : Qobj; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. ",MatchSource.WIKI,docs/3.1.0/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:252,Deployability,install,installation,252,"﻿. qutip.fortran.mcsolve_f90 — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.fortran.mcsolve_f90; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the f",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:10752,Deployability,integrat,integrate,10752,"procs):; p = Process(target=self.evolve_serial,; args=((resq, self.ntrajs[i], i, self.seed * (i + 1)),)); p.start(); processes.append(p); cnt = 0. while True:; try:; sols.append(resq.get()); resq.task_done(); cnt += 1; if (cnt >= self.nprocs):; break; except KeyboardInterrupt:; break; except:; pass. resq.join(); for proc in processes:; try:; proc.join(); except KeyboardInterrupt:; if debug:; print(""Cancel thread on keyboard interrupt""); proc.terminate(); proc.join(); resq.close(); return sols. def serial(self):. if debug:; print(inspect.stack()[0][3]). self.nprocs = 1; self.ntrajs = [self.ntraj]; if debug:; print(""Running in serial.""); print(""Number of trajectories: "" + str(self.ntraj)); sol = self.evolve_serial((0, self.ntraj, 0, self.seed)); return [sol]. def run(self):. if debug:; print(inspect.stack()[0][3]). from numpy.random import random_integers; if (config.c_num == 0):; # force one trajectory if no collapse operators; config.ntraj = 1; self.ntraj = 1; # Set unravel_type to 1 to integrate without collapses; self.unravel_type = 1; if (config.e_num == 0):; # If we are returning states, and there are no; # collapse operators, set average_states to False to return; # ket vectors instead of density matrices; config.options.average_states = False; # generate a random seed, useful if e.g. running with MPI; self.seed = random_integers(1e8); if (self.serial_run):; # run in serial; sols = self.serial(); else:; # run in paralell; sols = self.parallel(); # gather data; self.sol = _gather(sols). def evolve_serial(self, args):. if debug:; print(inspect.stack()[0][3] + "":"" + str(os.getpid())). # run ntraj trajectories for one process via fortran; # get args; queue, ntraj, instanceno, rngseed = args; # initialize the problem in fortran; _init_tlist(); _init_psi0(); if (self.ptrace_sel != []):; _init_ptrace_stuff(self.ptrace_sel); _init_hamilt(); if (config.c_num != 0):; _init_c_ops(); if (config.e_num != 0):; _init_e_ops(); # set options; qtf90.qutraj_run.n_c_ops = config.c",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:20891,Deployability,update,updated,20891,"si0,; dims=config.psi0_dims,; shape=config.psi0_shape); qtf90.qutraj_run.init_ptrace_stuff(config.psi0_dims[0],; np.array(sel) + 1,; psi0.ptrace(sel).shape[0]). def _init_hamilt():; # construct effective non-Hermitian Hamiltonian; # H_eff = H - 0.5j*sum([c_ops[i].dag()*c_ops[i]; # for i in range(len(c_ops))]); # Of = _qobj_to_fortrancsr(H_eff); # qtf90.qutraj_run.init_hamiltonian(Of[0],Of[1],; # Of[2],Of[3],Of[4]); d = np.size(config.psi0); qtf90.qutraj_run.init_hamiltonian(; _complexarray_to_fortran(config.h_data),; config.h_ind + 1, config.h_ptr + 1, d, d). def _init_c_ops():; d = np.size(config.psi0); n = config.c_num; first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(c_ops[i]); # qtf90.qutraj_run.init_c_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_c_ops(; i + 1, n, _complexarray_to_fortran(config.c_ops_data[i]),; config.c_ops_ind[i] + 1, config.c_ops_ptr[i] + 1, d, d, first); first = False. def _init_e_ops():; d = np.size(config.psi0); # n = config.e_num; n = len(config.e_ops_data); first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(e_ops[i]); # qtf90.qutraj_run.init_e_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_e_ops(; i + 1, n, _complexarray_to_fortran(config.e_ops_data[i]),; config.e_ops_ind[i] + 1, config.e_ops_ptr[i] + 1, d, d, first); first = False. #; # Misc. converison functions; #; def _realarray_to_fortran(a):; datad = np.array(a, dtype=wpr); return datad. def _complexarray_to_fortran(a):; datad = np.array(a, dtype=wpc); return datad. def _qobj_to_fortranfull(A):; datad = np.array(A.data.toarray(), dtype=wpc); return datad. def _qobj_to_fortrancsr(A):; data = np.array(A.data.data, dtype=wpc); indices = np.array(A.data.indices); indptr = np.array(A.data.indptr); m = A.data.shape[0]; k = A.data.shape[1]; return data, indices + 1, indptr + 1, m, k. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:7828,Energy Efficiency,reduce,reduced,7828,"zed method for ode solver, using ""adams"".'); mc.mf = 10; # store ket and density matrix dims and shape for convenience; mc.psi0_dims = psi0.dims; mc.psi0_shape = psi0.shape; mc.dm_dims = (psi0 * psi0.dag()).dims; mc.dm_shape = (psi0 * psi0.dag()).shape; # use sparse density matrices during computation?; mc.sparse_dms = sparse_dms; # run in serial?; mc.serial_run = serial or (ntraj == 1); # are we doing a partial trace for returned states?; mc.ptrace_sel = ptrace_sel; if (ptrace_sel != []):; if debug:; print(""ptrace_sel set to "" + str(ptrace_sel)); print(""We are using dense density matrices during computation "" +; ""when performing partial trace. Setting sparse_dms = False""); print(""This feature is experimental.""); mc.sparse_dms = False; mc.dm_dims = psi0.ptrace(ptrace_sel).dims; mc.dm_shape = psi0.ptrace(ptrace_sel).shape; if (calc_entropy):; if (ptrace_sel == []):; if debug:; print(""calc_entropy = True, but ptrace_sel = []. Please set "" +; ""a list of components to keep when calculating average"" +; "" entropy of reduced density matrix in ptrace_sel. "" +; ""Setting calc_entropy = False.""); calc_entropy = False; mc.calc_entropy = calc_entropy. # construct output Result object; output = Result(). # Run; mc.run(); output.states = mc.sol.states; output.expect = mc.sol.expect; output.col_times = mc.sol.col_times; output.col_which = mc.sol.col_which; if (hasattr(mc.sol, 'entropy')):; output.entropy = mc.sol.entropy. output.solver = 'Fortran 90 Monte Carlo solver'; # simulation parameters; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj. return output. class _MC_class():; def __init__(self):; self.cpus = config.options.num_cpus; self.nprocs = self.cpus; self.sol = Result(); self.mf = 10; # If returning density matrices, return as sparse or dense?; self.sparse_dms = True; # Run in serial?; self.serial_run = False; self.ntraj = config.ntraj; self.ntrajs = []; self.seed = None; self.psi0_dims = None; s",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:12699,Energy Efficiency,reduce,reduced,12699,"); # set options; qtf90.qutraj_run.n_c_ops = config.c_num; qtf90.qutraj_run.n_e_ops = config.e_num; qtf90.qutraj_run.ntraj = ntraj; qtf90.qutraj_run.unravel_type = self.unravel_type; qtf90.qutraj_run.average_states = config.options.average_states; qtf90.qutraj_run.average_expect = config.options.average_expect; qtf90.qutraj_run.init_result(config.psi0_shape[0],; config.options.atol,; config.options.rtol, mf=self.mf,; norm_steps=config.norm_steps,; norm_tol=config.norm_tol); # set optional arguments; qtf90.qutraj_run.order = config.options.order; qtf90.qutraj_run.nsteps = config.options.nsteps; qtf90.qutraj_run.first_step = config.options.first_step; qtf90.qutraj_run.min_step = config.options.min_step; qtf90.qutraj_run.max_step = config.options.max_step; qtf90.qutraj_run.norm_steps = config.options.norm_steps; qtf90.qutraj_run.norm_tol = config.options.norm_tol; # use sparse density matrices during computation?; qtf90.qutraj_run.rho_return_sparse = self.sparse_dms; # calculate entropy of reduced density matrice?; qtf90.qutraj_run.calc_entropy = self.calc_entropy; # run; show_progress = 1 if debug else 0; qtf90.qutraj_run.evolve(instanceno, rngseed, show_progress). # construct Result instance; sol = Result(); sol.ntraj = ntraj; # sol.col_times = qtf90.qutraj_run.col_times; # sol.col_which = qtf90.qutraj_run.col_which-1; sol.col_times, sol.col_which = self.get_collapses(ntraj); if (config.e_num == 0):; sol.states = self.get_states(len(config.tlist), ntraj); else:; sol.expect = self.get_expect(len(config.tlist), ntraj); if (self.calc_entropy):; sol.entropy = self.get_entropy(len(config.tlist)). if (not self.serial_run):; # put to queue; queue.put(sol); queue.join(). # deallocate stuff; # finalize(); return sol. # Routines for retrieving data data from fortran; def get_collapses(self, ntraj):. if debug:; print(inspect.stack()[0][3]). col_times = np.zeros((ntraj), dtype=np.ndarray); col_which = np.zeros((ntraj), dtype=np.ndarray); if (config.c_num == 0):; # no collapses; r",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:4060,Integrability,depend,dependence,4060," WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; #; # Original Code by Arne Grimsmo (2012): github.com/arnelg/qutipf90mc; ###############################################################################. import numpy as np. from qutip.fortran import qutraj_run as qtf90; from qutip.qobj import Qobj; from qutip.mcsolve import _mc_data_config; from qutip.solver import Options, Result, config; from qutip.settings import debug; import qutip.settings. if debug:; import inspect; import os. # Working precision; wpr = np.dtype(np.float64); wpc = np.dtype(np.complex128). [docs]def mcsolve_f90(H, psi0, tlist, c_ops, e_ops, ntraj=None,; options=Options(), sparse_dms=True, serial=False,; ptrace_sel=[], calc_entropy=False):; """"""; Monte-Carlo wave function solver with fortran 90 backend.; Usage is identical to qutip.mcsolve, for problems without explicit; time-dependence, and with some optional input:. Parameters; ----------; H : qobj; System Hamiltonian.; psi0 : qobj; Initial state vector; tlist : array_like; Times at which results are recorded.; ntraj : int; Number of trajectories to run.; c_ops : array_like; ``list`` or ``array`` of collapse operators.; e_ops : array_like; ``list`` or ``array`` of operators for calculating expectation values.; options : Options; Instance of solver options.; sparse_dms : boolean; If averaged density matrices are returned, they will be stored as; sparse (Compressed Row Format) matrices during computation if; sparse_dms = True (default), and dense matrices otherwise. Dense; matrices might be preferable for smaller systems.; serial : boolean; If True (default is False) the solver will not make use of the; multiprocessing module, and simply run in serial.; ptrace_sel: list; This optional argument specifies a list of components to keep when; returning a partially traced density matrix. This can be convenient f",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:6403,Integrability,depend,dependence,6403,"ett.; 93, 120408 (2004), Phys. Rev. A 86, 022310 (2012). Returns; -------; results : Result; Object storing all results from simulation. """"""; if ntraj is None:; ntraj = options.ntraj. if psi0.type != 'ket':; raise Exception(""Initial state must be a state vector.""); config.options = options; # set num_cpus to the value given in qutip.settings; # if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full(); else:; config.psi0 = psi0.full(); config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape; # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; raise Exception(""ntraj as list argument is not supported.""); else:; config.ntraj = ntraj; # ntraj_list = [ntraj]; # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. if not options.rhs_reuse:; config.soft_reset(); # no time dependence; config.tflag = 0; # check for collapse operators; if len(c_ops) > 0:; config.cflag = 1; else:; config.cflag = 0; # Configure data; _mc_data_config(H, psi0, [], c_ops, [], [], e_ops, options, config). # Load Monte Carlo class; mc = _MC_class(); # Set solver type; if (options.method == 'adams'):; mc.mf = 10; elif (options.method == 'bdf'):; mc.mf = 22; else:; if debug:; print('Unrecognized method for ode solver, using ""adams"".'); mc.mf = 10; # store ket and density matrix dims and shape for convenience; mc.psi0_dims = psi0.dims; mc.psi0_shape = psi0.shape; mc.dm_dims = (psi0 * psi0.dag()).dims; mc.dm_shape = (psi0 * psi0.dag()).shape; # use sparse density matrices during computation?; mc.sparse_dms = sparse_dms; # run in serial?; mc.serial_run = serial or (ntraj == 1); # are we doing a partial trace for returned states?; mc.ptrace_sel = ptrace_sel; if (ptrace_sel != []):; if debug:; print(""ptrace_sel set to "" + str(ptrace_sel)); print(""We are using dense density matrices du",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:10752,Integrability,integrat,integrate,10752,"procs):; p = Process(target=self.evolve_serial,; args=((resq, self.ntrajs[i], i, self.seed * (i + 1)),)); p.start(); processes.append(p); cnt = 0. while True:; try:; sols.append(resq.get()); resq.task_done(); cnt += 1; if (cnt >= self.nprocs):; break; except KeyboardInterrupt:; break; except:; pass. resq.join(); for proc in processes:; try:; proc.join(); except KeyboardInterrupt:; if debug:; print(""Cancel thread on keyboard interrupt""); proc.terminate(); proc.join(); resq.close(); return sols. def serial(self):. if debug:; print(inspect.stack()[0][3]). self.nprocs = 1; self.ntrajs = [self.ntraj]; if debug:; print(""Running in serial.""); print(""Number of trajectories: "" + str(self.ntraj)); sol = self.evolve_serial((0, self.ntraj, 0, self.seed)); return [sol]. def run(self):. if debug:; print(inspect.stack()[0][3]). from numpy.random import random_integers; if (config.c_num == 0):; # force one trajectory if no collapse operators; config.ntraj = 1; self.ntraj = 1; # Set unravel_type to 1 to integrate without collapses; self.unravel_type = 1; if (config.e_num == 0):; # If we are returning states, and there are no; # collapse operators, set average_states to False to return; # ket vectors instead of density matrices; config.options.average_states = False; # generate a random seed, useful if e.g. running with MPI; self.seed = random_integers(1e8); if (self.serial_run):; # run in serial; sols = self.serial(); else:; # run in paralell; sols = self.parallel(); # gather data; self.sol = _gather(sols). def evolve_serial(self, args):. if debug:; print(inspect.stack()[0][3] + "":"" + str(os.getpid())). # run ntraj trajectories for one process via fortran; # get args; queue, ntraj, instanceno, rngseed = args; # initialize the problem in fortran; _init_tlist(); _init_psi0(); if (self.ptrace_sel != []):; _init_ptrace_stuff(self.ptrace_sel); _init_hamilt(); if (config.c_num != 0):; _init_c_ops(); if (config.e_num != 0):; _init_e_ops(); # set options; qtf90.qutraj_run.n_c_ops = config.c",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:3587,Modifiability,config,config,3587,", INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; #; # Original Code by Arne Grimsmo (2012): github.com/arnelg/qutipf90mc; ###############################################################################. import numpy as np. from qutip.fortran import qutraj_run as qtf90; from qutip.qobj import Qobj; from qutip.mcsolve import _mc_data_config; from qutip.solver import Options, Result, config; from qutip.settings import debug; import qutip.settings. if debug:; import inspect; import os. # Working precision; wpr = np.dtype(np.float64); wpc = np.dtype(np.complex128). [docs]def mcsolve_f90(H, psi0, tlist, c_ops, e_ops, ntraj=None,; options=Options(), sparse_dms=True, serial=False,; ptrace_sel=[], calc_entropy=False):; """"""; Monte-Carlo wave function solver with fortran 90 backend.; Usage is identical to qutip.mcsolve, for problems without explicit; time-dependence, and with some optional input:. Parameters; ----------; H : qobj; System Hamiltonian.; psi0 : qobj; Initial state vector; tlist : array_like; Times at which results are recorded.; ntraj : int; Number of trajectories to run.; c_ops : array_like; ``list`` or ``array`` of collapse operators.; e_ops : array_like; ``list`` or ``array`` of operators for calculating expectation values.; options : Options; Instance of solver options.; sparse_dms : boolean; If averaged density matrices are returned, they will be s",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:5666,Modifiability,config,config,5666,"True (default), and dense matrices otherwise. Dense; matrices might be preferable for smaller systems.; serial : boolean; If True (default is False) the solver will not make use of the; multiprocessing module, and simply run in serial.; ptrace_sel: list; This optional argument specifies a list of components to keep when; returning a partially traced density matrix. This can be convenient for; large systems where memory becomes a problem, but you are only; interested in parts of the density matrix.; calc_entropy : boolean; If ptrace_sel is specified, calc_entropy=True will have the solver; return the averaged entropy over trajectories in results.entropy. This; can be interpreted as a measure of entanglement. See Phys. Rev. Lett.; 93, 120408 (2004), Phys. Rev. A 86, 022310 (2012). Returns; -------; results : Result; Object storing all results from simulation. """"""; if ntraj is None:; ntraj = options.ntraj. if psi0.type != 'ket':; raise Exception(""Initial state must be a state vector.""); config.options = options; # set num_cpus to the value given in qutip.settings; # if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full(); else:; config.psi0 = psi0.full(); config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape; # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; raise Exception(""ntraj as list argument is not supported.""); else:; config.ntraj = ntraj; # ntraj_list = [ntraj]; # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. if not options.rhs_reuse:; config.soft_reset(); # no time dependence; config.tflag = 0; # check for collapse operators; if len(c_ops) > 0:; config.cflag = 1; else:; config.cflag = 0; # Configure data; _mc_data_config(H, psi0, [], c_ops, [], [], e_ops, options, config). # Load Monte Carlo class; mc = _MC_class(); # Set sol",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:5774,Modifiability,config,config,5774,"er systems.; serial : boolean; If True (default is False) the solver will not make use of the; multiprocessing module, and simply run in serial.; ptrace_sel: list; This optional argument specifies a list of components to keep when; returning a partially traced density matrix. This can be convenient for; large systems where memory becomes a problem, but you are only; interested in parts of the density matrix.; calc_entropy : boolean; If ptrace_sel is specified, calc_entropy=True will have the solver; return the averaged entropy over trajectories in results.entropy. This; can be interpreted as a measure of entanglement. See Phys. Rev. Lett.; 93, 120408 (2004), Phys. Rev. A 86, 022310 (2012). Returns; -------; results : Result; Object storing all results from simulation. """"""; if ntraj is None:; ntraj = options.ntraj. if psi0.type != 'ket':; raise Exception(""Initial state must be a state vector.""); config.options = options; # set num_cpus to the value given in qutip.settings; # if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full(); else:; config.psi0 = psi0.full(); config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape; # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; raise Exception(""ntraj as list argument is not supported.""); else:; config.ntraj = ntraj; # ntraj_list = [ntraj]; # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. if not options.rhs_reuse:; config.soft_reset(); # no time dependence; config.tflag = 0; # check for collapse operators; if len(c_ops) > 0:; config.cflag = 1; else:; config.cflag = 0; # Configure data; _mc_data_config(H, psi0, [], c_ops, [], [], e_ops, options, config). # Load Monte Carlo class; mc = _MC_class(); # Set solver type; if (options.method == 'adams'):; mc.mf = 10; elif (options.method == 'bdf'):; mc",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:5800,Modifiability,config,config,5800,"default is False) the solver will not make use of the; multiprocessing module, and simply run in serial.; ptrace_sel: list; This optional argument specifies a list of components to keep when; returning a partially traced density matrix. This can be convenient for; large systems where memory becomes a problem, but you are only; interested in parts of the density matrix.; calc_entropy : boolean; If ptrace_sel is specified, calc_entropy=True will have the solver; return the averaged entropy over trajectories in results.entropy. This; can be interpreted as a measure of entanglement. See Phys. Rev. Lett.; 93, 120408 (2004), Phys. Rev. A 86, 022310 (2012). Returns; -------; results : Result; Object storing all results from simulation. """"""; if ntraj is None:; ntraj = options.ntraj. if psi0.type != 'ket':; raise Exception(""Initial state must be a state vector.""); config.options = options; # set num_cpus to the value given in qutip.settings; # if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full(); else:; config.psi0 = psi0.full(); config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape; # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; raise Exception(""ntraj as list argument is not supported.""); else:; config.ntraj = ntraj; # ntraj_list = [ntraj]; # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. if not options.rhs_reuse:; config.soft_reset(); # no time dependence; config.tflag = 0; # check for collapse operators; if len(c_ops) > 0:; config.cflag = 1; else:; config.cflag = 0; # Configure data; _mc_data_config(H, psi0, [], c_ops, [], [], e_ops, options, config). # Load Monte Carlo class; mc = _MC_class(); # Set solver type; if (options.method == 'adams'):; mc.mf = 10; elif (options.method == 'bdf'):; mc.mf = 22; else:; if debug:; print('Unrec",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:5895,Modifiability,config,config,5895,"serial.; ptrace_sel: list; This optional argument specifies a list of components to keep when; returning a partially traced density matrix. This can be convenient for; large systems where memory becomes a problem, but you are only; interested in parts of the density matrix.; calc_entropy : boolean; If ptrace_sel is specified, calc_entropy=True will have the solver; return the averaged entropy over trajectories in results.entropy. This; can be interpreted as a measure of entanglement. See Phys. Rev. Lett.; 93, 120408 (2004), Phys. Rev. A 86, 022310 (2012). Returns; -------; results : Result; Object storing all results from simulation. """"""; if ntraj is None:; ntraj = options.ntraj. if psi0.type != 'ket':; raise Exception(""Initial state must be a state vector.""); config.options = options; # set num_cpus to the value given in qutip.settings; # if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full(); else:; config.psi0 = psi0.full(); config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape; # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; raise Exception(""ntraj as list argument is not supported.""); else:; config.ntraj = ntraj; # ntraj_list = [ntraj]; # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. if not options.rhs_reuse:; config.soft_reset(); # no time dependence; config.tflag = 0; # check for collapse operators; if len(c_ops) > 0:; config.cflag = 1; else:; config.cflag = 0; # Configure data; _mc_data_config(H, psi0, [], c_ops, [], [], e_ops, options, config). # Load Monte Carlo class; mc = _MC_class(); # Set solver type; if (options.method == 'adams'):; mc.mf = 10; elif (options.method == 'bdf'):; mc.mf = 22; else:; if debug:; print('Unrecognized method for ode solver, using ""adams"".'); mc.mf = 10; # store ket and density matrix dims ",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:5950,Modifiability,config,config,5950,"pecifies a list of components to keep when; returning a partially traced density matrix. This can be convenient for; large systems where memory becomes a problem, but you are only; interested in parts of the density matrix.; calc_entropy : boolean; If ptrace_sel is specified, calc_entropy=True will have the solver; return the averaged entropy over trajectories in results.entropy. This; can be interpreted as a measure of entanglement. See Phys. Rev. Lett.; 93, 120408 (2004), Phys. Rev. A 86, 022310 (2012). Returns; -------; results : Result; Object storing all results from simulation. """"""; if ntraj is None:; ntraj = options.ntraj. if psi0.type != 'ket':; raise Exception(""Initial state must be a state vector.""); config.options = options; # set num_cpus to the value given in qutip.settings; # if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full(); else:; config.psi0 = psi0.full(); config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape; # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; raise Exception(""ntraj as list argument is not supported.""); else:; config.ntraj = ntraj; # ntraj_list = [ntraj]; # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. if not options.rhs_reuse:; config.soft_reset(); # no time dependence; config.tflag = 0; # check for collapse operators; if len(c_ops) > 0:; config.cflag = 1; else:; config.cflag = 0; # Configure data; _mc_data_config(H, psi0, [], c_ops, [], [], e_ops, options, config). # Load Monte Carlo class; mc = _MC_class(); # Set solver type; if (options.method == 'adams'):; mc.mf = 10; elif (options.method == 'bdf'):; mc.mf = 22; else:; if debug:; print('Unrecognized method for ode solver, using ""adams"".'); mc.mf = 10; # store ket and density matrix dims and shape for convenience; mc.psi0_dims = psi0.dims",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:5977,Modifiability,config,config,5977,"to keep when; returning a partially traced density matrix. This can be convenient for; large systems where memory becomes a problem, but you are only; interested in parts of the density matrix.; calc_entropy : boolean; If ptrace_sel is specified, calc_entropy=True will have the solver; return the averaged entropy over trajectories in results.entropy. This; can be interpreted as a measure of entanglement. See Phys. Rev. Lett.; 93, 120408 (2004), Phys. Rev. A 86, 022310 (2012). Returns; -------; results : Result; Object storing all results from simulation. """"""; if ntraj is None:; ntraj = options.ntraj. if psi0.type != 'ket':; raise Exception(""Initial state must be a state vector.""); config.options = options; # set num_cpus to the value given in qutip.settings; # if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full(); else:; config.psi0 = psi0.full(); config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape; # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; raise Exception(""ntraj as list argument is not supported.""); else:; config.ntraj = ntraj; # ntraj_list = [ntraj]; # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. if not options.rhs_reuse:; config.soft_reset(); # no time dependence; config.tflag = 0; # check for collapse operators; if len(c_ops) > 0:; config.cflag = 1; else:; config.cflag = 0; # Configure data; _mc_data_config(H, psi0, [], c_ops, [], [], e_ops, options, config). # Load Monte Carlo class; mc = _MC_class(); # Set solver type; if (options.method == 'adams'):; mc.mf = 10; elif (options.method == 'bdf'):; mc.mf = 22; else:; if debug:; print('Unrecognized method for ode solver, using ""adams"".'); mc.mf = 10; # store ket and density matrix dims and shape for convenience; mc.psi0_dims = psi0.dims; mc.psi0_shape = psi0.shape; m",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:6007,Modifiability,config,config,6007,"ally traced density matrix. This can be convenient for; large systems where memory becomes a problem, but you are only; interested in parts of the density matrix.; calc_entropy : boolean; If ptrace_sel is specified, calc_entropy=True will have the solver; return the averaged entropy over trajectories in results.entropy. This; can be interpreted as a measure of entanglement. See Phys. Rev. Lett.; 93, 120408 (2004), Phys. Rev. A 86, 022310 (2012). Returns; -------; results : Result; Object storing all results from simulation. """"""; if ntraj is None:; ntraj = options.ntraj. if psi0.type != 'ket':; raise Exception(""Initial state must be a state vector.""); config.options = options; # set num_cpus to the value given in qutip.settings; # if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full(); else:; config.psi0 = psi0.full(); config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape; # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; raise Exception(""ntraj as list argument is not supported.""); else:; config.ntraj = ntraj; # ntraj_list = [ntraj]; # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. if not options.rhs_reuse:; config.soft_reset(); # no time dependence; config.tflag = 0; # check for collapse operators; if len(c_ops) > 0:; config.cflag = 1; else:; config.cflag = 0; # Configure data; _mc_data_config(H, psi0, [], c_ops, [], [], e_ops, options, config). # Load Monte Carlo class; mc = _MC_class(); # Set solver type; if (options.method == 'adams'):; mc.mf = 10; elif (options.method == 'bdf'):; mc.mf = 22; else:; if debug:; print('Unrecognized method for ode solver, using ""adams"".'); mc.mf = 10; # store ket and density matrix dims and shape for convenience; mc.psi0_dims = psi0.dims; mc.psi0_shape = psi0.shape; mc.dm_dims = (psi0 * psi0.dag())",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:6060,Modifiability,config,config,6060,"nvenient for; large systems where memory becomes a problem, but you are only; interested in parts of the density matrix.; calc_entropy : boolean; If ptrace_sel is specified, calc_entropy=True will have the solver; return the averaged entropy over trajectories in results.entropy. This; can be interpreted as a measure of entanglement. See Phys. Rev. Lett.; 93, 120408 (2004), Phys. Rev. A 86, 022310 (2012). Returns; -------; results : Result; Object storing all results from simulation. """"""; if ntraj is None:; ntraj = options.ntraj. if psi0.type != 'ket':; raise Exception(""Initial state must be a state vector.""); config.options = options; # set num_cpus to the value given in qutip.settings; # if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full(); else:; config.psi0 = psi0.full(); config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape; # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; raise Exception(""ntraj as list argument is not supported.""); else:; config.ntraj = ntraj; # ntraj_list = [ntraj]; # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. if not options.rhs_reuse:; config.soft_reset(); # no time dependence; config.tflag = 0; # check for collapse operators; if len(c_ops) > 0:; config.cflag = 1; else:; config.cflag = 0; # Configure data; _mc_data_config(H, psi0, [], c_ops, [], [], e_ops, options, config). # Load Monte Carlo class; mc = _MC_class(); # Set solver type; if (options.method == 'adams'):; mc.mf = 10; elif (options.method == 'bdf'):; mc.mf = 22; else:; if debug:; print('Unrecognized method for ode solver, using ""adams"".'); mc.mf = 10; # store ket and density matrix dims and shape for convenience; mc.psi0_dims = psi0.dims; mc.psi0_shape = psi0.shape; mc.dm_dims = (psi0 * psi0.dag()).dims; mc.dm_shape = (psi0 * psi0.dag()).s",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:6193,Modifiability,config,config,6193,"an; If ptrace_sel is specified, calc_entropy=True will have the solver; return the averaged entropy over trajectories in results.entropy. This; can be interpreted as a measure of entanglement. See Phys. Rev. Lett.; 93, 120408 (2004), Phys. Rev. A 86, 022310 (2012). Returns; -------; results : Result; Object storing all results from simulation. """"""; if ntraj is None:; ntraj = options.ntraj. if psi0.type != 'ket':; raise Exception(""Initial state must be a state vector.""); config.options = options; # set num_cpus to the value given in qutip.settings; # if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full(); else:; config.psi0 = psi0.full(); config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape; # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; raise Exception(""ntraj as list argument is not supported.""); else:; config.ntraj = ntraj; # ntraj_list = [ntraj]; # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. if not options.rhs_reuse:; config.soft_reset(); # no time dependence; config.tflag = 0; # check for collapse operators; if len(c_ops) > 0:; config.cflag = 1; else:; config.cflag = 0; # Configure data; _mc_data_config(H, psi0, [], c_ops, [], [], e_ops, options, config). # Load Monte Carlo class; mc = _MC_class(); # Set solver type; if (options.method == 'adams'):; mc.mf = 10; elif (options.method == 'bdf'):; mc.mf = 22; else:; if debug:; print('Unrecognized method for ode solver, using ""adams"".'); mc.mf = 10; # store ket and density matrix dims and shape for convenience; mc.psi0_dims = psi0.dims; mc.psi0_shape = psi0.shape; mc.dm_dims = (psi0 * psi0.dag()).dims; mc.dm_shape = (psi0 * psi0.dag()).shape; # use sparse density matrices during computation?; mc.sparse_dms = sparse_dms; # run in serial?; mc.serial_run = serial or (ntraj == 1)",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:6269,Modifiability,config,config,6269,"ue will have the solver; return the averaged entropy over trajectories in results.entropy. This; can be interpreted as a measure of entanglement. See Phys. Rev. Lett.; 93, 120408 (2004), Phys. Rev. A 86, 022310 (2012). Returns; -------; results : Result; Object storing all results from simulation. """"""; if ntraj is None:; ntraj = options.ntraj. if psi0.type != 'ket':; raise Exception(""Initial state must be a state vector.""); config.options = options; # set num_cpus to the value given in qutip.settings; # if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full(); else:; config.psi0 = psi0.full(); config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape; # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; raise Exception(""ntraj as list argument is not supported.""); else:; config.ntraj = ntraj; # ntraj_list = [ntraj]; # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. if not options.rhs_reuse:; config.soft_reset(); # no time dependence; config.tflag = 0; # check for collapse operators; if len(c_ops) > 0:; config.cflag = 1; else:; config.cflag = 0; # Configure data; _mc_data_config(H, psi0, [], c_ops, [], [], e_ops, options, config). # Load Monte Carlo class; mc = _MC_class(); # Set solver type; if (options.method == 'adams'):; mc.mf = 10; elif (options.method == 'bdf'):; mc.mf = 22; else:; if debug:; print('Unrecognized method for ode solver, using ""adams"".'); mc.mf = 10; # store ket and density matrix dims and shape for convenience; mc.psi0_dims = psi0.dims; mc.psi0_shape = psi0.shape; mc.dm_dims = (psi0 * psi0.dag()).dims; mc.dm_shape = (psi0 * psi0.dag()).shape; # use sparse density matrices during computation?; mc.sparse_dms = sparse_dms; # run in serial?; mc.serial_run = serial or (ntraj == 1); # are we doing a partial trace for returned s",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:6305,Modifiability,config,config,6305,"ories in results.entropy. This; can be interpreted as a measure of entanglement. See Phys. Rev. Lett.; 93, 120408 (2004), Phys. Rev. A 86, 022310 (2012). Returns; -------; results : Result; Object storing all results from simulation. """"""; if ntraj is None:; ntraj = options.ntraj. if psi0.type != 'ket':; raise Exception(""Initial state must be a state vector.""); config.options = options; # set num_cpus to the value given in qutip.settings; # if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full(); else:; config.psi0 = psi0.full(); config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape; # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; raise Exception(""ntraj as list argument is not supported.""); else:; config.ntraj = ntraj; # ntraj_list = [ntraj]; # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. if not options.rhs_reuse:; config.soft_reset(); # no time dependence; config.tflag = 0; # check for collapse operators; if len(c_ops) > 0:; config.cflag = 1; else:; config.cflag = 0; # Configure data; _mc_data_config(H, psi0, [], c_ops, [], [], e_ops, options, config). # Load Monte Carlo class; mc = _MC_class(); # Set solver type; if (options.method == 'adams'):; mc.mf = 10; elif (options.method == 'bdf'):; mc.mf = 22; else:; if debug:; print('Unrecognized method for ode solver, using ""adams"".'); mc.mf = 10; # store ket and density matrix dims and shape for convenience; mc.psi0_dims = psi0.dims; mc.psi0_shape = psi0.shape; mc.dm_dims = (psi0 * psi0.dag()).dims; mc.dm_shape = (psi0 * psi0.dag()).shape; # use sparse density matrices during computation?; mc.sparse_dms = sparse_dms; # run in serial?; mc.serial_run = serial or (ntraj == 1); # are we doing a partial trace for returned states?; mc.ptrace_sel = ptrace_sel; if (ptrace_sel != []):; if deb",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:6372,Modifiability,config,config,6372," entanglement. See Phys. Rev. Lett.; 93, 120408 (2004), Phys. Rev. A 86, 022310 (2012). Returns; -------; results : Result; Object storing all results from simulation. """"""; if ntraj is None:; ntraj = options.ntraj. if psi0.type != 'ket':; raise Exception(""Initial state must be a state vector.""); config.options = options; # set num_cpus to the value given in qutip.settings; # if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full(); else:; config.psi0 = psi0.full(); config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape; # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; raise Exception(""ntraj as list argument is not supported.""); else:; config.ntraj = ntraj; # ntraj_list = [ntraj]; # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. if not options.rhs_reuse:; config.soft_reset(); # no time dependence; config.tflag = 0; # check for collapse operators; if len(c_ops) > 0:; config.cflag = 1; else:; config.cflag = 0; # Configure data; _mc_data_config(H, psi0, [], c_ops, [], [], e_ops, options, config). # Load Monte Carlo class; mc = _MC_class(); # Set solver type; if (options.method == 'adams'):; mc.mf = 10; elif (options.method == 'bdf'):; mc.mf = 22; else:; if debug:; print('Unrecognized method for ode solver, using ""adams"".'); mc.mf = 10; # store ket and density matrix dims and shape for convenience; mc.psi0_dims = psi0.dims; mc.psi0_shape = psi0.shape; mc.dm_dims = (psi0 * psi0.dag()).dims; mc.dm_shape = (psi0 * psi0.dag()).shape; # use sparse density matrices during computation?; mc.sparse_dms = sparse_dms; # run in serial?; mc.serial_run = serial or (ntraj == 1); # are we doing a partial trace for returned states?; mc.ptrace_sel = ptrace_sel; if (ptrace_sel != []):; if debug:; print(""ptrace_sel set to "" + str(ptrace_sel)); print(""We are ",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:6415,Modifiability,config,config,6415,"ett.; 93, 120408 (2004), Phys. Rev. A 86, 022310 (2012). Returns; -------; results : Result; Object storing all results from simulation. """"""; if ntraj is None:; ntraj = options.ntraj. if psi0.type != 'ket':; raise Exception(""Initial state must be a state vector.""); config.options = options; # set num_cpus to the value given in qutip.settings; # if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full(); else:; config.psi0 = psi0.full(); config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape; # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; raise Exception(""ntraj as list argument is not supported.""); else:; config.ntraj = ntraj; # ntraj_list = [ntraj]; # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. if not options.rhs_reuse:; config.soft_reset(); # no time dependence; config.tflag = 0; # check for collapse operators; if len(c_ops) > 0:; config.cflag = 1; else:; config.cflag = 0; # Configure data; _mc_data_config(H, psi0, [], c_ops, [], [], e_ops, options, config). # Load Monte Carlo class; mc = _MC_class(); # Set solver type; if (options.method == 'adams'):; mc.mf = 10; elif (options.method == 'bdf'):; mc.mf = 22; else:; if debug:; print('Unrecognized method for ode solver, using ""adams"".'); mc.mf = 10; # store ket and density matrix dims and shape for convenience; mc.psi0_dims = psi0.dims; mc.psi0_shape = psi0.shape; mc.dm_dims = (psi0 * psi0.dag()).dims; mc.dm_shape = (psi0 * psi0.dag()).shape; # use sparse density matrices during computation?; mc.sparse_dms = sparse_dms; # run in serial?; mc.serial_run = serial or (ntraj == 1); # are we doing a partial trace for returned states?; mc.ptrace_sel = ptrace_sel; if (ptrace_sel != []):; if debug:; print(""ptrace_sel set to "" + str(ptrace_sel)); print(""We are using dense density matrices du",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:6485,Modifiability,config,config,6485,"Returns; -------; results : Result; Object storing all results from simulation. """"""; if ntraj is None:; ntraj = options.ntraj. if psi0.type != 'ket':; raise Exception(""Initial state must be a state vector.""); config.options = options; # set num_cpus to the value given in qutip.settings; # if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full(); else:; config.psi0 = psi0.full(); config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape; # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; raise Exception(""ntraj as list argument is not supported.""); else:; config.ntraj = ntraj; # ntraj_list = [ntraj]; # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. if not options.rhs_reuse:; config.soft_reset(); # no time dependence; config.tflag = 0; # check for collapse operators; if len(c_ops) > 0:; config.cflag = 1; else:; config.cflag = 0; # Configure data; _mc_data_config(H, psi0, [], c_ops, [], [], e_ops, options, config). # Load Monte Carlo class; mc = _MC_class(); # Set solver type; if (options.method == 'adams'):; mc.mf = 10; elif (options.method == 'bdf'):; mc.mf = 22; else:; if debug:; print('Unrecognized method for ode solver, using ""adams"".'); mc.mf = 10; # store ket and density matrix dims and shape for convenience; mc.psi0_dims = psi0.dims; mc.psi0_shape = psi0.shape; mc.dm_dims = (psi0 * psi0.dag()).dims; mc.dm_shape = (psi0 * psi0.dag()).shape; # use sparse density matrices during computation?; mc.sparse_dms = sparse_dms; # run in serial?; mc.serial_run = serial or (ntraj == 1); # are we doing a partial trace for returned states?; mc.ptrace_sel = ptrace_sel; if (ptrace_sel != []):; if debug:; print(""ptrace_sel set to "" + str(ptrace_sel)); print(""We are using dense density matrices during computation "" +; ""when performing partial trace. Se",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:6510,Modifiability,config,config,6510,"ing all results from simulation. """"""; if ntraj is None:; ntraj = options.ntraj. if psi0.type != 'ket':; raise Exception(""Initial state must be a state vector.""); config.options = options; # set num_cpus to the value given in qutip.settings; # if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full(); else:; config.psi0 = psi0.full(); config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape; # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; raise Exception(""ntraj as list argument is not supported.""); else:; config.ntraj = ntraj; # ntraj_list = [ntraj]; # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. if not options.rhs_reuse:; config.soft_reset(); # no time dependence; config.tflag = 0; # check for collapse operators; if len(c_ops) > 0:; config.cflag = 1; else:; config.cflag = 0; # Configure data; _mc_data_config(H, psi0, [], c_ops, [], [], e_ops, options, config). # Load Monte Carlo class; mc = _MC_class(); # Set solver type; if (options.method == 'adams'):; mc.mf = 10; elif (options.method == 'bdf'):; mc.mf = 22; else:; if debug:; print('Unrecognized method for ode solver, using ""adams"".'); mc.mf = 10; # store ket and density matrix dims and shape for convenience; mc.psi0_dims = psi0.dims; mc.psi0_shape = psi0.shape; mc.dm_dims = (psi0 * psi0.dag()).dims; mc.dm_shape = (psi0 * psi0.dag()).shape; # use sparse density matrices during computation?; mc.sparse_dms = sparse_dms; # run in serial?; mc.serial_run = serial or (ntraj == 1); # are we doing a partial trace for returned states?; mc.ptrace_sel = ptrace_sel; if (ptrace_sel != []):; if debug:; print(""ptrace_sel set to "" + str(ptrace_sel)); print(""We are using dense density matrices during computation "" +; ""when performing partial trace. Setting sparse_dms = False""); print(""This feature ",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:6606,Modifiability,config,config,6606,"j = options.ntraj. if psi0.type != 'ket':; raise Exception(""Initial state must be a state vector.""); config.options = options; # set num_cpus to the value given in qutip.settings; # if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full(); else:; config.psi0 = psi0.full(); config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape; # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; raise Exception(""ntraj as list argument is not supported.""); else:; config.ntraj = ntraj; # ntraj_list = [ntraj]; # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. if not options.rhs_reuse:; config.soft_reset(); # no time dependence; config.tflag = 0; # check for collapse operators; if len(c_ops) > 0:; config.cflag = 1; else:; config.cflag = 0; # Configure data; _mc_data_config(H, psi0, [], c_ops, [], [], e_ops, options, config). # Load Monte Carlo class; mc = _MC_class(); # Set solver type; if (options.method == 'adams'):; mc.mf = 10; elif (options.method == 'bdf'):; mc.mf = 22; else:; if debug:; print('Unrecognized method for ode solver, using ""adams"".'); mc.mf = 10; # store ket and density matrix dims and shape for convenience; mc.psi0_dims = psi0.dims; mc.psi0_shape = psi0.shape; mc.dm_dims = (psi0 * psi0.dag()).dims; mc.dm_shape = (psi0 * psi0.dag()).shape; # use sparse density matrices during computation?; mc.sparse_dms = sparse_dms; # run in serial?; mc.serial_run = serial or (ntraj == 1); # are we doing a partial trace for returned states?; mc.ptrace_sel = ptrace_sel; if (ptrace_sel != []):; if debug:; print(""ptrace_sel set to "" + str(ptrace_sel)); print(""We are using dense density matrices during computation "" +; ""when performing partial trace. Setting sparse_dms = False""); print(""This feature is experimental.""); mc.sparse_dms = False; mc.dm_dims = psi0.",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:8321,Modifiability,config,config,8321,"ce_sel set to "" + str(ptrace_sel)); print(""We are using dense density matrices during computation "" +; ""when performing partial trace. Setting sparse_dms = False""); print(""This feature is experimental.""); mc.sparse_dms = False; mc.dm_dims = psi0.ptrace(ptrace_sel).dims; mc.dm_shape = psi0.ptrace(ptrace_sel).shape; if (calc_entropy):; if (ptrace_sel == []):; if debug:; print(""calc_entropy = True, but ptrace_sel = []. Please set "" +; ""a list of components to keep when calculating average"" +; "" entropy of reduced density matrix in ptrace_sel. "" +; ""Setting calc_entropy = False.""); calc_entropy = False; mc.calc_entropy = calc_entropy. # construct output Result object; output = Result(). # Run; mc.run(); output.states = mc.sol.states; output.expect = mc.sol.expect; output.col_times = mc.sol.col_times; output.col_which = mc.sol.col_which; if (hasattr(mc.sol, 'entropy')):; output.entropy = mc.sol.entropy. output.solver = 'Fortran 90 Monte Carlo solver'; # simulation parameters; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj. return output. class _MC_class():; def __init__(self):; self.cpus = config.options.num_cpus; self.nprocs = self.cpus; self.sol = Result(); self.mf = 10; # If returning density matrices, return as sparse or dense?; self.sparse_dms = True; # Run in serial?; self.serial_run = False; self.ntraj = config.ntraj; self.ntrajs = []; self.seed = None; self.psi0_dims = None; self.psi0_shape = None; self.dm_dims = None; self.dm_shape = None; self.unravel_type = 2; self.ptrace_sel = []; self.calc_entropy = False. def parallel(self):; from multiprocessing import Process, Queue, JoinableQueue. if debug:; print(inspect.stack()[0][3]). self.ntrajs = []; for i in range(self.cpus):; self.ntrajs.append(min(int(np.floor(float(self.ntraj); / self.cpus)),; self.ntraj - sum(self.ntrajs))); cnt = sum(self.ntrajs); while cnt < self.ntraj:; for i in range(self.cpus):; self.ntrajs[i] += 1; cnt += 1; if",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:8355,Modifiability,config,config,8355,")); print(""We are using dense density matrices during computation "" +; ""when performing partial trace. Setting sparse_dms = False""); print(""This feature is experimental.""); mc.sparse_dms = False; mc.dm_dims = psi0.ptrace(ptrace_sel).dims; mc.dm_shape = psi0.ptrace(ptrace_sel).shape; if (calc_entropy):; if (ptrace_sel == []):; if debug:; print(""calc_entropy = True, but ptrace_sel = []. Please set "" +; ""a list of components to keep when calculating average"" +; "" entropy of reduced density matrix in ptrace_sel. "" +; ""Setting calc_entropy = False.""); calc_entropy = False; mc.calc_entropy = calc_entropy. # construct output Result object; output = Result(). # Run; mc.run(); output.states = mc.sol.states; output.expect = mc.sol.expect; output.col_times = mc.sol.col_times; output.col_which = mc.sol.col_which; if (hasattr(mc.sol, 'entropy')):; output.entropy = mc.sol.entropy. output.solver = 'Fortran 90 Monte Carlo solver'; # simulation parameters; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj. return output. class _MC_class():; def __init__(self):; self.cpus = config.options.num_cpus; self.nprocs = self.cpus; self.sol = Result(); self.mf = 10; # If returning density matrices, return as sparse or dense?; self.sparse_dms = True; # Run in serial?; self.serial_run = False; self.ntraj = config.ntraj; self.ntrajs = []; self.seed = None; self.psi0_dims = None; self.psi0_shape = None; self.dm_dims = None; self.dm_shape = None; self.unravel_type = 2; self.ptrace_sel = []; self.calc_entropy = False. def parallel(self):; from multiprocessing import Process, Queue, JoinableQueue. if debug:; print(inspect.stack()[0][3]). self.ntrajs = []; for i in range(self.cpus):; self.ntrajs.append(min(int(np.floor(float(self.ntraj); / self.cpus)),; self.ntraj - sum(self.ntrajs))); cnt = sum(self.ntrajs); while cnt < self.ntraj:; for i in range(self.cpus):; self.ntrajs[i] += 1; cnt += 1; if (cnt >= self.ntraj):; break; s",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:8391,Modifiability,config,config,8391,"ty matrices during computation "" +; ""when performing partial trace. Setting sparse_dms = False""); print(""This feature is experimental.""); mc.sparse_dms = False; mc.dm_dims = psi0.ptrace(ptrace_sel).dims; mc.dm_shape = psi0.ptrace(ptrace_sel).shape; if (calc_entropy):; if (ptrace_sel == []):; if debug:; print(""calc_entropy = True, but ptrace_sel = []. Please set "" +; ""a list of components to keep when calculating average"" +; "" entropy of reduced density matrix in ptrace_sel. "" +; ""Setting calc_entropy = False.""); calc_entropy = False; mc.calc_entropy = calc_entropy. # construct output Result object; output = Result(). # Run; mc.run(); output.states = mc.sol.states; output.expect = mc.sol.expect; output.col_times = mc.sol.col_times; output.col_which = mc.sol.col_which; if (hasattr(mc.sol, 'entropy')):; output.entropy = mc.sol.entropy. output.solver = 'Fortran 90 Monte Carlo solver'; # simulation parameters; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj. return output. class _MC_class():; def __init__(self):; self.cpus = config.options.num_cpus; self.nprocs = self.cpus; self.sol = Result(); self.mf = 10; # If returning density matrices, return as sparse or dense?; self.sparse_dms = True; # Run in serial?; self.serial_run = False; self.ntraj = config.ntraj; self.ntrajs = []; self.seed = None; self.psi0_dims = None; self.psi0_shape = None; self.dm_dims = None; self.dm_shape = None; self.unravel_type = 2; self.ptrace_sel = []; self.calc_entropy = False. def parallel(self):; from multiprocessing import Process, Queue, JoinableQueue. if debug:; print(inspect.stack()[0][3]). self.ntrajs = []; for i in range(self.cpus):; self.ntrajs.append(min(int(np.floor(float(self.ntraj); / self.cpus)),; self.ntraj - sum(self.ntrajs))); cnt = sum(self.ntrajs); while cnt < self.ntraj:; for i in range(self.cpus):; self.ntrajs[i] += 1; cnt += 1; if (cnt >= self.ntraj):; break; self.ntrajs = np.array(self.ntrajs);",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:8420,Modifiability,config,config,8420," +; ""when performing partial trace. Setting sparse_dms = False""); print(""This feature is experimental.""); mc.sparse_dms = False; mc.dm_dims = psi0.ptrace(ptrace_sel).dims; mc.dm_shape = psi0.ptrace(ptrace_sel).shape; if (calc_entropy):; if (ptrace_sel == []):; if debug:; print(""calc_entropy = True, but ptrace_sel = []. Please set "" +; ""a list of components to keep when calculating average"" +; "" entropy of reduced density matrix in ptrace_sel. "" +; ""Setting calc_entropy = False.""); calc_entropy = False; mc.calc_entropy = calc_entropy. # construct output Result object; output = Result(). # Run; mc.run(); output.states = mc.sol.states; output.expect = mc.sol.expect; output.col_times = mc.sol.col_times; output.col_which = mc.sol.col_which; if (hasattr(mc.sol, 'entropy')):; output.entropy = mc.sol.entropy. output.solver = 'Fortran 90 Monte Carlo solver'; # simulation parameters; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj. return output. class _MC_class():; def __init__(self):; self.cpus = config.options.num_cpus; self.nprocs = self.cpus; self.sol = Result(); self.mf = 10; # If returning density matrices, return as sparse or dense?; self.sparse_dms = True; # Run in serial?; self.serial_run = False; self.ntraj = config.ntraj; self.ntrajs = []; self.seed = None; self.psi0_dims = None; self.psi0_shape = None; self.dm_dims = None; self.dm_shape = None; self.unravel_type = 2; self.ptrace_sel = []; self.calc_entropy = False. def parallel(self):; from multiprocessing import Process, Queue, JoinableQueue. if debug:; print(inspect.stack()[0][3]). self.ntrajs = []; for i in range(self.cpus):; self.ntrajs.append(min(int(np.floor(float(self.ntraj); / self.cpus)),; self.ntraj - sum(self.ntrajs))); cnt = sum(self.ntrajs); while cnt < self.ntraj:; for i in range(self.cpus):; self.ntrajs[i] += 1; cnt += 1; if (cnt >= self.ntraj):; break; self.ntrajs = np.array(self.ntrajs); self.ntrajs = self.ntrajs[np.whe",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:8502,Modifiability,config,config,8502,"re is experimental.""); mc.sparse_dms = False; mc.dm_dims = psi0.ptrace(ptrace_sel).dims; mc.dm_shape = psi0.ptrace(ptrace_sel).shape; if (calc_entropy):; if (ptrace_sel == []):; if debug:; print(""calc_entropy = True, but ptrace_sel = []. Please set "" +; ""a list of components to keep when calculating average"" +; "" entropy of reduced density matrix in ptrace_sel. "" +; ""Setting calc_entropy = False.""); calc_entropy = False; mc.calc_entropy = calc_entropy. # construct output Result object; output = Result(). # Run; mc.run(); output.states = mc.sol.states; output.expect = mc.sol.expect; output.col_times = mc.sol.col_times; output.col_which = mc.sol.col_which; if (hasattr(mc.sol, 'entropy')):; output.entropy = mc.sol.entropy. output.solver = 'Fortran 90 Monte Carlo solver'; # simulation parameters; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj. return output. class _MC_class():; def __init__(self):; self.cpus = config.options.num_cpus; self.nprocs = self.cpus; self.sol = Result(); self.mf = 10; # If returning density matrices, return as sparse or dense?; self.sparse_dms = True; # Run in serial?; self.serial_run = False; self.ntraj = config.ntraj; self.ntrajs = []; self.seed = None; self.psi0_dims = None; self.psi0_shape = None; self.dm_dims = None; self.dm_shape = None; self.unravel_type = 2; self.ptrace_sel = []; self.calc_entropy = False. def parallel(self):; from multiprocessing import Process, Queue, JoinableQueue. if debug:; print(inspect.stack()[0][3]). self.ntrajs = []; for i in range(self.cpus):; self.ntrajs.append(min(int(np.floor(float(self.ntraj); / self.cpus)),; self.ntraj - sum(self.ntrajs))); cnt = sum(self.ntrajs); while cnt < self.ntraj:; for i in range(self.cpus):; self.ntrajs[i] += 1; cnt += 1; if (cnt >= self.ntraj):; break; self.ntrajs = np.array(self.ntrajs); self.ntrajs = self.ntrajs[np.where(self.ntrajs > 0)]; self.nprocs = len(self.ntrajs); sols = []; processes = []; r",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:8728,Modifiability,config,config,8728,"ce_sel = []. Please set "" +; ""a list of components to keep when calculating average"" +; "" entropy of reduced density matrix in ptrace_sel. "" +; ""Setting calc_entropy = False.""); calc_entropy = False; mc.calc_entropy = calc_entropy. # construct output Result object; output = Result(). # Run; mc.run(); output.states = mc.sol.states; output.expect = mc.sol.expect; output.col_times = mc.sol.col_times; output.col_which = mc.sol.col_which; if (hasattr(mc.sol, 'entropy')):; output.entropy = mc.sol.entropy. output.solver = 'Fortran 90 Monte Carlo solver'; # simulation parameters; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj. return output. class _MC_class():; def __init__(self):; self.cpus = config.options.num_cpus; self.nprocs = self.cpus; self.sol = Result(); self.mf = 10; # If returning density matrices, return as sparse or dense?; self.sparse_dms = True; # Run in serial?; self.serial_run = False; self.ntraj = config.ntraj; self.ntrajs = []; self.seed = None; self.psi0_dims = None; self.psi0_shape = None; self.dm_dims = None; self.dm_shape = None; self.unravel_type = 2; self.ptrace_sel = []; self.calc_entropy = False. def parallel(self):; from multiprocessing import Process, Queue, JoinableQueue. if debug:; print(inspect.stack()[0][3]). self.ntrajs = []; for i in range(self.cpus):; self.ntrajs.append(min(int(np.floor(float(self.ntraj); / self.cpus)),; self.ntraj - sum(self.ntrajs))); cnt = sum(self.ntrajs); while cnt < self.ntraj:; for i in range(self.cpus):; self.ntrajs[i] += 1; cnt += 1; if (cnt >= self.ntraj):; break; self.ntrajs = np.array(self.ntrajs); self.ntrajs = self.ntrajs[np.where(self.ntrajs > 0)]; self.nprocs = len(self.ntrajs); sols = []; processes = []; resq = JoinableQueue(); resq.join(). if debug:; print(""Number of cpus: "" + str(self.cpus)); print(""Trying to start "" + str(self.nprocs) + "" process(es).""); print(""Number of trajectories for each process: "" +; str(self.ntrajs)).",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:10621,Modifiability,config,config,10621,"to start "" + str(self.nprocs) + "" process(es).""); print(""Number of trajectories for each process: "" +; str(self.ntrajs)). for i in range(self.nprocs):; p = Process(target=self.evolve_serial,; args=((resq, self.ntrajs[i], i, self.seed * (i + 1)),)); p.start(); processes.append(p); cnt = 0. while True:; try:; sols.append(resq.get()); resq.task_done(); cnt += 1; if (cnt >= self.nprocs):; break; except KeyboardInterrupt:; break; except:; pass. resq.join(); for proc in processes:; try:; proc.join(); except KeyboardInterrupt:; if debug:; print(""Cancel thread on keyboard interrupt""); proc.terminate(); proc.join(); resq.close(); return sols. def serial(self):. if debug:; print(inspect.stack()[0][3]). self.nprocs = 1; self.ntrajs = [self.ntraj]; if debug:; print(""Running in serial.""); print(""Number of trajectories: "" + str(self.ntraj)); sol = self.evolve_serial((0, self.ntraj, 0, self.seed)); return [sol]. def run(self):. if debug:; print(inspect.stack()[0][3]). from numpy.random import random_integers; if (config.c_num == 0):; # force one trajectory if no collapse operators; config.ntraj = 1; self.ntraj = 1; # Set unravel_type to 1 to integrate without collapses; self.unravel_type = 1; if (config.e_num == 0):; # If we are returning states, and there are no; # collapse operators, set average_states to False to return; # ket vectors instead of density matrices; config.options.average_states = False; # generate a random seed, useful if e.g. running with MPI; self.seed = random_integers(1e8); if (self.serial_run):; # run in serial; sols = self.serial(); else:; # run in paralell; sols = self.parallel(); # gather data; self.sol = _gather(sols). def evolve_serial(self, args):. if debug:; print(inspect.stack()[0][3] + "":"" + str(os.getpid())). # run ntraj trajectories for one process via fortran; # get args; queue, ntraj, instanceno, rngseed = args; # initialize the problem in fortran; _init_tlist(); _init_psi0(); if (self.ptrace_sel != []):; _init_ptrace_stuff(self.ptrace_sel); _in",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:10691,Modifiability,config,config,10691,"""Number of trajectories for each process: "" +; str(self.ntrajs)). for i in range(self.nprocs):; p = Process(target=self.evolve_serial,; args=((resq, self.ntrajs[i], i, self.seed * (i + 1)),)); p.start(); processes.append(p); cnt = 0. while True:; try:; sols.append(resq.get()); resq.task_done(); cnt += 1; if (cnt >= self.nprocs):; break; except KeyboardInterrupt:; break; except:; pass. resq.join(); for proc in processes:; try:; proc.join(); except KeyboardInterrupt:; if debug:; print(""Cancel thread on keyboard interrupt""); proc.terminate(); proc.join(); resq.close(); return sols. def serial(self):. if debug:; print(inspect.stack()[0][3]). self.nprocs = 1; self.ntrajs = [self.ntraj]; if debug:; print(""Running in serial.""); print(""Number of trajectories: "" + str(self.ntraj)); sol = self.evolve_serial((0, self.ntraj, 0, self.seed)); return [sol]. def run(self):. if debug:; print(inspect.stack()[0][3]). from numpy.random import random_integers; if (config.c_num == 0):; # force one trajectory if no collapse operators; config.ntraj = 1; self.ntraj = 1; # Set unravel_type to 1 to integrate without collapses; self.unravel_type = 1; if (config.e_num == 0):; # If we are returning states, and there are no; # collapse operators, set average_states to False to return; # ket vectors instead of density matrices; config.options.average_states = False; # generate a random seed, useful if e.g. running with MPI; self.seed = random_integers(1e8); if (self.serial_run):; # run in serial; sols = self.serial(); else:; # run in paralell; sols = self.parallel(); # gather data; self.sol = _gather(sols). def evolve_serial(self, args):. if debug:; print(inspect.stack()[0][3] + "":"" + str(os.getpid())). # run ntraj trajectories for one process via fortran; # get args; queue, ntraj, instanceno, rngseed = args; # initialize the problem in fortran; _init_tlist(); _init_psi0(); if (self.ptrace_sel != []):; _init_ptrace_stuff(self.ptrace_sel); _init_hamilt(); if (config.c_num != 0):; _init_c_ops(); if ",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:10808,Modifiability,config,config,10808,"rgs=((resq, self.ntrajs[i], i, self.seed * (i + 1)),)); p.start(); processes.append(p); cnt = 0. while True:; try:; sols.append(resq.get()); resq.task_done(); cnt += 1; if (cnt >= self.nprocs):; break; except KeyboardInterrupt:; break; except:; pass. resq.join(); for proc in processes:; try:; proc.join(); except KeyboardInterrupt:; if debug:; print(""Cancel thread on keyboard interrupt""); proc.terminate(); proc.join(); resq.close(); return sols. def serial(self):. if debug:; print(inspect.stack()[0][3]). self.nprocs = 1; self.ntrajs = [self.ntraj]; if debug:; print(""Running in serial.""); print(""Number of trajectories: "" + str(self.ntraj)); sol = self.evolve_serial((0, self.ntraj, 0, self.seed)); return [sol]. def run(self):. if debug:; print(inspect.stack()[0][3]). from numpy.random import random_integers; if (config.c_num == 0):; # force one trajectory if no collapse operators; config.ntraj = 1; self.ntraj = 1; # Set unravel_type to 1 to integrate without collapses; self.unravel_type = 1; if (config.e_num == 0):; # If we are returning states, and there are no; # collapse operators, set average_states to False to return; # ket vectors instead of density matrices; config.options.average_states = False; # generate a random seed, useful if e.g. running with MPI; self.seed = random_integers(1e8); if (self.serial_run):; # run in serial; sols = self.serial(); else:; # run in paralell; sols = self.parallel(); # gather data; self.sol = _gather(sols). def evolve_serial(self, args):. if debug:; print(inspect.stack()[0][3] + "":"" + str(os.getpid())). # run ntraj trajectories for one process via fortran; # get args; queue, ntraj, instanceno, rngseed = args; # initialize the problem in fortran; _init_tlist(); _init_psi0(); if (self.ptrace_sel != []):; _init_ptrace_stuff(self.ptrace_sel); _init_hamilt(); if (config.c_num != 0):; _init_c_ops(); if (config.e_num != 0):; _init_e_ops(); # set options; qtf90.qutraj_run.n_c_ops = config.c_num; qtf90.qutraj_run.n_e_ops = config.e_num; qtf9",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:10981,Modifiability,config,config,10981,"e True:; try:; sols.append(resq.get()); resq.task_done(); cnt += 1; if (cnt >= self.nprocs):; break; except KeyboardInterrupt:; break; except:; pass. resq.join(); for proc in processes:; try:; proc.join(); except KeyboardInterrupt:; if debug:; print(""Cancel thread on keyboard interrupt""); proc.terminate(); proc.join(); resq.close(); return sols. def serial(self):. if debug:; print(inspect.stack()[0][3]). self.nprocs = 1; self.ntrajs = [self.ntraj]; if debug:; print(""Running in serial.""); print(""Number of trajectories: "" + str(self.ntraj)); sol = self.evolve_serial((0, self.ntraj, 0, self.seed)); return [sol]. def run(self):. if debug:; print(inspect.stack()[0][3]). from numpy.random import random_integers; if (config.c_num == 0):; # force one trajectory if no collapse operators; config.ntraj = 1; self.ntraj = 1; # Set unravel_type to 1 to integrate without collapses; self.unravel_type = 1; if (config.e_num == 0):; # If we are returning states, and there are no; # collapse operators, set average_states to False to return; # ket vectors instead of density matrices; config.options.average_states = False; # generate a random seed, useful if e.g. running with MPI; self.seed = random_integers(1e8); if (self.serial_run):; # run in serial; sols = self.serial(); else:; # run in paralell; sols = self.parallel(); # gather data; self.sol = _gather(sols). def evolve_serial(self, args):. if debug:; print(inspect.stack()[0][3] + "":"" + str(os.getpid())). # run ntraj trajectories for one process via fortran; # get args; queue, ntraj, instanceno, rngseed = args; # initialize the problem in fortran; _init_tlist(); _init_psi0(); if (self.ptrace_sel != []):; _init_ptrace_stuff(self.ptrace_sel); _init_hamilt(); if (config.c_num != 0):; _init_c_ops(); if (config.e_num != 0):; _init_e_ops(); # set options; qtf90.qutraj_run.n_c_ops = config.c_num; qtf90.qutraj_run.n_e_ops = config.e_num; qtf90.qutraj_run.ntraj = ntraj; qtf90.qutraj_run.unravel_type = self.unravel_type; qtf90.qutraj_run.avera",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:11624,Modifiability,config,config,11624,"gers; if (config.c_num == 0):; # force one trajectory if no collapse operators; config.ntraj = 1; self.ntraj = 1; # Set unravel_type to 1 to integrate without collapses; self.unravel_type = 1; if (config.e_num == 0):; # If we are returning states, and there are no; # collapse operators, set average_states to False to return; # ket vectors instead of density matrices; config.options.average_states = False; # generate a random seed, useful if e.g. running with MPI; self.seed = random_integers(1e8); if (self.serial_run):; # run in serial; sols = self.serial(); else:; # run in paralell; sols = self.parallel(); # gather data; self.sol = _gather(sols). def evolve_serial(self, args):. if debug:; print(inspect.stack()[0][3] + "":"" + str(os.getpid())). # run ntraj trajectories for one process via fortran; # get args; queue, ntraj, instanceno, rngseed = args; # initialize the problem in fortran; _init_tlist(); _init_psi0(); if (self.ptrace_sel != []):; _init_ptrace_stuff(self.ptrace_sel); _init_hamilt(); if (config.c_num != 0):; _init_c_ops(); if (config.e_num != 0):; _init_e_ops(); # set options; qtf90.qutraj_run.n_c_ops = config.c_num; qtf90.qutraj_run.n_e_ops = config.e_num; qtf90.qutraj_run.ntraj = ntraj; qtf90.qutraj_run.unravel_type = self.unravel_type; qtf90.qutraj_run.average_states = config.options.average_states; qtf90.qutraj_run.average_expect = config.options.average_expect; qtf90.qutraj_run.init_result(config.psi0_shape[0],; config.options.atol,; config.options.rtol, mf=self.mf,; norm_steps=config.norm_steps,; norm_tol=config.norm_tol); # set optional arguments; qtf90.qutraj_run.order = config.options.order; qtf90.qutraj_run.nsteps = config.options.nsteps; qtf90.qutraj_run.first_step = config.options.first_step; qtf90.qutraj_run.min_step = config.options.min_step; qtf90.qutraj_run.max_step = config.options.max_step; qtf90.qutraj_run.norm_steps = config.options.norm_steps; qtf90.qutraj_run.norm_tol = config.options.norm_tol; # use sparse density matrices during com",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:11664,Modifiability,config,config,11664,"ne trajectory if no collapse operators; config.ntraj = 1; self.ntraj = 1; # Set unravel_type to 1 to integrate without collapses; self.unravel_type = 1; if (config.e_num == 0):; # If we are returning states, and there are no; # collapse operators, set average_states to False to return; # ket vectors instead of density matrices; config.options.average_states = False; # generate a random seed, useful if e.g. running with MPI; self.seed = random_integers(1e8); if (self.serial_run):; # run in serial; sols = self.serial(); else:; # run in paralell; sols = self.parallel(); # gather data; self.sol = _gather(sols). def evolve_serial(self, args):. if debug:; print(inspect.stack()[0][3] + "":"" + str(os.getpid())). # run ntraj trajectories for one process via fortran; # get args; queue, ntraj, instanceno, rngseed = args; # initialize the problem in fortran; _init_tlist(); _init_psi0(); if (self.ptrace_sel != []):; _init_ptrace_stuff(self.ptrace_sel); _init_hamilt(); if (config.c_num != 0):; _init_c_ops(); if (config.e_num != 0):; _init_e_ops(); # set options; qtf90.qutraj_run.n_c_ops = config.c_num; qtf90.qutraj_run.n_e_ops = config.e_num; qtf90.qutraj_run.ntraj = ntraj; qtf90.qutraj_run.unravel_type = self.unravel_type; qtf90.qutraj_run.average_states = config.options.average_states; qtf90.qutraj_run.average_expect = config.options.average_expect; qtf90.qutraj_run.init_result(config.psi0_shape[0],; config.options.atol,; config.options.rtol, mf=self.mf,; norm_steps=config.norm_steps,; norm_tol=config.norm_tol); # set optional arguments; qtf90.qutraj_run.order = config.options.order; qtf90.qutraj_run.nsteps = config.options.nsteps; qtf90.qutraj_run.first_step = config.options.first_step; qtf90.qutraj_run.min_step = config.options.min_step; qtf90.qutraj_run.max_step = config.options.max_step; qtf90.qutraj_run.norm_steps = config.options.norm_steps; qtf90.qutraj_run.norm_tol = config.options.norm_tol; # use sparse density matrices during computation?; qtf90.qutraj_run.rho_return_s",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:11742,Modifiability,config,config,11742,"ype to 1 to integrate without collapses; self.unravel_type = 1; if (config.e_num == 0):; # If we are returning states, and there are no; # collapse operators, set average_states to False to return; # ket vectors instead of density matrices; config.options.average_states = False; # generate a random seed, useful if e.g. running with MPI; self.seed = random_integers(1e8); if (self.serial_run):; # run in serial; sols = self.serial(); else:; # run in paralell; sols = self.parallel(); # gather data; self.sol = _gather(sols). def evolve_serial(self, args):. if debug:; print(inspect.stack()[0][3] + "":"" + str(os.getpid())). # run ntraj trajectories for one process via fortran; # get args; queue, ntraj, instanceno, rngseed = args; # initialize the problem in fortran; _init_tlist(); _init_psi0(); if (self.ptrace_sel != []):; _init_ptrace_stuff(self.ptrace_sel); _init_hamilt(); if (config.c_num != 0):; _init_c_ops(); if (config.e_num != 0):; _init_e_ops(); # set options; qtf90.qutraj_run.n_c_ops = config.c_num; qtf90.qutraj_run.n_e_ops = config.e_num; qtf90.qutraj_run.ntraj = ntraj; qtf90.qutraj_run.unravel_type = self.unravel_type; qtf90.qutraj_run.average_states = config.options.average_states; qtf90.qutraj_run.average_expect = config.options.average_expect; qtf90.qutraj_run.init_result(config.psi0_shape[0],; config.options.atol,; config.options.rtol, mf=self.mf,; norm_steps=config.norm_steps,; norm_tol=config.norm_tol); # set optional arguments; qtf90.qutraj_run.order = config.options.order; qtf90.qutraj_run.nsteps = config.options.nsteps; qtf90.qutraj_run.first_step = config.options.first_step; qtf90.qutraj_run.min_step = config.options.min_step; qtf90.qutraj_run.max_step = config.options.max_step; qtf90.qutraj_run.norm_steps = config.options.norm_steps; qtf90.qutraj_run.norm_tol = config.options.norm_tol; # use sparse density matrices during computation?; qtf90.qutraj_run.rho_return_sparse = self.sparse_dms; # calculate entropy of reduced density matrice?; qtf90.qutraj_run",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:11783,Modifiability,config,config,11783,"self.unravel_type = 1; if (config.e_num == 0):; # If we are returning states, and there are no; # collapse operators, set average_states to False to return; # ket vectors instead of density matrices; config.options.average_states = False; # generate a random seed, useful if e.g. running with MPI; self.seed = random_integers(1e8); if (self.serial_run):; # run in serial; sols = self.serial(); else:; # run in paralell; sols = self.parallel(); # gather data; self.sol = _gather(sols). def evolve_serial(self, args):. if debug:; print(inspect.stack()[0][3] + "":"" + str(os.getpid())). # run ntraj trajectories for one process via fortran; # get args; queue, ntraj, instanceno, rngseed = args; # initialize the problem in fortran; _init_tlist(); _init_psi0(); if (self.ptrace_sel != []):; _init_ptrace_stuff(self.ptrace_sel); _init_hamilt(); if (config.c_num != 0):; _init_c_ops(); if (config.e_num != 0):; _init_e_ops(); # set options; qtf90.qutraj_run.n_c_ops = config.c_num; qtf90.qutraj_run.n_e_ops = config.e_num; qtf90.qutraj_run.ntraj = ntraj; qtf90.qutraj_run.unravel_type = self.unravel_type; qtf90.qutraj_run.average_states = config.options.average_states; qtf90.qutraj_run.average_expect = config.options.average_expect; qtf90.qutraj_run.init_result(config.psi0_shape[0],; config.options.atol,; config.options.rtol, mf=self.mf,; norm_steps=config.norm_steps,; norm_tol=config.norm_tol); # set optional arguments; qtf90.qutraj_run.order = config.options.order; qtf90.qutraj_run.nsteps = config.options.nsteps; qtf90.qutraj_run.first_step = config.options.first_step; qtf90.qutraj_run.min_step = config.options.min_step; qtf90.qutraj_run.max_step = config.options.max_step; qtf90.qutraj_run.norm_steps = config.options.norm_steps; qtf90.qutraj_run.norm_tol = config.options.norm_tol; # use sparse density matrices during computation?; qtf90.qutraj_run.rho_return_sparse = self.sparse_dms; # calculate entropy of reduced density matrice?; qtf90.qutraj_run.calc_entropy = self.calc_entropy; # run;",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:11914,Modifiability,config,config,11914,"e_states to False to return; # ket vectors instead of density matrices; config.options.average_states = False; # generate a random seed, useful if e.g. running with MPI; self.seed = random_integers(1e8); if (self.serial_run):; # run in serial; sols = self.serial(); else:; # run in paralell; sols = self.parallel(); # gather data; self.sol = _gather(sols). def evolve_serial(self, args):. if debug:; print(inspect.stack()[0][3] + "":"" + str(os.getpid())). # run ntraj trajectories for one process via fortran; # get args; queue, ntraj, instanceno, rngseed = args; # initialize the problem in fortran; _init_tlist(); _init_psi0(); if (self.ptrace_sel != []):; _init_ptrace_stuff(self.ptrace_sel); _init_hamilt(); if (config.c_num != 0):; _init_c_ops(); if (config.e_num != 0):; _init_e_ops(); # set options; qtf90.qutraj_run.n_c_ops = config.c_num; qtf90.qutraj_run.n_e_ops = config.e_num; qtf90.qutraj_run.ntraj = ntraj; qtf90.qutraj_run.unravel_type = self.unravel_type; qtf90.qutraj_run.average_states = config.options.average_states; qtf90.qutraj_run.average_expect = config.options.average_expect; qtf90.qutraj_run.init_result(config.psi0_shape[0],; config.options.atol,; config.options.rtol, mf=self.mf,; norm_steps=config.norm_steps,; norm_tol=config.norm_tol); # set optional arguments; qtf90.qutraj_run.order = config.options.order; qtf90.qutraj_run.nsteps = config.options.nsteps; qtf90.qutraj_run.first_step = config.options.first_step; qtf90.qutraj_run.min_step = config.options.min_step; qtf90.qutraj_run.max_step = config.options.max_step; qtf90.qutraj_run.norm_steps = config.options.norm_steps; qtf90.qutraj_run.norm_tol = config.options.norm_tol; # use sparse density matrices during computation?; qtf90.qutraj_run.rho_return_sparse = self.sparse_dms; # calculate entropy of reduced density matrice?; qtf90.qutraj_run.calc_entropy = self.calc_entropy; # run; show_progress = 1 if debug else 0; qtf90.qutraj_run.evolve(instanceno, rngseed, show_progress). # construct Result instance; s",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:11979,Modifiability,config,config,11979,"rices; config.options.average_states = False; # generate a random seed, useful if e.g. running with MPI; self.seed = random_integers(1e8); if (self.serial_run):; # run in serial; sols = self.serial(); else:; # run in paralell; sols = self.parallel(); # gather data; self.sol = _gather(sols). def evolve_serial(self, args):. if debug:; print(inspect.stack()[0][3] + "":"" + str(os.getpid())). # run ntraj trajectories for one process via fortran; # get args; queue, ntraj, instanceno, rngseed = args; # initialize the problem in fortran; _init_tlist(); _init_psi0(); if (self.ptrace_sel != []):; _init_ptrace_stuff(self.ptrace_sel); _init_hamilt(); if (config.c_num != 0):; _init_c_ops(); if (config.e_num != 0):; _init_e_ops(); # set options; qtf90.qutraj_run.n_c_ops = config.c_num; qtf90.qutraj_run.n_e_ops = config.e_num; qtf90.qutraj_run.ntraj = ntraj; qtf90.qutraj_run.unravel_type = self.unravel_type; qtf90.qutraj_run.average_states = config.options.average_states; qtf90.qutraj_run.average_expect = config.options.average_expect; qtf90.qutraj_run.init_result(config.psi0_shape[0],; config.options.atol,; config.options.rtol, mf=self.mf,; norm_steps=config.norm_steps,; norm_tol=config.norm_tol); # set optional arguments; qtf90.qutraj_run.order = config.options.order; qtf90.qutraj_run.nsteps = config.options.nsteps; qtf90.qutraj_run.first_step = config.options.first_step; qtf90.qutraj_run.min_step = config.options.min_step; qtf90.qutraj_run.max_step = config.options.max_step; qtf90.qutraj_run.norm_steps = config.options.norm_steps; qtf90.qutraj_run.norm_tol = config.options.norm_tol; # use sparse density matrices during computation?; qtf90.qutraj_run.rho_return_sparse = self.sparse_dms; # calculate entropy of reduced density matrice?; qtf90.qutraj_run.calc_entropy = self.calc_entropy; # run; show_progress = 1 if debug else 0; qtf90.qutraj_run.evolve(instanceno, rngseed, show_progress). # construct Result instance; sol = Result(); sol.ntraj = ntraj; # sol.col_times = qtf90.qutraj_",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:12039,Modifiability,config,config,12039,"dom seed, useful if e.g. running with MPI; self.seed = random_integers(1e8); if (self.serial_run):; # run in serial; sols = self.serial(); else:; # run in paralell; sols = self.parallel(); # gather data; self.sol = _gather(sols). def evolve_serial(self, args):. if debug:; print(inspect.stack()[0][3] + "":"" + str(os.getpid())). # run ntraj trajectories for one process via fortran; # get args; queue, ntraj, instanceno, rngseed = args; # initialize the problem in fortran; _init_tlist(); _init_psi0(); if (self.ptrace_sel != []):; _init_ptrace_stuff(self.ptrace_sel); _init_hamilt(); if (config.c_num != 0):; _init_c_ops(); if (config.e_num != 0):; _init_e_ops(); # set options; qtf90.qutraj_run.n_c_ops = config.c_num; qtf90.qutraj_run.n_e_ops = config.e_num; qtf90.qutraj_run.ntraj = ntraj; qtf90.qutraj_run.unravel_type = self.unravel_type; qtf90.qutraj_run.average_states = config.options.average_states; qtf90.qutraj_run.average_expect = config.options.average_expect; qtf90.qutraj_run.init_result(config.psi0_shape[0],; config.options.atol,; config.options.rtol, mf=self.mf,; norm_steps=config.norm_steps,; norm_tol=config.norm_tol); # set optional arguments; qtf90.qutraj_run.order = config.options.order; qtf90.qutraj_run.nsteps = config.options.nsteps; qtf90.qutraj_run.first_step = config.options.first_step; qtf90.qutraj_run.min_step = config.options.min_step; qtf90.qutraj_run.max_step = config.options.max_step; qtf90.qutraj_run.norm_steps = config.options.norm_steps; qtf90.qutraj_run.norm_tol = config.options.norm_tol; # use sparse density matrices during computation?; qtf90.qutraj_run.rho_return_sparse = self.sparse_dms; # calculate entropy of reduced density matrice?; qtf90.qutraj_run.calc_entropy = self.calc_entropy; # run; show_progress = 1 if debug else 0; qtf90.qutraj_run.evolve(instanceno, rngseed, show_progress). # construct Result instance; sol = Result(); sol.ntraj = ntraj; # sol.col_times = qtf90.qutraj_run.col_times; # sol.col_which = qtf90.qutraj_run.col_which-1; ",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:12062,Modifiability,config,config,12062,".g. running with MPI; self.seed = random_integers(1e8); if (self.serial_run):; # run in serial; sols = self.serial(); else:; # run in paralell; sols = self.parallel(); # gather data; self.sol = _gather(sols). def evolve_serial(self, args):. if debug:; print(inspect.stack()[0][3] + "":"" + str(os.getpid())). # run ntraj trajectories for one process via fortran; # get args; queue, ntraj, instanceno, rngseed = args; # initialize the problem in fortran; _init_tlist(); _init_psi0(); if (self.ptrace_sel != []):; _init_ptrace_stuff(self.ptrace_sel); _init_hamilt(); if (config.c_num != 0):; _init_c_ops(); if (config.e_num != 0):; _init_e_ops(); # set options; qtf90.qutraj_run.n_c_ops = config.c_num; qtf90.qutraj_run.n_e_ops = config.e_num; qtf90.qutraj_run.ntraj = ntraj; qtf90.qutraj_run.unravel_type = self.unravel_type; qtf90.qutraj_run.average_states = config.options.average_states; qtf90.qutraj_run.average_expect = config.options.average_expect; qtf90.qutraj_run.init_result(config.psi0_shape[0],; config.options.atol,; config.options.rtol, mf=self.mf,; norm_steps=config.norm_steps,; norm_tol=config.norm_tol); # set optional arguments; qtf90.qutraj_run.order = config.options.order; qtf90.qutraj_run.nsteps = config.options.nsteps; qtf90.qutraj_run.first_step = config.options.first_step; qtf90.qutraj_run.min_step = config.options.min_step; qtf90.qutraj_run.max_step = config.options.max_step; qtf90.qutraj_run.norm_steps = config.options.norm_steps; qtf90.qutraj_run.norm_tol = config.options.norm_tol; # use sparse density matrices during computation?; qtf90.qutraj_run.rho_return_sparse = self.sparse_dms; # calculate entropy of reduced density matrice?; qtf90.qutraj_run.calc_entropy = self.calc_entropy; # run; show_progress = 1 if debug else 0; qtf90.qutraj_run.evolve(instanceno, rngseed, show_progress). # construct Result instance; sol = Result(); sol.ntraj = ntraj; # sol.col_times = qtf90.qutraj_run.col_times; # sol.col_which = qtf90.qutraj_run.col_which-1; sol.col_times, sol.co",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:12084,Modifiability,config,config,12084,"seed = random_integers(1e8); if (self.serial_run):; # run in serial; sols = self.serial(); else:; # run in paralell; sols = self.parallel(); # gather data; self.sol = _gather(sols). def evolve_serial(self, args):. if debug:; print(inspect.stack()[0][3] + "":"" + str(os.getpid())). # run ntraj trajectories for one process via fortran; # get args; queue, ntraj, instanceno, rngseed = args; # initialize the problem in fortran; _init_tlist(); _init_psi0(); if (self.ptrace_sel != []):; _init_ptrace_stuff(self.ptrace_sel); _init_hamilt(); if (config.c_num != 0):; _init_c_ops(); if (config.e_num != 0):; _init_e_ops(); # set options; qtf90.qutraj_run.n_c_ops = config.c_num; qtf90.qutraj_run.n_e_ops = config.e_num; qtf90.qutraj_run.ntraj = ntraj; qtf90.qutraj_run.unravel_type = self.unravel_type; qtf90.qutraj_run.average_states = config.options.average_states; qtf90.qutraj_run.average_expect = config.options.average_expect; qtf90.qutraj_run.init_result(config.psi0_shape[0],; config.options.atol,; config.options.rtol, mf=self.mf,; norm_steps=config.norm_steps,; norm_tol=config.norm_tol); # set optional arguments; qtf90.qutraj_run.order = config.options.order; qtf90.qutraj_run.nsteps = config.options.nsteps; qtf90.qutraj_run.first_step = config.options.first_step; qtf90.qutraj_run.min_step = config.options.min_step; qtf90.qutraj_run.max_step = config.options.max_step; qtf90.qutraj_run.norm_steps = config.options.norm_steps; qtf90.qutraj_run.norm_tol = config.options.norm_tol; # use sparse density matrices during computation?; qtf90.qutraj_run.rho_return_sparse = self.sparse_dms; # calculate entropy of reduced density matrice?; qtf90.qutraj_run.calc_entropy = self.calc_entropy; # run; show_progress = 1 if debug else 0; qtf90.qutraj_run.evolve(instanceno, rngseed, show_progress). # construct Result instance; sol = Result(); sol.ntraj = ntraj; # sol.col_times = qtf90.qutraj_run.col_times; # sol.col_which = qtf90.qutraj_run.col_which-1; sol.col_times, sol.col_which = self.get_collaps",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:12129,Modifiability,config,config,12129,"rial_run):; # run in serial; sols = self.serial(); else:; # run in paralell; sols = self.parallel(); # gather data; self.sol = _gather(sols). def evolve_serial(self, args):. if debug:; print(inspect.stack()[0][3] + "":"" + str(os.getpid())). # run ntraj trajectories for one process via fortran; # get args; queue, ntraj, instanceno, rngseed = args; # initialize the problem in fortran; _init_tlist(); _init_psi0(); if (self.ptrace_sel != []):; _init_ptrace_stuff(self.ptrace_sel); _init_hamilt(); if (config.c_num != 0):; _init_c_ops(); if (config.e_num != 0):; _init_e_ops(); # set options; qtf90.qutraj_run.n_c_ops = config.c_num; qtf90.qutraj_run.n_e_ops = config.e_num; qtf90.qutraj_run.ntraj = ntraj; qtf90.qutraj_run.unravel_type = self.unravel_type; qtf90.qutraj_run.average_states = config.options.average_states; qtf90.qutraj_run.average_expect = config.options.average_expect; qtf90.qutraj_run.init_result(config.psi0_shape[0],; config.options.atol,; config.options.rtol, mf=self.mf,; norm_steps=config.norm_steps,; norm_tol=config.norm_tol); # set optional arguments; qtf90.qutraj_run.order = config.options.order; qtf90.qutraj_run.nsteps = config.options.nsteps; qtf90.qutraj_run.first_step = config.options.first_step; qtf90.qutraj_run.min_step = config.options.min_step; qtf90.qutraj_run.max_step = config.options.max_step; qtf90.qutraj_run.norm_steps = config.options.norm_steps; qtf90.qutraj_run.norm_tol = config.options.norm_tol; # use sparse density matrices during computation?; qtf90.qutraj_run.rho_return_sparse = self.sparse_dms; # calculate entropy of reduced density matrice?; qtf90.qutraj_run.calc_entropy = self.calc_entropy; # run; show_progress = 1 if debug else 0; qtf90.qutraj_run.evolve(instanceno, rngseed, show_progress). # construct Result instance; sol = Result(); sol.ntraj = ntraj; # sol.col_times = qtf90.qutraj_run.col_times; # sol.col_which = qtf90.qutraj_run.col_which-1; sol.col_times, sol.col_which = self.get_collapses(ntraj); if (config.e_num == 0):; sol.s",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:12158,Modifiability,config,config,12158,"l; sols = self.serial(); else:; # run in paralell; sols = self.parallel(); # gather data; self.sol = _gather(sols). def evolve_serial(self, args):. if debug:; print(inspect.stack()[0][3] + "":"" + str(os.getpid())). # run ntraj trajectories for one process via fortran; # get args; queue, ntraj, instanceno, rngseed = args; # initialize the problem in fortran; _init_tlist(); _init_psi0(); if (self.ptrace_sel != []):; _init_ptrace_stuff(self.ptrace_sel); _init_hamilt(); if (config.c_num != 0):; _init_c_ops(); if (config.e_num != 0):; _init_e_ops(); # set options; qtf90.qutraj_run.n_c_ops = config.c_num; qtf90.qutraj_run.n_e_ops = config.e_num; qtf90.qutraj_run.ntraj = ntraj; qtf90.qutraj_run.unravel_type = self.unravel_type; qtf90.qutraj_run.average_states = config.options.average_states; qtf90.qutraj_run.average_expect = config.options.average_expect; qtf90.qutraj_run.init_result(config.psi0_shape[0],; config.options.atol,; config.options.rtol, mf=self.mf,; norm_steps=config.norm_steps,; norm_tol=config.norm_tol); # set optional arguments; qtf90.qutraj_run.order = config.options.order; qtf90.qutraj_run.nsteps = config.options.nsteps; qtf90.qutraj_run.first_step = config.options.first_step; qtf90.qutraj_run.min_step = config.options.min_step; qtf90.qutraj_run.max_step = config.options.max_step; qtf90.qutraj_run.norm_steps = config.options.norm_steps; qtf90.qutraj_run.norm_tol = config.options.norm_tol; # use sparse density matrices during computation?; qtf90.qutraj_run.rho_return_sparse = self.sparse_dms; # calculate entropy of reduced density matrice?; qtf90.qutraj_run.calc_entropy = self.calc_entropy; # run; show_progress = 1 if debug else 0; qtf90.qutraj_run.evolve(instanceno, rngseed, show_progress). # construct Result instance; sol = Result(); sol.ntraj = ntraj; # sol.col_times = qtf90.qutraj_run.col_times; # sol.col_which = qtf90.qutraj_run.col_which-1; sol.col_times, sol.col_which = self.get_collapses(ntraj); if (config.e_num == 0):; sol.states = self.get_states(le",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:12227,Modifiability,config,config,12227," gather data; self.sol = _gather(sols). def evolve_serial(self, args):. if debug:; print(inspect.stack()[0][3] + "":"" + str(os.getpid())). # run ntraj trajectories for one process via fortran; # get args; queue, ntraj, instanceno, rngseed = args; # initialize the problem in fortran; _init_tlist(); _init_psi0(); if (self.ptrace_sel != []):; _init_ptrace_stuff(self.ptrace_sel); _init_hamilt(); if (config.c_num != 0):; _init_c_ops(); if (config.e_num != 0):; _init_e_ops(); # set options; qtf90.qutraj_run.n_c_ops = config.c_num; qtf90.qutraj_run.n_e_ops = config.e_num; qtf90.qutraj_run.ntraj = ntraj; qtf90.qutraj_run.unravel_type = self.unravel_type; qtf90.qutraj_run.average_states = config.options.average_states; qtf90.qutraj_run.average_expect = config.options.average_expect; qtf90.qutraj_run.init_result(config.psi0_shape[0],; config.options.atol,; config.options.rtol, mf=self.mf,; norm_steps=config.norm_steps,; norm_tol=config.norm_tol); # set optional arguments; qtf90.qutraj_run.order = config.options.order; qtf90.qutraj_run.nsteps = config.options.nsteps; qtf90.qutraj_run.first_step = config.options.first_step; qtf90.qutraj_run.min_step = config.options.min_step; qtf90.qutraj_run.max_step = config.options.max_step; qtf90.qutraj_run.norm_steps = config.options.norm_steps; qtf90.qutraj_run.norm_tol = config.options.norm_tol; # use sparse density matrices during computation?; qtf90.qutraj_run.rho_return_sparse = self.sparse_dms; # calculate entropy of reduced density matrice?; qtf90.qutraj_run.calc_entropy = self.calc_entropy; # run; show_progress = 1 if debug else 0; qtf90.qutraj_run.evolve(instanceno, rngseed, show_progress). # construct Result instance; sol = Result(); sol.ntraj = ntraj; # sol.col_times = qtf90.qutraj_run.col_times; # sol.col_which = qtf90.qutraj_run.col_which-1; sol.col_times, sol.col_which = self.get_collapses(ntraj); if (config.e_num == 0):; sol.states = self.get_states(len(config.tlist), ntraj); else:; sol.expect = self.get_expect(len(config.tlis",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:12275,Modifiability,config,config,12275,"ve_serial(self, args):. if debug:; print(inspect.stack()[0][3] + "":"" + str(os.getpid())). # run ntraj trajectories for one process via fortran; # get args; queue, ntraj, instanceno, rngseed = args; # initialize the problem in fortran; _init_tlist(); _init_psi0(); if (self.ptrace_sel != []):; _init_ptrace_stuff(self.ptrace_sel); _init_hamilt(); if (config.c_num != 0):; _init_c_ops(); if (config.e_num != 0):; _init_e_ops(); # set options; qtf90.qutraj_run.n_c_ops = config.c_num; qtf90.qutraj_run.n_e_ops = config.e_num; qtf90.qutraj_run.ntraj = ntraj; qtf90.qutraj_run.unravel_type = self.unravel_type; qtf90.qutraj_run.average_states = config.options.average_states; qtf90.qutraj_run.average_expect = config.options.average_expect; qtf90.qutraj_run.init_result(config.psi0_shape[0],; config.options.atol,; config.options.rtol, mf=self.mf,; norm_steps=config.norm_steps,; norm_tol=config.norm_tol); # set optional arguments; qtf90.qutraj_run.order = config.options.order; qtf90.qutraj_run.nsteps = config.options.nsteps; qtf90.qutraj_run.first_step = config.options.first_step; qtf90.qutraj_run.min_step = config.options.min_step; qtf90.qutraj_run.max_step = config.options.max_step; qtf90.qutraj_run.norm_steps = config.options.norm_steps; qtf90.qutraj_run.norm_tol = config.options.norm_tol; # use sparse density matrices during computation?; qtf90.qutraj_run.rho_return_sparse = self.sparse_dms; # calculate entropy of reduced density matrice?; qtf90.qutraj_run.calc_entropy = self.calc_entropy; # run; show_progress = 1 if debug else 0; qtf90.qutraj_run.evolve(instanceno, rngseed, show_progress). # construct Result instance; sol = Result(); sol.ntraj = ntraj; # sol.col_times = qtf90.qutraj_run.col_times; # sol.col_which = qtf90.qutraj_run.col_which-1; sol.col_times, sol.col_which = self.get_collapses(ntraj); if (config.e_num == 0):; sol.states = self.get_states(len(config.tlist), ntraj); else:; sol.expect = self.get_expect(len(config.tlist), ntraj); if (self.calc_entropy):; sol.entrop",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:12328,Modifiability,config,config,12328,"ack()[0][3] + "":"" + str(os.getpid())). # run ntraj trajectories for one process via fortran; # get args; queue, ntraj, instanceno, rngseed = args; # initialize the problem in fortran; _init_tlist(); _init_psi0(); if (self.ptrace_sel != []):; _init_ptrace_stuff(self.ptrace_sel); _init_hamilt(); if (config.c_num != 0):; _init_c_ops(); if (config.e_num != 0):; _init_e_ops(); # set options; qtf90.qutraj_run.n_c_ops = config.c_num; qtf90.qutraj_run.n_e_ops = config.e_num; qtf90.qutraj_run.ntraj = ntraj; qtf90.qutraj_run.unravel_type = self.unravel_type; qtf90.qutraj_run.average_states = config.options.average_states; qtf90.qutraj_run.average_expect = config.options.average_expect; qtf90.qutraj_run.init_result(config.psi0_shape[0],; config.options.atol,; config.options.rtol, mf=self.mf,; norm_steps=config.norm_steps,; norm_tol=config.norm_tol); # set optional arguments; qtf90.qutraj_run.order = config.options.order; qtf90.qutraj_run.nsteps = config.options.nsteps; qtf90.qutraj_run.first_step = config.options.first_step; qtf90.qutraj_run.min_step = config.options.min_step; qtf90.qutraj_run.max_step = config.options.max_step; qtf90.qutraj_run.norm_steps = config.options.norm_steps; qtf90.qutraj_run.norm_tol = config.options.norm_tol; # use sparse density matrices during computation?; qtf90.qutraj_run.rho_return_sparse = self.sparse_dms; # calculate entropy of reduced density matrice?; qtf90.qutraj_run.calc_entropy = self.calc_entropy; # run; show_progress = 1 if debug else 0; qtf90.qutraj_run.evolve(instanceno, rngseed, show_progress). # construct Result instance; sol = Result(); sol.ntraj = ntraj; # sol.col_times = qtf90.qutraj_run.col_times; # sol.col_which = qtf90.qutraj_run.col_which-1; sol.col_times, sol.col_which = self.get_collapses(ntraj); if (config.e_num == 0):; sol.states = self.get_states(len(config.tlist), ntraj); else:; sol.expect = self.get_expect(len(config.tlist), ntraj); if (self.calc_entropy):; sol.entropy = self.get_entropy(len(config.tlist)). if (not se",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:12383,Modifiability,config,config,12383,"ctories for one process via fortran; # get args; queue, ntraj, instanceno, rngseed = args; # initialize the problem in fortran; _init_tlist(); _init_psi0(); if (self.ptrace_sel != []):; _init_ptrace_stuff(self.ptrace_sel); _init_hamilt(); if (config.c_num != 0):; _init_c_ops(); if (config.e_num != 0):; _init_e_ops(); # set options; qtf90.qutraj_run.n_c_ops = config.c_num; qtf90.qutraj_run.n_e_ops = config.e_num; qtf90.qutraj_run.ntraj = ntraj; qtf90.qutraj_run.unravel_type = self.unravel_type; qtf90.qutraj_run.average_states = config.options.average_states; qtf90.qutraj_run.average_expect = config.options.average_expect; qtf90.qutraj_run.init_result(config.psi0_shape[0],; config.options.atol,; config.options.rtol, mf=self.mf,; norm_steps=config.norm_steps,; norm_tol=config.norm_tol); # set optional arguments; qtf90.qutraj_run.order = config.options.order; qtf90.qutraj_run.nsteps = config.options.nsteps; qtf90.qutraj_run.first_step = config.options.first_step; qtf90.qutraj_run.min_step = config.options.min_step; qtf90.qutraj_run.max_step = config.options.max_step; qtf90.qutraj_run.norm_steps = config.options.norm_steps; qtf90.qutraj_run.norm_tol = config.options.norm_tol; # use sparse density matrices during computation?; qtf90.qutraj_run.rho_return_sparse = self.sparse_dms; # calculate entropy of reduced density matrice?; qtf90.qutraj_run.calc_entropy = self.calc_entropy; # run; show_progress = 1 if debug else 0; qtf90.qutraj_run.evolve(instanceno, rngseed, show_progress). # construct Result instance; sol = Result(); sol.ntraj = ntraj; # sol.col_times = qtf90.qutraj_run.col_times; # sol.col_which = qtf90.qutraj_run.col_which-1; sol.col_times, sol.col_which = self.get_collapses(ntraj); if (config.e_num == 0):; sol.states = self.get_states(len(config.tlist), ntraj); else:; sol.expect = self.get_expect(len(config.tlist), ntraj); if (self.calc_entropy):; sol.entropy = self.get_entropy(len(config.tlist)). if (not self.serial_run):; # put to queue; queue.put(sol); queue.j",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:12436,Modifiability,config,config,12436,"e, ntraj, instanceno, rngseed = args; # initialize the problem in fortran; _init_tlist(); _init_psi0(); if (self.ptrace_sel != []):; _init_ptrace_stuff(self.ptrace_sel); _init_hamilt(); if (config.c_num != 0):; _init_c_ops(); if (config.e_num != 0):; _init_e_ops(); # set options; qtf90.qutraj_run.n_c_ops = config.c_num; qtf90.qutraj_run.n_e_ops = config.e_num; qtf90.qutraj_run.ntraj = ntraj; qtf90.qutraj_run.unravel_type = self.unravel_type; qtf90.qutraj_run.average_states = config.options.average_states; qtf90.qutraj_run.average_expect = config.options.average_expect; qtf90.qutraj_run.init_result(config.psi0_shape[0],; config.options.atol,; config.options.rtol, mf=self.mf,; norm_steps=config.norm_steps,; norm_tol=config.norm_tol); # set optional arguments; qtf90.qutraj_run.order = config.options.order; qtf90.qutraj_run.nsteps = config.options.nsteps; qtf90.qutraj_run.first_step = config.options.first_step; qtf90.qutraj_run.min_step = config.options.min_step; qtf90.qutraj_run.max_step = config.options.max_step; qtf90.qutraj_run.norm_steps = config.options.norm_steps; qtf90.qutraj_run.norm_tol = config.options.norm_tol; # use sparse density matrices during computation?; qtf90.qutraj_run.rho_return_sparse = self.sparse_dms; # calculate entropy of reduced density matrice?; qtf90.qutraj_run.calc_entropy = self.calc_entropy; # run; show_progress = 1 if debug else 0; qtf90.qutraj_run.evolve(instanceno, rngseed, show_progress). # construct Result instance; sol = Result(); sol.ntraj = ntraj; # sol.col_times = qtf90.qutraj_run.col_times; # sol.col_which = qtf90.qutraj_run.col_which-1; sol.col_times, sol.col_which = self.get_collapses(ntraj); if (config.e_num == 0):; sol.states = self.get_states(len(config.tlist), ntraj); else:; sol.expect = self.get_expect(len(config.tlist), ntraj); if (self.calc_entropy):; sol.entropy = self.get_entropy(len(config.tlist)). if (not self.serial_run):; # put to queue; queue.put(sol); queue.join(). # deallocate stuff; # finalize(); return sol. ",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:12491,Modifiability,config,config,12491," problem in fortran; _init_tlist(); _init_psi0(); if (self.ptrace_sel != []):; _init_ptrace_stuff(self.ptrace_sel); _init_hamilt(); if (config.c_num != 0):; _init_c_ops(); if (config.e_num != 0):; _init_e_ops(); # set options; qtf90.qutraj_run.n_c_ops = config.c_num; qtf90.qutraj_run.n_e_ops = config.e_num; qtf90.qutraj_run.ntraj = ntraj; qtf90.qutraj_run.unravel_type = self.unravel_type; qtf90.qutraj_run.average_states = config.options.average_states; qtf90.qutraj_run.average_expect = config.options.average_expect; qtf90.qutraj_run.init_result(config.psi0_shape[0],; config.options.atol,; config.options.rtol, mf=self.mf,; norm_steps=config.norm_steps,; norm_tol=config.norm_tol); # set optional arguments; qtf90.qutraj_run.order = config.options.order; qtf90.qutraj_run.nsteps = config.options.nsteps; qtf90.qutraj_run.first_step = config.options.first_step; qtf90.qutraj_run.min_step = config.options.min_step; qtf90.qutraj_run.max_step = config.options.max_step; qtf90.qutraj_run.norm_steps = config.options.norm_steps; qtf90.qutraj_run.norm_tol = config.options.norm_tol; # use sparse density matrices during computation?; qtf90.qutraj_run.rho_return_sparse = self.sparse_dms; # calculate entropy of reduced density matrice?; qtf90.qutraj_run.calc_entropy = self.calc_entropy; # run; show_progress = 1 if debug else 0; qtf90.qutraj_run.evolve(instanceno, rngseed, show_progress). # construct Result instance; sol = Result(); sol.ntraj = ntraj; # sol.col_times = qtf90.qutraj_run.col_times; # sol.col_which = qtf90.qutraj_run.col_which-1; sol.col_times, sol.col_which = self.get_collapses(ntraj); if (config.e_num == 0):; sol.states = self.get_states(len(config.tlist), ntraj); else:; sol.expect = self.get_expect(len(config.tlist), ntraj); if (self.calc_entropy):; sol.entropy = self.get_entropy(len(config.tlist)). if (not self.serial_run):; # put to queue; queue.put(sol); queue.join(). # deallocate stuff; # finalize(); return sol. # Routines for retrieving data data from fortran; def ",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:12546,Modifiability,config,config,12546,"lf.ptrace_sel != []):; _init_ptrace_stuff(self.ptrace_sel); _init_hamilt(); if (config.c_num != 0):; _init_c_ops(); if (config.e_num != 0):; _init_e_ops(); # set options; qtf90.qutraj_run.n_c_ops = config.c_num; qtf90.qutraj_run.n_e_ops = config.e_num; qtf90.qutraj_run.ntraj = ntraj; qtf90.qutraj_run.unravel_type = self.unravel_type; qtf90.qutraj_run.average_states = config.options.average_states; qtf90.qutraj_run.average_expect = config.options.average_expect; qtf90.qutraj_run.init_result(config.psi0_shape[0],; config.options.atol,; config.options.rtol, mf=self.mf,; norm_steps=config.norm_steps,; norm_tol=config.norm_tol); # set optional arguments; qtf90.qutraj_run.order = config.options.order; qtf90.qutraj_run.nsteps = config.options.nsteps; qtf90.qutraj_run.first_step = config.options.first_step; qtf90.qutraj_run.min_step = config.options.min_step; qtf90.qutraj_run.max_step = config.options.max_step; qtf90.qutraj_run.norm_steps = config.options.norm_steps; qtf90.qutraj_run.norm_tol = config.options.norm_tol; # use sparse density matrices during computation?; qtf90.qutraj_run.rho_return_sparse = self.sparse_dms; # calculate entropy of reduced density matrice?; qtf90.qutraj_run.calc_entropy = self.calc_entropy; # run; show_progress = 1 if debug else 0; qtf90.qutraj_run.evolve(instanceno, rngseed, show_progress). # construct Result instance; sol = Result(); sol.ntraj = ntraj; # sol.col_times = qtf90.qutraj_run.col_times; # sol.col_which = qtf90.qutraj_run.col_which-1; sol.col_times, sol.col_which = self.get_collapses(ntraj); if (config.e_num == 0):; sol.states = self.get_states(len(config.tlist), ntraj); else:; sol.expect = self.get_expect(len(config.tlist), ntraj); if (self.calc_entropy):; sol.entropy = self.get_entropy(len(config.tlist)). if (not self.serial_run):; # put to queue; queue.put(sol); queue.join(). # deallocate stuff; # finalize(); return sol. # Routines for retrieving data data from fortran; def get_collapses(self, ntraj):. if debug:; print(inspect.st",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:12835,Modifiability,evolve,evolve,12835,"pe = self.unravel_type; qtf90.qutraj_run.average_states = config.options.average_states; qtf90.qutraj_run.average_expect = config.options.average_expect; qtf90.qutraj_run.init_result(config.psi0_shape[0],; config.options.atol,; config.options.rtol, mf=self.mf,; norm_steps=config.norm_steps,; norm_tol=config.norm_tol); # set optional arguments; qtf90.qutraj_run.order = config.options.order; qtf90.qutraj_run.nsteps = config.options.nsteps; qtf90.qutraj_run.first_step = config.options.first_step; qtf90.qutraj_run.min_step = config.options.min_step; qtf90.qutraj_run.max_step = config.options.max_step; qtf90.qutraj_run.norm_steps = config.options.norm_steps; qtf90.qutraj_run.norm_tol = config.options.norm_tol; # use sparse density matrices during computation?; qtf90.qutraj_run.rho_return_sparse = self.sparse_dms; # calculate entropy of reduced density matrice?; qtf90.qutraj_run.calc_entropy = self.calc_entropy; # run; show_progress = 1 if debug else 0; qtf90.qutraj_run.evolve(instanceno, rngseed, show_progress). # construct Result instance; sol = Result(); sol.ntraj = ntraj; # sol.col_times = qtf90.qutraj_run.col_times; # sol.col_which = qtf90.qutraj_run.col_which-1; sol.col_times, sol.col_which = self.get_collapses(ntraj); if (config.e_num == 0):; sol.states = self.get_states(len(config.tlist), ntraj); else:; sol.expect = self.get_expect(len(config.tlist), ntraj); if (self.calc_entropy):; sol.entropy = self.get_entropy(len(config.tlist)). if (not self.serial_run):; # put to queue; queue.put(sol); queue.join(). # deallocate stuff; # finalize(); return sol. # Routines for retrieving data data from fortran; def get_collapses(self, ntraj):. if debug:; print(inspect.stack()[0][3]). col_times = np.zeros((ntraj), dtype=np.ndarray); col_which = np.zeros((ntraj), dtype=np.ndarray); if (config.c_num == 0):; # no collapses; return col_times, col_which; for i in range(ntraj):; qtf90.qutraj_run.get_collapses(i + 1); times = qtf90.qutraj_run.col_times; which = qtf90.qutraj_run.col_whi",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:13099,Modifiability,config,config,13099,"g.options.rtol, mf=self.mf,; norm_steps=config.norm_steps,; norm_tol=config.norm_tol); # set optional arguments; qtf90.qutraj_run.order = config.options.order; qtf90.qutraj_run.nsteps = config.options.nsteps; qtf90.qutraj_run.first_step = config.options.first_step; qtf90.qutraj_run.min_step = config.options.min_step; qtf90.qutraj_run.max_step = config.options.max_step; qtf90.qutraj_run.norm_steps = config.options.norm_steps; qtf90.qutraj_run.norm_tol = config.options.norm_tol; # use sparse density matrices during computation?; qtf90.qutraj_run.rho_return_sparse = self.sparse_dms; # calculate entropy of reduced density matrice?; qtf90.qutraj_run.calc_entropy = self.calc_entropy; # run; show_progress = 1 if debug else 0; qtf90.qutraj_run.evolve(instanceno, rngseed, show_progress). # construct Result instance; sol = Result(); sol.ntraj = ntraj; # sol.col_times = qtf90.qutraj_run.col_times; # sol.col_which = qtf90.qutraj_run.col_which-1; sol.col_times, sol.col_which = self.get_collapses(ntraj); if (config.e_num == 0):; sol.states = self.get_states(len(config.tlist), ntraj); else:; sol.expect = self.get_expect(len(config.tlist), ntraj); if (self.calc_entropy):; sol.entropy = self.get_entropy(len(config.tlist)). if (not self.serial_run):; # put to queue; queue.put(sol); queue.join(). # deallocate stuff; # finalize(); return sol. # Routines for retrieving data data from fortran; def get_collapses(self, ntraj):. if debug:; print(inspect.stack()[0][3]). col_times = np.zeros((ntraj), dtype=np.ndarray); col_which = np.zeros((ntraj), dtype=np.ndarray); if (config.c_num == 0):; # no collapses; return col_times, col_which; for i in range(ntraj):; qtf90.qutraj_run.get_collapses(i + 1); times = qtf90.qutraj_run.col_times; which = qtf90.qutraj_run.col_which; if times is None:; times = np.array([]); if which is None:; which = np.array([]); else:; which = which - 1; col_times[i] = np.array(times, copy=True); col_which[i] = np.array(which, copy=True); return col_times, col_which. def ge",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:13153,Modifiability,config,config,13153,"norm_tol=config.norm_tol); # set optional arguments; qtf90.qutraj_run.order = config.options.order; qtf90.qutraj_run.nsteps = config.options.nsteps; qtf90.qutraj_run.first_step = config.options.first_step; qtf90.qutraj_run.min_step = config.options.min_step; qtf90.qutraj_run.max_step = config.options.max_step; qtf90.qutraj_run.norm_steps = config.options.norm_steps; qtf90.qutraj_run.norm_tol = config.options.norm_tol; # use sparse density matrices during computation?; qtf90.qutraj_run.rho_return_sparse = self.sparse_dms; # calculate entropy of reduced density matrice?; qtf90.qutraj_run.calc_entropy = self.calc_entropy; # run; show_progress = 1 if debug else 0; qtf90.qutraj_run.evolve(instanceno, rngseed, show_progress). # construct Result instance; sol = Result(); sol.ntraj = ntraj; # sol.col_times = qtf90.qutraj_run.col_times; # sol.col_which = qtf90.qutraj_run.col_which-1; sol.col_times, sol.col_which = self.get_collapses(ntraj); if (config.e_num == 0):; sol.states = self.get_states(len(config.tlist), ntraj); else:; sol.expect = self.get_expect(len(config.tlist), ntraj); if (self.calc_entropy):; sol.entropy = self.get_entropy(len(config.tlist)). if (not self.serial_run):; # put to queue; queue.put(sol); queue.join(). # deallocate stuff; # finalize(); return sol. # Routines for retrieving data data from fortran; def get_collapses(self, ntraj):. if debug:; print(inspect.stack()[0][3]). col_times = np.zeros((ntraj), dtype=np.ndarray); col_which = np.zeros((ntraj), dtype=np.ndarray); if (config.c_num == 0):; # no collapses; return col_times, col_which; for i in range(ntraj):; qtf90.qutraj_run.get_collapses(i + 1); times = qtf90.qutraj_run.col_times; which = qtf90.qutraj_run.col_which; if times is None:; times = np.array([]); if which is None:; which = np.array([]); else:; which = which - 1; col_times[i] = np.array(times, copy=True); col_which[i] = np.array(which, copy=True); return col_times, col_which. def get_states(self, nstep, ntraj):. if debug:; print(inspect.sta",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:13216,Modifiability,config,config,13216,"aj_run.order = config.options.order; qtf90.qutraj_run.nsteps = config.options.nsteps; qtf90.qutraj_run.first_step = config.options.first_step; qtf90.qutraj_run.min_step = config.options.min_step; qtf90.qutraj_run.max_step = config.options.max_step; qtf90.qutraj_run.norm_steps = config.options.norm_steps; qtf90.qutraj_run.norm_tol = config.options.norm_tol; # use sparse density matrices during computation?; qtf90.qutraj_run.rho_return_sparse = self.sparse_dms; # calculate entropy of reduced density matrice?; qtf90.qutraj_run.calc_entropy = self.calc_entropy; # run; show_progress = 1 if debug else 0; qtf90.qutraj_run.evolve(instanceno, rngseed, show_progress). # construct Result instance; sol = Result(); sol.ntraj = ntraj; # sol.col_times = qtf90.qutraj_run.col_times; # sol.col_which = qtf90.qutraj_run.col_which-1; sol.col_times, sol.col_which = self.get_collapses(ntraj); if (config.e_num == 0):; sol.states = self.get_states(len(config.tlist), ntraj); else:; sol.expect = self.get_expect(len(config.tlist), ntraj); if (self.calc_entropy):; sol.entropy = self.get_entropy(len(config.tlist)). if (not self.serial_run):; # put to queue; queue.put(sol); queue.join(). # deallocate stuff; # finalize(); return sol. # Routines for retrieving data data from fortran; def get_collapses(self, ntraj):. if debug:; print(inspect.stack()[0][3]). col_times = np.zeros((ntraj), dtype=np.ndarray); col_which = np.zeros((ntraj), dtype=np.ndarray); if (config.c_num == 0):; # no collapses; return col_times, col_which; for i in range(ntraj):; qtf90.qutraj_run.get_collapses(i + 1); times = qtf90.qutraj_run.col_times; which = qtf90.qutraj_run.col_which; if times is None:; times = np.array([]); if which is None:; which = np.array([]); else:; which = which - 1; col_times[i] = np.array(times, copy=True); col_which[i] = np.array(which, copy=True); return col_times, col_which. def get_states(self, nstep, ntraj):. if debug:; print(inspect.stack()[0][3]). from scipy.sparse import csr_matrix; if (config.op",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:13299,Modifiability,config,config,13299,"ps; qtf90.qutraj_run.first_step = config.options.first_step; qtf90.qutraj_run.min_step = config.options.min_step; qtf90.qutraj_run.max_step = config.options.max_step; qtf90.qutraj_run.norm_steps = config.options.norm_steps; qtf90.qutraj_run.norm_tol = config.options.norm_tol; # use sparse density matrices during computation?; qtf90.qutraj_run.rho_return_sparse = self.sparse_dms; # calculate entropy of reduced density matrice?; qtf90.qutraj_run.calc_entropy = self.calc_entropy; # run; show_progress = 1 if debug else 0; qtf90.qutraj_run.evolve(instanceno, rngseed, show_progress). # construct Result instance; sol = Result(); sol.ntraj = ntraj; # sol.col_times = qtf90.qutraj_run.col_times; # sol.col_which = qtf90.qutraj_run.col_which-1; sol.col_times, sol.col_which = self.get_collapses(ntraj); if (config.e_num == 0):; sol.states = self.get_states(len(config.tlist), ntraj); else:; sol.expect = self.get_expect(len(config.tlist), ntraj); if (self.calc_entropy):; sol.entropy = self.get_entropy(len(config.tlist)). if (not self.serial_run):; # put to queue; queue.put(sol); queue.join(). # deallocate stuff; # finalize(); return sol. # Routines for retrieving data data from fortran; def get_collapses(self, ntraj):. if debug:; print(inspect.stack()[0][3]). col_times = np.zeros((ntraj), dtype=np.ndarray); col_which = np.zeros((ntraj), dtype=np.ndarray); if (config.c_num == 0):; # no collapses; return col_times, col_which; for i in range(ntraj):; qtf90.qutraj_run.get_collapses(i + 1); times = qtf90.qutraj_run.col_times; which = qtf90.qutraj_run.col_which; if times is None:; times = np.array([]); if which is None:; which = np.array([]); else:; which = which - 1; col_times[i] = np.array(times, copy=True); col_which[i] = np.array(which, copy=True); return col_times, col_which. def get_states(self, nstep, ntraj):. if debug:; print(inspect.stack()[0][3]). from scipy.sparse import csr_matrix; if (config.options.average_states):; states = np.array([Qobj()] * nstep); if (self.sparse_dms):;",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:13660,Modifiability,config,config,13660," = self.sparse_dms; # calculate entropy of reduced density matrice?; qtf90.qutraj_run.calc_entropy = self.calc_entropy; # run; show_progress = 1 if debug else 0; qtf90.qutraj_run.evolve(instanceno, rngseed, show_progress). # construct Result instance; sol = Result(); sol.ntraj = ntraj; # sol.col_times = qtf90.qutraj_run.col_times; # sol.col_which = qtf90.qutraj_run.col_which-1; sol.col_times, sol.col_which = self.get_collapses(ntraj); if (config.e_num == 0):; sol.states = self.get_states(len(config.tlist), ntraj); else:; sol.expect = self.get_expect(len(config.tlist), ntraj); if (self.calc_entropy):; sol.entropy = self.get_entropy(len(config.tlist)). if (not self.serial_run):; # put to queue; queue.put(sol); queue.join(). # deallocate stuff; # finalize(); return sol. # Routines for retrieving data data from fortran; def get_collapses(self, ntraj):. if debug:; print(inspect.stack()[0][3]). col_times = np.zeros((ntraj), dtype=np.ndarray); col_which = np.zeros((ntraj), dtype=np.ndarray); if (config.c_num == 0):; # no collapses; return col_times, col_which; for i in range(ntraj):; qtf90.qutraj_run.get_collapses(i + 1); times = qtf90.qutraj_run.col_times; which = qtf90.qutraj_run.col_which; if times is None:; times = np.array([]); if which is None:; which = np.array([]); else:; which = which - 1; col_times[i] = np.array(times, copy=True); col_which[i] = np.array(which, copy=True); return col_times, col_which. def get_states(self, nstep, ntraj):. if debug:; print(inspect.stack()[0][3]). from scipy.sparse import csr_matrix; if (config.options.average_states):; states = np.array([Qobj()] * nstep); if (self.sparse_dms):; # averaged sparse density matrices; for i in range(nstep):; qtf90.qutraj_run.get_rho_sparse(i + 1); val = qtf90.qutraj_run.csr_val; col = qtf90.qutraj_run.csr_col - 1; ptr = qtf90.qutraj_run.csr_ptr - 1; m = qtf90.qutraj_run.csr_nrows; k = qtf90.qutraj_run.csr_ncols; states[i] = Qobj(csr_matrix((val, col, ptr),; (m, k)).toarray(),; dims=self.dm_dims, shape=se",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:14203,Modifiability,config,config,14203,"ct = self.get_expect(len(config.tlist), ntraj); if (self.calc_entropy):; sol.entropy = self.get_entropy(len(config.tlist)). if (not self.serial_run):; # put to queue; queue.put(sol); queue.join(). # deallocate stuff; # finalize(); return sol. # Routines for retrieving data data from fortran; def get_collapses(self, ntraj):. if debug:; print(inspect.stack()[0][3]). col_times = np.zeros((ntraj), dtype=np.ndarray); col_which = np.zeros((ntraj), dtype=np.ndarray); if (config.c_num == 0):; # no collapses; return col_times, col_which; for i in range(ntraj):; qtf90.qutraj_run.get_collapses(i + 1); times = qtf90.qutraj_run.col_times; which = qtf90.qutraj_run.col_which; if times is None:; times = np.array([]); if which is None:; which = np.array([]); else:; which = which - 1; col_times[i] = np.array(times, copy=True); col_which[i] = np.array(which, copy=True); return col_times, col_which. def get_states(self, nstep, ntraj):. if debug:; print(inspect.stack()[0][3]). from scipy.sparse import csr_matrix; if (config.options.average_states):; states = np.array([Qobj()] * nstep); if (self.sparse_dms):; # averaged sparse density matrices; for i in range(nstep):; qtf90.qutraj_run.get_rho_sparse(i + 1); val = qtf90.qutraj_run.csr_val; col = qtf90.qutraj_run.csr_col - 1; ptr = qtf90.qutraj_run.csr_ptr - 1; m = qtf90.qutraj_run.csr_nrows; k = qtf90.qutraj_run.csr_ncols; states[i] = Qobj(csr_matrix((val, col, ptr),; (m, k)).toarray(),; dims=self.dm_dims, shape=self.dm_shape); else:; # averaged dense density matrices; for i in range(nstep):; states[i] = Qobj(qtf90.qutraj_run.sol[0, i, :, :],; dims=self.dm_dims, shape=self.dm_shape); else:; # all trajectories as kets; if (ntraj == 1):; states = np.array([Qobj()] * nstep, dtype=object); for i in range(nstep):; states[i] = Qobj(np.matrix(; qtf90.qutraj_run.sol[0, 0, i, :]).transpose(),; dims=self.psi0_dims, shape=self.psi0_shape); else:; states = np.array([np.array([Qobj()] * nstep, dtype=object)] *; ntraj); for traj in range(ntraj):; for i ",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:15438,Modifiability,config,config,15438,".qutraj_run.csr_col - 1; ptr = qtf90.qutraj_run.csr_ptr - 1; m = qtf90.qutraj_run.csr_nrows; k = qtf90.qutraj_run.csr_ncols; states[i] = Qobj(csr_matrix((val, col, ptr),; (m, k)).toarray(),; dims=self.dm_dims, shape=self.dm_shape); else:; # averaged dense density matrices; for i in range(nstep):; states[i] = Qobj(qtf90.qutraj_run.sol[0, i, :, :],; dims=self.dm_dims, shape=self.dm_shape); else:; # all trajectories as kets; if (ntraj == 1):; states = np.array([Qobj()] * nstep, dtype=object); for i in range(nstep):; states[i] = Qobj(np.matrix(; qtf90.qutraj_run.sol[0, 0, i, :]).transpose(),; dims=self.psi0_dims, shape=self.psi0_shape); else:; states = np.array([np.array([Qobj()] * nstep, dtype=object)] *; ntraj); for traj in range(ntraj):; for i in range(nstep):; states[traj][i] = Qobj(np.matrix(; qtf90.qutraj_run.sol[0, traj, i, :]).transpose(),; dims=self.psi0_dims, shape=self.psi0_shape); return states. def get_expect(self, nstep, ntraj):. if debug:; print(inspect.stack()[0][3]). if (config.options.average_expect):; expect = []; for j in range(config.e_num):; if config.e_ops_isherm[j]:; expect += [np.real(qtf90.qutraj_run.sol[j, 0, :, 0])]; else:; expect += [qtf90.qutraj_run.sol[j, 0, :, 0]]; else:; expect = np.array([[np.array([0. + 0.j] * nstep)] *; config.e_num] * ntraj); for j in range(config.e_num):; expect[:, j, :] = qtf90.qutraj_run.sol[j, :, :, 0]; return expect. def get_entropy(self, nstep):. if debug:; print(inspect.stack()[0][3]). if (not self.calc_entropy):; raise Exception('get_entropy: calc_entropy=False. Aborting.'); entropy = np.array([0.] * nstep); entropy[:] = qtf90.qutraj_run.reduced_state_entropy[:]; return entropy. def finalize():; # not in use... if debug:; print(inspect.stack()[0][3]). qtf90.qutraj_run.finalize_work(); qtf90.qutraj_run.finalize_sol(). def _gather(sols):; # gather list of Result objects, sols, into one.; sol = Result(); # sol = sols[0]; ntraj = sum([a.ntraj for a in sols]); sol.col_times = np.zeros((ntraj), dtype=np.ndarray); s",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:15499,Modifiability,config,config,15499,"raj_run.csr_ptr - 1; m = qtf90.qutraj_run.csr_nrows; k = qtf90.qutraj_run.csr_ncols; states[i] = Qobj(csr_matrix((val, col, ptr),; (m, k)).toarray(),; dims=self.dm_dims, shape=self.dm_shape); else:; # averaged dense density matrices; for i in range(nstep):; states[i] = Qobj(qtf90.qutraj_run.sol[0, i, :, :],; dims=self.dm_dims, shape=self.dm_shape); else:; # all trajectories as kets; if (ntraj == 1):; states = np.array([Qobj()] * nstep, dtype=object); for i in range(nstep):; states[i] = Qobj(np.matrix(; qtf90.qutraj_run.sol[0, 0, i, :]).transpose(),; dims=self.psi0_dims, shape=self.psi0_shape); else:; states = np.array([np.array([Qobj()] * nstep, dtype=object)] *; ntraj); for traj in range(ntraj):; for i in range(nstep):; states[traj][i] = Qobj(np.matrix(; qtf90.qutraj_run.sol[0, traj, i, :]).transpose(),; dims=self.psi0_dims, shape=self.psi0_shape); return states. def get_expect(self, nstep, ntraj):. if debug:; print(inspect.stack()[0][3]). if (config.options.average_expect):; expect = []; for j in range(config.e_num):; if config.e_ops_isherm[j]:; expect += [np.real(qtf90.qutraj_run.sol[j, 0, :, 0])]; else:; expect += [qtf90.qutraj_run.sol[j, 0, :, 0]]; else:; expect = np.array([[np.array([0. + 0.j] * nstep)] *; config.e_num] * ntraj); for j in range(config.e_num):; expect[:, j, :] = qtf90.qutraj_run.sol[j, :, :, 0]; return expect. def get_entropy(self, nstep):. if debug:; print(inspect.stack()[0][3]). if (not self.calc_entropy):; raise Exception('get_entropy: calc_entropy=False. Aborting.'); entropy = np.array([0.] * nstep); entropy[:] = qtf90.qutraj_run.reduced_state_entropy[:]; return entropy. def finalize():; # not in use... if debug:; print(inspect.stack()[0][3]). qtf90.qutraj_run.finalize_work(); qtf90.qutraj_run.finalize_sol(). def _gather(sols):; # gather list of Result objects, sols, into one.; sol = Result(); # sol = sols[0]; ntraj = sum([a.ntraj for a in sols]); sol.col_times = np.zeros((ntraj), dtype=np.ndarray); sol.col_which = np.zeros((ntraj), dtype=np",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:15518,Modifiability,config,config,15518,"j_run.csr_nrows; k = qtf90.qutraj_run.csr_ncols; states[i] = Qobj(csr_matrix((val, col, ptr),; (m, k)).toarray(),; dims=self.dm_dims, shape=self.dm_shape); else:; # averaged dense density matrices; for i in range(nstep):; states[i] = Qobj(qtf90.qutraj_run.sol[0, i, :, :],; dims=self.dm_dims, shape=self.dm_shape); else:; # all trajectories as kets; if (ntraj == 1):; states = np.array([Qobj()] * nstep, dtype=object); for i in range(nstep):; states[i] = Qobj(np.matrix(; qtf90.qutraj_run.sol[0, 0, i, :]).transpose(),; dims=self.psi0_dims, shape=self.psi0_shape); else:; states = np.array([np.array([Qobj()] * nstep, dtype=object)] *; ntraj); for traj in range(ntraj):; for i in range(nstep):; states[traj][i] = Qobj(np.matrix(; qtf90.qutraj_run.sol[0, traj, i, :]).transpose(),; dims=self.psi0_dims, shape=self.psi0_shape); return states. def get_expect(self, nstep, ntraj):. if debug:; print(inspect.stack()[0][3]). if (config.options.average_expect):; expect = []; for j in range(config.e_num):; if config.e_ops_isherm[j]:; expect += [np.real(qtf90.qutraj_run.sol[j, 0, :, 0])]; else:; expect += [qtf90.qutraj_run.sol[j, 0, :, 0]]; else:; expect = np.array([[np.array([0. + 0.j] * nstep)] *; config.e_num] * ntraj); for j in range(config.e_num):; expect[:, j, :] = qtf90.qutraj_run.sol[j, :, :, 0]; return expect. def get_entropy(self, nstep):. if debug:; print(inspect.stack()[0][3]). if (not self.calc_entropy):; raise Exception('get_entropy: calc_entropy=False. Aborting.'); entropy = np.array([0.] * nstep); entropy[:] = qtf90.qutraj_run.reduced_state_entropy[:]; return entropy. def finalize():; # not in use... if debug:; print(inspect.stack()[0][3]). qtf90.qutraj_run.finalize_work(); qtf90.qutraj_run.finalize_sol(). def _gather(sols):; # gather list of Result objects, sols, into one.; sol = Result(); # sol = sols[0]; ntraj = sum([a.ntraj for a in sols]); sol.col_times = np.zeros((ntraj), dtype=np.ndarray); sol.col_which = np.zeros((ntraj), dtype=np.ndarray); sol.col_times[0:sols[0].n",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:15711,Modifiability,config,config,15711,"rices; for i in range(nstep):; states[i] = Qobj(qtf90.qutraj_run.sol[0, i, :, :],; dims=self.dm_dims, shape=self.dm_shape); else:; # all trajectories as kets; if (ntraj == 1):; states = np.array([Qobj()] * nstep, dtype=object); for i in range(nstep):; states[i] = Qobj(np.matrix(; qtf90.qutraj_run.sol[0, 0, i, :]).transpose(),; dims=self.psi0_dims, shape=self.psi0_shape); else:; states = np.array([np.array([Qobj()] * nstep, dtype=object)] *; ntraj); for traj in range(ntraj):; for i in range(nstep):; states[traj][i] = Qobj(np.matrix(; qtf90.qutraj_run.sol[0, traj, i, :]).transpose(),; dims=self.psi0_dims, shape=self.psi0_shape); return states. def get_expect(self, nstep, ntraj):. if debug:; print(inspect.stack()[0][3]). if (config.options.average_expect):; expect = []; for j in range(config.e_num):; if config.e_ops_isherm[j]:; expect += [np.real(qtf90.qutraj_run.sol[j, 0, :, 0])]; else:; expect += [qtf90.qutraj_run.sol[j, 0, :, 0]]; else:; expect = np.array([[np.array([0. + 0.j] * nstep)] *; config.e_num] * ntraj); for j in range(config.e_num):; expect[:, j, :] = qtf90.qutraj_run.sol[j, :, :, 0]; return expect. def get_entropy(self, nstep):. if debug:; print(inspect.stack()[0][3]). if (not self.calc_entropy):; raise Exception('get_entropy: calc_entropy=False. Aborting.'); entropy = np.array([0.] * nstep); entropy[:] = qtf90.qutraj_run.reduced_state_entropy[:]; return entropy. def finalize():; # not in use... if debug:; print(inspect.stack()[0][3]). qtf90.qutraj_run.finalize_work(); qtf90.qutraj_run.finalize_sol(). def _gather(sols):; # gather list of Result objects, sols, into one.; sol = Result(); # sol = sols[0]; ntraj = sum([a.ntraj for a in sols]); sol.col_times = np.zeros((ntraj), dtype=np.ndarray); sol.col_which = np.zeros((ntraj), dtype=np.ndarray); sol.col_times[0:sols[0].ntraj] = sols[0].col_times; sol.col_which[0:sols[0].ntraj] = sols[0].col_which; sol.states = np.array(sols[0].states, dtype=object); sol.expect = np.array(sols[0].expect); if (hasattr(sols[0],",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:15750,Modifiability,config,config,15750,"states[i] = Qobj(qtf90.qutraj_run.sol[0, i, :, :],; dims=self.dm_dims, shape=self.dm_shape); else:; # all trajectories as kets; if (ntraj == 1):; states = np.array([Qobj()] * nstep, dtype=object); for i in range(nstep):; states[i] = Qobj(np.matrix(; qtf90.qutraj_run.sol[0, 0, i, :]).transpose(),; dims=self.psi0_dims, shape=self.psi0_shape); else:; states = np.array([np.array([Qobj()] * nstep, dtype=object)] *; ntraj); for traj in range(ntraj):; for i in range(nstep):; states[traj][i] = Qobj(np.matrix(; qtf90.qutraj_run.sol[0, traj, i, :]).transpose(),; dims=self.psi0_dims, shape=self.psi0_shape); return states. def get_expect(self, nstep, ntraj):. if debug:; print(inspect.stack()[0][3]). if (config.options.average_expect):; expect = []; for j in range(config.e_num):; if config.e_ops_isherm[j]:; expect += [np.real(qtf90.qutraj_run.sol[j, 0, :, 0])]; else:; expect += [qtf90.qutraj_run.sol[j, 0, :, 0]]; else:; expect = np.array([[np.array([0. + 0.j] * nstep)] *; config.e_num] * ntraj); for j in range(config.e_num):; expect[:, j, :] = qtf90.qutraj_run.sol[j, :, :, 0]; return expect. def get_entropy(self, nstep):. if debug:; print(inspect.stack()[0][3]). if (not self.calc_entropy):; raise Exception('get_entropy: calc_entropy=False. Aborting.'); entropy = np.array([0.] * nstep); entropy[:] = qtf90.qutraj_run.reduced_state_entropy[:]; return entropy. def finalize():; # not in use... if debug:; print(inspect.stack()[0][3]). qtf90.qutraj_run.finalize_work(); qtf90.qutraj_run.finalize_sol(). def _gather(sols):; # gather list of Result objects, sols, into one.; sol = Result(); # sol = sols[0]; ntraj = sum([a.ntraj for a in sols]); sol.col_times = np.zeros((ntraj), dtype=np.ndarray); sol.col_which = np.zeros((ntraj), dtype=np.ndarray); sol.col_times[0:sols[0].ntraj] = sols[0].col_times; sol.col_which[0:sols[0].ntraj] = sols[0].col_which; sol.states = np.array(sols[0].states, dtype=object); sol.expect = np.array(sols[0].expect); if (hasattr(sols[0], 'entropy')):; sol.entropy = np",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:16980,Modifiability,config,config,16980,"y=False. Aborting.'); entropy = np.array([0.] * nstep); entropy[:] = qtf90.qutraj_run.reduced_state_entropy[:]; return entropy. def finalize():; # not in use... if debug:; print(inspect.stack()[0][3]). qtf90.qutraj_run.finalize_work(); qtf90.qutraj_run.finalize_sol(). def _gather(sols):; # gather list of Result objects, sols, into one.; sol = Result(); # sol = sols[0]; ntraj = sum([a.ntraj for a in sols]); sol.col_times = np.zeros((ntraj), dtype=np.ndarray); sol.col_which = np.zeros((ntraj), dtype=np.ndarray); sol.col_times[0:sols[0].ntraj] = sols[0].col_times; sol.col_which[0:sols[0].ntraj] = sols[0].col_which; sol.states = np.array(sols[0].states, dtype=object); sol.expect = np.array(sols[0].expect); if (hasattr(sols[0], 'entropy')):; sol.entropy = np.array(sols[0].entropy); sofar = 0; for j in range(1, len(sols)):; sofar = sofar + sols[j - 1].ntraj; sol.col_times[sofar:sofar + sols[j].ntraj] = (; sols[j].col_times); sol.col_which[sofar:sofar + sols[j].ntraj] = (; sols[j].col_which); if (config.e_num == 0):; if (config.options.average_states):; # collect states, averaged over trajectories; sol.states += np.array(sols[j].states); else:; # collect states, all trajectories; sol.states = np.vstack((sol.states,; np.array(sols[j].states))); else:; if (config.options.average_expect):; # collect expectation values, averaged; for i in range(config.e_num):; sol.expect[i] += np.array(sols[j].expect[i]); else:; # collect expectation values, all trajectories; sol.expect = np.vstack((sol.expect,; np.array(sols[j].expect))); if (hasattr(sols[j], 'entropy')):; if (config.options.average_states or; config.options.average_expect):; # collect entropy values, averaged; sol.entropy += np.array(sols[j].entropy); else:; # collect entropy values, all trajectories; sol.entropy = np.vstack((sol.entropy,; np.array(sols[j].entropy))); if (config.options.average_states or config.options.average_expect):; if (config.e_num == 0):; sol.states = sol.states / len(sols); else:; sol.expect = list(sol",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:17005,Modifiability,config,config,17005,"tropy = np.array([0.] * nstep); entropy[:] = qtf90.qutraj_run.reduced_state_entropy[:]; return entropy. def finalize():; # not in use... if debug:; print(inspect.stack()[0][3]). qtf90.qutraj_run.finalize_work(); qtf90.qutraj_run.finalize_sol(). def _gather(sols):; # gather list of Result objects, sols, into one.; sol = Result(); # sol = sols[0]; ntraj = sum([a.ntraj for a in sols]); sol.col_times = np.zeros((ntraj), dtype=np.ndarray); sol.col_which = np.zeros((ntraj), dtype=np.ndarray); sol.col_times[0:sols[0].ntraj] = sols[0].col_times; sol.col_which[0:sols[0].ntraj] = sols[0].col_which; sol.states = np.array(sols[0].states, dtype=object); sol.expect = np.array(sols[0].expect); if (hasattr(sols[0], 'entropy')):; sol.entropy = np.array(sols[0].entropy); sofar = 0; for j in range(1, len(sols)):; sofar = sofar + sols[j - 1].ntraj; sol.col_times[sofar:sofar + sols[j].ntraj] = (; sols[j].col_times); sol.col_which[sofar:sofar + sols[j].ntraj] = (; sols[j].col_which); if (config.e_num == 0):; if (config.options.average_states):; # collect states, averaged over trajectories; sol.states += np.array(sols[j].states); else:; # collect states, all trajectories; sol.states = np.vstack((sol.states,; np.array(sols[j].states))); else:; if (config.options.average_expect):; # collect expectation values, averaged; for i in range(config.e_num):; sol.expect[i] += np.array(sols[j].expect[i]); else:; # collect expectation values, all trajectories; sol.expect = np.vstack((sol.expect,; np.array(sols[j].expect))); if (hasattr(sols[j], 'entropy')):; if (config.options.average_states or; config.options.average_expect):; # collect entropy values, averaged; sol.entropy += np.array(sols[j].entropy); else:; # collect entropy values, all trajectories; sol.entropy = np.vstack((sol.entropy,; np.array(sols[j].entropy))); if (config.options.average_states or config.options.average_expect):; if (config.e_num == 0):; sol.states = sol.states / len(sols); else:; sol.expect = list(sol.expect / len(sols)); in",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:17243,Modifiability,config,config,17243,"e_sol(). def _gather(sols):; # gather list of Result objects, sols, into one.; sol = Result(); # sol = sols[0]; ntraj = sum([a.ntraj for a in sols]); sol.col_times = np.zeros((ntraj), dtype=np.ndarray); sol.col_which = np.zeros((ntraj), dtype=np.ndarray); sol.col_times[0:sols[0].ntraj] = sols[0].col_times; sol.col_which[0:sols[0].ntraj] = sols[0].col_which; sol.states = np.array(sols[0].states, dtype=object); sol.expect = np.array(sols[0].expect); if (hasattr(sols[0], 'entropy')):; sol.entropy = np.array(sols[0].entropy); sofar = 0; for j in range(1, len(sols)):; sofar = sofar + sols[j - 1].ntraj; sol.col_times[sofar:sofar + sols[j].ntraj] = (; sols[j].col_times); sol.col_which[sofar:sofar + sols[j].ntraj] = (; sols[j].col_which); if (config.e_num == 0):; if (config.options.average_states):; # collect states, averaged over trajectories; sol.states += np.array(sols[j].states); else:; # collect states, all trajectories; sol.states = np.vstack((sol.states,; np.array(sols[j].states))); else:; if (config.options.average_expect):; # collect expectation values, averaged; for i in range(config.e_num):; sol.expect[i] += np.array(sols[j].expect[i]); else:; # collect expectation values, all trajectories; sol.expect = np.vstack((sol.expect,; np.array(sols[j].expect))); if (hasattr(sols[j], 'entropy')):; if (config.options.average_states or; config.options.average_expect):; # collect entropy values, averaged; sol.entropy += np.array(sols[j].entropy); else:; # collect entropy values, all trajectories; sol.entropy = np.vstack((sol.entropy,; np.array(sols[j].entropy))); if (config.options.average_states or config.options.average_expect):; if (config.e_num == 0):; sol.states = sol.states / len(sols); else:; sol.expect = list(sol.expect / len(sols)); inds = np.where(config.e_ops_isherm)[0]; for jj in inds:; sol.expect[jj] = np.real(sol.expect[jj]); if (hasattr(sols[0], 'entropy')):; sol.entropy = sol.entropy / len(sols). # convert sol.expect array to list and fix dtypes of arrays; if ",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:17331,Modifiability,config,config,17331,"ols, into one.; sol = Result(); # sol = sols[0]; ntraj = sum([a.ntraj for a in sols]); sol.col_times = np.zeros((ntraj), dtype=np.ndarray); sol.col_which = np.zeros((ntraj), dtype=np.ndarray); sol.col_times[0:sols[0].ntraj] = sols[0].col_times; sol.col_which[0:sols[0].ntraj] = sols[0].col_which; sol.states = np.array(sols[0].states, dtype=object); sol.expect = np.array(sols[0].expect); if (hasattr(sols[0], 'entropy')):; sol.entropy = np.array(sols[0].entropy); sofar = 0; for j in range(1, len(sols)):; sofar = sofar + sols[j - 1].ntraj; sol.col_times[sofar:sofar + sols[j].ntraj] = (; sols[j].col_times); sol.col_which[sofar:sofar + sols[j].ntraj] = (; sols[j].col_which); if (config.e_num == 0):; if (config.options.average_states):; # collect states, averaged over trajectories; sol.states += np.array(sols[j].states); else:; # collect states, all trajectories; sol.states = np.vstack((sol.states,; np.array(sols[j].states))); else:; if (config.options.average_expect):; # collect expectation values, averaged; for i in range(config.e_num):; sol.expect[i] += np.array(sols[j].expect[i]); else:; # collect expectation values, all trajectories; sol.expect = np.vstack((sol.expect,; np.array(sols[j].expect))); if (hasattr(sols[j], 'entropy')):; if (config.options.average_states or; config.options.average_expect):; # collect entropy values, averaged; sol.entropy += np.array(sols[j].entropy); else:; # collect entropy values, all trajectories; sol.entropy = np.vstack((sol.entropy,; np.array(sols[j].entropy))); if (config.options.average_states or config.options.average_expect):; if (config.e_num == 0):; sol.states = sol.states / len(sols); else:; sol.expect = list(sol.expect / len(sols)); inds = np.where(config.e_ops_isherm)[0]; for jj in inds:; sol.expect[jj] = np.real(sol.expect[jj]); if (hasattr(sols[0], 'entropy')):; sol.entropy = sol.entropy / len(sols). # convert sol.expect array to list and fix dtypes of arrays; if (not config.options.average_expect) and config.e_num != 0:; te",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:17552,Modifiability,config,config,17552,"].col_times; sol.col_which[0:sols[0].ntraj] = sols[0].col_which; sol.states = np.array(sols[0].states, dtype=object); sol.expect = np.array(sols[0].expect); if (hasattr(sols[0], 'entropy')):; sol.entropy = np.array(sols[0].entropy); sofar = 0; for j in range(1, len(sols)):; sofar = sofar + sols[j - 1].ntraj; sol.col_times[sofar:sofar + sols[j].ntraj] = (; sols[j].col_times); sol.col_which[sofar:sofar + sols[j].ntraj] = (; sols[j].col_which); if (config.e_num == 0):; if (config.options.average_states):; # collect states, averaged over trajectories; sol.states += np.array(sols[j].states); else:; # collect states, all trajectories; sol.states = np.vstack((sol.states,; np.array(sols[j].states))); else:; if (config.options.average_expect):; # collect expectation values, averaged; for i in range(config.e_num):; sol.expect[i] += np.array(sols[j].expect[i]); else:; # collect expectation values, all trajectories; sol.expect = np.vstack((sol.expect,; np.array(sols[j].expect))); if (hasattr(sols[j], 'entropy')):; if (config.options.average_states or; config.options.average_expect):; # collect entropy values, averaged; sol.entropy += np.array(sols[j].entropy); else:; # collect entropy values, all trajectories; sol.entropy = np.vstack((sol.entropy,; np.array(sols[j].entropy))); if (config.options.average_states or config.options.average_expect):; if (config.e_num == 0):; sol.states = sol.states / len(sols); else:; sol.expect = list(sol.expect / len(sols)); inds = np.where(config.e_ops_isherm)[0]; for jj in inds:; sol.expect[jj] = np.real(sol.expect[jj]); if (hasattr(sols[0], 'entropy')):; sol.entropy = sol.entropy / len(sols). # convert sol.expect array to list and fix dtypes of arrays; if (not config.options.average_expect) and config.e_num != 0:; temp = [list(sol.expect[ii]) for ii in range(ntraj)]; for ii in range(ntraj):; for jj in np.where(config.e_ops_isherm)[0]:; temp[ii][jj] = np.real(temp[ii][jj]); sol.expect = temp; # convert to list/array to be consistent with qutip mc",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:17586,Modifiability,config,config,17586,"[0].col_which; sol.states = np.array(sols[0].states, dtype=object); sol.expect = np.array(sols[0].expect); if (hasattr(sols[0], 'entropy')):; sol.entropy = np.array(sols[0].entropy); sofar = 0; for j in range(1, len(sols)):; sofar = sofar + sols[j - 1].ntraj; sol.col_times[sofar:sofar + sols[j].ntraj] = (; sols[j].col_times); sol.col_which[sofar:sofar + sols[j].ntraj] = (; sols[j].col_which); if (config.e_num == 0):; if (config.options.average_states):; # collect states, averaged over trajectories; sol.states += np.array(sols[j].states); else:; # collect states, all trajectories; sol.states = np.vstack((sol.states,; np.array(sols[j].states))); else:; if (config.options.average_expect):; # collect expectation values, averaged; for i in range(config.e_num):; sol.expect[i] += np.array(sols[j].expect[i]); else:; # collect expectation values, all trajectories; sol.expect = np.vstack((sol.expect,; np.array(sols[j].expect))); if (hasattr(sols[j], 'entropy')):; if (config.options.average_states or; config.options.average_expect):; # collect entropy values, averaged; sol.entropy += np.array(sols[j].entropy); else:; # collect entropy values, all trajectories; sol.entropy = np.vstack((sol.entropy,; np.array(sols[j].entropy))); if (config.options.average_states or config.options.average_expect):; if (config.e_num == 0):; sol.states = sol.states / len(sols); else:; sol.expect = list(sol.expect / len(sols)); inds = np.where(config.e_ops_isherm)[0]; for jj in inds:; sol.expect[jj] = np.real(sol.expect[jj]); if (hasattr(sols[0], 'entropy')):; sol.entropy = sol.entropy / len(sols). # convert sol.expect array to list and fix dtypes of arrays; if (not config.options.average_expect) and config.e_num != 0:; temp = [list(sol.expect[ii]) for ii in range(ntraj)]; for ii in range(ntraj):; for jj in np.where(config.e_ops_isherm)[0]:; temp[ii][jj] = np.real(temp[ii][jj]); sol.expect = temp; # convert to list/array to be consistent with qutip mcsolve; sol.states = list(sol.states); return sol.",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:17820,Modifiability,config,config,17820,"far + sols[j - 1].ntraj; sol.col_times[sofar:sofar + sols[j].ntraj] = (; sols[j].col_times); sol.col_which[sofar:sofar + sols[j].ntraj] = (; sols[j].col_which); if (config.e_num == 0):; if (config.options.average_states):; # collect states, averaged over trajectories; sol.states += np.array(sols[j].states); else:; # collect states, all trajectories; sol.states = np.vstack((sol.states,; np.array(sols[j].states))); else:; if (config.options.average_expect):; # collect expectation values, averaged; for i in range(config.e_num):; sol.expect[i] += np.array(sols[j].expect[i]); else:; # collect expectation values, all trajectories; sol.expect = np.vstack((sol.expect,; np.array(sols[j].expect))); if (hasattr(sols[j], 'entropy')):; if (config.options.average_states or; config.options.average_expect):; # collect entropy values, averaged; sol.entropy += np.array(sols[j].entropy); else:; # collect entropy values, all trajectories; sol.entropy = np.vstack((sol.entropy,; np.array(sols[j].entropy))); if (config.options.average_states or config.options.average_expect):; if (config.e_num == 0):; sol.states = sol.states / len(sols); else:; sol.expect = list(sol.expect / len(sols)); inds = np.where(config.e_ops_isherm)[0]; for jj in inds:; sol.expect[jj] = np.real(sol.expect[jj]); if (hasattr(sols[0], 'entropy')):; sol.entropy = sol.entropy / len(sols). # convert sol.expect array to list and fix dtypes of arrays; if (not config.options.average_expect) and config.e_num != 0:; temp = [list(sol.expect[ii]) for ii in range(ntraj)]; for ii in range(ntraj):; for jj in np.where(config.e_ops_isherm)[0]:; temp[ii][jj] = np.real(temp[ii][jj]); sol.expect = temp; # convert to list/array to be consistent with qutip mcsolve; sol.states = list(sol.states); return sol. #; # Functions to initialize the problem in fortran; #; def _init_tlist():; Of = _realarray_to_fortran(config.tlist); qtf90.qutraj_run.init_tlist(Of, np.size(Of)). def _init_psi0():; # Of = _qobj_to_fortranfull(config.psi0); Of = _comp",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:17853,Modifiability,config,config,17853,"_times[sofar:sofar + sols[j].ntraj] = (; sols[j].col_times); sol.col_which[sofar:sofar + sols[j].ntraj] = (; sols[j].col_which); if (config.e_num == 0):; if (config.options.average_states):; # collect states, averaged over trajectories; sol.states += np.array(sols[j].states); else:; # collect states, all trajectories; sol.states = np.vstack((sol.states,; np.array(sols[j].states))); else:; if (config.options.average_expect):; # collect expectation values, averaged; for i in range(config.e_num):; sol.expect[i] += np.array(sols[j].expect[i]); else:; # collect expectation values, all trajectories; sol.expect = np.vstack((sol.expect,; np.array(sols[j].expect))); if (hasattr(sols[j], 'entropy')):; if (config.options.average_states or; config.options.average_expect):; # collect entropy values, averaged; sol.entropy += np.array(sols[j].entropy); else:; # collect entropy values, all trajectories; sol.entropy = np.vstack((sol.entropy,; np.array(sols[j].entropy))); if (config.options.average_states or config.options.average_expect):; if (config.e_num == 0):; sol.states = sol.states / len(sols); else:; sol.expect = list(sol.expect / len(sols)); inds = np.where(config.e_ops_isherm)[0]; for jj in inds:; sol.expect[jj] = np.real(sol.expect[jj]); if (hasattr(sols[0], 'entropy')):; sol.entropy = sol.entropy / len(sols). # convert sol.expect array to list and fix dtypes of arrays; if (not config.options.average_expect) and config.e_num != 0:; temp = [list(sol.expect[ii]) for ii in range(ntraj)]; for ii in range(ntraj):; for jj in np.where(config.e_ops_isherm)[0]:; temp[ii][jj] = np.real(temp[ii][jj]); sol.expect = temp; # convert to list/array to be consistent with qutip mcsolve; sol.states = list(sol.states); return sol. #; # Functions to initialize the problem in fortran; #; def _init_tlist():; Of = _realarray_to_fortran(config.tlist); qtf90.qutraj_run.init_tlist(Of, np.size(Of)). def _init_psi0():; # Of = _qobj_to_fortranfull(config.psi0); Of = _complexarray_to_fortran(config.psi0)",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:17890,Modifiability,config,config,17890," = (; sols[j].col_times); sol.col_which[sofar:sofar + sols[j].ntraj] = (; sols[j].col_which); if (config.e_num == 0):; if (config.options.average_states):; # collect states, averaged over trajectories; sol.states += np.array(sols[j].states); else:; # collect states, all trajectories; sol.states = np.vstack((sol.states,; np.array(sols[j].states))); else:; if (config.options.average_expect):; # collect expectation values, averaged; for i in range(config.e_num):; sol.expect[i] += np.array(sols[j].expect[i]); else:; # collect expectation values, all trajectories; sol.expect = np.vstack((sol.expect,; np.array(sols[j].expect))); if (hasattr(sols[j], 'entropy')):; if (config.options.average_states or; config.options.average_expect):; # collect entropy values, averaged; sol.entropy += np.array(sols[j].entropy); else:; # collect entropy values, all trajectories; sol.entropy = np.vstack((sol.entropy,; np.array(sols[j].entropy))); if (config.options.average_states or config.options.average_expect):; if (config.e_num == 0):; sol.states = sol.states / len(sols); else:; sol.expect = list(sol.expect / len(sols)); inds = np.where(config.e_ops_isherm)[0]; for jj in inds:; sol.expect[jj] = np.real(sol.expect[jj]); if (hasattr(sols[0], 'entropy')):; sol.entropy = sol.entropy / len(sols). # convert sol.expect array to list and fix dtypes of arrays; if (not config.options.average_expect) and config.e_num != 0:; temp = [list(sol.expect[ii]) for ii in range(ntraj)]; for ii in range(ntraj):; for jj in np.where(config.e_ops_isherm)[0]:; temp[ii][jj] = np.real(temp[ii][jj]); sol.expect = temp; # convert to list/array to be consistent with qutip mcsolve; sol.states = list(sol.states); return sol. #; # Functions to initialize the problem in fortran; #; def _init_tlist():; Of = _realarray_to_fortran(config.tlist); qtf90.qutraj_run.init_tlist(Of, np.size(Of)). def _init_psi0():; # Of = _qobj_to_fortranfull(config.psi0); Of = _complexarray_to_fortran(config.psi0); qtf90.qutraj_run.init_psi0(Of, np",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:18014,Modifiability,config,config,18014,"tions.average_states):; # collect states, averaged over trajectories; sol.states += np.array(sols[j].states); else:; # collect states, all trajectories; sol.states = np.vstack((sol.states,; np.array(sols[j].states))); else:; if (config.options.average_expect):; # collect expectation values, averaged; for i in range(config.e_num):; sol.expect[i] += np.array(sols[j].expect[i]); else:; # collect expectation values, all trajectories; sol.expect = np.vstack((sol.expect,; np.array(sols[j].expect))); if (hasattr(sols[j], 'entropy')):; if (config.options.average_states or; config.options.average_expect):; # collect entropy values, averaged; sol.entropy += np.array(sols[j].entropy); else:; # collect entropy values, all trajectories; sol.entropy = np.vstack((sol.entropy,; np.array(sols[j].entropy))); if (config.options.average_states or config.options.average_expect):; if (config.e_num == 0):; sol.states = sol.states / len(sols); else:; sol.expect = list(sol.expect / len(sols)); inds = np.where(config.e_ops_isherm)[0]; for jj in inds:; sol.expect[jj] = np.real(sol.expect[jj]); if (hasattr(sols[0], 'entropy')):; sol.entropy = sol.entropy / len(sols). # convert sol.expect array to list and fix dtypes of arrays; if (not config.options.average_expect) and config.e_num != 0:; temp = [list(sol.expect[ii]) for ii in range(ntraj)]; for ii in range(ntraj):; for jj in np.where(config.e_ops_isherm)[0]:; temp[ii][jj] = np.real(temp[ii][jj]); sol.expect = temp; # convert to list/array to be consistent with qutip mcsolve; sol.states = list(sol.states); return sol. #; # Functions to initialize the problem in fortran; #; def _init_tlist():; Of = _realarray_to_fortran(config.tlist); qtf90.qutraj_run.init_tlist(Of, np.size(Of)). def _init_psi0():; # Of = _qobj_to_fortranfull(config.psi0); Of = _complexarray_to_fortran(config.psi0); qtf90.qutraj_run.init_psi0(Of, np.size(Of)). def _init_ptrace_stuff(sel):; psi0 = Qobj(config.psi0,; dims=config.psi0_dims,; shape=config.psi0_shape); qtf90.qutraj_r",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:18241,Modifiability,config,config,18241,"[j].states))); else:; if (config.options.average_expect):; # collect expectation values, averaged; for i in range(config.e_num):; sol.expect[i] += np.array(sols[j].expect[i]); else:; # collect expectation values, all trajectories; sol.expect = np.vstack((sol.expect,; np.array(sols[j].expect))); if (hasattr(sols[j], 'entropy')):; if (config.options.average_states or; config.options.average_expect):; # collect entropy values, averaged; sol.entropy += np.array(sols[j].entropy); else:; # collect entropy values, all trajectories; sol.entropy = np.vstack((sol.entropy,; np.array(sols[j].entropy))); if (config.options.average_states or config.options.average_expect):; if (config.e_num == 0):; sol.states = sol.states / len(sols); else:; sol.expect = list(sol.expect / len(sols)); inds = np.where(config.e_ops_isherm)[0]; for jj in inds:; sol.expect[jj] = np.real(sol.expect[jj]); if (hasattr(sols[0], 'entropy')):; sol.entropy = sol.entropy / len(sols). # convert sol.expect array to list and fix dtypes of arrays; if (not config.options.average_expect) and config.e_num != 0:; temp = [list(sol.expect[ii]) for ii in range(ntraj)]; for ii in range(ntraj):; for jj in np.where(config.e_ops_isherm)[0]:; temp[ii][jj] = np.real(temp[ii][jj]); sol.expect = temp; # convert to list/array to be consistent with qutip mcsolve; sol.states = list(sol.states); return sol. #; # Functions to initialize the problem in fortran; #; def _init_tlist():; Of = _realarray_to_fortran(config.tlist); qtf90.qutraj_run.init_tlist(Of, np.size(Of)). def _init_psi0():; # Of = _qobj_to_fortranfull(config.psi0); Of = _complexarray_to_fortran(config.psi0); qtf90.qutraj_run.init_psi0(Of, np.size(Of)). def _init_ptrace_stuff(sel):; psi0 = Qobj(config.psi0,; dims=config.psi0_dims,; shape=config.psi0_shape); qtf90.qutraj_run.init_ptrace_stuff(config.psi0_dims[0],; np.array(sel) + 1,; psi0.ptrace(sel).shape[0]). def _init_hamilt():; # construct effective non-Hermitian Hamiltonian; # H_eff = H - 0.5j*sum([c_ops[i].dag()*c_",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:18276,Modifiability,config,config,18276,"ect):; # collect expectation values, averaged; for i in range(config.e_num):; sol.expect[i] += np.array(sols[j].expect[i]); else:; # collect expectation values, all trajectories; sol.expect = np.vstack((sol.expect,; np.array(sols[j].expect))); if (hasattr(sols[j], 'entropy')):; if (config.options.average_states or; config.options.average_expect):; # collect entropy values, averaged; sol.entropy += np.array(sols[j].entropy); else:; # collect entropy values, all trajectories; sol.entropy = np.vstack((sol.entropy,; np.array(sols[j].entropy))); if (config.options.average_states or config.options.average_expect):; if (config.e_num == 0):; sol.states = sol.states / len(sols); else:; sol.expect = list(sol.expect / len(sols)); inds = np.where(config.e_ops_isherm)[0]; for jj in inds:; sol.expect[jj] = np.real(sol.expect[jj]); if (hasattr(sols[0], 'entropy')):; sol.entropy = sol.entropy / len(sols). # convert sol.expect array to list and fix dtypes of arrays; if (not config.options.average_expect) and config.e_num != 0:; temp = [list(sol.expect[ii]) for ii in range(ntraj)]; for ii in range(ntraj):; for jj in np.where(config.e_ops_isherm)[0]:; temp[ii][jj] = np.real(temp[ii][jj]); sol.expect = temp; # convert to list/array to be consistent with qutip mcsolve; sol.states = list(sol.states); return sol. #; # Functions to initialize the problem in fortran; #; def _init_tlist():; Of = _realarray_to_fortran(config.tlist); qtf90.qutraj_run.init_tlist(Of, np.size(Of)). def _init_psi0():; # Of = _qobj_to_fortranfull(config.psi0); Of = _complexarray_to_fortran(config.psi0); qtf90.qutraj_run.init_psi0(Of, np.size(Of)). def _init_ptrace_stuff(sel):; psi0 = Qobj(config.psi0,; dims=config.psi0_dims,; shape=config.psi0_shape); qtf90.qutraj_run.init_ptrace_stuff(config.psi0_dims[0],; np.array(sel) + 1,; psi0.ptrace(sel).shape[0]). def _init_hamilt():; # construct effective non-Hermitian Hamiltonian; # H_eff = H - 0.5j*sum([c_ops[i].dag()*c_ops[i]; # for i in range(len(c_ops))]); # Of = _qobj_",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:18394,Modifiability,config,config,18394,"lse:; # collect expectation values, all trajectories; sol.expect = np.vstack((sol.expect,; np.array(sols[j].expect))); if (hasattr(sols[j], 'entropy')):; if (config.options.average_states or; config.options.average_expect):; # collect entropy values, averaged; sol.entropy += np.array(sols[j].entropy); else:; # collect entropy values, all trajectories; sol.entropy = np.vstack((sol.entropy,; np.array(sols[j].entropy))); if (config.options.average_states or config.options.average_expect):; if (config.e_num == 0):; sol.states = sol.states / len(sols); else:; sol.expect = list(sol.expect / len(sols)); inds = np.where(config.e_ops_isherm)[0]; for jj in inds:; sol.expect[jj] = np.real(sol.expect[jj]); if (hasattr(sols[0], 'entropy')):; sol.entropy = sol.entropy / len(sols). # convert sol.expect array to list and fix dtypes of arrays; if (not config.options.average_expect) and config.e_num != 0:; temp = [list(sol.expect[ii]) for ii in range(ntraj)]; for ii in range(ntraj):; for jj in np.where(config.e_ops_isherm)[0]:; temp[ii][jj] = np.real(temp[ii][jj]); sol.expect = temp; # convert to list/array to be consistent with qutip mcsolve; sol.states = list(sol.states); return sol. #; # Functions to initialize the problem in fortran; #; def _init_tlist():; Of = _realarray_to_fortran(config.tlist); qtf90.qutraj_run.init_tlist(Of, np.size(Of)). def _init_psi0():; # Of = _qobj_to_fortranfull(config.psi0); Of = _complexarray_to_fortran(config.psi0); qtf90.qutraj_run.init_psi0(Of, np.size(Of)). def _init_ptrace_stuff(sel):; psi0 = Qobj(config.psi0,; dims=config.psi0_dims,; shape=config.psi0_shape); qtf90.qutraj_run.init_ptrace_stuff(config.psi0_dims[0],; np.array(sel) + 1,; psi0.ptrace(sel).shape[0]). def _init_hamilt():; # construct effective non-Hermitian Hamiltonian; # H_eff = H - 0.5j*sum([c_ops[i].dag()*c_ops[i]; # for i in range(len(c_ops))]); # Of = _qobj_to_fortrancsr(H_eff); # qtf90.qutraj_run.init_hamiltonian(Of[0],Of[1],; # Of[2],Of[3],Of[4]); d = np.size(config.psi0); qtf90",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:18684,Modifiability,config,config,18684,"y values, averaged; sol.entropy += np.array(sols[j].entropy); else:; # collect entropy values, all trajectories; sol.entropy = np.vstack((sol.entropy,; np.array(sols[j].entropy))); if (config.options.average_states or config.options.average_expect):; if (config.e_num == 0):; sol.states = sol.states / len(sols); else:; sol.expect = list(sol.expect / len(sols)); inds = np.where(config.e_ops_isherm)[0]; for jj in inds:; sol.expect[jj] = np.real(sol.expect[jj]); if (hasattr(sols[0], 'entropy')):; sol.entropy = sol.entropy / len(sols). # convert sol.expect array to list and fix dtypes of arrays; if (not config.options.average_expect) and config.e_num != 0:; temp = [list(sol.expect[ii]) for ii in range(ntraj)]; for ii in range(ntraj):; for jj in np.where(config.e_ops_isherm)[0]:; temp[ii][jj] = np.real(temp[ii][jj]); sol.expect = temp; # convert to list/array to be consistent with qutip mcsolve; sol.states = list(sol.states); return sol. #; # Functions to initialize the problem in fortran; #; def _init_tlist():; Of = _realarray_to_fortran(config.tlist); qtf90.qutraj_run.init_tlist(Of, np.size(Of)). def _init_psi0():; # Of = _qobj_to_fortranfull(config.psi0); Of = _complexarray_to_fortran(config.psi0); qtf90.qutraj_run.init_psi0(Of, np.size(Of)). def _init_ptrace_stuff(sel):; psi0 = Qobj(config.psi0,; dims=config.psi0_dims,; shape=config.psi0_shape); qtf90.qutraj_run.init_ptrace_stuff(config.psi0_dims[0],; np.array(sel) + 1,; psi0.ptrace(sel).shape[0]). def _init_hamilt():; # construct effective non-Hermitian Hamiltonian; # H_eff = H - 0.5j*sum([c_ops[i].dag()*c_ops[i]; # for i in range(len(c_ops))]); # Of = _qobj_to_fortrancsr(H_eff); # qtf90.qutraj_run.init_hamiltonian(Of[0],Of[1],; # Of[2],Of[3],Of[4]); d = np.size(config.psi0); qtf90.qutraj_run.init_hamiltonian(; _complexarray_to_fortran(config.h_data),; config.h_ind + 1, config.h_ptr + 1, d, d). def _init_c_ops():; d = np.size(config.psi0); n = config.c_num; first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:18792,Modifiability,config,config,18792,"((sol.entropy,; np.array(sols[j].entropy))); if (config.options.average_states or config.options.average_expect):; if (config.e_num == 0):; sol.states = sol.states / len(sols); else:; sol.expect = list(sol.expect / len(sols)); inds = np.where(config.e_ops_isherm)[0]; for jj in inds:; sol.expect[jj] = np.real(sol.expect[jj]); if (hasattr(sols[0], 'entropy')):; sol.entropy = sol.entropy / len(sols). # convert sol.expect array to list and fix dtypes of arrays; if (not config.options.average_expect) and config.e_num != 0:; temp = [list(sol.expect[ii]) for ii in range(ntraj)]; for ii in range(ntraj):; for jj in np.where(config.e_ops_isherm)[0]:; temp[ii][jj] = np.real(temp[ii][jj]); sol.expect = temp; # convert to list/array to be consistent with qutip mcsolve; sol.states = list(sol.states); return sol. #; # Functions to initialize the problem in fortran; #; def _init_tlist():; Of = _realarray_to_fortran(config.tlist); qtf90.qutraj_run.init_tlist(Of, np.size(Of)). def _init_psi0():; # Of = _qobj_to_fortranfull(config.psi0); Of = _complexarray_to_fortran(config.psi0); qtf90.qutraj_run.init_psi0(Of, np.size(Of)). def _init_ptrace_stuff(sel):; psi0 = Qobj(config.psi0,; dims=config.psi0_dims,; shape=config.psi0_shape); qtf90.qutraj_run.init_ptrace_stuff(config.psi0_dims[0],; np.array(sel) + 1,; psi0.ptrace(sel).shape[0]). def _init_hamilt():; # construct effective non-Hermitian Hamiltonian; # H_eff = H - 0.5j*sum([c_ops[i].dag()*c_ops[i]; # for i in range(len(c_ops))]); # Of = _qobj_to_fortrancsr(H_eff); # qtf90.qutraj_run.init_hamiltonian(Of[0],Of[1],; # Of[2],Of[3],Of[4]); d = np.size(config.psi0); qtf90.qutraj_run.init_hamiltonian(; _complexarray_to_fortran(config.h_data),; config.h_ind + 1, config.h_ptr + 1, d, d). def _init_c_ops():; d = np.size(config.psi0); n = config.c_num; first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(c_ops[i]); # qtf90.qutraj_run.init_c_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_c_ops(; i + 1, n, _comple",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:18836,Modifiability,config,config,18836,"onfig.options.average_states or config.options.average_expect):; if (config.e_num == 0):; sol.states = sol.states / len(sols); else:; sol.expect = list(sol.expect / len(sols)); inds = np.where(config.e_ops_isherm)[0]; for jj in inds:; sol.expect[jj] = np.real(sol.expect[jj]); if (hasattr(sols[0], 'entropy')):; sol.entropy = sol.entropy / len(sols). # convert sol.expect array to list and fix dtypes of arrays; if (not config.options.average_expect) and config.e_num != 0:; temp = [list(sol.expect[ii]) for ii in range(ntraj)]; for ii in range(ntraj):; for jj in np.where(config.e_ops_isherm)[0]:; temp[ii][jj] = np.real(temp[ii][jj]); sol.expect = temp; # convert to list/array to be consistent with qutip mcsolve; sol.states = list(sol.states); return sol. #; # Functions to initialize the problem in fortran; #; def _init_tlist():; Of = _realarray_to_fortran(config.tlist); qtf90.qutraj_run.init_tlist(Of, np.size(Of)). def _init_psi0():; # Of = _qobj_to_fortranfull(config.psi0); Of = _complexarray_to_fortran(config.psi0); qtf90.qutraj_run.init_psi0(Of, np.size(Of)). def _init_ptrace_stuff(sel):; psi0 = Qobj(config.psi0,; dims=config.psi0_dims,; shape=config.psi0_shape); qtf90.qutraj_run.init_ptrace_stuff(config.psi0_dims[0],; np.array(sel) + 1,; psi0.ptrace(sel).shape[0]). def _init_hamilt():; # construct effective non-Hermitian Hamiltonian; # H_eff = H - 0.5j*sum([c_ops[i].dag()*c_ops[i]; # for i in range(len(c_ops))]); # Of = _qobj_to_fortrancsr(H_eff); # qtf90.qutraj_run.init_hamiltonian(Of[0],Of[1],; # Of[2],Of[3],Of[4]); d = np.size(config.psi0); qtf90.qutraj_run.init_hamiltonian(; _complexarray_to_fortran(config.h_data),; config.h_ind + 1, config.h_ptr + 1, d, d). def _init_c_ops():; d = np.size(config.psi0); n = config.c_num; first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(c_ops[i]); # qtf90.qutraj_run.init_c_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_c_ops(; i + 1, n, _complexarray_to_fortran(config.c_ops_data[i]),; config.",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:18937,Modifiability,config,config,18937,"es = sol.states / len(sols); else:; sol.expect = list(sol.expect / len(sols)); inds = np.where(config.e_ops_isherm)[0]; for jj in inds:; sol.expect[jj] = np.real(sol.expect[jj]); if (hasattr(sols[0], 'entropy')):; sol.entropy = sol.entropy / len(sols). # convert sol.expect array to list and fix dtypes of arrays; if (not config.options.average_expect) and config.e_num != 0:; temp = [list(sol.expect[ii]) for ii in range(ntraj)]; for ii in range(ntraj):; for jj in np.where(config.e_ops_isherm)[0]:; temp[ii][jj] = np.real(temp[ii][jj]); sol.expect = temp; # convert to list/array to be consistent with qutip mcsolve; sol.states = list(sol.states); return sol. #; # Functions to initialize the problem in fortran; #; def _init_tlist():; Of = _realarray_to_fortran(config.tlist); qtf90.qutraj_run.init_tlist(Of, np.size(Of)). def _init_psi0():; # Of = _qobj_to_fortranfull(config.psi0); Of = _complexarray_to_fortran(config.psi0); qtf90.qutraj_run.init_psi0(Of, np.size(Of)). def _init_ptrace_stuff(sel):; psi0 = Qobj(config.psi0,; dims=config.psi0_dims,; shape=config.psi0_shape); qtf90.qutraj_run.init_ptrace_stuff(config.psi0_dims[0],; np.array(sel) + 1,; psi0.ptrace(sel).shape[0]). def _init_hamilt():; # construct effective non-Hermitian Hamiltonian; # H_eff = H - 0.5j*sum([c_ops[i].dag()*c_ops[i]; # for i in range(len(c_ops))]); # Of = _qobj_to_fortrancsr(H_eff); # qtf90.qutraj_run.init_hamiltonian(Of[0],Of[1],; # Of[2],Of[3],Of[4]); d = np.size(config.psi0); qtf90.qutraj_run.init_hamiltonian(; _complexarray_to_fortran(config.h_data),; config.h_ind + 1, config.h_ptr + 1, d, d). def _init_c_ops():; d = np.size(config.psi0); n = config.c_num; first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(c_ops[i]); # qtf90.qutraj_run.init_c_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_c_ops(; i + 1, n, _complexarray_to_fortran(config.c_ops_data[i]),; config.c_ops_ind[i] + 1, config.c_ops_ptr[i] + 1, d, d, first); first = False. def _init_e_ops():; d = np",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:18956,Modifiability,config,config,18956,"; sol.expect = list(sol.expect / len(sols)); inds = np.where(config.e_ops_isherm)[0]; for jj in inds:; sol.expect[jj] = np.real(sol.expect[jj]); if (hasattr(sols[0], 'entropy')):; sol.entropy = sol.entropy / len(sols). # convert sol.expect array to list and fix dtypes of arrays; if (not config.options.average_expect) and config.e_num != 0:; temp = [list(sol.expect[ii]) for ii in range(ntraj)]; for ii in range(ntraj):; for jj in np.where(config.e_ops_isherm)[0]:; temp[ii][jj] = np.real(temp[ii][jj]); sol.expect = temp; # convert to list/array to be consistent with qutip mcsolve; sol.states = list(sol.states); return sol. #; # Functions to initialize the problem in fortran; #; def _init_tlist():; Of = _realarray_to_fortran(config.tlist); qtf90.qutraj_run.init_tlist(Of, np.size(Of)). def _init_psi0():; # Of = _qobj_to_fortranfull(config.psi0); Of = _complexarray_to_fortran(config.psi0); qtf90.qutraj_run.init_psi0(Of, np.size(Of)). def _init_ptrace_stuff(sel):; psi0 = Qobj(config.psi0,; dims=config.psi0_dims,; shape=config.psi0_shape); qtf90.qutraj_run.init_ptrace_stuff(config.psi0_dims[0],; np.array(sel) + 1,; psi0.ptrace(sel).shape[0]). def _init_hamilt():; # construct effective non-Hermitian Hamiltonian; # H_eff = H - 0.5j*sum([c_ops[i].dag()*c_ops[i]; # for i in range(len(c_ops))]); # Of = _qobj_to_fortrancsr(H_eff); # qtf90.qutraj_run.init_hamiltonian(Of[0],Of[1],; # Of[2],Of[3],Of[4]); d = np.size(config.psi0); qtf90.qutraj_run.init_hamiltonian(; _complexarray_to_fortran(config.h_data),; config.h_ind + 1, config.h_ptr + 1, d, d). def _init_c_ops():; d = np.size(config.psi0); n = config.c_num; first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(c_ops[i]); # qtf90.qutraj_run.init_c_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_c_ops(; i + 1, n, _complexarray_to_fortran(config.c_ops_data[i]),; config.c_ops_ind[i] + 1, config.c_ops_ptr[i] + 1, d, d, first); first = False. def _init_e_ops():; d = np.size(config.psi0); # n = config.e_",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:18981,Modifiability,config,config,18981,"l.expect / len(sols)); inds = np.where(config.e_ops_isherm)[0]; for jj in inds:; sol.expect[jj] = np.real(sol.expect[jj]); if (hasattr(sols[0], 'entropy')):; sol.entropy = sol.entropy / len(sols). # convert sol.expect array to list and fix dtypes of arrays; if (not config.options.average_expect) and config.e_num != 0:; temp = [list(sol.expect[ii]) for ii in range(ntraj)]; for ii in range(ntraj):; for jj in np.where(config.e_ops_isherm)[0]:; temp[ii][jj] = np.real(temp[ii][jj]); sol.expect = temp; # convert to list/array to be consistent with qutip mcsolve; sol.states = list(sol.states); return sol. #; # Functions to initialize the problem in fortran; #; def _init_tlist():; Of = _realarray_to_fortran(config.tlist); qtf90.qutraj_run.init_tlist(Of, np.size(Of)). def _init_psi0():; # Of = _qobj_to_fortranfull(config.psi0); Of = _complexarray_to_fortran(config.psi0); qtf90.qutraj_run.init_psi0(Of, np.size(Of)). def _init_ptrace_stuff(sel):; psi0 = Qobj(config.psi0,; dims=config.psi0_dims,; shape=config.psi0_shape); qtf90.qutraj_run.init_ptrace_stuff(config.psi0_dims[0],; np.array(sel) + 1,; psi0.ptrace(sel).shape[0]). def _init_hamilt():; # construct effective non-Hermitian Hamiltonian; # H_eff = H - 0.5j*sum([c_ops[i].dag()*c_ops[i]; # for i in range(len(c_ops))]); # Of = _qobj_to_fortrancsr(H_eff); # qtf90.qutraj_run.init_hamiltonian(Of[0],Of[1],; # Of[2],Of[3],Of[4]); d = np.size(config.psi0); qtf90.qutraj_run.init_hamiltonian(; _complexarray_to_fortran(config.h_data),; config.h_ind + 1, config.h_ptr + 1, d, d). def _init_c_ops():; d = np.size(config.psi0); n = config.c_num; first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(c_ops[i]); # qtf90.qutraj_run.init_c_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_c_ops(; i + 1, n, _complexarray_to_fortran(config.c_ops_data[i]),; config.c_ops_ind[i] + 1, config.c_ops_ptr[i] + 1, d, d, first); first = False. def _init_e_ops():; d = np.size(config.psi0); # n = config.e_num; n = len(config.e_",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:19036,Modifiability,config,config,19036,"erm)[0]; for jj in inds:; sol.expect[jj] = np.real(sol.expect[jj]); if (hasattr(sols[0], 'entropy')):; sol.entropy = sol.entropy / len(sols). # convert sol.expect array to list and fix dtypes of arrays; if (not config.options.average_expect) and config.e_num != 0:; temp = [list(sol.expect[ii]) for ii in range(ntraj)]; for ii in range(ntraj):; for jj in np.where(config.e_ops_isherm)[0]:; temp[ii][jj] = np.real(temp[ii][jj]); sol.expect = temp; # convert to list/array to be consistent with qutip mcsolve; sol.states = list(sol.states); return sol. #; # Functions to initialize the problem in fortran; #; def _init_tlist():; Of = _realarray_to_fortran(config.tlist); qtf90.qutraj_run.init_tlist(Of, np.size(Of)). def _init_psi0():; # Of = _qobj_to_fortranfull(config.psi0); Of = _complexarray_to_fortran(config.psi0); qtf90.qutraj_run.init_psi0(Of, np.size(Of)). def _init_ptrace_stuff(sel):; psi0 = Qobj(config.psi0,; dims=config.psi0_dims,; shape=config.psi0_shape); qtf90.qutraj_run.init_ptrace_stuff(config.psi0_dims[0],; np.array(sel) + 1,; psi0.ptrace(sel).shape[0]). def _init_hamilt():; # construct effective non-Hermitian Hamiltonian; # H_eff = H - 0.5j*sum([c_ops[i].dag()*c_ops[i]; # for i in range(len(c_ops))]); # Of = _qobj_to_fortrancsr(H_eff); # qtf90.qutraj_run.init_hamiltonian(Of[0],Of[1],; # Of[2],Of[3],Of[4]); d = np.size(config.psi0); qtf90.qutraj_run.init_hamiltonian(; _complexarray_to_fortran(config.h_data),; config.h_ind + 1, config.h_ptr + 1, d, d). def _init_c_ops():; d = np.size(config.psi0); n = config.c_num; first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(c_ops[i]); # qtf90.qutraj_run.init_c_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_c_ops(; i + 1, n, _complexarray_to_fortran(config.c_ops_data[i]),; config.c_ops_ind[i] + 1, config.c_ops_ptr[i] + 1, d, d, first); first = False. def _init_e_ops():; d = np.size(config.psi0); # n = config.e_num; n = len(config.e_ops_data); first = True; for i in range(n):; # Of = _qo",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:19376,Modifiability,config,config,19376,"r jj in np.where(config.e_ops_isherm)[0]:; temp[ii][jj] = np.real(temp[ii][jj]); sol.expect = temp; # convert to list/array to be consistent with qutip mcsolve; sol.states = list(sol.states); return sol. #; # Functions to initialize the problem in fortran; #; def _init_tlist():; Of = _realarray_to_fortran(config.tlist); qtf90.qutraj_run.init_tlist(Of, np.size(Of)). def _init_psi0():; # Of = _qobj_to_fortranfull(config.psi0); Of = _complexarray_to_fortran(config.psi0); qtf90.qutraj_run.init_psi0(Of, np.size(Of)). def _init_ptrace_stuff(sel):; psi0 = Qobj(config.psi0,; dims=config.psi0_dims,; shape=config.psi0_shape); qtf90.qutraj_run.init_ptrace_stuff(config.psi0_dims[0],; np.array(sel) + 1,; psi0.ptrace(sel).shape[0]). def _init_hamilt():; # construct effective non-Hermitian Hamiltonian; # H_eff = H - 0.5j*sum([c_ops[i].dag()*c_ops[i]; # for i in range(len(c_ops))]); # Of = _qobj_to_fortrancsr(H_eff); # qtf90.qutraj_run.init_hamiltonian(Of[0],Of[1],; # Of[2],Of[3],Of[4]); d = np.size(config.psi0); qtf90.qutraj_run.init_hamiltonian(; _complexarray_to_fortran(config.h_data),; config.h_ind + 1, config.h_ptr + 1, d, d). def _init_c_ops():; d = np.size(config.psi0); n = config.c_num; first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(c_ops[i]); # qtf90.qutraj_run.init_c_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_c_ops(; i + 1, n, _complexarray_to_fortran(config.c_ops_data[i]),; config.c_ops_ind[i] + 1, config.c_ops_ptr[i] + 1, d, d, first); first = False. def _init_e_ops():; d = np.size(config.psi0); # n = config.e_num; n = len(config.e_ops_data); first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(e_ops[i]); # qtf90.qutraj_run.init_e_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_e_ops(; i + 1, n, _complexarray_to_fortran(config.e_ops_data[i]),; config.e_ops_ind[i] + 1, config.e_ops_ptr[i] + 1, d, d, first); first = False. #; # Misc. converison functions; #; def _realarray_to_fortran(a):; datad",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:19451,Modifiability,config,config,19451," = np.real(temp[ii][jj]); sol.expect = temp; # convert to list/array to be consistent with qutip mcsolve; sol.states = list(sol.states); return sol. #; # Functions to initialize the problem in fortran; #; def _init_tlist():; Of = _realarray_to_fortran(config.tlist); qtf90.qutraj_run.init_tlist(Of, np.size(Of)). def _init_psi0():; # Of = _qobj_to_fortranfull(config.psi0); Of = _complexarray_to_fortran(config.psi0); qtf90.qutraj_run.init_psi0(Of, np.size(Of)). def _init_ptrace_stuff(sel):; psi0 = Qobj(config.psi0,; dims=config.psi0_dims,; shape=config.psi0_shape); qtf90.qutraj_run.init_ptrace_stuff(config.psi0_dims[0],; np.array(sel) + 1,; psi0.ptrace(sel).shape[0]). def _init_hamilt():; # construct effective non-Hermitian Hamiltonian; # H_eff = H - 0.5j*sum([c_ops[i].dag()*c_ops[i]; # for i in range(len(c_ops))]); # Of = _qobj_to_fortrancsr(H_eff); # qtf90.qutraj_run.init_hamiltonian(Of[0],Of[1],; # Of[2],Of[3],Of[4]); d = np.size(config.psi0); qtf90.qutraj_run.init_hamiltonian(; _complexarray_to_fortran(config.h_data),; config.h_ind + 1, config.h_ptr + 1, d, d). def _init_c_ops():; d = np.size(config.psi0); n = config.c_num; first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(c_ops[i]); # qtf90.qutraj_run.init_c_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_c_ops(; i + 1, n, _complexarray_to_fortran(config.c_ops_data[i]),; config.c_ops_ind[i] + 1, config.c_ops_ptr[i] + 1, d, d, first); first = False. def _init_e_ops():; d = np.size(config.psi0); # n = config.e_num; n = len(config.e_ops_data); first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(e_ops[i]); # qtf90.qutraj_run.init_e_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_e_ops(; i + 1, n, _complexarray_to_fortran(config.e_ops_data[i]),; config.e_ops_ind[i] + 1, config.e_ops_ptr[i] + 1, d, d, first); first = False. #; # Misc. converison functions; #; def _realarray_to_fortran(a):; datad = np.array(a, dtype=wpr); return datad. def _complexarr",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:19468,Modifiability,config,config,19468,"ct = temp; # convert to list/array to be consistent with qutip mcsolve; sol.states = list(sol.states); return sol. #; # Functions to initialize the problem in fortran; #; def _init_tlist():; Of = _realarray_to_fortran(config.tlist); qtf90.qutraj_run.init_tlist(Of, np.size(Of)). def _init_psi0():; # Of = _qobj_to_fortranfull(config.psi0); Of = _complexarray_to_fortran(config.psi0); qtf90.qutraj_run.init_psi0(Of, np.size(Of)). def _init_ptrace_stuff(sel):; psi0 = Qobj(config.psi0,; dims=config.psi0_dims,; shape=config.psi0_shape); qtf90.qutraj_run.init_ptrace_stuff(config.psi0_dims[0],; np.array(sel) + 1,; psi0.ptrace(sel).shape[0]). def _init_hamilt():; # construct effective non-Hermitian Hamiltonian; # H_eff = H - 0.5j*sum([c_ops[i].dag()*c_ops[i]; # for i in range(len(c_ops))]); # Of = _qobj_to_fortrancsr(H_eff); # qtf90.qutraj_run.init_hamiltonian(Of[0],Of[1],; # Of[2],Of[3],Of[4]); d = np.size(config.psi0); qtf90.qutraj_run.init_hamiltonian(; _complexarray_to_fortran(config.h_data),; config.h_ind + 1, config.h_ptr + 1, d, d). def _init_c_ops():; d = np.size(config.psi0); n = config.c_num; first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(c_ops[i]); # qtf90.qutraj_run.init_c_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_c_ops(; i + 1, n, _complexarray_to_fortran(config.c_ops_data[i]),; config.c_ops_ind[i] + 1, config.c_ops_ptr[i] + 1, d, d, first); first = False. def _init_e_ops():; d = np.size(config.psi0); # n = config.e_num; n = len(config.e_ops_data); first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(e_ops[i]); # qtf90.qutraj_run.init_e_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_e_ops(; i + 1, n, _complexarray_to_fortran(config.e_ops_data[i]),; config.e_ops_ind[i] + 1, config.e_ops_ptr[i] + 1, d, d, first); first = False. #; # Misc. converison functions; #; def _realarray_to_fortran(a):; datad = np.array(a, dtype=wpr); return datad. def _complexarray_to_fortran(a):; datad = np.arra",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:19486,Modifiability,config,config,19486,"rt to list/array to be consistent with qutip mcsolve; sol.states = list(sol.states); return sol. #; # Functions to initialize the problem in fortran; #; def _init_tlist():; Of = _realarray_to_fortran(config.tlist); qtf90.qutraj_run.init_tlist(Of, np.size(Of)). def _init_psi0():; # Of = _qobj_to_fortranfull(config.psi0); Of = _complexarray_to_fortran(config.psi0); qtf90.qutraj_run.init_psi0(Of, np.size(Of)). def _init_ptrace_stuff(sel):; psi0 = Qobj(config.psi0,; dims=config.psi0_dims,; shape=config.psi0_shape); qtf90.qutraj_run.init_ptrace_stuff(config.psi0_dims[0],; np.array(sel) + 1,; psi0.ptrace(sel).shape[0]). def _init_hamilt():; # construct effective non-Hermitian Hamiltonian; # H_eff = H - 0.5j*sum([c_ops[i].dag()*c_ops[i]; # for i in range(len(c_ops))]); # Of = _qobj_to_fortrancsr(H_eff); # qtf90.qutraj_run.init_hamiltonian(Of[0],Of[1],; # Of[2],Of[3],Of[4]); d = np.size(config.psi0); qtf90.qutraj_run.init_hamiltonian(; _complexarray_to_fortran(config.h_data),; config.h_ind + 1, config.h_ptr + 1, d, d). def _init_c_ops():; d = np.size(config.psi0); n = config.c_num; first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(c_ops[i]); # qtf90.qutraj_run.init_c_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_c_ops(; i + 1, n, _complexarray_to_fortran(config.c_ops_data[i]),; config.c_ops_ind[i] + 1, config.c_ops_ptr[i] + 1, d, d, first); first = False. def _init_e_ops():; d = np.size(config.psi0); # n = config.e_num; n = len(config.e_ops_data); first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(e_ops[i]); # qtf90.qutraj_run.init_e_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_e_ops(; i + 1, n, _complexarray_to_fortran(config.e_ops_data[i]),; config.e_ops_ind[i] + 1, config.e_ops_ptr[i] + 1, d, d, first); first = False. #; # Misc. converison functions; #; def _realarray_to_fortran(a):; datad = np.array(a, dtype=wpr); return datad. def _complexarray_to_fortran(a):; datad = np.array(a, dtype=wpc); ",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:19543,Modifiability,config,config,19543,"ates = list(sol.states); return sol. #; # Functions to initialize the problem in fortran; #; def _init_tlist():; Of = _realarray_to_fortran(config.tlist); qtf90.qutraj_run.init_tlist(Of, np.size(Of)). def _init_psi0():; # Of = _qobj_to_fortranfull(config.psi0); Of = _complexarray_to_fortran(config.psi0); qtf90.qutraj_run.init_psi0(Of, np.size(Of)). def _init_ptrace_stuff(sel):; psi0 = Qobj(config.psi0,; dims=config.psi0_dims,; shape=config.psi0_shape); qtf90.qutraj_run.init_ptrace_stuff(config.psi0_dims[0],; np.array(sel) + 1,; psi0.ptrace(sel).shape[0]). def _init_hamilt():; # construct effective non-Hermitian Hamiltonian; # H_eff = H - 0.5j*sum([c_ops[i].dag()*c_ops[i]; # for i in range(len(c_ops))]); # Of = _qobj_to_fortrancsr(H_eff); # qtf90.qutraj_run.init_hamiltonian(Of[0],Of[1],; # Of[2],Of[3],Of[4]); d = np.size(config.psi0); qtf90.qutraj_run.init_hamiltonian(; _complexarray_to_fortran(config.h_data),; config.h_ind + 1, config.h_ptr + 1, d, d). def _init_c_ops():; d = np.size(config.psi0); n = config.c_num; first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(c_ops[i]); # qtf90.qutraj_run.init_c_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_c_ops(; i + 1, n, _complexarray_to_fortran(config.c_ops_data[i]),; config.c_ops_ind[i] + 1, config.c_ops_ptr[i] + 1, d, d, first); first = False. def _init_e_ops():; d = np.size(config.psi0); # n = config.e_num; n = len(config.e_ops_data); first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(e_ops[i]); # qtf90.qutraj_run.init_e_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_e_ops(; i + 1, n, _complexarray_to_fortran(config.e_ops_data[i]),; config.e_ops_ind[i] + 1, config.e_ops_ptr[i] + 1, d, d, first); first = False. #; # Misc. converison functions; #; def _realarray_to_fortran(a):; datad = np.array(a, dtype=wpr); return datad. def _complexarray_to_fortran(a):; datad = np.array(a, dtype=wpc); return datad. def _qobj_to_fortranfull(A):; datad = np.array",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:19561,Modifiability,config,config,19561,".states); return sol. #; # Functions to initialize the problem in fortran; #; def _init_tlist():; Of = _realarray_to_fortran(config.tlist); qtf90.qutraj_run.init_tlist(Of, np.size(Of)). def _init_psi0():; # Of = _qobj_to_fortranfull(config.psi0); Of = _complexarray_to_fortran(config.psi0); qtf90.qutraj_run.init_psi0(Of, np.size(Of)). def _init_ptrace_stuff(sel):; psi0 = Qobj(config.psi0,; dims=config.psi0_dims,; shape=config.psi0_shape); qtf90.qutraj_run.init_ptrace_stuff(config.psi0_dims[0],; np.array(sel) + 1,; psi0.ptrace(sel).shape[0]). def _init_hamilt():; # construct effective non-Hermitian Hamiltonian; # H_eff = H - 0.5j*sum([c_ops[i].dag()*c_ops[i]; # for i in range(len(c_ops))]); # Of = _qobj_to_fortrancsr(H_eff); # qtf90.qutraj_run.init_hamiltonian(Of[0],Of[1],; # Of[2],Of[3],Of[4]); d = np.size(config.psi0); qtf90.qutraj_run.init_hamiltonian(; _complexarray_to_fortran(config.h_data),; config.h_ind + 1, config.h_ptr + 1, d, d). def _init_c_ops():; d = np.size(config.psi0); n = config.c_num; first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(c_ops[i]); # qtf90.qutraj_run.init_c_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_c_ops(; i + 1, n, _complexarray_to_fortran(config.c_ops_data[i]),; config.c_ops_ind[i] + 1, config.c_ops_ptr[i] + 1, d, d, first); first = False. def _init_e_ops():; d = np.size(config.psi0); # n = config.e_num; n = len(config.e_ops_data); first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(e_ops[i]); # qtf90.qutraj_run.init_e_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_e_ops(; i + 1, n, _complexarray_to_fortran(config.e_ops_data[i]),; config.e_ops_ind[i] + 1, config.e_ops_ptr[i] + 1, d, d, first); first = False. #; # Misc. converison functions; #; def _realarray_to_fortran(a):; datad = np.array(a, dtype=wpr); return datad. def _complexarray_to_fortran(a):; datad = np.array(a, dtype=wpc); return datad. def _qobj_to_fortranfull(A):; datad = np.array(A.data.toarray",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:19790,Modifiability,config,config,19790,"= _qobj_to_fortranfull(config.psi0); Of = _complexarray_to_fortran(config.psi0); qtf90.qutraj_run.init_psi0(Of, np.size(Of)). def _init_ptrace_stuff(sel):; psi0 = Qobj(config.psi0,; dims=config.psi0_dims,; shape=config.psi0_shape); qtf90.qutraj_run.init_ptrace_stuff(config.psi0_dims[0],; np.array(sel) + 1,; psi0.ptrace(sel).shape[0]). def _init_hamilt():; # construct effective non-Hermitian Hamiltonian; # H_eff = H - 0.5j*sum([c_ops[i].dag()*c_ops[i]; # for i in range(len(c_ops))]); # Of = _qobj_to_fortrancsr(H_eff); # qtf90.qutraj_run.init_hamiltonian(Of[0],Of[1],; # Of[2],Of[3],Of[4]); d = np.size(config.psi0); qtf90.qutraj_run.init_hamiltonian(; _complexarray_to_fortran(config.h_data),; config.h_ind + 1, config.h_ptr + 1, d, d). def _init_c_ops():; d = np.size(config.psi0); n = config.c_num; first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(c_ops[i]); # qtf90.qutraj_run.init_c_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_c_ops(; i + 1, n, _complexarray_to_fortran(config.c_ops_data[i]),; config.c_ops_ind[i] + 1, config.c_ops_ptr[i] + 1, d, d, first); first = False. def _init_e_ops():; d = np.size(config.psi0); # n = config.e_num; n = len(config.e_ops_data); first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(e_ops[i]); # qtf90.qutraj_run.init_e_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_e_ops(; i + 1, n, _complexarray_to_fortran(config.e_ops_data[i]),; config.e_ops_ind[i] + 1, config.e_ops_ptr[i] + 1, d, d, first); first = False. #; # Misc. converison functions; #; def _realarray_to_fortran(a):; datad = np.array(a, dtype=wpr); return datad. def _complexarray_to_fortran(a):; datad = np.array(a, dtype=wpc); return datad. def _qobj_to_fortranfull(A):; datad = np.array(A.data.toarray(), dtype=wpc); return datad. def _qobj_to_fortrancsr(A):; data = np.array(A.data.data, dtype=wpc); indices = np.array(A.data.indices); indptr = np.array(A.data.indptr); m = A.data.shape[0]; k = A.data.shape[1];",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:19814,Modifiability,config,config,19814,"= _complexarray_to_fortran(config.psi0); qtf90.qutraj_run.init_psi0(Of, np.size(Of)). def _init_ptrace_stuff(sel):; psi0 = Qobj(config.psi0,; dims=config.psi0_dims,; shape=config.psi0_shape); qtf90.qutraj_run.init_ptrace_stuff(config.psi0_dims[0],; np.array(sel) + 1,; psi0.ptrace(sel).shape[0]). def _init_hamilt():; # construct effective non-Hermitian Hamiltonian; # H_eff = H - 0.5j*sum([c_ops[i].dag()*c_ops[i]; # for i in range(len(c_ops))]); # Of = _qobj_to_fortrancsr(H_eff); # qtf90.qutraj_run.init_hamiltonian(Of[0],Of[1],; # Of[2],Of[3],Of[4]); d = np.size(config.psi0); qtf90.qutraj_run.init_hamiltonian(; _complexarray_to_fortran(config.h_data),; config.h_ind + 1, config.h_ptr + 1, d, d). def _init_c_ops():; d = np.size(config.psi0); n = config.c_num; first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(c_ops[i]); # qtf90.qutraj_run.init_c_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_c_ops(; i + 1, n, _complexarray_to_fortran(config.c_ops_data[i]),; config.c_ops_ind[i] + 1, config.c_ops_ptr[i] + 1, d, d, first); first = False. def _init_e_ops():; d = np.size(config.psi0); # n = config.e_num; n = len(config.e_ops_data); first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(e_ops[i]); # qtf90.qutraj_run.init_e_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_e_ops(; i + 1, n, _complexarray_to_fortran(config.e_ops_data[i]),; config.e_ops_ind[i] + 1, config.e_ops_ptr[i] + 1, d, d, first); first = False. #; # Misc. converison functions; #; def _realarray_to_fortran(a):; datad = np.array(a, dtype=wpr); return datad. def _complexarray_to_fortran(a):; datad = np.array(a, dtype=wpc); return datad. def _qobj_to_fortranfull(A):; datad = np.array(A.data.toarray(), dtype=wpc); return datad. def _qobj_to_fortrancsr(A):; data = np.array(A.data.data, dtype=wpc); indices = np.array(A.data.indices); indptr = np.array(A.data.indptr); m = A.data.shape[0]; k = A.data.shape[1]; return data, indices + 1, indptr + 1, ",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:19839,Modifiability,config,config,19839,"an(config.psi0); qtf90.qutraj_run.init_psi0(Of, np.size(Of)). def _init_ptrace_stuff(sel):; psi0 = Qobj(config.psi0,; dims=config.psi0_dims,; shape=config.psi0_shape); qtf90.qutraj_run.init_ptrace_stuff(config.psi0_dims[0],; np.array(sel) + 1,; psi0.ptrace(sel).shape[0]). def _init_hamilt():; # construct effective non-Hermitian Hamiltonian; # H_eff = H - 0.5j*sum([c_ops[i].dag()*c_ops[i]; # for i in range(len(c_ops))]); # Of = _qobj_to_fortrancsr(H_eff); # qtf90.qutraj_run.init_hamiltonian(Of[0],Of[1],; # Of[2],Of[3],Of[4]); d = np.size(config.psi0); qtf90.qutraj_run.init_hamiltonian(; _complexarray_to_fortran(config.h_data),; config.h_ind + 1, config.h_ptr + 1, d, d). def _init_c_ops():; d = np.size(config.psi0); n = config.c_num; first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(c_ops[i]); # qtf90.qutraj_run.init_c_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_c_ops(; i + 1, n, _complexarray_to_fortran(config.c_ops_data[i]),; config.c_ops_ind[i] + 1, config.c_ops_ptr[i] + 1, d, d, first); first = False. def _init_e_ops():; d = np.size(config.psi0); # n = config.e_num; n = len(config.e_ops_data); first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(e_ops[i]); # qtf90.qutraj_run.init_e_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_e_ops(; i + 1, n, _complexarray_to_fortran(config.e_ops_data[i]),; config.e_ops_ind[i] + 1, config.e_ops_ptr[i] + 1, d, d, first); first = False. #; # Misc. converison functions; #; def _realarray_to_fortran(a):; datad = np.array(a, dtype=wpr); return datad. def _complexarray_to_fortran(a):; datad = np.array(a, dtype=wpc); return datad. def _qobj_to_fortranfull(A):; datad = np.array(A.data.toarray(), dtype=wpc); return datad. def _qobj_to_fortrancsr(A):; data = np.array(A.data.data, dtype=wpc); indices = np.array(A.data.indices); indptr = np.array(A.data.indptr); m = A.data.shape[0]; k = A.data.shape[1]; return data, indices + 1, indptr + 1, m, k. Back to top. © Copy",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:19925,Modifiability,config,config,19925,"si0 = Qobj(config.psi0,; dims=config.psi0_dims,; shape=config.psi0_shape); qtf90.qutraj_run.init_ptrace_stuff(config.psi0_dims[0],; np.array(sel) + 1,; psi0.ptrace(sel).shape[0]). def _init_hamilt():; # construct effective non-Hermitian Hamiltonian; # H_eff = H - 0.5j*sum([c_ops[i].dag()*c_ops[i]; # for i in range(len(c_ops))]); # Of = _qobj_to_fortrancsr(H_eff); # qtf90.qutraj_run.init_hamiltonian(Of[0],Of[1],; # Of[2],Of[3],Of[4]); d = np.size(config.psi0); qtf90.qutraj_run.init_hamiltonian(; _complexarray_to_fortran(config.h_data),; config.h_ind + 1, config.h_ptr + 1, d, d). def _init_c_ops():; d = np.size(config.psi0); n = config.c_num; first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(c_ops[i]); # qtf90.qutraj_run.init_c_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_c_ops(; i + 1, n, _complexarray_to_fortran(config.c_ops_data[i]),; config.c_ops_ind[i] + 1, config.c_ops_ptr[i] + 1, d, d, first); first = False. def _init_e_ops():; d = np.size(config.psi0); # n = config.e_num; n = len(config.e_ops_data); first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(e_ops[i]); # qtf90.qutraj_run.init_e_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_e_ops(; i + 1, n, _complexarray_to_fortran(config.e_ops_data[i]),; config.e_ops_ind[i] + 1, config.e_ops_ptr[i] + 1, d, d, first); first = False. #; # Misc. converison functions; #; def _realarray_to_fortran(a):; datad = np.array(a, dtype=wpr); return datad. def _complexarray_to_fortran(a):; datad = np.array(a, dtype=wpc); return datad. def _qobj_to_fortranfull(A):; datad = np.array(A.data.toarray(), dtype=wpc); return datad. def _qobj_to_fortrancsr(A):; data = np.array(A.data.data, dtype=wpc); indices = np.array(A.data.indices); indptr = np.array(A.data.indptr); m = A.data.shape[0]; k = A.data.shape[1]; return data, indices + 1, indptr + 1, m, k. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created u",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:19945,Modifiability,config,config,19945,"g.psi0,; dims=config.psi0_dims,; shape=config.psi0_shape); qtf90.qutraj_run.init_ptrace_stuff(config.psi0_dims[0],; np.array(sel) + 1,; psi0.ptrace(sel).shape[0]). def _init_hamilt():; # construct effective non-Hermitian Hamiltonian; # H_eff = H - 0.5j*sum([c_ops[i].dag()*c_ops[i]; # for i in range(len(c_ops))]); # Of = _qobj_to_fortrancsr(H_eff); # qtf90.qutraj_run.init_hamiltonian(Of[0],Of[1],; # Of[2],Of[3],Of[4]); d = np.size(config.psi0); qtf90.qutraj_run.init_hamiltonian(; _complexarray_to_fortran(config.h_data),; config.h_ind + 1, config.h_ptr + 1, d, d). def _init_c_ops():; d = np.size(config.psi0); n = config.c_num; first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(c_ops[i]); # qtf90.qutraj_run.init_c_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_c_ops(; i + 1, n, _complexarray_to_fortran(config.c_ops_data[i]),; config.c_ops_ind[i] + 1, config.c_ops_ptr[i] + 1, d, d, first); first = False. def _init_e_ops():; d = np.size(config.psi0); # n = config.e_num; n = len(config.e_ops_data); first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(e_ops[i]); # qtf90.qutraj_run.init_e_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_e_ops(; i + 1, n, _complexarray_to_fortran(config.e_ops_data[i]),; config.e_ops_ind[i] + 1, config.e_ops_ptr[i] + 1, d, d, first); first = False. #; # Misc. converison functions; #; def _realarray_to_fortran(a):; datad = np.array(a, dtype=wpr); return datad. def _complexarray_to_fortran(a):; datad = np.array(a, dtype=wpc); return datad. def _qobj_to_fortranfull(A):; datad = np.array(A.data.toarray(), dtype=wpc); return datad. def _qobj_to_fortrancsr(A):; data = np.array(A.data.data, dtype=wpc); indices = np.array(A.data.indices); indptr = np.array(A.data.indptr); m = A.data.shape[0]; k = A.data.shape[1]; return data, indices + 1, indptr + 1, m, k. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:19967,Modifiability,config,config,19967,"si0,; dims=config.psi0_dims,; shape=config.psi0_shape); qtf90.qutraj_run.init_ptrace_stuff(config.psi0_dims[0],; np.array(sel) + 1,; psi0.ptrace(sel).shape[0]). def _init_hamilt():; # construct effective non-Hermitian Hamiltonian; # H_eff = H - 0.5j*sum([c_ops[i].dag()*c_ops[i]; # for i in range(len(c_ops))]); # Of = _qobj_to_fortrancsr(H_eff); # qtf90.qutraj_run.init_hamiltonian(Of[0],Of[1],; # Of[2],Of[3],Of[4]); d = np.size(config.psi0); qtf90.qutraj_run.init_hamiltonian(; _complexarray_to_fortran(config.h_data),; config.h_ind + 1, config.h_ptr + 1, d, d). def _init_c_ops():; d = np.size(config.psi0); n = config.c_num; first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(c_ops[i]); # qtf90.qutraj_run.init_c_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_c_ops(; i + 1, n, _complexarray_to_fortran(config.c_ops_data[i]),; config.c_ops_ind[i] + 1, config.c_ops_ptr[i] + 1, d, d, first); first = False. def _init_e_ops():; d = np.size(config.psi0); # n = config.e_num; n = len(config.e_ops_data); first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(e_ops[i]); # qtf90.qutraj_run.init_e_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_e_ops(; i + 1, n, _complexarray_to_fortran(config.e_ops_data[i]),; config.e_ops_ind[i] + 1, config.e_ops_ptr[i] + 1, d, d, first); first = False. #; # Misc. converison functions; #; def _realarray_to_fortran(a):; datad = np.array(a, dtype=wpr); return datad. def _complexarray_to_fortran(a):; datad = np.array(a, dtype=wpc); return datad. def _qobj_to_fortranfull(A):; datad = np.array(A.data.toarray(), dtype=wpc); return datad. def _qobj_to_fortrancsr(A):; data = np.array(A.data.data, dtype=wpc); indices = np.array(A.data.indices); indptr = np.array(A.data.indptr); m = A.data.shape[0]; k = A.data.shape[1]; return data, indices + 1, indptr + 1, m, k. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:20202,Modifiability,config,config,20202,"si0,; dims=config.psi0_dims,; shape=config.psi0_shape); qtf90.qutraj_run.init_ptrace_stuff(config.psi0_dims[0],; np.array(sel) + 1,; psi0.ptrace(sel).shape[0]). def _init_hamilt():; # construct effective non-Hermitian Hamiltonian; # H_eff = H - 0.5j*sum([c_ops[i].dag()*c_ops[i]; # for i in range(len(c_ops))]); # Of = _qobj_to_fortrancsr(H_eff); # qtf90.qutraj_run.init_hamiltonian(Of[0],Of[1],; # Of[2],Of[3],Of[4]); d = np.size(config.psi0); qtf90.qutraj_run.init_hamiltonian(; _complexarray_to_fortran(config.h_data),; config.h_ind + 1, config.h_ptr + 1, d, d). def _init_c_ops():; d = np.size(config.psi0); n = config.c_num; first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(c_ops[i]); # qtf90.qutraj_run.init_c_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_c_ops(; i + 1, n, _complexarray_to_fortran(config.c_ops_data[i]),; config.c_ops_ind[i] + 1, config.c_ops_ptr[i] + 1, d, d, first); first = False. def _init_e_ops():; d = np.size(config.psi0); # n = config.e_num; n = len(config.e_ops_data); first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(e_ops[i]); # qtf90.qutraj_run.init_e_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_e_ops(; i + 1, n, _complexarray_to_fortran(config.e_ops_data[i]),; config.e_ops_ind[i] + 1, config.e_ops_ptr[i] + 1, d, d, first); first = False. #; # Misc. converison functions; #; def _realarray_to_fortran(a):; datad = np.array(a, dtype=wpr); return datad. def _complexarray_to_fortran(a):; datad = np.array(a, dtype=wpc); return datad. def _qobj_to_fortranfull(A):; datad = np.array(A.data.toarray(), dtype=wpc); return datad. def _qobj_to_fortrancsr(A):; data = np.array(A.data.data, dtype=wpc); indices = np.array(A.data.indices); indptr = np.array(A.data.indptr); m = A.data.shape[0]; k = A.data.shape[1]; return data, indices + 1, indptr + 1, m, k. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:20226,Modifiability,config,config,20226,"si0,; dims=config.psi0_dims,; shape=config.psi0_shape); qtf90.qutraj_run.init_ptrace_stuff(config.psi0_dims[0],; np.array(sel) + 1,; psi0.ptrace(sel).shape[0]). def _init_hamilt():; # construct effective non-Hermitian Hamiltonian; # H_eff = H - 0.5j*sum([c_ops[i].dag()*c_ops[i]; # for i in range(len(c_ops))]); # Of = _qobj_to_fortrancsr(H_eff); # qtf90.qutraj_run.init_hamiltonian(Of[0],Of[1],; # Of[2],Of[3],Of[4]); d = np.size(config.psi0); qtf90.qutraj_run.init_hamiltonian(; _complexarray_to_fortran(config.h_data),; config.h_ind + 1, config.h_ptr + 1, d, d). def _init_c_ops():; d = np.size(config.psi0); n = config.c_num; first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(c_ops[i]); # qtf90.qutraj_run.init_c_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_c_ops(; i + 1, n, _complexarray_to_fortran(config.c_ops_data[i]),; config.c_ops_ind[i] + 1, config.c_ops_ptr[i] + 1, d, d, first); first = False. def _init_e_ops():; d = np.size(config.psi0); # n = config.e_num; n = len(config.e_ops_data); first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(e_ops[i]); # qtf90.qutraj_run.init_e_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_e_ops(; i + 1, n, _complexarray_to_fortran(config.e_ops_data[i]),; config.e_ops_ind[i] + 1, config.e_ops_ptr[i] + 1, d, d, first); first = False. #; # Misc. converison functions; #; def _realarray_to_fortran(a):; datad = np.array(a, dtype=wpr); return datad. def _complexarray_to_fortran(a):; datad = np.array(a, dtype=wpc); return datad. def _qobj_to_fortranfull(A):; datad = np.array(A.data.toarray(), dtype=wpc); return datad. def _qobj_to_fortrancsr(A):; data = np.array(A.data.data, dtype=wpc); indices = np.array(A.data.indices); indptr = np.array(A.data.indptr); m = A.data.shape[0]; k = A.data.shape[1]; return data, indices + 1, indptr + 1, m, k. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:20251,Modifiability,config,config,20251,"si0,; dims=config.psi0_dims,; shape=config.psi0_shape); qtf90.qutraj_run.init_ptrace_stuff(config.psi0_dims[0],; np.array(sel) + 1,; psi0.ptrace(sel).shape[0]). def _init_hamilt():; # construct effective non-Hermitian Hamiltonian; # H_eff = H - 0.5j*sum([c_ops[i].dag()*c_ops[i]; # for i in range(len(c_ops))]); # Of = _qobj_to_fortrancsr(H_eff); # qtf90.qutraj_run.init_hamiltonian(Of[0],Of[1],; # Of[2],Of[3],Of[4]); d = np.size(config.psi0); qtf90.qutraj_run.init_hamiltonian(; _complexarray_to_fortran(config.h_data),; config.h_ind + 1, config.h_ptr + 1, d, d). def _init_c_ops():; d = np.size(config.psi0); n = config.c_num; first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(c_ops[i]); # qtf90.qutraj_run.init_c_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_c_ops(; i + 1, n, _complexarray_to_fortran(config.c_ops_data[i]),; config.c_ops_ind[i] + 1, config.c_ops_ptr[i] + 1, d, d, first); first = False. def _init_e_ops():; d = np.size(config.psi0); # n = config.e_num; n = len(config.e_ops_data); first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(e_ops[i]); # qtf90.qutraj_run.init_e_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_e_ops(; i + 1, n, _complexarray_to_fortran(config.e_ops_data[i]),; config.e_ops_ind[i] + 1, config.e_ops_ptr[i] + 1, d, d, first); first = False. #; # Misc. converison functions; #; def _realarray_to_fortran(a):; datad = np.array(a, dtype=wpr); return datad. def _complexarray_to_fortran(a):; datad = np.array(a, dtype=wpc); return datad. def _qobj_to_fortranfull(A):; datad = np.array(A.data.toarray(), dtype=wpc); return datad. def _qobj_to_fortrancsr(A):; data = np.array(A.data.data, dtype=wpc); indices = np.array(A.data.indices); indptr = np.array(A.data.indptr); m = A.data.shape[0]; k = A.data.shape[1]; return data, indices + 1, indptr + 1, m, k. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:7429,Performance,perform,performing,7429," options.rhs_reuse:; config.soft_reset(); # no time dependence; config.tflag = 0; # check for collapse operators; if len(c_ops) > 0:; config.cflag = 1; else:; config.cflag = 0; # Configure data; _mc_data_config(H, psi0, [], c_ops, [], [], e_ops, options, config). # Load Monte Carlo class; mc = _MC_class(); # Set solver type; if (options.method == 'adams'):; mc.mf = 10; elif (options.method == 'bdf'):; mc.mf = 22; else:; if debug:; print('Unrecognized method for ode solver, using ""adams"".'); mc.mf = 10; # store ket and density matrix dims and shape for convenience; mc.psi0_dims = psi0.dims; mc.psi0_shape = psi0.shape; mc.dm_dims = (psi0 * psi0.dag()).dims; mc.dm_shape = (psi0 * psi0.dag()).shape; # use sparse density matrices during computation?; mc.sparse_dms = sparse_dms; # run in serial?; mc.serial_run = serial or (ntraj == 1); # are we doing a partial trace for returned states?; mc.ptrace_sel = ptrace_sel; if (ptrace_sel != []):; if debug:; print(""ptrace_sel set to "" + str(ptrace_sel)); print(""We are using dense density matrices during computation "" +; ""when performing partial trace. Setting sparse_dms = False""); print(""This feature is experimental.""); mc.sparse_dms = False; mc.dm_dims = psi0.ptrace(ptrace_sel).dims; mc.dm_shape = psi0.ptrace(ptrace_sel).shape; if (calc_entropy):; if (ptrace_sel == []):; if debug:; print(""calc_entropy = True, but ptrace_sel = []. Please set "" +; ""a list of components to keep when calculating average"" +; "" entropy of reduced density matrix in ptrace_sel. "" +; ""Setting calc_entropy = False.""); calc_entropy = False; mc.calc_entropy = calc_entropy. # construct output Result object; output = Result(). # Run; mc.run(); output.states = mc.sol.states; output.expect = mc.sol.expect; output.col_times = mc.sol.col_times; output.col_which = mc.sol.col_which; if (hasattr(mc.sol, 'entropy')):; output.entropy = mc.sol.entropy. output.solver = 'Fortran 90 Monte Carlo solver'; # simulation parameters; output.times = config.tlist; output.num_expect",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:11430,Performance,queue,queue,11430,"lf.evolve_serial((0, self.ntraj, 0, self.seed)); return [sol]. def run(self):. if debug:; print(inspect.stack()[0][3]). from numpy.random import random_integers; if (config.c_num == 0):; # force one trajectory if no collapse operators; config.ntraj = 1; self.ntraj = 1; # Set unravel_type to 1 to integrate without collapses; self.unravel_type = 1; if (config.e_num == 0):; # If we are returning states, and there are no; # collapse operators, set average_states to False to return; # ket vectors instead of density matrices; config.options.average_states = False; # generate a random seed, useful if e.g. running with MPI; self.seed = random_integers(1e8); if (self.serial_run):; # run in serial; sols = self.serial(); else:; # run in paralell; sols = self.parallel(); # gather data; self.sol = _gather(sols). def evolve_serial(self, args):. if debug:; print(inspect.stack()[0][3] + "":"" + str(os.getpid())). # run ntraj trajectories for one process via fortran; # get args; queue, ntraj, instanceno, rngseed = args; # initialize the problem in fortran; _init_tlist(); _init_psi0(); if (self.ptrace_sel != []):; _init_ptrace_stuff(self.ptrace_sel); _init_hamilt(); if (config.c_num != 0):; _init_c_ops(); if (config.e_num != 0):; _init_e_ops(); # set options; qtf90.qutraj_run.n_c_ops = config.c_num; qtf90.qutraj_run.n_e_ops = config.e_num; qtf90.qutraj_run.ntraj = ntraj; qtf90.qutraj_run.unravel_type = self.unravel_type; qtf90.qutraj_run.average_states = config.options.average_states; qtf90.qutraj_run.average_expect = config.options.average_expect; qtf90.qutraj_run.init_result(config.psi0_shape[0],; config.options.atol,; config.options.rtol, mf=self.mf,; norm_steps=config.norm_steps,; norm_tol=config.norm_tol); # set optional arguments; qtf90.qutraj_run.order = config.options.order; qtf90.qutraj_run.nsteps = config.options.nsteps; qtf90.qutraj_run.first_step = config.options.first_step; qtf90.qutraj_run.min_step = config.options.min_step; qtf90.qutraj_run.max_step = config.options.max_",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:13351,Performance,queue,queue,13351,"st_step; qtf90.qutraj_run.min_step = config.options.min_step; qtf90.qutraj_run.max_step = config.options.max_step; qtf90.qutraj_run.norm_steps = config.options.norm_steps; qtf90.qutraj_run.norm_tol = config.options.norm_tol; # use sparse density matrices during computation?; qtf90.qutraj_run.rho_return_sparse = self.sparse_dms; # calculate entropy of reduced density matrice?; qtf90.qutraj_run.calc_entropy = self.calc_entropy; # run; show_progress = 1 if debug else 0; qtf90.qutraj_run.evolve(instanceno, rngseed, show_progress). # construct Result instance; sol = Result(); sol.ntraj = ntraj; # sol.col_times = qtf90.qutraj_run.col_times; # sol.col_which = qtf90.qutraj_run.col_which-1; sol.col_times, sol.col_which = self.get_collapses(ntraj); if (config.e_num == 0):; sol.states = self.get_states(len(config.tlist), ntraj); else:; sol.expect = self.get_expect(len(config.tlist), ntraj); if (self.calc_entropy):; sol.entropy = self.get_entropy(len(config.tlist)). if (not self.serial_run):; # put to queue; queue.put(sol); queue.join(). # deallocate stuff; # finalize(); return sol. # Routines for retrieving data data from fortran; def get_collapses(self, ntraj):. if debug:; print(inspect.stack()[0][3]). col_times = np.zeros((ntraj), dtype=np.ndarray); col_which = np.zeros((ntraj), dtype=np.ndarray); if (config.c_num == 0):; # no collapses; return col_times, col_which; for i in range(ntraj):; qtf90.qutraj_run.get_collapses(i + 1); times = qtf90.qutraj_run.col_times; which = qtf90.qutraj_run.col_which; if times is None:; times = np.array([]); if which is None:; which = np.array([]); else:; which = which - 1; col_times[i] = np.array(times, copy=True); col_which[i] = np.array(which, copy=True); return col_times, col_which. def get_states(self, nstep, ntraj):. if debug:; print(inspect.stack()[0][3]). from scipy.sparse import csr_matrix; if (config.options.average_states):; states = np.array([Qobj()] * nstep); if (self.sparse_dms):; # averaged sparse density matrices; for i in range",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:13358,Performance,queue,queue,13358,"st_step; qtf90.qutraj_run.min_step = config.options.min_step; qtf90.qutraj_run.max_step = config.options.max_step; qtf90.qutraj_run.norm_steps = config.options.norm_steps; qtf90.qutraj_run.norm_tol = config.options.norm_tol; # use sparse density matrices during computation?; qtf90.qutraj_run.rho_return_sparse = self.sparse_dms; # calculate entropy of reduced density matrice?; qtf90.qutraj_run.calc_entropy = self.calc_entropy; # run; show_progress = 1 if debug else 0; qtf90.qutraj_run.evolve(instanceno, rngseed, show_progress). # construct Result instance; sol = Result(); sol.ntraj = ntraj; # sol.col_times = qtf90.qutraj_run.col_times; # sol.col_which = qtf90.qutraj_run.col_which-1; sol.col_times, sol.col_which = self.get_collapses(ntraj); if (config.e_num == 0):; sol.states = self.get_states(len(config.tlist), ntraj); else:; sol.expect = self.get_expect(len(config.tlist), ntraj); if (self.calc_entropy):; sol.entropy = self.get_entropy(len(config.tlist)). if (not self.serial_run):; # put to queue; queue.put(sol); queue.join(). # deallocate stuff; # finalize(); return sol. # Routines for retrieving data data from fortran; def get_collapses(self, ntraj):. if debug:; print(inspect.stack()[0][3]). col_times = np.zeros((ntraj), dtype=np.ndarray); col_which = np.zeros((ntraj), dtype=np.ndarray); if (config.c_num == 0):; # no collapses; return col_times, col_which; for i in range(ntraj):; qtf90.qutraj_run.get_collapses(i + 1); times = qtf90.qutraj_run.col_times; which = qtf90.qutraj_run.col_which; if times is None:; times = np.array([]); if which is None:; which = np.array([]); else:; which = which - 1; col_times[i] = np.array(times, copy=True); col_which[i] = np.array(which, copy=True); return col_times, col_which. def get_states(self, nstep, ntraj):. if debug:; print(inspect.stack()[0][3]). from scipy.sparse import csr_matrix; if (config.options.average_states):; states = np.array([Qobj()] * nstep); if (self.sparse_dms):; # averaged sparse density matrices; for i in range",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:13374,Performance,queue,queue,13374,"min_step = config.options.min_step; qtf90.qutraj_run.max_step = config.options.max_step; qtf90.qutraj_run.norm_steps = config.options.norm_steps; qtf90.qutraj_run.norm_tol = config.options.norm_tol; # use sparse density matrices during computation?; qtf90.qutraj_run.rho_return_sparse = self.sparse_dms; # calculate entropy of reduced density matrice?; qtf90.qutraj_run.calc_entropy = self.calc_entropy; # run; show_progress = 1 if debug else 0; qtf90.qutraj_run.evolve(instanceno, rngseed, show_progress). # construct Result instance; sol = Result(); sol.ntraj = ntraj; # sol.col_times = qtf90.qutraj_run.col_times; # sol.col_which = qtf90.qutraj_run.col_which-1; sol.col_times, sol.col_which = self.get_collapses(ntraj); if (config.e_num == 0):; sol.states = self.get_states(len(config.tlist), ntraj); else:; sol.expect = self.get_expect(len(config.tlist), ntraj); if (self.calc_entropy):; sol.entropy = self.get_entropy(len(config.tlist)). if (not self.serial_run):; # put to queue; queue.put(sol); queue.join(). # deallocate stuff; # finalize(); return sol. # Routines for retrieving data data from fortran; def get_collapses(self, ntraj):. if debug:; print(inspect.stack()[0][3]). col_times = np.zeros((ntraj), dtype=np.ndarray); col_which = np.zeros((ntraj), dtype=np.ndarray); if (config.c_num == 0):; # no collapses; return col_times, col_which; for i in range(ntraj):; qtf90.qutraj_run.get_collapses(i + 1); times = qtf90.qutraj_run.col_times; which = qtf90.qutraj_run.col_which; if times is None:; times = np.array([]); if which is None:; which = np.array([]); else:; which = which - 1; col_times[i] = np.array(times, copy=True); col_which[i] = np.array(which, copy=True); return col_times, col_which. def get_states(self, nstep, ntraj):. if debug:; print(inspect.stack()[0][3]). from scipy.sparse import csr_matrix; if (config.options.average_states):; states = np.array([Qobj()] * nstep); if (self.sparse_dms):; # averaged sparse density matrices; for i in range(nstep):; qtf90.qutraj_run",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:4881,Usability,simpl,simply,4881,"options=Options(), sparse_dms=True, serial=False,; ptrace_sel=[], calc_entropy=False):; """"""; Monte-Carlo wave function solver with fortran 90 backend.; Usage is identical to qutip.mcsolve, for problems without explicit; time-dependence, and with some optional input:. Parameters; ----------; H : qobj; System Hamiltonian.; psi0 : qobj; Initial state vector; tlist : array_like; Times at which results are recorded.; ntraj : int; Number of trajectories to run.; c_ops : array_like; ``list`` or ``array`` of collapse operators.; e_ops : array_like; ``list`` or ``array`` of operators for calculating expectation values.; options : Options; Instance of solver options.; sparse_dms : boolean; If averaged density matrices are returned, they will be stored as; sparse (Compressed Row Format) matrices during computation if; sparse_dms = True (default), and dense matrices otherwise. Dense; matrices might be preferable for smaller systems.; serial : boolean; If True (default is False) the solver will not make use of the; multiprocessing module, and simply run in serial.; ptrace_sel: list; This optional argument specifies a list of components to keep when; returning a partially traced density matrix. This can be convenient for; large systems where memory becomes a problem, but you are only; interested in parts of the density matrix.; calc_entropy : boolean; If ptrace_sel is specified, calc_entropy=True will have the solver; return the averaged entropy over trajectories in results.entropy. This; can be interpreted as a measure of entanglement. See Phys. Rev. Lett.; 93, 120408 (2004), Phys. Rev. A 86, 022310 (2012). Returns; -------; results : Result; Object storing all results from simulation. """"""; if ntraj is None:; ntraj = options.ntraj. if psi0.type != 'ket':; raise Exception(""Initial state must be a state vector.""); config.options = options; # set num_cpus to the value given in qutip.settings; # if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.sett",MatchSource.WIKI,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html
https://qutip.org/docs/3.1.0/modules/qutip/qip/circuit.html:244,Deployability,install,installation,244,"﻿. qutip.qip.circuit — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.qip.circuit; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclai",MatchSource.WIKI,docs/3.1.0/modules/qutip/qip/circuit.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/qip/circuit.html
https://qutip.org/docs/3.1.0/modules/qutip/qip/circuit.html:31710,Deployability,update,updated,31710,"el(gate.name,; gate.arg_label))); else:; col.append(r"" \ghost{%s} "" %; (_gate_label(gate.name,; gate.arg_label))). elif gate.name == ""CNOT"":; col.append(r"" \targ ""); elif gate.name == ""SWAP"":; col.append(r"" \qswap ""); else:; col.append(r"" \gate{%s} "" %; _gate_label(gate.name, gate.arg_label)). elif gate.controls and n in gate.controls:; m = (gate.targets[0] - n) * (-1 if self.reverse_states; else 1); if gate.name == ""SWAP"":; col.append(r"" \qswap \ctrl{%d} "" % m); else:; col.append(r"" \ctrl{%d} "" % m). elif (not gate.controls and not gate.targets):; # global gate; if ((self.reverse_states and n == self.N - 1); or (not self.reverse_states and n == 0)):; col.append(r"" \multigate{%d}{%s} "" %; (self.N - 1,; _gate_label(gate.name, gate.arg_label))); else:; col.append(r"" \ghost{%s} "" %; (_gate_label(gate.name, gate.arg_label))). else:; col.append(r"" \qw ""). col.append(r"" \qw ""); rows.append(col). code = """"; n_iter = (reversed(range(self.N)) if self.reverse_states; else range(self.N)); for n in n_iter:; for m in range(len(gates)):; code += r"" & %s"" % rows[m][n]; code += r"" & \qw \\ "" + ""\n"". return code. def _repr_png_(self):; return _latex_compile(self.latex_code(), format=""png""). def _repr_svg_(self):; return _latex_compile(self.latex_code(), format=""svg""). @property; def png(self):; from IPython.display import Image; return Image(self._repr_png_(), embed=True). @property; def svg(self):; from IPython.display import SVG; return SVG(self._repr_svg_()). def qasm(self):. code = ""# qasm code generated by QuTiP\n\n"". for n in range(self.N):; code += ""\tqubit\tq%d\n"" % n. code += ""\n"". for gate in self.gates:; code += ""\t%s\t"" % gate.name; qtargets = [""q%d"" %; t for t in gate.targets] if gate.targets else []; qcontrols = ([""q%d"" % c for c in gate.controls] if gate.controls; else []); code += "","".join(qtargets + qcontrols); code += ""\n"". return code. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/modules/qutip/qip/circuit.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/qip/circuit.html
https://qutip.org/docs/3.1.0/modules/qutip/qip/circuit.html:7170,Modifiability,variab,variable,7170,"n gate %s"" % name); gate_label = name. if arg_label:; return r'%s(%s)' % (gate_label, arg_label); else:; return r'%s' % gate_label. [docs]class QubitCircuit(object):; """"""; Representation of a quantum program/algorithm, maintaining a sequence; of gates.; """""". def __init__(self, N, reverse_states=True):. # number of qubits in the register; self.N = N; self.reverse_states = reverse_states; self.gates = []; self.U_list = []. [docs] def add_gate(self, name, targets=None, controls=None, arg_value=None,; arg_label=None):; """"""; Adds a gate with specified parameters to the circuit. Parameters; ----------; name: String; Gate name.; targets: List; Gate targets.; controls: List; Gate controls.; arg_value: Float; Argument value(phi).; arg_label: String; Label for gate representation.; """"""; self.gates.append(Gate(name, targets=targets, controls=controls,; arg_value=arg_value, arg_label=arg_label)). [docs] def add_1q_gate(self, name, start=0, end=None, qubits=None,; arg_value=None, arg_label=None):; """"""; Adds a single qubit gate with specified parameters on a variable; number of qubits in the circuit. By default, it applies the given gate; to all the qubits in the register. Parameters; ----------; name: String; Gate name.; start: Integer; Starting location of qubits.; end: Integer; Last qubit for the gate.; qubits: List; Specific qubits for applying gates.; arg_value: Float; Argument value(phi).; arg_label: String; Label for gate representation.; """"""; if name not in [""RX"", ""RY"", ""RZ"", ""SNOT"", ""SQRTNOT"", ""PHASEGATE""]:; raise ValueError(""%s is not a single qubit gate"" % name). if qubits is not None:; for i in range(len(qubits)):; self.gates.append(Gate(name, targets=qubits[i], controls=None,; arg_value=arg_value,; arg_label=arg_label)). else:; if end is None:; end = self.N - 1; for i in range(start, end):; self.gates.append(Gate(name, targets=i, controls=None,; arg_value=arg_value,; arg_label=arg_label)). [docs] def add_circuit(self, qc, start=0):; """"""; Adds a block of a qubit circu",MatchSource.WIKI,docs/3.1.0/modules/qutip/qip/circuit.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/qip/circuit.html
https://qutip.org/docs/3.1.0/modules/qutip/qip/gates.html:242,Deployability,install,installation,242,"﻿. qutip.qip.gates — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.qip.gates; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.",MatchSource.WIKI,docs/3.1.0/modules/qutip/qip/gates.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/qip/gates.html
https://qutip.org/docs/3.1.0/modules/qutip/qip/gates.html:24880,Deployability,update,updated,24880,"], p[1]; p[1], p[0] = p[0], p[1]; p[1], p[controls[0]] = p[controls[0]], p[1]. elif target == 1 and controls[1] == 0:; # target -> controls[1] -> controls[0] -> outside; p[2], p[1] = p[1], p[2]; p[2], p[0] = p[0], p[2]; p[2], p[controls[0]] = p[controls[0]], p[2]. elif target == 0 and controls[0] == 1:; # target -> controls[0] -> controls[1] -> outside; p[2], p[0] = p[0], p[2]; p[2], p[1] = p[1], p[2]; p[2], p[controls[1]] = p[controls[1]], p[2]. elif controls[0] == 0 and controls[1] == 2:; # controls[0] -> self, controls[1] -> target -> outside; p[1], p[2] = p[2], p[1]; p[1], p[target] = p[target], p[1]. elif controls[1] == 1 and controls[0] == 2:; # controls[1] -> self, controls[0] -> target -> outside; p[0], p[2] = p[2], p[0]; p[0], p[target] = p[target], p[0]. elif target == 2 and controls[0] == 1:; # target -> self, controls[0] -> controls[1] -> outside; p[0], p[1] = p[1], p[0]; p[0], p[controls[1]] = p[controls[1]], p[0]. #; # N > 4 cases; #. elif controls[0] == 1 and controls[1] > 2 and target > 2:; # controls[0] -> controls[1] -> outside, target -> outside; p[0], p[1] = p[1], p[0]; p[0], p[controls[1]] = p[controls[1]], p[0]; p[2], p[target] = p[target], p[2]. elif controls[0] == 2 and controls[1] > 2 and target > 2:; # controls[0] -> target -> outside, controls[1] -> outside; p[0], p[2] = p[2], p[0]; p[0], p[target] = p[target], p[0]; p[1], p[controls[1]] = p[controls[1]], p[1]. elif controls[1] == 2 and controls[0] > 2 and target > 2:; # controls[1] -> target -> outside, controls[0] -> outside; p[1], p[2] = p[2], p[1]; p[1], p[target] = p[target], p[1]; p[0], p[controls[0]] = p[controls[0]], p[0]. else:; p[0], p[controls[0]] = p[controls[0]], p[0]; p1[1], p1[controls[1]] = p1[controls[1]], p1[1]; p2[2], p2[target] = p2[target], p2[2]; p = [p[p1[p2[k]]] for k in range(N)]. return tensor([U] + [identity(2)] * (N - 3)).permute(p). Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/modules/qutip/qip/gates.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/qip/gates.html
https://qutip.org/docs/3.1.0/modules/qutip/qip/models.html:243,Deployability,install,installation,243,"﻿. qutip.qip.models — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.qip.models; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaime",MatchSource.WIKI,docs/3.1.0/modules/qutip/qip/models.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/qip/models.html
https://qutip.org/docs/3.1.0/modules/qutip/qip/models.html:3455,Deployability,update,updated,3455,"phy. Page . Source code for qutip.qip.models; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; from qutip.qip.models.circuitprocessor import CircuitProcessor. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/modules/qutip/qip/models.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/qip/models.html
https://qutip.org/docs/3.1.0/modules/qutip/qip/qubits.html:243,Deployability,install,installation,243,"﻿. qutip.qip.qubits — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.qip.qubits; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaime",MatchSource.WIKI,docs/3.1.0/modules/qutip/qip/qubits.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/qip/qubits.html
https://qutip.org/docs/3.1.0/modules/qutip/qip/qubits.html:3953,Deployability,update,updated,3953," # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['qubit_states']. from qutip.tensor import tensor. [docs]def qubit_states(N=1, states=[0]):; """"""; Function to define initial state of the qubits. Parameters; ----------; N: Integer; Number of qubits in the register.; states: List; Initial state of each qubit. Returns; ----------; qstates: Qobj; List of qubits.; """"""; state_list = []; for i in range(N):; if N > len(states) and i >= len(states):; state_list.append(0); else:; state_list.append(states[i]). return tensor(alpha * basis(2, 0) + sqrt(1 - alpha**2) * basis(2, 1); for alpha in state_list). Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/modules/qutip/qip/qubits.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/qip/qubits.html
https://qutip.org/docs/3.1.0/modules/qutip/qip/algorithms/qft.html:251,Deployability,install,installation,251,"﻿. qutip.qip.algorithms.qft — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.qip.algorithms.qft; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the fol",MatchSource.WIKI,docs/3.1.0/modules/qutip/qip/algorithms/qft.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/qip/algorithms/qft.html
https://qutip.org/docs/3.1.0/modules/qutip/qip/algorithms/qft.html:5689,Deployability,update,updated,5689,"be 1""). N2 = 2 ** N; phase = 2.0j * np.pi / N2; arr = np.arange(N2); L, M = np.meshgrid(arr, arr); L = phase * (L * M); L = np.exp(L); dims = [[2] * N, [2] * N]; return Qobj(1.0 / np.sqrt(N2) * L, dims=dims). [docs]def qft_steps(N=1, swapping=True):; """"""; Quantum Fourier Transform operator on N qubits returning the individual; steps as unitary matrices operating from left to right. Parameters; ----------; N: int; Number of qubits.; swap: boolean; Flag indicating sequence of swap gates to be applied at the end or not. Returns; -------; U_step_list: list of qobj; List of Hadamard and controlled rotation gates implementing QFT. """"""; if N < 1:; raise ValueError(""Minimum value of N can be 1""). U_step_list = []; if N == 1:; U_step_list.append(snot()); else:; for i in range(N):; for j in range(i):; U_step_list.append(cphase(np.pi / (2 ** (i - j)), N,; control=i, target=j)); U_step_list.append(snot(N, i)); if swapping is True:; for i in range(N // 2):; U_step_list.append(swap(N, [N - i - 1, i])). return U_step_list. [docs]def qft_gate_sequence(N=1, swapping=True):; """"""; Quantum Fourier Transform operator on N qubits returning the gate sequence. Parameters; ----------; N: int; Number of qubits.; swap: boolean; Flag indicating sequence of swap gates to be applied at the end or not. Returns; -------; qc: instance of QubitCircuit; Gate sequence of Hadamard and controlled rotation gates implementing; QFT.; """""". if N < 1:; raise ValueError(""Minimum value of N can be 1""). qc = QubitCircuit(N); if N == 1:; qc.add_gate(""SNOT"", targets=[0]); else:; for i in range(N):; for j in range(i):; qc.add_gate(r""CPHASE"", targets=[j], controls=[i],; arg_label=r""{\pi/2^{%d}}"" % (i - j),; arg_value=np.pi / (2 ** (i - j))); qc.add_gate(""SNOT"", targets=[i]); if swapping is True:; for i in range(N // 2):; qc.add_gate(r""SWAP"", targets=[i], controls=[N - 1 - i]). return qc. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/modules/qutip/qip/algorithms/qft.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/qip/algorithms/qft.html
https://qutip.org/docs/3.1.0/modules/qutip/qip/models/cqed.html:248,Deployability,install,installation,248,"﻿. qutip.qip.models.cqed — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.qip.models.cqed; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following",MatchSource.WIKI,docs/3.1.0/modules/qutip/qip/models/cqed.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/qip/models/cqed.html
https://qutip.org/docs/3.1.0/modules/qutip/qip/models/cqed.html:10481,Deployability,update,updated,10481,"r""-\pi/4"")); elif gate.name == ""ISWAP"":; qc.gates.append(Gate(""RZ"", [gate.targets[0]], None,; arg_value=-np.pi / 2,; arg_label=r""-\pi/2"")); qc.gates.append(Gate(""RZ"", [gate.targets[1]], None,; arg_value=-np.pi / 2,; arg_label=r""-\pi/2"")); qc.gates.append(Gate(""GLOBALPHASE"", None, None,; arg_value=-np.pi / 2,; arg_label=r""-\pi/2"")). return qc. def load_circuit(self, qc):. gates = self.optimize_circuit(qc).gates. self.global_phase = 0; self.sx_u = np.zeros((len(gates), len(self.sx_ops))); self.sz_u = np.zeros((len(gates), len(self.sz_ops))); self.g_u = np.zeros((len(gates), len(self.cavityqubit_ops))); self.T_list = []. n = 0; for gate in gates:. if gate.name == ""ISWAP"":; t0, t1 = gate.targets[0], gate.targets[1]; self.sz_u[n, t0] = self.wq[t0] - self.w0; self.sz_u[n, t1] = self.wq[t1] - self.w0; self.g_u[n, t0] = self.g[t0]; self.g_u[n, t1] = self.g[t1]. J = self.g[t0] * self.g[t1] * (1 / self.Delta[t0] +; 1 / self.Delta[t1]) / 2; T = (4 * np.pi / abs(J)) / 4; self.T_list.append(T); n += 1. elif gate.name == ""SQRTISWAP"":; t0, t1 = gate.targets[0], gate.targets[1]; self.sz_u[n, t0] = self.wq[t0] - self.w0; self.sz_u[n, t1] = self.wq[t1] - self.w0; self.g_u[n, t0] = self.g[t0]; self.g_u[n, t1] = self.g[t1]. J = self.g[t0] * self.g[t1] * (1 / self.Delta[t0] +; 1 / self.Delta[t1]) / 2; T = (4 * np.pi / abs(J)) / 8; self.T_list.append(T); n += 1. elif gate.name == ""RZ"":; g = self.sz_coeff[gate.targets[0]]; self.sz_u[n, gate.targets[0]] = np.sign(gate.arg_value) * g; T = abs(gate.arg_value) / (2 * g); self.T_list.append(T); n += 1. elif gate.name == ""RX"":; g = self.sx_coeff[gate.targets[0]]; self.sx_u[n, gate.targets[0]] = np.sign(gate.arg_value) * g; T = abs(gate.arg_value) / (2 * g); self.T_list.append(T); n += 1. elif gate.name == ""GLOBALPHASE"":; self.global_phase += gate.arg_value. else:; raise ValueError(""Unsupported gate %s"" % gate.name). Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/modules/qutip/qip/models/cqed.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/qip/models/cqed.html
https://qutip.org/docs/3.1.0/modules/qutip/qip/models/cqed.html:3912,Energy Efficiency,energy,energy,3912,"MPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; import numpy as np; import warnings; from qutip import tensor, identity, destroy, sigmax, sigmaz, basis; from qutip.qip.circuit import QubitCircuit, Gate; from qutip.qip.models.circuitprocessor import CircuitProcessor. [docs]class DispersivecQED(CircuitProcessor):; """"""; Representation of the physical implementation of a quantum; program/algorithm on a dispersive cavity-QED system.; """""". def __init__(self, N, correct_global_phase=True, Nres=None, deltamax=None,; epsmax=None, w0=None, wq=None, eps=None, delta=None, g=None):; """"""; Parameters; ----------; Nres: Integer; The number of energy levels in the resonator. deltamax: Integer/List; The sigma-x coefficient for each of the qubits in the system. epsmax: Integer/List; The sigma-z coefficient for each of the qubits in the system. wo: Integer; The base frequency of the resonator. wq: Integer/List; The frequency of the qubits. eps: Integer/List; The epsilon for each of the qubits in the system. delta: Integer/List; The epsilon for each of the qubits in the system. g: Integer/List; The interaction strength for each of the qubit with the resonator.; """""". super(DispersivecQED, self).__init__(N, correct_global_phase). # user definable; if Nres is None:; self.Nres = 10; else:; self.Nres = Nres. if deltamax is None:; self.sx_coeff = np.array([1.0 * 2 * np.pi] * N); elif not isinstance(deltamax, list):; self.sx_coeff = np.array([deltamax * 2 * np.pi] * N); else:; self.sx_coeff = np.array(deltamax). if epsmax is None:; self.sz_coeff = np.arr",MatchSource.WIKI,docs/3.1.0/modules/qutip/qip/models/cqed.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/qip/models/cqed.html
https://qutip.org/docs/3.1.0/modules/qutip/qip/models/cqed.html:6141,Testability,test,tests,6141,"):; self.eps = np.array([eps * 2 * np.pi] * N); else:; self.eps = np.array(eps). if delta is None:; self.delta = np.array([0.0 * 2 * np.pi] * N); elif not isinstance(delta, list):; self.delta = np.array([delta * 2 * np.pi] * N); else:; self.delta = np.array(delta). if g is None:; self.g = np.array([0.01 * 2 * np.pi] * N); elif not isinstance(g, list):; self.g = np.array([g * 2 * np.pi] * N); else:; self.g = np.array(g). if wq is not None:; if not isinstance(wq, list):; self.wq = np.array([wq] * N); else:; self.wq = np.array(wq). if wq is None:; if eps is None:; self.eps = np.array([9.5 * 2 * np.pi] * N); elif not isinstance(eps, list):; self.eps = np.array([eps] * N); else:; self.eps = np.array(eps). if delta is None:; self.delta = np.array([0.0 * 2 * np.pi] * N); elif not isinstance(delta, list):; self.delta = np.array([delta] * N); else:; self.delta = np.array(delta). # computed; self.wq = np.sqrt(self.eps ** 2 + self.delta ** 2); self.Delta = self.wq - self.w0. # rwa/dispersive regime tests; if any(self.g / (self.w0 - self.wq) > 0.05):; warnings.warn(""Not in the dispersive regime""). if any((self.w0 - self.wq) / (self.w0 + self.wq) > 0.05):; warnings.warn(; ""The rotating-wave approximation might not be valid.""). self.sx_ops = [tensor([identity(self.Nres)] +; [sigmax() if m == n else identity(2); for n in range(N)]); for m in range(N)]; self.sz_ops = [tensor([identity(self.Nres)] +; [sigmaz() if m == n else identity(2); for n in range(N)]); for m in range(N)]. self.a = tensor([destroy(self.Nres)] + [identity(2) for n in range(N)]). self.cavityqubit_ops = []; for n in range(N):; sm = tensor([identity(self.Nres)] +; [destroy(2) if m == n else identity(2); for m in range(N)]); self.cavityqubit_ops.append(self.a.dag() * sm + self.a * sm.dag()). self.psi_proj = tensor([basis(self.Nres, 0)] +; [identity(2) for n in range(N)]). def get_ops_and_u(self):; H0 = self.a.dag() * self.a; return ([H0] + self.sx_ops + self.sz_ops + self.cavityqubit_ops,; np.hstack((self.w0 * np.ze",MatchSource.WIKI,docs/3.1.0/modules/qutip/qip/models/cqed.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/qip/models/cqed.html
https://qutip.org/docs/3.1.0/modules/qutip/qip/models/spinchain.html:253,Deployability,install,installation,253,"﻿. qutip.qip.models.spinchain — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.qip.models.spinchain; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the",MatchSource.WIKI,docs/3.1.0/modules/qutip/qip/models/spinchain.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/qip/models/spinchain.html
https://qutip.org/docs/3.1.0/modules/qutip/qip/models/spinchain.html:13742,Deployability,update,updated,13742,"n of a quantum; program/algorithm on a spin chain qubit system arranged in a linear; formation. It is a sub-class of SpinChain.; """""". def __init__(self, N, correct_global_phase=True,; sx=None, sz=None, sxsy=None):. super(LinearSpinChain, self).__init__(N, correct_global_phase,; sx, sz, sxsy). def get_ops_labels(self):; return ([r""$\sigma_x^%d$"" % n for n in range(self.N)] +; [r""$\sigma_z^%d$"" % n for n in range(self.N)] +; [r""$\sigma_x^%d\sigma_x^{%d} + \sigma_y^%d\sigma_y^{%d}$""; % (n, n, n + 1, n + 1) for n in range(self.N - 1)]). def optimize_circuit(self, qc):; self.qc0 = qc; self.qc1 = self.adjacent_gates(self.qc0, ""linear""); self.qc2 = self.qc1.resolve_gates(basis=[""ISWAP"", ""RX"", ""RZ""]); return self.qc2. [docs]class CircularSpinChain(SpinChain):; """"""; Representation of the physical implementation of a quantum; program/algorithm on a spin chain qubit system arranged in a circular; formation. It is a sub-class of SpinChain.; """""". def __init__(self, N, correct_global_phase=True,; sx=None, sz=None, sxsy=None):. super(CircularSpinChain, self).__init__(N, correct_global_phase,; sx, sz, sxsy). x = [identity(2)] * N; x[0] = x[N - 1] = sigmax(); y = [identity(2)] * N; y[0] = y[N - 1] = sigmay(); self.sxsy_ops.append(tensor(x) + tensor(y)). if sxsy is None:; self.sxsy_coeff = [0.1 * 2 * np.pi] * N; elif not isinstance(sxsy, list):; self.sxsy_coeff = [sxsy * 2 * np.pi] * N; else:; self.sxsy_coeff = sxsy. def get_ops_labels(self):; return ([r""$\sigma_x^%d$"" % n for n in range(self.N)] +; [r""$\sigma_z^%d$"" % n for n in range(self.N)] +; [r""$\sigma_x^%d\sigma_x^{%d} + \sigma_y^%d\sigma_y^{%d}$""; % (n, n, (n + 1) % self.N, (n + 1) % self.N); for n in range(self.N)]). def optimize_circuit(self, qc):; self.qc0 = qc; self.qc1 = self.adjacent_gates(self.qc0, ""circular""); self.qc2 = self.qc1.resolve_gates(basis=[""ISWAP"", ""RX"", ""RZ""]); return self.qc2. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/modules/qutip/qip/models/spinchain.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/qip/models/spinchain.html
https://qutip.org/docs/4.0.2/apidoc/apidoc.html:1757,Deployability,update,updated,1757,". . API documentation — QuTiP 4.0 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.0; . Frontmatter; Installation; Users Guide; API documentation; Classes; Functions. Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; API documentation. API documentation¶; This chapter contains automatically generated API documentation, including a; complete list of QuTiP’s public classes and functions. Classes; Qobj; eseries; Bloch sphere; non-Markovian Solvers; Solver Options and Results; Distribution functions; Quantum information processing; Optimal control. Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Random Operators and States; Three-Level Atoms; Superoperators and Liouvillians; Superoperator Representations. Functions acting on states and operators; Tensor; Expectation Values; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continous Variables. Dynamics and Time-Evolution; Schrödinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic Schrödinger Equation and Master Equation; Correlation Functions; Steady-state Solvers; Propagators; Time-dependent problems. Visualization; Pseudoprobability Functions; Graphs and Visualization; Quantum Process Tomography. Quantum Information Processing; Gates; Qubits; Algorithms. non-Markovian Solvers; Optimal control; GRAPE; CRAB. Utilitiy Functions; Graph Theory Routines; Utility Functions; File I/O Functions; Parallelization; IPython Notebook Tools; Miscellaneous. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/apidoc/apidoc.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/apidoc.html
https://qutip.org/docs/4.0.2/apidoc/apidoc.html:1261,Integrability,depend,dependent,1261,". . API documentation — QuTiP 4.0 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.0; . Frontmatter; Installation; Users Guide; API documentation; Classes; Functions. Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; API documentation. API documentation¶; This chapter contains automatically generated API documentation, including a; complete list of QuTiP’s public classes and functions. Classes; Qobj; eseries; Bloch sphere; non-Markovian Solvers; Solver Options and Results; Distribution functions; Quantum information processing; Optimal control. Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Random Operators and States; Three-Level Atoms; Superoperators and Liouvillians; Superoperator Representations. Functions acting on states and operators; Tensor; Expectation Values; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continous Variables. Dynamics and Time-Evolution; Schrödinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic Schrödinger Equation and Master Equation; Correlation Functions; Steady-state Solvers; Propagators; Time-dependent problems. Visualization; Pseudoprobability Functions; Graphs and Visualization; Quantum Process Tomography. Quantum Information Processing; Gates; Qubits; Algorithms. non-Markovian Solvers; Optimal control; GRAPE; CRAB. Utilitiy Functions; Graph Theory Routines; Utility Functions; File I/O Functions; Parallelization; IPython Notebook Tools; Miscellaneous. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/apidoc/apidoc.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/apidoc.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:6062,Availability,toler,tolerance,6062,"d. Return type:array. dnorm(B=None)[source]¶; Calculates the diamond norm, or the diamond distance to another operator. Parameters:B (Qobj or None) – If B is not None, the diamond distance d(A, B) = dnorm(A - B) between; this operator and B is returned instead of the diamond norm. Returns:d – Either the diamond norm of this operator, or the diamond distance; from this operator to B. Return type:float. dual_chan()[source]¶; Dual channel of quantum object representing a completely positive; map. eigenenergies(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)[source]¶; Eigenenergies of a quantum object.; Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters:; sparse (bool) – Use sparse Eigensolver; sort (str) – Sort eigenvalues ‘low’ to high, or ‘high’ to low.; eigvals (int) – Number of requested eigenvalues. Default is all eigenvalues.; tol (float) – Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter (int) – Maximum number of iterations performed by sparse solver (if used). Returns:eigvals – Array of eigenvalues for operator. Return type:array. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)[source]¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters:; sparse (bool) – Use sparse Eigensolver; sort (str) – Sort eigenvalues (and vectors) ‘low’ to high, or ‘high’ to low.; eigvals (int) – Number of requested eigenvalues. Default is all eigenvalues.; tol (float) – Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter (int) – Maximum number of iterations performed by sparse solver (if used). Returns:; eigvals (array) – Array of eigenvalues for op",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:6888,Availability,toler,tolerance,6888,"t) – Number of requested eigenvalues. Default is all eigenvalues.; tol (float) – Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter (int) – Maximum number of iterations performed by sparse solver (if used). Returns:eigvals – Array of eigenvalues for operator. Return type:array. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)[source]¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters:; sparse (bool) – Use sparse Eigensolver; sort (str) – Sort eigenvalues (and vectors) ‘low’ to high, or ‘high’ to low.; eigvals (int) – Number of requested eigenvalues. Default is all eigenvalues.; tol (float) – Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter (int) – Maximum number of iterations performed by sparse solver (if used). Returns:; eigvals (array) – Array of eigenvalues for operator.; eigvecs (array) – Array of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eliminate_states(states_inds, normalize=False)[source]¶; Creates a new quantum object with states in state_inds eliminated. Parameters:; states_inds (list of integer) – The states that should be removed.; normalize (True / False) – Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q – A new instance of qutip.Qobj t",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:8923,Availability,avail,available,8923,"ot in state_inds. Return type:Qobj. Notes; Experimental. static evaluate(qobj_list, t, args)[source]¶; Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]; is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args); and. qobj_list = [H0, [H1, ‘sin(w * t)’]]; is evaluated to. Qobj(t) = H0 + H1 * sin(args[‘w’] * t). Parameters:; qobj_list (list) – A nested list of Qobj instances and corresponding time-dependent; coefficients.; t (float) – The time for which to evaluate the time-dependent Qobj instance.; args (dictionary) – A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns:output – A Qobj instance that represents the value of qobj_list at time t. Return type:Qobj. expm(method='dense')[source]¶; Matrix exponential of quantum operator.; Input operator must be square. Parameters:method (str {'dense', 'sparse'}) – Use set method to use to calculate the matrix exponentiation. The; available choices includes ‘dense’ and ‘sparse’. Since the; exponential of a matrix is nearly always dense, method=’dense’; is set as default.s. Returns:oper – Exponentiated quantum operator. Return type:qobj. Raises:TypeError – Quantum operator is not square. extract_states(states_inds, normalize=False)[source]¶; Qobj with states in state_inds only. Parameters:; states_inds (list of integer) – The states that should be kept.; normalize (True / False) – Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q – A new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Return type:Qobj. Notes; Experimental. full(squeeze=False)[source]¶; Dense array from quantum object. Returns:data – Array of complex data from quantum objects data",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:10313,Availability,toler,tolerance,10313,"ist of integer) – The states that should be kept.; normalize (True / False) – Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q – A new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Return type:Qobj. Notes; Experimental. full(squeeze=False)[source]¶; Dense array from quantum object. Returns:data – Array of complex data from quantum objects data attribute. Return type:array. groundstate(sparse=False, tol=0, maxiter=100000, safe=True)[source]¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters:; sparse (bool) – Use sparse Eigensolver; tol (float) – Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter (int) – Maximum number of iterations performed by sparse solver (if used).; safe (bool (default=True)) – Check for degenerate ground state. Returns:; eigval (float) – Eigenvalue for the ground state of quantum operator.; eigvec (qobj) – Eigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. matrix_element(bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters:; bra (qobj) – Quantum object of type ‘bra’.; ket (qobj) – Quantum object of type ‘ket’. Returns:elem – Complex valued matrix element. Return type:complex. Raises:TypeError – Can only calculate matrix elements between a bra and ket; quantum object. norm(norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:11786,Availability,toler,tolerance,11786,"ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters:; bra (qobj) – Quantum object of type ‘bra’.; ket (qobj) – Quantum object of type ‘ket’. Returns:elem – Complex valued matrix element. Return type:complex. Raises:TypeError – Can only calculate matrix elements between a bra and ket; quantum object. norm(norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Parameters:; norm (str) – Which norm to use for ket/bra vectors: L2 ‘l2’, max norm ‘max’,; or for operators: trace ‘tr’, Frobius ‘fro’, one ‘one’, or max; ‘max’.; sparse (bool) – Use sparse eigenvalue solver for trace norm. Other norms are not; affected by this parameter.; tol (float) – Tolerance for sparse solver (if used) for trace norm. The sparse; solver may not converge if the tolerance is set too low.; maxiter (int) – Maximum number of iterations performed by sparse solver (if used); for trace norm. Returns:norm – The requested norm of the operator or state quantum object. Return type:float. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. overlap(state)[source]¶; Overlap between two state vectors.; Gives the overlap (scalar product) for the quantum object and state; state vector. Parameters:state (qobj) – Quantum object for a state vector of type ‘ket’ or ‘bra’. Returns:overlap – Complex valued overlap. Return type:complex. Raises:TypeError – Can only calculate overlap between a bra and ket quantum objects. permute(order)[source]¶; Permutes a composite quantum object. Parameters:order (list/array) – List specifying new tensor order. Returns:P – Permuted quantum object. Return type:qobj. ptrace(sel)[source]¶; Partial trace of the quantum object. Parameters:sel (int/list) – An in",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:13907,Availability,toler,tolerance,13907,"components; remaining. Return type:qobj. Notes; This function is identical to the qutip.qobj.ptrace function; that has been deprecated. sinm()[source]¶; Sine of a quantum operator.; Operator must be square. Returns:oper – Matrix sine of operator. Return type:qobj. Raises:TypeError – Quantum object is not square. Notes; Uses the Q.expm() method. sqrtm(sparse=False, tol=0, maxiter=100000)[source]¶; Sqrt of a quantum operator.; Operator must be square. Parameters:; sparse (bool) – Use sparse eigenvalue/vector solver.; tol (float) – Tolerance used by sparse solver (0 = machine precision).; maxiter (int) – Maximum number of iterations used by sparse solver. Returns:oper – Matrix square root of operator. Return type:qobj. Raises:TypeError – Quantum object is not square. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. tidyup(atol=None)[source]¶; Removes small elements from the quantum object. Parameters:atol (float) – Absolute tolerance used by tidyup. Default is set; via qutip global settings parameters. Returns:oper – Quantum object with small elements removed. Return type:qobj. tr()[source]¶; Trace of a quantum object. Returns:trace – Returns real if operator is Hermitian, returns complex; otherwise. Return type:float. trans()[source]¶; Transposed operator. Returns:oper – Transpose of input operator. Return type:qobj. transform(inpt, inverse=False, sparse=True)[source]¶; Basis transform defined by input array.; Input array can be a matrix defining the transformation,; or a list of kets that defines the new basis. Parameters:; inpt (array_like) – A matrix or list of kets defining the transformation.; inverse (bool) – Whether to return inverse transformation.; sparse (bool) – Use sparse matrices when possible. Can be slower. Returns:oper – Operator in new basis. Return type:qobj. Notes; This function is still in development. trunc_neg(method='clip')[source]¶; Truncates negative eigenvalues and renormal",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:36193,Availability,toler,tolerance,36193,"s learning times if argument; dynmaps is a callback function. thres¶; float – Threshold for halting. Halts if \(||T_{n}-T_{n-1}||\) is below; treshold. options¶; qutip.solver.Options – Generic solver options. Solver Options and Results¶. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False, store_final_state=False, store_states=False, seeds=None, steady_state_average=False, normalize_output=True)[source]¶; Class of options for evolution solvers such as qutip.mesolve and; qutip.mcsolve. Options can be specified either as arguments to the; constructor:; opts = Options(order=10, ...). or by changing the class attributes after creation:; opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. atol¶; float {1e-8} – Absolute tolerance. rtol¶; float {1e-6} – Relative tolerance. method¶; str {‘adams’,’bdf’} – Integration method. order¶; int {12} – Order of integrator (<=12 ‘adams’, <=5 ‘bdf’). nsteps¶; int {2500} – Max. number of internal steps/call. first_step¶; float {0} – Size of initial step (0 = automatic). min_step¶; float {0} – Minimum step size (0 = automatic). max_step¶; float {0} – Maximum step size (0 = automatic). tidy¶; bool {True,False} – Tidyup Hamiltonian and initial state by removing small terms. num_cpus¶; int – Number of cpus used by mcsolver (default = # of cpus). norm_tol¶; float – Tolerance used when finding wavefunction norm in mcsolve. norm_steps¶; int – Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve. average_states¶; bool {False} – Average states values over trajectories in stochastic solvers. average_expect¶; bool {True} – Average expectation values over trajectories for stochastic solvers. mc_corr_eps¶; float {1e-10} – Arbitrarily smal",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:36235,Availability,toler,tolerance,36235," callback function. thres¶; float – Threshold for halting. Halts if \(||T_{n}-T_{n-1}||\) is below; treshold. options¶; qutip.solver.Options – Generic solver options. Solver Options and Results¶. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False, store_final_state=False, store_states=False, seeds=None, steady_state_average=False, normalize_output=True)[source]¶; Class of options for evolution solvers such as qutip.mesolve and; qutip.mcsolve. Options can be specified either as arguments to the; constructor:; opts = Options(order=10, ...). or by changing the class attributes after creation:; opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. atol¶; float {1e-8} – Absolute tolerance. rtol¶; float {1e-6} – Relative tolerance. method¶; str {‘adams’,’bdf’} – Integration method. order¶; int {12} – Order of integrator (<=12 ‘adams’, <=5 ‘bdf’). nsteps¶; int {2500} – Max. number of internal steps/call. first_step¶; float {0} – Size of initial step (0 = automatic). min_step¶; float {0} – Minimum step size (0 = automatic). max_step¶; float {0} – Maximum step size (0 = automatic). tidy¶; bool {True,False} – Tidyup Hamiltonian and initial state by removing small terms. num_cpus¶; int – Number of cpus used by mcsolver (default = # of cpus). norm_tol¶; float – Tolerance used when finding wavefunction norm in mcsolve. norm_steps¶; int – Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve. average_states¶; bool {False} – Average states values over trajectories in stochastic solvers. average_expect¶; bool {True} – Average expectation values over trajectories for stochastic solvers. mc_corr_eps¶; float {1e-10} – Arbitrarily small value for eliminating any divide-by-zero",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:37225,Availability,error,errors,37225,"l¶; float {1e-6} – Relative tolerance. method¶; str {‘adams’,’bdf’} – Integration method. order¶; int {12} – Order of integrator (<=12 ‘adams’, <=5 ‘bdf’). nsteps¶; int {2500} – Max. number of internal steps/call. first_step¶; float {0} – Size of initial step (0 = automatic). min_step¶; float {0} – Minimum step size (0 = automatic). max_step¶; float {0} – Maximum step size (0 = automatic). tidy¶; bool {True,False} – Tidyup Hamiltonian and initial state by removing small terms. num_cpus¶; int – Number of cpus used by mcsolver (default = # of cpus). norm_tol¶; float – Tolerance used when finding wavefunction norm in mcsolve. norm_steps¶; int – Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve. average_states¶; bool {False} – Average states values over trajectories in stochastic solvers. average_expect¶; bool {True} – Average expectation values over trajectories for stochastic solvers. mc_corr_eps¶; float {1e-10} – Arbitrarily small value for eliminating any divide-by-zero errors in; correlation calculations when using mcsolve. ntraj¶; int {500} – Number of trajectories in stochastic solvers. rhs_reuse¶; bool {False,True} – Reuse Hamiltonian data. rhs_with_state¶; bool {False,True} – Whether or not to include the state in the Hamiltonian function; callback signature. rhs_filename¶; str – Name for compiled Cython file. seeds¶; ndarray – Array containing random number seeds for mcsolver. store_final_state¶; bool {False, True} – Whether or not to store the final state of the evolution in the; result class. store_states¶; bool {False, True} – Whether or not to store the state vectors or density matrices in the; result class, even if expectation values operators are given. If no; expectation are provided, then states are stored by default and this; option has no effect. class Result[source]¶; Class for storing simulation results from any of the dynamics solvers. solver¶; str – Which solver was used [e.g., ‘mesolve’, ‘mcsolve’, ‘brmesolve’, ..",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:45374,Availability,toler,tolerance,45374,"y needed to explicitly; create an instance of this class. H¶; qutip.Qobj – System Hamiltonian. state0¶; qutip.Qobj – Initial state vector (ket) or density matrix. times¶; list* / *array – List of times for \(t\). Must be uniformly spaced. c_ops¶; list of qutip.Qobj – List of deterministic collapse operators. sc_ops¶; list of qutip.Qobj – List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the equation of motion according to how the d1 and d2 functions; are defined. e_ops¶; list of qutip.Qobj – Single operator or list of operators for which to evaluate; expectation values. m_ops¶; list of qutip.Qobj – List of operators representing the measurement operators. The expected; format is a nested list with one measurement operator for each; stochastic increament, for each stochastic collapse operator. args¶; dict / list – List of dictionary of additional problem-specific parameters.; Implicit methods can adjust tolerance via args = {‘tol’:value}. ntraj¶; int – Number of trajectors. nsubsteps¶; int – Number of sub steps between each time-spep given in times. d1¶; function – Function for calculating the operator-valued coefficient to the; deterministic increment dt. d2¶; function – Function for calculating the operator-valued coefficient to the; stochastic increment(s) dW_n, where n is in [0, d2_len[. d2_len¶; int (default 1) – The number of stochastic increments in the process. dW_factors¶; array – Array of length d2_len, containing scaling factors for each; measurement operator in m_ops. rhs¶; function – Function for calculating the deterministic and stochastic contributions; to the right-hand side of the stochastic differential equation. This; only needs to be specified when implementing a custom SDE solver. generate_A_ops¶; function – Function that generates a list of pre-computed operators or super-; operators. These precomputed operators are used in some d1 and d2; functions. generate_noise¶",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:47088,Availability,toler,tolerance,47088,"al equation. This; only needs to be specified when implementing a custom SDE solver. generate_A_ops¶; function – Function that generates a list of pre-computed operators or super-; operators. These precomputed operators are used in some d1 and d2; functions. generate_noise¶; function – Function for generate an array of pre-computed noise signal. homogeneous¶; bool (True) – Wheter or not the stochastic process is homogenous. Inhomogenous; processes are only supported for poisson distributions. solver¶; string – Name of the solver method to use for solving the stochastic; equations. Valid values are:; 1/2 order algorithms: ‘euler-maruyama’, ‘fast-euler-maruyama’,; ‘pc-euler’ is a predictor-corrector method which is more; stable than explicit methods,; 1 order algorithms: ‘milstein’, ‘fast-milstein’, ‘platen’,; ‘milstein-imp’ is semi-implicit Milstein method,; 3/2 order algorithms: ‘taylor15’,; ‘taylor15-imp’ is semi-implicit Taylor 1.5 method.; Implicit methods can adjust tolerance via args = {‘tol’:value},; default is {‘tol’:1e-6}. method¶; string (‘homodyne’, ‘heterodyne’, ‘photocurrent’) – The name of the type of measurement process that give rise to the; stochastic equation to solve. Specifying a method with this keyword; argument is a short-hand notation for using pre-defined d1 and d2; functions for the corresponding stochastic processes. distribution¶; string (‘normal’, ‘poission’) – The name of the distribution used for the stochastic increments. store_measurements¶; bool (default False) – Whether or not to store the measurement results in the; qutip.solver.SolverResult instance returned by the solver. noise¶; array – Vector specifying the noise. normalize¶; bool (default True) – Whether or not to normalize the wave function during the evolution. options¶; qutip.solver.Options – Generic solver options. map_func¶; function – A map function or managing the calls to single-trajactory solvers. map_kwargs¶; dictionary – Optional keyword arguments to the map_func fun",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:60698,Availability,error,error,60698,"e logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params¶; Dictionary – The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg¶; string – Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params¶; Dictionary – options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg¶; bool – Set true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_method¶; string – a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_params¶; Dictionary – Options for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_grad¶; bool – If set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound¶; float or list of floats – lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound¶; float or list of floats – upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds¶; List of floats – Bounds for the paramete",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:64671,Availability,error,error,64671," matches an attribute of this object or the; termination conditions object, then the value of this attribute; is set. Otherwise it is assumed to a method_option for the; scipy.optimize.minimize function. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. dumping¶. The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms ",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:65049,Availability,error,error,65049," called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. dumping¶. The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; Thi",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:65226,Availability,error,error,65226,"written if they do. dumping¶. The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]¶; Check the elapsed wall time for the optimi",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:66474,Availability,error,error,66474,"ed as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(term_conds=None)[source]¶; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algor",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:67656,Availability,error,error,67656,"l time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. max_metric_corr¶; integer – The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:69006,Availability,error,error,69006,"nditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. max_metric_corr¶; integer – The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses t",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:70199,Availability,error,error,70199,"f the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity ",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:70761,Availability,error,error,70761,"ot None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be ",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:71206,Availability,error,error,71206,"init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimIterSummary[source]¶; A summary of the most recent iteration of the pulse optimisation. iter_num¶; int – Iteration number of the pulse optimisation. fid_func_call_num¶; int – Fidelity function call number of the pulse optimisation. grad_func_call_num¶; int – Gradient function call number of the pulse optimisation. fid_err¶; float – Fi",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:72308,Availability,error,error,72308,"in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimIterSummary[source]¶; A summary of the most recent iteration of the pulse optimisation. iter_num¶; int – Iteration number of the pulse optimisation. fid_func_call_num¶; int – Fidelity function call number of the pulse optimisation. grad_func_call_num¶; int – Gradient function call number of the pulse optimisation. fid_err¶; float – Fidelity error. grad_norm¶; float – fidelity gradient (wrt the control parameters) vector norm; that is the magnitude of the gradient. wall_time¶; float – Time spent computing the pulse optimisation so far; (in seconds of elapsed time). class TerminationConditions[source]¶; Base class for all termination conditions; Used to determine when to stop the optimisation algorithm; Note different subclasses should be used to match the type of; optimisation being used. fid_err_targ¶; float – Target fidelity error. fid_goal¶; float – goal fidelity, e.g. 1 - self.fid_err_targ; It its typical to set this for unitary systems. max_wall_time¶; float – # maximum time for optimisation (seconds). min_gradient_norm¶; float – Minimum normalised gradient after which optimisation will terminate. max_iterations¶; integer – Maximum iterations of the optimisation algorithm. max_fid_func_calls¶; integer – Maximum number of calls to the fidelity function during; the optimisation algorithm. accuracy_factor¶; fl",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:72803,Availability,error,error,72803,"written if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimIterSummary[source]¶; A summary of the most recent iteration of the pulse optimisation. iter_num¶; int – Iteration number of the pulse optimisation. fid_func_call_num¶; int – Fidelity function call number of the pulse optimisation. grad_func_call_num¶; int – Gradient function call number of the pulse optimisation. fid_err¶; float – Fidelity error. grad_norm¶; float – fidelity gradient (wrt the control parameters) vector norm; that is the magnitude of the gradient. wall_time¶; float – Time spent computing the pulse optimisation so far; (in seconds of elapsed time). class TerminationConditions[source]¶; Base class for all termination conditions; Used to determine when to stop the optimisation algorithm; Note different subclasses should be used to match the type of; optimisation being used. fid_err_targ¶; float – Target fidelity error. fid_goal¶; float – goal fidelity, e.g. 1 - self.fid_err_targ; It its typical to set this for unitary systems. max_wall_time¶; float – # maximum time for optimisation (seconds). min_gradient_norm¶; float – Minimum normalised gradient after which optimisation will terminate. max_iterations¶; integer – Maximum iterations of the optimisation algorithm. max_fid_func_calls¶; integer – Maximum number of calls to the fidelity function during; the optimisation algorithm. accuracy_factor¶; float – Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user. class OptimResult[source]¶; Attributes give the result of t",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:74008,Availability,error,error,74008,"float – Minimum normalised gradient after which optimisation will terminate. max_iterations¶; integer – Maximum iterations of the optimisation algorithm. max_fid_func_calls¶; integer – Maximum number of calls to the fidelity function during; the optimisation algorithm. accuracy_factor¶; float – Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user. class OptimResult[source]¶; Attributes give the result of the pulse optimisation attempt. termination_reason¶; string – Description of the reason for terminating the optimisation. fidelity¶; float – final (normalised) fidelity that was achieved. initial_fid_err¶; float – fidelity error before optimisation starting. fid_err¶; float – final fidelity error that was achieved. goal_achieved¶; boolean – True is the fidely error achieved was below the target. grad_norm_final¶; float – Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached¶; float – True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter¶; integer – Number of iterations of the optimisation algorithm completed. max_iter_exceeded¶; boolean – True if the iteration limit was reached. max_fid_func_exceeded¶; boolean – True if the fidelity function call limit was reached. wall_time¶; float – time elapsed during the optimisation. wall_time_limit_exceeded¶; boolean – True if the wall time limit was reached. time¶; array[num_tslots+1] of float – Time are the start of each timeslot; with the final value being the total evolution time. initial_amps¶; array[num_tslots, n_ctrls] – The amplitudes at the start of the opt",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:74077,Availability,error,error,74077," terminate. max_iterations¶; integer – Maximum iterations of the optimisation algorithm. max_fid_func_calls¶; integer – Maximum number of calls to the fidelity function during; the optimisation algorithm. accuracy_factor¶; float – Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user. class OptimResult[source]¶; Attributes give the result of the pulse optimisation attempt. termination_reason¶; string – Description of the reason for terminating the optimisation. fidelity¶; float – final (normalised) fidelity that was achieved. initial_fid_err¶; float – fidelity error before optimisation starting. fid_err¶; float – final fidelity error that was achieved. goal_achieved¶; boolean – True is the fidely error achieved was below the target. grad_norm_final¶; float – Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached¶; float – True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter¶; integer – Number of iterations of the optimisation algorithm completed. max_iter_exceeded¶; boolean – True if the iteration limit was reached. max_fid_func_exceeded¶; boolean – True if the fidelity function call limit was reached. wall_time¶; float – time elapsed during the optimisation. wall_time_limit_exceeded¶; boolean – True if the wall time limit was reached. time¶; array[num_tslots+1] of float – Time are the start of each timeslot; with the final value being the total evolution time. initial_amps¶; array[num_tslots, n_ctrls] – The amplitudes at the start of the optimisation. final_amps¶; array[num_tslots, n_ctrls] – The amplitu",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:74147,Availability,error,error,74147,"isation algorithm. max_fid_func_calls¶; integer – Maximum number of calls to the fidelity function during; the optimisation algorithm. accuracy_factor¶; float – Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user. class OptimResult[source]¶; Attributes give the result of the pulse optimisation attempt. termination_reason¶; string – Description of the reason for terminating the optimisation. fidelity¶; float – final (normalised) fidelity that was achieved. initial_fid_err¶; float – fidelity error before optimisation starting. fid_err¶; float – final fidelity error that was achieved. goal_achieved¶; boolean – True is the fidely error achieved was below the target. grad_norm_final¶; float – Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached¶; float – True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter¶; integer – Number of iterations of the optimisation algorithm completed. max_iter_exceeded¶; boolean – True if the iteration limit was reached. max_fid_func_exceeded¶; boolean – True if the fidelity function call limit was reached. wall_time¶; float – time elapsed during the optimisation. wall_time_limit_exceeded¶; boolean – True if the wall time limit was reached. time¶; array[num_tslots+1] of float – Time are the start of each timeslot; with the final value being the total evolution time. initial_amps¶; array[num_tslots, n_ctrls] – The amplitudes at the start of the optimisation. final_amps¶; array[num_tslots, n_ctrls] – The amplitudes at the end of the optimisation. evo_full_final¶; Qobj – The evolut",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:74278,Availability,error,error,74278,"on during; the optimisation algorithm. accuracy_factor¶; float – Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user. class OptimResult[source]¶; Attributes give the result of the pulse optimisation attempt. termination_reason¶; string – Description of the reason for terminating the optimisation. fidelity¶; float – final (normalised) fidelity that was achieved. initial_fid_err¶; float – fidelity error before optimisation starting. fid_err¶; float – final fidelity error that was achieved. goal_achieved¶; boolean – True is the fidely error achieved was below the target. grad_norm_final¶; float – Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached¶; float – True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter¶; integer – Number of iterations of the optimisation algorithm completed. max_iter_exceeded¶; boolean – True if the iteration limit was reached. max_fid_func_exceeded¶; boolean – True if the fidelity function call limit was reached. wall_time¶; float – time elapsed during the optimisation. wall_time_limit_exceeded¶; boolean – True if the wall time limit was reached. time¶; array[num_tslots+1] of float – Time are the start of each timeslot; with the final value being the total evolution time. initial_amps¶; array[num_tslots, n_ctrls] – The amplitudes at the start of the optimisation. final_amps¶; array[num_tslots, n_ctrls] – The amplitudes at the end of the optimisation. evo_full_final¶; Qobj – The evolution operator from t=0 to t=T based on the final amps. stats¶; Stats – Object contaning the stats ",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:77274,Availability,error,error,77274,",; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params¶; Dictionary – The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats¶; Stats – Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer¶; TimeslotComputer (subclass instance) – Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer¶; PropagatorComputer (subclass instance) – Used to compute the propagators and their gradients. fid_computer¶; FidelityComputer (subclass instance) – Used to computer the fidelity error and the fidelity error; gradient. memory_optimization¶; int – Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype¶; type – Data type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform bette",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:77297,Availability,error,error,77297,",; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params¶; Dictionary – The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats¶; Stats – Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer¶; TimeslotComputer (subclass instance) – Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer¶; PropagatorComputer (subclass instance) – Used to compute the propagators and their gradients. fid_computer¶; FidelityComputer (subclass instance) – Used to computer the fidelity error and the fidelity error; gradient. memory_optimization¶; int – Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype¶; type – Data type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform bette",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:93070,Availability,error,error,93070,"log_level¶; integer – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_norm¶; float – Normalisation constant. fid_norm_func¶; function – Used to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_func¶; function – Used to normalise the fidelity gradient; See SU and PSU options for the unitary dynamics. uses_onwd_evo¶; boolean – flag to specify whether the onwd_evo evolution operator; (see Dynamics) is used by the FidelityComputer. uses_onto_evo¶; boolean –. flag to specify whether the onto_evo evolution operator; (see Dynamics) is used by the FidelityComputer. fid_err¶; float – Last computed value of the fidelity error. fidelity¶; float – Last computed value of the normalised fidelity. fidelity_current¶; boolean – flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad¶; array[num_tslot, num_ctrls] of float – Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm¶; float – Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current¶; boolean – flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are ove",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:93390,Availability,error,error,93390,"efault NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_norm¶; float – Normalisation constant. fid_norm_func¶; function – Used to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_func¶; function – Used to normalise the fidelity gradient; See SU and PSU options for the unitary dynamics. uses_onwd_evo¶; boolean – flag to specify whether the onwd_evo evolution operator; (see Dynamics) is used by the FidelityComputer. uses_onto_evo¶; boolean –. flag to specify whether the onto_evo evolution operator; (see Dynamics) is used by the FidelityComputer. fid_err¶; float – Last computed value of the fidelity error. fidelity¶; float – Last computed value of the normalised fidelity. fidelity_current¶; boolean – flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad¶; array[num_tslot, num_ctrls] of float – Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm¶; float – Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current¶; boolean – flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient ",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:93509,Availability,error,error,93509,"t – Normalisation constant. fid_norm_func¶; function – Used to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_func¶; function – Used to normalise the fidelity gradient; See SU and PSU options for the unitary dynamics. uses_onwd_evo¶; boolean – flag to specify whether the onwd_evo evolution operator; (see Dynamics) is used by the FidelityComputer. uses_onto_evo¶; boolean –. flag to specify whether the onto_evo evolution operator; (see Dynamics) is used by the FidelityComputer. fid_err¶; float – Last computed value of the fidelity error. fidelity¶; float – Last computed value of the normalised fidelity. fidelity_current¶; boolean – flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad¶; array[num_tslot, num_ctrls] of float – Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm¶; float – Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current¶; boolean – flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the ",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:94384,Availability,error,error,94384,"fidelity error gradients wrt the; control in the timeslot. grad_norm¶; float – Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current¶; boolean – flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). phase_option¶; string –. determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm¶; complex – Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current¶; boolean – flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. compute_fid_grad()[source]¶; Calculates exact gradie",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:94716,Availability,error,error,94716,"itudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). phase_option¶; string –. determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm¶; complex – Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current¶; boolean – flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:95661,Availability,error,error,95661,"FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). phase_option¶; string –. determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm¶; complex – Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current¶; boolean – flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the ",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:95765,Availability,error,error,95765," calculations were taken from DYNAMO; (see file header). phase_option¶; string –. determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm¶; complex – Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current¶; boolean – flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either ",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:97424,Availability,error,error,97424,"idering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(A)[source]¶. normalize_SU(A)[source]¶. normalize_gradient_PSU(grad)[source]¶; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(grad)[source]¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. set_phase_option(phase_option=None)[source]¶; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. scale_factor¶; float – The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Ge",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:97504,Availability,error,error,97504,"idering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(A)[source]¶. normalize_SU(A)[source]¶. normalize_gradient_PSU(grad)[source]¶; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(grad)[source]¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. set_phase_option(phase_option=None)[source]¶; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. scale_factor¶; float – The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Ge",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:97976,Availability,error,error,97976," the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(grad)[source]¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. set_phase_option(phase_option=None)[source]¶; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. scale_factor¶; float – The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. class FidCompTraceDiffApprox(dynamic",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:98067,Availability,error,error,98067," passed as grad; This SU version respects global phase. set_phase_option(phase_option=None)[source]¶; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. scale_factor¶; float – The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. epsilon¶; float – control ampl",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:98320,Availability,error,error,98320,"t; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. scale_factor¶; float – The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. epsilon¶; float – control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; contr",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:98515,Availability,error,error,98515,"error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. scale_factor¶; float – The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. epsilon¶; float – control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. class TimeslotComputer(dynamics, params=None)[source]¶; Base cla",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:98619,Availability,error,error,98619,"a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. scale_factor¶; float – The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. epsilon¶; float – control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. class TimeslotComputer(dynamics, params=None)[source]¶; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. log_level¶; i",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:112981,Availability,error,error,112981,"the optimisation. wall_time_optim_end¶; float – End time for the optimisation. wall_time_optim¶; float – Time elasped during the optimisation. wall_time_dyn_gen_compute¶; float – Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute¶; float – Total wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_time_fwd_prop_compute¶; float – Total wall (elasped) time computing combined forward propagation,; that is the time evolution from the start to a specific timeslot.; Excludes calculating the propagators themselves. wall_time_onwd_prop_compute¶; float – Total wall (elasped) time computing combined onward propagation,; that is the time evolution from a specific timeslot to the end time.; Excludes calculating the propagators themselves. wall_time_gradient_compute¶; float – Total wall (elasped) time computing the fidelity error gradient.; Excludes calculating the propagator gradients (in exact gradient; methods). num_fidelity_func_calls¶; integer – Number of calls to fidelity function by the optimisation algorithm. num_grad_func_calls¶; integer – Number of calls to gradient function by the optimisation algorithm. num_tslot_recompute¶; integer – Number of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computes¶; integer – Number of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computes¶; integer – Number of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates¶; integer – Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter¶; float – Mean number of control amplitude updates per iteration. num_timeslot_changes¶; integer – Number of ",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:116796,Availability,error,error,116796," for the summary file.; default is a space. data_sep¶; str – delimiter for the data files (arrays saved to file).; default is a space. summary_file¶; str – File path for summary file.; Automatically generated. Can be set specifically. create_dump_dir()[source]¶; Checks dump directory exists, creates it if not. level¶. The level of data dumping that will occur. SUMMARY : A summary will be recorded; FULL : All possible dumping; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specifically is dumped. class OptimDump(optim, level='SUMMARY')[source]¶; A container for dumps of optimisation data generated during the pulse; optimisation. dump_summary¶; bool – When True summary items are appended to the iter_summary. iter_summary¶; list of optimizer.OptimIterSummary – Summary at each iteration. dump_fid_err¶; bool – When True values are appended to the fid_err_log. fid_err_log¶; list of float – Fidelity error at each call of the fid_err_func. dump_grad_norm¶; bool – When True values are appended to the fid_err_log. grad_norm_log¶; list of float – Gradient norm at each call of the grad_norm_log. dump_grad¶; bool – When True values are appended to the grad_log. grad_log¶; list of ndarray – Gradients at each call of the fid_grad_func. add_iter_summary()[source]¶; add copy of current optimizer iteration summary. dump_all¶; True if everything (ignoring the summary) is to be dumped. dump_any¶; True if anything other than the summary is to be dumped. update_fid_err_log(fid_err)[source]¶; add an entry to the fid_err log. update_grad_log(grad)[source]¶; add an entry to the grad log. update_grad_norm_log(grad_norm)[source]¶; add an entry to the grad_norm log. writeout(f=None)[source]¶; write all the logs and the summary out to file(s). Parameters:f (filename or filehandle) – If specified then all summary and object data will go in one file.; If None is specified then type specific files will be",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:28878,Deployability,integrat,integrate,28878," boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters:; options (qutip.solver.Options) – Generic solver options.; If set to None the default options will be used; progress_bar (BaseProgressBar) – Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar; stats (qutip.solver.Stats) – Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). cut_freq¶; float – Bath spectral density cutoff frequency. renorm¶; bool – Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx¶; bool – Use boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, pl",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:30528,Deployability,integrat,integrator,30528,"h spectral density cutoff frequency. renorm¶; bool – Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx¶; bool – Use boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters:; rho0 (Qobj) – Initial state (density matrix) of the system.; tlist (list) – Time over which system evolves. Returns:results – Object storing all results from the simulation. Return type:qutip.solver.Result. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. H_S¶; qutip.Qobj – System Hamiltonian (can also be a Liouvillian). L1¶; qutip.Qobj / list of qutip.Qobj – System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2¶; qutip.Qobj / list of qutip.Qobj – System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix¶; array – S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov¶; qutip.Qobj / list of qutip.Qobj – Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator¶; str {‘propagator’, ‘mesolve’} – Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:31455,Deployability,integrat,integrator,31455," L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. H_S¶; qutip.Qobj – System Hamiltonian (can also be a Liouvillian). L1¶; qutip.Qobj / list of qutip.Qobj – System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2¶; qutip.Qobj / list of qutip.Qobj – System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix¶; array – S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov¶; qutip.Qobj / list of qutip.Qobj – Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator¶; str {‘propagator’, ‘mesolve’} – Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallel¶; bool – Run integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. options¶; qutip.solver.Options – Generic solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters:; rho0 (qutip.Qobj) – initial density matrix or state vector (ket).; blist (array_like) – List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger; tlist (array_like) – list of corresponding times t1,..,tn at which to evaluate the field; operators; tau (float) – time-delay; c1 (qutip.Qobj) – system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has mor",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:31643,Deployability,integrat,integrator,31643,"uantum systems; with time-delayed coherent feedback. H_S¶; qutip.Qobj – System Hamiltonian (can also be a Liouvillian). L1¶; qutip.Qobj / list of qutip.Qobj – System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2¶; qutip.Qobj / list of qutip.Qobj – System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix¶; array – S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov¶; qutip.Qobj / list of qutip.Qobj – Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator¶; str {‘propagator’, ‘mesolve’} – Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallel¶; bool – Run integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. options¶; qutip.solver.Options – Generic solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters:; rho0 (qutip.Qobj) – initial density matrix or state vector (ket).; blist (array_like) – List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger; tlist (array_like) – list of corresponding times t1,..,tn at which to evaluate the field; operators; tau (float) – time-delay; c1 (qutip.Qobj) – system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element); c2 (qutip.Qobj) – system collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has mor",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:31717,Deployability,integrat,integrator,31717,"; qutip.Qobj – System Hamiltonian (can also be a Liouvillian). L1¶; qutip.Qobj / list of qutip.Qobj – System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2¶; qutip.Qobj / list of qutip.Qobj – System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix¶; array – S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov¶; qutip.Qobj / list of qutip.Qobj – Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator¶; str {‘propagator’, ‘mesolve’} – Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallel¶; bool – Run integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. options¶; qutip.solver.Options – Generic solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters:; rho0 (qutip.Qobj) – initial density matrix or state vector (ket).; blist (array_like) – List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger; tlist (array_like) – list of corresponding times t1,..,tn at which to evaluate the field; operators; tau (float) – time-delay; c1 (qutip.Qobj) – system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element); c2 (qutip.Qobj) – system collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). Returns:expectation value of field c",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:36325,Deployability,integrat,integrator,36325,"old. options¶; qutip.solver.Options – Generic solver options. Solver Options and Results¶. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False, store_final_state=False, store_states=False, seeds=None, steady_state_average=False, normalize_output=True)[source]¶; Class of options for evolution solvers such as qutip.mesolve and; qutip.mcsolve. Options can be specified either as arguments to the; constructor:; opts = Options(order=10, ...). or by changing the class attributes after creation:; opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. atol¶; float {1e-8} – Absolute tolerance. rtol¶; float {1e-6} – Relative tolerance. method¶; str {‘adams’,’bdf’} – Integration method. order¶; int {12} – Order of integrator (<=12 ‘adams’, <=5 ‘bdf’). nsteps¶; int {2500} – Max. number of internal steps/call. first_step¶; float {0} – Size of initial step (0 = automatic). min_step¶; float {0} – Minimum step size (0 = automatic). max_step¶; float {0} – Maximum step size (0 = automatic). tidy¶; bool {True,False} – Tidyup Hamiltonian and initial state by removing small terms. num_cpus¶; int – Number of cpus used by mcsolver (default = # of cpus). norm_tol¶; float – Tolerance used when finding wavefunction norm in mcsolve. norm_steps¶; int – Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve. average_states¶; bool {False} – Average states values over trajectories in stochastic solvers. average_expect¶; bool {True} – Average expectation values over trajectories for stochastic solvers. mc_corr_eps¶; float {1e-10} – Arbitrarily small value for eliminating any divide-by-zero errors in; correlation calculations when using mcsolve. ntraj¶; int {500} – Number of trajectories in st",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:50954,Deployability,update,update,50954,"sionality of the underlaying distribution.; Parameters:. fig; : matplotlib Figure instanceIf given, use this figure instance for the visualization,; ax; : matplotlib Axes instanceIf given, render the visualization using this axis instance.; figsize; : tupleSize of the new Figure instance, if one needs to be created.; colorbar: Bool; Whether or not the colorbar (in 2D visualization) should be used.; cmap: matplotlib colormap instance; If given, use this colormap for 2D visualizations.; style; : stringType of visualization: ‘colormap’ (default) or ‘surface’. Returns:fig, ax – A tuple of matplotlib figure and axes instances. Return type:tuple. class WignerDistribution(rho=None, extent=[[-5, 5], [-5, 5]], steps=250)[source]¶. class QDistribution(rho=None, extent=[[-5, 5], [-5, 5]], steps=250)[source]¶. class TwoModeQuadratureCorrelation(state=None, theta1=0.0, theta2=0.0, extent=[[-5, 5], [-5, 5]], steps=250)[source]¶. update(state)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction or density matrix. update_psi(psi)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction. update_rho(rho)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode density matrix. class HarmonicOscillatorWaveFunction(psi=None, omega=1.0, extent=[-5, 5], steps=250)[source]¶. update(psi)[source]¶; Calculate the wavefunction for the given state of an harmonic; oscillator. class HarmonicOscillatorProbabilityFunction(rho=None, omega=1.0, extent=[-5, 5], steps=250)[source]¶. update(rho)[source]¶; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix). Quantum information processing¶. class Gate(name, targets=None, controls=None, arg_value=None, arg_label=None)[source]¶; Representation of a quantum gate, with its required parametrs, and target; and control qubits. class QubitCircuit(N, reverse_st",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:51454,Deployability,update,update,51454,"ualizations.; style; : stringType of visualization: ‘colormap’ (default) or ‘surface’. Returns:fig, ax – A tuple of matplotlib figure and axes instances. Return type:tuple. class WignerDistribution(rho=None, extent=[[-5, 5], [-5, 5]], steps=250)[source]¶. class QDistribution(rho=None, extent=[[-5, 5], [-5, 5]], steps=250)[source]¶. class TwoModeQuadratureCorrelation(state=None, theta1=0.0, theta2=0.0, extent=[[-5, 5], [-5, 5]], steps=250)[source]¶. update(state)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction or density matrix. update_psi(psi)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction. update_rho(rho)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode density matrix. class HarmonicOscillatorWaveFunction(psi=None, omega=1.0, extent=[-5, 5], steps=250)[source]¶. update(psi)[source]¶; Calculate the wavefunction for the given state of an harmonic; oscillator. class HarmonicOscillatorProbabilityFunction(rho=None, omega=1.0, extent=[-5, 5], steps=250)[source]¶. update(rho)[source]¶; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix). Quantum information processing¶. class Gate(name, targets=None, controls=None, arg_value=None, arg_label=None)[source]¶; Representation of a quantum gate, with its required parametrs, and target; and control qubits. class QubitCircuit(N, reverse_states=True)[source]¶; Representation of a quantum program/algorithm, maintaining a sequence; of gates. add_1q_gate(name, start=0, end=None, qubits=None, arg_value=None, arg_label=None)[source]¶; Adds a single qubit gate with specified parameters on a variable; number of qubits in the circuit. By default, it applies the given gate; to all the qubits in the register. Parameters:; name (String) – Gate name.; start (Integer) – Starting location of qubits.; end (Integer) – Last",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:51653,Deployability,update,update,51653,"t=[[-5, 5], [-5, 5]], steps=250)[source]¶. class QDistribution(rho=None, extent=[[-5, 5], [-5, 5]], steps=250)[source]¶. class TwoModeQuadratureCorrelation(state=None, theta1=0.0, theta2=0.0, extent=[[-5, 5], [-5, 5]], steps=250)[source]¶. update(state)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction or density matrix. update_psi(psi)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction. update_rho(rho)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode density matrix. class HarmonicOscillatorWaveFunction(psi=None, omega=1.0, extent=[-5, 5], steps=250)[source]¶. update(psi)[source]¶; Calculate the wavefunction for the given state of an harmonic; oscillator. class HarmonicOscillatorProbabilityFunction(rho=None, omega=1.0, extent=[-5, 5], steps=250)[source]¶. update(rho)[source]¶; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix). Quantum information processing¶. class Gate(name, targets=None, controls=None, arg_value=None, arg_label=None)[source]¶; Representation of a quantum gate, with its required parametrs, and target; and control qubits. class QubitCircuit(N, reverse_states=True)[source]¶; Representation of a quantum program/algorithm, maintaining a sequence; of gates. add_1q_gate(name, start=0, end=None, qubits=None, arg_value=None, arg_label=None)[source]¶; Adds a single qubit gate with specified parameters on a variable; number of qubits in the circuit. By default, it applies the given gate; to all the qubits in the register. Parameters:; name (String) – Gate name.; start (Integer) – Starting location of qubits.; end (Integer) – Last qubit for the gate.; qubits (List) – Specific qubits for applying gates.; arg_value (Float) – Argument value(phi).; arg_label (String) – Label for gate representation. add_circuit(qc, start=0)[source]¶; Adds a bl",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:59491,Deployability,configurat,configuration,59491,"ue, Nres=None, deltamax=None, epsmax=None, w0=None, wq=None, eps=None, delta=None, g=None)[source]¶; Representation of the physical implementation of a quantum; program/algorithm on a dispersive cavity-QED system. dispersive_gate_correction(qc1, rwa=True)[source]¶; Method to resolve ISWAP and SQRTISWAP gates in a cQED system by adding; single qubit gates to get the correct output matrix. Parameters:; qc (Qobj) – The circular spin chain circuit to be resolved; rwa (Boolean) – Specify if RWA is used or not. Returns:qc – Returns QubitCircuit of resolved gates for the qubit circuit in the; desired basis. Return type:QubitCircuit. Optimal control¶. class Optimizer(config, dyn, params=None)[source]¶; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a. OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system. to be control optimised. log_level¶; integer – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params¶; Dictionary – The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg¶; string – Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params¶; Dictionary – options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg¶; bool – Set true to display a converge",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:62122,Deployability,configurat,configuration,62122," Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound¶; float or list of floats – lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound¶; float or list of floats – upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds¶; List of floats – Bounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamics¶; Dynamics (subclass instance) – describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). config¶; OptimConfig instance – various configuration options; (see OptimConfig for details). termination_conditions¶; TerminationCondition instance – attributes determine when the optimisation will end. pulse_generator¶; PulseGen (subclass instance) – (can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. stats¶; Stats – attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dump¶; dump.OptimDump – Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping¶; string – level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file¶; bool – If set True then data will be dumped to file during the optimisation; dumping will be set",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:64991,Deployability,update,update,64991," called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. dumping¶. The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; Thi",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:65589,Deployability,update,update,65589,"c_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(term_conds=None)[source]¶; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination ",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:66116,Deployability,configurat,configuration,66116,"get, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(term_conds=None)[source]¶; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:68884,Deployability,configurat,configuration,68884," (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. max_metric_corr¶; integer – The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which inclu",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:70504,Deployability,configurat,configuration,70504,"ablished implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, o",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:77071,Deployability,update,updated,77071,"cations, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. log_level¶; integer – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params¶; Dictionary – The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats¶; Stats – Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer¶; TimeslotComputer (subclass instance) – Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer¶; PropagatorComputer (subclass instance) – Used to compute the propagators and their gradients. fid_computer¶; FidelityComputer (subclass instance) – Used to computer the fidelity error and the fidelity error; gradient. memory_optimization¶; int – Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype¶; type – Data type for internal dynamics generators, propagators and time; evolution operat",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:86141,Deployability,configurat,configuration,86141,"ion operators (Qobj) from the initial to the given; timeslot. get_ctrl_dyn_gen(j)[source]¶; Get the dynamics generator for the control; Not implemented in the base class. Choose a subclass. get_drift_dim()[source]¶; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N. get_dyn_gen(k)[source]¶; Get the combined dynamics generator for the timeslot; Not implemented in the base class. Choose a subclass. get_num_ctrls()[source]¶; calculate the of controls from the length of the control list; sets the num_ctrls property, which can be used alternatively; subsequently. init_timeslots()[source]¶; Generate the timeslot duration array ‘tau’ based on the evo_time; and num_tslots attributes, unless the tau attribute is already set; in which case this step in ignored; Generate the cumulative time array ‘time’ based on the tau values. initialize_controls(amps, init_tslots=True)[source]¶; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated. num_ctrls¶; calculate the of controls from the length of the control list; sets the num_ctrls property, which can be used alternatively; subsequently. onto_evo¶; List of evolution operators (Qobj) from the initial to the given; timeslot. onwd_evo¶; List of evolution operators (Qobj) from the initial to the given; timeslot. prop¶; List of propagators (Qobj) for each timeslot. prop_grad¶; Array of propagator gradients (Qobj) for each timeslot, control. refresh_drift_attribs()[source]¶; Reset the dyn_shape, dyn_dims and time_depend_drift attribs. save_amps(file_name=None, times=None, amps=None, verbose=False)[source]¶; Save a file with the current control amplitudes in each timeslot; The first column in the file will be the start time of the slot. Parameters:; file_name (string) – Name of the file; If None given the def_amps_fname attribuite will be used; times (List type (or string)) –",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:90916,Deployability,configurat,configuration,90916,"cation. log_level¶; integer – level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exact¶; boolean – indicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]¶. Frechet method for calculating the propagator:; exponentiating the combined dynamics generator. and the propagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient. class FidelityComputer(dynamics, params=None)[source]¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the ",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:91192,Deployability,configurat,configuration,91192,"xecution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exact¶; boolean – indicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]¶. Frechet method for calculating the propagator:; exponentiating the combined dynamics generator. and the propagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient. class FidelityComputer(dynamics, params=None)[source]¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. log_level¶; integer – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of mess",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:91385,Deployability,configurat,configuration,91385,"es whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]¶. Frechet method for calculating the propagator:; exponentiating the combined dynamics generator. and the propagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient. class FidelityComputer(dynamics, params=None)[source]¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. log_level¶; integer – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSE",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:94521,Deployability,configurat,configuration,94521,"ity error gradients; (sqrt of the sum of the squares). fid_err_grad_current¶; boolean – flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). phase_option¶; string –. determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm¶; complex – Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current¶; boolean – flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nT",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:94580,Deployability,configurat,configuration,94580," to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). phase_option¶; string –. determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm¶; complex – Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current¶; boolean – flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as n",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:95891,Deployability,update,updates,95891," calculations were taken from DYNAMO; (see file header). phase_option¶; string –. determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm¶; complex – Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current¶; boolean – flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either ",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:96352,Deployability,configurat,configuration,96352,"culates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(A)[source]¶. normalize_SU(A)[source]¶. normalize_gradient_PSU(grad)[source]¶; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(grad)[source]¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. set_phase_option(phase_option=None)[source]¶; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCo",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:98745,Deployability,update,updates,98745,"a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. scale_factor¶; float – The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. epsilon¶; float – control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. class TimeslotComputer(dynamics, params=None)[source]¶; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. log_level¶; i",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:98864,Deployability,configurat,configuration,98864,"; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. scale_factor¶; float – The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. epsilon¶; float – control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. class TimeslotComputer(dynamics, params=None)[source]¶; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. log_level¶; integer – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITI",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:100852,Deployability,update,updated,100852,"s,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. evo_comp_summary¶; EvoCompSummary – A summary of the most recent evolution computation; Used in the stats and dump; Will be set to None if neither stats or dump are set. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. dump_current()[source]¶; Store a copy of the current time evolution. class TSlotCompUpdateAll(dynamics, params=None)[source]¶; Timeslot Computer - Update All; Updates all dynamics generators, propagators and evolutions when; ctrl amplitudes are updated. compare_amps(new_amps)[source]¶; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; Returns: True if amplitudes are the same, False if they have changed. get_timeslot_for_fidelity_calc()[source]¶; Returns the timeslot index that will be used calculate current fidelity; value.; This (default) method simply returns the last timeslot. recompute_evolution()[source]¶; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary. class PulseGen(dyn=None, params=None)[source]¶; Pulse generator; Base class for all Pulse generators; The object can optionally be instantiated with a Dynamics object,; in which case the timeslots and amplitude scaling and offset; are copied from that.; Otherwise the class can be used independently by setting:; tau (array of timeslot durations); or; num_tslot",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:111487,Deployability,configurat,configurations,111487,"e optimisation method; Typically this will be the basis coefficients. class PulseGenCrabFourier(dyn=None, num_coeffs=None, params=None)[source]¶; Generates a pulse using the Fourier basis functions, i.e. sin and cos. freqs¶; float array[num_coeffs] – Frequencies for the basis functions. randomize_freqs¶; bool – If True (default) the some random offset is applied to the frequencies. gen_pulse(coeffs=None)[source]¶; Generate a pulse using the Fourier basis with the freqs and; coeffs attributes. Parameters:coeffs (float array[num_coeffs, num_basis_funcs]) – The basis coefficient values; If given this overides the default and sets the attribute; of the same name. init_freqs()[source]¶; Generate the frequencies; These are the Fourier harmonics with a uniformly distributed; random offset. init_pulse(num_coeffs=None)[source]¶; Set the initial freq and coefficient values. reset()[source]¶; reset attributes to default values. class Stats[source]¶; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. dyn_gen_name¶; string – Text used in some report functions.; Makes sense to set it to ‘Hamiltonian’ when using unitary dynamics; Default is simply ‘dynamics generator’. num_iter¶; integer – Number of iterations of the optimisation algorithm. wall_time_optim_start¶; float – Start time for the optimisation. wall_time_optim_end¶; float – End time for the optimisation. wall_time_optim¶; float – Time elasped during the optimisation. wall_time_dyn_gen_compute¶; float – Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute¶; float – Total wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_time_fwd_prop_compute¶; f",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:111526,Deployability,update,updated,111526,"e optimisation method; Typically this will be the basis coefficients. class PulseGenCrabFourier(dyn=None, num_coeffs=None, params=None)[source]¶; Generates a pulse using the Fourier basis functions, i.e. sin and cos. freqs¶; float array[num_coeffs] – Frequencies for the basis functions. randomize_freqs¶; bool – If True (default) the some random offset is applied to the frequencies. gen_pulse(coeffs=None)[source]¶; Generate a pulse using the Fourier basis with the freqs and; coeffs attributes. Parameters:coeffs (float array[num_coeffs, num_basis_funcs]) – The basis coefficient values; If given this overides the default and sets the attribute; of the same name. init_freqs()[source]¶; Generate the frequencies; These are the Fourier harmonics with a uniformly distributed; random offset. init_pulse(num_coeffs=None)[source]¶; Set the initial freq and coefficient values. reset()[source]¶; reset attributes to default values. class Stats[source]¶; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. dyn_gen_name¶; string – Text used in some report functions.; Makes sense to set it to ‘Hamiltonian’ when using unitary dynamics; Default is simply ‘dynamics generator’. num_iter¶; integer – Number of iterations of the optimisation algorithm. wall_time_optim_start¶; float – Start time for the optimisation. wall_time_optim_end¶; float – End time for the optimisation. wall_time_optim¶; float – Time elasped during the optimisation. wall_time_dyn_gen_compute¶; float – Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute¶; float – Total wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_time_fwd_prop_compute¶; f",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:113792,Deployability,update,updated,113792,"ward propagation,; that is the time evolution from a specific timeslot to the end time.; Excludes calculating the propagators themselves. wall_time_gradient_compute¶; float – Total wall (elasped) time computing the fidelity error gradient.; Excludes calculating the propagator gradients (in exact gradient; methods). num_fidelity_func_calls¶; integer – Number of calls to fidelity function by the optimisation algorithm. num_grad_func_calls¶; integer – Number of calls to gradient function by the optimisation algorithm. num_tslot_recompute¶; integer – Number of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computes¶; integer – Number of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computes¶; integer – Number of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates¶; integer – Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter¶; float – Mean number of control amplitude updates per iteration. num_timeslot_changes¶; integer – Number of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_update¶; float – Mean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changes¶; integer – Number of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_update¶; float – Mean average number of control amplitudes that are changed per update. calculate()[source]¶; Perform the calculations (e.g. averages) that are required on the stats; Should be called before calling report. report()[source]¶; Print a report of the stats to the console. class Dump[source]¶; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. parent¶; some control object (Dynamics or Optimizer) – aka the host. Object that generates the data",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:113879,Deployability,update,updates,113879,udes calculating the propagators themselves. wall_time_gradient_compute¶; float – Total wall (elasped) time computing the fidelity error gradient.; Excludes calculating the propagator gradients (in exact gradient; methods). num_fidelity_func_calls¶; integer – Number of calls to fidelity function by the optimisation algorithm. num_grad_func_calls¶; integer – Number of calls to gradient function by the optimisation algorithm. num_tslot_recompute¶; integer – Number of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computes¶; integer – Number of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computes¶; integer – Number of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates¶; integer – Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter¶; float – Mean number of control amplitude updates per iteration. num_timeslot_changes¶; integer – Number of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_update¶; float – Mean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changes¶; integer – Number of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_update¶; float – Mean average number of control amplitudes that are changed per update. calculate()[source]¶; Perform the calculations (e.g. averages) that are required on the stats; Should be called before calling report. report()[source]¶; Print a report of the stats to the console. class Dump[source]¶; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. parent¶; some control object (Dynamics or Optimizer) – aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dir¶; str – directory where files (if ,MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:114117,Deployability,update,update,114117,methods). num_fidelity_func_calls¶; integer – Number of calls to fidelity function by the optimisation algorithm. num_grad_func_calls¶; integer – Number of calls to gradient function by the optimisation algorithm. num_tslot_recompute¶; integer – Number of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computes¶; integer – Number of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computes¶; integer – Number of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates¶; integer – Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter¶; float – Mean number of control amplitude updates per iteration. num_timeslot_changes¶; integer – Number of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_update¶; float – Mean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changes¶; integer – Number of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_update¶; float – Mean average number of control amplitudes that are changed per update. calculate()[source]¶; Perform the calculations (e.g. averages) that are required on the stats; Should be called before calling report. report()[source]¶; Print a report of the stats to the console. class Dump[source]¶; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. parent¶; some control object (Dynamics or Optimizer) – aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dir¶; str – directory where files (if any) will be written out; the path and be relative or absolute; use ~/ to specify user home directory; Note: files are only written when write_to_file is True; of writeout is called explicitly; Defaults to ~/.qtrl_,MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:114332,Deployability,update,update,114332,"m_tslot_recompute¶; integer – Number of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computes¶; integer – Number of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computes¶; integer – Number of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates¶; integer – Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter¶; float – Mean number of control amplitude updates per iteration. num_timeslot_changes¶; integer – Number of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_update¶; float – Mean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changes¶; integer – Number of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_update¶; float – Mean average number of control amplitudes that are changed per update. calculate()[source]¶; Perform the calculations (e.g. averages) that are required on the stats; Should be called before calling report. report()[source]¶; Print a report of the stats to the console. class Dump[source]¶; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. parent¶; some control object (Dynamics or Optimizer) – aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dir¶; str – directory where files (if any) will be written out; the path and be relative or absolute; use ~/ to specify user home directory; Note: files are only written when write_to_file is True; of writeout is called explicitly; Defaults to ~/.qtrl_dump. level¶; string – level of data dumping: SUMMARY, FULL or CUSTOM; See property docstring for details; Set automatically if dump is created by the setting host dumping attrib. write_to_file¶; bool – When set Tru",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:120458,Deployability,update,updated,120458,"If True forward evolution operators are dumped. dump_onwd_evo¶; bool – If True onward evolution operators are dumped. dump_onto_evo¶; bool – If True onto (or backward) evolution operators are dumped. evo_dumps¶; list of EvoCompDumpItem – A new dump item is appended at each recomputation of the evolution.; That is if any of the calculation objects are to be dumped. add_evo_comp_summary(dump_item_idx=None)[source]¶; add copy of current evo comp summary. add_evo_dump()[source]¶; Add dump of current time evolution generating objects. dump_all¶; True if all of the calculation objects are to be dumped. dump_any¶; True if any of the calculation objects are to be dumped. writeout(f=None)[source]¶; write all the dump items and the summary out to file(s); :param f: If specified then all summary and object data will go in one file. If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this. class DumpItem[source]¶; An item in a dump list. class EvoCompDumpItem(dump)[source]¶; A copy of all objects generated to calculate one time evolution; Note the attributes are only set if the corresponding; DynamicsDump dump_ attribute is set. writeout(f=None)[source]¶; write all the objects out to files. Parameters:f (filename or filehandle) – If specified then all object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this. class DumpSummaryItem[source]¶; A summary of the most recent iteration; Abstract class only; Attributes:; idx : int. Index in the summary list in which this is stored. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:27148,Energy Efficiency,reduce,reduced,27148," systems where the bath; correlations can be approximated to a sum of complex eponentials.; The method builds a matrix of linked differential equations, which are; then solved used the same ODE solvers as other qutip solvers (e.g. mesolve); This class should be treated as abstract. Currently the only subclass; implemented is that for the Drude-Lorentz spectral density. This covers; the majority of the work that has been done using this model, and there; are some performance advantages to assuming this model where it is; appropriate.; There are opportunities to develop a more general spectral density code. H_sys¶; Qobj – System Hamiltonian. coup_op¶; Qobj – Operator describing the coupling between system and bath. coup_strength¶; float – Coupling strength. temperature¶; float – Bath temperature, in units corresponding to planck. N_cut¶; int – Cutoff parameter for the bath. N_exp¶; int – Number of exponential terms used to approximate the bath correlation; functions. planck¶; float – reduced Planck constant. boltzmann¶; float – Boltzmann’s constant. options¶; qutip.solver.Options – Generic solver options.; If set to None the default options will be used. progress_bar¶; BaseProgressBar – Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. stats¶; qutip.solver.Stats – optional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coeff¶; list of complex – Coefficients for the exponential series terms. exp_freq¶; list of complex – Frequencies for the exponential series terms. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters:; options ",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:34404,Energy Efficiency,reduce,reduced,34404,"f self.L1 has more than one; element); c2 (qutip.Qobj) – system collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element); notrace (bool {False}) – If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns:time-propagator for computing field correlation function. Return type:qutip.Qobj. propagator(t, tau, notrace=False)[source]¶; Compute propagator for time t and time-delay tau. Parameters:; t (float) – current time; tau (float) – time-delay; notrace (bool {False}) – If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns:time-propagator for reduced system dynamics. Return type:qutip.Qobj. rhot(rho0, t, tau)[source]¶; Compute the reduced system density matrix \(\rho(t)\). Parameters:; rho0 (qutip.Qobj) – initial density matrix or state vector (ket); t (float) – current time; tau (float) – time-delay. Returns:density matrix at time \(t\). Return type:qutip.Qobj. class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]¶; Class of options for the Transfer Tensor Method solver. dynmaps¶; list of qutip.Qobj – List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. times¶; array_like – List of times \(t_n\) at which to calculate \(\rho(t_n)\). learningtimes¶; array_like – List of times \(t_k\) to use as learning times if argument; dynmaps is a callback function. thres¶; float – Threshold for halting. Halts if \(||T_{n}-T_{n-1}||\) is below; treshold. options¶; qutip.solver.Options – Generic solver options. Solver Opti",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:34494,Energy Efficiency,reduce,reduced,34494,"s to the output field in; question (only needs to be specified if self.L2 has more than one; element); notrace (bool {False}) – If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns:time-propagator for computing field correlation function. Return type:qutip.Qobj. propagator(t, tau, notrace=False)[source]¶; Compute propagator for time t and time-delay tau. Parameters:; t (float) – current time; tau (float) – time-delay; notrace (bool {False}) – If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns:time-propagator for reduced system dynamics. Return type:qutip.Qobj. rhot(rho0, t, tau)[source]¶; Compute the reduced system density matrix \(\rho(t)\). Parameters:; rho0 (qutip.Qobj) – initial density matrix or state vector (ket); t (float) – current time; tau (float) – time-delay. Returns:density matrix at time \(t\). Return type:qutip.Qobj. class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]¶; Class of options for the Transfer Tensor Method solver. dynmaps¶; list of qutip.Qobj – List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. times¶; array_like – List of times \(t_n\) at which to calculate \(\rho(t_n)\). learningtimes¶; array_like – List of times \(t_k\) to use as learning times if argument; dynmaps is a callback function. thres¶; float – Threshold for halting. Halts if \(||T_{n}-T_{n-1}||\) is below; treshold. options¶; qutip.solver.Options – Generic solver options. Solver Options and Results¶. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=100",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:49148,Energy Efficiency,reduce,reduced,49148,"ui.BaseProgressBar – Optional progress bar class instance. Distribution functions¶. class Distribution(data=None, xvecs=[], xlabels=[])[source]¶; A class for representation spatial distribution functions.; The Distribution class can be used to prepresent spatial distribution; functions of arbitray dimension (although only 1D and 2D distributions; are used so far).; It is indented as a base class for specific distribution function, and; provide implementation of basic functions that are shared among all; Distribution functions, such as visualization, calculating marginal; distributions, etc. Parameters:; data (array_like) – Data for the distribution. The dimensions must match the lengths of; the coordinate arrays in xvecs.; xvecs (list) – List of arrays that spans the space for each coordinate.; xlabels (list) – List of labels for each coordinate. marginal(dim=0)[source]¶; Calculate the marginal distribution function along the dimension; dim. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters:dim (int) – The dimension (coordinate index) along which to obtain the; marginal distribution. Returns:d – A new instances of Distribution that describes the marginal; distribution. Return type:Distributions. project(dim=0)[source]¶; Calculate the projection (max value) distribution function along the; dimension dim. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters:dim (int) – The dimension (coordinate index) along which to obtain the; projected distribution. Returns:d – A new instances of Distribution that describes the projection. Return type:Distributions. visualize(fig=None, ax=None, figsize=(8, 6), colorbar=True, cmap=None, style='colormap', show_xlabel=True, show_ylabel=True)[source]¶; Visualize the data of the distribution in 1D or 2D, depending; on the dimensionality of the underlaying distribution.; Parameters:. fig; : matplotlib Figure instanceIf given, use this figure ",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:49569,Energy Efficiency,reduce,reduced-dimensionality,49569,"ution function, and; provide implementation of basic functions that are shared among all; Distribution functions, such as visualization, calculating marginal; distributions, etc. Parameters:; data (array_like) – Data for the distribution. The dimensions must match the lengths of; the coordinate arrays in xvecs.; xvecs (list) – List of arrays that spans the space for each coordinate.; xlabels (list) – List of labels for each coordinate. marginal(dim=0)[source]¶; Calculate the marginal distribution function along the dimension; dim. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters:dim (int) – The dimension (coordinate index) along which to obtain the; marginal distribution. Returns:d – A new instances of Distribution that describes the marginal; distribution. Return type:Distributions. project(dim=0)[source]¶; Calculate the projection (max value) distribution function along the; dimension dim. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters:dim (int) – The dimension (coordinate index) along which to obtain the; projected distribution. Returns:d – A new instances of Distribution that describes the projection. Return type:Distributions. visualize(fig=None, ax=None, figsize=(8, 6), colorbar=True, cmap=None, style='colormap', show_xlabel=True, show_ylabel=True)[source]¶; Visualize the data of the distribution in 1D or 2D, depending; on the dimensionality of the underlaying distribution.; Parameters:. fig; : matplotlib Figure instanceIf given, use this figure instance for the visualization,; ax; : matplotlib Axes instanceIf given, render the visualization using this axis instance.; figsize; : tupleSize of the new Figure instance, if one needs to be created.; colorbar: Bool; Whether or not the colorbar (in 2D visualization) should be used.; cmap: matplotlib colormap instance; If given, use this colormap for 2D visualizations.; style; : stringType of visualization: ‘colorma",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:62540,Energy Efficiency,reduce,reduce,62540,"ntrol amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds¶; List of floats – Bounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamics¶; Dynamics (subclass instance) – describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). config¶; OptimConfig instance – various configuration options; (see OptimConfig for details). termination_conditions¶; TerminationCondition instance – attributes determine when the optimisation will end. pulse_generator¶; PulseGen (subclass instance) – (can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. stats¶; Stats – attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dump¶; dump.OptimDump – Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping¶; string – level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file¶; bool – If set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dir¶; string – Basically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summary¶; OptimIterSummary – Summary of the most recent iteration.; Note this is on",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:76835,Energy Efficiency,reduce,reduce,76835,"t is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. log_level¶; integer – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params¶; Dictionary – The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats¶; Stats – Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer¶; TimeslotComputer (subclass instance) – Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer¶; PropagatorComputer (subclass instance) – Used to compute the propagators and their gradients. fid_computer¶; FidelityComputer (subclass instance) – Used to computer the fidelity error and the fidelity error; gradient. memory_optimization¶; int – Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more infor",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:91712,Energy Efficiency,efficient,efficient,91712,"s a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]¶. Frechet method for calculating the propagator:; exponentiating the combined dynamics generator. and the propagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient. class FidelityComputer(dynamics, params=None)[source]¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. log_level¶; integer – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_norm¶; float – Normalisation constant. fid_norm_func¶; function – Used to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_func¶; function – Used to n",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:8063,Integrability,depend,dependent,8063,"operator.; eigvecs (array) – Array of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eliminate_states(states_inds, normalize=False)[source]¶; Creates a new quantum object with states in state_inds eliminated. Parameters:; states_inds (list of integer) – The states that should be removed.; normalize (True / False) – Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q – A new instance of qutip.Qobj that contains only the states; corresponding to indices that are not in state_inds. Return type:Qobj. Notes; Experimental. static evaluate(qobj_list, t, args)[source]¶; Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]; is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args); and. qobj_list = [H0, [H1, ‘sin(w * t)’]]; is evaluated to. Qobj(t) = H0 + H1 * sin(args[‘w’] * t). Parameters:; qobj_list (list) – A nested list of Qobj instances and corresponding time-dependent; coefficients.; t (float) – The time for which to evaluate the time-dependent Qobj instance.; args (dictionary) – A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns:output – A Qobj instance that represents the value of qobj_list at time t. Return type:Qobj. expm(method='dense')[source]¶; Matrix exponential of quantum operator.; Input operator must be square. Parameters:method (str {'dense', 'sparse'}) – Use set method to use to calculate the matrix exponentiation. The; available choices includes ‘dense’ and ‘sparse’. Since the; exponential of a matrix is nearly always dense, method=’dense’; is se",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:8392,Integrability,depend,dependent,8392,"e=False)[source]¶; Creates a new quantum object with states in state_inds eliminated. Parameters:; states_inds (list of integer) – The states that should be removed.; normalize (True / False) – Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q – A new instance of qutip.Qobj that contains only the states; corresponding to indices that are not in state_inds. Return type:Qobj. Notes; Experimental. static evaluate(qobj_list, t, args)[source]¶; Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]; is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args); and. qobj_list = [H0, [H1, ‘sin(w * t)’]]; is evaluated to. Qobj(t) = H0 + H1 * sin(args[‘w’] * t). Parameters:; qobj_list (list) – A nested list of Qobj instances and corresponding time-dependent; coefficients.; t (float) – The time for which to evaluate the time-dependent Qobj instance.; args (dictionary) – A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns:output – A Qobj instance that represents the value of qobj_list at time t. Return type:Qobj. expm(method='dense')[source]¶; Matrix exponential of quantum operator.; Input operator must be square. Parameters:method (str {'dense', 'sparse'}) – Use set method to use to calculate the matrix exponentiation. The; available choices includes ‘dense’ and ‘sparse’. Since the; exponential of a matrix is nearly always dense, method=’dense’; is set as default.s. Returns:oper – Exponentiated quantum operator. Return type:qobj. Raises:TypeError – Quantum operator is not square. extract_states(states_inds, normalize=False)[source]¶; Qobj with states in state_inds only. Parameters:; states_inds (list of integer) – The states that should be kept.; normal",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:8470,Integrability,depend,dependent,8470,"s:; states_inds (list of integer) – The states that should be removed.; normalize (True / False) – Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q – A new instance of qutip.Qobj that contains only the states; corresponding to indices that are not in state_inds. Return type:Qobj. Notes; Experimental. static evaluate(qobj_list, t, args)[source]¶; Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]; is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args); and. qobj_list = [H0, [H1, ‘sin(w * t)’]]; is evaluated to. Qobj(t) = H0 + H1 * sin(args[‘w’] * t). Parameters:; qobj_list (list) – A nested list of Qobj instances and corresponding time-dependent; coefficients.; t (float) – The time for which to evaluate the time-dependent Qobj instance.; args (dictionary) – A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns:output – A Qobj instance that represents the value of qobj_list at time t. Return type:Qobj. expm(method='dense')[source]¶; Matrix exponential of quantum operator.; Input operator must be square. Parameters:method (str {'dense', 'sparse'}) – Use set method to use to calculate the matrix exponentiation. The; available choices includes ‘dense’ and ‘sparse’. Since the; exponential of a matrix is nearly always dense, method=’dense’; is set as default.s. Returns:oper – Exponentiated quantum operator. Return type:qobj. Raises:TypeError – Quantum operator is not square. extract_states(states_inds, normalize=False)[source]¶; Qobj with states in state_inds only. Parameters:; states_inds (list of integer) – The states that should be kept.; normalize (True / False) – Weather or not the new Qobj instance should be normalized (default; is Fal",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:8582,Integrability,depend,dependent,8582,"e) – Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q – A new instance of qutip.Qobj that contains only the states; corresponding to indices that are not in state_inds. Return type:Qobj. Notes; Experimental. static evaluate(qobj_list, t, args)[source]¶; Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]; is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args); and. qobj_list = [H0, [H1, ‘sin(w * t)’]]; is evaluated to. Qobj(t) = H0 + H1 * sin(args[‘w’] * t). Parameters:; qobj_list (list) – A nested list of Qobj instances and corresponding time-dependent; coefficients.; t (float) – The time for which to evaluate the time-dependent Qobj instance.; args (dictionary) – A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns:output – A Qobj instance that represents the value of qobj_list at time t. Return type:Qobj. expm(method='dense')[source]¶; Matrix exponential of quantum operator.; Input operator must be square. Parameters:method (str {'dense', 'sparse'}) – Use set method to use to calculate the matrix exponentiation. The; available choices includes ‘dense’ and ‘sparse’. Since the; exponential of a matrix is nearly always dense, method=’dense’; is set as default.s. Returns:oper – Exponentiated quantum operator. Return type:qobj. Raises:TypeError – Quantum operator is not square. extract_states(states_inds, normalize=False)[source]¶; Qobj with states in state_inds only. Parameters:; states_inds (list of integer) – The states that should be kept.; normalize (True / False) – Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:15980,Integrability,depend,dependent,15980,"ew Qobj by removing the negative eigenvalues; of this instance, then renormalizing to obtain a valid density; operator. Parameters:method (str) – Algorithm to use to remove negative eigenvalues. “clip”; simply discards negative eigenvalues, then renormalizes.; “sgs” uses the SGS algorithm (doi:10/bb76) to find the; positive operator that is nearest in the Shatten 2-norm. Returns:oper – A valid density operator. Return type:qobj. unit(norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Operator or state normalized to unity.; Uses norm from Qobj.norm(). Parameters:; norm (str) – Requested norm for states / operators.; sparse (bool) – Use sparse eigensolver for trace norm. Does not affect other norms.; tol (float) – Tolerance used by sparse eigensolver.; maxiter (int) – Number of maximum iterations performed by sparse eigensolver. Returns:oper – Normalized quantum object. Return type:qobj. eseries¶. class eseries(q=array([], dtype=object), s=array([], dtype=float64))[source]¶; Class representation of an exponential-series expansion of; time-dependent quantum objects. ampl¶; ndarray – Array of amplitudes for exponential series. rates¶; ndarray – Array of rates for exponential series. dims¶; list – Dimensions of exponential series components. shape¶; list – Shape corresponding to exponential series components. value(tlist)¶; Evaluate an exponential series at the times listed in tlist. spec(wlist)¶; Evaluate the spectrum of an exponential series at frequencies in wlist. tidyup()¶; Returns a tidier version of the exponential series. spec(wlist)[source]¶; Evaluate the spectrum of an exponential series at frequencies; in wlist. Parameters:wlist (array_like) – Array/list of frequenies. Returns:val_list – Values of exponential series at frequencies in wlist. Return type:ndarray. tidyup(*args)[source]¶; Returns a tidier version of exponential series. value(tlist)[source]¶; Evaluates an exponential series at the times listed in tlist. Parameters:tlist (ndarray) – Times at w",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:28878,Integrability,integrat,integrate,28878," boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters:; options (qutip.solver.Options) – Generic solver options.; If set to None the default options will be used; progress_bar (BaseProgressBar) – Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar; stats (qutip.solver.Stats) – Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). cut_freq¶; float – Bath spectral density cutoff frequency. renorm¶; bool – Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx¶; bool – Use boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, pl",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:29340,Integrability,depend,depend,29340,"ion.; If set to None, then the default progress bar will be used; Set to False for no progress bar; stats (qutip.solver.Stats) – Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). cut_freq¶; float – Bath spectral density cutoff frequency. renorm¶; bool – Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx¶; bool – Use boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters:; rho0 (Qobj) – Initial state (density matrix) of the system.; tlist (list) – Time over which system evolves. Returns:results – Objec",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:30528,Integrability,integrat,integrator,30528,"h spectral density cutoff frequency. renorm¶; bool – Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx¶; bool – Use boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters:; rho0 (Qobj) – Initial state (density matrix) of the system.; tlist (list) – Time over which system evolves. Returns:results – Object storing all results from the simulation. Return type:qutip.solver.Result. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. H_S¶; qutip.Qobj – System Hamiltonian (can also be a Liouvillian). L1¶; qutip.Qobj / list of qutip.Qobj – System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2¶; qutip.Qobj / list of qutip.Qobj – System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix¶; array – S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov¶; qutip.Qobj / list of qutip.Qobj – Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator¶; str {‘propagator’, ‘mesolve’} – Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:31455,Integrability,integrat,integrator,31455," L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. H_S¶; qutip.Qobj – System Hamiltonian (can also be a Liouvillian). L1¶; qutip.Qobj / list of qutip.Qobj – System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2¶; qutip.Qobj / list of qutip.Qobj – System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix¶; array – S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov¶; qutip.Qobj / list of qutip.Qobj – Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator¶; str {‘propagator’, ‘mesolve’} – Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallel¶; bool – Run integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. options¶; qutip.solver.Options – Generic solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters:; rho0 (qutip.Qobj) – initial density matrix or state vector (ket).; blist (array_like) – List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger; tlist (array_like) – list of corresponding times t1,..,tn at which to evaluate the field; operators; tau (float) – time-delay; c1 (qutip.Qobj) – system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has mor",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:31643,Integrability,integrat,integrator,31643,"uantum systems; with time-delayed coherent feedback. H_S¶; qutip.Qobj – System Hamiltonian (can also be a Liouvillian). L1¶; qutip.Qobj / list of qutip.Qobj – System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2¶; qutip.Qobj / list of qutip.Qobj – System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix¶; array – S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov¶; qutip.Qobj / list of qutip.Qobj – Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator¶; str {‘propagator’, ‘mesolve’} – Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallel¶; bool – Run integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. options¶; qutip.solver.Options – Generic solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters:; rho0 (qutip.Qobj) – initial density matrix or state vector (ket).; blist (array_like) – List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger; tlist (array_like) – list of corresponding times t1,..,tn at which to evaluate the field; operators; tau (float) – time-delay; c1 (qutip.Qobj) – system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element); c2 (qutip.Qobj) – system collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has mor",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:31717,Integrability,integrat,integrator,31717,"; qutip.Qobj – System Hamiltonian (can also be a Liouvillian). L1¶; qutip.Qobj / list of qutip.Qobj – System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2¶; qutip.Qobj / list of qutip.Qobj – System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix¶; array – S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov¶; qutip.Qobj / list of qutip.Qobj – Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator¶; str {‘propagator’, ‘mesolve’} – Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallel¶; bool – Run integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. options¶; qutip.solver.Options – Generic solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters:; rho0 (qutip.Qobj) – initial density matrix or state vector (ket).; blist (array_like) – List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger; tlist (array_like) – list of corresponding times t1,..,tn at which to evaluate the field; operators; tau (float) – time-delay; c1 (qutip.Qobj) – system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element); c2 (qutip.Qobj) – system collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). Returns:expectation value of field c",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:36325,Integrability,integrat,integrator,36325,"old. options¶; qutip.solver.Options – Generic solver options. Solver Options and Results¶. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False, store_final_state=False, store_states=False, seeds=None, steady_state_average=False, normalize_output=True)[source]¶; Class of options for evolution solvers such as qutip.mesolve and; qutip.mcsolve. Options can be specified either as arguments to the; constructor:; opts = Options(order=10, ...). or by changing the class attributes after creation:; opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. atol¶; float {1e-8} – Absolute tolerance. rtol¶; float {1e-6} – Relative tolerance. method¶; str {‘adams’,’bdf’} – Integration method. order¶; int {12} – Order of integrator (<=12 ‘adams’, <=5 ‘bdf’). nsteps¶; int {2500} – Max. number of internal steps/call. first_step¶; float {0} – Size of initial step (0 = automatic). min_step¶; float {0} – Minimum step size (0 = automatic). max_step¶; float {0} – Maximum step size (0 = automatic). tidy¶; bool {True,False} – Tidyup Hamiltonian and initial state by removing small terms. num_cpus¶; int – Number of cpus used by mcsolver (default = # of cpus). norm_tol¶; float – Tolerance used when finding wavefunction norm in mcsolve. norm_steps¶; int – Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve. average_states¶; bool {False} – Average states values over trajectories in stochastic solvers. average_expect¶; bool {True} – Average expectation values over trajectories for stochastic solvers. mc_corr_eps¶; float {1e-10} – Arbitrarily small value for eliminating any divide-by-zero errors in; correlation calculations when using mcsolve. ntraj¶; int {500} – Number of trajectories in st",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:40794,Integrability,message,message,40794,"e¶; float – Time in seconds for the solver to complete processing; Can be None, meaning that total timing percentages will be reported. add_section()¶; Add another section. add_count()¶; Add some stat that is an integer count. add_timing()¶; Add some timing statistics. add_message()¶; Add some text type for output in the report. report:; Output the statistics report to console or file. add_count(key, value, section=None)[source]¶; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be an integer. Parameters:; key (string) – key for the section.counts dictionary; reusing a key will result in numerical addition of value; value (int) – Initial value of the count, or added to an existing count; section (string or class : _StatsSection) – Section which to add the count to.; If None given, the default (first) section will be used. add_message(key, value, section=None, sep=';')[source]¶; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters:; key (string) – key for the section.messages dictionary; reusing a key will result in concatenation of value; value (int) – Initial value of the message, or added to an existing message; sep (string) – Message will be prefixed with this string when concatenating; section (string or class : _StatsSection) – Section which to add the message to.; If None given, the default (first) section will be used. add_section(name)[source]¶; Add another section with the given name. Parameters:name (string) – will be used as key for sections dict; will also be the header for the section. Returns:section – The new section. Return type:class : _StatsSection. add_timing(key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is c",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:40930,Integrability,message,message,40930,"tion. add_count()¶; Add some stat that is an integer count. add_timing()¶; Add some timing statistics. add_message()¶; Add some text type for output in the report. report:; Output the statistics report to console or file. add_count(key, value, section=None)[source]¶; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be an integer. Parameters:; key (string) – key for the section.counts dictionary; reusing a key will result in numerical addition of value; value (int) – Initial value of the count, or added to an existing count; section (string or class : _StatsSection) – Section which to add the count to.; If None given, the default (first) section will be used. add_message(key, value, section=None, sep=';')[source]¶; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters:; key (string) – key for the section.messages dictionary; reusing a key will result in concatenation of value; value (int) – Initial value of the message, or added to an existing message; sep (string) – Message will be prefixed with this string when concatenating; section (string or class : _StatsSection) – Section which to add the message to.; If None given, the default (first) section will be used. add_section(name)[source]¶; Add another section with the given name. Parameters:name (string) – will be used as key for sections dict; will also be the header for the section. Returns:section – The new section. Return type:class : _StatsSection. add_timing(key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters:; key (string) – ke",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:41028,Integrability,message,messages,41028,"one)[source]¶; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be an integer. Parameters:; key (string) – key for the section.counts dictionary; reusing a key will result in numerical addition of value; value (int) – Initial value of the count, or added to an existing count; section (string or class : _StatsSection) – Section which to add the count to.; If None given, the default (first) section will be used. add_message(key, value, section=None, sep=';')[source]¶; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters:; key (string) – key for the section.messages dictionary; reusing a key will result in concatenation of value; value (int) – Initial value of the message, or added to an existing message; sep (string) – Message will be prefixed with this string when concatenating; section (string or class : _StatsSection) – Section which to add the message to.; If None given, the default (first) section will be used. add_section(name)[source]¶; Add another section with the given name. Parameters:name (string) – will be used as key for sections dict; will also be the header for the section. Returns:section – The new section. Return type:class : _StatsSection. add_timing(key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters:; key (string) – key for the section.timings dictionary; reusing a key will result in numerical addition of value; value (int) – Initial value of the timing, or added to an existing timing; section (string or class : _StatsSection) – Section which to add the timing to.; ",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:41137,Integrability,message,message,41137,"one)[source]¶; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be an integer. Parameters:; key (string) – key for the section.counts dictionary; reusing a key will result in numerical addition of value; value (int) – Initial value of the count, or added to an existing count; section (string or class : _StatsSection) – Section which to add the count to.; If None given, the default (first) section will be used. add_message(key, value, section=None, sep=';')[source]¶; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters:; key (string) – key for the section.messages dictionary; reusing a key will result in concatenation of value; value (int) – Initial value of the message, or added to an existing message; sep (string) – Message will be prefixed with this string when concatenating; section (string or class : _StatsSection) – Section which to add the message to.; If None given, the default (first) section will be used. add_section(name)[source]¶; Add another section with the given name. Parameters:name (string) – will be used as key for sections dict; will also be the header for the section. Returns:section – The new section. Return type:class : _StatsSection. add_timing(key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters:; key (string) – key for the section.timings dictionary; reusing a key will result in numerical addition of value; value (int) – Initial value of the timing, or added to an existing timing; section (string or class : _StatsSection) – Section which to add the timing to.; ",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:41170,Integrability,message,message,41170,"one)[source]¶; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be an integer. Parameters:; key (string) – key for the section.counts dictionary; reusing a key will result in numerical addition of value; value (int) – Initial value of the count, or added to an existing count; section (string or class : _StatsSection) – Section which to add the count to.; If None given, the default (first) section will be used. add_message(key, value, section=None, sep=';')[source]¶; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters:; key (string) – key for the section.messages dictionary; reusing a key will result in concatenation of value; value (int) – Initial value of the message, or added to an existing message; sep (string) – Message will be prefixed with this string when concatenating; section (string or class : _StatsSection) – Section which to add the message to.; If None given, the default (first) section will be used. add_section(name)[source]¶; Add another section with the given name. Parameters:name (string) – will be used as key for sections dict; will also be the header for the section. Returns:section – The new section. Return type:class : _StatsSection. add_timing(key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters:; key (string) – key for the section.timings dictionary; reusing a key will result in numerical addition of value; value (int) – Initial value of the timing, or added to an existing timing; section (string or class : _StatsSection) – Section which to add the timing to.; ",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:41325,Integrability,message,message,41325,"one)[source]¶; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be an integer. Parameters:; key (string) – key for the section.counts dictionary; reusing a key will result in numerical addition of value; value (int) – Initial value of the count, or added to an existing count; section (string or class : _StatsSection) – Section which to add the count to.; If None given, the default (first) section will be used. add_message(key, value, section=None, sep=';')[source]¶; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters:; key (string) – key for the section.messages dictionary; reusing a key will result in concatenation of value; value (int) – Initial value of the message, or added to an existing message; sep (string) – Message will be prefixed with this string when concatenating; section (string or class : _StatsSection) – Section which to add the message to.; If None given, the default (first) section will be used. add_section(name)[source]¶; Add another section with the given name. Parameters:name (string) – will be used as key for sections dict; will also be the header for the section. Returns:section – The new section. Return type:class : _StatsSection. add_timing(key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters:; key (string) – key for the section.timings dictionary; reusing a key will result in numerical addition of value; value (int) – Initial value of the timing, or added to an existing timing; section (string or class : _StatsSection) – Section which to add the timing to.; ",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:42283,Integrability,message,messages,42283," class : _StatsSection) – Section which to add the message to.; If None given, the default (first) section will be used. add_section(name)[source]¶; Add another section with the given name. Parameters:name (string) – will be used as key for sections dict; will also be the header for the section. Returns:section – The new section. Return type:class : _StatsSection. add_timing(key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters:; key (string) – key for the section.timings dictionary; reusing a key will result in numerical addition of value; value (int) – Initial value of the timing, or added to an existing timing; section (string or class : _StatsSection) – Section which to add the timing to.; If None given, the default (first) section will be used. clear()[source]¶; Clear counts, timings and messages from all sections. report(output=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='UTF-8'>)[source]¶; Report the counts, timings and messages from the sections.; Sections are reported in the order that the names were supplied; in the constructor.; The counts, timings and messages are reported in the order that they; are added to the sections; The output can be written to anything that supports a write method,; e.g. a file or the console (default); The output is intended to in markdown format. Parameters:output (stream) – file or console stream - anything that support write - where; the output will be written. set_total_time(value, section=None)[source]¶; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds. Parameters:; value (float) – Time in seconds to complete the solver section; section (string or class : _StatsSection) – Section which to set the total_time for; If None given, the total_tim",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:42429,Integrability,message,messages,42429,". add_section(name)[source]¶; Add another section with the given name. Parameters:name (string) – will be used as key for sections dict; will also be the header for the section. Returns:section – The new section. Return type:class : _StatsSection. add_timing(key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters:; key (string) – key for the section.timings dictionary; reusing a key will result in numerical addition of value; value (int) – Initial value of the timing, or added to an existing timing; section (string or class : _StatsSection) – Section which to add the timing to.; If None given, the default (first) section will be used. clear()[source]¶; Clear counts, timings and messages from all sections. report(output=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='UTF-8'>)[source]¶; Report the counts, timings and messages from the sections.; Sections are reported in the order that the names were supplied; in the constructor.; The counts, timings and messages are reported in the order that they; are added to the sections; The output can be written to anything that supports a write method,; e.g. a file or the console (default); The output is intended to in markdown format. Parameters:output (stream) – file or console stream - anything that support write - where; the output will be written. set_total_time(value, section=None)[source]¶; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds. Parameters:; value (float) – Time in seconds to complete the solver section; section (string or class : _StatsSection) – Section which to set the total_time for; If None given, the total_time for complete solve is set. class StochasticSolverOptions(H=None, state0=None, times=None, c_ops=[], sc_ops=[], e_ops=",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:42568,Integrability,message,messages,42568,"StatsSection. add_timing(key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters:; key (string) – key for the section.timings dictionary; reusing a key will result in numerical addition of value; value (int) – Initial value of the timing, or added to an existing timing; section (string or class : _StatsSection) – Section which to add the timing to.; If None given, the default (first) section will be used. clear()[source]¶; Clear counts, timings and messages from all sections. report(output=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='UTF-8'>)[source]¶; Report the counts, timings and messages from the sections.; Sections are reported in the order that the names were supplied; in the constructor.; The counts, timings and messages are reported in the order that they; are added to the sections; The output can be written to anything that supports a write method,; e.g. a file or the console (default); The output is intended to in markdown format. Parameters:output (stream) – file or console stream - anything that support write - where; the output will be written. set_total_time(value, section=None)[source]¶; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds. Parameters:; value (float) – Time in seconds to complete the solver section; section (string or class : _StatsSection) – Section which to set the total_time for; If None given, the total_time for complete solve is set. class StochasticSolverOptions(H=None, state0=None, times=None, c_ops=[], sc_ops=[], e_ops=[], m_ops=None, args=None, ntraj=1, nsubsteps=1, d1=None, d2=None, d2_len=1, dW_factors=None, rhs=None, generate_A_ops=None, generate_noise=None, homogeneous=True, solver=None, method=None, distribution='normal', store_measurement=Fal",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:50002,Integrability,depend,depending,50002,"nate.; xlabels (list) – List of labels for each coordinate. marginal(dim=0)[source]¶; Calculate the marginal distribution function along the dimension; dim. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters:dim (int) – The dimension (coordinate index) along which to obtain the; marginal distribution. Returns:d – A new instances of Distribution that describes the marginal; distribution. Return type:Distributions. project(dim=0)[source]¶; Calculate the projection (max value) distribution function along the; dimension dim. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters:dim (int) – The dimension (coordinate index) along which to obtain the; projected distribution. Returns:d – A new instances of Distribution that describes the projection. Return type:Distributions. visualize(fig=None, ax=None, figsize=(8, 6), colorbar=True, cmap=None, style='colormap', show_xlabel=True, show_ylabel=True)[source]¶; Visualize the data of the distribution in 1D or 2D, depending; on the dimensionality of the underlaying distribution.; Parameters:. fig; : matplotlib Figure instanceIf given, use this figure instance for the visualization,; ax; : matplotlib Axes instanceIf given, render the visualization using this axis instance.; figsize; : tupleSize of the new Figure instance, if one needs to be created.; colorbar: Bool; Whether or not the colorbar (in 2D visualization) should be used.; cmap: matplotlib colormap instance; If given, use this colormap for 2D visualizations.; style; : stringType of visualization: ‘colormap’ (default) or ‘surface’. Returns:fig, ax – A tuple of matplotlib figure and axes instances. Return type:tuple. class WignerDistribution(rho=None, extent=[[-5, 5], [-5, 5]], steps=250)[source]¶. class QDistribution(rho=None, extent=[[-5, 5], [-5, 5]], steps=250)[source]¶. class TwoModeQuadratureCorrelation(state=None, theta1=0.0, theta2=0.0, extent=[[-5, 5], [-5, 5]], steps=25",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:60524,Integrability,message,message,60524,"options; Dynamics instance - describes the dynamics of the (quantum) system. to be control optimised. log_level¶; integer – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params¶; Dictionary – The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg¶; string – Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params¶; Dictionary – options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg¶; bool – Set true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_method¶; string – a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_params¶; Dictionary – Options for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_grad¶; bool – If set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound¶; float or list of floats – lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound¶; float or list of floats – upper boundaries for t",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:66382,Integrability,wrap,wrapper,66382,"ation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(term_conds=None)[source]¶; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object,",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:67925,Integrability,wrap,wrapper,67925,"all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. max_metric_corr¶; integer – The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:69375,Integrability,wrap,wrapper,69375,"algorithm. max_metric_corr¶; integer – The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:70697,Integrability,wrap,wrapper,70697,"ditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol.; If the parameter term_co",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:71118,Integrability,wrap,wrapper,71118,"specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimIterSummary[source]¶; A summary of the most recent iteration of the pulse optimisation. iter_num¶; int – Iteration number ",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:87445,Integrability,message,message,87445,"ls¶; calculate the of controls from the length of the control list; sets the num_ctrls property, which can be used alternatively; subsequently. onto_evo¶; List of evolution operators (Qobj) from the initial to the given; timeslot. onwd_evo¶; List of evolution operators (Qobj) from the initial to the given; timeslot. prop¶; List of propagators (Qobj) for each timeslot. prop_grad¶; Array of propagator gradients (Qobj) for each timeslot, control. refresh_drift_attribs()[source]¶; Reset the dyn_shape, dyn_dims and time_depend_drift attribs. save_amps(file_name=None, times=None, amps=None, verbose=False)[source]¶; Save a file with the current control amplitudes in each timeslot; The first column in the file will be the start time of the slot. Parameters:; file_name (string) – Name of the file; If None given the def_amps_fname attribuite will be used; times (List type (or string)) – List / array of the start times for each slot; If None given this will be retrieved through get_amp_times(); If ‘exclude’ then times will not be saved in the file, just; the amplitudes; amps (Array[num_tslots, num_ctrls]) – Amplitudes to be saved; If None given the ctrl_amps attribute will be used; verbose (Boolean) – If True then an info message will be logged. unitarity_check()[source]¶; Checks whether all propagators are unitary. update_ctrl_amps(new_amps)[source]¶; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer. class DynamicsGenMat(optimconfig, params=None)[source]¶; This sub class can be used for any system where no additional; operator is applied to the dynamics generator before calculating; the propagator, e.g. classical dynamics, Lindbladian. class DynamicsUnitary(optimconfig, params=None)[source]¶; This is the subclass to use for systems with dynamics described by; unitary matrices. E.g. closed systems with Hermitian Hamiltonians; Note a matrix diagona",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:114616,Integrability,depend,depends,114616,"he gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates¶; integer – Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter¶; float – Mean number of control amplitude updates per iteration. num_timeslot_changes¶; integer – Number of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_update¶; float – Mean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changes¶; integer – Number of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_update¶; float – Mean average number of control amplitudes that are changed per update. calculate()[source]¶; Perform the calculations (e.g. averages) that are required on the stats; Should be called before calling report. report()[source]¶; Print a report of the stats to the console. class Dump[source]¶; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. parent¶; some control object (Dynamics or Optimizer) – aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dir¶; str – directory where files (if any) will be written out; the path and be relative or absolute; use ~/ to specify user home directory; Note: files are only written when write_to_file is True; of writeout is called explicitly; Defaults to ~/.qtrl_dump. level¶; string – level of data dumping: SUMMARY, FULL or CUSTOM; See property docstring for details; Set automatically if dump is created by the setting host dumping attrib. write_to_file¶; bool – When set True data and summaries (as configured) will be written; interactively to file during the processing; Set during instantiation by the host based on its dump_to_file attrib. dump_file_ext¶; str – Default file extension for any file names that are auto generated. fname_base¶; str – First part of any auto generated file names.; This is usually ov",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:26840,Modifiability,coupling,coupling,26840,"or this.; A good introduction, and perhaps closest to the notation used here is:; DOI:10.1103/PhysRevLett.104.250401; A more canonical reference, with full derivation is:; DOI: 10.1103/PhysRevA.41.6676; The method can compute open system dynamics without using any Markovian; or rotating wave approximation (RWA) for systems where the bath; correlations can be approximated to a sum of complex eponentials.; The method builds a matrix of linked differential equations, which are; then solved used the same ODE solvers as other qutip solvers (e.g. mesolve); This class should be treated as abstract. Currently the only subclass; implemented is that for the Drude-Lorentz spectral density. This covers; the majority of the work that has been done using this model, and there; are some performance advantages to assuming this model where it is; appropriate.; There are opportunities to develop a more general spectral density code. H_sys¶; Qobj – System Hamiltonian. coup_op¶; Qobj – Operator describing the coupling between system and bath. coup_strength¶; float – Coupling strength. temperature¶; float – Bath temperature, in units corresponding to planck. N_cut¶; int – Cutoff parameter for the bath. N_exp¶; int – Number of exponential terms used to approximate the bath correlation; functions. planck¶; float – reduced Planck constant. boltzmann¶; float – Boltzmann’s constant. options¶; qutip.solver.Options – Generic solver options.; If set to None the default options will be used. progress_bar¶; BaseProgressBar – Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. stats¶; qutip.solver.Stats – optional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coeff¶; list of complex – Coefficients for the exponential series terms. exp_freq¶; list of complex – Frequencies for the exponential series terms. configure(H_sys, coup_op, coup_strengt",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:27798,Modifiability,config,configure,27798,"ts corresponding to planck. N_cut¶; int – Cutoff parameter for the bath. N_exp¶; int – Number of exponential terms used to approximate the bath correlation; functions. planck¶; float – reduced Planck constant. boltzmann¶; float – Boltzmann’s constant. options¶; qutip.solver.Options – Generic solver options.; If set to None the default options will be used. progress_bar¶; BaseProgressBar – Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. stats¶; qutip.solver.Stats – optional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coeff¶; list of complex – Coefficients for the exponential series terms. exp_freq¶; list of complex – Frequencies for the exponential series terms. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters:; options (qutip.solver.Options) – Generic solver options.; If set to None the default options will be used; progress_bar (BaseProgressBar) – Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar; stats (qutip.solver.Stats) – Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class HSolverDL(",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:28870,Modifiability,config,config,28870," boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters:; options (qutip.solver.Options) – Generic solver options.; If set to None the default options will be used; progress_bar (BaseProgressBar) – Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar; stats (qutip.solver.Stats) – Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). cut_freq¶; float – Bath spectral density cutoff frequency. renorm¶; bool – Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx¶; bool – Use boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, pl",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:29657,Modifiability,coupling,coupling,29657,"lass will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). cut_freq¶; float – Bath spectral density cutoff frequency. renorm¶; bool – Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx¶; bool – Use boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters:; rho0 (Qobj) – Initial state (density matrix) of the system.; tlist (list) – Time over which system evolves. Returns:results – Object storing all results from the simulation. Return type:qutip.solver.Result. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:29799,Modifiability,config,configure,29799,"ues. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). cut_freq¶; float – Bath spectral density cutoff frequency. renorm¶; bool – Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx¶; bool – Use boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters:; rho0 (Qobj) – Initial state (density matrix) of the system.; tlist (list) – Time over which system evolves. Returns:results – Object storing all results from the simulation. Return type:qutip.solver.Result. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. H_S¶; qutip.Qobj – System Hamiltonian (can also be a Liouvillian). L1¶; qutip.Qobj / list of qutip.Qobj – System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2¶; qutip.Qobj / list of qutip.Qobj ",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:30001,Modifiability,config,configure,30001,"ues. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). cut_freq¶; float – Bath spectral density cutoff frequency. renorm¶; bool – Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx¶; bool – Use boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters:; rho0 (Qobj) – Initial state (density matrix) of the system.; tlist (list) – Time over which system evolves. Returns:results – Object storing all results from the simulation. Return type:qutip.solver.Result. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. H_S¶; qutip.Qobj – System Hamiltonian (can also be a Liouvillian). L1¶; qutip.Qobj / list of qutip.Qobj – System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2¶; qutip.Qobj / list of qutip.Qobj ",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:30353,Modifiability,evolve,evolves,30353,"ch depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). cut_freq¶; float – Bath spectral density cutoff frequency. renorm¶; bool – Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx¶; bool – Use boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters:; rho0 (Qobj) – Initial state (density matrix) of the system.; tlist (list) – Time over which system evolves. Returns:results – Object storing all results from the simulation. Return type:qutip.solver.Result. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. H_S¶; qutip.Qobj – System Hamiltonian (can also be a Liouvillian). L1¶; qutip.Qobj / list of qutip.Qobj – System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2¶; qutip.Qobj / list of qutip.Qobj – System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix¶; array – S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov¶; qutip.Qobj / list of qutip.Qobj ",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:30823,Modifiability,coupling,coupling,30823,"up_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters:; rho0 (Qobj) – Initial state (density matrix) of the system.; tlist (list) – Time over which system evolves. Returns:results – Object storing all results from the simulation. Return type:qutip.solver.Result. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. H_S¶; qutip.Qobj – System Hamiltonian (can also be a Liouvillian). L1¶; qutip.Qobj / list of qutip.Qobj – System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2¶; qutip.Qobj / list of qutip.Qobj – System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix¶; array – S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov¶; qutip.Qobj / list of qutip.Qobj – Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator¶; str {‘propagator’, ‘mesolve’} – Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallel¶; bool – Run integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. options¶; qutip.solver.Options – Generic solver options. outfieldcorr(rho0, blist, tlist, t",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:30962,Modifiability,coupling,coupling,30962,"None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters:; rho0 (Qobj) – Initial state (density matrix) of the system.; tlist (list) – Time over which system evolves. Returns:results – Object storing all results from the simulation. Return type:qutip.solver.Result. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. H_S¶; qutip.Qobj – System Hamiltonian (can also be a Liouvillian). L1¶; qutip.Qobj / list of qutip.Qobj – System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2¶; qutip.Qobj / list of qutip.Qobj – System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix¶; array – S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov¶; qutip.Qobj / list of qutip.Qobj – Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator¶; str {‘propagator’, ‘mesolve’} – Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallel¶; bool – Run integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. options¶; qutip.solver.Options – Generic solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, ",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:52276,Modifiability,variab,variable,52276,"tion. update_rho(rho)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode density matrix. class HarmonicOscillatorWaveFunction(psi=None, omega=1.0, extent=[-5, 5], steps=250)[source]¶. update(psi)[source]¶; Calculate the wavefunction for the given state of an harmonic; oscillator. class HarmonicOscillatorProbabilityFunction(rho=None, omega=1.0, extent=[-5, 5], steps=250)[source]¶. update(rho)[source]¶; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix). Quantum information processing¶. class Gate(name, targets=None, controls=None, arg_value=None, arg_label=None)[source]¶; Representation of a quantum gate, with its required parametrs, and target; and control qubits. class QubitCircuit(N, reverse_states=True)[source]¶; Representation of a quantum program/algorithm, maintaining a sequence; of gates. add_1q_gate(name, start=0, end=None, qubits=None, arg_value=None, arg_label=None)[source]¶; Adds a single qubit gate with specified parameters on a variable; number of qubits in the circuit. By default, it applies the given gate; to all the qubits in the register. Parameters:; name (String) – Gate name.; start (Integer) – Starting location of qubits.; end (Integer) – Last qubit for the gate.; qubits (List) – Specific qubits for applying gates.; arg_value (Float) – Argument value(phi).; arg_label (String) – Label for gate representation. add_circuit(qc, start=0)[source]¶; Adds a block of a qubit circuit to the main circuit.; Globalphase gates are not added. Parameters:; qc (QubitCircuit) – The circuit block to be added to the main circuit.; start (Integer) – The qubit on which the first gate is applied. add_gate(gate, targets=None, controls=None, arg_value=None, arg_label=None)[source]¶; Adds a gate with specified parameters to the circuit. Parameters:; gate (String or Gate) – Gate name. If gate is an instance of Gate, parameters are; unpacked and added.; targets (List) – Gate ta",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:59188,Modifiability,config,config,59188,"rSpinChain(N, correct_global_phase=True, sx=None, sz=None, sxsy=None)[source]¶; Representation of the physical implementation of a quantum; program/algorithm on a spin chain qubit system arranged in a circular; formation. It is a sub-class of SpinChain. class DispersivecQED(N, correct_global_phase=True, Nres=None, deltamax=None, epsmax=None, w0=None, wq=None, eps=None, delta=None, g=None)[source]¶; Representation of the physical implementation of a quantum; program/algorithm on a dispersive cavity-QED system. dispersive_gate_correction(qc1, rwa=True)[source]¶; Method to resolve ISWAP and SQRTISWAP gates in a cQED system by adding; single qubit gates to get the correct output matrix. Parameters:; qc (Qobj) – The circular spin chain circuit to be resolved; rwa (Boolean) – Specify if RWA is used or not. Returns:qc – Returns QubitCircuit of resolved gates for the qubit circuit in the; desired basis. Return type:QubitCircuit. Optimal control¶. class Optimizer(config, dyn, params=None)[source]¶; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a. OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system. to be control optimised. log_level¶; integer – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params¶; Dictionary – The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg¶; string –",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:59491,Modifiability,config,configuration,59491,"ue, Nres=None, deltamax=None, epsmax=None, w0=None, wq=None, eps=None, delta=None, g=None)[source]¶; Representation of the physical implementation of a quantum; program/algorithm on a dispersive cavity-QED system. dispersive_gate_correction(qc1, rwa=True)[source]¶; Method to resolve ISWAP and SQRTISWAP gates in a cQED system by adding; single qubit gates to get the correct output matrix. Parameters:; qc (Qobj) – The circular spin chain circuit to be resolved; rwa (Boolean) – Specify if RWA is used or not. Returns:qc – Returns QubitCircuit of resolved gates for the qubit circuit in the; desired basis. Return type:QubitCircuit. Optimal control¶. class Optimizer(config, dyn, params=None)[source]¶; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a. OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system. to be control optimised. log_level¶; integer – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params¶; Dictionary – The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg¶; string – Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params¶; Dictionary – options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg¶; bool – Set true to display a converge",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:62082,Modifiability,config,config,62082," Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound¶; float or list of floats – lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound¶; float or list of floats – upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds¶; List of floats – Bounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamics¶; Dynamics (subclass instance) – describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). config¶; OptimConfig instance – various configuration options; (see OptimConfig for details). termination_conditions¶; TerminationCondition instance – attributes determine when the optimisation will end. pulse_generator¶; PulseGen (subclass instance) – (can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. stats¶; Stats – attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dump¶; dump.OptimDump – Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping¶; string – level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file¶; bool – If set True then data will be dumped to file during the optimisation; dumping will be set",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:62122,Modifiability,config,configuration,62122," Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound¶; float or list of floats – lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound¶; float or list of floats – upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds¶; List of floats – Bounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamics¶; Dynamics (subclass instance) – describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). config¶; OptimConfig instance – various configuration options; (see OptimConfig for details). termination_conditions¶; TerminationCondition instance – attributes determine when the optimisation will end. pulse_generator¶; PulseGen (subclass instance) – (can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. stats¶; Stats – attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dump¶; dump.OptimDump – Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping¶; string – level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file¶; bool – If set True then data will be dumped to file during the optimisation; dumping will be set",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:64856,Modifiability,variab,variable,64856,"scipy.optimize.minimize function. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. dumping¶. The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is t",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:65260,Modifiability,variab,variables,65260,"written if they do. dumping¶. The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]¶; Check the elapsed wall time for the optimi",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:65414,Modifiability,variab,variables,65414,"lt); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(term_conds=None)[source]¶; This default fu",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:65454,Modifiability,variab,variable,65454,"dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(term_conds=None)[source]¶; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.; It will attempt ",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:66116,Modifiability,config,configuration,66116,"get, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(term_conds=None)[source]¶; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:67448,Modifiability,config,config,67448,"spect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. max_metric_corr¶; integer – The maximum number of variable metric corrections used to define; the limi",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:68281,Modifiability,config,config,68281," in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. max_metric_corr¶; integer – The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall t",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:68436,Modifiability,variab,variable,68436,"GS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. max_metric_corr¶; integer – The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:68884,Modifiability,config,configuration,68884," (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. max_metric_corr¶; integer – The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which inclu",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:69939,Modifiability,config,config,69939,"mplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011). [2] T. Canev",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:70504,Modifiability,config,configuration,70504,"ablished implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, o",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:70543,Modifiability,config,config,70543," SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will sto",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:86141,Modifiability,config,configuration,86141,"ion operators (Qobj) from the initial to the given; timeslot. get_ctrl_dyn_gen(j)[source]¶; Get the dynamics generator for the control; Not implemented in the base class. Choose a subclass. get_drift_dim()[source]¶; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N. get_dyn_gen(k)[source]¶; Get the combined dynamics generator for the timeslot; Not implemented in the base class. Choose a subclass. get_num_ctrls()[source]¶; calculate the of controls from the length of the control list; sets the num_ctrls property, which can be used alternatively; subsequently. init_timeslots()[source]¶; Generate the timeslot duration array ‘tau’ based on the evo_time; and num_tslots attributes, unless the tau attribute is already set; in which case this step in ignored; Generate the cumulative time array ‘time’ based on the tau values. initialize_controls(amps, init_tslots=True)[source]¶; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated. num_ctrls¶; calculate the of controls from the length of the control list; sets the num_ctrls property, which can be used alternatively; subsequently. onto_evo¶; List of evolution operators (Qobj) from the initial to the given; timeslot. onwd_evo¶; List of evolution operators (Qobj) from the initial to the given; timeslot. prop¶; List of propagators (Qobj) for each timeslot. prop_grad¶; Array of propagator gradients (Qobj) for each timeslot, control. refresh_drift_attribs()[source]¶; Reset the dyn_shape, dyn_dims and time_depend_drift attribs. save_amps(file_name=None, times=None, amps=None, verbose=False)[source]¶; Save a file with the current control amplitudes in each timeslot; The first column in the file will be the start time of the slot. Parameters:; file_name (string) – Name of the file; If None given the def_amps_fname attribuite will be used; times (List type (or string)) –",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:90916,Modifiability,config,configuration,90916,"cation. log_level¶; integer – level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exact¶; boolean – indicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]¶. Frechet method for calculating the propagator:; exponentiating the combined dynamics generator. and the propagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient. class FidelityComputer(dynamics, params=None)[source]¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the ",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:91192,Modifiability,config,configuration,91192,"xecution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exact¶; boolean – indicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]¶. Frechet method for calculating the propagator:; exponentiating the combined dynamics generator. and the propagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient. class FidelityComputer(dynamics, params=None)[source]¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. log_level¶; integer – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of mess",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:91385,Modifiability,config,configuration,91385,"es whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]¶. Frechet method for calculating the propagator:; exponentiating the combined dynamics generator. and the propagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient. class FidelityComputer(dynamics, params=None)[source]¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. log_level¶; integer – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSE",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:94521,Modifiability,config,configuration,94521,"ity error gradients; (sqrt of the sum of the squares). fid_err_grad_current¶; boolean – flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). phase_option¶; string –. determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm¶; complex – Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current¶; boolean – flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nT",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:94580,Modifiability,config,configuration,94580," to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). phase_option¶; string –. determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm¶; complex – Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current¶; boolean – flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as n",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:96114,Modifiability,config,config,96114,"m¶; complex – Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current¶; boolean – flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(A)[source]¶. normalize_SU(A)[source]¶. normalize_gradient_PSU(grad)[source]¶; Normalise the gradient matrix passed as grad; This PSU version is",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:96352,Modifiability,config,configuration,96352,"culates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(A)[source]¶. normalize_SU(A)[source]¶. normalize_gradient_PSU(grad)[source]¶; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(grad)[source]¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. set_phase_option(phase_option=None)[source]¶; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCo",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:98864,Modifiability,config,configuration,98864,"; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. scale_factor¶; float – The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. epsilon¶; float – control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. class TimeslotComputer(dynamics, params=None)[source]¶; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. log_level¶; integer – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITI",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:111487,Modifiability,config,configurations,111487,"e optimisation method; Typically this will be the basis coefficients. class PulseGenCrabFourier(dyn=None, num_coeffs=None, params=None)[source]¶; Generates a pulse using the Fourier basis functions, i.e. sin and cos. freqs¶; float array[num_coeffs] – Frequencies for the basis functions. randomize_freqs¶; bool – If True (default) the some random offset is applied to the frequencies. gen_pulse(coeffs=None)[source]¶; Generate a pulse using the Fourier basis with the freqs and; coeffs attributes. Parameters:coeffs (float array[num_coeffs, num_basis_funcs]) – The basis coefficient values; If given this overides the default and sets the attribute; of the same name. init_freqs()[source]¶; Generate the frequencies; These are the Fourier harmonics with a uniformly distributed; random offset. init_pulse(num_coeffs=None)[source]¶; Set the initial freq and coefficient values. reset()[source]¶; reset attributes to default values. class Stats[source]¶; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. dyn_gen_name¶; string – Text used in some report functions.; Makes sense to set it to ‘Hamiltonian’ when using unitary dynamics; Default is simply ‘dynamics generator’. num_iter¶; integer – Number of iterations of the optimisation algorithm. wall_time_optim_start¶; float – Start time for the optimisation. wall_time_optim_end¶; float – End time for the optimisation. wall_time_optim¶; float – Time elasped during the optimisation. wall_time_dyn_gen_compute¶; float – Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute¶; float – Total wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_time_fwd_prop_compute¶; f",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:115305,Modifiability,config,configured,115305,"ate()[source]¶; Perform the calculations (e.g. averages) that are required on the stats; Should be called before calling report. report()[source]¶; Print a report of the stats to the console. class Dump[source]¶; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. parent¶; some control object (Dynamics or Optimizer) – aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dir¶; str – directory where files (if any) will be written out; the path and be relative or absolute; use ~/ to specify user home directory; Note: files are only written when write_to_file is True; of writeout is called explicitly; Defaults to ~/.qtrl_dump. level¶; string – level of data dumping: SUMMARY, FULL or CUSTOM; See property docstring for details; Set automatically if dump is created by the setting host dumping attrib. write_to_file¶; bool – When set True data and summaries (as configured) will be written; interactively to file during the processing; Set during instantiation by the host based on its dump_to_file attrib. dump_file_ext¶; str – Default file extension for any file names that are auto generated. fname_base¶; str – First part of any auto generated file names.; This is usually overridden in the subclass. dump_summary¶; bool – If True a summary is recorded each time a new item is added to the; the dump.; Default is True. summary_sep¶; str – delimiter for the summary file.; default is a space. data_sep¶; str – delimiter for the data files (arrays saved to file).; default is a space. summary_file¶; str – File path for summary file.; Automatically generated. Can be set specifically. create_dump_dir()[source]¶; Checks dump directory exists, creates it if not. level¶. The level of data dumping that will occur. SUMMARY : A summary will be recorded; FULL : All possible dumping; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the u",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:3888,Performance,perform,performing,3888,"tum object. cosm()¶; Cosine of quantum object. dag()¶; Adjoint (dagger) of quantum object. dnorm()¶; Diamond norm of quantum operator. dual_chan()¶; Dual channel of quantum object representing a CP map. eigenenergies(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)¶; Returns eigenenergies (eigenvalues) of a quantum object. eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)¶; Returns eigenenergies and eigenstates of quantum object. expm()¶; Matrix exponential of quantum object. full()¶; Returns dense array of quantum object data attribute. groundstate(sparse=False, tol=0, maxiter=100000)¶; Returns eigenvalue and eigenket for the groundstate of a quantum; object. matrix_element(bra, ket)¶; Returns the matrix element of operator between bra and ket vectors. norm(norm='tr', sparse=False, tol=0, maxiter=100000)¶; Returns norm of a ket or an operator. permute(order)¶; Returns composite qobj with indices reordered. ptrace(sel)¶; Returns quantum object for selected dimensions after performing; partial trace. sinm()¶; Sine of quantum object. sqrtm()¶; Matrix square root of quantum object. tidyup(atol=1e-12)¶; Removes small elements from quantum object. tr()¶; Trace of quantum object. trans()¶; Transpose of quantum object. transform(inpt, inverse=False)¶; Performs a basis transformation defined by inpt matrix. trunc_neg(method='clip')¶; Removes negative eigenvalues and returns a new Qobj that is; a valid density operator. unit(norm='tr', sparse=False, tol=0, maxiter=100000)¶; Returns normalized quantum object. check_herm()[source]¶; Check if the quantum object is hermitian. Returns:isherm – Returns the new value of isherm property. Return type:bool. conj()[source]¶; Conjugate operator of quantum object. cosm()[source]¶; Cosine of a quantum operator.; Operator must be square. Returns:oper – Matrix cosine of operator. Return type:qobj. Raises:TypeError – Quantum object is not square. Notes; Uses the Q.expm() method. dag()[source]¶; Adjoint operat",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:6134,Performance,perform,performed,6134," the diamond distance to another operator. Parameters:B (Qobj or None) – If B is not None, the diamond distance d(A, B) = dnorm(A - B) between; this operator and B is returned instead of the diamond norm. Returns:d – Either the diamond norm of this operator, or the diamond distance; from this operator to B. Return type:float. dual_chan()[source]¶; Dual channel of quantum object representing a completely positive; map. eigenenergies(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)[source]¶; Eigenenergies of a quantum object.; Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters:; sparse (bool) – Use sparse Eigensolver; sort (str) – Sort eigenvalues ‘low’ to high, or ‘high’ to low.; eigvals (int) – Number of requested eigenvalues. Default is all eigenvalues.; tol (float) – Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter (int) – Maximum number of iterations performed by sparse solver (if used). Returns:eigvals – Array of eigenvalues for operator. Return type:array. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)[source]¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters:; sparse (bool) – Use sparse Eigensolver; sort (str) – Sort eigenvalues (and vectors) ‘low’ to high, or ‘high’ to low.; eigvals (int) – Number of requested eigenvalues. Default is all eigenvalues.; tol (float) – Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter (int) – Maximum number of iterations performed by sparse solver (if used). Returns:; eigvals (array) – Array of eigenvalues for operator.; eigvecs (array) – Array of quantum operators representing the oprat",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:6960,Performance,perform,performed,6960,") – Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter (int) – Maximum number of iterations performed by sparse solver (if used). Returns:eigvals – Array of eigenvalues for operator. Return type:array. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)[source]¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters:; sparse (bool) – Use sparse Eigensolver; sort (str) – Sort eigenvalues (and vectors) ‘low’ to high, or ‘high’ to low.; eigvals (int) – Number of requested eigenvalues. Default is all eigenvalues.; tol (float) – Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter (int) – Maximum number of iterations performed by sparse solver (if used). Returns:; eigvals (array) – Array of eigenvalues for operator.; eigvecs (array) – Array of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eliminate_states(states_inds, normalize=False)[source]¶; Creates a new quantum object with states in state_inds eliminated. Parameters:; states_inds (list of integer) – The states that should be removed.; normalize (True / False) – Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q – A new instance of qutip.Qobj that contains only the states; corresponding to indices that are not in state",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:10385,Performance,perform,performed,10385," Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q – A new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Return type:Qobj. Notes; Experimental. full(squeeze=False)[source]¶; Dense array from quantum object. Returns:data – Array of complex data from quantum objects data attribute. Return type:array. groundstate(sparse=False, tol=0, maxiter=100000, safe=True)[source]¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters:; sparse (bool) – Use sparse Eigensolver; tol (float) – Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter (int) – Maximum number of iterations performed by sparse solver (if used).; safe (bool (default=True)) – Check for degenerate ground state. Returns:; eigval (float) – Eigenvalue for the ground state of quantum operator.; eigvec (qobj) – Eigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. matrix_element(bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters:; bra (qobj) – Quantum object of type ‘bra’.; ket (qobj) – Quantum object of type ‘ket’. Returns:elem – Complex valued matrix element. Return type:complex. Raises:TypeError – Can only calculate matrix elements between a bra and ket; quantum object. norm(norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:11858,Performance,perform,performed,11858," object sandwiched between a; bra and ket vector. Parameters:; bra (qobj) – Quantum object of type ‘bra’.; ket (qobj) – Quantum object of type ‘ket’. Returns:elem – Complex valued matrix element. Return type:complex. Raises:TypeError – Can only calculate matrix elements between a bra and ket; quantum object. norm(norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Parameters:; norm (str) – Which norm to use for ket/bra vectors: L2 ‘l2’, max norm ‘max’,; or for operators: trace ‘tr’, Frobius ‘fro’, one ‘one’, or max; ‘max’.; sparse (bool) – Use sparse eigenvalue solver for trace norm. Other norms are not; affected by this parameter.; tol (float) – Tolerance for sparse solver (if used) for trace norm. The sparse; solver may not converge if the tolerance is set too low.; maxiter (int) – Maximum number of iterations performed by sparse solver (if used); for trace norm. Returns:norm – The requested norm of the operator or state quantum object. Return type:float. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. overlap(state)[source]¶; Overlap between two state vectors.; Gives the overlap (scalar product) for the quantum object and state; state vector. Parameters:state (qobj) – Quantum object for a state vector of type ‘ket’ or ‘bra’. Returns:overlap – Complex valued overlap. Return type:complex. Raises:TypeError – Can only calculate overlap between a bra and ket quantum objects. permute(order)[source]¶; Permutes a composite quantum object. Parameters:order (list/array) – List specifying new tensor order. Returns:P – Permuted quantum object. Return type:qobj. ptrace(sel)[source]¶; Partial trace of the quantum object. Parameters:sel (int/list) – An int or list of components to keep after partial trace. Returns:oper – Quantum object r",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:15733,Performance,perform,performed,15733,"urns:oper – Operator in new basis. Return type:qobj. Notes; This function is still in development. trunc_neg(method='clip')[source]¶; Truncates negative eigenvalues and renormalizes.; Returns a new Qobj by removing the negative eigenvalues; of this instance, then renormalizing to obtain a valid density; operator. Parameters:method (str) – Algorithm to use to remove negative eigenvalues. “clip”; simply discards negative eigenvalues, then renormalizes.; “sgs” uses the SGS algorithm (doi:10/bb76) to find the; positive operator that is nearest in the Shatten 2-norm. Returns:oper – A valid density operator. Return type:qobj. unit(norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Operator or state normalized to unity.; Uses norm from Qobj.norm(). Parameters:; norm (str) – Requested norm for states / operators.; sparse (bool) – Use sparse eigensolver for trace norm. Does not affect other norms.; tol (float) – Tolerance used by sparse eigensolver.; maxiter (int) – Number of maximum iterations performed by sparse eigensolver. Returns:oper – Normalized quantum object. Return type:qobj. eseries¶. class eseries(q=array([], dtype=object), s=array([], dtype=float64))[source]¶; Class representation of an exponential-series expansion of; time-dependent quantum objects. ampl¶; ndarray – Array of amplitudes for exponential series. rates¶; ndarray – Array of rates for exponential series. dims¶; list – Dimensions of exponential series components. shape¶; list – Shape corresponding to exponential series components. value(tlist)¶; Evaluate an exponential series at the times listed in tlist. spec(wlist)¶; Evaluate the spectrum of an exponential series at frequencies in wlist. tidyup()¶; Returns a tidier version of the exponential series. spec(wlist)[source]¶; Evaluate the spectrum of an exponential series at frequencies; in wlist. Parameters:wlist (array_like) – Array/list of frequenies. Returns:val_list – Values of exponential series at frequencies in wlist. Return type:ndarray. t",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:26618,Performance,perform,performance,26618,"play the Bloch sphere and corresponding data sets. non-Markovian Solvers¶. class HEOMSolver[source]¶; This is superclass for all solvers that use the HEOM method for; calculating the dynamics evolution. There are many references for this.; A good introduction, and perhaps closest to the notation used here is:; DOI:10.1103/PhysRevLett.104.250401; A more canonical reference, with full derivation is:; DOI: 10.1103/PhysRevA.41.6676; The method can compute open system dynamics without using any Markovian; or rotating wave approximation (RWA) for systems where the bath; correlations can be approximated to a sum of complex eponentials.; The method builds a matrix of linked differential equations, which are; then solved used the same ODE solvers as other qutip solvers (e.g. mesolve); This class should be treated as abstract. Currently the only subclass; implemented is that for the Drude-Lorentz spectral density. This covers; the majority of the work that has been done using this model, and there; are some performance advantages to assuming this model where it is; appropriate.; There are opportunities to develop a more general spectral density code. H_sys¶; Qobj – System Hamiltonian. coup_op¶; Qobj – Operator describing the coupling between system and bath. coup_strength¶; float – Coupling strength. temperature¶; float – Bath temperature, in units corresponding to planck. N_cut¶; int – Cutoff parameter for the bath. N_exp¶; int – Number of exponential terms used to approximate the bath correlation; functions. planck¶; float – reduced Planck constant. boltzmann¶; float – Boltzmann’s constant. options¶; qutip.solver.Options – Generic solver options.; If set to None the default options will be used. progress_bar¶; BaseProgressBar – Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. stats¶; qutip.solver.Stats – optional container for holding performance statitics; If None is set, then statistics are not collected; There may b",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:27521,Performance,perform,performance,27521,"at has been done using this model, and there; are some performance advantages to assuming this model where it is; appropriate.; There are opportunities to develop a more general spectral density code. H_sys¶; Qobj – System Hamiltonian. coup_op¶; Qobj – Operator describing the coupling between system and bath. coup_strength¶; float – Coupling strength. temperature¶; float – Bath temperature, in units corresponding to planck. N_cut¶; int – Cutoff parameter for the bath. N_exp¶; int – Number of exponential terms used to approximate the bath correlation; functions. planck¶; float – reduced Planck constant. boltzmann¶; float – Boltzmann’s constant. options¶; qutip.solver.Options – Generic solver options.; If set to None the default options will be used. progress_bar¶; BaseProgressBar – Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. stats¶; qutip.solver.Stats – optional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coeff¶; list of complex – Coefficients for the exponential series terms. exp_freq¶; list of complex – Frequencies for the exponential series terms. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters:; options (qutip.solver.Options) – Generic solver options.; If set to None the default options will be used; progress_bar (BaseProgressBar) – Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar; stats (qutip.solver.Stats) – Optional instance of solver.Stats, or a subclass th",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:28584,Performance,perform,performance,28584,"ting statistics. exp_coeff¶; list of complex – Coefficients for the exponential series terms. exp_freq¶; list of complex – Frequencies for the exponential series terms. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters:; options (qutip.solver.Options) – Generic solver options.; If set to None the default options will be used; progress_bar (BaseProgressBar) – Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar; stats (qutip.solver.Stats) – Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). cut_freq¶; float – Bath spectral density cutoff frequency. renorm¶; bool",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:33801,Performance,perform,performed,33801,", notrace=False)[source]¶; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters:; blist (array_like) – List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger; tlist (array_like) – list of corresponding times t1,..,tn at which to evaluate the field; operators; tau (float) – time-delay; c1 (qutip.Qobj) – system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element); c2 (qutip.Qobj) – system collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element); notrace (bool {False}) – If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns:time-propagator for computing field correlation function. Return type:qutip.Qobj. propagator(t, tau, notrace=False)[source]¶; Compute propagator for time t and time-delay tau. Parameters:; t (float) – current time; tau (float) – time-delay; notrace (bool {False}) – If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns:time-propagator for reduced system dynamics. Return type:qutip.Qobj. rhot(rho0, t, tau)[source]¶; Compute the reduced system density matrix \(\rho(t)\). Parameters:; rho0 (qutip.Qobj) – initial density matrix or state vector (ket); t (float) – current time; tau (float) – time-delay. Returns:density matrix at time \(t\). Return type:qutip.Qobj. class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:34315,Performance,perform,performed,34315," operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element); c2 (qutip.Qobj) – system collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element); notrace (bool {False}) – If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns:time-propagator for computing field correlation function. Return type:qutip.Qobj. propagator(t, tau, notrace=False)[source]¶; Compute propagator for time t and time-delay tau. Parameters:; t (float) – current time; tau (float) – time-delay; notrace (bool {False}) – If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns:time-propagator for reduced system dynamics. Return type:qutip.Qobj. rhot(rho0, t, tau)[source]¶; Compute the reduced system density matrix \(\rho(t)\). Parameters:; rho0 (qutip.Qobj) – initial density matrix or state vector (ket); t (float) – current time; tau (float) – time-delay. Returns:density matrix at time \(t\). Return type:qutip.Qobj. class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]¶; Class of options for the Transfer Tensor Method solver. dynmaps¶; list of qutip.Qobj – List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. times¶; array_like – List of times \(t_n\) at which to calculate \(\rho(t_n)\). learningtimes¶; array_like – List of times \(t_k\) to use as learning times if argument; dynmaps is a callback function. thres¶; float – Threshold for halting. Halts if \(||T_{n}-T_{n-1}||\) i",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:39043,Performance,perform,performance,39043,"ct. class Result[source]¶; Class for storing simulation results from any of the dynamics solvers. solver¶; str – Which solver was used [e.g., ‘mesolve’, ‘mcsolve’, ‘brmesolve’, ...]. times¶; list/array – Times at which simulation data was collected. expect¶; list/array – Expectation values (if requested) for simulation. states¶; array – State of the simulation (density matrix or ket) evaluated at times. num_expect¶; int – Number of expectation value operators in simulation. num_collapse¶; int – Number of collapse operators in simualation. ntraj¶; int/list – Number of trajectories (for stochastic solvers). A list indicates; that averaging of expectation values was done over a subset of total; number of trajectories. col_times¶; list – Times at which state collpase occurred. Only for Monte Carlo solver. col_which¶; list – Which collapse operator was responsible for each collapse in; col_times. Only for Monte Carlo solver. class Stats(section_names=None)[source]¶; Statistical information on the solver performance; Statistics can be grouped into sections.; If no section names are given in the the contructor, then all statistics; will be added to one section ‘main’. Parameters:section_names (list) – list of keys that will be used as keys for the sections; These keys will also be used as names for the sections; The text in the output can be overidden by setting the header property; of the section; If no names are given then one section called ‘main’ is created. sections¶; OrderedDict of _StatsSection – These are the sections that are created automatically on instantiation; or added using add_section. header¶; string – Some text that will be used as the heading in the report; By default there is None. total_time¶; float – Time in seconds for the solver to complete processing; Can be None, meaning that total timing percentages will be reported. add_section()¶; Add another section. add_count()¶; Add some stat that is an integer count. add_timing()¶; Add some timing statistic",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:60544,Performance,optimiz,optimize,60544,"dynamics of the (quantum) system. to be control optimised. log_level¶; integer – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params¶; Dictionary – The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg¶; string – Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params¶; Dictionary – options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg¶; bool – Set true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_method¶; string – a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_params¶; Dictionary – Options for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_grad¶; bool – If set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound¶; float or list of floats – lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound¶; float or list of floats – upper boundaries for the control amplitudes; Can be a scalar value",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:60611,Performance,optimiz,optimize,60611,"l¶; integer – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params¶; Dictionary – The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg¶; string – Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params¶; Dictionary – options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg¶; bool – Set true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_method¶; string – a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_params¶; Dictionary – Options for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_grad¶; bool – If set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound¶; float or list of floats – lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound¶; float or list of floats – upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bou",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:62485,Performance,perform,performance,62485,"ntrol amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds¶; List of floats – Bounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamics¶; Dynamics (subclass instance) – describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). config¶; OptimConfig instance – various configuration options; (see OptimConfig for details). termination_conditions¶; TerminationCondition instance – attributes determine when the optimisation will end. pulse_generator¶; PulseGen (subclass instance) – (can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. stats¶; Stats – attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dump¶; dump.OptimDump – Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping¶; string – level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file¶; bool – If set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dir¶; string – Basically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summary¶; OptimIterSummary – Summary of the most recent iteration.; Note this is on",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:63856,Performance,optimiz,optimize,63856," status information during a long optimisation. dumping¶; string – level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file¶; bool – If set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dir¶; string – Basically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summary¶; OptimIterSummary – Summary of the most recent iteration.; Note this is only set if dummping is on. apply_method_params(params=None)[source]¶; Loops through all the method_params; (either passed here or the method_params attribute); If the name matches an attribute of this object or the; termination conditions object, then the value of this attribute; is set. Otherwise it is assumed to a method_option for the; scipy.optimize.minimize function. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. dumping¶. The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; varia",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:66404,Performance,optimiz,optimize,66404,"t the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(term_conds=None)[source]¶; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason fo",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:67948,Performance,optimiz,optimize,67948,"een tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. max_metric_corr¶; integer – The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise t",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:68611,Performance,optimiz,optimize,68611,"ulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. max_metric_corr¶; integer – The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and detail",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:69398,Performance,optimiz,optimize,69398,"; integer – The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:70044,Performance,optimiz,optimize,70044," is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimizati",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:70651,Performance,optimiz,optimize,70651,"term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:71140,Performance,optimiz,optimize,71140,"un_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimIterSummary[source]¶; A summary of the most recent iteration of the pulse optimisation. iter_num¶; int – Iteration number of the pulse optimisation. fid_func_call_num¶; int – Fidel",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:73474,Performance,optimiz,optimize,73474," pulse optimisation so far; (in seconds of elapsed time). class TerminationConditions[source]¶; Base class for all termination conditions; Used to determine when to stop the optimisation algorithm; Note different subclasses should be used to match the type of; optimisation being used. fid_err_targ¶; float – Target fidelity error. fid_goal¶; float – goal fidelity, e.g. 1 - self.fid_err_targ; It its typical to set this for unitary systems. max_wall_time¶; float – # maximum time for optimisation (seconds). min_gradient_norm¶; float – Minimum normalised gradient after which optimisation will terminate. max_iterations¶; integer – Maximum iterations of the optimisation algorithm. max_fid_func_calls¶; integer – Maximum number of calls to the fidelity function during; the optimisation algorithm. accuracy_factor¶; float – Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user. class OptimResult[source]¶; Attributes give the result of the pulse optimisation attempt. termination_reason¶; string – Description of the reason for terminating the optimisation. fidelity¶; float – final (normalised) fidelity that was achieved. initial_fid_err¶; float – fidelity error before optimisation starting. fid_err¶; float – final fidelity error that was achieved. goal_achieved¶; boolean – True is the fidely error achieved was below the target. grad_norm_final¶; float – Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached¶; float – True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter¶; integer – Number of iterations of the optimisati",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:75271,Performance,optimiz,optimizer,75271,"reached¶; float – True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter¶; integer – Number of iterations of the optimisation algorithm completed. max_iter_exceeded¶; boolean – True if the iteration limit was reached. max_fid_func_exceeded¶; boolean – True if the fidelity function call limit was reached. wall_time¶; float – time elapsed during the optimisation. wall_time_limit_exceeded¶; boolean – True if the wall time limit was reached. time¶; array[num_tslots+1] of float – Time are the start of each timeslot; with the final value being the total evolution time. initial_amps¶; array[num_tslots, n_ctrls] – The amplitudes at the start of the optimisation. final_amps¶; array[num_tslots, n_ctrls] – The amplitudes at the end of the optimisation. evo_full_final¶; Qobj – The evolution operator from t=0 to t=T based on the final amps. stats¶; Stats – Object contaning the stats for the run (if any collected). optimizer¶; Optimizer – Instance of the Optimizer used to generate the result. class Dynamics(optimconfig, params=None)[source]¶; This is a base class only. See subclass descriptions and choose an; appropriate one for the application.; Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes; This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. log_level¶; integer – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, ",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:76058,Performance,perform,performance,76058,"[num_tslots, n_ctrls] – The amplitudes at the end of the optimisation. evo_full_final¶; Qobj – The evolution operator from t=0 to t=T based on the final amps. stats¶; Stats – Object contaning the stats for the run (if any collected). optimizer¶; Optimizer – Instance of the Optimizer used to generate the result. class Dynamics(optimconfig, params=None)[source]¶; This is a base class only. See subclass descriptions and choose an; appropriate one for the application.; Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes; This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. log_level¶; integer – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params¶; Dictionary – The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats¶; Stats – Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer¶; TimeslotComputer (subclass instance) – Used to manage when the timeslot dynamics; generator",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:76780,Performance,perform,performance,76780,"t is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. log_level¶; integer – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params¶; Dictionary – The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats¶; Stats – Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer¶; TimeslotComputer (subclass instance) – Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer¶; PropagatorComputer (subclass instance) – Used to compute the propagators and their gradients. fid_computer¶; FidelityComputer (subclass instance) – Used to computer the fidelity error and the fidelity error; gradient. memory_optimization¶; int – Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more infor",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:78135,Performance,perform,performs,78135,"pute the propagators and their gradients. fid_computer¶; FidelityComputer (subclass instance) – Used to computer the fidelity error and the fidelity error; gradient. memory_optimization¶; int – Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype¶; type – Data type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_gen¶; bool – If True then the dynamics generators will be saved with and; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False. cache_prop_grad¶; bool – If the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj¶; bool – If True then DynamicsUnitary will cached the adjoint of; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp¶; bool – If",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:78188,Performance,perform,perform,78188," computer the fidelity error and the fidelity error; gradient. memory_optimization¶; int – Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype¶; type – Data type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_gen¶; bool – If True then the dynamics generators will be saved with and; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False. cache_prop_grad¶; bool – If the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj¶; bool – If True then DynamicsUnitary will cached the adjoint of; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp¶; bool – If True then DynamicsUnitary will use the sparse eigenvalue; decomposition.; Defaults to True when memor",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:78238,Performance,perform,perform,78238," computer the fidelity error and the fidelity error; gradient. memory_optimization¶; int – Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype¶; type – Data type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_gen¶; bool – If True then the dynamics generators will be saved with and; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False. cache_prop_grad¶; bool – If the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj¶; bool – If True then DynamicsUnitary will cached the adjoint of; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp¶; bool – If True then DynamicsUnitary will use the sparse eigenvalue; decomposition.; Defaults to True when memor",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:78743,Performance,cache,cache,78743,"h; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype¶; type – Data type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_gen¶; bool – If True then the dynamics generators will be saved with and; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False. cache_prop_grad¶; bool – If the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj¶; bool – If True then DynamicsUnitary will cached the adjoint of; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp¶; bool – If True then DynamicsUnitary will use the sparse eigenvalue; decomposition.; Defaults to True when memory_optimization<=1, otherwise False. num_tslots¶; integer – Number of timeslots (aka timeslices). num_ctrls¶; integer – Number of controls.; Note this is calculated as the length of ctrl_dyn_gen when first used.; And is recalculated during initialise_controls only. evo_time¶; float – Total time for the evolution. tau¶; array[num_tslots] of float – Duration of each timeslot; Note that if this is set before initialize_controls is called; then n",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:79000,Performance,cache,cached,79000,"ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_gen¶; bool – If True then the dynamics generators will be saved with and; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False. cache_prop_grad¶; bool – If the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj¶; bool – If True then DynamicsUnitary will cached the adjoint of; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp¶; bool – If True then DynamicsUnitary will use the sparse eigenvalue; decomposition.; Defaults to True when memory_optimization<=1, otherwise False. num_tslots¶; integer – Number of timeslots (aka timeslices). num_ctrls¶; integer – Number of controls.; Note this is calculated as the length of ctrl_dyn_gen when first used.; And is recalculated during initialise_controls only. evo_time¶; float – Total time for the evolution. tau¶; array[num_tslots] of float – Duration of each timeslot; Note that if this is set before initialize_controls is called; then num_tslots and evo_time are calculated from tau, otherwise; tau is generated from num_tslots and evo_time, that is; equal size time slices. time¶; array[num_tslots+1] of float – Cumulative time for the evolution, that is the time at the start; of each time slice. drift_dyn_gen¶; Qobj or list of Qobj – Drift or system dynamic",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:95825,Performance,cache,cached,95825," calculations were taken from DYNAMO; (see file header). phase_option¶; string –. determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm¶; complex – Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current¶; boolean – flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either ",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:96268,Performance,cache,cached,96268,"ify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(A)[source]¶. normalize_SU(A)[source]¶. normalize_gradient_PSU(grad)[source]¶; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(grad)[source]¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. set_phase_option(phase_option=None",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:98679,Performance,cache,cached,98679,"a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. scale_factor¶; float – The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. epsilon¶; float – control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. class TimeslotComputer(dynamics, params=None)[source]¶; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. log_level¶; i",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:116629,Performance,optimiz,optimizer,116629,"erridden in the subclass. dump_summary¶; bool – If True a summary is recorded each time a new item is added to the; the dump.; Default is True. summary_sep¶; str – delimiter for the summary file.; default is a space. data_sep¶; str – delimiter for the data files (arrays saved to file).; default is a space. summary_file¶; str – File path for summary file.; Automatically generated. Can be set specifically. create_dump_dir()[source]¶; Checks dump directory exists, creates it if not. level¶. The level of data dumping that will occur. SUMMARY : A summary will be recorded; FULL : All possible dumping; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specifically is dumped. class OptimDump(optim, level='SUMMARY')[source]¶; A container for dumps of optimisation data generated during the pulse; optimisation. dump_summary¶; bool – When True summary items are appended to the iter_summary. iter_summary¶; list of optimizer.OptimIterSummary – Summary at each iteration. dump_fid_err¶; bool – When True values are appended to the fid_err_log. fid_err_log¶; list of float – Fidelity error at each call of the fid_err_func. dump_grad_norm¶; bool – When True values are appended to the fid_err_log. grad_norm_log¶; list of float – Gradient norm at each call of the grad_norm_log. dump_grad¶; bool – When True values are appended to the grad_log. grad_log¶; list of ndarray – Gradients at each call of the fid_grad_func. add_iter_summary()[source]¶; add copy of current optimizer iteration summary. dump_all¶; True if everything (ignoring the summary) is to be dumped. dump_any¶; True if anything other than the summary is to be dumped. update_fid_err_log(fid_err)[source]¶; add an entry to the fid_err log. update_grad_log(grad)[source]¶; add an entry to the grad log. update_grad_norm_log(grad_norm)[source]¶; add an entry to the grad_norm log. writeout(f=None)[source]¶; write all the logs and the summary out",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:117180,Performance,optimiz,optimizer,117180," summary will be recorded; FULL : All possible dumping; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specifically is dumped. class OptimDump(optim, level='SUMMARY')[source]¶; A container for dumps of optimisation data generated during the pulse; optimisation. dump_summary¶; bool – When True summary items are appended to the iter_summary. iter_summary¶; list of optimizer.OptimIterSummary – Summary at each iteration. dump_fid_err¶; bool – When True values are appended to the fid_err_log. fid_err_log¶; list of float – Fidelity error at each call of the fid_err_func. dump_grad_norm¶; bool – When True values are appended to the fid_err_log. grad_norm_log¶; list of float – Gradient norm at each call of the grad_norm_log. dump_grad¶; bool – When True values are appended to the grad_log. grad_log¶; list of ndarray – Gradients at each call of the fid_grad_func. add_iter_summary()[source]¶; add copy of current optimizer iteration summary. dump_all¶; True if everything (ignoring the summary) is to be dumped. dump_any¶; True if anything other than the summary is to be dumped. update_fid_err_log(fid_err)[source]¶; add an entry to the fid_err log. update_grad_log(grad)[source]¶; add an entry to the grad log. update_grad_norm_log(grad_norm)[source]¶; add an entry to the grad_norm log. writeout(f=None)[source]¶; write all the logs and the summary out to file(s). Parameters:f (filename or filehandle) – If specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this. class DynamicsDump(dynamics, level='SUMMARY')[source]¶; A container for dumps of dynamics data.; Mainly time evolution calculations. dump_summary¶; bool – If True a summary is recorded. evo_summary¶; list of :class:`tslotcomp.EvoCompSum",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:10024,Safety,safe,safe,10024,", method=’dense’; is set as default.s. Returns:oper – Exponentiated quantum operator. Return type:qobj. Raises:TypeError – Quantum operator is not square. extract_states(states_inds, normalize=False)[source]¶; Qobj with states in state_inds only. Parameters:; states_inds (list of integer) – The states that should be kept.; normalize (True / False) – Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q – A new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Return type:Qobj. Notes; Experimental. full(squeeze=False)[source]¶; Dense array from quantum object. Returns:data – Array of complex data from quantum objects data attribute. Return type:array. groundstate(sparse=False, tol=0, maxiter=100000, safe=True)[source]¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters:; sparse (bool) – Use sparse Eigensolver; tol (float) – Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter (int) – Maximum number of iterations performed by sparse solver (if used).; safe (bool (default=True)) – Check for degenerate ground state. Returns:; eigval (float) – Eigenvalue for the ground state of quantum operator.; eigvec (qobj) – Eigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. matrix_element(bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters:; bra (qobj) – Quantum object of type ‘bra’.; ket (qobj) – Quantum object of type ‘ket’. Returns:elem – Comp",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:10424,Safety,safe,safe,10424,"lse). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q – A new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Return type:Qobj. Notes; Experimental. full(squeeze=False)[source]¶; Dense array from quantum object. Returns:data – Array of complex data from quantum objects data attribute. Return type:array. groundstate(sparse=False, tol=0, maxiter=100000, safe=True)[source]¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters:; sparse (bool) – Use sparse Eigensolver; tol (float) – Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter (int) – Maximum number of iterations performed by sparse solver (if used).; safe (bool (default=True)) – Check for degenerate ground state. Returns:; eigval (float) – Eigenvalue for the ground state of quantum operator.; eigvec (qobj) – Eigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. matrix_element(bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters:; bra (qobj) – Quantum object of type ‘bra’.; ket (qobj) – Quantum object of type ‘ket’. Returns:elem – Complex valued matrix element. Return type:complex. Raises:TypeError – Can only calculate matrix elements between a bra and ket; quantum object. norm(norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Parameters:; norm (str) – Which norm to use for ket/br",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:46790,Safety,predict,predictor-corrector,46790," Array of length d2_len, containing scaling factors for each; measurement operator in m_ops. rhs¶; function – Function for calculating the deterministic and stochastic contributions; to the right-hand side of the stochastic differential equation. This; only needs to be specified when implementing a custom SDE solver. generate_A_ops¶; function – Function that generates a list of pre-computed operators or super-; operators. These precomputed operators are used in some d1 and d2; functions. generate_noise¶; function – Function for generate an array of pre-computed noise signal. homogeneous¶; bool (True) – Wheter or not the stochastic process is homogenous. Inhomogenous; processes are only supported for poisson distributions. solver¶; string – Name of the solver method to use for solving the stochastic; equations. Valid values are:; 1/2 order algorithms: ‘euler-maruyama’, ‘fast-euler-maruyama’,; ‘pc-euler’ is a predictor-corrector method which is more; stable than explicit methods,; 1 order algorithms: ‘milstein’, ‘fast-milstein’, ‘platen’,; ‘milstein-imp’ is semi-implicit Milstein method,; 3/2 order algorithms: ‘taylor15’,; ‘taylor15-imp’ is semi-implicit Taylor 1.5 method.; Implicit methods can adjust tolerance via args = {‘tol’:value},; default is {‘tol’:1e-6}. method¶; string (‘homodyne’, ‘heterodyne’, ‘photocurrent’) – The name of the type of measurement process that give rise to the; stochastic equation to solve. Specifying a method with this keyword; argument is a short-hand notation for using pre-defined d1 and d2; functions for the corresponding stochastic processes. distribution¶; string (‘normal’, ‘poission’) – The name of the distribution used for the stochastic increments. store_measurements¶; bool (default False) – Whether or not to store the measurement results in the; qutip.solver.SolverResult instance returned by the solver. noise¶; array – Vector specifying the noise. normalize¶; bool (default True) – Whether or not to normalize the wave function during",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:75653,Security,access,access,75653,"uring the optimisation. wall_time_limit_exceeded¶; boolean – True if the wall time limit was reached. time¶; array[num_tslots+1] of float – Time are the start of each timeslot; with the final value being the total evolution time. initial_amps¶; array[num_tslots, n_ctrls] – The amplitudes at the start of the optimisation. final_amps¶; array[num_tslots, n_ctrls] – The amplitudes at the end of the optimisation. evo_full_final¶; Qobj – The evolution operator from t=0 to t=T based on the final amps. stats¶; Stats – Object contaning the stats for the run (if any collected). optimizer¶; Optimizer – Instance of the Optimizer used to generate the result. class Dynamics(optimconfig, params=None)[source]¶; This is a base class only. See subclass descriptions and choose an; appropriate one for the application.; Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes; This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. log_level¶; integer – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params¶; Dictionary – The key value pairs are the attribute name and value; Note: attributes are created if they do not exist ",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:59664,Testability,log,logger,59664," the physical implementation of a quantum; program/algorithm on a dispersive cavity-QED system. dispersive_gate_correction(qc1, rwa=True)[source]¶; Method to resolve ISWAP and SQRTISWAP gates in a cQED system by adding; single qubit gates to get the correct output matrix. Parameters:; qc (Qobj) – The circular spin chain circuit to be resolved; rwa (Boolean) – Specify if RWA is used or not. Returns:qc – Returns QubitCircuit of resolved gates for the qubit circuit in the; desired basis. Return type:QubitCircuit. Optimal control¶. class Optimizer(config, dyn, params=None)[source]¶; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a. OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system. to be control optimised. log_level¶; integer – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params¶; Dictionary – The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg¶; string – Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params¶; Dictionary – options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg¶; bool – Set true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_method¶; string – a scipy.optimize.minimize method tha",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:64421,Testability,log,logs,64421,"en setting a path. iter_summary¶; OptimIterSummary – Summary of the most recent iteration.; Note this is only set if dummping is on. apply_method_params(params=None)[source]¶; Loops through all the method_params; (either passed here or the method_params attribute); If the name matches an attribute of this object or the; termination conditions object, then the value of this attribute; is set. Otherwise it is assumed to a method_option for the; scipy.optimize.minimize function. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. dumping¶. The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimise",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:64599,Testability,log,logs,64599," through all the method_params; (either passed here or the method_params attribute); If the name matches an attribute of this object or the; termination conditions object, then the value of this attribute; is set. Otherwise it is assumed to a method_option for the; scipy.optimize.minimize function. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. dumping¶. The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:66956,Testability,test,tested,66956,"ource]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(term_conds=None)[source]¶; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to t",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:76197,Testability,log,logger,76197,"based on the final amps. stats¶; Stats – Object contaning the stats for the run (if any collected). optimizer¶; Optimizer – Instance of the Optimizer used to generate the result. class Dynamics(optimconfig, params=None)[source]¶; This is a base class only. See subclass descriptions and choose an; appropriate one for the application.; Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes; This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. log_level¶; integer – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params¶; Dictionary – The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats¶; Stats – Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer¶; TimeslotComputer (subclass instance) – Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer¶; PropagatorComputer (subclass instance) – Used to compute the propagators and",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:87461,Testability,log,logged,87461,"ls¶; calculate the of controls from the length of the control list; sets the num_ctrls property, which can be used alternatively; subsequently. onto_evo¶; List of evolution operators (Qobj) from the initial to the given; timeslot. onwd_evo¶; List of evolution operators (Qobj) from the initial to the given; timeslot. prop¶; List of propagators (Qobj) for each timeslot. prop_grad¶; Array of propagator gradients (Qobj) for each timeslot, control. refresh_drift_attribs()[source]¶; Reset the dyn_shape, dyn_dims and time_depend_drift attribs. save_amps(file_name=None, times=None, amps=None, verbose=False)[source]¶; Save a file with the current control amplitudes in each timeslot; The first column in the file will be the start time of the slot. Parameters:; file_name (string) – Name of the file; If None given the def_amps_fname attribuite will be used; times (List type (or string)) – List / array of the start times for each slot; If None given this will be retrieved through get_amp_times(); If ‘exclude’ then times will not be saved in the file, just; the amplitudes; amps (Array[num_tslots, num_ctrls]) – Amplitudes to be saved; If None given the ctrl_amps attribute will be used; verbose (Boolean) – If True then an info message will be logged. unitarity_check()[source]¶; Checks whether all propagators are unitary. update_ctrl_amps(new_amps)[source]¶; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer. class DynamicsGenMat(optimconfig, params=None)[source]¶; This sub class can be used for any system where no additional; operator is applied to the dynamics generator before calculating; the propagator, e.g. classical dynamics, Lindbladian. class DynamicsUnitary(optimconfig, params=None)[source]¶; This is the subclass to use for systems with dynamics described by; unitary matrices. E.g. closed systems with Hermitian Hamiltonians; Note a matrix diagona",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:89976,Testability,log,logger,89976,"itary, the potential underlying; causes are investigated. class DynamicsSymplectic(optimconfig, params=None)[source]¶; Symplectic systems; This is the subclass to use for systems where the dynamics is described; by symplectic matrices, e.g. coupled oscillators, quantum optics. omega¶; array[drift_dyn_gen.shape] – matrix used in the calculation of propagators (time evolution); with symplectic systems. dyn_gen_phase¶; The prephasing operator for the symplectic group generators; usually refered to as Omega. class PropagatorComputer(dynamics, params=None)[source]¶; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. log_level¶; integer – level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exact¶; boolean – indicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompA",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:90023,Testability,log,logging,90023,"where the dynamics is described; by symplectic matrices, e.g. coupled oscillators, quantum optics. omega¶; array[drift_dyn_gen.shape] – matrix used in the calculation of propagators (time evolution); with symplectic systems. dyn_gen_phase¶; The prephasing operator for the symplectic group generators; usually refered to as Omega. class PropagatorComputer(dynamics, params=None)[source]¶; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. log_level¶; integer – level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exact¶; boolean – indicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calc",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:92102,Testability,log,logger,92102," dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]¶. Frechet method for calculating the propagator:; exponentiating the combined dynamics generator. and the propagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient. class FidelityComputer(dynamics, params=None)[source]¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. log_level¶; integer – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_norm¶; float – Normalisation constant. fid_norm_func¶; function – Used to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_func¶; function – Used to normalise the fidelity gradient; See SU and PSU options for the unitary dynamics. uses_onwd_evo¶; boolean – flag to specify whether the onwd_evo evolution operator; (see Dynamics) is used by the FidelityComputer. uses_onto_evo¶; boolean –. flag to specify whether the onto_evo evolution operator; (see Dynamics) is used by the FidelityComputer. fid_err¶; float – Last computed value of the fidelity error. ",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:99714,Testability,log,logger,99714," case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. epsilon¶; float – control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. class TimeslotComputer(dynamics, params=None)[source]¶; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. log_level¶; integer – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. evo_comp_summary¶; EvoCompSummary – A summary of the most recent evolution computation; Used in the stats and dump; Will be set to None if neither stats or dump are set. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. dump_current()[source]¶; Store a copy of the current time evolution. class TSlotCo",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:103058,Testability,log,logger,103058," applied to the pulse; (copied from Dynamics.initial_ctrl_scaling if given). offset¶; float – linear offset applied to the pulse; (copied from Dynamics.initial_ctrl_offset if given). tau¶; array[num_tslots] of float – Duration of each timeslot; (copied from Dynamics if given). lbound¶; float – Lower boundary for the pulse amplitudes; Note that the scaling and offset attributes can be used to fully; bound the pulse for all generators except some of the random ones; This bound (if set) may result in additional shifting / scaling; Default is -Inf. ubound¶; float – Upper boundary for the pulse amplitudes; Note that the scaling and offset attributes can be used to fully; bound the pulse for all generators except some of the random ones; This bound (if set) may result in additional shifting / scaling; Default is Inf. periodic¶; boolean – True if the pulse generator produces periodic pulses. random¶; boolean – True if the pulse generator produces random pulses. log_level¶; integer – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value. gen_pulse()[source]¶; returns the pulse as an array of vales for each timeslot; Must be implemented by subclass. init_pulse()[source]¶; Initialise the pulse parameters. reset()[source]¶; reset attributes to default values. class PulseGenRandom(dyn=None, params=None)[source]¶; Generates random pulses as simply random values for each timeslot. ",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:117413,Testability,log,log,117413,"s dumped. class OptimDump(optim, level='SUMMARY')[source]¶; A container for dumps of optimisation data generated during the pulse; optimisation. dump_summary¶; bool – When True summary items are appended to the iter_summary. iter_summary¶; list of optimizer.OptimIterSummary – Summary at each iteration. dump_fid_err¶; bool – When True values are appended to the fid_err_log. fid_err_log¶; list of float – Fidelity error at each call of the fid_err_func. dump_grad_norm¶; bool – When True values are appended to the fid_err_log. grad_norm_log¶; list of float – Gradient norm at each call of the grad_norm_log. dump_grad¶; bool – When True values are appended to the grad_log. grad_log¶; list of ndarray – Gradients at each call of the fid_grad_func. add_iter_summary()[source]¶; add copy of current optimizer iteration summary. dump_all¶; True if everything (ignoring the summary) is to be dumped. dump_any¶; True if anything other than the summary is to be dumped. update_fid_err_log(fid_err)[source]¶; add an entry to the fid_err log. update_grad_log(grad)[source]¶; add an entry to the grad log. update_grad_norm_log(grad_norm)[source]¶; add an entry to the grad_norm log. writeout(f=None)[source]¶; write all the logs and the summary out to file(s). Parameters:f (filename or filehandle) – If specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this. class DynamicsDump(dynamics, level='SUMMARY')[source]¶; A container for dumps of dynamics data.; Mainly time evolution calculations. dump_summary¶; bool – If True a summary is recorded. evo_summary¶; list of :class:`tslotcomp.EvoCompSummary’ – Summary items are appended if dump_summary is True; at each recomputation of the evolution. dump_amps¶; bool – If True control amplitudes are dumped. dump_dyn_gen¶; bool – If True the dynamics generators (",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:117475,Testability,log,log,117475,"iner for dumps of optimisation data generated during the pulse; optimisation. dump_summary¶; bool – When True summary items are appended to the iter_summary. iter_summary¶; list of optimizer.OptimIterSummary – Summary at each iteration. dump_fid_err¶; bool – When True values are appended to the fid_err_log. fid_err_log¶; list of float – Fidelity error at each call of the fid_err_func. dump_grad_norm¶; bool – When True values are appended to the fid_err_log. grad_norm_log¶; list of float – Gradient norm at each call of the grad_norm_log. dump_grad¶; bool – When True values are appended to the grad_log. grad_log¶; list of ndarray – Gradients at each call of the fid_grad_func. add_iter_summary()[source]¶; add copy of current optimizer iteration summary. dump_all¶; True if everything (ignoring the summary) is to be dumped. dump_any¶; True if anything other than the summary is to be dumped. update_fid_err_log(fid_err)[source]¶; add an entry to the fid_err log. update_grad_log(grad)[source]¶; add an entry to the grad log. update_grad_norm_log(grad_norm)[source]¶; add an entry to the grad_norm log. writeout(f=None)[source]¶; write all the logs and the summary out to file(s). Parameters:f (filename or filehandle) – If specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this. class DynamicsDump(dynamics, level='SUMMARY')[source]¶; A container for dumps of dynamics data.; Mainly time evolution calculations. dump_summary¶; bool – If True a summary is recorded. evo_summary¶; list of :class:`tslotcomp.EvoCompSummary’ – Summary items are appended if dump_summary is True; at each recomputation of the evolution. dump_amps¶; bool – If True control amplitudes are dumped. dump_dyn_gen¶; bool – If True the dynamics generators (Hamiltonians) are dumped. dump_prop¶; bool – If True propagators a",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:117552,Testability,log,log,117552,"isation. dump_summary¶; bool – When True summary items are appended to the iter_summary. iter_summary¶; list of optimizer.OptimIterSummary – Summary at each iteration. dump_fid_err¶; bool – When True values are appended to the fid_err_log. fid_err_log¶; list of float – Fidelity error at each call of the fid_err_func. dump_grad_norm¶; bool – When True values are appended to the fid_err_log. grad_norm_log¶; list of float – Gradient norm at each call of the grad_norm_log. dump_grad¶; bool – When True values are appended to the grad_log. grad_log¶; list of ndarray – Gradients at each call of the fid_grad_func. add_iter_summary()[source]¶; add copy of current optimizer iteration summary. dump_all¶; True if everything (ignoring the summary) is to be dumped. dump_any¶; True if anything other than the summary is to be dumped. update_fid_err_log(fid_err)[source]¶; add an entry to the fid_err log. update_grad_log(grad)[source]¶; add an entry to the grad log. update_grad_norm_log(grad_norm)[source]¶; add an entry to the grad_norm log. writeout(f=None)[source]¶; write all the logs and the summary out to file(s). Parameters:f (filename or filehandle) – If specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this. class DynamicsDump(dynamics, level='SUMMARY')[source]¶; A container for dumps of dynamics data.; Mainly time evolution calculations. dump_summary¶; bool – If True a summary is recorded. evo_summary¶; list of :class:`tslotcomp.EvoCompSummary’ – Summary items are appended if dump_summary is True; at each recomputation of the evolution. dump_amps¶; bool – If True control amplitudes are dumped. dump_dyn_gen¶; bool – If True the dynamics generators (Hamiltonians) are dumped. dump_prop¶; bool – If True propagators are dumped. dump_prop_grad¶; bool – If True propagator gradients are du",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:117598,Testability,log,logs,117598,"r_summary. iter_summary¶; list of optimizer.OptimIterSummary – Summary at each iteration. dump_fid_err¶; bool – When True values are appended to the fid_err_log. fid_err_log¶; list of float – Fidelity error at each call of the fid_err_func. dump_grad_norm¶; bool – When True values are appended to the fid_err_log. grad_norm_log¶; list of float – Gradient norm at each call of the grad_norm_log. dump_grad¶; bool – When True values are appended to the grad_log. grad_log¶; list of ndarray – Gradients at each call of the fid_grad_func. add_iter_summary()[source]¶; add copy of current optimizer iteration summary. dump_all¶; True if everything (ignoring the summary) is to be dumped. dump_any¶; True if anything other than the summary is to be dumped. update_fid_err_log(fid_err)[source]¶; add an entry to the fid_err log. update_grad_log(grad)[source]¶; add an entry to the grad log. update_grad_norm_log(grad_norm)[source]¶; add an entry to the grad_norm log. writeout(f=None)[source]¶; write all the logs and the summary out to file(s). Parameters:f (filename or filehandle) – If specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this. class DynamicsDump(dynamics, level='SUMMARY')[source]¶; A container for dumps of dynamics data.; Mainly time evolution calculations. dump_summary¶; bool – If True a summary is recorded. evo_summary¶; list of :class:`tslotcomp.EvoCompSummary’ – Summary items are appended if dump_summary is True; at each recomputation of the evolution. dump_amps¶; bool – If True control amplitudes are dumped. dump_dyn_gen¶; bool – If True the dynamics generators (Hamiltonians) are dumped. dump_prop¶; bool – If True propagators are dumped. dump_prop_grad¶; bool – If True propagator gradients are dumped. dump_fwd_evo¶; bool – If True forward evolution operators are dumped. d",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:15123,Usability,simpl,simply,15123," is Hermitian, returns complex; otherwise. Return type:float. trans()[source]¶; Transposed operator. Returns:oper – Transpose of input operator. Return type:qobj. transform(inpt, inverse=False, sparse=True)[source]¶; Basis transform defined by input array.; Input array can be a matrix defining the transformation,; or a list of kets that defines the new basis. Parameters:; inpt (array_like) – A matrix or list of kets defining the transformation.; inverse (bool) – Whether to return inverse transformation.; sparse (bool) – Use sparse matrices when possible. Can be slower. Returns:oper – Operator in new basis. Return type:qobj. Notes; This function is still in development. trunc_neg(method='clip')[source]¶; Truncates negative eigenvalues and renormalizes.; Returns a new Qobj by removing the negative eigenvalues; of this instance, then renormalizing to obtain a valid density; operator. Parameters:method (str) – Algorithm to use to remove negative eigenvalues. “clip”; simply discards negative eigenvalues, then renormalizes.; “sgs” uses the SGS algorithm (doi:10/bb76) to find the; positive operator that is nearest in the Shatten 2-norm. Returns:oper – A valid density operator. Return type:qobj. unit(norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Operator or state normalized to unity.; Uses norm from Qobj.norm(). Parameters:; norm (str) – Requested norm for states / operators.; sparse (bool) – Use sparse eigensolver for trace norm. Does not affect other norms.; tol (float) – Tolerance used by sparse eigensolver.; maxiter (int) – Number of maximum iterations performed by sparse eigensolver. Returns:oper – Normalized quantum object. Return type:qobj. eseries¶. class eseries(q=array([], dtype=object), s=array([], dtype=float64))[source]¶; Class representation of an exponential-series expansion of; time-dependent quantum objects. ampl¶; ndarray – Array of amplitudes for exponential series. rates¶; ndarray – Array of rates for exponential series. dims¶; list – Dimensio",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:18566,Usability,simpl,simple,18566," transparency of Bloch sphere frame. frame_color¶; str {‘gray’} – Color of sphere wireframe. frame_width¶; int {1} – Width of wireframe. point_color¶; list {[“b”,”r”,”g”,”#CC6600”]} – List of colors for Bloch sphere point markers to cycle through.; i.e. By default, points 0 and 4 will both be blue (‘b’). point_marker¶; list {[“o”,”s”,”d”,”^”]} – List of point marker shapes to cycle through. point_size¶; list {[25,32,35,45]} – List of point marker sizes. Note, not all point markers look; the same size when plotted!. sphere_alpha¶; float {0.2} – Transparency of Bloch sphere itself. sphere_color¶; str {‘#FFDDDD’} – Color of Bloch sphere. figsize¶; list {[7,7]} – Figure size of Bloch sphere plot. Best to have both numbers the same;; otherwise you will have a Bloch sphere that looks like a football. vector_color¶; list {[“g”,”#CC6600”,”b”,”r”]} – List of vector colors to cycle through. vector_width¶; int {5} – Width of displayed vectors. vector_style¶; str {‘-|>’, ‘simple’, ‘fancy’, ‘’} – Vector arrowhead style (from matplotlib’s arrow style). vector_mutation¶; int {20} – Width of vectors arrowhead. view¶; list {[-60,30]} – Azimuthal and Elevation viewing angles. xlabel¶; list {[“$x$”,”“]} – List of strings corresponding to +x and -x axes labels, respectively. xlpos¶; list {[1.1,-1.1]} – Positions of +x and -x labels respectively. ylabel¶; list {[“$y$”,”“]} – List of strings corresponding to +y and -y axes labels, respectively. ylpos¶; list {[1.2,-1.2]} – Positions of +y and -y labels respectively. zlabel¶; list {[r’$left|0right>$’,r’$left|1right>$’]} – List of strings corresponding to +z and -z axes labels, respectively. zlpos¶; list {[1.2,-1.2]} – Positions of +z and -z labels respectively. add_annotation(state_or_vector, text, **kwargs)[source]¶; Add a text or LaTeX annotation to Bloch sphere,; parametrized by a qubit state or a vector. Parameters:; state_or_vector (Qobj/array/list/tuple) – Position for the annotaion.; Qobj of a qubit or a vector of 3 elements.; text ",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:20473,Usability,clear,clear,20473,"st/tuple) – Position for the annotaion.; Qobj of a qubit or a vector of 3 elements.; text (str/unicode) – Annotation text.; You can use LaTeX, but remember to use raw string; e.g. r”$langle x rangle$”; or escape backslashes; e.g. “$\langle x \rangle$”.; **kwargs – Options as for mplot3d.axes3d.text, including:; fontsize, color, horizontalalignment, verticalalignment. add_points(points, meth='s')[source]¶; Add a list of data points to bloch sphere. Parameters:; points (array/list) – Collection of data points.; meth (str {'s', 'm', 'l'}) – Type of points to plot, use ‘m’ for multicolored, ‘l’ for points; connected with a line. add_states(state, kind='vector')[source]¶; Add a state vector Qobj to Bloch sphere. Parameters:; state (qobj) – Input state vector.; kind (str {'vector','point'}) – Type of object to plot. add_vectors(vectors)[source]¶; Add a list of vectors to Bloch sphere. Parameters:vectors (array_like) – Array with vectors of unit length or smaller. clear()[source]¶; Resets Bloch sphere data sets to empty. make_sphere()[source]¶; Plots Bloch sphere and data sets. render(fig=None, axes=None)[source]¶; Render the Bloch sphere and its data sets in on given figure and axes. save(name=None, format='png', dirc=None)[source]¶; Saves Bloch sphere to file of type format in directory dirc. Parameters:; name (str) – Name of saved image. Must include path and format as well.; i.e. ‘/Users/Paul/Desktop/bloch.png’; This overrides the ‘format’ and ‘dirc’ arguments.; format (str) – Format of output image.; dirc (str) – Directory for output images. Defaults to current working directory. Returns:. Return type:File containing plot of Bloch sphere. set_label_convention(convention)[source]¶; Set x, y and z labels according to one of conventions. Parameters:convention (string) – One of the following:. “original”; “xyz”; “sx sy sz”; “01”; “polarization jones”; “polarization jones letters”; see also: http://en.wikipedia.org/wiki/Jones_calculus; “polarization stokes”; see also: http",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:21745,Usability,simpl,simple,21745,"ormat='png', dirc=None)[source]¶; Saves Bloch sphere to file of type format in directory dirc. Parameters:; name (str) – Name of saved image. Must include path and format as well.; i.e. ‘/Users/Paul/Desktop/bloch.png’; This overrides the ‘format’ and ‘dirc’ arguments.; format (str) – Format of output image.; dirc (str) – Directory for output images. Defaults to current working directory. Returns:. Return type:File containing plot of Bloch sphere. set_label_convention(convention)[source]¶; Set x, y and z labels according to one of conventions. Parameters:convention (string) – One of the following:. “original”; “xyz”; “sx sy sz”; “01”; “polarization jones”; “polarization jones letters”; see also: http://en.wikipedia.org/wiki/Jones_calculus; “polarization stokes”; see also: http://en.wikipedia.org/wiki/Stokes_parameters. show()[source]¶; Display Bloch sphere and corresponding data sets. vector_mutation = None¶; Sets the width of the vectors arrowhead. vector_style = None¶; Style of Bloch vectors, default = ‘-|>’ (or ‘simple’). vector_width = None¶; Width of Bloch vectors, default = 5. class Bloch3d(fig=None)[source]¶; Class for plotting data on a 3D Bloch sphere using mayavi.; Valid data can be either points, vectors, or qobj objects; corresponding to state vectors or density matrices. for; a two-state system (or subsystem). fig¶; instance {None} – User supplied Matplotlib Figure instance for plotting Bloch sphere. font_color¶; str {‘black’} – Color of font used for Bloch sphere labels. font_scale¶; float {0.08} – Scale for font used for Bloch sphere labels. frame¶; bool {True} – Draw frame for Bloch sphere. frame_alpha¶; float {0.05} – Sets transparency of Bloch sphere frame. frame_color¶; str {‘gray’} – Color of sphere wireframe. frame_num¶; int {8} – Number of frame elements to draw. frame_radius¶; floats {0.005} – Width of wireframe. point_color¶; list {[‘r’, ‘g’, ‘b’, ‘y’]} – List of colors for Bloch sphere point markers to cycle through.; i.e. By default, points 0",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:24861,Usability,clear,clear,24861,"abels respectively. Notes; The use of mayavi for 3D rendering of the Bloch sphere comes with; a few limitations: I) You can not embed a Bloch3d figure into a; matplotlib window. II) The use of LaTex is not supported by the; mayavi rendering engine. Therefore all labels must be defined using; standard text. Of course you can post-process the generated figures; later to add LaTeX using other software if needed. add_points(points, meth='s')[source]¶; Add a list of data points to bloch sphere. Parameters:; points (array/list) – Collection of data points.; meth (str {'s','m'}) – Type of points to plot, use ‘m’ for multicolored. add_states(state, kind='vector')[source]¶; Add a state vector Qobj to Bloch sphere. Parameters:; state (qobj) – Input state vector.; kind (str {'vector','point'}) – Type of object to plot. add_vectors(vectors)[source]¶; Add a list of vectors to Bloch sphere. Parameters:vectors (array/list) – Array with vectors of unit length or smaller. clear()[source]¶; Resets the Bloch sphere data sets to empty. make_sphere()[source]¶; Plots Bloch sphere and data sets. plot_points()[source]¶; Plots points on the Bloch sphere. plot_vectors()[source]¶; Plots vectors on the Bloch sphere. save(name=None, format='png', dirc=None)[source]¶; Saves Bloch sphere to file of type format in directory dirc. Parameters:; name (str) – Name of saved image. Must include path and format as well.; i.e. ‘/Users/Paul/Desktop/bloch.png’; This overrides the ‘format’ and ‘dirc’ arguments.; format (str) – Format of output image. Default is ‘png’.; dirc (str) – Directory for output images. Defaults to current working directory. Returns:. Return type:File containing plot of Bloch sphere. show()[source]¶; Display the Bloch sphere and corresponding data sets. non-Markovian Solvers¶. class HEOMSolver[source]¶; This is superclass for all solvers that use the HEOM method for; calculating the dynamics evolution. There are many references for this.; A good introduction, and perhaps closest to th",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:28423,Usability,progress bar,progress bar,28423,"of the simulation. stats¶; qutip.solver.Stats – optional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coeff¶; list of complex – Coefficients for the exponential series terms. exp_freq¶; list of complex – Frequencies for the exponential series terms. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters:; options (qutip.solver.Options) – Generic solver options.; If set to None the default options will be used; progress_bar (BaseProgressBar) – Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar; stats (qutip.solver.Stats) – Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practica",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:28470,Usability,progress bar,progress bar,28470,"of the simulation. stats¶; qutip.solver.Stats – optional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coeff¶; list of complex – Coefficients for the exponential series terms. exp_freq¶; list of complex – Frequencies for the exponential series terms. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters:; options (qutip.solver.Options) – Generic solver options.; If set to None the default options will be used; progress_bar (BaseProgressBar) – Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar; stats (qutip.solver.Stats) – Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practica",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:30690,Usability,feedback,feedback,30690,"h spectral density cutoff frequency. renorm¶; bool – Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx¶; bool – Use boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters:; rho0 (Qobj) – Initial state (density matrix) of the system.; tlist (list) – Time over which system evolves. Returns:results – Object storing all results from the simulation. Return type:qutip.solver.Result. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. H_S¶; qutip.Qobj – System Hamiltonian (can also be a Liouvillian). L1¶; qutip.Qobj / list of qutip.Qobj – System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2¶; qutip.Qobj / list of qutip.Qobj – System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix¶; array – S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov¶; qutip.Qobj / list of qutip.Qobj – Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator¶; str {‘propagator’, ‘mesolve’} – Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:30841,Usability,feedback,feedback,30841,"up_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters:; rho0 (Qobj) – Initial state (density matrix) of the system.; tlist (list) – Time over which system evolves. Returns:results – Object storing all results from the simulation. Return type:qutip.solver.Result. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. H_S¶; qutip.Qobj – System Hamiltonian (can also be a Liouvillian). L1¶; qutip.Qobj / list of qutip.Qobj – System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2¶; qutip.Qobj / list of qutip.Qobj – System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix¶; array – S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov¶; qutip.Qobj / list of qutip.Qobj – Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator¶; str {‘propagator’, ‘mesolve’} – Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallel¶; bool – Run integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. options¶; qutip.solver.Options – Generic solver options. outfieldcorr(rho0, blist, tlist, t",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:30982,Usability,feedback,feedback,30982,"None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters:; rho0 (Qobj) – Initial state (density matrix) of the system.; tlist (list) – Time over which system evolves. Returns:results – Object storing all results from the simulation. Return type:qutip.solver.Result. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. H_S¶; qutip.Qobj – System Hamiltonian (can also be a Liouvillian). L1¶; qutip.Qobj / list of qutip.Qobj – System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2¶; qutip.Qobj / list of qutip.Qobj – System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix¶; array – S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov¶; qutip.Qobj / list of qutip.Qobj – Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator¶; str {‘propagator’, ‘mesolve’} – Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallel¶; bool – Run integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. options¶; qutip.solver.Options – Generic solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, ",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:31189,Usability,feedback,feedback,31189,". run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters:; rho0 (Qobj) – Initial state (density matrix) of the system.; tlist (list) – Time over which system evolves. Returns:results – Object storing all results from the simulation. Return type:qutip.solver.Result. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. H_S¶; qutip.Qobj – System Hamiltonian (can also be a Liouvillian). L1¶; qutip.Qobj / list of qutip.Qobj – System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2¶; qutip.Qobj / list of qutip.Qobj – System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix¶; array – S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov¶; qutip.Qobj / list of qutip.Qobj – Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator¶; str {‘propagator’, ‘mesolve’} – Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallel¶; bool – Run integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. options¶; qutip.solver.Options – Generic solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters:; rho0 (qutip.Qobj) – initial density matrix or state vector (ket).; blist (array_like) – List of integers specifying the field o",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:34777,Usability,learn,learningtimes,34777,"t), a generalized partial trace is performed; and a propagator for a single system is returned. Returns:time-propagator for computing field correlation function. Return type:qutip.Qobj. propagator(t, tau, notrace=False)[source]¶; Compute propagator for time t and time-delay tau. Parameters:; t (float) – current time; tau (float) – time-delay; notrace (bool {False}) – If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns:time-propagator for reduced system dynamics. Return type:qutip.Qobj. rhot(rho0, t, tau)[source]¶; Compute the reduced system density matrix \(\rho(t)\). Parameters:; rho0 (qutip.Qobj) – initial density matrix or state vector (ket); t (float) – current time; tau (float) – time-delay. Returns:density matrix at time \(t\). Return type:qutip.Qobj. class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]¶; Class of options for the Transfer Tensor Method solver. dynmaps¶; list of qutip.Qobj – List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. times¶; array_like – List of times \(t_n\) at which to calculate \(\rho(t_n)\). learningtimes¶; array_like – List of times \(t_k\) to use as learning times if argument; dynmaps is a callback function. thres¶; float – Threshold for halting. Halts if \(||T_{n}-T_{n-1}||\) is below; treshold. options¶; qutip.solver.Options – Generic solver options. Solver Options and Results¶. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False, store_final_state=False, store_states=False, seeds=None",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:35123,Usability,learn,learningtimes,35123,"is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns:time-propagator for reduced system dynamics. Return type:qutip.Qobj. rhot(rho0, t, tau)[source]¶; Compute the reduced system density matrix \(\rho(t)\). Parameters:; rho0 (qutip.Qobj) – initial density matrix or state vector (ket); t (float) – current time; tau (float) – time-delay. Returns:density matrix at time \(t\). Return type:qutip.Qobj. class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]¶; Class of options for the Transfer Tensor Method solver. dynmaps¶; list of qutip.Qobj – List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. times¶; array_like – List of times \(t_n\) at which to calculate \(\rho(t_n)\). learningtimes¶; array_like – List of times \(t_k\) to use as learning times if argument; dynmaps is a callback function. thres¶; float – Threshold for halting. Halts if \(||T_{n}-T_{n-1}||\) is below; treshold. options¶; qutip.solver.Options – Generic solver options. Solver Options and Results¶. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False, store_final_state=False, store_states=False, seeds=None, steady_state_average=False, normalize_output=True)[source]¶; Class of options for evolution solvers such as qutip.mesolve and; qutip.mcsolve. Options can be specified either as arguments to the; constructor:; opts = Options(order=10, ...). or by changing the class attributes after creation:; opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. atol¶; float {1e-8} –",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:35184,Usability,learn,learning,35184,"is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns:time-propagator for reduced system dynamics. Return type:qutip.Qobj. rhot(rho0, t, tau)[source]¶; Compute the reduced system density matrix \(\rho(t)\). Parameters:; rho0 (qutip.Qobj) – initial density matrix or state vector (ket); t (float) – current time; tau (float) – time-delay. Returns:density matrix at time \(t\). Return type:qutip.Qobj. class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]¶; Class of options for the Transfer Tensor Method solver. dynmaps¶; list of qutip.Qobj – List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. times¶; array_like – List of times \(t_n\) at which to calculate \(\rho(t_n)\). learningtimes¶; array_like – List of times \(t_k\) to use as learning times if argument; dynmaps is a callback function. thres¶; float – Threshold for halting. Halts if \(||T_{n}-T_{n-1}||\) is below; treshold. options¶; qutip.solver.Options – Generic solver options. Solver Options and Results¶. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False, store_final_state=False, store_states=False, seeds=None, steady_state_average=False, normalize_output=True)[source]¶; Class of options for evolution solvers such as qutip.mesolve and; qutip.mcsolve. Options can be specified either as arguments to the; constructor:; opts = Options(order=10, ...). or by changing the class attributes after creation:; opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. atol¶; float {1e-8} –",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:42239,Usability,clear,clear,42239," class : _StatsSection) – Section which to add the message to.; If None given, the default (first) section will be used. add_section(name)[source]¶; Add another section with the given name. Parameters:name (string) – will be used as key for sections dict; will also be the header for the section. Returns:section – The new section. Return type:class : _StatsSection. add_timing(key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters:; key (string) – key for the section.timings dictionary; reusing a key will result in numerical addition of value; value (int) – Initial value of the timing, or added to an existing timing; section (string or class : _StatsSection) – Section which to add the timing to.; If None given, the default (first) section will be used. clear()[source]¶; Clear counts, timings and messages from all sections. report(output=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='UTF-8'>)[source]¶; Report the counts, timings and messages from the sections.; Sections are reported in the order that the names were supplied; in the constructor.; The counts, timings and messages are reported in the order that they; are added to the sections; The output can be written to anything that supports a write method,; e.g. a file or the console (default); The output is intended to in markdown format. Parameters:output (stream) – file or console stream - anything that support write - where; the output will be written. set_total_time(value, section=None)[source]¶; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds. Parameters:; value (float) – Time in seconds to complete the solver section; section (string or class : _StatsSection) – Section which to set the total_time for; If None given, the total_tim",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:48171,Usability,progress bar,progress bar,48171,"odyne’, ‘heterodyne’, ‘photocurrent’) – The name of the type of measurement process that give rise to the; stochastic equation to solve. Specifying a method with this keyword; argument is a short-hand notation for using pre-defined d1 and d2; functions for the corresponding stochastic processes. distribution¶; string (‘normal’, ‘poission’) – The name of the distribution used for the stochastic increments. store_measurements¶; bool (default False) – Whether or not to store the measurement results in the; qutip.solver.SolverResult instance returned by the solver. noise¶; array – Vector specifying the noise. normalize¶; bool (default True) – Whether or not to normalize the wave function during the evolution. options¶; qutip.solver.Options – Generic solver options. map_func¶; function – A map function or managing the calls to single-trajactory solvers. map_kwargs¶; dictionary – Optional keyword arguments to the map_func function function. progress_bar¶; qutip.ui.BaseProgressBar – Optional progress bar class instance. Distribution functions¶. class Distribution(data=None, xvecs=[], xlabels=[])[source]¶; A class for representation spatial distribution functions.; The Distribution class can be used to prepresent spatial distribution; functions of arbitray dimension (although only 1D and 2D distributions; are used so far).; It is indented as a base class for specific distribution function, and; provide implementation of basic functions that are shared among all; Distribution functions, such as visualization, calculating marginal; distributions, etc. Parameters:; data (array_like) – Data for the distribution. The dimensions must match the lengths of; the coordinate arrays in xvecs.; xvecs (list) – List of arrays that spans the space for each coordinate.; xlabels (list) – List of labels for each coordinate. marginal(dim=0)[source]¶; Calculate the marginal distribution function along the dimension; dim. Return a new Distribution instance describing this reduced-; dimensionality",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:91054,Usability,simpl,simply,91054,"utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exact¶; boolean – indicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]¶. Frechet method for calculating the propagator:; exponentiating the combined dynamics generator. and the propagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient. class FidelityComputer(dynamics, params=None)[source]¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data t",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:94067,Usability,clear,clear,94067," Last computed value of the normalised fidelity. fidelity_current¶; boolean – flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad¶; array[num_tslot, num_ctrls] of float – Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm¶; float – Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current¶; boolean – flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). phase_option¶; string –. determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm¶; complex – Last computed value of the fidelity before it ",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:94085,Usability,clear,clear,94085," Last computed value of the normalised fidelity. fidelity_current¶; boolean – flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad¶; array[num_tslot, num_ctrls] of float – Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm¶; float – Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current¶; boolean – flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). phase_option¶; string –. determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm¶; complex – Last computed value of the fidelity before it ",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:94604,Usability,clear,clear,94604," to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). phase_option¶; string –. determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm¶; complex – Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current¶; boolean – flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as n",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:101210,Usability,simpl,simply,101210,"t to None if neither stats or dump are set. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. dump_current()[source]¶; Store a copy of the current time evolution. class TSlotCompUpdateAll(dynamics, params=None)[source]¶; Timeslot Computer - Update All; Updates all dynamics generators, propagators and evolutions when; ctrl amplitudes are updated. compare_amps(new_amps)[source]¶; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; Returns: True if amplitudes are the same, False if they have changed. get_timeslot_for_fidelity_calc()[source]¶; Returns the timeslot index that will be used calculate current fidelity; value.; This (default) method simply returns the last timeslot. recompute_evolution()[source]¶; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary. class PulseGen(dyn=None, params=None)[source]¶; Pulse generator; Base class for all Pulse generators; The object can optionally be instantiated with a Dynamics object,; in which case the timeslots and amplitude scaling and offset; are copied from that.; Otherwise the class can be used independently by setting:; tau (array of timeslot durations); or; num_tslots and pulse_time for equally spaced timeslots. num_tslots¶; integer – Number of timeslots, aka timeslices; (copied from Dynamics if given). pulse_time¶; float – total duration of the pulse; (copied from Dynamics.evo_time if given). scaling¶; float – linear scaling applied to the pulse; (copied from Dynamics.initial_ctrl_scaling if given). offset¶; float – linear offset applied to the pulse; (copied from Dynamics.initial_ctrl_offset if given). ",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:103993,Usability,simpl,simply,103993,"rator produces random pulses. log_level¶; integer – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value. gen_pulse()[source]¶; returns the pulse as an array of vales for each timeslot; Must be implemented by subclass. init_pulse()[source]¶; Initialise the pulse parameters. reset()[source]¶; reset attributes to default values. class PulseGenRandom(dyn=None, params=None)[source]¶; Generates random pulses as simply random values for each timeslot. gen_pulse()[source]¶; Generate a pulse of random values between 1 and -1; Values are scaled using the scaling property; and shifted using the offset property; Returns the pulse as an array of vales for each timeslot. class PulseGenZero(dyn=None, params=None)[source]¶; Generates a flat pulse. gen_pulse()[source]¶; Generate a pulse with the same value in every timeslot.; The value will be zero, unless the offset is not zero,; in which case it will be the offset. class PulseGenLinear(dyn=None, params=None)[source]¶; Generates linear pulses. gradient¶; float – Gradient of the line.; Note this is calculated from the start_val and end_val if these; are given. start_val¶; float – Start point of the line. That is the starting amplitude. end_val¶; float – End point of the line.; That is the amplitude at the start of the last timeslot. gen_pulse(gradient=None, start_val=None, end_val=None)[source]¶; Generate a linear pulse using either",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/classes.html:111796,Usability,simpl,simply,111796,"randomize_freqs¶; bool – If True (default) the some random offset is applied to the frequencies. gen_pulse(coeffs=None)[source]¶; Generate a pulse using the Fourier basis with the freqs and; coeffs attributes. Parameters:coeffs (float array[num_coeffs, num_basis_funcs]) – The basis coefficient values; If given this overides the default and sets the attribute; of the same name. init_freqs()[source]¶; Generate the frequencies; These are the Fourier harmonics with a uniformly distributed; random offset. init_pulse(num_coeffs=None)[source]¶; Set the initial freq and coefficient values. reset()[source]¶; reset attributes to default values. class Stats[source]¶; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. dyn_gen_name¶; string – Text used in some report functions.; Makes sense to set it to ‘Hamiltonian’ when using unitary dynamics; Default is simply ‘dynamics generator’. num_iter¶; integer – Number of iterations of the optimisation algorithm. wall_time_optim_start¶; float – Start time for the optimisation. wall_time_optim_end¶; float – End time for the optimisation. wall_time_optim¶; float – Time elasped during the optimisation. wall_time_dyn_gen_compute¶; float – Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute¶; float – Total wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_time_fwd_prop_compute¶; float – Total wall (elasped) time computing combined forward propagation,; that is the time evolution from the start to a specific timeslot.; Excludes calculating the propagators themselves. wall_time_onwd_prop_compute¶; float – Total wall (elasped) time computing combined onward propagat",MatchSource.WIKI,docs/4.0.2/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:2826,Availability,down,down,2826,">. Return type:qobj. Examples; >>> basis(5,2); Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 0.+0.j]; [ 0.+0.j]; [ 1.+0.j]; [ 0.+0.j]; [ 0.+0.j]]. Notes; A subtle incompatibility with the quantum optics toolbox: In QuTiP:; basis(N, 0) = ground state. but in the qotoolbox:; basis(N, 1) = ground state. bell_state(state='00')[source]¶; Returns the Bell state:. |B00> = 1 / sqrt(2)*[|0>|0>+|1>|1>]; |B01> = 1 / sqrt(2)*[|0>|0>-|1>|1>]; |B10> = 1 / sqrt(2)*[|0>|1>+|1>|0>]; |B11> = 1 / sqrt(2)*[|0>|1>-|1>|0>]. Returns:Bell_state – Bell state. Return type:qobj. bra(seq, dim=2)[source]¶; Produces a multiparticle bra state for a list or string,; where each element stands for state of the respective particle. Parameters:seq (str / list of ints or characters) – Each element defines state of the respective particle.; (e.g. [1,1,0,1] or a string “1101”).; For qubits it is also possible to use the following conventions:; - ‘g’/’e’ (ground and excited state); - ‘u’/’d’ (spin up and down); - ‘H’/’V’ (horizontal and vertical polarization); Note: for dimension > 9 you need to use a list. dim; : int (default: 2) / list of intsSpace dimension for each particle:; int if there are the same, list if they are different. Returns:bra. Return type:qobj. Examples; >>> bra(""10""); Quantum object: dims = [[1, 1], [2, 2]], shape = [1, 4], type = bra; Qobj data =; [[ 0. 0. 1. 0.]]. >>> bra(""Hue""); Quantum object: dims = [[1, 1, 1], [2, 2, 2]], shape = [1, 8], type = bra; Qobj data =; [[ 0. 1. 0. 0. 0. 0. 0. 0.]]. >>> bra(""12"", 3); Quantum object: dims = [[1, 1], [3, 3]], shape = [1, 9], type = bra; Qobj data =; [[ 0. 0. 0. 0. 0. 1. 0. 0. 0.]]. >>> bra(""31"", [5, 2]); Quantum object: dims = [[1, 1], [5, 2]], shape = [1, 10], type = bra; Qobj data =; [[ 0. 0. 0. 0. 0. 0. 0. 1. 0. 0.]]. coherent(N, alpha, offset=0, method='operator')[source]¶; Generates a coherent state with eigenvalue alpha.; Constructed using displacement operator on vacuum state. Parameters:; N (int) – ",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:10944,Availability,down,down,10944,"les; >>> fock_dm(3,1); Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j]; [ 0.+0.j 0.+0.j 0.+0.j]]. ghz_state(N=3)[source]¶; Returns the N-qubit GHZ-state. Parameters:N (int (default=3)) – Number of qubits in state. Returns:G – N-qubit GHZ-state. Return type:qobj. maximally_mixed_dm(N)[source]¶; Returns the maximally mixed density matrix for a Hilbert space of; dimension N. Parameters:N (int) – Number of basis states in Hilbert space. Returns:dm – Thermal state density matrix. Return type:qobj. ket(seq, dim=2)[source]¶; Produces a multiparticle ket state for a list or string,; where each element stands for state of the respective particle. Parameters:seq (str / list of ints or characters) – Each element defines state of the respective particle.; (e.g. [1,1,0,1] or a string “1101”).; For qubits it is also possible to use the following conventions:; - ‘g’/’e’ (ground and excited state); - ‘u’/’d’ (spin up and down); - ‘H’/’V’ (horizontal and vertical polarization); Note: for dimension > 9 you need to use a list. dim; : int (default: 2) / list of intsSpace dimension for each particle:; int if there are the same, list if they are different. Returns:ket. Return type:qobj. Examples; >>> ket(""10""); Quantum object: dims = [[2, 2], [1, 1]], shape = [4, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 1.]; [ 0.]]. >>> ket(""Hue""); Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket; Qobj data =; [[ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]]. >>> ket(""12"", 3); Quantum object: dims = [[3, 3], [1, 1]], shape = [9, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]]. >>> ket(""31"", [5, 2]); Quantum object: dims = [[5, 2], [1, 1]], shape = [10, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]]. ket2dm(Q)[source]¶; Takes input ket or bra vector and returns density matrix; for",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:31126,Availability,error,error,31126,"form; \(\sum |N><N+m| + |N+m><N|\). Parameters:; N (int) – Number of basis states in Hilbert space.; m (int (default = 1)) – Number of excitations in tunneling event. Returns:T – Tunneling operator. Return type:Qobj. Notes. New in version 3.2. Random Operators and States¶; This module is a collection of random state and operator generators.; The sparsity of the ouput Qobj’s is controlled by varing the; density parameter. rand_dm(N, density=0.75, pure=False, dims=None)[source]¶; Creates a random NxN density matrix. Parameters:; N (int, ndarray, list) – If int, then shape of output operator. If list/ndarray then eigenvalues; of generated density matrix.; density (float) – Density between [0,1] of output density matrix.; dims (list) – Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns:oper – NxN density matrix quantum operator. Return type:qobj. Notes; For small density matrices., choosing a low density will result in an error; as no diagonal elements will be generated such that \(Tr(\rho)=1\). rand_dm_ginibre(N=2, rank=None, dims=None)[source]¶; Returns a Ginibre random density operator of dimension; dim and rank rank by using the algorithm of; [BCSZ08]. If rank is None, a full-rank; (Hilbert-Schmidt ensemble) random density operator will be; returned. Parameters:; N (int) – Dimension of the density operator to be returned.; dims (list) – Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]].; rank (int or None) – Rank of the sampled density operator. If None, a full-rank; density operator is generated. Returns:rho – An N × N density operator sampled from the Ginibre; or Hilbert-Schmidt distribution. Return type:Qobj. rand_dm_hs(N=2, dims=None)[source]¶; Returns a Hilbert-Schmidt random density operator of dimension; dim and rank rank by using the algorithm of; [BCSZ08]. Parameters:; N (int) – Dimension of the density operator to be returned.; dims (list) – Dimensions of quant",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:44450,Availability,mask,mask,44450,"y. Return type:Qobj. Expectation Values¶. expect(oper, state)[source]¶; Calculates the expectation value for operator(s) and state(s). Parameters:; oper (qobj/array-like) – A single or a list or operators for expectation value.; state (qobj/array-like) – A single or a list of quantum states or density matrices. Returns:expt – Expectation value. real if oper is Hermitian, complex; otherwise. A (nested) array of expectaction values of state or operator; are arrays. Return type:float/complex/array-like. Examples; >>> expect(num(4), basis(4, 3)); 3. variance(oper, state)[source]¶; Variance of an operator for the given state vector or density matrix. Parameters:; oper (qobj) – Operator for expectation value.; state (qobj/list) – A single or list of quantum states or density matrices.. Returns:var – Variance of operator ‘oper’ for given state. Return type:float. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters:; rho (qutip.qobj) – A density matrix.; mask (list / array) – A mask that selects which subsystems should be transposed.; method (str) – choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:rho_pr – A density matrix with the selected subsystems transposed. Return type:qutip.qobj. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:state (qobj) – Ket, bra, or density matrix for a two-qubit state. Returns:concur – Concurrence. Return t",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:44542,Availability,mask,mask,44542,"y. Return type:Qobj. Expectation Values¶. expect(oper, state)[source]¶; Calculates the expectation value for operator(s) and state(s). Parameters:; oper (qobj/array-like) – A single or a list or operators for expectation value.; state (qobj/array-like) – A single or a list of quantum states or density matrices. Returns:expt – Expectation value. real if oper is Hermitian, complex; otherwise. A (nested) array of expectaction values of state or operator; are arrays. Return type:float/complex/array-like. Examples; >>> expect(num(4), basis(4, 3)); 3. variance(oper, state)[source]¶; Variance of an operator for the given state vector or density matrix. Parameters:; oper (qobj) – Operator for expectation value.; state (qobj/list) – A single or list of quantum states or density matrices.. Returns:var – Variance of operator ‘oper’ for given state. Return type:float. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters:; rho (qutip.qobj) – A density matrix.; mask (list / array) – A mask that selects which subsystems should be transposed.; method (str) – choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:rho_pr – A density matrix with the selected subsystems transposed. Return type:qutip.qobj. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:state (qobj) – Ket, bra, or density matrix for a two-qubit state. Returns:concur – Concurrence. Return t",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:44678,Availability,mask,mask,44678,"like) – A single or a list or operators for expectation value.; state (qobj/array-like) – A single or a list of quantum states or density matrices. Returns:expt – Expectation value. real if oper is Hermitian, complex; otherwise. A (nested) array of expectaction values of state or operator; are arrays. Return type:float/complex/array-like. Examples; >>> expect(num(4), basis(4, 3)); 3. variance(oper, state)[source]¶; Variance of an operator for the given state vector or density matrix. Parameters:; oper (qobj) – Operator for expectation value.; state (qobj/list) – A single or list of quantum states or density matrices.. Returns:var – Variance of operator ‘oper’ for given state. Return type:float. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters:; rho (qutip.qobj) – A density matrix.; mask (list / array) – A mask that selects which subsystems should be transposed.; method (str) – choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:rho_pr – A density matrix with the selected subsystems transposed. Return type:qutip.qobj. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:state (qobj) – Ket, bra, or density matrix for a two-qubit state. Returns:concur – Concurrence. Return type:float. References. [R2]http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:44775,Availability,mask,mask,44775,"ates or density matrices. Returns:expt – Expectation value. real if oper is Hermitian, complex; otherwise. A (nested) array of expectaction values of state or operator; are arrays. Return type:float/complex/array-like. Examples; >>> expect(num(4), basis(4, 3)); 3. variance(oper, state)[source]¶; Variance of an operator for the given state vector or density matrix. Parameters:; oper (qobj) – Operator for expectation value.; state (qobj/list) – A single or list of quantum states or density matrices.. Returns:var – Variance of operator ‘oper’ for given state. Return type:float. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters:; rho (qutip.qobj) – A density matrix.; mask (list / array) – A mask that selects which subsystems should be transposed.; method (str) – choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:rho_pr – A density matrix with the selected subsystems transposed. Return type:qutip.qobj. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:state (qobj) – Ket, bra, or density matrix for a two-qubit state. Returns:concur – Concurrence. Return type:float. References. [R2]http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters:; rho (qo",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:44945,Availability,mask,mask,44945,"operator; are arrays. Return type:float/complex/array-like. Examples; >>> expect(num(4), basis(4, 3)); 3. variance(oper, state)[source]¶; Variance of an operator for the given state vector or density matrix. Parameters:; oper (qobj) – Operator for expectation value.; state (qobj/list) – A single or list of quantum states or density matrices.. Returns:var – Variance of operator ‘oper’ for given state. Return type:float. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters:; rho (qutip.qobj) – A density matrix.; mask (list / array) – A mask that selects which subsystems should be transposed.; method (str) – choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:rho_pr – A density matrix with the selected subsystems transposed. Return type:qutip.qobj. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:state (qobj) – Ket, bra, or density matrix for a two-qubit state. Returns:concur – Concurrence. Return type:float. References. [R2]http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters:; rho (qobj) – Density matrix of composite object; selB (int/list) – Selected components for density matrix B; base ({e,2}) – Base of logarithm.; sparse ({False,True}) ",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:44969,Availability,mask,mask,44969,"operator; are arrays. Return type:float/complex/array-like. Examples; >>> expect(num(4), basis(4, 3)); 3. variance(oper, state)[source]¶; Variance of an operator for the given state vector or density matrix. Parameters:; oper (qobj) – Operator for expectation value.; state (qobj/list) – A single or list of quantum states or density matrices.. Returns:var – Variance of operator ‘oper’ for given state. Return type:float. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters:; rho (qutip.qobj) – A density matrix.; mask (list / array) – A mask that selects which subsystems should be transposed.; method (str) – choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:rho_pr – A density matrix with the selected subsystems transposed. Return type:qutip.qobj. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:state (qobj) – Ket, bra, or density matrix for a two-qubit state. Returns:concur – Concurrence. Return type:float. References. [R2]http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters:; rho (qobj) – Density matrix of composite object; selB (int/list) – Selected components for density matrix B; base ({e,2}) – Base of logarithm.; sparse ({False,True}) ",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:81829,Availability,error,errors,81829,"ly implemented; for the me and es solvers.; tlist (array_like) – list of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input.; taulist (array_like) – list of times for \(\tau\). taulist must be positive and contain; the element 0.; c_ops (list) – list of collapse operators, may be time-dependent for solver choice of; me or mc.; a_op (Qobj) – operator A.; b_op (Qobj) – operator B.; reverse (bool) – If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\).; solver (str) – choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series).; options (Options) – solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:corr_mat – An 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. Return type:array. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_ss(H, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:. \[\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\]; along one time axis (given steady-state initial conditions) using the; quantum regression theorem and the evolution solver indicated by the; solver parameter. Parameters:; H (Qobj) – system Hamiltonian.; taulist (array_like) – list of times for \(\tau\). taulist must be positive and contain; the element 0.; c_ops (list) – list of collapse operators.; a_op (Qobj) – operator A.; b_op (Qobj) – o",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:83297,Availability,error,errors,83297,"Options object>)[source]¶; Calculate the two-operator two-time correlation function:. \[\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\]; along one time axis (given steady-state initial conditions) using the; quantum regression theorem and the evolution solver indicated by the; solver parameter. Parameters:; H (Qobj) – system Hamiltonian.; taulist (array_like) – list of times for \(\tau\). taulist must be positive and contain; the element 0.; c_ops (list) – list of collapse operators.; a_op (Qobj) – operator A.; b_op (Qobj) – operator B.; reverse (bool) – If True, calculate; \(\lim_{t \to \infty} \left<A(t)B(t+\tau)\right>\) instead of; \(\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\).; solver (str) – choice of solver (me for master-equation and; es for exponential series).; options (Options) – solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:corr_vec – An array of correlation values for the times specified by tlist. Return type:array. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along one time axis using the quantum regression theorem and the evolution; solver indicated by the solver parameter. Parameters:; H (Qobj) – system Hamiltonian, may be time-dependent for solver choice of me or; mc.; state0 (Qobj) – Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers.; taulist (array_like) – list of times for \(\tau\). taulist must be positive and contain; the element ",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:84922,Availability,error,errors,84922,"t for solver choice of me or; mc.; state0 (Qobj) – Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers.; taulist (array_like) – list of times for \(\tau\). taulist must be positive and contain; the element 0.; c_ops (list) – list of collapse operators, may be time-dependent for solver choice of; me or mc.; a_op (Qobj) – operator A.; b_op (Qobj) – operator B.; reverse (bool {False, True}) – If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\).; solver (str {'me', 'mc', 'es'}) – choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series).; options (Options) – Solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:corr_vec – An array of correlation values for the times specified by tlist. Return type:ndarray. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter. Parameters:; H (Qobj) – system Hamiltonian, may be time-dependent for solver choice of me or; mc.; state0 (Qobj) – Initial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers.; tlist (array_like) – list of times for \(t\). tlist must be positive and contain the; element 0. W",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:86795,Availability,error,errors,86795,"; for the me and es solvers.; tlist (array_like) – list of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input.; taulist (array_like) – list of times for \(\tau\). taulist must be positive and contain; the element 0.; c_ops (list) – list of collapse operators, may be time-dependent for solver choice of; me or mc.; a_op (Qobj) – operator A.; b_op (Qobj) – operator B.; reverse (bool {False, True}) – If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\).; solver (str) – choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series).; options (Options) – solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:corr_mat – An 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. Return type:ndarray. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the three-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along one time axis using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters:; H (Qobj) – system Hamiltonian, may be time-dependent for solver choice of me or; mc.; rho0 (Qobj) – Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:88561,Availability,error,errors,88561," meaningful correlation; of this form where \(\tau<0\). Parameters:; H (Qobj) – system Hamiltonian, may be time-dependent for solver choice of me or; mc.; rho0 (Qobj) – Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers.; taulist (array_like) – list of times for \(\tau\). taulist must be positive and contain; the element 0.; c_ops (list) – list of collapse operators, may be time-dependent for solver choice of; me or mc.; a_op (Qobj) – operator A.; b_op (Qobj) – operator B.; c_op (Qobj) – operator C.; solver (str) – choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series).; options (Options) – solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:corr_vec – An array of correlation values for the times specified by taulist. Return type:array. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the three-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters:; H (Qobj) – system Hamiltonian, may be time-dependent for solver choice of me or; mc.; rho0 (Qobj) – Initial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solver",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:90437,Availability,error,errors,90437,"’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers.; tlist (array_like) – list of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input.; taulist (array_like) – list of times for \(\tau\). taulist must be positive and contain; the element 0.; c_ops (list) – list of collapse operators, may be time-dependent for solver choice of; me or mc.; a_op (Qobj) – operator A.; b_op (Qobj) – operator B.; c_op (Qobj) – operator C.; solver (str) – choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series).; options (Options) – solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:corr_mat – An 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. Return type:array. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_4op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\); along one time axis using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters:; H (Qobj) – system Hamiltonian, may be time-dependent for solver choice of me or; mc.; rho0 (Qobj) – Initial state density matrix \(\rho(t_0)\) or state ve",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:92242,Availability,error,errors,92242," this form where \(\tau<0\). Parameters:; H (Qobj) – system Hamiltonian, may be time-dependent for solver choice of me or; mc.; rho0 (Qobj) – Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers.; taulist (array_like) – list of times for \(\tau\). taulist must be positive and contain; the element 0.; c_ops (list) – list of collapse operators, may be time-dependent for solver choice of; me or mc.; a_op (Qobj) – operator A.; b_op (Qobj) – operator B.; c_op (Qobj) – operator C.; d_op (Qobj) – operator D.; solver (str) – choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series).; options (Options) – solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:corr_vec – An array of correlation values for the times specified by taulist. Return type:array. References; See, Gardiner, Quantum Noise, Section 5.2. Note; Deprecated in QuTiP 3.1; Use correlation_3op_1t() instead. correlation_4op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters:; H (Qobj) – system Hamiltonian, may be time-dependent for solver choice of me or; mc.; rho0 (Qobj) – Initial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the ",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:94224,Availability,error,errors,94224,"ll; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers.; tlist (array_like) – list of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input.; taulist (array_like) – list of times for \(\tau\). taulist must be positive and contain; the element 0.; c_ops (list) – list of collapse operators, may be time-dependent for solver choice of; me or mc.; a_op (Qobj) – operator A.; b_op (Qobj) – operator B.; c_op (Qobj) – operator C.; d_op (Qobj) – operator D.; solver (str) – choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series).; options (Options) – solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:corr_mat – An 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. Return type:array. References; See, Gardiner, Quantum Noise, Section 5.2. spectrum(H, wlist, c_ops, a_op, b_op, solver='es', use_pinv=False)[source]¶; Calculate the spectrum of the correlation function; \(\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\),; i.e., the Fourier transform of the correlation function:. \[S(\omega) = \int_{-\infty}^{\infty}; \lim_{t \to \infty} \left<A(t+\tau)B(t)\right>; e^{-i\omega\tau} d\tau.\]; using the solver indicated by the solver parameter. Note: this spectrum; is only defined for stationary statistics (uses steady state rho0). Parameters:; H (qutip.qobj) – system Hamiltonian.; wlist (array_like) – list of frequencies for \(\omega\).; c_ops (list) – list of collapse op",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:99140,Availability,error,errors,99140,"e A^\dagger(0)A(0)\rangle}}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters:; H (Qobj) – system Hamiltonian, may be time-dependent for solver choice of me or; mc.; state0 (Qobj) – Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers.; taulist (array_like) – list of times for \(\tau\). taulist must be positive and contain; the element 0.; c_ops (list) – list of collapse operators, may be time-dependent for solver choice of; me or mc.; a_op (Qobj) – operator A.; solver (str) – choice of solver (me for master-equation and; es for exponential series).; options (Options) – solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:g1, G1 – The normalized and unnormalized second-order coherence function. Return type:tuple. coherence_function_g2(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized second-order quantum coherence function:. \[ g^{(2)}(\tau) =; \frac{\langle A^\dagger(0)A^\dagger(\tau)A(\tau)A(0)\rangle}; {\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters:; H (Qobj) – system Hamiltonian, may be time-dependent for solver choice of me or; mc.; state0 (Qobj) – Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers.; taulist (array_like) – list of times for \(\tau\). taulist mus",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:100611,Availability,error,errors,100611,"le A^\dagger(0)A(0)\rangle}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters:; H (Qobj) – system Hamiltonian, may be time-dependent for solver choice of me or; mc.; state0 (Qobj) – Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers.; taulist (array_like) – list of times for \(\tau\). taulist must be positive and contain; the element 0.; c_ops (list) – list of collapse operators, may be time-dependent for solver choice of; me or mc.; a_op (Qobj) – operator A.; solver (str) – choice of solver (me for master-equation and; es for exponential series).; options (Options) – solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:g2, G2 – The normalized and unnormalized second-order coherence function. Return type:tuple. Steady-state Solvers¶; Module contains functions for solving for the steady state density matrix of; open quantum systems defined by a Liouvillian or Hamiltonian and a list of; collapse operators. steadystate(A, c_op_list=[], **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters:; A (qobj) – A Hamiltonian or Liouvillian operator.; c_op_list (list) – A list of collapse operators.; method (str {'direct', 'eigen', 'iterative-gmres',) – ; ‘iterative-lgmres’, ‘iterative-bicgstab’, ‘svd’, ‘power’,; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’}. Met",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:110480,Availability,error,error,110480,"eturns:a – Instance representing the propagator \(U(t)\). Return type:qobj. propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters:U (qobj) – Operator representing the propagator. Returns:a – Instance representing the steady-state density matrix. Return type:qobj. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters:; H (qobj) – System Hamiltonian.; c_ops (list) – list of collapse operators.; args (dict) – Arguments for time-dependent Hamiltonian and collapse operator terms.; options (Options) – Instance of ODE solver options.; name (str) – Name of generated RHS; cleanup (bool) – Whether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns:. Return type:Nothing, just clears data from internal config module. Visualization¶. Pseudoprobability Functions¶. qfunc(state, xvec, yvec, g=1.4142135623730951)[source]¶; Q-function of a given state vector or density matrix; at points xvec + i * yvec. Parameters:; state (qobj) – A state vector or density matrix.; xvec (array_like) – x-coordinates at which to calculate the Wigner function.; yvec (array_like) – y-coordinates at which to calculate the Wigner function.; g (float) – Scaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2). Returns:Q – Values representing the Q-function calculated over the specified range; [xvec,yvec]. Return type:array. spin_q_function(rho, theta, phi)[source]¶; Husimi Q-function for spins. Parameters:; state (qobj) – A state vector or density matrix for a spin-j quantum system.; theta (array_like) – theta-c",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:143664,Availability,error,error,143664,"returns the; superoperator at a given time.; rho0 (qutip.Qobj) – Initial density matrix or state vector (ket).; times (array_like) – list of times \(t_n\) at which to compute \(\rho(t_n)\).; Must be uniformily spaced.; e_ops (list of qutip.Qobj / callback function) – single operator or list of operators for which to evaluate; expectation values.; learningtimes (array_like) – list of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\).; tensors (array_like) – optional list of precomputed tensors \(T_k\); kwargs (dictionary) – Optional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns:output – An instance of the class qutip.solver.Result. Return type:qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisat",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:143832,Availability,error,error,143832,"te \(\rho(t_n)\).; Must be uniformily spaced.; e_ops (list of qutip.Qobj / callback function) – single operator or list of operators for which to evaluate; expectation values.; learningtimes (array_like) – list of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\).; tensors (array_like) – optional list of precomputed tensors \(T_k\); kwargs (dictionary) – Optional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns:output – An instance of the class qutip.solver.Result. Return type:qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the v",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:144129,Availability,error,error,144129,"ve knowledge of the dynamical; maps \(E(t_k)\).; tensors (array_like) – optional list of precomputed tensors \(T_k\); kwargs (dictionary) – Optional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns:output – An instance of the class qutip.solver.Result. Return type:qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dyna",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:144376,Availability,error,error,144376,"ns. Returns:output – An instance of the class qutip.solver.Result. Return type:qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; Doria, ",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:145049,Availability,error,error,145049,"hods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). optimize_pulse(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF'",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:146399,Availability,error,error,146399,"rXiv.1011.4874; Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). optimize_pulse(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters:; drift (Qobj or list of Qobj) – the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift; ctrls (List of Qobj) – a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; initial (Qobj) – starting point for the evolution.; Typically the identi",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:146810,Availability,error,error,146810,"arg=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters:; drift (Qobj or list of Qobj) – the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift; ctrls (List of Qobj) – a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; initial (Qobj) – starting point for the evolution.; Typically the identity matrix; target (Qobj) – target transformation, e.g. gate or state, for the time evolution; num_tslots (integer or None) – number of timeslots.; None implies that timeslots will be given in the tau array; evo_time (float or None) – total time for the evolution; None implies that timeslots will be given in the tau array; tau (array[num_tslots] of floats or None) – durations for the timeslots.; if this is given ",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:146830,Availability,error,error,146830,"arg=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters:; drift (Qobj or list of Qobj) – the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift; ctrls (List of Qobj) – a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; initial (Qobj) – starting point for the evolution.; Typically the identity matrix; target (Qobj) – target transformation, e.g. gate or state, for the time evolution; num_tslots (integer or None) – number of timeslots.; None implies that timeslots will be given in the tau array; evo_time (float or None) – total time for the evolution; None implies that timeslots will be given in the tau array; tau (array[num_tslots] of floats or None) – durations for the timeslots.; if this is given ",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:148248,Availability,error,error,148248,"list of Qobj) – the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift; ctrls (List of Qobj) – a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; initial (Qobj) – starting point for the evolution.; Typically the identity matrix; target (Qobj) – target transformation, e.g. gate or state, for the time evolution; num_tslots (integer or None) – number of timeslots.; None implies that timeslots will be given in the tau array; evo_time (float or None) – total time for the evolution; None implies that timeslots will be given in the tau array; tau (array[num_tslots] of floats or None) – durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots; amp_lbound (float or list of floats) – lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control; amp_ubound (float or list of floats) – upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control; fid_err_targ (float) – Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value; mim_grad (float) – Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima; max_iter (integer) – Maximum number of iterations of the optimisation algorithm; max_wall_time (float) – Maximum allowed elapsed time for the optimisation algorithm; alg (string) – Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params (Dictionary) – options that are specific to the algorithm see above; optim_params (Dictionary) – The key value pairs are ",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:148315,Availability,error,error,148315,"y matrix; target (Qobj) – target transformation, e.g. gate or state, for the time evolution; num_tslots (integer or None) – number of timeslots.; None implies that timeslots will be given in the tau array; evo_time (float or None) – total time for the evolution; None implies that timeslots will be given in the tau array; tau (array[num_tslots] of floats or None) – durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots; amp_lbound (float or list of floats) – lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control; amp_ubound (float or list of floats) – upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control; fid_err_targ (float) – Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value; mim_grad (float) – Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima; max_iter (integer) – Maximum number of iterations of the optimisation algorithm; max_wall_time (float) – Maximum allowed elapsed time for the optimisation algorithm; alg (string) – Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params (Dictionary) – options that are specific to the algorithm see above; optim_params (Dictionary) – The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; optim_method (string) – a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:149331,Availability,error,error,149331,"ue; mim_grad (float) – Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima; max_iter (integer) – Maximum number of iterations of the optimisation algorithm; max_wall_time (float) – Maximum allowed elapsed time for the optimisation algorithm; alg (string) – Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params (Dictionary) – options that are specific to the algorithm see above; optim_params (Dictionary) – The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; optim_method (string) – a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; optim_alg (string) – Deprecated. Use optim_method.; max_metric_corr (integer) – Deprecated. Use method_params instead; accuracy_factor (float) – Deprecated. Use method_params instead; dyn_type (string) – Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); dyn_params (dict) – Parameters fo",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:150952,Availability,error,error,150952,"y.optimize.minimize method.; optim_alg (string) – Deprecated. Use optim_method.; max_metric_corr (integer) – Deprecated. Use method_params instead; accuracy_factor (float) – Deprecated. Use method_params instead; dyn_type (string) – Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); dyn_params (dict) – Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; prop_type (string) – Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details); prop_params (dict) – Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; fid_type (string) – Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details); fid_params (dict) – Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; phase_option (string) – Deprecated. Pass in fid_params instead.; fid_err_scale_factor (float) – Deprecated. Use scale_factor key in fid_params instead.; tslot_type (string) – Method for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details); tslot_params (dict) – Parameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; amp_update_mode (string) – Deprecated. Use ts",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:150972,Availability,error,error,150972,"y.optimize.minimize method.; optim_alg (string) – Deprecated. Use optim_method.; max_metric_corr (integer) – Deprecated. Use method_params instead; accuracy_factor (float) – Deprecated. Use method_params instead; dyn_type (string) – Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); dyn_params (dict) – Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; prop_type (string) – Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details); prop_params (dict) – Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; fid_type (string) – Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details); fid_params (dict) – Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; phase_option (string) – Deprecated. Pass in fid_params instead.; fid_err_scale_factor (float) – Deprecated. Use scale_factor key in fid_params instead.; tslot_type (string) – Method for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details); tslot_params (dict) – Parameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; amp_update_mode (string) – Deprecated. Use ts",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:154144,Availability,error,error,154144," assumed to be attribute name value pairs; They applied after the object is created; log_level (integer) – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; out_file_ext (string or None) – files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files; gen_stats (boolean) – if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt – Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. Return type:OptimResult. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:154943,Availability,error,error,154943,"to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt – Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. Return type:OptimResult. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters:; H_d (Qobj or list of Qobj) – Drift (aka system) the underlying Hamiltonian of the syste",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:155613,Availability,error,error,155613,"_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters:; H_d (Qobj or list of Qobj) – Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift; H_c (Qobj) – a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; U_0 (Qobj) – starting point for the evolution.; Typically the identity matrix; U_targ (Qobj) – target transformation, e.g. gate or state, for the time evolution; num_tslots (integer or None) – number of timeslots.; None implies that timeslots will be given in the tau array; evo_time (float or None) – total time for the evolution; None implies that timeslots will be given in the tau array; tau (array[num_ts",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:155780,Availability,error,error,155780,"=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters:; H_d (Qobj or list of Qobj) – Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift; H_c (Qobj) – a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; U_0 (Qobj) – starting point for the evolution.; Typically the identity matrix; U_targ (Qobj) – target transformation, e.g. gate or state, for the time evolution; num_tslots (integer or None) – number of timeslots.; None implies that timeslots will be given in the tau array; evo_time (float or None) – total time for the evolution; None implies that timeslots will be given in the tau array; tau (array[num_tslots] of floats or None) – durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots; amp_lbound (float or list of floats) – lower boundaries for the con",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:157080,Availability,error,error,157080,"(Qobj or list of Qobj) – Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift; H_c (Qobj) – a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; U_0 (Qobj) – starting point for the evolution.; Typically the identity matrix; U_targ (Qobj) – target transformation, e.g. gate or state, for the time evolution; num_tslots (integer or None) – number of timeslots.; None implies that timeslots will be given in the tau array; evo_time (float or None) – total time for the evolution; None implies that timeslots will be given in the tau array; tau (array[num_tslots] of floats or None) – durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots; amp_lbound (float or list of floats) – lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control; amp_ubound (float or list of floats) – upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control; fid_err_targ (float) – Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value; mim_grad (float) – Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima; max_iter (integer) – Maximum number of iterations of the optimisation algorithm; max_wall_time (float) – Maximum allowed elapsed time for the optimisation algorithm; alg (string) – Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params (Dictionary) – options that are specific to the algorithm see above; optim_params (Dictionary) – The key value pairs are ",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:157147,Availability,error,error,157147,"y matrix; U_targ (Qobj) – target transformation, e.g. gate or state, for the time evolution; num_tslots (integer or None) – number of timeslots.; None implies that timeslots will be given in the tau array; evo_time (float or None) – total time for the evolution; None implies that timeslots will be given in the tau array; tau (array[num_tslots] of floats or None) – durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots; amp_lbound (float or list of floats) – lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control; amp_ubound (float or list of floats) – upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control; fid_err_targ (float) – Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value; mim_grad (float) – Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima; max_iter (integer) – Maximum number of iterations of the optimisation algorithm; max_wall_time (float) – Maximum allowed elapsed time for the optimisation algorithm; alg (string) – Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params (Dictionary) – options that are specific to the algorithm see above; optim_params (Dictionary) – The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; optim_method (string) – a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:158163,Availability,error,error,158163,"ue; mim_grad (float) – Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima; max_iter (integer) – Maximum number of iterations of the optimisation algorithm; max_wall_time (float) – Maximum allowed elapsed time for the optimisation algorithm; alg (string) – Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params (Dictionary) – options that are specific to the algorithm see above; optim_params (Dictionary) – The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; optim_method (string) – a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; optim_alg (string) – Deprecated. Use optim_method.; max_metric_corr (integer) – Deprecated. Use method_params instead; accuracy_factor (float) – Deprecated. Use method_params instead; phase_option (string) – determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params (dic",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:162339,Availability,error,error,162339," assumed to be attribute name value pairs; They applied after the object is created; log_level (integer) – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; out_file_ext (string or None) – files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files; gen_stats (boolean) – if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt – Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. Return type:OptimResult. create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, gen_stats=False)[source]¶; Generate the objects of the appropriate subclasses; required for the pulse optmisation based on the parameters given; Note this method may be preferable",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:164839,Availability,error,error,164839,"list of Qobj) – the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift; ctrls (List of Qobj) – a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; initial (Qobj) – starting point for the evolution.; Typically the identity matrix; target (Qobj) – target transformation, e.g. gate or state, for the time evolution; num_tslots (integer or None) – number of timeslots.; None implies that timeslots will be given in the tau array; evo_time (float or None) – total time for the evolution; None implies that timeslots will be given in the tau array; tau (array[num_tslots] of floats or None) – durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots; amp_lbound (float or list of floats) – lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control; amp_ubound (float or list of floats) – upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control; fid_err_targ (float) – Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value; mim_grad (float) – Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima; max_iter (integer) – Maximum number of iterations of the optimisation algorithm; max_wall_time (float) – Maximum allowed elapsed time for the optimisation algorithm; alg (string) – Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params (Dictionary) – options that are specific to the algorithm see above; optim_params (Dictionary) – The key value pairs are ",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:164906,Availability,error,error,164906,"y matrix; target (Qobj) – target transformation, e.g. gate or state, for the time evolution; num_tslots (integer or None) – number of timeslots.; None implies that timeslots will be given in the tau array; evo_time (float or None) – total time for the evolution; None implies that timeslots will be given in the tau array; tau (array[num_tslots] of floats or None) – durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots; amp_lbound (float or list of floats) – lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control; amp_ubound (float or list of floats) – upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control; fid_err_targ (float) – Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value; mim_grad (float) – Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima; max_iter (integer) – Maximum number of iterations of the optimisation algorithm; max_wall_time (float) – Maximum allowed elapsed time for the optimisation algorithm; alg (string) – Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params (Dictionary) – options that are specific to the algorithm see above; optim_params (Dictionary) – The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; optim_method (string) – a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:165922,Availability,error,error,165922,"ue; mim_grad (float) – Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima; max_iter (integer) – Maximum number of iterations of the optimisation algorithm; max_wall_time (float) – Maximum allowed elapsed time for the optimisation algorithm; alg (string) – Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params (Dictionary) – options that are specific to the algorithm see above; optim_params (Dictionary) – The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; optim_method (string) – a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; optim_alg (string) – Deprecated. Use optim_method.; max_metric_corr (integer) – Deprecated. Use method_params instead; accuracy_factor (float) – Deprecated. Use method_params instead; dyn_type (string) – Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); dyn_params (dict) – Parame",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:167550,Availability,error,error,167550,"y.optimize.minimize method.; optim_alg (string) – Deprecated. Use optim_method.; max_metric_corr (integer) – Deprecated. Use method_params instead; accuracy_factor (float) – Deprecated. Use method_params instead; dyn_type (string) – Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); dyn_params (dict) – Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; prop_type (string) – Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details); prop_params (dict) – Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; fid_type (string) – Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details); fid_params (dict) – Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; phase_option (string) – Deprecated. Pass in fid_params instead.; fid_err_scale_factor (float) – Deprecated. Use scale_factor key in fid_params instead.; tslot_type (string) – Method for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details); tslot_params (dict) – Parameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; amp_update_mode (string) – Deprecated. Use ts",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:167570,Availability,error,error,167570,"y.optimize.minimize method.; optim_alg (string) – Deprecated. Use optim_method.; max_metric_corr (integer) – Deprecated. Use method_params instead; accuracy_factor (float) – Deprecated. Use method_params instead; dyn_type (string) – Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); dyn_params (dict) – Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; prop_type (string) – Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details); prop_params (dict) – Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; fid_type (string) – Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details); fid_params (dict) – Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; phase_option (string) – Deprecated. Pass in fid_params instead.; fid_err_scale_factor (float) – Deprecated. Use scale_factor key in fid_params instead.; tslot_type (string) – Method for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details); tslot_params (dict) – Parameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; amp_update_mode (string) – Deprecated. Use ts",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:171509,Availability,error,error,171509,"r, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. Return type:Optimizer. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters:; drift (Qobj or list of Qobj) – the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift; ctrls (List of Qobj) – a list of control dynamics generators. These are scaled by; the amplitudes to alter the over",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:171991,Availability,error,error,171991,"oeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters:; drift (Qobj or list of Qobj) – the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift; ctrls (List of Qobj) – a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; initial (Qobj) – starting point for the evolution.; Typically the identity matrix; target (Qobj) – target transformation, e.g. gate or state, for the time evolution; num_tslots (integer or None) – number of timeslots.; None implies that timeslots will be given in the tau array; evo_time (float or None) – total time for the evolution; None implies that timeslots will be given in the tau array; tau (array[num_tslots] of floats or None) – durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durat",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:172011,Availability,error,error,172011,"oeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters:; drift (Qobj or list of Qobj) – the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift; ctrls (List of Qobj) – a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; initial (Qobj) – starting point for the evolution.; Typically the identity matrix; target (Qobj) – target transformation, e.g. gate or state, for the time evolution; num_tslots (integer or None) – number of timeslots.; None implies that timeslots will be given in the tau array; evo_time (float or None) – total time for the evolution; None implies that timeslots will be given in the tau array; tau (array[num_tslots] of floats or None) – durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durat",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:173429,Availability,error,error,173429,"list of Qobj) – the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift; ctrls (List of Qobj) – a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; initial (Qobj) – starting point for the evolution.; Typically the identity matrix; target (Qobj) – target transformation, e.g. gate or state, for the time evolution; num_tslots (integer or None) – number of timeslots.; None implies that timeslots will be given in the tau array; evo_time (float or None) – total time for the evolution; None implies that timeslots will be given in the tau array; tau (array[num_tslots] of floats or None) – durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots; amp_lbound (float or list of floats) – lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control; amp_ubound (float or list of floats) – upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control; fid_err_targ (float) – Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value; max_iter (integer) – Maximum number of iterations of the optimisation algorithm; max_wall_time (float) – Maximum allowed elapsed time for the optimisation algorithm; alg_params (Dictionary) – options that are specific to the algorithm see above; optim_params (Dictionary) – The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; coeff_scaling (float) – Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Not",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:173496,Availability,error,error,173496,"evo_time (float or None) – total time for the evolution; None implies that timeslots will be given in the tau array; tau (array[num_tslots] of floats or None) – durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots; amp_lbound (float or list of floats) – lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control; amp_ubound (float or list of floats) – upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control; fid_err_targ (float) – Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value; max_iter (integer) – Maximum number of iterations of the optimisation algorithm; max_wall_time (float) – Maximum allowed elapsed time for the optimisation algorithm; alg_params (Dictionary) – options that are specific to the algorithm see above; optim_params (Dictionary) – The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; coeff_scaling (float) – Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); num_coeffs (integer) – Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); optim_method (string) – Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:175189,Availability,error,error,175189," Note this is overridden by alg_params (if given there); num_coeffs (integer) – Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); optim_method (string) – Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used.; method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_type (string) – Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); dyn_params (dict) – Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; prop_type (string) – Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details); prop_params (dict) – Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; fid_type (string) – Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:176024,Availability,error,error,176024,"he scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_type (string) – Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); dyn_params (dict) – Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; prop_type (string) – Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details); prop_params (dict) – Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; fid_type (string) – Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details); fid_params (dict) – Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; tslot_type (string) – Method for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details); tslot_params (dict) – Parameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; guess_pulse_type (string) – type / shape of pulse(s) used modulate the control amplitudes.; Options include:. RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW, GAUSSIAN; Default is None. guess_pulse_params (dict) – Parameters for the guess p",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:176044,Availability,error,error,176044,"he scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_type (string) – Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); dyn_params (dict) – Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; prop_type (string) – Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details); prop_params (dict) – Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; fid_type (string) – Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details); fid_params (dict) – Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; tslot_type (string) – Method for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details); tslot_params (dict) – Parameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; guess_pulse_type (string) – type / shape of pulse(s) used modulate the control amplitudes.; Options include:. RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW, GAUSSIAN; Default is None. guess_pulse_params (dict) – Parameters for the guess p",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:179058,Availability,error,error,179058," assumed to be attribute name value pairs; They applied after the object is created; log_level (integer) – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; out_file_ext (string or None) – files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files; gen_stats (boolean) – if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt – Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. Return type:OptimResult. opt_pulse_crab_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:179832,Availability,error,error,179832,"t of files; gen_stats (boolean) – if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt – Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. Return type:OptimResult. opt_pulse_crab_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters:; H_d (Qobj or list of Qobj) – Drift (aka sy",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:180572,Availability,error,error,180572,"ams=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters:; H_d (Qobj or list of Qobj) – Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift; H_c (Qobj) – a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; U_0 (Qobj) – starting point for the evolution.; Typically the identity matrix; U_targ (Qobj) – target transformation, e.g. gate or state, for the time evolution; num_tslots (integer or None) – number of timeslots.; None implies that timeslots will be given in the tau array; evo_time (float or None) – total time for the evolution; None implies that timeslots will be given in the tau array; tau (array[num_tslots] of floats or None) – durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will b",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:180592,Availability,error,error,180592,"ams=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters:; H_d (Qobj or list of Qobj) – Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift; H_c (Qobj) – a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; U_0 (Qobj) – starting point for the evolution.; Typically the identity matrix; U_targ (Qobj) – target transformation, e.g. gate or state, for the time evolution; num_tslots (integer or None) – number of timeslots.; None implies that timeslots will be given in the tau array; evo_time (float or None) – total time for the evolution; None implies that timeslots will be given in the tau array; tau (array[num_tslots] of floats or None) – durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will b",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:181999,Availability,error,error,181999,"(Qobj or list of Qobj) – Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift; H_c (Qobj) – a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; U_0 (Qobj) – starting point for the evolution.; Typically the identity matrix; U_targ (Qobj) – target transformation, e.g. gate or state, for the time evolution; num_tslots (integer or None) – number of timeslots.; None implies that timeslots will be given in the tau array; evo_time (float or None) – total time for the evolution; None implies that timeslots will be given in the tau array; tau (array[num_tslots] of floats or None) – durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots; amp_lbound (float or list of floats) – lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control; amp_ubound (float or list of floats) – upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control; fid_err_targ (float) – Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value; max_iter (integer) – Maximum number of iterations of the optimisation algorithm; max_wall_time (float) – Maximum allowed elapsed time for the optimisation algorithm; alg_params (Dictionary) – options that are specific to the algorithm see above; optim_params (Dictionary) – The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; coeff_scaling (float) – Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Not",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:182066,Availability,error,error,182066,"evo_time (float or None) – total time for the evolution; None implies that timeslots will be given in the tau array; tau (array[num_tslots] of floats or None) – durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots; amp_lbound (float or list of floats) – lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control; amp_ubound (float or list of floats) – upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control; fid_err_targ (float) – Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value; max_iter (integer) – Maximum number of iterations of the optimisation algorithm; max_wall_time (float) – Maximum allowed elapsed time for the optimisation algorithm; alg_params (Dictionary) – options that are specific to the algorithm see above; optim_params (Dictionary) – The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; coeff_scaling (float) – Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); num_coeffs (integer) – Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); optim_method (string) – Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:183759,Availability,error,error,183759," Note this is overridden by alg_params (if given there); num_coeffs (integer) – Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); optim_method (string) – Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used.; method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option (string) – determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params (dict) – Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; prop_params (dict) – Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; fid_params (dict) – Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; tslot_type (string) – Method for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details); tslot_params (d",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:187144,Availability,error,error,187144," assumed to be attribute name value pairs; They applied after the object is created; log_level (integer) – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; out_file_ext (string or None) – files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files; gen_stats (boolean) – if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt – Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. Return type:OptimResult. Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details. create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None)[source]¶; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot; These are the other non-periodic options:. LIN - Linear, i.e. contant gradient over the tim",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:36755,Deployability,configurat,configuration,36755," less than full-rank,; zero eigenvalues may become slightly negative, such that the; returned operator is not actually completely positive. Parameters:; N (int) – Square root of the dimension of the superoperator to be returned.; enforce_tp (bool) – If True, the trace-preserving condition of [BCSZ08] is enforced;; otherwise only complete positivity is enforced.; rank (int or None) – Rank of the sampled superoperator. If None, a full-rank; superoperator is generated.; dims (list) – Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[[N],[N]], [[N],[N]]]. Returns:rho – A superoperator acting on vectorized dim × dim density operators,; sampled from the BCSZ distribution. Return type:Qobj. Three-Level Atoms¶; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations:; Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; The naming of qutip operators follows the convention in [R1] . [R1]Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()[source]¶; Basis states for a three level atom. Returns:states – array of three level atom basis vectors. Return type:array. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns:ops – array of three level operators. Return type:array. Superoperators and Liouvillians¶. operator_to_vector(op)[source]¶; Create a vector representation of a quantum operator given; the matrix representation.",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:36844,Deployability,configurat,configurations,36844,"operator to be returned.; enforce_tp (bool) – If True, the trace-preserving condition of [BCSZ08] is enforced;; otherwise only complete positivity is enforced.; rank (int or None) – Rank of the sampled superoperator. If None, a full-rank; superoperator is generated.; dims (list) – Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[[N],[N]], [[N],[N]]]. Returns:rho – A superoperator acting on vectorized dim × dim density operators,; sampled from the BCSZ distribution. Return type:Qobj. Three-Level Atoms¶; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations:; Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; The naming of qutip operators follows the convention in [R1] . [R1]Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()[source]¶; Basis states for a three level atom. Returns:states – array of three level atom basis vectors. Return type:array. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns:ops – array of three level operators. Return type:array. Superoperators and Liouvillians¶. operator_to_vector(op)[source]¶; Create a vector representation of a quantum operator given; the matrix representation. vector_to_operator(op)[source]¶; Create a matrix representation given a quantum operator in; vector form. liouvillian(H, c_ops=[], data_only=False, chi=None)[source]¶; Assembles the Liouvillian superoper",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:50320,Deployability,continuous,continuous,50320," matrices A & B. Parameters:; A (qobj) – Density matrix or state vector.; B (qobj) – Density matrix or state vector with same dimensions as A. Returns:dist – Hilbert-Schmidt distance between density matrices. Return type:float. Notes; See V. Vedral and M. B. Plenio, Phys. Rev. A 57, 1619 (1998). average_gate_fidelity(oper, target=None)[source]¶; Given a Qobj representing the supermatrix form of a map, returns the; average gate fidelity (pseudo-metric) of that map. Parameters:; A (Qobj) – Quantum object representing a superoperator.; target (Qobj) – Quantum object representing the target unitary; the inverse; is applied before evaluating the fidelity. Returns:fid – Fidelity pseudo-metric between A and the identity superoperator,; or between A and the target superunitary. Return type:float. process_fidelity(U1, U2, normalize=True)[source]¶; Calculate the process fidelity given two process operators. Continous Variables¶; This module contains a collection functions for calculating continuous variable; quantities from fock-basis representation of the state of multi-mode fields. correlation_matrix(basis, rho=None)[source]¶; Given a basis set of operators \(\{a\}_n\), calculate the correlation; matrix:. \[C_{mn} = \langle a_m a_n \rangle\]. Parameters:; basis (list) – List of operators that defines the basis for the correlation matrix.; rho (Qobj) – Density matrix for which to calculate the correlation matrix. If; rho is None, then a matrix of correlation matrix operators is; returned instead of expectation values of those operators. Returns:corr_mat – A 2-dimensional array of correlation values or operators. Return type:ndarray. covariance_matrix(basis, rho, symmetrized=True)[source]¶; Given a basis set of operators \(\{a\}_n\), calculate the covariance; matrix:. \[V_{mn} = \frac{1}{2}\langle a_m a_n + a_n a_m \rangle -; \langle a_m \rangle \langle a_n\rangle\]; or, if of the optional argument symmetrized=False,. \[V_{mn} = \langle a_m a_n\rangle -; \langle a_m \rangle \",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:54758,Deployability,integrat,integrating,54758,"late the covariance matrix. Returns:cov_mat – A 2-dimensional array of covariance values. Return type:ndarray. logarithmic_negativity(V)[source]¶; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see qutip.continous_variables.covariance_matrix. Note that; the two-mode field state that is described by V must be Gaussian for this; function to applicable. Parameters:V (2d array) – The covariance matrix. Returns:N – The logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. Return type:float. Dynamics and Time-Evolution¶. Schrödinger Equation¶; This module provides solvers for the unitary Schrodinger equation. sesolve(H, rho0, tlist, e_ops=[], args={}, options=None, progress_bar=<qutip.ui.progressbar.BaseProgressBar object>, _safe_mode=True)[source]¶; Schrodinger equation evolution of a state vector for a given Hamiltonian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian (H), by integrating the set of ordinary differential; equations that define the system.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. Parameters:; H (qutip.qobj) – system Hamiltonian, or a callback function for time-dependent; Hamiltonians.; rho0 (qutip.qobj) – initial density matrix or state vector (ket).; tlist (list / array) – list of times for \(t\).; e_ops (list of qutip.qobj / callback function single) – single operator or list of operators for which to evaluate; expectation values.; args (dictionary) – dictionary of parameters for time-dependent Hamiltonians and; collapse operators.; options (qutip.Qdeoptions) – with options for the ODE solver. Returns:output – An instance of the class qutip.solver, which contains either; an array of ex",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:56540,Deployability,integrat,integrating,56540,"ary) – dictionary of parameters for time-dependent Hamiltonians and; collapse operators.; options (qutip.Qdeoptions) – with options for the ODE solver. Returns:output – An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors or density matrices corresponding to the; times in tlist [if e_ops is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. Return type:qutip.solver. Master Equation¶; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops=[], e_ops=[], args={}, options=None, progress_bar=None, _safe_mode=True)[source]¶; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian (H) and an [optional] set of collapse operators; (c_ops), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; If either H or the Qobj elements in c_ops are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows to solve master equations that are not on standard Lindblad; form by passing a custom Liouvillian in place of either the H or c_ops; elements.; Time-dependent operators; For time-dependent problems, H and c_ops can be callback; functions that takes two arguments, time and args, and returns the; Hamiltonian or Liouvillian",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:58824,Deployability,integrat,integration,58824,"ent for the corresponding operator, or a NumPy array (list; array format) which specifies the value of the coefficient to the; corresponding operator for each value of t in tlist.; Examples. H = [[H0, ‘sin(w*t)’], [H1, ‘sin(2*w*t)’]]; H = [[H0, f0_t], [H1, f1_t]]; where f0_t and f1_t are python functions with signature f_t(t, args).; H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the list string format and list callback format, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as second argument.; Additional options; Additional options to mesolve can be set via the options argument, which; should be an instance of qutip.solver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using mesolve for solving master; equations that are not on standard Lindblad form. Note; On using callback function: mesolve transforms all qutip.qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.qobj in; args and handle the conversion to sparse matrices. All other; qutip.qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters:; H (qutip.Qobj) – System Hamiltonia",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:59463,Deployability,integrat,integrator,59463,"number (coefficient for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as second argument.; Additional options; Additional options to mesolve can be set via the options argument, which; should be an instance of qutip.solver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using mesolve for solving master; equations that are not on standard Lindblad form. Note; On using callback function: mesolve transforms all qutip.qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.qobj in; args and handle the conversion to sparse matrices. All other; qutip.qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters:; H (qutip.Qobj) – System Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian.; rho0 (qutip.Qobj) – initial density matrix or state vector (ket).; tlist (list / array) – list of times for \(t\).; c_ops (list of qutip.Qobj) – single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators.; e_ops (list of qutip.Qobj / callback function single) – single operator or list of operators for which to evaluate; expectation values.; args (dictionary) – dictionary of parameters",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:59800,Deployability,integrat,integrator,59800,"olver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using mesolve for solving master; equations that are not on standard Lindblad form. Note; On using callback function: mesolve transforms all qutip.qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.qobj in; args and handle the conversion to sparse matrices. All other; qutip.qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters:; H (qutip.Qobj) – System Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian.; rho0 (qutip.Qobj) – initial density matrix or state vector (ket).; tlist (list / array) – list of times for \(t\).; c_ops (list of qutip.Qobj) – single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators.; e_ops (list of qutip.Qobj / callback function single) – single operator or list of operators for which to evaluate; expectation values.; args (dictionary) – dictionary of parameters for time-dependent Hamiltonians and; collapse operators.; options (qutip.Options) – with options for the solver.; progress_bar (BaseProgressBar) – Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns:result – An instance of the class qutip.Result, which contains; either an array result.expect of ",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:143536,Deployability,configurat,configuration,143536,"d, based on a set of; precomputed dynamical maps. Parameters:; dynmaps (list of qutip.Qobj) – List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time.; rho0 (qutip.Qobj) – Initial density matrix or state vector (ket).; times (array_like) – list of times \(t_n\) at which to compute \(\rho(t_n)\).; Must be uniformily spaced.; e_ops (list of qutip.Qobj / callback function) – single operator or list of operators for which to evaluate; expectation values.; learningtimes (array_like) – list of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\).; tensors (array_like) – optional list of precomputed tensors \(T_k\); kwargs (dictionary) – Optional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns:output – An instance of the class qutip.solver.Result. Return type:qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The C",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:163353,Deployability,configurat,configuration,163353,"n for termination, final fidelity error, final evolution; final amplitudes, statistics etc. Return type:OptimResult. create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, gen_stats=False)[source]¶; Generate the objects of the appropriate subclasses; required for the pulse optmisation based on the parameters given; Note this method may be preferable to calling optimize_pulse; if more detailed configuration is required before running the; optmisation algorthim, or the algorithm will be run many times,; for instances when trying to finding global the optimum or; minimum time optimisation. Parameters:; drift (Qobj or list of Qobj) – the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift; ctrls (List of Qobj) – a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; initial (Qobj) – starting point for the evolution.; Typically the identity matrix; target (Qobj) – target transformation, e.g. gate or state, for the time evolution; num_tslots (integer or None) – number of timeslots.; None implies that timeslots will be given in the tau array; evo_time (float or None) – total time for the evolution; None implies that timeslots will be given in the tau array; tau (array[num_tslots] of floats or None) – durations for the timeslots",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:204027,Deployability,update,updated,204027,"Client) – The IPython.parallel Client instance that will be used in the; parfor execution.; view (a IPython.parallel.Client view) – The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view().; show_scheduling (bool {False, True}, default False) – Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster.; show_progressbar (bool {False, True}, default False) – Display a HTML-based progress bar during the execution of the parfor; loop. Returns:result – The result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. Return type:list. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns:version_table – Return an HTML-formatted string containing version information for; QuTiP dependencies. Return type:string. Miscellaneous¶. about()[source]¶; About box for QuTiP. Gives version numbers for; QuTiP, NumPy, SciPy, Cython, and MatPlotLib. simdiag(ops, evals=True)[source]¶; Simulateous diagonalization of communting Hermitian matrices.. Parameters:ops (list/array) – list or array of qobjs representing commuting Hermitian; operators. Returns:eigs – Tuple of arrays representing eigvecs and eigvals of quantum objects; corresponding to simultaneous eigenvectors and eigenvalues for each; operator. Return type:tuple. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:18405,Energy Efficiency,charge,charge,18405,"e = oper, isHerm = True; Qobj data =; [[ 0.5 0. 0. 0. 0. ]; [ 0. 0.25 0. 0. 0. ]; [ 0. 0. 0.125 0. 0. ]; [ 0. 0. 0. 0.0625 0. ]; [ 0. 0. 0. 0. 0.03125]]. Notes; The ‘operator’ method (default) generates; the thermal state using the truncated number operator num(N). This; is the method that should be used in computations. The; ‘analytic’ method uses the analytic coefficients derived in; an infinite Hilbert space. The analytic form is not necessarily normalized,; if truncated too aggressively. zero_ket(N, dims=None)[source]¶; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters:; N (int) – Hilbert space dimensionality; dims (list) – Optional dimensions if ket corresponds to; a composite Hilbert space. Returns:zero_ket – Zero ket on given Hilbert space. Return type:qobj. Quantum Operators¶; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]¶; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters:; Nmax (int) – Maximum charge state to consider.; Nmin (int (default = -Nmax)) – Lowest charge state to consider.; frac (float (default = 1)) – Specify fractional charge if needed. Returns:C – Charge operator over [Nmin,Nmax]. Return type:Qobj. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]¶; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]¶; Creation (raising) operator. Parameters:N (int) – Dimension of Hilbert space. Returns:; oper (qobj) – Qobj for raising operator.; offset (int (default 0)) – The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4); Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j];",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:18469,Energy Efficiency,charge,charge,18469,"e = oper, isHerm = True; Qobj data =; [[ 0.5 0. 0. 0. 0. ]; [ 0. 0.25 0. 0. 0. ]; [ 0. 0. 0.125 0. 0. ]; [ 0. 0. 0. 0.0625 0. ]; [ 0. 0. 0. 0. 0.03125]]. Notes; The ‘operator’ method (default) generates; the thermal state using the truncated number operator num(N). This; is the method that should be used in computations. The; ‘analytic’ method uses the analytic coefficients derived in; an infinite Hilbert space. The analytic form is not necessarily normalized,; if truncated too aggressively. zero_ket(N, dims=None)[source]¶; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters:; N (int) – Hilbert space dimensionality; dims (list) – Optional dimensions if ket corresponds to; a composite Hilbert space. Returns:zero_ket – Zero ket on given Hilbert space. Return type:qobj. Quantum Operators¶; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]¶; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters:; Nmax (int) – Maximum charge state to consider.; Nmin (int (default = -Nmax)) – Lowest charge state to consider.; frac (float (default = 1)) – Specify fractional charge if needed. Returns:C – Charge operator over [Nmin,Nmax]. Return type:Qobj. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]¶; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]¶; Creation (raising) operator. Parameters:N (int) – Dimension of Hilbert space. Returns:; oper (qobj) – Qobj for raising operator.; offset (int (default 0)) – The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4); Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j];",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:18490,Energy Efficiency,charge,charge,18490,"e = oper, isHerm = True; Qobj data =; [[ 0.5 0. 0. 0. 0. ]; [ 0. 0.25 0. 0. 0. ]; [ 0. 0. 0.125 0. 0. ]; [ 0. 0. 0. 0.0625 0. ]; [ 0. 0. 0. 0. 0.03125]]. Notes; The ‘operator’ method (default) generates; the thermal state using the truncated number operator num(N). This; is the method that should be used in computations. The; ‘analytic’ method uses the analytic coefficients derived in; an infinite Hilbert space. The analytic form is not necessarily normalized,; if truncated too aggressively. zero_ket(N, dims=None)[source]¶; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters:; N (int) – Hilbert space dimensionality; dims (list) – Optional dimensions if ket corresponds to; a composite Hilbert space. Returns:zero_ket – Zero ket on given Hilbert space. Return type:qobj. Quantum Operators¶; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]¶; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters:; Nmax (int) – Maximum charge state to consider.; Nmin (int (default = -Nmax)) – Lowest charge state to consider.; frac (float (default = 1)) – Specify fractional charge if needed. Returns:C – Charge operator over [Nmin,Nmax]. Return type:Qobj. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]¶; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]¶; Creation (raising) operator. Parameters:N (int) – Dimension of Hilbert space. Returns:; oper (qobj) – Qobj for raising operator.; offset (int (default 0)) – The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4); Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j];",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:18558,Energy Efficiency,charge,charge,18558,"0.125 0. 0. ]; [ 0. 0. 0. 0.0625 0. ]; [ 0. 0. 0. 0. 0.03125]]. Notes; The ‘operator’ method (default) generates; the thermal state using the truncated number operator num(N). This; is the method that should be used in computations. The; ‘analytic’ method uses the analytic coefficients derived in; an infinite Hilbert space. The analytic form is not necessarily normalized,; if truncated too aggressively. zero_ket(N, dims=None)[source]¶; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters:; N (int) – Hilbert space dimensionality; dims (list) – Optional dimensions if ket corresponds to; a composite Hilbert space. Returns:zero_ket – Zero ket on given Hilbert space. Return type:qobj. Quantum Operators¶; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]¶; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters:; Nmax (int) – Maximum charge state to consider.; Nmin (int (default = -Nmax)) – Lowest charge state to consider.; frac (float (default = 1)) – Specify fractional charge if needed. Returns:C – Charge operator over [Nmin,Nmax]. Return type:Qobj. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]¶; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]¶; Creation (raising) operator. Parameters:N (int) – Dimension of Hilbert space. Returns:; oper (qobj) – Qobj for raising operator.; offset (int (default 0)) – The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4); Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:18623,Energy Efficiency,charge,charge,18623,". Notes; The ‘operator’ method (default) generates; the thermal state using the truncated number operator num(N). This; is the method that should be used in computations. The; ‘analytic’ method uses the analytic coefficients derived in; an infinite Hilbert space. The analytic form is not necessarily normalized,; if truncated too aggressively. zero_ket(N, dims=None)[source]¶; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters:; N (int) – Hilbert space dimensionality; dims (list) – Optional dimensions if ket corresponds to; a composite Hilbert space. Returns:zero_ket – Zero ket on given Hilbert space. Return type:qobj. Quantum Operators¶; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]¶; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters:; Nmax (int) – Maximum charge state to consider.; Nmin (int (default = -Nmax)) – Lowest charge state to consider.; frac (float (default = 1)) – Specify fractional charge if needed. Returns:C – Charge operator over [Nmin,Nmax]. Return type:Qobj. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]¶; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]¶; Creation (raising) operator. Parameters:N (int) – Dimension of Hilbert space. Returns:; oper (qobj) – Qobj for raising operator.; offset (int (default 0)) – The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4); Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 1.73205081+0.j 0.00000000+0.j]]. destroy(N, offset=0)[s",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:18698,Energy Efficiency,charge,charge,18698,"ate using the truncated number operator num(N). This; is the method that should be used in computations. The; ‘analytic’ method uses the analytic coefficients derived in; an infinite Hilbert space. The analytic form is not necessarily normalized,; if truncated too aggressively. zero_ket(N, dims=None)[source]¶; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters:; N (int) – Hilbert space dimensionality; dims (list) – Optional dimensions if ket corresponds to; a composite Hilbert space. Returns:zero_ket – Zero ket on given Hilbert space. Return type:qobj. Quantum Operators¶; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]¶; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters:; Nmax (int) – Maximum charge state to consider.; Nmin (int (default = -Nmax)) – Lowest charge state to consider.; frac (float (default = 1)) – Specify fractional charge if needed. Returns:C – Charge operator over [Nmin,Nmax]. Return type:Qobj. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]¶; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]¶; Creation (raising) operator. Parameters:N (int) – Dimension of Hilbert space. Returns:; oper (qobj) – Qobj for raising operator.; offset (int (default 0)) – The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4); Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 1.73205081+0.j 0.00000000+0.j]]. destroy(N, offset=0)[source]¶; Destruction (lowering) operator. Parameters:; N (int) – D",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:66797,Energy Efficiency,power,power,66797,"o evaluate expectation values.; c_ops (list of qutip.qobj) – List of system collapse operators.; args (dictionary) – Placeholder for future implementation, kept for API consistency.; options (qutip.solver.Options) – Options for the solver. Returns:result – An instance of the class qutip.solver.Result, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by tlist. Return type:qutip.solver.Result. bloch_redfield_tensor(H, a_ops, spectra_cb, c_ops=[], use_secular=True)[source]¶; Calculate the Bloch-Redfield tensor for a system given a set of operators; and corresponding spectral functions that describes the system’s coupling; to its environment. Note; This tensor generation requires a time-independent Hamiltonian. Parameters:; H (qutip.qobj) – System Hamiltonian.; a_ops (list of qutip.qobj) – List of system operators that couple to the environment.; spectra_cb (list of callback functions) – List of callback functions that evaluate the noise power spectrum; at a given frequency.; c_ops (list of qutip.qobj) – List of system collapse operators.; use_secular (bool) – Flag (True of False) that indicates if the secular approximation should; be used. Returns:R, kets – R is the Bloch-Redfield tensor and kets is a list eigenstates of the; Hamiltonian. Return type:qutip.Qobj, list of qutip.Qobj. bloch_redfield_solve(R, ekets, rho0, tlist, e_ops=[], options=None)[source]¶; Evolve the ODEs defined by Bloch-Redfield master equation. The; Bloch-Redfield tensor can be calculated by the function; bloch_redfield_tensor. Parameters:; R (qutip.qobj) – Bloch-Redfield tensor.; ekets (array of qutip.qobj) – Array of kets that make up a basis tranformation for the eigenbasis.; rho0 (qutip.qobj) – Initial density matrix.; tlist (list / array) – List of times for \(t\).; e_ops (list of qutip.qobj / callback function) – List of operators for which to evaluate expectation values.; options (qutip.Qdeoptions) – Options fo",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:68750,Energy Efficiency,power,power,68750,"Qdeoptions) – Options for the ODE solver. Returns:output – An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. Return type:qutip.solver. Floquet States and Floquet-Markov Master Equation¶. fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None, args={}, options=<qutip.solver.Options object>, floquet_basis=True, kmax=5, _safe_mode=True)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters:; H (qutip.qobj) – system Hamiltonian.; / psi0 (rho0) – initial density matrix or state vector (ket).; tlist (list / array) – list of times for \(t\).; c_ops (list of qutip.qobj) – list of collapse operators.; e_ops (list of qutip.qobj / callback function) – list of operators for which to evaluate expectation values.; spectra_cb (list callback functions) – List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops.; T (float) – The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving.; args (dictionary) – dictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry ‘w_th’, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options (qutip.solver) – options for the ODE solver.; k_max (int) – The truncation of the number of sidebands (default 5). Returns:output – An instance of the class qutip.solver, which contains either; an array of expectation values",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:69210,Energy Efficiency,energy,energy,69210,"ource]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters:; H (qutip.qobj) – system Hamiltonian.; / psi0 (rho0) – initial density matrix or state vector (ket).; tlist (list / array) – list of times for \(t\).; c_ops (list of qutip.qobj) – list of collapse operators.; e_ops (list of qutip.qobj / callback function) – list of operators for which to evaluate expectation values.; spectra_cb (list callback functions) – List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops.; T (float) – The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving.; args (dictionary) – dictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry ‘w_th’, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options (qutip.solver) – options for the ODE solver.; k_max (int) – The truncation of the number of sidebands (default 5). Returns:output – An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. Return type:qutip.solver. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter sort; decides if ",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:97453,Energy Efficiency,power,power,97453,"ecified in wlist. Return type:array. spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False)[source]¶; Calculate the spectrum of the correlation function; \(\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\),; i.e., the Fourier transform of the correlation function:. \[S(\omega) = \int_{-\infty}^{\infty}; \lim_{t \to \infty} \left<A(t+\tau)B(t)\right>; e^{-i\omega\tau} d\tau.\]; using a psuedo-inverse method. Note: this spectrum is only defined for; stationary statistics (uses steady state rho0). Parameters:; H (qutip.qobj) – system Hamiltonian.; wlist (array_like) – list of frequencies for \(\omega\).; c_ops (list of qutip.qobj) – list of collapse operators.; a_op (qutip.qobj) – operator A.; b_op (qutip.qobj) – operator B.; use_pinv (bool) – If True use numpy’s pinv method, otherwise use a generic solver. Returns:spectrum – An array with spectrum \(S(\omega)\) for the frequencies; specified in wlist. Return type:array. spectrum_correlation_fft(taulist, y)[source]¶; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters:; tlist (array_like) – list/array of times \(t\) which the correlation function is given.; y (array_like) – list/array of correlations corresponding to time delays \(t\). Returns:w, S – Returns an array of angular frequencies ‘w’ and the corresponding; one-sided power spectrum ‘S(w)’. Return type:tuple. coherence_function_g1(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized first-order quantum coherence function:. \[g^{(1)}(\tau) =; \frac{\langle A^\dagger(\tau)A(0)\rangle}; {\sqrt{\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters:; H (Qobj) – system Hamiltonian, may be time-dependent for solver choice of me or; mc.; state0 (Qobj) – Initial state density matrix \(\rho(t_0)\) or state vector; \(\ps",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:97803,Energy Efficiency,power,power,97803,"im_{t \to \infty} \left<A(t+\tau)B(t)\right>; e^{-i\omega\tau} d\tau.\]; using a psuedo-inverse method. Note: this spectrum is only defined for; stationary statistics (uses steady state rho0). Parameters:; H (qutip.qobj) – system Hamiltonian.; wlist (array_like) – list of frequencies for \(\omega\).; c_ops (list of qutip.qobj) – list of collapse operators.; a_op (qutip.qobj) – operator A.; b_op (qutip.qobj) – operator B.; use_pinv (bool) – If True use numpy’s pinv method, otherwise use a generic solver. Returns:spectrum – An array with spectrum \(S(\omega)\) for the frequencies; specified in wlist. Return type:array. spectrum_correlation_fft(taulist, y)[source]¶; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters:; tlist (array_like) – list/array of times \(t\) which the correlation function is given.; y (array_like) – list/array of correlations corresponding to time delays \(t\). Returns:w, S – Returns an array of angular frequencies ‘w’ and the corresponding; one-sided power spectrum ‘S(w)’. Return type:tuple. coherence_function_g1(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized first-order quantum coherence function:. \[g^{(1)}(\tau) =; \frac{\langle A^\dagger(\tau)A(0)\rangle}; {\sqrt{\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters:; H (Qobj) – system Hamiltonian, may be time-dependent for solver choice of me or; mc.; state0 (Qobj) – Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers.; taulist (array_like) – list of times for \(\tau\). taulist must be positive and contain; the element 0.; c_ops (list) – list of collapse operators, m",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:101561,Energy Efficiency,power,power,101561,"rsively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:g2, G2 – The normalized and unnormalized second-order coherence function. Return type:tuple. Steady-state Solvers¶; Module contains functions for solving for the steady state density matrix of; open quantum systems defined by a Liouvillian or Hamiltonian and a list of; collapse operators. steadystate(A, c_op_list=[], **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters:; A (qobj) – A Hamiltonian or Liouvillian operator.; c_op_list (list) – A list of collapse operators.; method (str {'direct', 'eigen', 'iterative-gmres',) – ; ‘iterative-lgmres’, ‘iterative-bicgstab’, ‘svd’, ‘power’,; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’}. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’,; iterative GMRES method ‘iterative-gmres’, iterative LGMRES method; ‘iterative-lgmres’, iterative BICGSTAB method ‘iterative-bicgstab’,; SVD ‘svd’ (dense), or inverse-power method ‘power’. The iterative; power methods ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use; the same solvers as their direct counterparts. return_info (bool, optional, default = False) – Return a dictionary of solver-specific infomation about the; solution and how it was obtained.; sparse (bool, optional, default = True) – Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems.; use_rcm (bool, optional, default = False) – Use reverse Cuthill-Mckee reordering to minimize fill-in in the; ",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:101571,Energy Efficiency,power,power-gmres,101571,"rsively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:g2, G2 – The normalized and unnormalized second-order coherence function. Return type:tuple. Steady-state Solvers¶; Module contains functions for solving for the steady state density matrix of; open quantum systems defined by a Liouvillian or Hamiltonian and a list of; collapse operators. steadystate(A, c_op_list=[], **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters:; A (qobj) – A Hamiltonian or Liouvillian operator.; c_op_list (list) – A list of collapse operators.; method (str {'direct', 'eigen', 'iterative-gmres',) – ; ‘iterative-lgmres’, ‘iterative-bicgstab’, ‘svd’, ‘power’,; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’}. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’,; iterative GMRES method ‘iterative-gmres’, iterative LGMRES method; ‘iterative-lgmres’, iterative BICGSTAB method ‘iterative-bicgstab’,; SVD ‘svd’ (dense), or inverse-power method ‘power’. The iterative; power methods ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use; the same solvers as their direct counterparts. return_info (bool, optional, default = False) – Return a dictionary of solver-specific infomation about the; solution and how it was obtained.; sparse (bool, optional, default = True) – Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems.; use_rcm (bool, optional, default = False) – Use reverse Cuthill-Mckee reordering to minimize fill-in in the; ",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:101586,Energy Efficiency,power,power-lgmres,101586,"rsively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:g2, G2 – The normalized and unnormalized second-order coherence function. Return type:tuple. Steady-state Solvers¶; Module contains functions for solving for the steady state density matrix of; open quantum systems defined by a Liouvillian or Hamiltonian and a list of; collapse operators. steadystate(A, c_op_list=[], **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters:; A (qobj) – A Hamiltonian or Liouvillian operator.; c_op_list (list) – A list of collapse operators.; method (str {'direct', 'eigen', 'iterative-gmres',) – ; ‘iterative-lgmres’, ‘iterative-bicgstab’, ‘svd’, ‘power’,; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’}. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’,; iterative GMRES method ‘iterative-gmres’, iterative LGMRES method; ‘iterative-lgmres’, iterative BICGSTAB method ‘iterative-bicgstab’,; SVD ‘svd’ (dense), or inverse-power method ‘power’. The iterative; power methods ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use; the same solvers as their direct counterparts. return_info (bool, optional, default = False) – Return a dictionary of solver-specific infomation about the; solution and how it was obtained.; sparse (bool, optional, default = True) – Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems.; use_rcm (bool, optional, default = False) – Use reverse Cuthill-Mckee reordering to minimize fill-in in the; ",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:101602,Energy Efficiency,power,power-bicgstab,101602,"rsively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:g2, G2 – The normalized and unnormalized second-order coherence function. Return type:tuple. Steady-state Solvers¶; Module contains functions for solving for the steady state density matrix of; open quantum systems defined by a Liouvillian or Hamiltonian and a list of; collapse operators. steadystate(A, c_op_list=[], **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters:; A (qobj) – A Hamiltonian or Liouvillian operator.; c_op_list (list) – A list of collapse operators.; method (str {'direct', 'eigen', 'iterative-gmres',) – ; ‘iterative-lgmres’, ‘iterative-bicgstab’, ‘svd’, ‘power’,; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’}. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’,; iterative GMRES method ‘iterative-gmres’, iterative LGMRES method; ‘iterative-lgmres’, iterative BICGSTAB method ‘iterative-bicgstab’,; SVD ‘svd’ (dense), or inverse-power method ‘power’. The iterative; power methods ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use; the same solvers as their direct counterparts. return_info (bool, optional, default = False) – Return a dictionary of solver-specific infomation about the; solution and how it was obtained.; sparse (bool, optional, default = True) – Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems.; use_rcm (bool, optional, default = False) – Use reverse Cuthill-Mckee reordering to minimize fill-in in the; ",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:101911,Energy Efficiency,power,power,101911,"e contains functions for solving for the steady state density matrix of; open quantum systems defined by a Liouvillian or Hamiltonian and a list of; collapse operators. steadystate(A, c_op_list=[], **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters:; A (qobj) – A Hamiltonian or Liouvillian operator.; c_op_list (list) – A list of collapse operators.; method (str {'direct', 'eigen', 'iterative-gmres',) – ; ‘iterative-lgmres’, ‘iterative-bicgstab’, ‘svd’, ‘power’,; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’}. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’,; iterative GMRES method ‘iterative-gmres’, iterative LGMRES method; ‘iterative-lgmres’, iterative BICGSTAB method ‘iterative-bicgstab’,; SVD ‘svd’ (dense), or inverse-power method ‘power’. The iterative; power methods ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use; the same solvers as their direct counterparts. return_info (bool, optional, default = False) – Return a dictionary of solver-specific infomation about the; solution and how it was obtained.; sparse (bool, optional, default = True) – Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems.; use_rcm (bool, optional, default = False) – Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian.; use_wbm (bool, optional, default = False) – Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:101925,Energy Efficiency,power,power,101925,"e contains functions for solving for the steady state density matrix of; open quantum systems defined by a Liouvillian or Hamiltonian and a list of; collapse operators. steadystate(A, c_op_list=[], **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters:; A (qobj) – A Hamiltonian or Liouvillian operator.; c_op_list (list) – A list of collapse operators.; method (str {'direct', 'eigen', 'iterative-gmres',) – ; ‘iterative-lgmres’, ‘iterative-bicgstab’, ‘svd’, ‘power’,; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’}. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’,; iterative GMRES method ‘iterative-gmres’, iterative LGMRES method; ‘iterative-lgmres’, iterative BICGSTAB method ‘iterative-bicgstab’,; SVD ‘svd’ (dense), or inverse-power method ‘power’. The iterative; power methods ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use; the same solvers as their direct counterparts. return_info (bool, optional, default = False) – Return a dictionary of solver-specific infomation about the; solution and how it was obtained.; sparse (bool, optional, default = True) – Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems.; use_rcm (bool, optional, default = False) – Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian.; use_wbm (bool, optional, default = False) – Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:101948,Energy Efficiency,power,power,101948,"], **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters:; A (qobj) – A Hamiltonian or Liouvillian operator.; c_op_list (list) – A list of collapse operators.; method (str {'direct', 'eigen', 'iterative-gmres',) – ; ‘iterative-lgmres’, ‘iterative-bicgstab’, ‘svd’, ‘power’,; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’}. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’,; iterative GMRES method ‘iterative-gmres’, iterative LGMRES method; ‘iterative-lgmres’, iterative BICGSTAB method ‘iterative-bicgstab’,; SVD ‘svd’ (dense), or inverse-power method ‘power’. The iterative; power methods ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use; the same solvers as their direct counterparts. return_info (bool, optional, default = False) – Return a dictionary of solver-specific infomation about the; solution and how it was obtained.; sparse (bool, optional, default = True) – Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems.; use_rcm (bool, optional, default = False) – Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian.; use_wbm (bool, optional, default = False) – Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner.; weight (float, optional) – Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvill",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:101963,Energy Efficiency,power,power-gmres,101963,"], **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters:; A (qobj) – A Hamiltonian or Liouvillian operator.; c_op_list (list) – A list of collapse operators.; method (str {'direct', 'eigen', 'iterative-gmres',) – ; ‘iterative-lgmres’, ‘iterative-bicgstab’, ‘svd’, ‘power’,; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’}. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’,; iterative GMRES method ‘iterative-gmres’, iterative LGMRES method; ‘iterative-lgmres’, iterative BICGSTAB method ‘iterative-bicgstab’,; SVD ‘svd’ (dense), or inverse-power method ‘power’. The iterative; power methods ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use; the same solvers as their direct counterparts. return_info (bool, optional, default = False) – Return a dictionary of solver-specific infomation about the; solution and how it was obtained.; sparse (bool, optional, default = True) – Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems.; use_rcm (bool, optional, default = False) – Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian.; use_wbm (bool, optional, default = False) – Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner.; weight (float, optional) – Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvill",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:101978,Energy Efficiency,power,power-lgmres,101978,"], **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters:; A (qobj) – A Hamiltonian or Liouvillian operator.; c_op_list (list) – A list of collapse operators.; method (str {'direct', 'eigen', 'iterative-gmres',) – ; ‘iterative-lgmres’, ‘iterative-bicgstab’, ‘svd’, ‘power’,; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’}. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’,; iterative GMRES method ‘iterative-gmres’, iterative LGMRES method; ‘iterative-lgmres’, iterative BICGSTAB method ‘iterative-bicgstab’,; SVD ‘svd’ (dense), or inverse-power method ‘power’. The iterative; power methods ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use; the same solvers as their direct counterparts. return_info (bool, optional, default = False) – Return a dictionary of solver-specific infomation about the; solution and how it was obtained.; sparse (bool, optional, default = True) – Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems.; use_rcm (bool, optional, default = False) – Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian.; use_wbm (bool, optional, default = False) – Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner.; weight (float, optional) – Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvill",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:101994,Energy Efficiency,power,power-bicgstab,101994,"], **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters:; A (qobj) – A Hamiltonian or Liouvillian operator.; c_op_list (list) – A list of collapse operators.; method (str {'direct', 'eigen', 'iterative-gmres',) – ; ‘iterative-lgmres’, ‘iterative-bicgstab’, ‘svd’, ‘power’,; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’}. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’,; iterative GMRES method ‘iterative-gmres’, iterative LGMRES method; ‘iterative-lgmres’, iterative BICGSTAB method ‘iterative-bicgstab’,; SVD ‘svd’ (dense), or inverse-power method ‘power’. The iterative; power methods ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use; the same solvers as their direct counterparts. return_info (bool, optional, default = False) – Return a dictionary of solver-specific infomation about the; solution and how it was obtained.; sparse (bool, optional, default = True) – Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems.; use_rcm (bool, optional, default = False) – Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian.; use_wbm (bool, optional, default = False) – Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner.; weight (float, optional) – Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvill",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:104571,Energy Efficiency,reduce,reduced,104571,"se) – ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the ‘iterative’ GMRES and BICG solvers.; Speeds up convergence time by orders of magnitude in many cases.; M ({sparse matrix, dense matrix, LinearOperator}, optional) – ITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner is given and use_precond = True, then one; is generated automatically.; fill_factor (float, optional, default = 100) – ITERATIVE ONLY. Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization.; drop_tol (float, optional, default = 1e-4) – ITERATIVE ONLY. Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization.; diag_pivot_thresh (float, optional, default = None) – ITERATIVE ONLY. Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element.; ILU_MILU (str, optional, default = 'smilu_2') – ITERATIVE ONLY. Selects the incomplete LU decomposition method; algoithm used in creating the preconditoner. Should only be used by; advanced users. Returns:; dm (qobj) – Steady state density matrix.; info (dict, optional) – Dictionary containing solver-specific information about the solution. Notes; The SVD method works only for dense operators (i.e. small systems). build_preconditioner(A, c_op_list=[], **kwargs)[source]¶; Constructs a iLU preconditioner necessary for solving for; the steady state density matrix using the iterative linear solvers; in the ‘steadystate’ function. Parameters:; A (qobj) – A Hamilto",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:106641,Energy Efficiency,power,power,106641,"or.; c_op_list (list) – A list of collapse operators.; return_info (bool, optional, default = False) – Return a dictionary of solver-specific infomation about the; solution and how it was obtained.; use_rcm (bool, optional, default = False) – Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian.; use_wbm (bool, optional, default = False) – Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner.; weight (float, optional) – Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user.; method (str, default = 'iterative') – Tells the preconditioner what type of Liouvillian to build for; iLU factorization. For direct iterative methods use ‘iterative’.; For power iterative methods use ‘power’.; permc_spec (str, optional, default='COLAMD') – Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ and; ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified.; fill_factor (float, optional, default = 100) – Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization.; drop_tol (float, optional, default = 1e-4) – Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization.; diag_pivot_thresh (float, optional, default = None) – Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be ",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:106670,Energy Efficiency,power,power,106670,"or.; c_op_list (list) – A list of collapse operators.; return_info (bool, optional, default = False) – Return a dictionary of solver-specific infomation about the; solution and how it was obtained.; use_rcm (bool, optional, default = False) – Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian.; use_wbm (bool, optional, default = False) – Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner.; weight (float, optional) – Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user.; method (str, default = 'iterative') – Tells the preconditioner what type of Liouvillian to build for; iLU factorization. For direct iterative methods use ‘iterative’.; For power iterative methods use ‘power’.; permc_spec (str, optional, default='COLAMD') – Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ and; ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified.; fill_factor (float, optional, default = 100) – Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization.; drop_tol (float, optional, default = 1e-4) – Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization.; diag_pivot_thresh (float, optional, default = None) – Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be ",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:107304,Energy Efficiency,reduce,reduced,107304,"solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user.; method (str, default = 'iterative') – Tells the preconditioner what type of Liouvillian to build for; iLU factorization. For direct iterative methods use ‘iterative’.; For power iterative methods use ‘power’.; permc_spec (str, optional, default='COLAMD') – Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ and; ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified.; fill_factor (float, optional, default = 100) – Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization.; drop_tol (float, optional, default = 1e-4) – Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization.; diag_pivot_thresh (float, optional, default = None) – Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element.; ILU_MILU (str, optional, default = 'smilu_2') – Selects the incomplete LU decomposition method algoithm used in; creating the preconditoner. Should only be used by advanced users. Returns:; lu (object) – Returns a SuperLU object representing iLU preconditioner.; info (dict, optional) – Dictionary containing solver-specific information. Propagators¶. propagator(H, t, c_op_list=[], args={}, options=None, unitary_mode='batch', parallel=False, progress_bar=None, **kwargs)[source]¶; Calculate the propagator U(t) for the density matrix or wave function such; that \(\psi(t) = U(t)\psi(0)\) or; \(\rho_{\mathrm vec}(t) = U(t) \rho_{\mathrm vec}(0)\); where \(\rho_{\mathrm vec}\) is t",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:113183,Energy Efficiency,efficient,efficient,113183,"Experimental. wigner(psi, xvec, yvec, method='clenshaw', g=1.4142135623730951, sparse=False, parfor=False)[source]¶; Wigner function for a state vector or density matrix at points; xvec + i * yvec. Parameters:; state (qobj) – A state vector or density matrix.; xvec (array_like) – x-coordinates at which to calculate the Wigner function.; yvec (array_like) – y-coordinates at which to calculate the Wigner function. Does not; apply to the ‘fft’ method.; g (float) – Scaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2).; method (string {'clenshaw', 'iterative', 'laguerre', 'fft'}) – Select method ‘clenshaw’ ‘iterative’, ‘laguerre’, or ‘fft’, where ‘clenshaw’; and ‘iterative’ use an iterative method to evaluate the Wigner functions for density; matrices \(|m><n|\), while ‘laguerre’ uses the Laguerre polynomials; in scipy for the same task. The ‘fft’ method evaluates the Fourier; transform of the density matrix. The ‘iterative’ method is default, and; in general recommended, but the ‘laguerre’ method is more efficient for; very sparse density matrices (e.g., superpositions of Fock states in a; large Hilbert space). The ‘clenshaw’ method is the preferred method for; dealing with density matrices that have a large number of excitations; (>~50). ‘clenshaw’ is a fast and numerically stable method.; sparse (bool {False, True}) – Tells the default solver whether or not to keep the input density; matrix in sparse format. As the dimensions of the density matrix; grow, setthing this flag can result in increased performance.; parfor (bool {False, True}) – Flag for calculating the Laguerre polynomial based Wigner function; method=’laguerre’ in parallel using the parfor function. Returns:; W (array) – Values representing the Wigner function calculated over the specified; range [xvec,yvec].; yvex (array) – FFT ONLY. Returns the y-coordinate values calculated via the Fourier; transform. Notes; The ‘fft’ method accepts only an xvec input for the x-coordinate.; The y-coordinates ",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:117224,Energy Efficiency,energy,energy,117224,"udes of matrix M, using the argument; of each element for coloring the bars, with the given x and y labels; and title. Parameters:; M (Matrix of Qobj) – The matrix to visualize; xlabels (list of strings) – list of x labels; ylabels (list of strings) – list of y labels; title (string) – title of the plot (optional); limits (list/array with two float numbers) – The z-axis limits [min, max] (optional); phase_limits (list/array with two float numbers) – The phase-axis (colorbar) limits [min, max] (optional); ax (a matplotlib axes instance) – The axes context in which the plot will be drawn.; threshold (float (None)) – Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns:fig, ax – A tuple of the matplotlib figure and axes instances used to produce; the figure. Return type:tuple. Raises:ValueError – Input argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters:; H_list (List of Qobj) – A list of Hamiltonians.; labels (List of string) – A list of labels for each Hamiltonian; show_ylabels (Bool (default False)) – Show y labels to the left of energy levels of the initial; Hamiltonian.; N (int) – The number of energy levels to plot; figsize (tuple (int,int)) – The size of the figure (width, height).; fig (a matplotlib Figure instance) – The Figure canvas in which the plot will be drawn.; ax (a matplotlib axes instance) – The axes context in which the plot will be drawn. Returns:fig, ax – A tuple of the matplotlib figure and axes instances used to produce; the figure. Return type:tuple. Raises:ValueError – Input argument is not valid. plot_fock_distribution(rh",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:117291,Energy Efficiency,energy,energy,117291,"abels; and title. Parameters:; M (Matrix of Qobj) – The matrix to visualize; xlabels (list of strings) – list of x labels; ylabels (list of strings) – list of y labels; title (string) – title of the plot (optional); limits (list/array with two float numbers) – The z-axis limits [min, max] (optional); phase_limits (list/array with two float numbers) – The phase-axis (colorbar) limits [min, max] (optional); ax (a matplotlib axes instance) – The axes context in which the plot will be drawn.; threshold (float (None)) – Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns:fig, ax – A tuple of the matplotlib figure and axes instances used to produce; the figure. Return type:tuple. Raises:ValueError – Input argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters:; H_list (List of Qobj) – A list of Hamiltonians.; labels (List of string) – A list of labels for each Hamiltonian; show_ylabels (Bool (default False)) – Show y labels to the left of energy levels of the initial; Hamiltonian.; N (int) – The number of energy levels to plot; figsize (tuple (int,int)) – The size of the figure (width, height).; fig (a matplotlib Figure instance) – The Figure canvas in which the plot will be drawn.; ax (a matplotlib axes instance) – The axes context in which the plot will be drawn. Returns:fig, ax – A tuple of the matplotlib figure and axes instances used to produce; the figure. Return type:tuple. Raises:ValueError – Input argument is not valid. plot_fock_distribution(rho, offset=0, fig=None, ax=None, figsize=(8, 6), title=None, unit_y_range=True)[source]¶; Plot the Foc",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:117338,Energy Efficiency,energy,energy,117338,"ings) – list of x labels; ylabels (list of strings) – list of y labels; title (string) – title of the plot (optional); limits (list/array with two float numbers) – The z-axis limits [min, max] (optional); phase_limits (list/array with two float numbers) – The phase-axis (colorbar) limits [min, max] (optional); ax (a matplotlib axes instance) – The axes context in which the plot will be drawn.; threshold (float (None)) – Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns:fig, ax – A tuple of the matplotlib figure and axes instances used to produce; the figure. Return type:tuple. Raises:ValueError – Input argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters:; H_list (List of Qobj) – A list of Hamiltonians.; labels (List of string) – A list of labels for each Hamiltonian; show_ylabels (Bool (default False)) – Show y labels to the left of energy levels of the initial; Hamiltonian.; N (int) – The number of energy levels to plot; figsize (tuple (int,int)) – The size of the figure (width, height).; fig (a matplotlib Figure instance) – The Figure canvas in which the plot will be drawn.; ax (a matplotlib axes instance) – The axes context in which the plot will be drawn. Returns:fig, ax – A tuple of the matplotlib figure and axes instances used to produce; the figure. Return type:tuple. Raises:ValueError – Input argument is not valid. plot_fock_distribution(rho, offset=0, fig=None, ax=None, figsize=(8, 6), title=None, unit_y_range=True)[source]¶; Plot the Fock distribution for a density matrix (or ket) that describes; an oscillator mode. Parameters:; rho ",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:117663,Energy Efficiency,energy,energy,117663,"ith two float numbers) – The phase-axis (colorbar) limits [min, max] (optional); ax (a matplotlib axes instance) – The axes context in which the plot will be drawn.; threshold (float (None)) – Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns:fig, ax – A tuple of the matplotlib figure and axes instances used to produce; the figure. Return type:tuple. Raises:ValueError – Input argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters:; H_list (List of Qobj) – A list of Hamiltonians.; labels (List of string) – A list of labels for each Hamiltonian; show_ylabels (Bool (default False)) – Show y labels to the left of energy levels of the initial; Hamiltonian.; N (int) – The number of energy levels to plot; figsize (tuple (int,int)) – The size of the figure (width, height).; fig (a matplotlib Figure instance) – The Figure canvas in which the plot will be drawn.; ax (a matplotlib axes instance) – The axes context in which the plot will be drawn. Returns:fig, ax – A tuple of the matplotlib figure and axes instances used to produce; the figure. Return type:tuple. Raises:ValueError – Input argument is not valid. plot_fock_distribution(rho, offset=0, fig=None, ax=None, figsize=(8, 6), title=None, unit_y_range=True)[source]¶; Plot the Fock distribution for a density matrix (or ket) that describes; an oscillator mode. Parameters:; rho (qutip.qobj.Qobj) – The density matrix (or ket) of the state to visualize.; fig (a matplotlib Figure instance) – The Figure canvas in which the plot will be drawn.; ax (a matplotlib axes instance) – The axes context in which the p",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:117731,Energy Efficiency,energy,energy,117731,"lot will be drawn.; threshold (float (None)) – Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns:fig, ax – A tuple of the matplotlib figure and axes instances used to produce; the figure. Return type:tuple. Raises:ValueError – Input argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters:; H_list (List of Qobj) – A list of Hamiltonians.; labels (List of string) – A list of labels for each Hamiltonian; show_ylabels (Bool (default False)) – Show y labels to the left of energy levels of the initial; Hamiltonian.; N (int) – The number of energy levels to plot; figsize (tuple (int,int)) – The size of the figure (width, height).; fig (a matplotlib Figure instance) – The Figure canvas in which the plot will be drawn.; ax (a matplotlib axes instance) – The axes context in which the plot will be drawn. Returns:fig, ax – A tuple of the matplotlib figure and axes instances used to produce; the figure. Return type:tuple. Raises:ValueError – Input argument is not valid. plot_fock_distribution(rho, offset=0, fig=None, ax=None, figsize=(8, 6), title=None, unit_y_range=True)[source]¶; Plot the Fock distribution for a density matrix (or ket) that describes; an oscillator mode. Parameters:; rho (qutip.qobj.Qobj) – The density matrix (or ket) of the state to visualize.; fig (a matplotlib Figure instance) – The Figure canvas in which the plot will be drawn.; ax (a matplotlib axes instance) – The axes context in which the plot will be drawn.; title (string) – An optional title for the figure.; figsize ((width, height)) – The size of the matplotlib figure (in inches) ",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:144690,Energy Efficiency,reduce,reduces,144690,"tion in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). optimize_pulse(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:194737,Energy Efficiency,energy,energy,194737,"; if not already included in set.; Returned sample array is not evenly spaced if addtional elements; are added. Parameters:; start (int) – The starting value of the sequence.; stop (int) – The stoping values of the sequence.; num (int, optional) – Number of samples to generate.; elems (list/ndarray, optional) – Requested elements to include in array. Returns:samples – Original equally spaced sample array with additional; elements added. Return type:ndadrray. clebsch(j1, j2, j3, m1, m2, m3)[source]¶; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters:; j1 (float) – Total angular momentum 1.; j2 (float) – Total angular momentum 2.; j3 (float) – Total angular momentum 3.; m1 (float) – z-component of angular momentum 1.; m2 (float) – z-component of angular momentum 2.; m3 (float) – z-component of angular momentum 3. Returns:cg_coeff – Requested Clebsch-Gordan coefficient. Return type:float. convert_unit(value, orig='meV', to='GHz')[source]¶; Convert an energy from unit orig to unit to. Parameters:; value (float / array) – The energy in the old unit.; orig (string) – The name of the original unit (“J”, “eV”, “meV”, “GHz”, “mK”); to (string) – The name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”). Returns:value_new_unit – The energy in the new unit. Return type:float / array. File I/O Functions¶. file_data_read(filename, sep=None)[source]¶; Retrieves an array of data from the requested file. Parameters:; filename (str) – Name of file containing reqested data.; sep (str) – Seperator used to store data. Returns:data – Data from selected file. Return type:array_like. file_data_store(filename, data, numtype='complex', numformat='decimal', sep=', ')[source]¶; Stores a matrix of data to a file to be read by an external program. Parameters:; filename (str) – Name of data file to be stored, including extension.; data (array_like) – Data to be written to file.; numtype (str {'complex, 'real'}) – Type of numerical data.; numfor",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:194812,Energy Efficiency,energy,energy,194812,"addtional elements; are added. Parameters:; start (int) – The starting value of the sequence.; stop (int) – The stoping values of the sequence.; num (int, optional) – Number of samples to generate.; elems (list/ndarray, optional) – Requested elements to include in array. Returns:samples – Original equally spaced sample array with additional; elements added. Return type:ndadrray. clebsch(j1, j2, j3, m1, m2, m3)[source]¶; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters:; j1 (float) – Total angular momentum 1.; j2 (float) – Total angular momentum 2.; j3 (float) – Total angular momentum 3.; m1 (float) – z-component of angular momentum 1.; m2 (float) – z-component of angular momentum 2.; m3 (float) – z-component of angular momentum 3. Returns:cg_coeff – Requested Clebsch-Gordan coefficient. Return type:float. convert_unit(value, orig='meV', to='GHz')[source]¶; Convert an energy from unit orig to unit to. Parameters:; value (float / array) – The energy in the old unit.; orig (string) – The name of the original unit (“J”, “eV”, “meV”, “GHz”, “mK”); to (string) – The name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”). Returns:value_new_unit – The energy in the new unit. Return type:float / array. File I/O Functions¶. file_data_read(filename, sep=None)[source]¶; Retrieves an array of data from the requested file. Parameters:; filename (str) – Name of file containing reqested data.; sep (str) – Seperator used to store data. Returns:data – Data from selected file. Return type:array_like. file_data_store(filename, data, numtype='complex', numformat='decimal', sep=', ')[source]¶; Stores a matrix of data to a file to be read by an external program. Parameters:; filename (str) – Name of data file to be stored, including extension.; data (array_like) – Data to be written to file.; numtype (str {'complex, 'real'}) – Type of numerical data.; numformat (str {'decimal','exp'}) – Format for written data.; sep (str) – Single-charac",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:195017,Energy Efficiency,energy,energy,195017,"ndarray, optional) – Requested elements to include in array. Returns:samples – Original equally spaced sample array with additional; elements added. Return type:ndadrray. clebsch(j1, j2, j3, m1, m2, m3)[source]¶; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters:; j1 (float) – Total angular momentum 1.; j2 (float) – Total angular momentum 2.; j3 (float) – Total angular momentum 3.; m1 (float) – z-component of angular momentum 1.; m2 (float) – z-component of angular momentum 2.; m3 (float) – z-component of angular momentum 3. Returns:cg_coeff – Requested Clebsch-Gordan coefficient. Return type:float. convert_unit(value, orig='meV', to='GHz')[source]¶; Convert an energy from unit orig to unit to. Parameters:; value (float / array) – The energy in the old unit.; orig (string) – The name of the original unit (“J”, “eV”, “meV”, “GHz”, “mK”); to (string) – The name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”). Returns:value_new_unit – The energy in the new unit. Return type:float / array. File I/O Functions¶. file_data_read(filename, sep=None)[source]¶; Retrieves an array of data from the requested file. Parameters:; filename (str) – Name of file containing reqested data.; sep (str) – Seperator used to store data. Returns:data – Data from selected file. Return type:array_like. file_data_store(filename, data, numtype='complex', numformat='decimal', sep=', ')[source]¶; Stores a matrix of data to a file to be read by an external program. Parameters:; filename (str) – Name of data file to be stored, including extension.; data (array_like) – Data to be written to file.; numtype (str {'complex, 'real'}) – Type of numerical data.; numformat (str {'decimal','exp'}) – Format for written data.; sep (str) – Single-character field seperator. Usually a tab, space, comma,; or semicolon. qload(name)[source]¶; Loads data file from file named ‘filename.qu’ in current directory. Parameters:name (str) – Name of data file to be loaded. ",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:200506,Energy Efficiency,schedul,scheduling,200506,"tebooks. parfor(task, task_vec, args=None, client=None, view=None, show_scheduling=False, show_progressbar=False)[source]¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:; task (a Python function) – The function that is to be called for each value in task_vec.; task_vec (array / list) – The list or array of values for which the task function is to be; evaluated.; args (list / dictionary) – The optional additional argument to the task function. For example; a dictionary with parameter values.; client (IPython.parallel.Client) – The IPython.parallel Client instance that will be used in the; parfor execution.; view (a IPython.parallel.Client view) – The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view().; show_scheduling (bool {False, True}, default False) – Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster.; show_progressbar (bool {False, True}, default False) – Display a HTML-based progress bar duing the execution of the parfor; loop. Returns:result – The result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. Return type:list. parallel_map(task, values, task_args=None, task_kwargs=None, client=None, view=None, progress_bar=None, show_scheduling=False, **kwargs)[source]¶; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(val",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:200856,Energy Efficiency,schedul,scheduled,200856,"gs=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:; task (a Python function) – The function that is to be called for each value in task_vec.; task_vec (array / list) – The list or array of values for which the task function is to be; evaluated.; args (list / dictionary) – The optional additional argument to the task function. For example; a dictionary with parameter values.; client (IPython.parallel.Client) – The IPython.parallel Client instance that will be used in the; parfor execution.; view (a IPython.parallel.Client view) – The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view().; show_scheduling (bool {False, True}, default False) – Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster.; show_progressbar (bool {False, True}, default False) – Display a HTML-based progress bar duing the execution of the parfor; loop. Returns:result – The result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. Return type:list. parallel_map(task, values, task_args=None, task_kwargs=None, client=None, view=None, progress_bar=None, show_scheduling=False, **kwargs)[source]¶; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(value, *args, **kwargs).; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:; task (a Python function) – The function that is to be called for each value in task_vec",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:202278,Energy Efficiency,schedul,scheduling,202278,"one, client=None, view=None, progress_bar=None, show_scheduling=False, **kwargs)[source]¶; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(value, *args, **kwargs).; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:; task (a Python function) – The function that is to be called for each value in task_vec.; values (array / list) – The list or array of values for which the task function is to be; evaluated.; task_args (list / dictionary) – The optional additional argument to the task function.; task_kwargs (list / dictionary) – The optional additional keyword argument to the task function.; client (IPython.parallel.Client) – The IPython.parallel Client instance that will be used in the; parfor execution.; view (a IPython.parallel.Client view) – The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view().; show_scheduling (bool {False, True}, default False) – Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster.; show_progressbar (bool {False, True}, default False) – Display a HTML-based progress bar during the execution of the parfor; loop. Returns:result – The result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. Return type:list. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns:version_",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:202628,Energy Efficiency,schedul,scheduled,202628,"el client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:; task (a Python function) – The function that is to be called for each value in task_vec.; values (array / list) – The list or array of values for which the task function is to be; evaluated.; task_args (list / dictionary) – The optional additional argument to the task function.; task_kwargs (list / dictionary) – The optional additional keyword argument to the task function.; client (IPython.parallel.Client) – The IPython.parallel Client instance that will be used in the; parfor execution.; view (a IPython.parallel.Client view) – The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view().; show_scheduling (bool {False, True}, default False) – Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster.; show_progressbar (bool {False, True}, default False) – Display a HTML-based progress bar during the execution of the parfor; loop. Returns:result – The result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. Return type:list. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns:version_table – Return an HTML-formatted string containing version information for; QuTiP dependencies. Return type:string. Miscellaneous¶. about()[source]¶; About box for QuTiP. Gives version numbers for; QuTiP, NumPy, SciPy, Cython, and MatPlotLib. simdiag(ops, evals=True)[source]¶; Simulateous dia",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:828,Integrability,depend,dependent,828,". . Functions — QuTiP 4.0 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.0; . Frontmatter; Installation; Users Guide; API documentation; Classes; Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Random Operators and States; Three-Level Atoms; Superoperators and Liouvillians; Superoperator Representations. Functions acting on states and operators; Tensor; Expectation Values; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continous Variables. Dynamics and Time-Evolution; Schrödinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic Schrödinger Equation and Master Equation; Correlation Functions; Steady-state Solvers; Propagators; Time-dependent problems. Visualization; Pseudoprobability Functions; Graphs and Visualization; Quantum Process Tomography. Quantum Information Processing; Gates; Qubits; Algorithms. non-Markovian Solvers; Optimal control; GRAPE; CRAB. Utilitiy Functions; Graph Theory Routines; Utility Functions; File I/O Functions; Parallelization; IPython Notebook Tools; Miscellaneous. Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; API documentation »; Functions. Functions¶. Manipulation and Creation of States and Operators¶. Quantum States¶. basis(N, n=0, offset=0)[source]¶; Generates the vector representation of a Fock state. Parameters:; N (int) – Number of Fock states in Hilbert space.; n (int) – Integer corresponding to desired number state, defaults; to 0 if omitted.; offset (int (default 0)) – The lowest number state that is included in the finite number state; representation of the state. Returns:state – Qobj representing the requested number state |n>. Return type:qobj. Examples; >>> basis(5,2); Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 0.+0.j]; [ 0.+0.j]; [ 1.+0.j]; [ 0.+0.j]; [ 0.+0.j]]. Notes; A",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:43450,Integrability,contract,contracted,43450,"tor; acts. Parameters:args (array_like) – list or array of quantum objects with type=""super"". Returns:obj – A composite quantum object. Return type:qobj. composite(*args)[source]¶; Given two or more operators, kets or bras, returns the Qobj; corresponding to a composite system over each argument.; For ordinary operators and vectors, this is the tensor product,; while for superoperators and vectorized operators, this is; the column-reshuffled tensor product.; If a mix of Qobjs supported on Hilbert and Liouville spaces; are passed in, the former are promoted. Ordinary operators; are assumed to be unitaries, and are promoted using to_super,; while kets and bras are promoted by taking their projectors and; using operator_to_vector(ket2dm(arg)). tensor_contract(qobj, *pairs)[source]¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters:pairs (tuple) – One or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns:cqobj – The original Qobj with all named index pairs contracted; away. Return type:Qobj. Expectation Values¶. expect(oper, state)[source]¶; Calculates the expectation value for operator(s) and state(s). Parameters:; oper (qobj/array-like) – A single or a list or operators for expectation value.; state (qobj/array-like) – A single or a list of quantum states or density matrices. Returns:expt – Expectation value. real if oper is Hermitian, complex; otherwise. A (nested) array of expectaction values of state or operator; are arrays. Return type:float/complex/array-like. Examples; >>> expect(num(4), basis(4, 3)); 3. variance(oper, state)[source]¶; Variance of an operator for the given state vector or density matrix. Parameters:; oper (qobj) – Operator for expectation value.; state (qobj/list) – A single or list of quantum states or density matrices.. Returns:var – Variance of operator ‘oper’ for given state. Retur",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:43523,Integrability,contract,contracted,43523,"A composite quantum object. Return type:qobj. composite(*args)[source]¶; Given two or more operators, kets or bras, returns the Qobj; corresponding to a composite system over each argument.; For ordinary operators and vectors, this is the tensor product,; while for superoperators and vectorized operators, this is; the column-reshuffled tensor product.; If a mix of Qobjs supported on Hilbert and Liouville spaces; are passed in, the former are promoted. Ordinary operators; are assumed to be unitaries, and are promoted using to_super,; while kets and bras are promoted by taking their projectors and; using operator_to_vector(ket2dm(arg)). tensor_contract(qobj, *pairs)[source]¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters:pairs (tuple) – One or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns:cqobj – The original Qobj with all named index pairs contracted; away. Return type:Qobj. Expectation Values¶. expect(oper, state)[source]¶; Calculates the expectation value for operator(s) and state(s). Parameters:; oper (qobj/array-like) – A single or a list or operators for expectation value.; state (qobj/array-like) – A single or a list of quantum states or density matrices. Returns:expt – Expectation value. real if oper is Hermitian, complex; otherwise. A (nested) array of expectaction values of state or operator; are arrays. Return type:float/complex/array-like. Examples; >>> expect(num(4), basis(4, 3)); 3. variance(oper, state)[source]¶; Variance of an operator for the given state vector or density matrix. Parameters:; oper (qobj) – Operator for expectation value.; state (qobj/list) – A single or list of quantum states or density matrices.. Returns:var – Variance of operator ‘oper’ for given state. Return type:float. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial ",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:54758,Integrability,integrat,integrating,54758,"late the covariance matrix. Returns:cov_mat – A 2-dimensional array of covariance values. Return type:ndarray. logarithmic_negativity(V)[source]¶; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see qutip.continous_variables.covariance_matrix. Note that; the two-mode field state that is described by V must be Gaussian for this; function to applicable. Parameters:V (2d array) – The covariance matrix. Returns:N – The logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. Return type:float. Dynamics and Time-Evolution¶. Schrödinger Equation¶; This module provides solvers for the unitary Schrodinger equation. sesolve(H, rho0, tlist, e_ops=[], args={}, options=None, progress_bar=<qutip.ui.progressbar.BaseProgressBar object>, _safe_mode=True)[source]¶; Schrodinger equation evolution of a state vector for a given Hamiltonian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian (H), by integrating the set of ordinary differential; equations that define the system.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. Parameters:; H (qutip.qobj) – system Hamiltonian, or a callback function for time-dependent; Hamiltonians.; rho0 (qutip.qobj) – initial density matrix or state vector (ket).; tlist (list / array) – list of times for \(t\).; e_ops (list of qutip.qobj / callback function single) – single operator or list of operators for which to evaluate; expectation values.; args (dictionary) – dictionary of parameters for time-dependent Hamiltonians and; collapse operators.; options (qutip.Qdeoptions) – with options for the ODE solver. Returns:output – An instance of the class qutip.solver, which contains either; an array of ex",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:55218,Integrability,depend,dependent,55218,"he logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. Return type:float. Dynamics and Time-Evolution¶. Schrödinger Equation¶; This module provides solvers for the unitary Schrodinger equation. sesolve(H, rho0, tlist, e_ops=[], args={}, options=None, progress_bar=<qutip.ui.progressbar.BaseProgressBar object>, _safe_mode=True)[source]¶; Schrodinger equation evolution of a state vector for a given Hamiltonian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian (H), by integrating the set of ordinary differential; equations that define the system.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. Parameters:; H (qutip.qobj) – system Hamiltonian, or a callback function for time-dependent; Hamiltonians.; rho0 (qutip.qobj) – initial density matrix or state vector (ket).; tlist (list / array) – list of times for \(t\).; e_ops (list of qutip.qobj / callback function single) – single operator or list of operators for which to evaluate; expectation values.; args (dictionary) – dictionary of parameters for time-dependent Hamiltonians and; collapse operators.; options (qutip.Qdeoptions) – with options for the ODE solver. Returns:output – An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors or density matrices corresponding to the; times in tlist [if e_ops is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. Return type:qutip.solver. Master Equation¶; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops=[",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:55551,Integrability,depend,dependent,55551,".BaseProgressBar object>, _safe_mode=True)[source]¶; Schrodinger equation evolution of a state vector for a given Hamiltonian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian (H), by integrating the set of ordinary differential; equations that define the system.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. Parameters:; H (qutip.qobj) – system Hamiltonian, or a callback function for time-dependent; Hamiltonians.; rho0 (qutip.qobj) – initial density matrix or state vector (ket).; tlist (list / array) – list of times for \(t\).; e_ops (list of qutip.qobj / callback function single) – single operator or list of operators for which to evaluate; expectation values.; args (dictionary) – dictionary of parameters for time-dependent Hamiltonians and; collapse operators.; options (qutip.Qdeoptions) – with options for the ODE solver. Returns:output – An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors or density matrices corresponding to the; times in tlist [if e_ops is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. Return type:qutip.solver. Master Equation¶; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops=[], e_ops=[], args={}, options=None, progress_bar=None, _safe_mode=True)[source]¶; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian (H) and an [optional] set of collapse operators; (c_ops), by integra",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:56540,Integrability,integrat,integrating,56540,"ary) – dictionary of parameters for time-dependent Hamiltonians and; collapse operators.; options (qutip.Qdeoptions) – with options for the ODE solver. Returns:output – An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors or density matrices corresponding to the; times in tlist [if e_ops is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. Return type:qutip.solver. Master Equation¶; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops=[], e_ops=[], args={}, options=None, progress_bar=None, _safe_mode=True)[source]¶; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian (H) and an [optional] set of collapse operators; (c_ops), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; If either H or the Qobj elements in c_ops are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows to solve master equations that are not on standard Lindblad; form by passing a custom Liouvillian in place of either the H or c_ops; elements.; Time-dependent operators; For time-dependent problems, H and c_ops can be callback; functions that takes two arguments, time and args, and returns the; Hamiltonian or Liouvillian",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:57337,Integrability,depend,dependent,57337,"o0) using a given; Hamiltonian (H) and an [optional] set of collapse operators; (c_ops), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; If either H or the Qobj elements in c_ops are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows to solve master equations that are not on standard Lindblad; form by passing a custom Liouvillian in place of either the H or c_ops; elements.; Time-dependent operators; For time-dependent problems, H and c_ops can be callback; functions that takes two arguments, time and args, and returns the; Hamiltonian or Liouvillian for the system at that point in time; (callback format).; Alternatively, H and c_ops can be a specified in a nested-list format; where each element in the list is a list of length 2, containing an; operator (qutip.qobj) at the first element and where the; second element is either a string (list string format), a callback; function (list callback format) that evaluates to the time-dependent; coefficient for the corresponding operator, or a NumPy array (list; array format) which specifies the value of the coefficient to the; corresponding operator for each value of t in tlist.; Examples. H = [[H0, ‘sin(w*t)’], [H1, ‘sin(2*w*t)’]]; H = [[H0, f0_t], [H1, f1_t]]; where f0_t and f1_t are python functions with signature f_t(t, args).; H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the list string format and list callback format, the string; expression and the callback function must evaluate to a real or complex; number (c",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:57367,Integrability,depend,dependent,57367,"o0) using a given; Hamiltonian (H) and an [optional] set of collapse operators; (c_ops), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; If either H or the Qobj elements in c_ops are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows to solve master equations that are not on standard Lindblad; form by passing a custom Liouvillian in place of either the H or c_ops; elements.; Time-dependent operators; For time-dependent problems, H and c_ops can be callback; functions that takes two arguments, time and args, and returns the; Hamiltonian or Liouvillian for the system at that point in time; (callback format).; Alternatively, H and c_ops can be a specified in a nested-list format; where each element in the list is a list of length 2, containing an; operator (qutip.qobj) at the first element and where the; second element is either a string (list string format), a callback; function (list callback format) that evaluates to the time-dependent; coefficient for the corresponding operator, or a NumPy array (list; array format) which specifies the value of the coefficient to the; corresponding operator for each value of t in tlist.; Examples. H = [[H0, ‘sin(w*t)’], [H1, ‘sin(2*w*t)’]]; H = [[H0, f0_t], [H1, f1_t]]; where f0_t and f1_t are python functions with signature f_t(t, args).; H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the list string format and list callback format, the string; expression and the callback function must evaluate to a real or complex; number (c",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:57894,Integrability,depend,dependent,57894,"t is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; If either H or the Qobj elements in c_ops are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows to solve master equations that are not on standard Lindblad; form by passing a custom Liouvillian in place of either the H or c_ops; elements.; Time-dependent operators; For time-dependent problems, H and c_ops can be callback; functions that takes two arguments, time and args, and returns the; Hamiltonian or Liouvillian for the system at that point in time; (callback format).; Alternatively, H and c_ops can be a specified in a nested-list format; where each element in the list is a list of length 2, containing an; operator (qutip.qobj) at the first element and where the; second element is either a string (list string format), a callback; function (list callback format) that evaluates to the time-dependent; coefficient for the corresponding operator, or a NumPy array (list; array format) which specifies the value of the coefficient to the; corresponding operator for each value of t in tlist.; Examples. H = [[H0, ‘sin(w*t)’], [H1, ‘sin(2*w*t)’]]; H = [[H0, f0_t], [H1, f1_t]]; where f0_t and f1_t are python functions with signature f_t(t, args).; H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the list string format and list callback format, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as second argument.; Additional options; Additional options to mesolve can be set via the options argument, which; should be an instance of qutip.solver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state ",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:58515,Integrability,depend,dependent,58515,"allback format).; Alternatively, H and c_ops can be a specified in a nested-list format; where each element in the list is a list of length 2, containing an; operator (qutip.qobj) at the first element and where the; second element is either a string (list string format), a callback; function (list callback format) that evaluates to the time-dependent; coefficient for the corresponding operator, or a NumPy array (list; array format) which specifies the value of the coefficient to the; corresponding operator for each value of t in tlist.; Examples. H = [[H0, ‘sin(w*t)’], [H1, ‘sin(2*w*t)’]]; H = [[H0, f0_t], [H1, f1_t]]; where f0_t and f1_t are python functions with signature f_t(t, args).; H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the list string format and list callback format, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as second argument.; Additional options; Additional options to mesolve can be set via the options argument, which; should be an instance of qutip.solver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using mesolve for solving master; equations that are not on standard Lindblad form. Note; On using callback function: mesolve transforms all qutip.qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qu",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:58824,Integrability,integrat,integration,58824,"ent for the corresponding operator, or a NumPy array (list; array format) which specifies the value of the coefficient to the; corresponding operator for each value of t in tlist.; Examples. H = [[H0, ‘sin(w*t)’], [H1, ‘sin(2*w*t)’]]; H = [[H0, f0_t], [H1, f1_t]]; where f0_t and f1_t are python functions with signature f_t(t, args).; H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the list string format and list callback format, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as second argument.; Additional options; Additional options to mesolve can be set via the options argument, which; should be an instance of qutip.solver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using mesolve for solving master; equations that are not on standard Lindblad form. Note; On using callback function: mesolve transforms all qutip.qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.qobj in; args and handle the conversion to sparse matrices. All other; qutip.qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters:; H (qutip.Qobj) – System Hamiltonia",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:59463,Integrability,integrat,integrator,59463,"number (coefficient for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as second argument.; Additional options; Additional options to mesolve can be set via the options argument, which; should be an instance of qutip.solver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using mesolve for solving master; equations that are not on standard Lindblad form. Note; On using callback function: mesolve transforms all qutip.qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.qobj in; args and handle the conversion to sparse matrices. All other; qutip.qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters:; H (qutip.Qobj) – System Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian.; rho0 (qutip.Qobj) – initial density matrix or state vector (ket).; tlist (list / array) – list of times for \(t\).; c_ops (list of qutip.Qobj) – single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators.; e_ops (list of qutip.Qobj / callback function single) – single operator or list of operators for which to evaluate; expectation values.; args (dictionary) – dictionary of parameters",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:59800,Integrability,integrat,integrator,59800,"olver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using mesolve for solving master; equations that are not on standard Lindblad form. Note; On using callback function: mesolve transforms all qutip.qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.qobj in; args and handle the conversion to sparse matrices. All other; qutip.qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters:; H (qutip.Qobj) – System Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian.; rho0 (qutip.Qobj) – initial density matrix or state vector (ket).; tlist (list / array) – list of times for \(t\).; c_ops (list of qutip.Qobj) – single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators.; e_ops (list of qutip.Qobj / callback function single) – single operator or list of operators for which to evaluate; expectation values.; args (dictionary) – dictionary of parameters for time-dependent Hamiltonians and; collapse operators.; options (qutip.Options) – with options for the solver.; progress_bar (BaseProgressBar) – Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns:result – An instance of the class qutip.Result, which contains; either an array result.expect of ",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:59949,Integrability,depend,dependent,59949,"though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using mesolve for solving master; equations that are not on standard Lindblad form. Note; On using callback function: mesolve transforms all qutip.qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.qobj in; args and handle the conversion to sparse matrices. All other; qutip.qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters:; H (qutip.Qobj) – System Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian.; rho0 (qutip.Qobj) – initial density matrix or state vector (ket).; tlist (list / array) – list of times for \(t\).; c_ops (list of qutip.Qobj) – single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators.; e_ops (list of qutip.Qobj / callback function single) – single operator or list of operators for which to evaluate; expectation values.; args (dictionary) – dictionary of parameters for time-dependent Hamiltonians and; collapse operators.; options (qutip.Options) – with options for the solver.; progress_bar (BaseProgressBar) – Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns:result – An instance of the class qutip.Result, which contains; either an array result.expect of expectation values for the times; specified by tlist, or an array result.states of state vectors or; density matrices corresponding to the times in tlis",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:60450,Integrability,depend,dependent,60450,"he problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.qobj in; args and handle the conversion to sparse matrices. All other; qutip.qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters:; H (qutip.Qobj) – System Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian.; rho0 (qutip.Qobj) – initial density matrix or state vector (ket).; tlist (list / array) – list of times for \(t\).; c_ops (list of qutip.Qobj) – single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators.; e_ops (list of qutip.Qobj / callback function single) – single operator or list of operators for which to evaluate; expectation values.; args (dictionary) – dictionary of parameters for time-dependent Hamiltonians and; collapse operators.; options (qutip.Options) – with options for the solver.; progress_bar (BaseProgressBar) – Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns:result – An instance of the class qutip.Result, which contains; either an array result.expect of expectation values for the times; specified by tlist, or an array result.states of state vectors or; density matrices corresponding to the times in tlist [if e_ops is; an empty list], or nothing if a callback function was given in place of; operators for which to calculate the expectation values. Return type:qutip.Result. Monte Carlo Evolution¶. mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=None, args={}, options=None, progress_bar=True, map_func=None, map_kwargs=None, _safe_mode=True)[source]¶; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; fo",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:61574,Integrability,depend,dependent,61574,"r a subclass thereof, for; showing the progress of the simulation. Returns:result – An instance of the class qutip.Result, which contains; either an array result.expect of expectation values for the times; specified by tlist, or an array result.states of state vectors or; density matrices corresponding to the times in tlist [if e_ops is; an empty list], or nothing if a callback function was given in place of; operators for which to calculate the expectation values. Return type:qutip.Result. Monte Carlo Evolution¶. mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=None, args={}, options=None, progress_bar=True, map_func=None, map_kwargs=None, _safe_mode=True)[source]¶; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class.; mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term.; As an example of a time-dependent problem, consider a Hamiltonian with two; terms H0 and H1, where H1 is time-dependent with coefficient; sin(w*t), and collapse operators C0 and C1, where C1 is; time-dependent with coeffcient exp(-a*t). Here, w and a are constant; arguments with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; opera",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:61680,Integrability,depend,dependent,61680,"r a subclass thereof, for; showing the progress of the simulation. Returns:result – An instance of the class qutip.Result, which contains; either an array result.expect of expectation values for the times; specified by tlist, or an array result.states of state vectors or; density matrices corresponding to the times in tlist [if e_ops is; an empty list], or nothing if a callback function was given in place of; operators for which to calculate the expectation values. Return type:qutip.Result. Monte Carlo Evolution¶. mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=None, args={}, options=None, progress_bar=True, map_func=None, map_kwargs=None, _safe_mode=True)[source]¶; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class.; mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term.; As an example of a time-dependent problem, consider a Hamiltonian with two; terms H0 and H1, where H1 is time-dependent with coefficient; sin(w*t), and collapse operators C0 and C1, where C1 is; time-dependent with coeffcient exp(-a*t). Here, w and a are constant; arguments with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; opera",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:61803,Integrability,depend,dependent,61803,"or; density matrices corresponding to the times in tlist [if e_ops is; an empty list], or nothing if a callback function was given in place of; operators for which to calculate the expectation values. Return type:qutip.Result. Monte Carlo Evolution¶. mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=None, args={}, options=None, progress_bar=True, map_func=None, map_kwargs=None, _safe_mode=True)[source]¶; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class.; mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term.; As an example of a time-dependent problem, consider a Hamiltonian with two; terms H0 and H1, where H1 is time-dependent with coefficient; sin(w*t), and collapse operators C0 and C1, where C1 is; time-dependent with coeffcient exp(-a*t). Here, w and a are constant; arguments with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters:; H (qutip.Qobj) – System Hamiltonian.; psi0 (qutip.Qobj) – Initial state vector; tlist (array_like) – Times at which results are recorded.; ntraj (int) – Number of trajectories to run.; c_ops (array_like) – single collapse operator or list or arr",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:61889,Integrability,depend,dependent,61889,"or; density matrices corresponding to the times in tlist [if e_ops is; an empty list], or nothing if a callback function was given in place of; operators for which to calculate the expectation values. Return type:qutip.Result. Monte Carlo Evolution¶. mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=None, args={}, options=None, progress_bar=True, map_func=None, map_kwargs=None, _safe_mode=True)[source]¶; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class.; mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term.; As an example of a time-dependent problem, consider a Hamiltonian with two; terms H0 and H1, where H1 is time-dependent with coefficient; sin(w*t), and collapse operators C0 and C1, where C1 is; time-dependent with coeffcient exp(-a*t). Here, w and a are constant; arguments with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters:; H (qutip.Qobj) – System Hamiltonian.; psi0 (qutip.Qobj) – Initial state vector; tlist (array_like) – Times at which results are recorded.; ntraj (int) – Number of trajectories to run.; c_ops (array_like) – single collapse operator or list or arr",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:61979,Integrability,depend,dependent,61979,"or; density matrices corresponding to the times in tlist [if e_ops is; an empty list], or nothing if a callback function was given in place of; operators for which to calculate the expectation values. Return type:qutip.Result. Monte Carlo Evolution¶. mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=None, args={}, options=None, progress_bar=True, map_func=None, map_kwargs=None, _safe_mode=True)[source]¶; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class.; mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term.; As an example of a time-dependent problem, consider a Hamiltonian with two; terms H0 and H1, where H1 is time-dependent with coefficient; sin(w*t), and collapse operators C0 and C1, where C1 is; time-dependent with coeffcient exp(-a*t). Here, w and a are constant; arguments with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters:; H (qutip.Qobj) – System Hamiltonian.; psi0 (qutip.Qobj) – Initial state vector; tlist (array_like) – Times at which results are recorded.; ntraj (int) – Number of trajectories to run.; c_ops (array_like) – single collapse operator or list or arr",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:62107,Integrability,depend,dependent,62107,"lo Evolution¶. mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=None, args={}, options=None, progress_bar=True, map_func=None, map_kwargs=None, _safe_mode=True)[source]¶; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class.; mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term.; As an example of a time-dependent problem, consider a Hamiltonian with two; terms H0 and H1, where H1 is time-dependent with coefficient; sin(w*t), and collapse operators C0 and C1, where C1 is; time-dependent with coeffcient exp(-a*t). Here, w and a are constant; arguments with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters:; H (qutip.Qobj) – System Hamiltonian.; psi0 (qutip.Qobj) – Initial state vector; tlist (array_like) – Times at which results are recorded.; ntraj (int) – Number of trajectories to run.; c_ops (array_like) – single collapse operator or list or array of collapse; operators.; e_ops (array_like) – single operator or list or array of operators for calculating; expectation values.; args (dict) – Arguments for time-dependent Hamiltonian and collapse operator terms.; options (Options) ",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:63062,Integrability,depend,dependent,63062,"nd A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters:; H (qutip.Qobj) – System Hamiltonian.; psi0 (qutip.Qobj) – Initial state vector; tlist (array_like) – Times at which results are recorded.; ntraj (int) – Number of trajectories to run.; c_ops (array_like) – single collapse operator or list or array of collapse; operators.; e_ops (array_like) – single operator or list or array of operators for calculating; expectation values.; args (dict) – Arguments for time-dependent Hamiltonian and collapse operator terms.; options (Options) – Instance of ODE solver options.; progress_bar (BaseProgressBar) – Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Set to None to disable the; progress bar.; map_func (function) – A map function for managing the calls to the single-trajactory solver.; map_kwargs (dictionary) – Optional keyword arguments to the map_func function. Returns:; results (qutip.solver.Result) – Object storing all results from the simulation.; .. note:: – It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds). Exponential Series¶. essolve(H, rho0, tlist, c_op_list, e_ops)[source]¶; Evolution of a state vector or density matrix (rho0) for a given; Hamiltonian (H) and set of collapse operators (c_op_list), by; expressing the ODE as an exponential series. The outp",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:64699,Integrability,depend,dependent,64699,"un; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds). Exponential Series¶. essolve(H, rho0, tlist, c_op_list, e_ops)[source]¶; Evolution of a state vector or density matrix (rho0) for a given; Hamiltonian (H) and set of collapse operators (c_op_list), by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (tlist), or the; expectation values of the supplied operators (e_ops). Parameters:; H (qobj/function_type) – System Hamiltonian.; rho0 (qutip.qobj) – Initial state density matrix.; tlist (list/array) – list of times for \(t\).; c_op_list (list of qutip.qobj) – list of qutip.qobj collapse operators.; e_ops (list of qutip.qobj) – list of qutip.qobj operators for which to evaluate; expectation values. Returns:expt_array – Expectation values of wavefunctions/density matrices for the; times specified in tlist. Return type:array. Note; This solver does not support time-dependent Hamiltonians. ode2es(L, rho0)[source]¶; Creates an exponential series that describes the time evolution for the; initial density matrix (or state vector) rho0, given the Liouvillian; (or Hamiltonian) L. Parameters:; L (qobj) – Liouvillian of the system.; rho0 (qobj) – Initial state vector or density matrix. Returns:eseries – eseries represention of the system dynamics. Return type:qutip.eseries. Bloch-Redfield Master Equation¶. brmesolve(H, psi0, tlist, a_ops, e_ops=[], spectra_cb=[], c_ops=[], args={}, options=<qutip.solver.Options object>, _safe_mode=True)[source]¶; Solve the dynamics for a system using the Bloch-Redfield master equation. Note; This solver does not currently support time-dependent Hamiltonians. Parameters:; H (qutip.Qobj) – System Hamiltonian.; / psi0 (rho0) – Initial density matrix or state vector (ket).; tlist (list / array) – List of times for \(t\).; a_ops (list of qutip.qobj) – List of system operators that couple to bath degrees of freedom.; ",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:65408,Integrability,depend,dependent,65408," of qutip.qobj collapse operators.; e_ops (list of qutip.qobj) – list of qutip.qobj operators for which to evaluate; expectation values. Returns:expt_array – Expectation values of wavefunctions/density matrices for the; times specified in tlist. Return type:array. Note; This solver does not support time-dependent Hamiltonians. ode2es(L, rho0)[source]¶; Creates an exponential series that describes the time evolution for the; initial density matrix (or state vector) rho0, given the Liouvillian; (or Hamiltonian) L. Parameters:; L (qobj) – Liouvillian of the system.; rho0 (qobj) – Initial state vector or density matrix. Returns:eseries – eseries represention of the system dynamics. Return type:qutip.eseries. Bloch-Redfield Master Equation¶. brmesolve(H, psi0, tlist, a_ops, e_ops=[], spectra_cb=[], c_ops=[], args={}, options=<qutip.solver.Options object>, _safe_mode=True)[source]¶; Solve the dynamics for a system using the Bloch-Redfield master equation. Note; This solver does not currently support time-dependent Hamiltonians. Parameters:; H (qutip.Qobj) – System Hamiltonian.; / psi0 (rho0) – Initial density matrix or state vector (ket).; tlist (list / array) – List of times for \(t\).; a_ops (list of qutip.qobj) – List of system operators that couple to bath degrees of freedom.; e_ops (list of qutip.qobj / callback function) – List of operators for which to evaluate expectation values.; c_ops (list of qutip.qobj) – List of system collapse operators.; args (dictionary) – Placeholder for future implementation, kept for API consistency.; options (qutip.solver.Options) – Options for the solver. Returns:result – An instance of the class qutip.solver.Result, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by tlist. Return type:qutip.solver.Result. bloch_redfield_tensor(H, a_ops, spectra_cb, c_ops=[], use_secular=True)[source]¶; Calculate the Bloch-Redfield tensor for a system given a set of oper",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:68866,Integrability,depend,dependence,68866,"r; an array of expectation values for the times specified by tlist. Return type:qutip.solver. Floquet States and Floquet-Markov Master Equation¶. fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None, args={}, options=<qutip.solver.Options object>, floquet_basis=True, kmax=5, _safe_mode=True)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters:; H (qutip.qobj) – system Hamiltonian.; / psi0 (rho0) – initial density matrix or state vector (ket).; tlist (list / array) – list of times for \(t\).; c_ops (list of qutip.qobj) – list of collapse operators.; e_ops (list of qutip.qobj / callback function) – list of operators for which to evaluate expectation values.; spectra_cb (list callback functions) – List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops.; T (float) – The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving.; args (dictionary) – dictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry ‘w_th’, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options (qutip.solver) – options for the ODE solver.; k_max (int) – The truncation of the number of sidebands (default 5). Returns:output – An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. Return type:qutip.solver. floquet_modes(H, T, args=None, sort=False, U=None)[source]",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:69043,Integrability,depend,dependent,69043,"s=[], e_ops=[], spectra_cb=[], T=None, args={}, options=<qutip.solver.Options object>, floquet_basis=True, kmax=5, _safe_mode=True)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters:; H (qutip.qobj) – system Hamiltonian.; / psi0 (rho0) – initial density matrix or state vector (ket).; tlist (list / array) – list of times for \(t\).; c_ops (list of qutip.qobj) – list of collapse operators.; e_ops (list of qutip.qobj / callback function) – list of operators for which to evaluate expectation values.; spectra_cb (list callback functions) – List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops.; T (float) – The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving.; args (dictionary) – dictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry ‘w_th’, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options (qutip.solver) – options for the ODE solver.; k_max (int) – The truncation of the number of sidebands (default 5). Returns:output – An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. Return type:qutip.solver. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of co",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:70289,Integrability,depend,dependent,70289,"se the following conversion; >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options (qutip.solver) – options for the ODE solver.; k_max (int) – The truncation of the number of sidebands (default 5). Returns:output – An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. Return type:qutip.solver. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter sort; decides if the output is to be sorted in increasing quasienergies or not. Parameters:; H (qutip.qobj) – system Hamiltonian, time-dependent with period T; args (dictionary) – dictionary with variables required to evaluate H; T (float) – The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving.; U (qutip.qobj) – The propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns:output – Two lists: the Floquet modes as kets and the quasi energies. Return type:list of kets, list of quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters:; f_modes_0 (list of qutip.qobj (kets)) – Floquet modes at \(t\); f_energies (list) – Floquet energies.; t (float) – The time at which to evaluate the floquet modes.; H (qutip.qobj) – system Hamiltonian, time-dependent with period T; args (dictionary) – dictionary with variables required to evaluate H;",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:70419,Integrability,depend,dependence,70419,"se the following conversion; >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options (qutip.solver) – options for the ODE solver.; k_max (int) – The truncation of the number of sidebands (default 5). Returns:output – An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. Return type:qutip.solver. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter sort; decides if the output is to be sorted in increasing quasienergies or not. Parameters:; H (qutip.qobj) – system Hamiltonian, time-dependent with period T; args (dictionary) – dictionary with variables required to evaluate H; T (float) – The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving.; U (qutip.qobj) – The propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns:output – Two lists: the Floquet modes as kets and the quasi energies. Return type:list of kets, list of quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters:; f_modes_0 (list of qutip.qobj (kets)) – Floquet modes at \(t\); f_energies (list) – Floquet energies.; t (float) – The time at which to evaluate the floquet modes.; H (qutip.qobj) – system Hamiltonian, time-dependent with period T; args (dictionary) – dictionary with variables required to evaluate H;",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:70587,Integrability,depend,dependent,70587,"ncation of the number of sidebands (default 5). Returns:output – An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. Return type:qutip.solver. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter sort; decides if the output is to be sorted in increasing quasienergies or not. Parameters:; H (qutip.qobj) – system Hamiltonian, time-dependent with period T; args (dictionary) – dictionary with variables required to evaluate H; T (float) – The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving.; U (qutip.qobj) – The propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns:output – Two lists: the Floquet modes as kets and the quasi energies. Return type:list of kets, list of quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters:; f_modes_0 (list of qutip.qobj (kets)) – Floquet modes at \(t\); f_energies (list) – Floquet energies.; t (float) – The time at which to evaluate the floquet modes.; H (qutip.qobj) – system Hamiltonian, time-dependent with period T; args (dictionary) – dictionary with variables required to evaluate H; T (float) – The period of the time-dependence of the hamiltonian. Returns:output – The Floquet modes as kets at time \(t\). Return type:list of kets. floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)[source]¶; Pre-ca",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:71259,Integrability,depend,dependent,71259,"ctionary) – dictionary with variables required to evaluate H; T (float) – The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving.; U (qutip.qobj) – The propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns:output – Two lists: the Floquet modes as kets and the quasi energies. Return type:list of kets, list of quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters:; f_modes_0 (list of qutip.qobj (kets)) – Floquet modes at \(t\); f_energies (list) – Floquet energies.; t (float) – The time at which to evaluate the floquet modes.; H (qutip.qobj) – system Hamiltonian, time-dependent with period T; args (dictionary) – dictionary with variables required to evaluate H; T (float) – The period of the time-dependence of the hamiltonian. Returns:output – The Floquet modes as kets at time \(t\). Return type:list of kets. floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)[source]¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters:; f_modes_0 (list of qutip.qobj (kets)) – Floquet modes at \(t\); f_energies (list) – Floquet energies.; tlist (array) – The list of times at which to evaluate the floquet modes.; H (qutip.qobj) – system Hamiltonian, time-dependent with period T; T (float) – The period of the time-dependence of the hamiltonian.; args (dictionary) – dictionary with variables required to evaluate H. Returns:output – A nested list of Floquet modes as kets for each time in tlist. Return type:nested list. floquet_modes_t_lookup(f_modes_table_t, t, T)[source]¶; Lookup the floquet mode at tim",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:71389,Integrability,depend,dependence,71389,"ctionary) – dictionary with variables required to evaluate H; T (float) – The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving.; U (qutip.qobj) – The propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns:output – Two lists: the Floquet modes as kets and the quasi energies. Return type:list of kets, list of quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters:; f_modes_0 (list of qutip.qobj (kets)) – Floquet modes at \(t\); f_energies (list) – Floquet energies.; t (float) – The time at which to evaluate the floquet modes.; H (qutip.qobj) – system Hamiltonian, time-dependent with period T; args (dictionary) – dictionary with variables required to evaluate H; T (float) – The period of the time-dependence of the hamiltonian. Returns:output – The Floquet modes as kets at time \(t\). Return type:list of kets. floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)[source]¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters:; f_modes_0 (list of qutip.qobj (kets)) – Floquet modes at \(t\); f_energies (list) – Floquet energies.; tlist (array) – The list of times at which to evaluate the floquet modes.; H (qutip.qobj) – system Hamiltonian, time-dependent with period T; T (float) – The period of the time-dependence of the hamiltonian.; args (dictionary) – dictionary with variables required to evaluate H. Returns:output – A nested list of Floquet modes as kets for each time in tlist. Return type:nested list. floquet_modes_t_lookup(f_modes_table_t, t, T)[source]¶; Lookup the floquet mode at tim",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:71970,Integrability,depend,dependent,71970,"the; initial Floquet modes Phi_alpha(0). Parameters:; f_modes_0 (list of qutip.qobj (kets)) – Floquet modes at \(t\); f_energies (list) – Floquet energies.; t (float) – The time at which to evaluate the floquet modes.; H (qutip.qobj) – system Hamiltonian, time-dependent with period T; args (dictionary) – dictionary with variables required to evaluate H; T (float) – The period of the time-dependence of the hamiltonian. Returns:output – The Floquet modes as kets at time \(t\). Return type:list of kets. floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)[source]¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters:; f_modes_0 (list of qutip.qobj (kets)) – Floquet modes at \(t\); f_energies (list) – Floquet energies.; tlist (array) – The list of times at which to evaluate the floquet modes.; H (qutip.qobj) – system Hamiltonian, time-dependent with period T; T (float) – The period of the time-dependence of the hamiltonian.; args (dictionary) – dictionary with variables required to evaluate H. Returns:output – A nested list of Floquet modes as kets for each time in tlist. Return type:nested list. floquet_modes_t_lookup(f_modes_table_t, t, T)[source]¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters:; f_modes_table_t (nested list of qutip.qobj (kets)) – A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table.; t (float) – The time for which to evaluate the Floquet modes.; T (float) – The period of the time-dependence of the hamiltonian. Returns:output – A list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. Return type:nested list. floquet_states_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Evaluate the floquet states at time t given the initial ",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:72030,Integrability,depend,dependence,72030,"the; initial Floquet modes Phi_alpha(0). Parameters:; f_modes_0 (list of qutip.qobj (kets)) – Floquet modes at \(t\); f_energies (list) – Floquet energies.; t (float) – The time at which to evaluate the floquet modes.; H (qutip.qobj) – system Hamiltonian, time-dependent with period T; args (dictionary) – dictionary with variables required to evaluate H; T (float) – The period of the time-dependence of the hamiltonian. Returns:output – The Floquet modes as kets at time \(t\). Return type:list of kets. floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)[source]¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters:; f_modes_0 (list of qutip.qobj (kets)) – Floquet modes at \(t\); f_energies (list) – Floquet energies.; tlist (array) – The list of times at which to evaluate the floquet modes.; H (qutip.qobj) – system Hamiltonian, time-dependent with period T; T (float) – The period of the time-dependence of the hamiltonian.; args (dictionary) – dictionary with variables required to evaluate H. Returns:output – A nested list of Floquet modes as kets for each time in tlist. Return type:nested list. floquet_modes_t_lookup(f_modes_table_t, t, T)[source]¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters:; f_modes_table_t (nested list of qutip.qobj (kets)) – A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table.; t (float) – The time for which to evaluate the Floquet modes.; T (float) – The period of the time-dependence of the hamiltonian. Returns:output – A list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. Return type:nested list. floquet_states_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Evaluate the floquet states at time t given the initial ",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:72405,Integrability,depend,dependence,72405,"les required to evaluate H; T (float) – The period of the time-dependence of the hamiltonian. Returns:output – The Floquet modes as kets at time \(t\). Return type:list of kets. floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)[source]¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters:; f_modes_0 (list of qutip.qobj (kets)) – Floquet modes at \(t\); f_energies (list) – Floquet energies.; tlist (array) – The list of times at which to evaluate the floquet modes.; H (qutip.qobj) – system Hamiltonian, time-dependent with period T; T (float) – The period of the time-dependence of the hamiltonian.; args (dictionary) – dictionary with variables required to evaluate H. Returns:output – A nested list of Floquet modes as kets for each time in tlist. Return type:nested list. floquet_modes_t_lookup(f_modes_table_t, t, T)[source]¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters:; f_modes_table_t (nested list of qutip.qobj (kets)) – A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table.; t (float) – The time for which to evaluate the Floquet modes.; T (float) – The period of the time-dependence of the hamiltonian. Returns:output – A list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. Return type:nested list. floquet_states_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Evaluate the floquet states at time t given the initial Floquet modes. Parameters:; f_modes_t (list of qutip.qobj (kets)) – A list of initial Floquet modes (for time \(t=0\)).; f_energies (array) – The Floquet energies.; t (float) – The time for which to evaluate the Floquet states.; H (qutip.qobj) – System Hamiltonian, time-dependent with period T.; T (float) – The period of the ",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:72676,Integrability,depend,dependence,72676,"r be used as a table to look up the floquet modes for; any time. Parameters:; f_modes_0 (list of qutip.qobj (kets)) – Floquet modes at \(t\); f_energies (list) – Floquet energies.; tlist (array) – The list of times at which to evaluate the floquet modes.; H (qutip.qobj) – system Hamiltonian, time-dependent with period T; T (float) – The period of the time-dependence of the hamiltonian.; args (dictionary) – dictionary with variables required to evaluate H. Returns:output – A nested list of Floquet modes as kets for each time in tlist. Return type:nested list. floquet_modes_t_lookup(f_modes_table_t, t, T)[source]¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters:; f_modes_table_t (nested list of qutip.qobj (kets)) – A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table.; t (float) – The time for which to evaluate the Floquet modes.; T (float) – The period of the time-dependence of the hamiltonian. Returns:output – A list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. Return type:nested list. floquet_states_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Evaluate the floquet states at time t given the initial Floquet modes. Parameters:; f_modes_t (list of qutip.qobj (kets)) – A list of initial Floquet modes (for time \(t=0\)).; f_energies (array) – The Floquet energies.; t (float) – The time for which to evaluate the Floquet states.; H (qutip.qobj) – System Hamiltonian, time-dependent with period T.; T (float) – The period of the time-dependence of the hamiltonian.; args (dictionary) – Dictionary with variables required to evaluate H. Returns:output – A list of Floquet states for the time \(t\). Return type:list. floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decomposito",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:73270,Integrability,depend,dependent,73270,"es_table_t, t, T)[source]¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters:; f_modes_table_t (nested list of qutip.qobj (kets)) – A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table.; t (float) – The time for which to evaluate the Floquet modes.; T (float) – The period of the time-dependence of the hamiltonian. Returns:output – A list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. Return type:nested list. floquet_states_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Evaluate the floquet states at time t given the initial Floquet modes. Parameters:; f_modes_t (list of qutip.qobj (kets)) – A list of initial Floquet modes (for time \(t=0\)).; f_energies (array) – The Floquet energies.; t (float) – The time for which to evaluate the Floquet states.; H (qutip.qobj) – System Hamiltonian, time-dependent with period T.; T (float) – The period of the time-dependence of the hamiltonian.; args (dictionary) – Dictionary with variables required to evaluate H. Returns:output – A list of Floquet states for the time \(t\). Return type:list. floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters:; f_modes_t (list of qutip.qobj (kets)) – A list of initial Floquet modes (for time \(t=0\)).; f_energies (array) – The Floquet energies.; f_coeff (array) – The coefficients for Floquet decomposition of the initial wavefunction.; t (float) – The time for which to evaluate the Floquet states.; H (qutip.qobj) – System Hamiltonian, time-dependent with period T.; T (float) – The period of the time-dependence of the hamiltonian.; args (dictionary) – Dictionary with variables required to evaluate H. Returns:output – The wavefunction for the time ",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:73331,Integrability,depend,dependence,73331,"in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters:; f_modes_table_t (nested list of qutip.qobj (kets)) – A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table.; t (float) – The time for which to evaluate the Floquet modes.; T (float) – The period of the time-dependence of the hamiltonian. Returns:output – A list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. Return type:nested list. floquet_states_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Evaluate the floquet states at time t given the initial Floquet modes. Parameters:; f_modes_t (list of qutip.qobj (kets)) – A list of initial Floquet modes (for time \(t=0\)).; f_energies (array) – The Floquet energies.; t (float) – The time for which to evaluate the Floquet states.; H (qutip.qobj) – System Hamiltonian, time-dependent with period T.; T (float) – The period of the time-dependence of the hamiltonian.; args (dictionary) – Dictionary with variables required to evaluate H. Returns:output – A list of Floquet states for the time \(t\). Return type:list. floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters:; f_modes_t (list of qutip.qobj (kets)) – A list of initial Floquet modes (for time \(t=0\)).; f_energies (array) – The Floquet energies.; f_coeff (array) – The coefficients for Floquet decomposition of the initial wavefunction.; t (float) – The time for which to evaluate the Floquet states.; H (qutip.qobj) – System Hamiltonian, time-dependent with period T.; T (float) – The period of the time-dependence of the hamiltonian.; args (dictionary) – Dictionary with variables required to evaluate H. Returns:output – The wavefunction for the time \(t\). Return type:qutip.qobj. floquet_state_decomposition(f_s",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:74056,Integrability,depend,dependent,74056,".qobj (kets)) – A list of initial Floquet modes (for time \(t=0\)).; f_energies (array) – The Floquet energies.; t (float) – The time for which to evaluate the Floquet states.; H (qutip.qobj) – System Hamiltonian, time-dependent with period T.; T (float) – The period of the time-dependence of the hamiltonian.; args (dictionary) – Dictionary with variables required to evaluate H. Returns:output – A list of Floquet states for the time \(t\). Return type:list. floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters:; f_modes_t (list of qutip.qobj (kets)) – A list of initial Floquet modes (for time \(t=0\)).; f_energies (array) – The Floquet energies.; f_coeff (array) – The coefficients for Floquet decomposition of the initial wavefunction.; t (float) – The time for which to evaluate the Floquet states.; H (qutip.qobj) – System Hamiltonian, time-dependent with period T.; T (float) – The period of the time-dependence of the hamiltonian.; args (dictionary) – Dictionary with variables required to evaluate H. Returns:output – The wavefunction for the time \(t\). Return type:qutip.qobj. floquet_state_decomposition(f_states, f_energies, psi)[source]¶; Decompose the wavefunction psi (typically an initial state) in terms of; the Floquet states, \(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\). Parameters:; f_states (list of qutip.qobj (kets)) – A list of Floquet modes.; f_energies (array) – The Floquet energies.; psi (qutip.qobj) – The wavefunction to decompose in the Floquet state basis. Returns:output – The coefficients \(c_\alpha\) in the Floquet state decomposition. Return type:array. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100)[source]¶; Solve the Schrodinger equation using the Floquet formalism. Parameters:; H (qutip.qobj.Qobj) – System Hamiltonian, time-dependent with period T.; psi0 (qutip.qobj) – Initial ",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:74117,Integrability,depend,dependence,74117,"0\)).; f_energies (array) – The Floquet energies.; t (float) – The time for which to evaluate the Floquet states.; H (qutip.qobj) – System Hamiltonian, time-dependent with period T.; T (float) – The period of the time-dependence of the hamiltonian.; args (dictionary) – Dictionary with variables required to evaluate H. Returns:output – A list of Floquet states for the time \(t\). Return type:list. floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters:; f_modes_t (list of qutip.qobj (kets)) – A list of initial Floquet modes (for time \(t=0\)).; f_energies (array) – The Floquet energies.; f_coeff (array) – The coefficients for Floquet decomposition of the initial wavefunction.; t (float) – The time for which to evaluate the Floquet states.; H (qutip.qobj) – System Hamiltonian, time-dependent with period T.; T (float) – The period of the time-dependence of the hamiltonian.; args (dictionary) – Dictionary with variables required to evaluate H. Returns:output – The wavefunction for the time \(t\). Return type:qutip.qobj. floquet_state_decomposition(f_states, f_energies, psi)[source]¶; Decompose the wavefunction psi (typically an initial state) in terms of; the Floquet states, \(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\). Parameters:; f_states (list of qutip.qobj (kets)) – A list of Floquet modes.; f_energies (array) – The Floquet energies.; psi (qutip.qobj) – The wavefunction to decompose in the Floquet state basis. Returns:output – The coefficients \(c_\alpha\) in the Floquet state decomposition. Return type:array. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100)[source]¶; Solve the Schrodinger equation using the Floquet formalism. Parameters:; H (qutip.qobj.Qobj) – System Hamiltonian, time-dependent with period T.; psi0 (qutip.qobj) – Initial state vector (ket).; tlist (list / array) – list of times for ",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:74998,Integrability,depend,dependent,74998,"the Floquet states.; H (qutip.qobj) – System Hamiltonian, time-dependent with period T.; T (float) – The period of the time-dependence of the hamiltonian.; args (dictionary) – Dictionary with variables required to evaluate H. Returns:output – The wavefunction for the time \(t\). Return type:qutip.qobj. floquet_state_decomposition(f_states, f_energies, psi)[source]¶; Decompose the wavefunction psi (typically an initial state) in terms of; the Floquet states, \(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\). Parameters:; f_states (list of qutip.qobj (kets)) – A list of Floquet modes.; f_energies (array) – The Floquet energies.; psi (qutip.qobj) – The wavefunction to decompose in the Floquet state basis. Returns:output – The coefficients \(c_\alpha\) in the Floquet state decomposition. Return type:array. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100)[source]¶; Solve the Schrodinger equation using the Floquet formalism. Parameters:; H (qutip.qobj.Qobj) – System Hamiltonian, time-dependent with period T.; psi0 (qutip.qobj) – Initial state vector (ket).; tlist (list / array) – list of times for \(t\).; e_ops (list of qutip.qobj / callback function) – list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values.; T (float) – The period of the time-dependence of the hamiltonian.; args (dictionary) – Dictionary with variables required to evaluate H.; Tsteps (integer) – The number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns:output – An instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Return type:qutip.solver.Result. Stochastic Schrödinger Equation and Master Equation¶; This module contains functions for solving stochastic schrodinger and master; equations. The API",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:75381,Integrability,depend,dependence,75381,"avefunction psi (typically an initial state) in terms of; the Floquet states, \(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\). Parameters:; f_states (list of qutip.qobj (kets)) – A list of Floquet modes.; f_energies (array) – The Floquet energies.; psi (qutip.qobj) – The wavefunction to decompose in the Floquet state basis. Returns:output – The coefficients \(c_\alpha\) in the Floquet state decomposition. Return type:array. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100)[source]¶; Solve the Schrodinger equation using the Floquet formalism. Parameters:; H (qutip.qobj.Qobj) – System Hamiltonian, time-dependent with period T.; psi0 (qutip.qobj) – Initial state vector (ket).; tlist (list / array) – list of times for \(t\).; e_ops (list of qutip.qobj / callback function) – list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values.; T (float) – The period of the time-dependence of the hamiltonian.; args (dictionary) – Dictionary with variables required to evaluate H.; Tsteps (integer) – The number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns:output – An instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Return type:qutip.solver.Result. Stochastic Schrödinger Equation and Master Equation¶; This module contains functions for solving stochastic schrodinger and master; equations. The API should not be considered stable, and is subject to change; when we work more on optimizing this module for performance and features. smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters:; H (qutip.Qobj) – System H",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:76285,Integrability,depend,depending,76285,"will be; returned instead of expectation values.; T (float) – The period of the time-dependence of the hamiltonian.; args (dictionary) – Dictionary with variables required to evaluate H.; Tsteps (integer) – The number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns:output – An instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Return type:qutip.solver.Result. Stochastic Schrödinger Equation and Master Equation¶; This module contains functions for solving stochastic schrodinger and master; equations. The API should not be considered stable, and is subject to change; when we work more on optimizing this module for performance and features. smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters:; H (qutip.Qobj) – System Hamiltonian.; rho0 (qutip.Qobj) – Initial density matrix or state vector (ket).; times (list / array) – List of times for \(t\). Must be uniformly spaced.; c_ops (list of qutip.Qobj) – Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; sc_ops (list of qutip.Qobj) – List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; e_ops (list of qutip.Qobj / callback function single) – single operator or list of operators for which to evaluate; expectation values.; kwargs (dictionary) – Optional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns:output – An instance of the class qutip.solver.SolverResult. Return type:qutip.solver.SolverResult. Todo; Add checks for commuting jump operators in M",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:77469,Integrability,depend,depending,77469," List of times for \(t\). Must be uniformly spaced.; c_ops (list of qutip.Qobj) – Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; sc_ops (list of qutip.Qobj) – List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; e_ops (list of qutip.Qobj / callback function single) – single operator or list of operators for which to evaluate; expectation values.; kwargs (dictionary) – Optional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns:output – An instance of the class qutip.solver.SolverResult. Return type:qutip.solver.SolverResult. Todo; Add checks for commuting jump operators in Milstein method. ssesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, **kwargs)[source]¶; Solve the stochastic Schrödinger equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters:; H (qutip.Qobj) – System Hamiltonian.; psi0 (qutip.Qobj) – Initial state vector (ket).; times (list / array) – List of times for \(t\). Must be uniformly spaced.; sc_ops (list of qutip.Qobj) – List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the equation of motion according to how the d1 and d2 functions; are defined.; e_ops (list of qutip.Qobj) – Single operator or list of operators for which to evaluate; expectation values.; kwargs (dictionary) – Optional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns:output – An instance of the class qutip.solver.SolverResult. Return type:qutip.solver.SolverResult. smepdpsolve(H, rho0, times, c_ops, e_ops, **kwargs)[source]¶; A stochastic (piecewse deterministic process) PDP solver for density matrix; evolution. Parameters:; H (qutip.Qobj) – System Hamiltonian.; rho0 (qutip.Qobj) – Initi",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:80601,Integrability,depend,dependent,80601,"itial state vector (ket).; times (list / array) – List of times for \(t\). Must be uniformly spaced.; c_ops (list of qutip.Qobj) – Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; e_ops (list of qutip.Qobj / callback function single) – single operator or list of operators for which to evaluate; expectation values.; kwargs (dictionary) – Optional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns:output – An instance of the class qutip.solver.SolverResult. Return type:qutip.solver.SolverResult. Correlation Functions¶. correlation(H, state0, tlist, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter. Parameters:; H (Qobj) – system Hamiltonian, may be time-dependent for solver choice of me or; mc.; state0 (Qobj) – Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers.; tlist (array_like) – list of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input.; taulist (array_like) – list of times for \(\tau\). taulist must be positive and contain; the element 0.; c_ops (list) – list of collapse operators, may be time-dependent for solver choice of; me or mc.; a_op (Qobj) – operator A.; b_op (Qobj) – operator B.; reverse (bool) – If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\).; solver (str) – choice of solver (me for master-equation, mc for Monte Carlo,",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:81308,Integrability,depend,dependent,81308,"p.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter. Parameters:; H (Qobj) – system Hamiltonian, may be time-dependent for solver choice of me or; mc.; state0 (Qobj) – Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers.; tlist (array_like) – list of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input.; taulist (array_like) – list of times for \(\tau\). taulist must be positive and contain; the element 0.; c_ops (list) – list of collapse operators, may be time-dependent for solver choice of; me or mc.; a_op (Qobj) – operator A.; b_op (Qobj) – operator B.; reverse (bool) – If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\).; solver (str) – choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series).; options (Options) – solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:corr_mat – An 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. Return type:array. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_ss(H, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:83925,Integrability,depend,dependent,83925,"<A(t)B(t+\tau)\right>\) instead of; \(\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\).; solver (str) – choice of solver (me for master-equation and; es for exponential series).; options (Options) – solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:corr_vec – An array of correlation values for the times specified by tlist. Return type:array. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along one time axis using the quantum regression theorem and the evolution; solver indicated by the solver parameter. Parameters:; H (Qobj) – system Hamiltonian, may be time-dependent for solver choice of me or; mc.; state0 (Qobj) – Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers.; taulist (array_like) – list of times for \(\tau\). taulist must be positive and contain; the element 0.; c_ops (list) – list of collapse operators, may be time-dependent for solver choice of; me or mc.; a_op (Qobj) – operator A.; b_op (Qobj) – operator B.; reverse (bool {False, True}) – If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\).; solver (str {'me', 'mc', 'es'}) – choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series).; options (Options) – Solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:84368,Integrability,depend,dependent,84368,"turns:corr_vec – An array of correlation values for the times specified by tlist. Return type:array. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along one time axis using the quantum regression theorem and the evolution; solver indicated by the solver parameter. Parameters:; H (Qobj) – system Hamiltonian, may be time-dependent for solver choice of me or; mc.; state0 (Qobj) – Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers.; taulist (array_like) – list of times for \(\tau\). taulist must be positive and contain; the element 0.; c_ops (list) – list of collapse operators, may be time-dependent for solver choice of; me or mc.; a_op (Qobj) – operator A.; b_op (Qobj) – operator B.; reverse (bool {False, True}) – If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\).; solver (str {'me', 'mc', 'es'}) – choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series).; options (Options) – Solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:corr_vec – An array of correlation values for the times specified by tlist. Return type:ndarray. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:85559,Integrability,depend,dependent,85559,"ad of; \(\left<A(t+\tau)B(t)\right>\).; solver (str {'me', 'mc', 'es'}) – choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series).; options (Options) – Solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:corr_vec – An array of correlation values for the times specified by tlist. Return type:ndarray. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter. Parameters:; H (Qobj) – system Hamiltonian, may be time-dependent for solver choice of me or; mc.; state0 (Qobj) – Initial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers.; tlist (array_like) – list of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input.; taulist (array_like) – list of times for \(\tau\). taulist must be positive and contain; the element 0.; c_ops (list) – list of collapse operators, may be time-dependent for solver choice of; me or mc.; a_op (Qobj) – operator A.; b_op (Qobj) – operator B.; reverse (bool {False, True}) – If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\).; solver (str) – choice of solver (me for master-equation, mc for Mont",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:86260,Integrability,depend,dependent,86260,"=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter. Parameters:; H (Qobj) – system Hamiltonian, may be time-dependent for solver choice of me or; mc.; state0 (Qobj) – Initial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers.; tlist (array_like) – list of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input.; taulist (array_like) – list of times for \(\tau\). taulist must be positive and contain; the element 0.; c_ops (list) – list of collapse operators, may be time-dependent for solver choice of; me or mc.; a_op (Qobj) – operator A.; b_op (Qobj) – operator B.; reverse (bool {False, True}) – If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\).; solver (str) – choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series).; options (Options) – solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:corr_mat – An 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. Return type:ndarray. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, solver='me', args",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:87684,Integrability,depend,dependent,87684,"ause; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:corr_mat – An 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. Return type:ndarray. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the three-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along one time axis using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters:; H (Qobj) – system Hamiltonian, may be time-dependent for solver choice of me or; mc.; rho0 (Qobj) – Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers.; taulist (array_like) – list of times for \(\tau\). taulist must be positive and contain; the element 0.; c_ops (list) – list of collapse operators, may be time-dependent for solver choice of; me or mc.; a_op (Qobj) – operator A.; b_op (Qobj) – operator B.; c_op (Qobj) – operator C.; solver (str) – choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series).; options (Options) – solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:corr_vec – An array of correlation values for ",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:88125,Integrability,depend,dependent,88125,"eferences; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the three-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along one time axis using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters:; H (Qobj) – system Hamiltonian, may be time-dependent for solver choice of me or; mc.; rho0 (Qobj) – Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers.; taulist (array_like) – list of times for \(\tau\). taulist must be positive and contain; the element 0.; c_ops (list) – list of collapse operators, may be time-dependent for solver choice of; me or mc.; a_op (Qobj) – operator A.; b_op (Qobj) – operator B.; c_op (Qobj) – operator C.; solver (str) – choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series).; options (Options) – solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:corr_vec – An array of correlation values for the times specified by taulist. Return type:array. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the three-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by ",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:89302,Integrability,depend,dependent,89302,"r-equation, mc for Monte Carlo, and; es for exponential series).; options (Options) – solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:corr_vec – An array of correlation values for the times specified by taulist. Return type:array. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the three-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters:; H (Qobj) – system Hamiltonian, may be time-dependent for solver choice of me or; mc.; rho0 (Qobj) – Initial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers.; tlist (array_like) – list of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input.; taulist (array_like) – list of times for \(\tau\). taulist must be positive and contain; the element 0.; c_ops (list) – list of collapse operators, may be time-dependent for solver choice of; me or mc.; a_op (Qobj) – operator A.; b_op (Qobj) – operator B.; c_op (Qobj) – operator C.; solver (str) – choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series).; options (Options) – solver options class. ntraj is taken a",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:90001,Integrability,depend,dependent,90001,"A(t)B(t+\tau)C(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters:; H (Qobj) – system Hamiltonian, may be time-dependent for solver choice of me or; mc.; rho0 (Qobj) – Initial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers.; tlist (array_like) – list of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input.; taulist (array_like) – list of times for \(\tau\). taulist must be positive and contain; the element 0.; c_ops (list) – list of collapse operators, may be time-dependent for solver choice of; me or mc.; a_op (Qobj) – operator A.; b_op (Qobj) – operator B.; c_op (Qobj) – operator C.; solver (str) – choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series).; options (Options) – solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:corr_mat – An 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. Return type:array. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_4op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the four-operator two-time corr",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:91338,Integrability,depend,dependent,91338," correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:corr_mat – An 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. Return type:array. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_4op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\); along one time axis using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters:; H (Qobj) – system Hamiltonian, may be time-dependent for solver choice of me or; mc.; rho0 (Qobj) – Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers.; taulist (array_like) – list of times for \(\tau\). taulist must be positive and contain; the element 0.; c_ops (list) – list of collapse operators, may be time-dependent for solver choice of; me or mc.; a_op (Qobj) – operator A.; b_op (Qobj) – operator B.; c_op (Qobj) – operator C.; d_op (Qobj) – operator D.; solver (str) – choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series).; options (Options) – solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:corr_vec – An array",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:91779,Integrability,depend,dependent,91779,", Gardiner, Quantum Noise, Section 5.2. correlation_4op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\); along one time axis using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters:; H (Qobj) – system Hamiltonian, may be time-dependent for solver choice of me or; mc.; rho0 (Qobj) – Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers.; taulist (array_like) – list of times for \(\tau\). taulist must be positive and contain; the element 0.; c_ops (list) – list of collapse operators, may be time-dependent for solver choice of; me or mc.; a_op (Qobj) – operator A.; b_op (Qobj) – operator B.; c_op (Qobj) – operator C.; d_op (Qobj) – operator D.; solver (str) – choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series).; options (Options) – solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:corr_vec – An array of correlation values for the times specified by taulist. Return type:array. References; See, Gardiner, Quantum Noise, Section 5.2. Note; Deprecated in QuTiP 3.1; Use correlation_3op_1t() instead. correlation_4op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:93062,Integrability,depend,dependent,93062,"ons) – solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:corr_vec – An array of correlation values for the times specified by taulist. Return type:array. References; See, Gardiner, Quantum Noise, Section 5.2. Note; Deprecated in QuTiP 3.1; Use correlation_3op_1t() instead. correlation_4op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters:; H (Qobj) – system Hamiltonian, may be time-dependent for solver choice of me or; mc.; rho0 (Qobj) – Initial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers.; tlist (array_like) – list of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input.; taulist (array_like) – list of times for \(\tau\). taulist must be positive and contain; the element 0.; c_ops (list) – list of collapse operators, may be time-dependent for solver choice of; me or mc.; a_op (Qobj) – operator A.; b_op (Qobj) – operator B.; c_op (Qobj) – operator C.; d_op (Qobj) – operator D.; solver (str) – choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series).; options (Options) – solver opti",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:93761,Integrability,depend,dependent,93761,"tau)C(t+\tau)D(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters:; H (Qobj) – system Hamiltonian, may be time-dependent for solver choice of me or; mc.; rho0 (Qobj) – Initial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers.; tlist (array_like) – list of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input.; taulist (array_like) – list of times for \(\tau\). taulist must be positive and contain; the element 0.; c_ops (list) – list of collapse operators, may be time-dependent for solver choice of; me or mc.; a_op (Qobj) – operator A.; b_op (Qobj) – operator B.; c_op (Qobj) – operator C.; d_op (Qobj) – operator D.; solver (str) – choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series).; options (Options) – solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:corr_mat – An 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. Return type:array. References; See, Gardiner, Quantum Noise, Section 5.2. spectrum(H, wlist, c_ops, a_op, b_op, solver='es', use_pinv=False)[source]¶; Calculate the spectrum of the correlation function; \(\lim_{t \to \infty} \lef",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:98336,Integrability,depend,dependent,98336,")\) for the frequencies; specified in wlist. Return type:array. spectrum_correlation_fft(taulist, y)[source]¶; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters:; tlist (array_like) – list/array of times \(t\) which the correlation function is given.; y (array_like) – list/array of correlations corresponding to time delays \(t\). Returns:w, S – Returns an array of angular frequencies ‘w’ and the corresponding; one-sided power spectrum ‘S(w)’. Return type:tuple. coherence_function_g1(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized first-order quantum coherence function:. \[g^{(1)}(\tau) =; \frac{\langle A^\dagger(\tau)A(0)\rangle}; {\sqrt{\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters:; H (Qobj) – system Hamiltonian, may be time-dependent for solver choice of me or; mc.; state0 (Qobj) – Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers.; taulist (array_like) – list of times for \(\tau\). taulist must be positive and contain; the element 0.; c_ops (list) – list of collapse operators, may be time-dependent for solver choice of; me or mc.; a_op (Qobj) – operator A.; solver (str) – choice of solver (me for master-equation and; es for exponential series).; options (Options) – solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:g1, G1 – The normalized and unnormalized second-order coherence function. Return type:tuple. coherence_function_g2(H, s",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:98779,Integrability,depend,dependent,98779,"nd the corresponding; one-sided power spectrum ‘S(w)’. Return type:tuple. coherence_function_g1(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized first-order quantum coherence function:. \[g^{(1)}(\tau) =; \frac{\langle A^\dagger(\tau)A(0)\rangle}; {\sqrt{\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters:; H (Qobj) – system Hamiltonian, may be time-dependent for solver choice of me or; mc.; state0 (Qobj) – Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers.; taulist (array_like) – list of times for \(\tau\). taulist must be positive and contain; the element 0.; c_ops (list) – list of collapse operators, may be time-dependent for solver choice of; me or mc.; a_op (Qobj) – operator A.; solver (str) – choice of solver (me for master-equation and; es for exponential series).; options (Options) – solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:g1, G1 – The normalized and unnormalized second-order coherence function. Return type:tuple. coherence_function_g2(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized second-order quantum coherence function:. \[ g^{(2)}(\tau) =; \frac{\langle A^\dagger(0)A^\dagger(\tau)A(\tau)A(0)\rangle}; {\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters:; H (Qobj",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:99807,Integrability,depend,dependent,99807," choice of; me or mc.; a_op (Qobj) – operator A.; solver (str) – choice of solver (me for master-equation and; es for exponential series).; options (Options) – solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:g1, G1 – The normalized and unnormalized second-order coherence function. Return type:tuple. coherence_function_g2(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized second-order quantum coherence function:. \[ g^{(2)}(\tau) =; \frac{\langle A^\dagger(0)A^\dagger(\tau)A(\tau)A(0)\rangle}; {\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters:; H (Qobj) – system Hamiltonian, may be time-dependent for solver choice of me or; mc.; state0 (Qobj) – Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers.; taulist (array_like) – list of times for \(\tau\). taulist must be positive and contain; the element 0.; c_ops (list) – list of collapse operators, may be time-dependent for solver choice of; me or mc.; a_op (Qobj) – operator A.; solver (str) – choice of solver (me for master-equation and; es for exponential series).; options (Options) – solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:g2, G2 – The normalized and unnormalized second-order coherence function. Return type:tuple. Steady-state Solvers¶; Mod",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:100250,Integrability,depend,dependent,100250,"malized second-order coherence function. Return type:tuple. coherence_function_g2(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized second-order quantum coherence function:. \[ g^{(2)}(\tau) =; \frac{\langle A^\dagger(0)A^\dagger(\tau)A(\tau)A(0)\rangle}; {\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters:; H (Qobj) – system Hamiltonian, may be time-dependent for solver choice of me or; mc.; state0 (Qobj) – Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers.; taulist (array_like) – list of times for \(\tau\). taulist must be positive and contain; the element 0.; c_ops (list) – list of collapse operators, may be time-dependent for solver choice of; me or mc.; a_op (Qobj) – operator A.; solver (str) – choice of solver (me for master-equation and; es for exponential series).; options (Options) – solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:g2, G2 – The normalized and unnormalized second-order coherence function. Return type:tuple. Steady-state Solvers¶; Module contains functions for solving for the steady state density matrix of; open quantum systems defined by a Liouvillian or Hamiltonian and a list of; collapse operators. steadystate(A, c_op_list=[], **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along wit",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:108572,Integrability,depend,dependent,108572,"1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element.; ILU_MILU (str, optional, default = 'smilu_2') – Selects the incomplete LU decomposition method algoithm used in; creating the preconditoner. Should only be used by advanced users. Returns:; lu (object) – Returns a SuperLU object representing iLU preconditioner.; info (dict, optional) – Dictionary containing solver-specific information. Propagators¶. propagator(H, t, c_op_list=[], args={}, options=None, unitary_mode='batch', parallel=False, progress_bar=None, **kwargs)[source]¶; Calculate the propagator U(t) for the density matrix or wave function such; that \(\psi(t) = U(t)\psi(0)\) or; \(\rho_{\mathrm vec}(t) = U(t) \rho_{\mathrm vec}(0)\); where \(\rho_{\mathrm vec}\) is the vector representation of the; density matrix. Parameters:; H (qobj or list) – Hamiltonian as a Qobj instance of a nested list of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in qutip.mesolve).; t (float or array-like) – Time or list of times for which to evaluate the propagator.; c_op_list (list) – List of qobj collapse operators.; args (list/array/dictionary) – Parameters to callback functions for time-dependent Hamiltonians and; collapse operators.; options (qutip.Options) – with options for the ODE solver.; = str ('batch', 'single') (unitary_mode) – Solve all basis vectors simulaneously (‘batch’) or individually; (‘single’).; parallel (bool {False, True}) – Run the propagator in parallel mode. This will override the; unitary_mode settings if set to True.; progress_bar (BaseProgressBar) – Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns:a – Instance representing the propagator \(U(t)\). Return type:qobj. propa",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:108845,Integrability,depend,dependent,108845,"y be used by advanced users. Returns:; lu (object) – Returns a SuperLU object representing iLU preconditioner.; info (dict, optional) – Dictionary containing solver-specific information. Propagators¶. propagator(H, t, c_op_list=[], args={}, options=None, unitary_mode='batch', parallel=False, progress_bar=None, **kwargs)[source]¶; Calculate the propagator U(t) for the density matrix or wave function such; that \(\psi(t) = U(t)\psi(0)\) or; \(\rho_{\mathrm vec}(t) = U(t) \rho_{\mathrm vec}(0)\); where \(\rho_{\mathrm vec}\) is the vector representation of the; density matrix. Parameters:; H (qobj or list) – Hamiltonian as a Qobj instance of a nested list of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in qutip.mesolve).; t (float or array-like) – Time or list of times for which to evaluate the propagator.; c_op_list (list) – List of qobj collapse operators.; args (list/array/dictionary) – Parameters to callback functions for time-dependent Hamiltonians and; collapse operators.; options (qutip.Options) – with options for the ODE solver.; = str ('batch', 'single') (unitary_mode) – Solve all basis vectors simulaneously (‘batch’) or individually; (‘single’).; parallel (bool {False, True}) – Run the propagator in parallel mode. This will override the; unitary_mode settings if set to True.; progress_bar (BaseProgressBar) – Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns:a – Instance representing the propagator \(U(t)\). Return type:qobj. propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters:U (qobj) – Operator representing the propagator. Returns:a – Instance representing the steady-state density matrix. Return type:qobj. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, optio",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:109773,Integrability,depend,dependent,109773,"st/array/dictionary) – Parameters to callback functions for time-dependent Hamiltonians and; collapse operators.; options (qutip.Options) – with options for the ODE solver.; = str ('batch', 'single') (unitary_mode) – Solve all basis vectors simulaneously (‘batch’) or individually; (‘single’).; parallel (bool {False, True}) – Run the propagator in parallel mode. This will override the; unitary_mode settings if set to True.; progress_bar (BaseProgressBar) – Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns:a – Instance representing the propagator \(U(t)\). Return type:qobj. propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters:U (qobj) – Operator representing the propagator. Returns:a – Instance representing the steady-state density matrix. Return type:qobj. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters:; H (qobj) – System Hamiltonian.; c_ops (list) – list of collapse operators.; args (dict) – Arguments for time-dependent Hamiltonian and collapse operator terms.; options (Options) – Instance of ODE solver options.; name (str) – Name of generated RHS; cleanup (bool) – Whether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns:. Return type:Nothing, just clears data from internal config module. Visualization¶. Pseudoprobability Functions¶. qfunc(state, xvec, yvec, g=1.4142135623730951)[source]¶; Q-function of a given state",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:110153,Integrability,depend,dependent,110153,"de the; unitary_mode settings if set to True.; progress_bar (BaseProgressBar) – Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns:a – Instance representing the propagator \(U(t)\). Return type:qobj. propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters:U (qobj) – Operator representing the propagator. Returns:a – Instance representing the steady-state density matrix. Return type:qobj. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters:; H (qobj) – System Hamiltonian.; c_ops (list) – list of collapse operators.; args (dict) – Arguments for time-dependent Hamiltonian and collapse operator terms.; options (Options) – Instance of ODE solver options.; name (str) – Name of generated RHS; cleanup (bool) – Whether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns:. Return type:Nothing, just clears data from internal config module. Visualization¶. Pseudoprobability Functions¶. qfunc(state, xvec, yvec, g=1.4142135623730951)[source]¶; Q-function of a given state vector or density matrix; at points xvec + i * yvec. Parameters:; state (qobj) – A state vector or density matrix.; xvec (array_like) – x-coordinates at which to calculate the Wigner function.; yvec (array_like) – y-coordinates at which to calculate the Wigner function.; g (float) – Scaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2). Returns:Q – Values representing ",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:110539,Integrability,depend,dependent,110539,"tate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters:U (qobj) – Operator representing the propagator. Returns:a – Instance representing the steady-state density matrix. Return type:qobj. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters:; H (qobj) – System Hamiltonian.; c_ops (list) – list of collapse operators.; args (dict) – Arguments for time-dependent Hamiltonian and collapse operator terms.; options (Options) – Instance of ODE solver options.; name (str) – Name of generated RHS; cleanup (bool) – Whether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns:. Return type:Nothing, just clears data from internal config module. Visualization¶. Pseudoprobability Functions¶. qfunc(state, xvec, yvec, g=1.4142135623730951)[source]¶; Q-function of a given state vector or density matrix; at points xvec + i * yvec. Parameters:; state (qobj) – A state vector or density matrix.; xvec (array_like) – x-coordinates at which to calculate the Wigner function.; yvec (array_like) – y-coordinates at which to calculate the Wigner function.; g (float) – Scaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2). Returns:Q – Values representing the Q-function calculated over the specified range; [xvec,yvec]. Return type:array. spin_q_function(rho, theta, phi)[source]¶; Husimi Q-function for spins. Parameters:; state (qobj) – A state vector or density matrix for a spin-j quantum system.; theta (array_like) – theta-coordinates at which to calculate the Q function.; phi (array_like) – phi-coordinates at which",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:147102,Integrability,depend,dependent,147102,"id_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters:; drift (Qobj or list of Qobj) – the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift; ctrls (List of Qobj) – a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; initial (Qobj) – starting point for the evolution.; Typically the identity matrix; target (Qobj) – target transformation, e.g. gate or state, for the time evolution; num_tslots (integer or None) – number of timeslots.; None implies that timeslots will be given in the tau array; evo_time (float or None) – total time for the evolution; None implies that timeslots will be given in the tau array; tau (array[num_tslots] of floats or None) – durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots; amp_lbound (float or list of floats) – lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control; amp_ubound (float or li",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:149561,Integrability,depend,dependent,149561,"– Maximum number of iterations of the optimisation algorithm; max_wall_time (float) – Maximum allowed elapsed time for the optimisation algorithm; alg (string) – Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params (Dictionary) – options that are specific to the algorithm see above; optim_params (Dictionary) – The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; optim_method (string) – a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; optim_alg (string) – Deprecated. Use optim_method.; max_metric_corr (integer) – Deprecated. Use method_params instead; accuracy_factor (float) – Deprecated. Use method_params instead; dyn_type (string) – Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); dyn_params (dict) – Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; prop_type (string) – Propagator type i.e. the method used to calculate the; propagt",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:155055,Integrability,wrap,wrapper,155055,"nal amplitudes, statistics etc. Return type:OptimResult. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters:; H_d (Qobj or list of Qobj) – Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift; H_c (Qobj) – a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; U_0 (Qobj) – starting point for the evolution.; Typically the identity matrix; U_targ (",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:155955,Integrability,depend,dependent,155955,"ol pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters:; H_d (Qobj or list of Qobj) – Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift; H_c (Qobj) – a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; U_0 (Qobj) – starting point for the evolution.; Typically the identity matrix; U_targ (Qobj) – target transformation, e.g. gate or state, for the time evolution; num_tslots (integer or None) – number of timeslots.; None implies that timeslots will be given in the tau array; evo_time (float or None) – total time for the evolution; None implies that timeslots will be given in the tau array; tau (array[num_tslots] of floats or None) – durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots; amp_lbound (float or list of floats) – lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control; amp_ubound (float or list of f",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:158393,Integrability,depend,dependent,158393,"– Maximum number of iterations of the optimisation algorithm; max_wall_time (float) – Maximum allowed elapsed time for the optimisation algorithm; alg (string) – Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params (Dictionary) – options that are specific to the algorithm see above; optim_params (Dictionary) – The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; optim_method (string) – a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; optim_alg (string) – Deprecated. Use optim_method.; max_metric_corr (integer) – Deprecated. Use method_params instead; accuracy_factor (float) – Deprecated. Use method_params instead; phase_option (string) – determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params (dict) – Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; prop_params (dict) – Parameters for the PropagatorComputer object",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:163693,Integrability,depend,dependent,163693,"ams=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, gen_stats=False)[source]¶; Generate the objects of the appropriate subclasses; required for the pulse optmisation based on the parameters given; Note this method may be preferable to calling optimize_pulse; if more detailed configuration is required before running the; optmisation algorthim, or the algorithm will be run many times,; for instances when trying to finding global the optimum or; minimum time optimisation. Parameters:; drift (Qobj or list of Qobj) – the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift; ctrls (List of Qobj) – a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; initial (Qobj) – starting point for the evolution.; Typically the identity matrix; target (Qobj) – target transformation, e.g. gate or state, for the time evolution; num_tslots (integer or None) – number of timeslots.; None implies that timeslots will be given in the tau array; evo_time (float or None) – total time for the evolution; None implies that timeslots will be given in the tau array; tau (array[num_tslots] of floats or None) – durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots; amp_lbound (float or list of floats) – lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control; amp_ubound (float or li",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:166152,Integrability,depend,dependent,166152,"– Maximum number of iterations of the optimisation algorithm; max_wall_time (float) – Maximum allowed elapsed time for the optimisation algorithm; alg (string) – Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params (Dictionary) – options that are specific to the algorithm see above; optim_params (Dictionary) – The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; optim_method (string) – a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; optim_alg (string) – Deprecated. Use optim_method.; max_metric_corr (integer) – Deprecated. Use method_params instead; accuracy_factor (float) – Deprecated. Use method_params instead; dyn_type (string) – Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); dyn_params (dict) – Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; prop_type (string) – Propagator type i.e. the method used to calculate the; ",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:172283,Integrability,depend,dependent,172283,"ulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters:; drift (Qobj or list of Qobj) – the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift; ctrls (List of Qobj) – a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; initial (Qobj) – starting point for the evolution.; Typically the identity matrix; target (Qobj) – target transformation, e.g. gate or state, for the time evolution; num_tslots (integer or None) – number of timeslots.; None implies that timeslots will be given in the tau array; evo_time (float or None) – total time for the evolution; None implies that timeslots will be given in the tau array; tau (array[num_tslots] of floats or None) – durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots; amp_lbound (float or list of floats) – lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control; amp_ubound (float or li",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:179944,Integrability,wrap,wrapper,179944,"rror, final evolution; final amplitudes, statistics etc. Return type:OptimResult. opt_pulse_crab_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters:; H_d (Qobj or list of Qobj) – Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift; H_c (Qobj) – a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; U_0 (Qobj) – starting point for the evolution.; Typically",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:180874,Integrability,depend,dependent,180874,"ity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters:; H_d (Qobj or list of Qobj) – Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift; H_c (Qobj) – a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; U_0 (Qobj) – starting point for the evolution.; Typically the identity matrix; U_targ (Qobj) – target transformation, e.g. gate or state, for the time evolution; num_tslots (integer or None) – number of timeslots.; None implies that timeslots will be given in the tau array; evo_time (float or None) – total time for the evolution; None implies that timeslots will be given in the tau array; tau (array[num_tslots] of floats or None) – durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots; amp_lbound (float or list of floats) – lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control; amp_ubound (float or list of f",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:188548,Integrability,rout,routines,188548,"; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot; These are the other non-periodic options:. LIN - Linear, i.e. contant gradient over the time; ZERO - special case of the LIN pulse, where the gradient is 0; These are the periodic options. SINE - Sine wave; SQUARE - Square wave; SAW - Saw tooth wave; TRIANGLE - Triangular wave; If a Dynamics object is passed in then this is used in instantiate; the PulseGen, meaning that some timeslot and amplitude properties; are copied over. Utilitiy Functions¶. Graph Theory Routines¶; This module contains a collection of graph theory routines used mainly; to reorder matrices for iterative steady state solvers. breadth_first_search(A, start)[source]¶; Breadth-First-Search (BFS) of a graph in CSR or CSC matrix format starting; from a given node (row). Takes Qobjs and CSR or CSC matrices as inputs.; This function requires a matrix with symmetric structure.; Use A+trans(A) if original matrix is not symmetric or not sure. Parameters:; A (csc_matrix, csr_matrix) – Input graph in CSC or CSR matrix format; start (int) – Staring node for BFS traversal. Returns:; order (array) – Order in which nodes are traversed from starting node.; levels (array) – Level of the nodes in the order that they are traversed. graph_degree(A)[source]¶; Returns the degree for the nodes (rows) of a symmetric; graph in sparse CSR or CSC format, or a qobj. Parameters:A (qobj, csr_matrix, csc_matrix) – Input quantum object or csr_matrix. Returns:degree – Array of integers giving the degree for each node (row). Return type:array. reverse_cuthill_mckee(",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:189726,Integrability,rout,routine,189726," from a given node (row). Takes Qobjs and CSR or CSC matrices as inputs.; This function requires a matrix with symmetric structure.; Use A+trans(A) if original matrix is not symmetric or not sure. Parameters:; A (csc_matrix, csr_matrix) – Input graph in CSC or CSR matrix format; start (int) – Staring node for BFS traversal. Returns:; order (array) – Order in which nodes are traversed from starting node.; levels (array) – Level of the nodes in the order that they are traversed. graph_degree(A)[source]¶; Returns the degree for the nodes (rows) of a symmetric; graph in sparse CSR or CSC format, or a qobj. Parameters:A (qobj, csr_matrix, csc_matrix) – Input quantum object or csr_matrix. Returns:degree – Array of integers giving the degree for each node (row). Return type:array. reverse_cuthill_mckee(A, sym=False)[source]¶; Returns the permutation array that orders a sparse CSR or CSC matrix; in Reverse-Cuthill McKee ordering. Since the input matrix must be; symmetric, this routine works on the matrix A+Trans(A) if the sym flag is; set to False (Default).; It is assumed by default (sym=False) that the input matrix is not; symmetric. This is because it is faster to do A+Trans(A) than it is to; check for symmetry for a generic matrix. If you are guaranteed that the; matrix is symmetric in structure (values of matrix element do not matter); then set sym=True. Parameters:; A (csc_matrix, csr_matrix) – Input sparse CSC or CSR sparse matrix format.; sym (bool {False, True}) – Flag to set whether input matrix is symmetric. Returns:perm – Array of permuted row and column indices. Return type:array. Notes; This routine is used primarily for internal reordering of Lindblad; superoperators for use in iterative solver routines. References; E. Cuthill and J. McKee, “Reducing the Bandwidth of Sparse Symmetric; Matrices”, ACM ‘69 Proceedings of the 1969 24th national conference,; (1969). maximum_bipartite_matching(A, perm_type='row')[source]¶; Returns an array of row or column permutati",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:190367,Integrability,rout,routine,190367," or csr_matrix. Returns:degree – Array of integers giving the degree for each node (row). Return type:array. reverse_cuthill_mckee(A, sym=False)[source]¶; Returns the permutation array that orders a sparse CSR or CSC matrix; in Reverse-Cuthill McKee ordering. Since the input matrix must be; symmetric, this routine works on the matrix A+Trans(A) if the sym flag is; set to False (Default).; It is assumed by default (sym=False) that the input matrix is not; symmetric. This is because it is faster to do A+Trans(A) than it is to; check for symmetry for a generic matrix. If you are guaranteed that the; matrix is symmetric in structure (values of matrix element do not matter); then set sym=True. Parameters:; A (csc_matrix, csr_matrix) – Input sparse CSC or CSR sparse matrix format.; sym (bool {False, True}) – Flag to set whether input matrix is symmetric. Returns:perm – Array of permuted row and column indices. Return type:array. Notes; This routine is used primarily for internal reordering of Lindblad; superoperators for use in iterative solver routines. References; E. Cuthill and J. McKee, “Reducing the Bandwidth of Sparse Symmetric; Matrices”, ACM ‘69 Proceedings of the 1969 24th national conference,; (1969). maximum_bipartite_matching(A, perm_type='row')[source]¶; Returns an array of row or column permutations that removes nonzero; elements from the diagonal of a nonsingular square CSC sparse matrix. Such; a permutation is always possible provided that the matrix is nonsingular.; This function looks at the structure of the matrix only.; The input matrix will be converted to CSC matrix format if; necessary. Parameters:; A (sparse matrix) – Input matrix; perm_type (str {'row', 'column'}) – Type of permutation to generate. Returns:perm – Array of row or column permutations. Return type:array. Notes; This function relies on a maximum cardinality bipartite matching algorithm; based on a breadth-first search (BFS) of the underlying graph[1]_. References; I. S. Duff, K. Kaya,",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:190473,Integrability,rout,routines,190473," or csr_matrix. Returns:degree – Array of integers giving the degree for each node (row). Return type:array. reverse_cuthill_mckee(A, sym=False)[source]¶; Returns the permutation array that orders a sparse CSR or CSC matrix; in Reverse-Cuthill McKee ordering. Since the input matrix must be; symmetric, this routine works on the matrix A+Trans(A) if the sym flag is; set to False (Default).; It is assumed by default (sym=False) that the input matrix is not; symmetric. This is because it is faster to do A+Trans(A) than it is to; check for symmetry for a generic matrix. If you are guaranteed that the; matrix is symmetric in structure (values of matrix element do not matter); then set sym=True. Parameters:; A (csc_matrix, csr_matrix) – Input sparse CSC or CSR sparse matrix format.; sym (bool {False, True}) – Flag to set whether input matrix is symmetric. Returns:perm – Array of permuted row and column indices. Return type:array. Notes; This routine is used primarily for internal reordering of Lindblad; superoperators for use in iterative solver routines. References; E. Cuthill and J. McKee, “Reducing the Bandwidth of Sparse Symmetric; Matrices”, ACM ‘69 Proceedings of the 1969 24th national conference,; (1969). maximum_bipartite_matching(A, perm_type='row')[source]¶; Returns an array of row or column permutations that removes nonzero; elements from the diagonal of a nonsingular square CSC sparse matrix. Such; a permutation is always possible provided that the matrix is nonsingular.; This function looks at the structure of the matrix only.; The input matrix will be converted to CSC matrix format if; necessary. Parameters:; A (sparse matrix) – Input matrix; perm_type (str {'row', 'column'}) – Type of permutation to generate. Returns:perm – Array of row or column permutations. Return type:array. Notes; This function relies on a maximum cardinality bipartite matching algorithm; based on a breadth-first search (BFS) of the underlying graph[1]_. References; I. S. Duff, K. Kaya,",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:203048,Integrability,depend,dependencies,203048,"args (list / dictionary) – The optional additional keyword argument to the task function.; client (IPython.parallel.Client) – The IPython.parallel Client instance that will be used in the; parfor execution.; view (a IPython.parallel.Client view) – The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view().; show_scheduling (bool {False, True}, default False) – Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster.; show_progressbar (bool {False, True}, default False) – Display a HTML-based progress bar during the execution of the parfor; loop. Returns:result – The result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. Return type:list. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns:version_table – Return an HTML-formatted string containing version information for; QuTiP dependencies. Return type:string. Miscellaneous¶. about()[source]¶; About box for QuTiP. Gives version numbers for; QuTiP, NumPy, SciPy, Cython, and MatPlotLib. simdiag(ops, evals=True)[source]¶; Simulateous diagonalization of communting Hermitian matrices.. Parameters:ops (list/array) – list or array of qobjs representing commuting Hermitian; operators. Returns:eigs – Tuple of arrays representing eigvecs and eigvals of quantum objects; corresponding to simultaneous eigenvectors and eigenvalues for each; operator. Return type:tuple. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granad",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:203360,Integrability,depend,dependencies,203360,"Client) – The IPython.parallel Client instance that will be used in the; parfor execution.; view (a IPython.parallel.Client view) – The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view().; show_scheduling (bool {False, True}, default False) – Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster.; show_progressbar (bool {False, True}, default False) – Display a HTML-based progress bar during the execution of the parfor; loop. Returns:result – The result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. Return type:list. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns:version_table – Return an HTML-formatted string containing version information for; QuTiP dependencies. Return type:string. Miscellaneous¶. about()[source]¶; About box for QuTiP. Gives version numbers for; QuTiP, NumPy, SciPy, Cython, and MatPlotLib. simdiag(ops, evals=True)[source]¶; Simulateous diagonalization of communting Hermitian matrices.. Parameters:ops (list/array) – list or array of qobjs representing commuting Hermitian; operators. Returns:eigs – Tuple of arrays representing eigvecs and eigvals of quantum objects; corresponding to simultaneous eigenvectors and eigenvalues for each; operator. Return type:tuple. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:36755,Modifiability,config,configuration,36755," less than full-rank,; zero eigenvalues may become slightly negative, such that the; returned operator is not actually completely positive. Parameters:; N (int) – Square root of the dimension of the superoperator to be returned.; enforce_tp (bool) – If True, the trace-preserving condition of [BCSZ08] is enforced;; otherwise only complete positivity is enforced.; rank (int or None) – Rank of the sampled superoperator. If None, a full-rank; superoperator is generated.; dims (list) – Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[[N],[N]], [[N],[N]]]. Returns:rho – A superoperator acting on vectorized dim × dim density operators,; sampled from the BCSZ distribution. Return type:Qobj. Three-Level Atoms¶; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations:; Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; The naming of qutip operators follows the convention in [R1] . [R1]Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()[source]¶; Basis states for a three level atom. Returns:states – array of three level atom basis vectors. Return type:array. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns:ops – array of three level operators. Return type:array. Superoperators and Liouvillians¶. operator_to_vector(op)[source]¶; Create a vector representation of a quantum operator given; the matrix representation.",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:36844,Modifiability,config,configurations,36844,"operator to be returned.; enforce_tp (bool) – If True, the trace-preserving condition of [BCSZ08] is enforced;; otherwise only complete positivity is enforced.; rank (int or None) – Rank of the sampled superoperator. If None, a full-rank; superoperator is generated.; dims (list) – Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[[N],[N]], [[N],[N]]]. Returns:rho – A superoperator acting on vectorized dim × dim density operators,; sampled from the BCSZ distribution. Return type:Qobj. Three-Level Atoms¶; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations:; Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; The naming of qutip operators follows the convention in [R1] . [R1]Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()[source]¶; Basis states for a three level atom. Returns:states – array of three level atom basis vectors. Return type:array. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns:ops – array of three level operators. Return type:array. Superoperators and Liouvillians¶. operator_to_vector(op)[source]¶; Create a vector representation of a quantum operator given; the matrix representation. vector_to_operator(op)[source]¶; Create a matrix representation given a quantum operator in; vector form. liouvillian(H, c_ops=[], data_only=False, chi=None)[source]¶; Assembles the Liouvillian superoper",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:50331,Modifiability,variab,variable,50331," matrices A & B. Parameters:; A (qobj) – Density matrix or state vector.; B (qobj) – Density matrix or state vector with same dimensions as A. Returns:dist – Hilbert-Schmidt distance between density matrices. Return type:float. Notes; See V. Vedral and M. B. Plenio, Phys. Rev. A 57, 1619 (1998). average_gate_fidelity(oper, target=None)[source]¶; Given a Qobj representing the supermatrix form of a map, returns the; average gate fidelity (pseudo-metric) of that map. Parameters:; A (Qobj) – Quantum object representing a superoperator.; target (Qobj) – Quantum object representing the target unitary; the inverse; is applied before evaluating the fidelity. Returns:fid – Fidelity pseudo-metric between A and the identity superoperator,; or between A and the target superunitary. Return type:float. process_fidelity(U1, U2, normalize=True)[source]¶; Calculate the process fidelity given two process operators. Continous Variables¶; This module contains a collection functions for calculating continuous variable; quantities from fock-basis representation of the state of multi-mode fields. correlation_matrix(basis, rho=None)[source]¶; Given a basis set of operators \(\{a\}_n\), calculate the correlation; matrix:. \[C_{mn} = \langle a_m a_n \rangle\]. Parameters:; basis (list) – List of operators that defines the basis for the correlation matrix.; rho (Qobj) – Density matrix for which to calculate the correlation matrix. If; rho is None, then a matrix of correlation matrix operators is; returned instead of expectation values of those operators. Returns:corr_mat – A 2-dimensional array of correlation values or operators. Return type:ndarray. covariance_matrix(basis, rho, symmetrized=True)[source]¶; Given a basis set of operators \(\{a\}_n\), calculate the covariance; matrix:. \[V_{mn} = \frac{1}{2}\langle a_m a_n + a_n a_m \rangle -; \langle a_m \rangle \langle a_n\rangle\]; or, if of the optional argument symmetrized=False,. \[V_{mn} = \langle a_m a_n\rangle -; \langle a_m \rangle \",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:56672,Modifiability,evolve,evolved,56672," – An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors or density matrices corresponding to the; times in tlist [if e_ops is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. Return type:qutip.solver. Master Equation¶; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops=[], e_ops=[], args={}, options=None, progress_bar=None, _safe_mode=True)[source]¶; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian (H) and an [optional] set of collapse operators; (c_ops), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; If either H or the Qobj elements in c_ops are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows to solve master equations that are not on standard Lindblad; form by passing a custom Liouvillian in place of either the H or c_ops; elements.; Time-dependent operators; For time-dependent problems, H and c_ops can be callback; functions that takes two arguments, time and args, and returns the; Hamiltonian or Liouvillian for the system at that point in time; (callback format).; Alternatively, H and c_ops can be a specified in a nested-list format; where each element in the list is a l",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:66466,Modifiability,coupling,coupling,66466,"solver does not currently support time-dependent Hamiltonians. Parameters:; H (qutip.Qobj) – System Hamiltonian.; / psi0 (rho0) – Initial density matrix or state vector (ket).; tlist (list / array) – List of times for \(t\).; a_ops (list of qutip.qobj) – List of system operators that couple to bath degrees of freedom.; e_ops (list of qutip.qobj / callback function) – List of operators for which to evaluate expectation values.; c_ops (list of qutip.qobj) – List of system collapse operators.; args (dictionary) – Placeholder for future implementation, kept for API consistency.; options (qutip.solver.Options) – Options for the solver. Returns:result – An instance of the class qutip.solver.Result, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by tlist. Return type:qutip.solver.Result. bloch_redfield_tensor(H, a_ops, spectra_cb, c_ops=[], use_secular=True)[source]¶; Calculate the Bloch-Redfield tensor for a system given a set of operators; and corresponding spectral functions that describes the system’s coupling; to its environment. Note; This tensor generation requires a time-independent Hamiltonian. Parameters:; H (qutip.qobj) – System Hamiltonian.; a_ops (list of qutip.qobj) – List of system operators that couple to the environment.; spectra_cb (list of callback functions) – List of callback functions that evaluate the noise power spectrum; at a given frequency.; c_ops (list of qutip.qobj) – List of system collapse operators.; use_secular (bool) – Flag (True of False) that indicates if the secular approximation should; be used. Returns:R, kets – R is the Bloch-Redfield tensor and kets is a list eigenstates of the; Hamiltonian. Return type:qutip.Qobj, list of qutip.Qobj. bloch_redfield_solve(R, ekets, rho0, tlist, e_ops=[], options=None)[source]¶; Evolve the ODEs defined by Bloch-Redfield master equation. The; Bloch-Redfield tensor can be calculated by the function; bloch_redfield_tensor",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:70350,Modifiability,variab,variables,70350,"se the following conversion; >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options (qutip.solver) – options for the ODE solver.; k_max (int) – The truncation of the number of sidebands (default 5). Returns:output – An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. Return type:qutip.solver. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter sort; decides if the output is to be sorted in increasing quasienergies or not. Parameters:; H (qutip.qobj) – system Hamiltonian, time-dependent with period T; args (dictionary) – dictionary with variables required to evaluate H; T (float) – The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving.; U (qutip.qobj) – The propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns:output – Two lists: the Floquet modes as kets and the quasi energies. Return type:list of kets, list of quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters:; f_modes_0 (list of qutip.qobj (kets)) – Floquet modes at \(t\); f_energies (list) – Floquet energies.; t (float) – The time at which to evaluate the floquet modes.; H (qutip.qobj) – system Hamiltonian, time-dependent with period T; args (dictionary) – dictionary with variables required to evaluate H;",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:71320,Modifiability,variab,variables,71320,"ctionary) – dictionary with variables required to evaluate H; T (float) – The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving.; U (qutip.qobj) – The propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns:output – Two lists: the Floquet modes as kets and the quasi energies. Return type:list of kets, list of quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters:; f_modes_0 (list of qutip.qobj (kets)) – Floquet modes at \(t\); f_energies (list) – Floquet energies.; t (float) – The time at which to evaluate the floquet modes.; H (qutip.qobj) – system Hamiltonian, time-dependent with period T; args (dictionary) – dictionary with variables required to evaluate H; T (float) – The period of the time-dependence of the hamiltonian. Returns:output – The Floquet modes as kets at time \(t\). Return type:list of kets. floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)[source]¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters:; f_modes_0 (list of qutip.qobj (kets)) – Floquet modes at \(t\); f_energies (list) – Floquet energies.; tlist (array) – The list of times at which to evaluate the floquet modes.; H (qutip.qobj) – system Hamiltonian, time-dependent with period T; T (float) – The period of the time-dependence of the hamiltonian.; args (dictionary) – dictionary with variables required to evaluate H. Returns:output – A nested list of Floquet modes as kets for each time in tlist. Return type:nested list. floquet_modes_t_lookup(f_modes_table_t, t, T)[source]¶; Lookup the floquet mode at tim",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:72098,Modifiability,variab,variables,72098,"quet modes at \(t\); f_energies (list) – Floquet energies.; t (float) – The time at which to evaluate the floquet modes.; H (qutip.qobj) – system Hamiltonian, time-dependent with period T; args (dictionary) – dictionary with variables required to evaluate H; T (float) – The period of the time-dependence of the hamiltonian. Returns:output – The Floquet modes as kets at time \(t\). Return type:list of kets. floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)[source]¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters:; f_modes_0 (list of qutip.qobj (kets)) – Floquet modes at \(t\); f_energies (list) – Floquet energies.; tlist (array) – The list of times at which to evaluate the floquet modes.; H (qutip.qobj) – system Hamiltonian, time-dependent with period T; T (float) – The period of the time-dependence of the hamiltonian.; args (dictionary) – dictionary with variables required to evaluate H. Returns:output – A nested list of Floquet modes as kets for each time in tlist. Return type:nested list. floquet_modes_t_lookup(f_modes_table_t, t, T)[source]¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters:; f_modes_table_t (nested list of qutip.qobj (kets)) – A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table.; t (float) – The time for which to evaluate the Floquet modes.; T (float) – The period of the time-dependence of the hamiltonian. Returns:output – A list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. Return type:nested list. floquet_states_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Evaluate the floquet states at time t given the initial Floquet modes. Parameters:; f_modes_t (list of qutip.qobj (kets)) – A list of initial Floquet mod",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:73399,Modifiability,variab,variables,73399,"the time-dependence. Parameters:; f_modes_table_t (nested list of qutip.qobj (kets)) – A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table.; t (float) – The time for which to evaluate the Floquet modes.; T (float) – The period of the time-dependence of the hamiltonian. Returns:output – A list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. Return type:nested list. floquet_states_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Evaluate the floquet states at time t given the initial Floquet modes. Parameters:; f_modes_t (list of qutip.qobj (kets)) – A list of initial Floquet modes (for time \(t=0\)).; f_energies (array) – The Floquet energies.; t (float) – The time for which to evaluate the Floquet states.; H (qutip.qobj) – System Hamiltonian, time-dependent with period T.; T (float) – The period of the time-dependence of the hamiltonian.; args (dictionary) – Dictionary with variables required to evaluate H. Returns:output – A list of Floquet states for the time \(t\). Return type:list. floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters:; f_modes_t (list of qutip.qobj (kets)) – A list of initial Floquet modes (for time \(t=0\)).; f_energies (array) – The Floquet energies.; f_coeff (array) – The coefficients for Floquet decomposition of the initial wavefunction.; t (float) – The time for which to evaluate the Floquet states.; H (qutip.qobj) – System Hamiltonian, time-dependent with period T.; T (float) – The period of the time-dependence of the hamiltonian.; args (dictionary) – Dictionary with variables required to evaluate H. Returns:output – The wavefunction for the time \(t\). Return type:qutip.qobj. floquet_state_decomposition(f_states, f_energies, psi)[source]¶; Decompose the wavefunction psi (typ",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:74185,Modifiability,variab,variables,74185,"me for which to evaluate the Floquet states.; H (qutip.qobj) – System Hamiltonian, time-dependent with period T.; T (float) – The period of the time-dependence of the hamiltonian.; args (dictionary) – Dictionary with variables required to evaluate H. Returns:output – A list of Floquet states for the time \(t\). Return type:list. floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters:; f_modes_t (list of qutip.qobj (kets)) – A list of initial Floquet modes (for time \(t=0\)).; f_energies (array) – The Floquet energies.; f_coeff (array) – The coefficients for Floquet decomposition of the initial wavefunction.; t (float) – The time for which to evaluate the Floquet states.; H (qutip.qobj) – System Hamiltonian, time-dependent with period T.; T (float) – The period of the time-dependence of the hamiltonian.; args (dictionary) – Dictionary with variables required to evaluate H. Returns:output – The wavefunction for the time \(t\). Return type:qutip.qobj. floquet_state_decomposition(f_states, f_energies, psi)[source]¶; Decompose the wavefunction psi (typically an initial state) in terms of; the Floquet states, \(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\). Parameters:; f_states (list of qutip.qobj (kets)) – A list of Floquet modes.; f_energies (array) – The Floquet energies.; psi (qutip.qobj) – The wavefunction to decompose in the Floquet state basis. Returns:output – The coefficients \(c_\alpha\) in the Floquet state decomposition. Return type:array. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100)[source]¶; Solve the Schrodinger equation using the Floquet formalism. Parameters:; H (qutip.qobj.Qobj) – System Hamiltonian, time-dependent with period T.; psi0 (qutip.qobj) – Initial state vector (ket).; tlist (list / array) – list of times for \(t\).; e_ops (list of qutip.qobj / callback function) – list of oper",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:75449,Modifiability,variab,variables,75449," states, \(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\). Parameters:; f_states (list of qutip.qobj (kets)) – A list of Floquet modes.; f_energies (array) – The Floquet energies.; psi (qutip.qobj) – The wavefunction to decompose in the Floquet state basis. Returns:output – The coefficients \(c_\alpha\) in the Floquet state decomposition. Return type:array. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100)[source]¶; Solve the Schrodinger equation using the Floquet formalism. Parameters:; H (qutip.qobj.Qobj) – System Hamiltonian, time-dependent with period T.; psi0 (qutip.qobj) – Initial state vector (ket).; tlist (list / array) – list of times for \(t\).; e_ops (list of qutip.qobj / callback function) – list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values.; T (float) – The period of the time-dependence of the hamiltonian.; args (dictionary) – Dictionary with variables required to evaluate H.; Tsteps (integer) – The number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns:output – An instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Return type:qutip.solver.Result. Stochastic Schrödinger Equation and Master Equation¶; This module contains functions for solving stochastic schrodinger and master; equations. The API should not be considered stable, and is subject to change; when we work more on optimizing this module for performance and features. smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters:; H (qutip.Qobj) – System Hamiltonian.; rho0 (qutip.Qobj) – Initial density matrix or state vect",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:110635,Modifiability,config,config,110635," \(U\). Parameters:U (qobj) – Operator representing the propagator. Returns:a – Instance representing the steady-state density matrix. Return type:qobj. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters:; H (qobj) – System Hamiltonian.; c_ops (list) – list of collapse operators.; args (dict) – Arguments for time-dependent Hamiltonian and collapse operator terms.; options (Options) – Instance of ODE solver options.; name (str) – Name of generated RHS; cleanup (bool) – Whether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns:. Return type:Nothing, just clears data from internal config module. Visualization¶. Pseudoprobability Functions¶. qfunc(state, xvec, yvec, g=1.4142135623730951)[source]¶; Q-function of a given state vector or density matrix; at points xvec + i * yvec. Parameters:; state (qobj) – A state vector or density matrix.; xvec (array_like) – x-coordinates at which to calculate the Wigner function.; yvec (array_like) – y-coordinates at which to calculate the Wigner function.; g (float) – Scaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2). Returns:Q – Values representing the Q-function calculated over the specified range; [xvec,yvec]. Return type:array. spin_q_function(rho, theta, phi)[source]¶; Husimi Q-function for spins. Parameters:; state (qobj) – A state vector or density matrix for a spin-j quantum system.; theta (array_like) – theta-coordinates at which to calculate the Q function.; phi (array_like) – phi-coordinates at which to calculate the Q function. Returns:Q, THETA, PHI – Values representing the spin Q fu",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:143536,Modifiability,config,configuration,143536,"d, based on a set of; precomputed dynamical maps. Parameters:; dynmaps (list of qutip.Qobj) – List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time.; rho0 (qutip.Qobj) – Initial density matrix or state vector (ket).; times (array_like) – list of times \(t_n\) at which to compute \(\rho(t_n)\).; Must be uniformily spaced.; e_ops (list of qutip.Qobj / callback function) – single operator or list of operators for which to evaluate; expectation values.; learningtimes (array_like) – list of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\).; tensors (array_like) – optional list of precomputed tensors \(T_k\); kwargs (dictionary) – Optional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns:output – An instance of the class qutip.solver.Result. Return type:qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The C",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:144154,Modifiability,variab,variables,144154,"ve knowledge of the dynamical; maps \(E(t_k)\).; tensors (array_like) – optional list of precomputed tensors \(T_k\); kwargs (dictionary) – Optional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns:output – An instance of the class qutip.solver.Result. Return type:qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dyna",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:144725,Modifiability,variab,variables,144725,"tion in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). optimize_pulse(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:144812,Modifiability,variab,variables,144812,"tion in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). optimize_pulse(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:144892,Modifiability,variab,variables,144892,"ntly two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). optimize_pulse(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metri",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:163353,Modifiability,config,configuration,163353,"n for termination, final fidelity error, final evolution; final amplitudes, statistics etc. Return type:OptimResult. create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, gen_stats=False)[source]¶; Generate the objects of the appropriate subclasses; required for the pulse optmisation based on the parameters given; Note this method may be preferable to calling optimize_pulse; if more detailed configuration is required before running the; optmisation algorthim, or the algorithm will be run many times,; for instances when trying to finding global the optimum or; minimum time optimisation. Parameters:; drift (Qobj or list of Qobj) – the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift; ctrls (List of Qobj) – a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; initial (Qobj) – starting point for the evolution.; Typically the identity matrix; target (Qobj) – target transformation, e.g. gate or state, for the time evolution; num_tslots (integer or None) – number of timeslots.; None implies that timeslots will be given in the tau array; evo_time (float or None) – total time for the evolution; None implies that timeslots will be given in the tau array; tau (array[num_tslots] of floats or None) – durations for the timeslots",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:171798,Modifiability,variab,variables,171798,"izer. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters:; drift (Qobj or list of Qobj) – the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift; ctrls (List of Qobj) – a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; initial (Qobj) – starting point for the evolution.; Typically the identity matrix; target (Qobj) – target transformation, e.g. gate or state, for the time evolution; num_tslots (integer or None) – number of timeslots.; None implies that timeslots will be given in the tau array; evo_time (float or None) – total time for the evolution; None implies th",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:174608,Modifiability,variab,variable,174608,"imum allowed elapsed time for the optimisation algorithm; alg_params (Dictionary) – options that are specific to the algorithm see above; optim_params (Dictionary) – The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; coeff_scaling (float) – Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); num_coeffs (integer) – Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); optim_method (string) – Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used.; method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_type (string) – Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); dyn_params (dict) – Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; prop_type (string) – Propagator type i.e. the method used to calculate the; propagtors and",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:175131,Modifiability,variab,variable,175131," Note this is overridden by alg_params (if given there); num_coeffs (integer) – Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); optim_method (string) – Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used.; method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_type (string) – Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); dyn_params (dict) – Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; prop_type (string) – Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details); prop_params (dict) – Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; fid_type (string) – Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:180379,Modifiability,variab,variables,180379,"ll_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters:; H_d (Qobj or list of Qobj) – Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift; H_c (Qobj) – a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; U_0 (Qobj) – starting point for the evolution.; Typically the identity matrix; U_targ (Qobj) – target transformation, e.g. gate or state, for the time evolution; num_tslots (integer or None) – number of timeslots.; None implies that timeslots will be given in the tau array; evo_time (float or None) –",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:183178,Modifiability,variab,variable,183178,"imum allowed elapsed time for the optimisation algorithm; alg_params (Dictionary) – options that are specific to the algorithm see above; optim_params (Dictionary) – The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; coeff_scaling (float) – Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); num_coeffs (integer) – Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); optim_method (string) – Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used.; method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option (string) – determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params (dict) – Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; prop_params (dict) – Parameters for the PropagatorComputer object; The k",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:183701,Modifiability,variab,variable,183701," Note this is overridden by alg_params (if given there); num_coeffs (integer) – Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); optim_method (string) – Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used.; method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option (string) – determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params (dict) – Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; prop_params (dict) – Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; fid_params (dict) – Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; tslot_type (string) – Method for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details); tslot_params (d",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:194273,Modifiability,coupling,coupling,194273,"f the oscillator.; w_th (float) – The temperature in units of frequency (or the same units as w). Returns:n_avg – Return the number of average photons in thermal equilibrium for a; an oscillator with the given frequency and temperature. Return type:float or array. linspace_with(start, stop, num=50, elems=[])[source]¶; Return an array of numbers sampled over specified interval; with additional elements added.; Returns num spaced array with elements from elems inserted; if not already included in set.; Returned sample array is not evenly spaced if addtional elements; are added. Parameters:; start (int) – The starting value of the sequence.; stop (int) – The stoping values of the sequence.; num (int, optional) – Number of samples to generate.; elems (list/ndarray, optional) – Requested elements to include in array. Returns:samples – Original equally spaced sample array with additional; elements added. Return type:ndadrray. clebsch(j1, j2, j3, m1, m2, m3)[source]¶; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters:; j1 (float) – Total angular momentum 1.; j2 (float) – Total angular momentum 2.; j3 (float) – Total angular momentum 3.; m1 (float) – z-component of angular momentum 1.; m2 (float) – z-component of angular momentum 2.; m3 (float) – z-component of angular momentum 3. Returns:cg_coeff – Requested Clebsch-Gordan coefficient. Return type:float. convert_unit(value, orig='meV', to='GHz')[source]¶; Convert an energy from unit orig to unit to. Parameters:; value (float / array) – The energy in the old unit.; orig (string) – The name of the original unit (“J”, “eV”, “meV”, “GHz”, “mK”); to (string) – The name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”). Returns:value_new_unit – The energy in the new unit. Return type:float / array. File I/O Functions¶. file_data_read(filename, sep=None)[source]¶; Retrieves an array of data from the requested file. Parameters:; filename (str) – Name of file containing reqested da",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:196546,Modifiability,variab,variable,196546,"me (str) – Name of data file to be stored, including extension.; data (array_like) – Data to be written to file.; numtype (str {'complex, 'real'}) – Type of numerical data.; numformat (str {'decimal','exp'}) – Format for written data.; sep (str) – Single-character field seperator. Usually a tab, space, comma,; or semicolon. qload(name)[source]¶; Loads data file from file named ‘filename.qu’ in current directory. Parameters:name (str) – Name of data file to be loaded. Returns:qobject – Object retrieved from requested file. Return type:instance / array_like. qsave(data, name='qutip_data')[source]¶; Saves given data to file named ‘filename.qu’ in current directory. Parameters:; data (instance/array_like) – Input Python object to be stored.; filename (str) – Name of output data file. Parallelization¶; This function provides functions for parallel execution of loops and function; mappings, using the builtin Python module multiprocessing. parfor(func, *args, **kwargs)[source]¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Note; From QuTiP 3.1, we recommend to use qutip.parallel_map; instead of this function. Parameters:; func (function_type) – A function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function.; following keyword argument is reserved (The) – ; num_cpus (int) – Number of CPU’s to use. Default uses maximum number of CPU’s.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns:result – A list with length equal to number of input parameters; containing the output from func. R",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:196967,Modifiability,variab,variables,196967,"ame.qu’ in current directory. Parameters:name (str) – Name of data file to be loaded. Returns:qobject – Object retrieved from requested file. Return type:instance / array_like. qsave(data, name='qutip_data')[source]¶; Saves given data to file named ‘filename.qu’ in current directory. Parameters:; data (instance/array_like) – Input Python object to be stored.; filename (str) – Name of output data file. Parallelization¶; This function provides functions for parallel execution of loops and function; mappings, using the builtin Python module multiprocessing. parfor(func, *args, **kwargs)[source]¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Note; From QuTiP 3.1, we recommend to use qutip.parallel_map; instead of this function. Parameters:; func (function_type) – A function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function.; following keyword argument is reserved (The) – ; num_cpus (int) – Number of CPU’s to use. Default uses maximum number of CPU’s.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns:result – A list with length equal to number of input parameters; containing the output from func. Return type:list. parallel_map(task, values, task_args=(), task_kwargs={}, **kwargs)[source]¶; Parallel execution of a mapping of values to the function task. This; is functionally equivalent to:; result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters:; task (a Python function) – The function that is to be called for each value in task_vec.; values (array /",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:197027,Modifiability,variab,variables,197027,"ested file. Return type:instance / array_like. qsave(data, name='qutip_data')[source]¶; Saves given data to file named ‘filename.qu’ in current directory. Parameters:; data (instance/array_like) – Input Python object to be stored.; filename (str) – Name of output data file. Parallelization¶; This function provides functions for parallel execution of loops and function; mappings, using the builtin Python module multiprocessing. parfor(func, *args, **kwargs)[source]¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Note; From QuTiP 3.1, we recommend to use qutip.parallel_map; instead of this function. Parameters:; func (function_type) – A function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function.; following keyword argument is reserved (The) – ; num_cpus (int) – Number of CPU’s to use. Default uses maximum number of CPU’s.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns:result – A list with length equal to number of input parameters; containing the output from func. Return type:list. parallel_map(task, values, task_args=(), task_kwargs={}, **kwargs)[source]¶; Parallel execution of a mapping of values to the function task. This; is functionally equivalent to:; result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters:; task (a Python function) – The function that is to be called for each value in task_vec.; values (array / list) – The list or array of values for which the task function is to be; evaluated.; task_args (list / dictionary) – The optional",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:45326,Performance,concurren,concurrence,45326,"r given state. Return type:float. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters:; rho (qutip.qobj) – A density matrix.; mask (list / array) – A mask that selects which subsystems should be transposed.; method (str) – choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:rho_pr – A density matrix with the selected subsystems transposed. Return type:qutip.qobj. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:state (qobj) – Ket, bra, or density matrix for a two-qubit state. Returns:concur – Concurrence. Return type:float. References. [R2]http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters:; rho (qobj) – Density matrix of composite object; selB (int/list) – Selected components for density matrix B; base ({e,2}) – Base of logarithm.; sparse ({False,True}) – Use sparse eigensolver. Returns:ent_cond – Value of conditional entropy. Return type:float. entropy_linear(rho)[source]¶; Linear entropy of a density matrix. Parameters:rho (qobj) – sensity matrix or ket/bra vector. Returns:entropy – Linear entropy of rho. Return type:float. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, sel",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:45367,Performance,concurren,concurrence,45367,"r given state. Return type:float. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters:; rho (qutip.qobj) – A density matrix.; mask (list / array) – A mask that selects which subsystems should be transposed.; method (str) – choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:rho_pr – A density matrix with the selected subsystems transposed. Return type:qutip.qobj. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:state (qobj) – Ket, bra, or density matrix for a two-qubit state. Returns:concur – Concurrence. Return type:float. References. [R2]http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters:; rho (qobj) – Density matrix of composite object; selB (int/list) – Selected components for density matrix B; base ({e,2}) – Base of logarithm.; sparse ({False,True}) – Use sparse eigensolver. Returns:ent_cond – Value of conditional entropy. Return type:float. entropy_linear(rho)[source]¶; Linear entropy of a density matrix. Parameters:rho (qobj) – sensity matrix or ket/bra vector. Returns:entropy – Linear entropy of rho. Return type:float. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, sel",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:76075,Performance,optimiz,optimizing,76075,"e vector (ket).; tlist (list / array) – list of times for \(t\).; e_ops (list of qutip.qobj / callback function) – list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values.; T (float) – The period of the time-dependence of the hamiltonian.; args (dictionary) – Dictionary with variables required to evaluate H.; Tsteps (integer) – The number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns:output – An instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Return type:qutip.solver.Result. Stochastic Schrödinger Equation and Master Equation¶; This module contains functions for solving stochastic schrodinger and master; equations. The API should not be considered stable, and is subject to change; when we work more on optimizing this module for performance and features. smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters:; H (qutip.Qobj) – System Hamiltonian.; rho0 (qutip.Qobj) – Initial density matrix or state vector (ket).; times (list / array) – List of times for \(t\). Must be uniformly spaced.; c_ops (list of qutip.Qobj) – Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; sc_ops (list of qutip.Qobj) – List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; e_ops (list of qutip.Qobj / callback function single) – single operator or list of operators for which to evaluate; expectation values.; kwargs (diction",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:76102,Performance,perform,performance,76102,"e vector (ket).; tlist (list / array) – list of times for \(t\).; e_ops (list of qutip.qobj / callback function) – list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values.; T (float) – The period of the time-dependence of the hamiltonian.; args (dictionary) – Dictionary with variables required to evaluate H.; Tsteps (integer) – The number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns:output – An instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Return type:qutip.solver.Result. Stochastic Schrödinger Equation and Master Equation¶; This module contains functions for solving stochastic schrodinger and master; equations. The API should not be considered stable, and is subject to change; when we work more on optimizing this module for performance and features. smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters:; H (qutip.Qobj) – System Hamiltonian.; rho0 (qutip.Qobj) – Initial density matrix or state vector (ket).; times (list / array) – List of times for \(t\). Must be uniformly spaced.; c_ops (list of qutip.Qobj) – Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; sc_ops (list of qutip.Qobj) – List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; e_ops (list of qutip.Qobj / callback function single) – single operator or list of operators for which to evaluate; expectation values.; kwargs (diction",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:103206,Performance,perform,perform,103206,"s obtained.; sparse (bool, optional, default = True) – Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems.; use_rcm (bool, optional, default = False) – Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian.; use_wbm (bool, optional, default = False) – Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner.; weight (float, optional) – Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user.; x0 (ndarray, optional) – ITERATIVE ONLY. Initial guess for solution vector.; maxiter (int, optional, default=1000) – ITERATIVE ONLY. Maximum number of iterations to perform.; tol (float, optional, default=1e-12) – ITERATIVE ONLY. Tolerance used for terminating solver.; permc_spec (str, optional, default='COLAMD') – ITERATIVE ONLY. Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ and; ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified.; use_precond (bool optional, default = False) – ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the ‘iterative’ GMRES and BICG solvers.; Speeds up convergence time by orders of magnitude in many cases.; M ({sparse matrix, dense matrix, LinearOperator}, optional) – ITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner is given and use_precond = True, then one; is generated automatically.; fill_factor (float",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:113687,Performance,perform,performance,113687,".5 * g * (x + iy), default g = sqrt(2).; method (string {'clenshaw', 'iterative', 'laguerre', 'fft'}) – Select method ‘clenshaw’ ‘iterative’, ‘laguerre’, or ‘fft’, where ‘clenshaw’; and ‘iterative’ use an iterative method to evaluate the Wigner functions for density; matrices \(|m><n|\), while ‘laguerre’ uses the Laguerre polynomials; in scipy for the same task. The ‘fft’ method evaluates the Fourier; transform of the density matrix. The ‘iterative’ method is default, and; in general recommended, but the ‘laguerre’ method is more efficient for; very sparse density matrices (e.g., superpositions of Fock states in a; large Hilbert space). The ‘clenshaw’ method is the preferred method for; dealing with density matrices that have a large number of excitations; (>~50). ‘clenshaw’ is a fast and numerically stable method.; sparse (bool {False, True}) – Tells the default solver whether or not to keep the input density; matrix in sparse format. As the dimensions of the density matrix; grow, setthing this flag can result in increased performance.; parfor (bool {False, True}) – Flag for calculating the Laguerre polynomial based Wigner function; method=’laguerre’ in parallel using the parfor function. Returns:; W (array) – Values representing the Wigner function calculated over the specified; range [xvec,yvec].; yvex (array) – FFT ONLY. Returns the y-coordinate values calculated via the Fourier; transform. Notes; The ‘fft’ method accepts only an xvec input for the x-coordinate.; The y-coordinates are calculated internally. References; Ulf Leonhardt,; Measuring the Quantum State of Light, (Cambridge University Press, 1997). Graphs and Visualization¶; Functions for visualizing results of quantum dynamics simulations,; visualizations of quantum states and processes. hinton(rho, xlabels=None, ylabels=None, title=None, ax=None, cmap=None, label_top=True)[source]¶; Draws a Hinton diagram for visualizing a density matrix or superoperator. Parameters:; rho (qobj) – Input density matrix ",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:144086,Performance,optimiz,optimize,144086,"ve knowledge of the dynamical; maps \(E(t_k)\).; tensors (array_like) – optional list of precomputed tensors \(T_k\); kwargs (dictionary) – Optional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns:output – An instance of the class qutip.solver.Result. Return type:qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dyna",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:145542,Performance,optimiz,optimization,145542," CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). optimize_pulse(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:149244,Performance,optimiz,optimize,149244,"error target. Pulse optimisation will; terminate when the fidelity error falls below this value; mim_grad (float) – Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima; max_iter (integer) – Maximum number of iterations of the optimisation algorithm; max_wall_time (float) – Maximum allowed elapsed time for the optimisation algorithm; alg (string) – Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params (Dictionary) – options that are specific to the algorithm see above; optim_params (Dictionary) – The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; optim_method (string) – a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; optim_alg (string) – Deprecated. Use optim_method.; max_metric_corr (integer) – Deprecated. Use method_params instead; accuracy_factor (float) – Deprecated. Use method_params instead; dyn_type (string) – Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:149429,Performance,optimiz,optimize,149429,"ue, the optimisation terminates, assuming local minima; max_iter (integer) – Maximum number of iterations of the optimisation algorithm; max_wall_time (float) – Maximum allowed elapsed time for the optimisation algorithm; alg (string) – Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params (Dictionary) – options that are specific to the algorithm see above; optim_params (Dictionary) – The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; optim_method (string) – a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; optim_alg (string) – Deprecated. Use optim_method.; max_metric_corr (integer) – Deprecated. Use method_params instead; accuracy_factor (float) – Deprecated. Use method_params instead; dyn_type (string) – Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); dyn_params (dict) – Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; prop_typ",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:149936,Performance,optimiz,optimize,149936,"im_params (Dictionary) – The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; optim_method (string) – a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; optim_alg (string) – Deprecated. Use optim_method.; max_metric_corr (integer) – Deprecated. Use method_params instead; accuracy_factor (float) – Deprecated. Use method_params instead; dyn_type (string) – Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); dyn_params (dict) – Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; prop_type (string) – Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details); prop_params (dict) – Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; fid_type (string) ",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:158076,Performance,optimiz,optimize,158076,"error target. Pulse optimisation will; terminate when the fidelity error falls below this value; mim_grad (float) – Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima; max_iter (integer) – Maximum number of iterations of the optimisation algorithm; max_wall_time (float) – Maximum allowed elapsed time for the optimisation algorithm; alg (string) – Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params (Dictionary) – options that are specific to the algorithm see above; optim_params (Dictionary) – The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; optim_method (string) – a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; optim_alg (string) – Deprecated. Use optim_method.; max_metric_corr (integer) – Deprecated. Use method_params instead; accuracy_factor (float) – Deprecated. Use method_params instead; phase_option (string) – determines how global phase is treated in fidelity; calculations (fid_type=’UN",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:158261,Performance,optimiz,optimize,158261,"ue, the optimisation terminates, assuming local minima; max_iter (integer) – Maximum number of iterations of the optimisation algorithm; max_wall_time (float) – Maximum allowed elapsed time for the optimisation algorithm; alg (string) – Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params (Dictionary) – options that are specific to the algorithm see above; optim_params (Dictionary) – The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; optim_method (string) – a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; optim_alg (string) – Deprecated. Use optim_method.; max_metric_corr (integer) – Deprecated. Use method_params instead; accuracy_factor (float) – Deprecated. Use method_params instead; phase_option (string) – determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params (dict) – Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:158768,Performance,optimiz,optimize,158768,"im_params (Dictionary) – The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; optim_method (string) – a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; optim_alg (string) – Deprecated. Use optim_method.; max_metric_corr (integer) – Deprecated. Use method_params instead; accuracy_factor (float) – Deprecated. Use method_params instead; phase_option (string) – determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params (dict) – Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; prop_params (dict) – Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; fid_params (dict) – Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; tslot_type (string) – Method for computing the dynamics generators, propagators and; evolution in the ti",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:165835,Performance,optimiz,optimize,165835,"error target. Pulse optimisation will; terminate when the fidelity error falls below this value; mim_grad (float) – Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima; max_iter (integer) – Maximum number of iterations of the optimisation algorithm; max_wall_time (float) – Maximum allowed elapsed time for the optimisation algorithm; alg (string) – Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params (Dictionary) – options that are specific to the algorithm see above; optim_params (Dictionary) – The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; optim_method (string) – a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; optim_alg (string) – Deprecated. Use optim_method.; max_metric_corr (integer) – Deprecated. Use method_params instead; accuracy_factor (float) – Deprecated. Use method_params instead; dyn_type (string) – Dynamics type, i.e. the type of matrix used to describe; the dynamics. Opti",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:166020,Performance,optimiz,optimize,166020,"ue, the optimisation terminates, assuming local minima; max_iter (integer) – Maximum number of iterations of the optimisation algorithm; max_wall_time (float) – Maximum allowed elapsed time for the optimisation algorithm; alg (string) – Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params (Dictionary) – options that are specific to the algorithm see above; optim_params (Dictionary) – The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; optim_method (string) – a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; optim_alg (string) – Deprecated. Use optim_method.; max_metric_corr (integer) – Deprecated. Use method_params instead; accuracy_factor (float) – Deprecated. Use method_params instead; dyn_type (string) – Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); dyn_params (dict) – Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; p",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:166534,Performance,optimiz,optimize,166534,"ms (Dictionary) – The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; optim_method (string) – a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; optim_alg (string) – Deprecated. Use optim_method.; max_metric_corr (integer) – Deprecated. Use method_params instead; accuracy_factor (float) – Deprecated. Use method_params instead; dyn_type (string) – Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); dyn_params (dict) – Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; prop_type (string) – Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details); prop_params (dict) – Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; fid_type (string) ",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:170661,Performance,optimiz,optimizer,170661,"lse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; log_level (integer) – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; gen_stats (boolean) – if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt – Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. Return type:Optimizer. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; T",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:170734,Performance,optimiz,optimizer,170734,"ssumed to be attribute name value pairs; They applied after the object is created; log_level (integer) – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; gen_stats (boolean) – if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt – Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. Return type:Optimizer. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, len(ctrls)] arra",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:174412,Performance,perform,performane,174412,"sation will; terminate when the fidelity error falls below this value; max_iter (integer) – Maximum number of iterations of the optimisation algorithm; max_wall_time (float) – Maximum allowed elapsed time for the optimisation algorithm; alg_params (Dictionary) – options that are specific to the algorithm see above; optim_params (Dictionary) – The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; coeff_scaling (float) – Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); num_coeffs (integer) – Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); optim_method (string) – Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used.; method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_type (string) – Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); dyn_params (dict) – Parameters for the Dynamics object; The key value pairs",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:174748,Performance,optimiz,optimize,174748,"lgorithm see above; optim_params (Dictionary) – The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; coeff_scaling (float) – Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); num_coeffs (integer) – Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); optim_method (string) – Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used.; method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_type (string) – Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); dyn_params (dict) – Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; prop_type (string) – Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for th",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:175054,Performance,optimiz,optimize,175054,"ng (float) – Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); num_coeffs (integer) – Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); optim_method (string) – Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used.; method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_type (string) – Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); dyn_params (dict) – Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; prop_type (string) – Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details); prop_params (dict) – Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; fid_type (string) – Fidelity error (and fidelity error gradient)",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:182982,Performance,perform,performane,182982,"sation will; terminate when the fidelity error falls below this value; max_iter (integer) – Maximum number of iterations of the optimisation algorithm; max_wall_time (float) – Maximum allowed elapsed time for the optimisation algorithm; alg_params (Dictionary) – options that are specific to the algorithm see above; optim_params (Dictionary) – The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; coeff_scaling (float) – Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); num_coeffs (integer) – Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); optim_method (string) – Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used.; method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option (string) – determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params (dict) – Parameters for the Dynamics object; T",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:183318,Performance,optimiz,optimize,183318,"lgorithm see above; optim_params (Dictionary) – The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; coeff_scaling (float) – Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); num_coeffs (integer) – Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); optim_method (string) – Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used.; method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option (string) – determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params (dict) – Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; prop_params (dict) – Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; fid_params (dict",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:183624,Performance,optimiz,optimize,183624,"ng (float) – Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); num_coeffs (integer) – Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); optim_method (string) – Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used.; method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option (string) – determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params (dict) – Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; prop_params (dict) – Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; fid_params (dict) – Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; tslot_type (string) – Method for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; U",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:192391,Performance,perform,performing,192391,"n, Implementation, and; Analysis of Maximum Transversal Algorithms”, ACM Trans. Math. Softw.; 38, no. 2, (2011). weighted_bipartite_matching(A, perm_type='row')[source]¶; Returns an array of row permutations that attempts to maximize; the product of the ABS values of the diagonal elements in; a nonsingular square CSC sparse matrix. Such a permutation is; always possible provided that the matrix is nonsingular.; This function looks at both the structure and ABS values of the; underlying matrix. Parameters:; A (csc_matrix) – Input matrix; perm_type (str {'row', 'column'}) – Type of permutation to generate. Returns:perm – Array of row or column permutations. Return type:array. Notes; This function uses a weighted maximum cardinality bipartite matching; algorithm based on breadth-first search (BFS). The columns are weighted; according to the element of max ABS value in the associated rows and; are traversed in descending order by weight. When performing the BFS; traversal, the row associated to a given column is the one with maximum; weight. Unlike other techniques[1]_, this algorithm does not guarantee the; product of the diagonal is maximized. However, this limitation is offset; by the substantially faster runtime of this method. References; I. S. Duff and J. Koster, “The design and use of algorithms for; permuting large entries to the diagonal of sparse matrices”, SIAM J.; Matrix Anal. and Applics. 20, no. 4, 889 (1997). Utility Functions¶; This module contains utility functions that are commonly needed in other; qutip modules. n_thermal(w, w_th)[source]¶; Return the number of photons in thermal equilibrium for an harmonic; oscillator mode with frequency ‘w’, at the temperature described by; ‘w_th’ where \(\omega_{\rm th} = k_BT/\hbar\). Parameters:; w (float or array) – Frequency of the oscillator.; w_th (float) – The temperature in units of frequency (or the same units as w). Returns:n_avg – Return the number of average photons in thermal equilibrium for a; an osci",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:196006,Performance,load,loaded,196006,"). Returns:value_new_unit – The energy in the new unit. Return type:float / array. File I/O Functions¶. file_data_read(filename, sep=None)[source]¶; Retrieves an array of data from the requested file. Parameters:; filename (str) – Name of file containing reqested data.; sep (str) – Seperator used to store data. Returns:data – Data from selected file. Return type:array_like. file_data_store(filename, data, numtype='complex', numformat='decimal', sep=', ')[source]¶; Stores a matrix of data to a file to be read by an external program. Parameters:; filename (str) – Name of data file to be stored, including extension.; data (array_like) – Data to be written to file.; numtype (str {'complex, 'real'}) – Type of numerical data.; numformat (str {'decimal','exp'}) – Format for written data.; sep (str) – Single-character field seperator. Usually a tab, space, comma,; or semicolon. qload(name)[source]¶; Loads data file from file named ‘filename.qu’ in current directory. Parameters:name (str) – Name of data file to be loaded. Returns:qobject – Object retrieved from requested file. Return type:instance / array_like. qsave(data, name='qutip_data')[source]¶; Saves given data to file named ‘filename.qu’ in current directory. Parameters:; data (instance/array_like) – Input Python object to be stored.; filename (str) – Name of output data file. Parallelization¶; This function provides functions for parallel execution of loops and function; mappings, using the builtin Python module multiprocessing. parfor(func, *args, **kwargs)[source]¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Note; From QuTiP 3.1, we recommend to use qutip.parallel_map; instead of this function. Parameters:; func (function_type) – A function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In gene",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:199866,Performance,load,load-balanced,199866,"ue in task_vec.; values (array / list) – The list or array of values for which the task function is to be; evaluated.; task_args (list / dictionary) – The optional additional argument to the task function.; task_kwargs (list / dictionary) – The optional additional keyword argument to the task function.; progress_bar (ProgressBar) – Progress bar class instance for showing progress. Returns:result – The result list contains the value of; task(value, *task_args, **task_kwargs) for each; value in values. Return type:list. IPython Notebook Tools¶; This module contains utility functions for using QuTiP with IPython notebooks. parfor(task, task_vec, args=None, client=None, view=None, show_scheduling=False, show_progressbar=False)[source]¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:; task (a Python function) – The function that is to be called for each value in task_vec.; task_vec (array / list) – The list or array of values for which the task function is to be; evaluated.; args (list / dictionary) – The optional additional argument to the task function. For example; a dictionary with parameter values.; client (IPython.parallel.Client) – The IPython.parallel Client instance that will be used in the; parfor execution.; view (a IPython.parallel.Client view) – The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view().; show_scheduling (bool {False, True}, default False) – Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engin",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:200565,Performance,load,load-balanced,200565,"g=False, show_progressbar=False)[source]¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:; task (a Python function) – The function that is to be called for each value in task_vec.; task_vec (array / list) – The list or array of values for which the task function is to be; evaluated.; args (list / dictionary) – The optional additional argument to the task function. For example; a dictionary with parameter values.; client (IPython.parallel.Client) – The IPython.parallel Client instance that will be used in the; parfor execution.; view (a IPython.parallel.Client view) – The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view().; show_scheduling (bool {False, True}, default False) – Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster.; show_progressbar (bool {False, True}, default False) – Display a HTML-based progress bar duing the execution of the parfor; loop. Returns:result – The result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. Return type:list. parallel_map(task, values, task_args=None, task_kwargs=None, client=None, view=None, progress_bar=None, show_scheduling=False, **kwargs)[source]¶; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(value, *args, **kwargs).; The client and view are the IPython.parallel client and; ",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:201586,Performance,load,load-balanced,201586,"m the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view().; show_scheduling (bool {False, True}, default False) – Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster.; show_progressbar (bool {False, True}, default False) – Display a HTML-based progress bar duing the execution of the parfor; loop. Returns:result – The result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. Return type:list. parallel_map(task, values, task_args=None, task_kwargs=None, client=None, view=None, progress_bar=None, show_scheduling=False, **kwargs)[source]¶; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(value, *args, **kwargs).; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:; task (a Python function) – The function that is to be called for each value in task_vec.; values (array / list) – The list or array of values for which the task function is to be; evaluated.; task_args (list / dictionary) – The optional additional argument to the task function.; task_kwargs (list / dictionary) – The optional additional keyword argument to the task function.; client (IPython.parallel.Client) – The IPython.parallel Client instance that will be used in the; parfor execution.; view (a IPython.parallel.Client view) – The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view().; show_scheduling (bool {False, True}, default False) – Display a graph showing how the tasks (the evaluation of task for; for the va",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:202337,Performance,load,load-balanced,202337,"source]¶; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(value, *args, **kwargs).; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:; task (a Python function) – The function that is to be called for each value in task_vec.; values (array / list) – The list or array of values for which the task function is to be; evaluated.; task_args (list / dictionary) – The optional additional argument to the task function.; task_kwargs (list / dictionary) – The optional additional keyword argument to the task function.; client (IPython.parallel.Client) – The IPython.parallel Client instance that will be used in the; parfor execution.; view (a IPython.parallel.Client view) – The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view().; show_scheduling (bool {False, True}, default False) – Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster.; show_progressbar (bool {False, True}, default False) – Display a HTML-based progress bar during the execution of the parfor; loop. Returns:result – The result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. Return type:list. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns:version_table – Return an HTML-formatted string containing version information for; QuTi",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:38051,Safety,avoid,avoids,38051,"ree> -------; |one> |two>. References; The naming of qutip operators follows the convention in [R1] . [R1]Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()[source]¶; Basis states for a three level atom. Returns:states – array of three level atom basis vectors. Return type:array. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns:ops – array of three level operators. Return type:array. Superoperators and Liouvillians¶. operator_to_vector(op)[source]¶; Create a vector representation of a quantum operator given; the matrix representation. vector_to_operator(op)[source]¶; Create a matrix representation given a quantum operator in; vector form. liouvillian(H, c_ops=[], data_only=False, chi=None)[source]¶; Assembles the Liouvillian superoperator from a Hamiltonian; and a list of collapse operators. Like liouvillian, but with an; experimental implementation which avoids creating extra Qobj instances,; which can be advantageous for large systems. Parameters:; H (qobj) – System Hamiltonian.; c_ops (array_like) – A list or array of collapse operators. Returns:L – Liouvillian superoperator. Return type:qobj. spost(A)[source]¶; Superoperator formed from post-multiplication by operator A. Parameters:A (qobj) – Quantum operator for post multiplication. Returns:super – Superoperator formed from input qauntum object. Return type:qobj. spre(A)[source]¶; Superoperator formed from pre-multiplication by operator A. Parameters:A (qobj) – Quantum operator for pre-multiplication. Returns:super – Superoperator formed from input quantum object. Return type:qobj. sprepost(A, B)[source]¶; Superoperator formed from pre-multiplication by operator A and post-; multiplication of operator B. Parameters:; A (Qobj) – Quantum operator for pre-multiplication.; B (Qobj) – Quantum operator for post-multiplication. Returns:super – Superoperator formed from input quantum objects. Retur",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:124123,Security,access,access,124123," The figure canvas on which the plot will be drawn.; ax (a matplotlib axis instance) – The axis context in which the plot will be drawn.; figsize ((width, height)) – The size of the matplotlib figure (in inches) if it is to be created; (that is, if no ‘fig’ and ‘ax’ arguments are passed). Returns:fig, ax – A tuple of the matplotlib figure and axes instances used to produce; the figure. Return type:tuple. plot_qubism(ket, theme='light', how='pairs', grid_iteration=1, legend_iteration=0, fig=None, ax=None, figsize=(6, 6))[source]¶; Qubism plot for pure states of many qudits.; Works best for spin chains, especially with even number of particles; of the same dimension.; Allows to see entanglement between first 2*k particles and the rest.; More information:. J. Rodriguez-Laguna, P. Migdal,; M. Ibanez Berganza, M. Lewenstein, G. Sierra,; “Qubism: self-similar visualization of many-body wavefunctions”,; New J. Phys. 14 053028 (2012), arXiv:1112.3560,; http://dx.doi.org/10.1088/1367-2630/14/5/053028 (open access). Parameters:; ket (Qobj) – Pure state for plotting.; theme ('light' (default) or 'dark') – Set coloring theme for mapping complex values into colors.; See: complex_array_to_rgb.; how ('pairs' (default), 'pairs_skewed' or 'before_after') – Type of Qubism plotting.; Options:. ‘pairs’ - typical coordinates,; ‘pairs_skewed’ - for ferromagnetic/antriferromagnetic plots,; ‘before_after’ - related to Schmidt plot (see also: plot_schmidt). grid_iteration (int (default 1)) – Helper lines to be drawn on plot.; Show tiles for 2*grid_iteration particles vs all others.; legend_iteration (int (default 0) or 'grid_iteration' or 'all') – Show labels for first 2*legend_iteration particles.; Option ‘grid_iteration’ sets the same number of particles. as for grid_iteration.; Option ‘all’ makes label for all particles.; Typically it should be 0, 1, 2 or perhaps 3. fig (a matplotlib figure instance) – The figure canvas on which the plot will be drawn.; ax (a matplotlib axis instance) – T",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:144004,Security,access,accessible,144004,"ors for which to evaluate; expectation values.; learningtimes (array_like) – list of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\).; tensors (array_like) – optional list of precomputed tensors \(T_k\); kwargs (dictionary) – Optional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns:output – An instance of the class qutip.solver.Result. Return type:qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelde",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:153973,Security,access,accessible,153973,"d in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ramping_pulse_params (dict) – Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; log_level (integer) – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; out_file_ext (string or None) – files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files; gen_stats (boolean) – if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt – Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. Return type:OptimResult. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶;",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:162168,Security,access,accessible,162168,"d in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ramping_pulse_params (dict) – Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; log_level (integer) – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; out_file_ext (string or None) – files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files; gen_stats (boolean) – if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt – Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. Return type:OptimResult. create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:170325,Security,access,accessible,170325,"r offset for the pulse. That is this value will be added; to any initial / guess pulses generated.; ramping_pulse_type (string) – Type of pulse used to modulate the control pulse.; It’s intended use for a ramping modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ramping_pulse_params (dict) – Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; log_level (integer) – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; gen_stats (boolean) – if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt – Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. Return type:Optimizer. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, g",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:170506,Security,access,accessed,170506,"ing modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ramping_pulse_params (dict) – Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; log_level (integer) – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; gen_stats (boolean) – if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt – Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. Return type:Optimizer. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[sour",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:170609,Security,access,accessed,170609,"is purpose.; ramping_pulse_params (dict) – Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; log_level (integer) – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; gen_stats (boolean) – if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt – Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. Return type:Optimizer. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combine",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:178887,Security,access,accessible,178887,"d in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ramping_pulse_params (dict) – Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; log_level (integer) – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; out_file_ext (string or None) – files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files; gen_stats (boolean) – if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt – Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. Return type:OptimResult. opt_pulse_crab_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:186973,Security,access,accessible,186973,"d in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ramping_pulse_params (dict) – Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; log_level (integer) – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; out_file_ext (string or None) – files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files; gen_stats (boolean) – if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt – Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. Return type:OptimResult. Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details. create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None)[source]¶; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summat",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:45950,Testability,log,logarithm,45950," tranposed. Parameters:; rho (qutip.qobj) – A density matrix.; mask (list / array) – A mask that selects which subsystems should be transposed.; method (str) – choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:rho_pr – A density matrix with the selected subsystems transposed. Return type:qutip.qobj. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:state (qobj) – Ket, bra, or density matrix for a two-qubit state. Returns:concur – Concurrence. Return type:float. References. [R2]http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters:; rho (qobj) – Density matrix of composite object; selB (int/list) – Selected components for density matrix B; base ({e,2}) – Base of logarithm.; sparse ({False,True}) – Use sparse eigensolver. Returns:ent_cond – Value of conditional entropy. Return type:float. entropy_linear(rho)[source]¶; Linear entropy of a density matrix. Parameters:rho (qobj) – sensity matrix or ket/bra vector. Returns:entropy – Linear entropy of rho. Return type:float. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters:; rho (qobj) – Density matrix for composite quantum systems; selA (int/list) – int or list of first selected density matrix components.; selB (int/list) – int or list of second selected density matrix components.; base ({e,2}) – Base of logarithm.; sparse ({False,True}) – Use sparse eigensolver. Returns:ent_mut – Mutual information between selec",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:46772,Testability,log,logarithm,46772," of a selected density matrix component. Parameters:; rho (qobj) – Density matrix of composite object; selB (int/list) – Selected components for density matrix B; base ({e,2}) – Base of logarithm.; sparse ({False,True}) – Use sparse eigensolver. Returns:ent_cond – Value of conditional entropy. Return type:float. entropy_linear(rho)[source]¶; Linear entropy of a density matrix. Parameters:rho (qobj) – sensity matrix or ket/bra vector. Returns:entropy – Linear entropy of rho. Return type:float. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters:; rho (qobj) – Density matrix for composite quantum systems; selA (int/list) – int or list of first selected density matrix components.; selB (int/list) – int or list of second selected density matrix components.; base ({e,2}) – Base of logarithm.; sparse ({False,True}) – Use sparse eigensolver. Returns:ent_mut – Mutual information between selected components. Return type:float. entropy_vn(rho, base=2.718281828459045, sparse=False)[source]¶; Von-Neumann entropy of density matrix. Parameters:; rho (qobj) – Density matrix.; base ({e,2}) – Base of logarithm.; sparse ({False,True}) – Use sparse eigensolver. Returns:entropy – Von-Neumann entropy of rho. Return type:float. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. Density Matrix Metrics¶; This module contains a collection of functions for calculating metrics; (distance measures) between states and operators. fidelity(A, B)[source]¶; Calculates the fidelity (pseudo-metric) between two density matrices.; See: Nielsen & Chuang, “Quantum Computation and Quantum Information”. Parameters:; A (qobj) – Density matrix or state vector.; B (qobj) – Density matrix or state vector with same dimensions as A. Returns:fid – Fidelity pseudo-metr",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:47086,Testability,log,logarithm,47086,"entropy_linear(rho)[source]¶; Linear entropy of a density matrix. Parameters:rho (qobj) – sensity matrix or ket/bra vector. Returns:entropy – Linear entropy of rho. Return type:float. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters:; rho (qobj) – Density matrix for composite quantum systems; selA (int/list) – int or list of first selected density matrix components.; selB (int/list) – int or list of second selected density matrix components.; base ({e,2}) – Base of logarithm.; sparse ({False,True}) – Use sparse eigensolver. Returns:ent_mut – Mutual information between selected components. Return type:float. entropy_vn(rho, base=2.718281828459045, sparse=False)[source]¶; Von-Neumann entropy of density matrix. Parameters:; rho (qobj) – Density matrix.; base ({e,2}) – Base of logarithm.; sparse ({False,True}) – Use sparse eigensolver. Returns:entropy – Von-Neumann entropy of rho. Return type:float. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. Density Matrix Metrics¶; This module contains a collection of functions for calculating metrics; (distance measures) between states and operators. fidelity(A, B)[source]¶; Calculates the fidelity (pseudo-metric) between two density matrices.; See: Nielsen & Chuang, “Quantum Computation and Quantum Information”. Parameters:; A (qobj) – Density matrix or state vector.; B (qobj) – Density matrix or state vector with same dimensions as A. Returns:fid – Fidelity pseudo-metric between A and B. Return type:float. Examples; >>> x = fock_dm(5,3); >>> y = coherent_dm(5,1); >>> fidelity(x,y); 0.24104350624628332. tracedist(A, B, sparse=False, tol=0)[source]¶; Calculates the trace distance between two density matrices..; See: Nielsen & Chuang, “Quantum Computation and Quantum Information”",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:53916,Testability,log,logarithmic,53916,"n type:ndarray. wigner_covariance_matrix(a1=None, a2=None, R=None, rho=None)[source]¶; Calculates the Wigner covariance matrix; \(V_{ij} = \frac{1}{2}(R_{ij} + R_{ji})\), given; the quadrature correlation matrix; \(R_{ij} = \langle R_{i} R_{j}\rangle -; \langle R_{i}\rangle \langle R_{j}\rangle\), where; \(R = (q_1, p_1, q_2, p_2)^T\) is the vector with quadrature operators; for the two modes.; Alternatively, if R = None, and if annihilation operators a1 and a2; for the two modes are supplied instead, the quadrature correlation matrix; is constructed from the annihilation operators before then the covariance; matrix is calculated. Parameters:; a1 (Qobj) – Field operator for mode 1.; a2 (Qobj) – Field operator for mode 2.; R (ndarray) – The quadrature correlation matrix.; rho (Qobj) – Density matrix for which to calculate the covariance matrix. Returns:cov_mat – A 2-dimensional array of covariance values. Return type:ndarray. logarithmic_negativity(V)[source]¶; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see qutip.continous_variables.covariance_matrix. Note that; the two-mode field state that is described by V must be Gaussian for this; function to applicable. Parameters:V (2d array) – The covariance matrix. Returns:N – The logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. Return type:float. Dynamics and Time-Evolution¶. Schrödinger Equation¶; This module provides solvers for the unitary Schrodinger equation. sesolve(H, rho0, tlist, e_ops=[], args={}, options=None, progress_bar=<qutip.ui.progressbar.BaseProgressBar object>, _safe_mode=True)[source]¶; Schrodinger equation evolution of a state vector for a given Hamiltonian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian (H), by integrating the set of ordinary differential; equations that define the system.; The output is either the state vector at arbitrary points in time; (tlist), or the expec",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:54203,Testability,log,logarithmic,54203,"_2, p_2)^T\) is the vector with quadrature operators; for the two modes.; Alternatively, if R = None, and if annihilation operators a1 and a2; for the two modes are supplied instead, the quadrature correlation matrix; is constructed from the annihilation operators before then the covariance; matrix is calculated. Parameters:; a1 (Qobj) – Field operator for mode 1.; a2 (Qobj) – Field operator for mode 2.; R (ndarray) – The quadrature correlation matrix.; rho (Qobj) – Density matrix for which to calculate the covariance matrix. Returns:cov_mat – A 2-dimensional array of covariance values. Return type:ndarray. logarithmic_negativity(V)[source]¶; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see qutip.continous_variables.covariance_matrix. Note that; the two-mode field state that is described by V must be Gaussian for this; function to applicable. Parameters:V (2d array) – The covariance matrix. Returns:N – The logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. Return type:float. Dynamics and Time-Evolution¶. Schrödinger Equation¶; This module provides solvers for the unitary Schrodinger equation. sesolve(H, rho0, tlist, e_ops=[], args={}, options=None, progress_bar=<qutip.ui.progressbar.BaseProgressBar object>, _safe_mode=True)[source]¶; Schrodinger equation evolution of a state vector for a given Hamiltonian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian (H), by integrating the set of ordinary differential; equations that define the system.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. Parameters:; H (qutip.qobj) – system Hamiltonian, or a callback function for time-dependent; Hamiltonians.; rho0 (q",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:153254,Testability,log,logger,153254,"RND; (see PulseGen classes for details); For the CRAB the this the guess_pulse_type. init_pulse_params (dict) – Parameters for the initial / guess pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; pulse_scaling (float) – Linear scale factor for generated initial / guess pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter; pulse_offset (float) – Linear offset for the pulse. That is this value will be added; to any initial / guess pulses generated.; ramping_pulse_type (string) – Type of pulse used to modulate the control pulse.; It’s intended use for a ramping modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ramping_pulse_params (dict) – Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; log_level (integer) – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; out_file_ext (string or None) – files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files; gen_stats (boolean) – if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt – Returns instance of OptimResult, which has attributes giving the; reason for termination, final",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:161449,Testability,log,logger,161449,"RND; (see PulseGen classes for details); For the CRAB the this the guess_pulse_type. init_pulse_params (dict) – Parameters for the initial / guess pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; pulse_scaling (float) – Linear scale factor for generated initial / guess pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter; pulse_offset (float) – Linear offset for the pulse. That is this value will be added; to any initial / guess pulses generated.; ramping_pulse_type (string) – Type of pulse used to modulate the control pulse.; It’s intended use for a ramping modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ramping_pulse_params (dict) – Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; log_level (integer) – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; out_file_ext (string or None) – files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files; gen_stats (boolean) – if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt – Returns instance of OptimResult, which has attributes giving the; reason for termination, final",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:169852,Testability,log,logger,169852,"RND; (see PulseGen classes for details); For the CRAB the this the guess_pulse_type. init_pulse_params (dict) – Parameters for the initial / guess pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; pulse_scaling (float) – Linear scale factor for generated initial / guess pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter; pulse_offset (float) – Linear offset for the pulse. That is this value will be added; to any initial / guess pulses generated.; ramping_pulse_type (string) – Type of pulse used to modulate the control pulse.; It’s intended use for a ramping modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ramping_pulse_params (dict) – Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; log_level (integer) – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; gen_stats (boolean) – if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt – Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through th",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:174647,Testability,test,tested,174647,"imum allowed elapsed time for the optimisation algorithm; alg_params (Dictionary) – options that are specific to the algorithm see above; optim_params (Dictionary) – The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; coeff_scaling (float) – Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); num_coeffs (integer) – Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); optim_method (string) – Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used.; method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_type (string) – Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); dyn_params (dict) – Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; prop_type (string) – Propagator type i.e. the method used to calculate the; propagtors and",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:178168,Testability,log,logger,178168,"se generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; guess_pulse_action (string) – Determines how the guess pulse is applied to the pulse generated; by the basis expansion.; Options are: MODULATE, ADD; Default is MODULATE; pulse_scaling (float) – Linear scale factor for generated guess pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter; pulse_offset (float) – Linear offset for the pulse. That is this value will be added; to any guess pulses generated.; ramping_pulse_type (string) – Type of pulse used to modulate the control pulse.; It’s intended use for a ramping modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ramping_pulse_params (dict) – Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; log_level (integer) – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; out_file_ext (string or None) – files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files; gen_stats (boolean) – if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt – Returns instance of OptimResult, which has attributes giving the; reason for termination, final",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:183217,Testability,test,tested,183217,"imum allowed elapsed time for the optimisation algorithm; alg_params (Dictionary) – options that are specific to the algorithm see above; optim_params (Dictionary) – The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; coeff_scaling (float) – Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); num_coeffs (integer) – Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); optim_method (string) – Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used.; method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option (string) – determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params (dict) – Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; prop_params (dict) – Parameters for the PropagatorComputer object; The k",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:186254,Testability,log,logger,186254,"se generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; guess_pulse_action (string) – Determines how the guess pulse is applied to the pulse generated; by the basis expansion.; Options are: MODULATE, ADD; Default is MODULATE; pulse_scaling (float) – Linear scale factor for generated guess pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter; pulse_offset (float) – Linear offset for the pulse. That is this value will be added; to any guess pulses generated.; ramping_pulse_type (string) – Type of pulse used to modulate the control pulse.; It’s intended use for a ramping modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ramping_pulse_params (dict) – Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; log_level (integer) – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; out_file_ext (string or None) – files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files; gen_stats (boolean) – if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt – Returns instance of OptimResult, which has attributes giving the; reason for termination, final",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:63334,Usability,progress bar,progress bar,63334,"s['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters:; H (qutip.Qobj) – System Hamiltonian.; psi0 (qutip.Qobj) – Initial state vector; tlist (array_like) – Times at which results are recorded.; ntraj (int) – Number of trajectories to run.; c_ops (array_like) – single collapse operator or list or array of collapse; operators.; e_ops (array_like) – single operator or list or array of operators for calculating; expectation values.; args (dict) – Arguments for time-dependent Hamiltonian and collapse operator terms.; options (Options) – Instance of ODE solver options.; progress_bar (BaseProgressBar) – Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Set to None to disable the; progress bar.; map_func (function) – A map function for managing the calls to the single-trajactory solver.; map_kwargs (dictionary) – Optional keyword arguments to the map_func function. Returns:; results (qutip.solver.Result) – Object storing all results from the simulation.; .. note:: – It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds). Exponential Series¶. essolve(H, rho0, tlist, c_op_list, e_ops)[source]¶; Evolution of a state vector or density matrix (rho0) for a given; Hamiltonian (H) and set of collapse operators (c_op_list), by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (tlist), or the; expectation values of the supplied operators (e_ops). Parameters:; H (qobj/function_type) – System Hamiltonian.; rho0 (qutip.qobj) – Initial state density matrix.; tlist (list/arra",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:109360,Usability,progress bar,progress bar,109360,"f the; density matrix. Parameters:; H (qobj or list) – Hamiltonian as a Qobj instance of a nested list of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in qutip.mesolve).; t (float or array-like) – Time or list of times for which to evaluate the propagator.; c_op_list (list) – List of qobj collapse operators.; args (list/array/dictionary) – Parameters to callback functions for time-dependent Hamiltonians and; collapse operators.; options (qutip.Options) – with options for the ODE solver.; = str ('batch', 'single') (unitary_mode) – Solve all basis vectors simulaneously (‘batch’) or individually; (‘single’).; parallel (bool {False, True}) – Run the propagator in parallel mode. This will override the; unitary_mode settings if set to True.; progress_bar (BaseProgressBar) – Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns:a – Instance representing the propagator \(U(t)\). Return type:qobj. propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters:U (qobj) – Operator representing the propagator. Returns:a – Instance representing the steady-state density matrix. Return type:qobj. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters:; H (qobj) – System Hamiltonian.; c_ops (list) – list of collapse operators.; args (dict) – Arguments for time-dependent Hamiltonian and collapse operator terms.; options (Options) – Instance of ODE solver options.; name (str) – Name of generated RHS; cleanup (bool) – Whether the generated cython file should be automatically removed or; not. Not",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:110609,Usability,clear,clears,110609," \(U\). Parameters:U (qobj) – Operator representing the propagator. Returns:a – Instance representing the steady-state density matrix. Return type:qobj. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters:; H (qobj) – System Hamiltonian.; c_ops (list) – list of collapse operators.; args (dict) – Arguments for time-dependent Hamiltonian and collapse operator terms.; options (Options) – Instance of ODE solver options.; name (str) – Name of generated RHS; cleanup (bool) – Whether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns:. Return type:Nothing, just clears data from internal config module. Visualization¶. Pseudoprobability Functions¶. qfunc(state, xvec, yvec, g=1.4142135623730951)[source]¶; Q-function of a given state vector or density matrix; at points xvec + i * yvec. Parameters:; state (qobj) – A state vector or density matrix.; xvec (array_like) – x-coordinates at which to calculate the Wigner function.; yvec (array_like) – y-coordinates at which to calculate the Wigner function.; g (float) – Scaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2). Returns:Q – Values representing the Q-function calculated over the specified range; [xvec,yvec]. Return type:array. spin_q_function(rho, theta, phi)[source]¶; Husimi Q-function for spins. Parameters:; state (qobj) – A state vector or density matrix for a spin-j quantum system.; theta (array_like) – theta-coordinates at which to calculate the Q function.; phi (array_like) – phi-coordinates at which to calculate the Q function. Returns:Q, THETA, PHI – Values representing the spin Q fu",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:142439,Usability,learn,learningtimes,142439,"e individual; steps as unitary matrices operating from left to right. Parameters:; N (int) – Number of qubits.; swap (boolean) – Flag indicating sequence of swap gates to be applied at the end or not. Returns:U_step_list – List of Hadamard and controlled rotation gates implementing QFT. Return type:list of qobj. qft_gate_sequence(N=1, swapping=True)[source]¶; Quantum Fourier Transform operator on N qubits returning the gate sequence. Parameters:; N (int) – Number of qubits.; swap (boolean) – Flag indicating sequence of swap gates to be applied at the end or not. Returns:qc – Gate sequence of Hadamard and controlled rotation gates implementing; QFT. Return type:instance of QubitCircuit. non-Markovian Solvers¶; This module contains an implementation of the non-Markovian transfer tensor; method (TTM), introduced in [1].; [1] Javier Cerrillo and Jianshu Cao, Phys. Rev. Lett 112, 110401 (2014). ttmsolve(dynmaps, rho0, times, e_ops=[], learningtimes=None, tensors=None, **kwargs)[source]¶; Solve time-evolution using the Transfer Tensor Method, based on a set of; precomputed dynamical maps. Parameters:; dynmaps (list of qutip.Qobj) – List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time.; rho0 (qutip.Qobj) – Initial density matrix or state vector (ket).; times (array_like) – list of times \(t_n\) at which to compute \(\rho(t_n)\).; Must be uniformily spaced.; e_ops (list of qutip.Qobj / callback function) – single operator or list of operators for which to evaluate; expectation values.; learningtimes (array_like) – list of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\).; tensors (array_like) – optional list of precomputed tensors \(T_k\); kwargs (dictionary) – Optional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns:output – An instance of the class qutip.solver.Result. Return type:qutip.solver.Result. Optimal control¶; Wrapper functions that will manage ",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:143070,Usability,learn,learningtimes,143070,"n gates implementing; QFT. Return type:instance of QubitCircuit. non-Markovian Solvers¶; This module contains an implementation of the non-Markovian transfer tensor; method (TTM), introduced in [1].; [1] Javier Cerrillo and Jianshu Cao, Phys. Rev. Lett 112, 110401 (2014). ttmsolve(dynmaps, rho0, times, e_ops=[], learningtimes=None, tensors=None, **kwargs)[source]¶; Solve time-evolution using the Transfer Tensor Method, based on a set of; precomputed dynamical maps. Parameters:; dynmaps (list of qutip.Qobj) – List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time.; rho0 (qutip.Qobj) – Initial density matrix or state vector (ket).; times (array_like) – list of times \(t_n\) at which to compute \(\rho(t_n)\).; Must be uniformily spaced.; e_ops (list of qutip.Qobj / callback function) – single operator or list of operators for which to evaluate; expectation values.; learningtimes (array_like) – list of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\).; tensors (array_like) – optional list of precomputed tensors \(T_k\); kwargs (dictionary) – Optional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns:output – An instance of the class qutip.solver.Result. Return type:qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fideli",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:155046,Usability,simpl,simply,155046,"nal amplitudes, statistics etc. Return type:OptimResult. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters:; H_d (Qobj or list of Qobj) – Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift; H_c (Qobj) – a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; U_0 (Qobj) – starting point for the evolution.; Typically the identity matrix; U_targ (",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:179935,Usability,simpl,simply,179935,"rror, final evolution; final amplitudes, statistics etc. Return type:OptimResult. opt_pulse_crab_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters:; H_d (Qobj or list of Qobj) – Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift; H_c (Qobj) – a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; U_0 (Qobj) – starting point for the evolution.; Typically",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:200975,Usability,progress bar,progress bar,200975,"will be created. Parameters:; task (a Python function) – The function that is to be called for each value in task_vec.; task_vec (array / list) – The list or array of values for which the task function is to be; evaluated.; args (list / dictionary) – The optional additional argument to the task function. For example; a dictionary with parameter values.; client (IPython.parallel.Client) – The IPython.parallel Client instance that will be used in the; parfor execution.; view (a IPython.parallel.Client view) – The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view().; show_scheduling (bool {False, True}, default False) – Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster.; show_progressbar (bool {False, True}, default False) – Display a HTML-based progress bar duing the execution of the parfor; loop. Returns:result – The result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. Return type:list. parallel_map(task, values, task_args=None, task_kwargs=None, client=None, view=None, progress_bar=None, show_scheduling=False, **kwargs)[source]¶; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(value, *args, **kwargs).; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:; task (a Python function) – The function that is to be called for each value in task_vec.; values (array / list) – The list or array of values for which the task function is to be; evaluated.; task_args (list / dictionary) – The optional additional arg",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/apidoc/functions.html:202747,Usability,progress bar,progress bar,202747,") – The function that is to be called for each value in task_vec.; values (array / list) – The list or array of values for which the task function is to be; evaluated.; task_args (list / dictionary) – The optional additional argument to the task function.; task_kwargs (list / dictionary) – The optional additional keyword argument to the task function.; client (IPython.parallel.Client) – The IPython.parallel Client instance that will be used in the; parfor execution.; view (a IPython.parallel.Client view) – The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view().; show_scheduling (bool {False, True}, default False) – Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster.; show_progressbar (bool {False, True}, default False) – Display a HTML-based progress bar during the execution of the parfor; loop. Returns:result – The result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. Return type:list. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns:version_table – Return an HTML-formatted string containing version information for; QuTiP dependencies. Return type:string. Miscellaneous¶. about()[source]¶; About box for QuTiP. Gives version numbers for; QuTiP, NumPy, SciPy, Cython, and MatPlotLib. simdiag(ops, evals=True)[source]¶; Simulateous diagonalization of communting Hermitian matrices.. Parameters:ops (list/array) – list or array of qobjs representing commuting Hermitian; operators. Returns:eigs – Tup",MatchSource.WIKI,docs/4.0.2/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html
https://qutip.org/docs/4.0.2/guide/guide-basics.html:1214,Availability,avail,available,1214,"irst things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; In [2]: import numpy as np. In [3]: import matplotlib.pyplot as plt. Note that, in the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics lies in the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems we need a data structure that is capable of encapsulating the properties of a quantum operator and ket/bra vectors. The quantum ",MatchSource.WIKI,docs/4.0.2/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-basics.html
https://qutip.org/docs/4.0.2/guide/guide-basics.html:12650,Availability,error,error,12650,,MatchSource.WIKI,docs/4.0.2/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-basics.html
https://qutip.org/docs/4.0.2/guide/guide-basics.html:1061,Deployability,install,installation,1061,"cumentation. QuTiP: Quantum Toolbox in Python; . ; . 4.0; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; First things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; In [2]: import numpy as np. In [3]: import matplotlib.pyplot as plt. Note that, in the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics lies in the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dyn",MatchSource.WIKI,docs/4.0.2/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-basics.html
https://qutip.org/docs/4.0.2/guide/guide-basics.html:26198,Deployability,update,updated,26198,,MatchSource.WIKI,docs/4.0.2/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-basics.html
https://qutip.org/docs/4.0.2/guide/guide-basics.html:4329,Energy Efficiency,charge,charge,4329,"fying the data for each quantum object is inefficient. Even more so when most objects correspond to commonly used types such as the ladder operators of a harmonic oscillator, the Pauli spin operators for a two-level system, or state vectors such as Fock states. Therefore, QuTiP includes predefined objects for a variety of states:. States; Command (# means optional); Inputs. Fock state ket vector; basis(N,#m)/fock(N,#m); N = number of levels in Hilbert space,; m = level containing excitation; (0 if no m given). Fock density matrix; (outer product of basis); fock_dm(N,#p); same as basis(N,m) / fock(N,m). Coherent state; coherent(N,alpha); alpha = complex number (eigenvalue); for requested coherent state. Coherent density matrix; (outer product); coherent_dm(N,alpha); same as coherent(N,alpha). Thermal density matrix; (for n particles); thermal_dm(N,n); n = particle number expectation value. and operators:. Operators; Command (# means optional); Inputs. Charge operator; charge(N,M=-N); Diagonal operator with entries; from M..0..N. Commutator; commutator(A, B, kind); Kind = ‘normal’ or ‘anti’. Diagonals operator; qdiags(N); Quantum object created from arrays of; diagonals at given offsets. Displacement operator; (Single-mode); displace(N,alpha); N=number of levels in Hilbert space,; alpha = complex displacement amplitude. Higher spin operators; jmat(j,#s); j = integer or half-integer; representing spin, s = ‘x’, ‘y’, ‘z’,; ‘+’, or ‘-‘. Identity; qeye(N); N = number of levels in Hilbert space. Lowering (destruction); operator; destroy(N); same as above. Momentum operator; momentum(N); same as above. Number operator; num(N); same as above. Phase operator; (Single-mode); phase(N, phi0); Single-mode Pegg-Barnett phase; operator with ref phase phi0. Position operator; position(N); same as above. Raising (creation); operator; create(N); same as above. Squeezing operator; (Single-mode); squeeze(N, sp); N=number of levels in Hilbert space,; sp = squeezing parameter. Squeezing op",MatchSource.WIKI,docs/4.0.2/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-basics.html
https://qutip.org/docs/4.0.2/guide/guide-basics.html:10002,Integrability,message,message,10002,"rieved using the Q.attribute notation. In addition to the attributes shown with the print function, the Qobj class also has the following:. Property; Attribute; Description. Data; Q.data; Matrix representing state or operator. Dimensions; Q.dims; List keeping track of shapes for; individual components of a; multipartite system (for tensor; products and partial traces). Shape; Q.shape; Dimensions of underlying data matrix. is Hermitian?; Q.isherm; Is the operator Hermitian or not?. Type; Q.type; Is object of type ‘ket, ‘bra’,; ‘oper’, or ‘super’?. The Qobj Class viewed as a container for the properties need to characterize a quantum operator or state vector. For the destruction operator above:; In [14]: q.type; Out[14]: 'oper'. In [15]: q.isherm; ",MatchSource.WIKI,docs/4.0.2/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-basics.html
https://qutip.org/docs/4.0.2/guide/guide-basics.html:1948,Modifiability,variab,variables,1948,"olbox in Python. Docs »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; In [2]: import numpy as np. In [3]: import matplotlib.pyplot as plt. Note that, in the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics lies in the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems we need a data structure that is capable of encapsulating the properties of a quantum operator and ket/bra vectors. The quantum object class, qutip.Qobj, accomplishes this using matrix representation.; To begin, let us create a blank Qobj:; In [4]: Qobj(); Out[4]: ; Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[ 0.]]. where we see the blank Qobj object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. Hint; By convention, Class objects in Python such as Qobj() differ from functions in the use of a beginning capital letter. We can create a Qobj with a user defined data set by passing a list or array of data into the Qobj:; In [5]: Qobj([[1],[2],[3],[4],[5]]); Out[5]: ; Quantum object: dims = [[5],",MatchSource.WIKI,docs/4.0.2/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-basics.html
https://qutip.org/docs/4.0.2/guide/guide-basics.html:1088,Performance,load,load,1088,"lation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; First things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; In [2]: import numpy as np. In [3]: import matplotlib.pyplot as plt. Note that, in the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics lies in the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems we need a data structure that is capable of encapsula",MatchSource.WIKI,docs/4.0.2/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-basics.html
https://qutip.org/docs/4.0.2/guide/guide-basics.html:1193,Performance,load,load,1193,"irst things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; In [2]: import numpy as np. In [3]: import matplotlib.pyplot as plt. Note that, in the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics lies in the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems we need a data structure that is capable of encapsulating the properties of a quantum operator and ket/bra vectors. The quantum ",MatchSource.WIKI,docs/4.0.2/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-basics.html
https://qutip.org/docs/4.0.2/guide/guide-basics.html:1599,Performance,load,loaded,1599,"Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; In [2]: import numpy as np. In [3]: import matplotlib.pyplot as plt. Note that, in the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics lies in the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems we need a data structure that is capable of encapsulating the properties of a quantum operator and ket/bra vectors. The quantum object class, qutip.Qobj, accomplishes this using matrix representation.; To begin, let us create a blank Qobj:; In [4]: Qobj(); Out[4]: ; Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[ 0.]]. where we see the blank Qobj object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. Hi",MatchSource.WIKI,docs/4.0.2/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-basics.html
https://qutip.org/docs/4.0.2/guide/guide-basics.html:8772,Security,access,accessed,8772,,MatchSource.WIKI,docs/4.0.2/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-basics.html
https://qutip.org/docs/4.0.2/guide/guide-basics.html:10126,Security,access,access,10126,"erty; Attribute; Description. Data; Q.data; Matrix representing state or operator. Dimensions; Q.dims; List keeping track of shapes for; individual components of a; multipartite system (for tensor; products and partial traces). Shape; Q.shape; Dimensions of underlying data matrix. is Hermitian?; Q.isherm; Is the operator Hermitian or not?. Type; Q.type; Is object of type ‘ket, ‘bra’,; ‘oper’, or ‘super’?. The Qobj Class viewed as a container for the properties need to characterize a quantum operator or state vector. For the destruction operator above:; In [14]: q.type; Out[14]: 'oper'. In [15]: q.isherm; ",MatchSource.WIKI,docs/4.0.2/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-basics.html
https://qutip.org/docs/4.0.2/guide/guide-basics.html:13092,Testability,log,logic,13092,,MatchSource.WIKI,docs/4.0.2/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-basics.html
https://qutip.org/docs/4.0.2/guide/guide-basics.html:3137,Usability,clear,clear,3137," of encapsulating the properties of a quantum operator and ket/bra vectors. The quantum object class, qutip.Qobj, accomplishes this using matrix representation.; To begin, let us create a blank Qobj:; In [4]: Qobj(); Out[4]: ; Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[ 0.]]. where we see the blank Qobj object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. Hint; By convention, Class objects in Python such as Qobj() differ from functions in the use of a beginning capital letter. We can create a Qobj with a user defined data set by passing a list or array of data into the Qobj:; In [5]: Qobj([[1],[2],[3],[4],[5]]); Out[5]: ; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 1.]; [ 2.]; [ 3.]; [ 4.]; [ 5.]]. Notice how both the dims and shape change according to the input data. Although dims and shape appear to have the same function, the difference will become quite clear in the section on tensor products and partial traces. Note; If you are running QuTiP from a python script you must use the print function to view the Qobj attributes. States and operators¶; Manually specifying the data for each quantum object is inefficient. Even more so when most objects correspond to commonly used types such as the ladder operators of a harmonic oscillator, the Pauli spin operators for a two-level system, or state vectors such as Fock states. Therefore, QuTiP includes predefined objects for a variety of states:. States; Command (# means optional); Inputs. Fock state ket vector; basis(N,#m)/fock(N,#m); N = number of levels in Hilbert space,; m = level containing excitation; (0 if no m given). Fock density matrix; (outer product of basis); fock_dm(N,#p); same as basis(N,m) / fock(N,m). Coherent state; coherent(N,alpha); alpha = complex number (eigenvalue); for requested coherent state. Coherent density matrix; (outer product); coherent_dm(N,alpha)",MatchSource.WIKI,docs/4.0.2/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-basics.html
https://qutip.org/docs/4.0.2/guide/guide-bloch.html:6986,Availability,down,down,6986,"or and shape of the data points is varied automatically by the Bloch class. Notice how the color and point markers change for each set of data. Again, we have had to call add_points twice because adding more than one set of multiple data points is not supported by the add_points function.; What if we want to vary the color of our points. We can tell the qutip.Bloch class to vary the color of each point according to the colors listed in the b.point_color list (see Configuring the Bloch sphere below). Again after clear():; In [39]: xp = [np.cos(th) for th in np.linspace(0, 2*pi, 20)]. In [40]: yp = [sin(th) for th in np.linspace(0, 2*pi, 20)]. In [41]: zp = np.zeros(20). In [42]: pnts = [xp, yp, zp]. In [43]: b.add_points(pnts,'m') # <-- add a 'm' string to signify 'multi' colored points. In [44]: b.show(). Now, the data points cycle through a variety of predefined colors. Now lets add another set of points, but this time we want the set to be a single color, representing say a qubit going from the \(\left|\rm up\right>\) state to the \(\left|\rm down\right>\) state in the y-z plane:; In [45]: xz = np.zeros(20). In [46]: yz = [np.sin(th) for th in np.linspace(0, pi ,20)]. In [47]: zz = [np.cos(th) for th in np.linspace(0, pi, 20)]. In [48]: b.add_points([xz, yz, zz]) # no 'm'. In [49]: b.show(). Again, the same plot can be generated using the qutip.Bloch3d class by replacing Bloch with Bloch3d:. A more slick way of using this ‘multi’ color feature is also given in the example, where we set the color of the markers as a function of time. Differences Between Bloch and Bloch3d¶; While in general the Bloch and Bloch3d classes are interchangeable, there are some important differences to consider when choosing between them. The Bloch class uses Matplotlib to generate figures. As such, the data plotted on the sphere is in reality just a 2D object. In contrast the Bloch3d class uses the 3D rendering engine from VTK via mayavi to generate the sphere and the included data. In t",MatchSource.WIKI,docs/4.0.2/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-bloch.html
https://qutip.org/docs/4.0.2/guide/guide-bloch.html:15472,Deployability,install,installing,15472," # qubit angular frequency; theta = 0.2 * pi # qubit angle from sigma_z axis (toward sigma_x axis); gamma1 = 0.5 # qubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a* basis(2,0) + (1-a)*basis(2,1))/(sqrt(a**2 + (1-a)**2)); tlist = linspace(0,4,250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; b = Bloch(); b.vector_color = ['r']; b.view = [-40,30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp') #saving images to temp directory in current working directory. Generating an animation using ffmpeg (for example) is fairly simple:; ffmpeg -r 20 -b 1800 -i bloch_%01d.png bloch.mp4. Directly Generating an Animation¶. Important; Generating animations directly from Matplotlib requires installing either mencoder or ffmpeg. While either choice works on linux, it is best to choose ffmpeg when running on the Mac. If using macports just do: sudo port install ffmpeg. The code to directly generate an mp4 movie of the Qubit decay is as follows:; from pylab import *; import matplotlib.animation as animation; from mpl_toolkits.mplot3d import Axes3D. fig = figure(); ax = Axes3D(fig,azim=-40,elev=30); sphere = Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([np.sin(theta),0,np.cos(theta)]); sphere.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); sphere.make_sphere(); return ax. def init():; sphere.vector_color = ['r']; return ax. ani = animation.FuncAnimation(fig, animate, np.arange(len(sx)),; init_func=init, blit=True, repeat=False); ani.save('bloch_sphere.mp4', fps=20, clear_temp=True). The resulting movie may be viewed here: Bloch_Decay.mp4. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and",MatchSource.WIKI,docs/4.0.2/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-bloch.html
https://qutip.org/docs/4.0.2/guide/guide-bloch.html:15636,Deployability,install,install,15636,".5 # qubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a* basis(2,0) + (1-a)*basis(2,1))/(sqrt(a**2 + (1-a)**2)); tlist = linspace(0,4,250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; b = Bloch(); b.vector_color = ['r']; b.view = [-40,30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp') #saving images to temp directory in current working directory. Generating an animation using ffmpeg (for example) is fairly simple:; ffmpeg -r 20 -b 1800 -i bloch_%01d.png bloch.mp4. Directly Generating an Animation¶. Important; Generating animations directly from Matplotlib requires installing either mencoder or ffmpeg. While either choice works on linux, it is best to choose ffmpeg when running on the Mac. If using macports just do: sudo port install ffmpeg. The code to directly generate an mp4 movie of the Qubit decay is as follows:; from pylab import *; import matplotlib.animation as animation; from mpl_toolkits.mplot3d import Axes3D. fig = figure(); ax = Axes3D(fig,azim=-40,elev=30); sphere = Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([np.sin(theta),0,np.cos(theta)]); sphere.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); sphere.make_sphere(); return ax. def init():; sphere.vector_color = ['r']; return ax. ani = animation.FuncAnimation(fig, animate, np.arange(len(sx)),; init_func=init, blit=True, repeat=False); ani.save('bloch_sphere.mp4', fps=20, clear_temp=True). The resulting movie may be viewed here: Bloch_Decay.mp4. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-bloch.html
https://qutip.org/docs/4.0.2/guide/guide-bloch.html:16478,Deployability,update,updated,16478,".5 # qubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a* basis(2,0) + (1-a)*basis(2,1))/(sqrt(a**2 + (1-a)**2)); tlist = linspace(0,4,250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; b = Bloch(); b.vector_color = ['r']; b.view = [-40,30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp') #saving images to temp directory in current working directory. Generating an animation using ffmpeg (for example) is fairly simple:; ffmpeg -r 20 -b 1800 -i bloch_%01d.png bloch.mp4. Directly Generating an Animation¶. Important; Generating animations directly from Matplotlib requires installing either mencoder or ffmpeg. While either choice works on linux, it is best to choose ffmpeg when running on the Mac. If using macports just do: sudo port install ffmpeg. The code to directly generate an mp4 movie of the Qubit decay is as follows:; from pylab import *; import matplotlib.animation as animation; from mpl_toolkits.mplot3d import Axes3D. fig = figure(); ax = Axes3D(fig,azim=-40,elev=30); sphere = Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([np.sin(theta),0,np.cos(theta)]); sphere.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); sphere.make_sphere(); return ax. def init():; sphere.vector_color = ['r']; return ax. ani = animation.FuncAnimation(fig, animate, np.arange(len(sx)),; init_func=init, blit=True, repeat=False); ani.save('bloch_sphere.mp4', fps=20, clear_temp=True). The resulting movie may be viewed here: Bloch_Decay.mp4. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-bloch.html
https://qutip.org/docs/4.0.2/guide/guide-bloch.html:14249,Modifiability,evolve,evolve,14249,"e() method and generate a series of images to convert into an animation. However, as of Matplotlib version 1.1, creating animations is built-in. We will demonstrate both methods by looking at the decay of a qubit on the bloch sphere. Example: Qubit Decay¶; The code for calculating the expectation values for the Pauli spin operators of a qubit decay is given below. This code is common to both animation examples.; from qutip import *; from scipy import *; def qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist):; # operators and the hamiltonian; sx = sigmax(); sy = sigmay(); sz = sigmaz(); sm = sigmam(); H = w * (cos(theta) * sz + sin(theta) * sx); # collapse operators; c_op_list = []; n_th = 0.5 # temperature; rate = gamma1 * (n_th + 1); if rate > 0.0: c_op_list.append(sqrt(rate) * sm); rate = gamma1 * n_th; if rate > 0.0: c_op_list.append(sqrt(rate) * sm.dag()); rate = gamma2; if rate > 0.0: c_op_list.append(sqrt(rate) * sz). # evolve and calculate expectation values; output = mesolve(H, psi0, tlist, c_op_list, [sx, sy, sz]) ; return output.expect[0], output.expect[1], output.expect[2]; ; ## calculate the dynamics; w = 1.0 * 2 * pi # qubit angular frequency; theta = 0.2 * pi # qubit angle from sigma_z axis (toward sigma_x axis); gamma1 = 0.5 # qubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a* basis(2,0) + (1-a)*basis(2,1))/(sqrt(a**2 + (1-a)**2)); tlist = linspace(0,4,250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; b = Bloch(); b.vector_color = ['r']; b.view = [-40,30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp') #saving images to temp directory in current working directory. Generating an animation using ffmpeg (for example) is f",MatchSource.WIKI,docs/4.0.2/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-bloch.html
https://qutip.org/docs/4.0.2/guide/guide-bloch.html:1764,Performance,load,load,1764,"Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Plotting on the Bloch Sphere. Plotting on the Bloch Sphere¶. Important; Updated in QuTiP version 3.0. Introduction¶; When studying the dynamics of a two-level system, it is often convent to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; In [1]: b = Bloch(). which will load an instance of the qutip.Bloch class, or using:; >>> b3d = Bloch3d(). that loads the qutip.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:; In [2]: b.show(). or. In addition to the show() command, the Bloch class has the following functions:. Name; Input Parameters (#=optional); Description. add_points(pnts,#meth); pnts list/array of (x,y,z) points,; meth=’m’ (default meth=’s’) will; plot a collection of points as; multi-colored data points.; Adds a single or set of data points; to be plotted on the sphere. add_states(state,#kind); state Qobj or list/array of Qobj’s; representing state or density matrix; of a two-level system,; kind (optional) string specifying; if state should be plotted as point; (‘point’) or vector (default).; Input multiple states as a list or array. add_vectors(vec); vec list/array of (x,y,z) points; giving direction and length of; state vectors.; adds single or multiple ",MatchSource.WIKI,docs/4.0.2/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-bloch.html
https://qutip.org/docs/4.0.2/guide/guide-bloch.html:1844,Performance,load,loads,1844,"ng Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Plotting on the Bloch Sphere. Plotting on the Bloch Sphere¶. Important; Updated in QuTiP version 3.0. Introduction¶; When studying the dynamics of a two-level system, it is often convent to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; In [1]: b = Bloch(). which will load an instance of the qutip.Bloch class, or using:; >>> b3d = Bloch3d(). that loads the qutip.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:; In [2]: b.show(). or. In addition to the show() command, the Bloch class has the following functions:. Name; Input Parameters (#=optional); Description. add_points(pnts,#meth); pnts list/array of (x,y,z) points,; meth=’m’ (default meth=’s’) will; plot a collection of points as; multi-colored data points.; Adds a single or set of data points; to be plotted on the sphere. add_states(state,#kind); state Qobj or list/array of Qobj’s; representing state or density matrix; of a two-level system,; kind (optional) string specifying; if state should be plotted as point; (‘point’) or vector (default).; Input multiple states as a list or array. add_vectors(vec); vec list/array of (x,y,z) points; giving direction and length of; state vectors.; adds single or multiple vectors to plot. clear();  ; Removes all data from Bloch sphere.; Keeps cust",MatchSource.WIKI,docs/4.0.2/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-bloch.html
https://qutip.org/docs/4.0.2/guide/guide-bloch.html:12130,Security,access,accessed,12130,"‘gray’. b.frame_num; Number of wireframe elements to draw; 8. b.frame_radius; Radius of wireframe lines; 0.005. b.point_color; List of colors for Bloch point markers to cycle through; [‘r’, ‘g’, ‘b’, ‘y’]. b.point_mode; Type of point markers to draw; sphere. b.point_size; Size of points; 0.075. b.sphere_alpha; Transparency of Bloch sphere; 0.1. b.sphere_color; Color of Bloch sphere; ‘#808080’. b.size; Sets size of figure window; [500,500] (500x500 pixels). b.vector_color; List of colors for Bloch vectors to cycle through; [‘r’, ‘g’, ‘b’, ‘y’]. b.vector_width; Width of Bloch vectors; 3. b.view; Azimuthal and Elevation viewing angles; [45,65 ]. b.xlabel; Labels for x-axis; [‘|x>’, ‘’] +x and -x. b.xlpos; Position of x-axis labels; [1.07,-1.07]. b.ylabel; Labels for y-axis; [‘$y$’,’‘] +y and -y. b.ylpos; Position of y-axis labels; [1.07,-1.07]. b.zlabel; Labels for z-axis; [‘|0>’, ‘|1>’] +z and -z. b.zlpos; Position of z-axis labels; [1.07,-1.07]. These properties can also be accessed via the print command:; In [50]: b = Bloch(). In [51]: print(b); Bloch data:; -----------; Number of points: 0; Number of vectors: 0. Bloch sphere properties:; ------------------------; font_color: black; font_size: 20; frame_alpha: 0.2; frame_color: gray; frame_width: 1; point_color: ['b', 'r', 'g', '#CC6600']; point_marker: ['o', 's', 'd', '^']; point_size: [25, 32, 35, 45]; sphere_alpha: 0.2; sphere_color: #FFDDDD; figsize: [5, 5]; vector_color: ['g', '#CC6600', 'b', 'r']; vector_width: 3; vector_style: -|>; vector_mutation: 20; view: [-60, 30]; xlabel: ['$x$', '']; xlpos: [1.2, -1.2]; ylabel: ['$y$', '']; ylpos: [1.2, -1.2]; zlabel: ['$\\left|0\\right>$', '$\\left|1\\right>$']; zlpos: [1.2, -1.2]. Animating with the Bloch sphere¶; The Bloch class was designed from the outset to generate animations. To animate a set of vectors or data points the basic idea is: plot the data at time t1, save the sphere, clear the sphere, plot data at t2,... The Bloch sphere will automatically number the",MatchSource.WIKI,docs/4.0.2/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-bloch.html
https://qutip.org/docs/4.0.2/guide/guide-bloch.html:1934,Usability,simpl,simply,1934,"um Toolbox in Python. Docs »; Users Guide »; Plotting on the Bloch Sphere. Plotting on the Bloch Sphere¶. Important; Updated in QuTiP version 3.0. Introduction¶; When studying the dynamics of a two-level system, it is often convent to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; In [1]: b = Bloch(). which will load an instance of the qutip.Bloch class, or using:; >>> b3d = Bloch3d(). that loads the qutip.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:; In [2]: b.show(). or. In addition to the show() command, the Bloch class has the following functions:. Name; Input Parameters (#=optional); Description. add_points(pnts,#meth); pnts list/array of (x,y,z) points,; meth=’m’ (default meth=’s’) will; plot a collection of points as; multi-colored data points.; Adds a single or set of data points; to be plotted on the sphere. add_states(state,#kind); state Qobj or list/array of Qobj’s; representing state or density matrix; of a two-level system,; kind (optional) string specifying; if state should be plotted as point; (‘point’) or vector (default).; Input multiple states as a list or array. add_vectors(vec); vec list/array of (x,y,z) points; giving direction and length of; state vectors.; adds single or multiple vectors to plot. clear();  ; Removes all data from Bloch sphere.; Keeps customized figure properties. save(#format,#dirc); format format (default=’png’) of; output file, dirc",MatchSource.WIKI,docs/4.0.2/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-bloch.html
https://qutip.org/docs/4.0.2/guide/guide-bloch.html:2790,Usability,clear,clear,2790,"ng:; >>> b3d = Bloch3d(). that loads the qutip.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:; In [2]: b.show(). or. In addition to the show() command, the Bloch class has the following functions:. Name; Input Parameters (#=optional); Description. add_points(pnts,#meth); pnts list/array of (x,y,z) points,; meth=’m’ (default meth=’s’) will; plot a collection of points as; multi-colored data points.; Adds a single or set of data points; to be plotted on the sphere. add_states(state,#kind); state Qobj or list/array of Qobj’s; representing state or density matrix; of a two-level system,; kind (optional) string specifying; if state should be plotted as point; (‘point’) or vector (default).; Input multiple states as a list or array. add_vectors(vec); vec list/array of (x,y,z) points; giving direction and length of; state vectors.; adds single or multiple vectors to plot. clear();  ; Removes all data from Bloch sphere.; Keeps customized figure properties. save(#format,#dirc); format format (default=’png’) of; output file, dirc (default=cwd); output directory; Saves Bloch sphere to a file. show();  ; Generates Bloch sphere with given data. As an example, we can add a single data point:; In [3]: pnt = [1/np.sqrt(3),1/np.sqrt(3),1/np.sqrt(3)]. In [4]: b.add_points(pnt). In [5]: b.show(). and then a single vector:; In [6]: vec = [0,1,0]. In [7]: b.add_vectors(vec). In [8]: b.show(). and then add another vector corresponding to the \(\left|\rm up \right>\) state:; In [9]: up = basis(2,0). In [10]: b.add_states(up). In [11]: b.show(). Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4). In total, the code for constructing our Bloch sphere with one vector, one state, and a single data point is:; In [12]: pnt = [1/np.sqrt(3),1/np.sqrt(3),1/np.sqrt(3)]. In [13]: b.add_points(pnt). In [14]: b.a",MatchSource.WIKI,docs/4.0.2/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-bloch.html
https://qutip.org/docs/4.0.2/guide/guide-bloch.html:4191,Usability,clear,clear,4191,"le vector:; In [6]: vec = [0,1,0]. In [7]: b.add_vectors(vec). In [8]: b.show(). and then add another vector corresponding to the \(\left|\rm up \right>\) state:; In [9]: up = basis(2,0). In [10]: b.add_states(up). In [11]: b.show(). Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4). In total, the code for constructing our Bloch sphere with one vector, one state, and a single data point is:; In [12]: pnt = [1/np.sqrt(3),1/np.sqrt(3),1/np.sqrt(3)]. In [13]: b.add_points(pnt). In [14]: b.add_vectors(vec). In [15]: b.add_states(up). In [16]: b.show(). where we have removed the extra show() commands. Replacing b=Bloch() with b=Bloch3d() in the above code generates the following 3D Bloch sphere. We can also plot multiple points, vectors, and states at the same time by passing list or arrays instead of individual elements. Before giving an example, we can use the clear() command to remove the current data from our Bloch sphere instead of creating a new instance:; In [17]: b.clear(). In [18]: b.show(). Now on the same Bloch sphere, we can plot the three states associated with the x, y, and z directions:; In [19]: x = (basis(2,0)+(1+0j)*basis(2,1)).unit(). In [20]: y = (basis(2,0)+(0+1j)*basis(2,1)).unit(). In [21]: z = (basis(2,0)+(0+0j)*basis(2,1)).unit(). In [22]: b.add_states([x,y,z]). In [23]: b.show(). a similar method works for adding vectors:; In [24]: b.clear(). In [25]: vec = [[1,0,0],[0,1,0],[0,0,1]]. In [26]: b.add_vectors(vec). In [27]: b.show(). Adding multiple points to the Bloch sphere works slightly differently than adding multiple states or vectors. For example, lets add a set of 20 points around the equator (after calling clear()):; In [28]: xp = [np.cos(th) for th in np.linspace(0, 2*pi, 20)]. In [29]: yp = [np.sin(th) for th in np.linspace(0, 2*pi, 20)]. In [30]: zp = np.zeros(20). In [31]: pnts = [xp, yp, zp]. In [32]: b.add_points(pnts). In [33]: b.show(). No",MatchSource.WIKI,docs/4.0.2/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-bloch.html
https://qutip.org/docs/4.0.2/guide/guide-bloch.html:4304,Usability,clear,clear,4304,"nd then add another vector corresponding to the \(\left|\rm up \right>\) state:; In [9]: up = basis(2,0). In [10]: b.add_states(up). In [11]: b.show(). Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4). In total, the code for constructing our Bloch sphere with one vector, one state, and a single data point is:; In [12]: pnt = [1/np.sqrt(3),1/np.sqrt(3),1/np.sqrt(3)]. In [13]: b.add_points(pnt). In [14]: b.add_vectors(vec). In [15]: b.add_states(up). In [16]: b.show(). where we have removed the extra show() commands. Replacing b=Bloch() with b=Bloch3d() in the above code generates the following 3D Bloch sphere. We can also plot multiple points, vectors, and states at the same time by passing list or arrays instead of individual elements. Before giving an example, we can use the clear() command to remove the current data from our Bloch sphere instead of creating a new instance:; In [17]: b.clear(). In [18]: b.show(). Now on the same Bloch sphere, we can plot the three states associated with the x, y, and z directions:; In [19]: x = (basis(2,0)+(1+0j)*basis(2,1)).unit(). In [20]: y = (basis(2,0)+(0+1j)*basis(2,1)).unit(). In [21]: z = (basis(2,0)+(0+0j)*basis(2,1)).unit(). In [22]: b.add_states([x,y,z]). In [23]: b.show(). a similar method works for adding vectors:; In [24]: b.clear(). In [25]: vec = [[1,0,0],[0,1,0],[0,0,1]]. In [26]: b.add_vectors(vec). In [27]: b.show(). Adding multiple points to the Bloch sphere works slightly differently than adding multiple states or vectors. For example, lets add a set of 20 points around the equator (after calling clear()):; In [28]: xp = [np.cos(th) for th in np.linspace(0, 2*pi, 20)]. In [29]: yp = [np.sin(th) for th in np.linspace(0, 2*pi, 20)]. In [30]: zp = np.zeros(20). In [31]: pnts = [xp, yp, zp]. In [32]: b.add_points(pnts). In [33]: b.show(). Notice that, in contrast to states or vectors, each point remains the same color as",MatchSource.WIKI,docs/4.0.2/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-bloch.html
https://qutip.org/docs/4.0.2/guide/guide-bloch.html:4698,Usability,clear,clear,4698,"ta point is:; In [12]: pnt = [1/np.sqrt(3),1/np.sqrt(3),1/np.sqrt(3)]. In [13]: b.add_points(pnt). In [14]: b.add_vectors(vec). In [15]: b.add_states(up). In [16]: b.show(). where we have removed the extra show() commands. Replacing b=Bloch() with b=Bloch3d() in the above code generates the following 3D Bloch sphere. We can also plot multiple points, vectors, and states at the same time by passing list or arrays instead of individual elements. Before giving an example, we can use the clear() command to remove the current data from our Bloch sphere instead of creating a new instance:; In [17]: b.clear(). In [18]: b.show(). Now on the same Bloch sphere, we can plot the three states associated with the x, y, and z directions:; In [19]: x = (basis(2,0)+(1+0j)*basis(2,1)).unit(). In [20]: y = (basis(2,0)+(0+1j)*basis(2,1)).unit(). In [21]: z = (basis(2,0)+(0+0j)*basis(2,1)).unit(). In [22]: b.add_states([x,y,z]). In [23]: b.show(). a similar method works for adding vectors:; In [24]: b.clear(). In [25]: vec = [[1,0,0],[0,1,0],[0,0,1]]. In [26]: b.add_vectors(vec). In [27]: b.show(). Adding multiple points to the Bloch sphere works slightly differently than adding multiple states or vectors. For example, lets add a set of 20 points around the equator (after calling clear()):; In [28]: xp = [np.cos(th) for th in np.linspace(0, 2*pi, 20)]. In [29]: yp = [np.sin(th) for th in np.linspace(0, 2*pi, 20)]. In [30]: zp = np.zeros(20). In [31]: pnts = [xp, yp, zp]. In [32]: b.add_points(pnts). In [33]: b.show(). Notice that, in contrast to states or vectors, each point remains the same color as the initial point. This is because adding multiple data points using the add_points function is interpreted, by default, to correspond to a single data point (single qubit state) plotted at different times. This is very useful when visualizing the dynamics of a qubit. An example of this is given in the example . If we want to plot additional qubit states we can call additional add_points fu",MatchSource.WIKI,docs/4.0.2/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-bloch.html
https://qutip.org/docs/4.0.2/guide/guide-bloch.html:4982,Usability,clear,clear,4982,"d() in the above code generates the following 3D Bloch sphere. We can also plot multiple points, vectors, and states at the same time by passing list or arrays instead of individual elements. Before giving an example, we can use the clear() command to remove the current data from our Bloch sphere instead of creating a new instance:; In [17]: b.clear(). In [18]: b.show(). Now on the same Bloch sphere, we can plot the three states associated with the x, y, and z directions:; In [19]: x = (basis(2,0)+(1+0j)*basis(2,1)).unit(). In [20]: y = (basis(2,0)+(0+1j)*basis(2,1)).unit(). In [21]: z = (basis(2,0)+(0+0j)*basis(2,1)).unit(). In [22]: b.add_states([x,y,z]). In [23]: b.show(). a similar method works for adding vectors:; In [24]: b.clear(). In [25]: vec = [[1,0,0],[0,1,0],[0,0,1]]. In [26]: b.add_vectors(vec). In [27]: b.show(). Adding multiple points to the Bloch sphere works slightly differently than adding multiple states or vectors. For example, lets add a set of 20 points around the equator (after calling clear()):; In [28]: xp = [np.cos(th) for th in np.linspace(0, 2*pi, 20)]. In [29]: yp = [np.sin(th) for th in np.linspace(0, 2*pi, 20)]. In [30]: zp = np.zeros(20). In [31]: pnts = [xp, yp, zp]. In [32]: b.add_points(pnts). In [33]: b.show(). Notice that, in contrast to states or vectors, each point remains the same color as the initial point. This is because adding multiple data points using the add_points function is interpreted, by default, to correspond to a single data point (single qubit state) plotted at different times. This is very useful when visualizing the dynamics of a qubit. An example of this is given in the example . If we want to plot additional qubit states we can call additional add_points functions:; In [34]: xz = np.zeros(20). In [35]: yz = [np.sin(th) for th in np.linspace(0, pi, 20)]. In [36]: zz = [np.cos(th) for th in np.linspace(0, pi, 20)]. In [37]: b.add_points([xz, yz, zz]). In [38]: b.show(). The color and shape of the data points is",MatchSource.WIKI,docs/4.0.2/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-bloch.html
https://qutip.org/docs/4.0.2/guide/guide-bloch.html:6442,Usability,clear,clear,6442,"single data point (single qubit state) plotted at different times. This is very useful when visualizing the dynamics of a qubit. An example of this is given in the example . If we want to plot additional qubit states we can call additional add_points functions:; In [34]: xz = np.zeros(20). In [35]: yz = [np.sin(th) for th in np.linspace(0, pi, 20)]. In [36]: zz = [np.cos(th) for th in np.linspace(0, pi, 20)]. In [37]: b.add_points([xz, yz, zz]). In [38]: b.show(). The color and shape of the data points is varied automatically by the Bloch class. Notice how the color and point markers change for each set of data. Again, we have had to call add_points twice because adding more than one set of multiple data points is not supported by the add_points function.; What if we want to vary the color of our points. We can tell the qutip.Bloch class to vary the color of each point according to the colors listed in the b.point_color list (see Configuring the Bloch sphere below). Again after clear():; In [39]: xp = [np.cos(th) for th in np.linspace(0, 2*pi, 20)]. In [40]: yp = [sin(th) for th in np.linspace(0, 2*pi, 20)]. In [41]: zp = np.zeros(20). In [42]: pnts = [xp, yp, zp]. In [43]: b.add_points(pnts,'m') # <-- add a 'm' string to signify 'multi' colored points. In [44]: b.show(). Now, the data points cycle through a variety of predefined colors. Now lets add another set of points, but this time we want the set to be a single color, representing say a qubit going from the \(\left|\rm up\right>\) state to the \(\left|\rm down\right>\) state in the y-z plane:; In [45]: xz = np.zeros(20). In [46]: yz = [np.sin(th) for th in np.linspace(0, pi ,20)]. In [47]: zz = [np.cos(th) for th in np.linspace(0, pi, 20)]. In [48]: b.add_points([xz, yz, zz]) # no 'm'. In [49]: b.show(). Again, the same plot can be generated using the qutip.Bloch3d class by replacing Bloch with Bloch3d:. A more slick way of using this ‘multi’ color feature is also given in the example, where we set the color of",MatchSource.WIKI,docs/4.0.2/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-bloch.html
https://qutip.org/docs/4.0.2/guide/guide-bloch.html:13058,Usability,clear,clear,13058,"s; [‘|0>’, ‘|1>’] +z and -z. b.zlpos; Position of z-axis labels; [1.07,-1.07]. These properties can also be accessed via the print command:; In [50]: b = Bloch(). In [51]: print(b); Bloch data:; -----------; Number of points: 0; Number of vectors: 0. Bloch sphere properties:; ------------------------; font_color: black; font_size: 20; frame_alpha: 0.2; frame_color: gray; frame_width: 1; point_color: ['b', 'r', 'g', '#CC6600']; point_marker: ['o', 's', 'd', '^']; point_size: [25, 32, 35, 45]; sphere_alpha: 0.2; sphere_color: #FFDDDD; figsize: [5, 5]; vector_color: ['g', '#CC6600', 'b', 'r']; vector_width: 3; vector_style: -|>; vector_mutation: 20; view: [-60, 30]; xlabel: ['$x$', '']; xlpos: [1.2, -1.2]; ylabel: ['$y$', '']; ylpos: [1.2, -1.2]; zlabel: ['$\\left|0\\right>$', '$\\left|1\\right>$']; zlpos: [1.2, -1.2]. Animating with the Bloch sphere¶; The Bloch class was designed from the outset to generate animations. To animate a set of vectors or data points the basic idea is: plot the data at time t1, save the sphere, clear the sphere, plot data at t2,... The Bloch sphere will automatically number the output file based on how many times the object has been saved (this is stored in b.savenum). The easiest way to animate data on the Bloch sphere is to use the save() method and generate a series of images to convert into an animation. However, as of Matplotlib version 1.1, creating animations is built-in. We will demonstrate both methods by looking at the decay of a qubit on the bloch sphere. Example: Qubit Decay¶; The code for calculating the expectation values for the Pauli spin operators of a qubit decay is given below. This code is common to both animation examples.; from qutip import *; from scipy import *; def qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist):; # operators and the hamiltonian; sx = sigmax(); sy = sigmay(); sz = sigmaz(); sm = sigmam(); H = w * (cos(theta) * sz + sin(theta) * sx); # collapse operators; c_op_list = []; n_th = 0.5 # temperatur",MatchSource.WIKI,docs/4.0.2/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-bloch.html
https://qutip.org/docs/4.0.2/guide/guide-bloch.html:15066,Usability,clear,clear,15066,"op_list.append(sqrt(rate) * sm); rate = gamma1 * n_th; if rate > 0.0: c_op_list.append(sqrt(rate) * sm.dag()); rate = gamma2; if rate > 0.0: c_op_list.append(sqrt(rate) * sz). # evolve and calculate expectation values; output = mesolve(H, psi0, tlist, c_op_list, [sx, sy, sz]) ; return output.expect[0], output.expect[1], output.expect[2]; ; ## calculate the dynamics; w = 1.0 * 2 * pi # qubit angular frequency; theta = 0.2 * pi # qubit angle from sigma_z axis (toward sigma_x axis); gamma1 = 0.5 # qubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a* basis(2,0) + (1-a)*basis(2,1))/(sqrt(a**2 + (1-a)**2)); tlist = linspace(0,4,250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; b = Bloch(); b.vector_color = ['r']; b.view = [-40,30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp') #saving images to temp directory in current working directory. Generating an animation using ffmpeg (for example) is fairly simple:; ffmpeg -r 20 -b 1800 -i bloch_%01d.png bloch.mp4. Directly Generating an Animation¶. Important; Generating animations directly from Matplotlib requires installing either mencoder or ffmpeg. While either choice works on linux, it is best to choose ffmpeg when running on the Mac. If using macports just do: sudo port install ffmpeg. The code to directly generate an mp4 movie of the Qubit decay is as follows:; from pylab import *; import matplotlib.animation as animation; from mpl_toolkits.mplot3d import Axes3D. fig = figure(); ax = Axes3D(fig,azim=-40,elev=30); sphere = Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([np.sin(theta),0,np.cos(theta)]); sphere.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); sphere.make_sphere(); retur",MatchSource.WIKI,docs/4.0.2/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-bloch.html
https://qutip.org/docs/4.0.2/guide/guide-bloch.html:15311,Usability,simpl,simple,15311,"olve(H, psi0, tlist, c_op_list, [sx, sy, sz]) ; return output.expect[0], output.expect[1], output.expect[2]; ; ## calculate the dynamics; w = 1.0 * 2 * pi # qubit angular frequency; theta = 0.2 * pi # qubit angle from sigma_z axis (toward sigma_x axis); gamma1 = 0.5 # qubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a* basis(2,0) + (1-a)*basis(2,1))/(sqrt(a**2 + (1-a)**2)); tlist = linspace(0,4,250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; b = Bloch(); b.vector_color = ['r']; b.view = [-40,30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp') #saving images to temp directory in current working directory. Generating an animation using ffmpeg (for example) is fairly simple:; ffmpeg -r 20 -b 1800 -i bloch_%01d.png bloch.mp4. Directly Generating an Animation¶. Important; Generating animations directly from Matplotlib requires installing either mencoder or ffmpeg. While either choice works on linux, it is best to choose ffmpeg when running on the Mac. If using macports just do: sudo port install ffmpeg. The code to directly generate an mp4 movie of the Qubit decay is as follows:; from pylab import *; import matplotlib.animation as animation; from mpl_toolkits.mplot3d import Axes3D. fig = figure(); ax = Axes3D(fig,azim=-40,elev=30); sphere = Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([np.sin(theta),0,np.cos(theta)]); sphere.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); sphere.make_sphere(); return ax. def init():; sphere.vector_color = ['r']; return ax. ani = animation.FuncAnimation(fig, animate, np.arange(len(sx)),; init_func=init, blit=True, repeat=False); ani.save('bloch_sphere.mp4', fps=20, clear_temp=True). The resul",MatchSource.WIKI,docs/4.0.2/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-bloch.html
https://qutip.org/docs/4.0.2/guide/guide-bloch.html:15934,Usability,clear,clear,15934,".5 # qubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a* basis(2,0) + (1-a)*basis(2,1))/(sqrt(a**2 + (1-a)**2)); tlist = linspace(0,4,250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; b = Bloch(); b.vector_color = ['r']; b.view = [-40,30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp') #saving images to temp directory in current working directory. Generating an animation using ffmpeg (for example) is fairly simple:; ffmpeg -r 20 -b 1800 -i bloch_%01d.png bloch.mp4. Directly Generating an Animation¶. Important; Generating animations directly from Matplotlib requires installing either mencoder or ffmpeg. While either choice works on linux, it is best to choose ffmpeg when running on the Mac. If using macports just do: sudo port install ffmpeg. The code to directly generate an mp4 movie of the Qubit decay is as follows:; from pylab import *; import matplotlib.animation as animation; from mpl_toolkits.mplot3d import Axes3D. fig = figure(); ax = Axes3D(fig,azim=-40,elev=30); sphere = Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([np.sin(theta),0,np.cos(theta)]); sphere.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); sphere.make_sphere(); return ax. def init():; sphere.vector_color = ['r']; return ax. ani = animation.FuncAnimation(fig, animate, np.arange(len(sx)),; init_func=init, blit=True, repeat=False); ani.save('bloch_sphere.mp4', fps=20, clear_temp=True). The resulting movie may be viewed here: Bloch_Decay.mp4. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-bloch.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:6305,Availability,error,error,6305,"(and including) any timeslot \(k\) (including the full evolution \(k=M\)) can the be calculated as. \[X(t_k):=X_k X_{k-1}\cdots X_1 X_0\]; If the objective is state-to-state transfer then \(\newcommand{\ket}[1]{\left|{#1}\right\rangle} X_0=\ket{\psi_0}\) and the target \(\newcommand{\ket}[1]{\left|{#1}\right\rangle} X_{targ}=\ket{\psi_1}\), for gate synthesis \(X_0 = U(0) = \mathbb{1}\) and the target \(X_{targ}=U_{targ}\).; A figure of merit or fidelity is some measure of how close the evolution is to the target, based on the control amplitudes in the timeslots. The typical figure of merit for unitary systems is the normalised overlap of the evolution and the target. \[\newcommand{\tr}[0]{\operatorname{tr}} f_{PSU} = \tfrac{1}{d} \big| \tr \{X_{targ}^{\dagger} X(T)\} \big|\]; where \(d\) is the system dimension. In this figure of merit the absolute value is taken to ignore any differences in global phase, and \(0 \le f \le 1\). Typically the fidelity error (or infidelity) is more useful, in this case defined as \(\varepsilon = 1 - f_{PSU}\). There are many other possible objectives, and hence figures of merit.; As there are now \(N \times M\) variables (the \(u_{jk}\)) and one parameter to minimise \(\varepsilon\), then the problem becomes a finite multi-variable optimisation problem, for which there are many established methods, often referred to as ‘hill-climbing’ methods. The simplest of these to understand is that of steepest ascent (or descent). The gradient of the fidelity with respect to all the variables is calculated (or approximated) and a step is made in the variable space in the direction of steepest ascent (or descent). This method is a first order gradient method. In two dimensions this describes a method of climbing a hill by heading in the direction where the ground rises fastest. This analogy also clearly illustrates one of the main challenges in multi-variable optimisation, which is that all methods have a tendency to get stuck in local maxima. It",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:11948,Availability,down,down,11948,"s (CRAB) algorithm [6,7] comes into play: Since the pulse complexity is usually very low, it is sufficient to transform the optimal control problem to a few parameter search by introducing a physically motivated function basis that builds up the pulse. Compared to the number of time slices needed to accurately simulate quantum dynamics (often equals basis dimension for Gradient based algorithms), this number is lower by orders of magnitude, allowing CRAB to efficiently optimize smooth pulses with realistic experimental constraints. It is important to point out, that CRAB does not make any suggestion on the basis function to be used. The basis must be chosen carefully considered, taking into account a priori knowledge of the system (such as symmetries, magnitudes of scales,...) and solution (e.g. sign, smoothness, bang-bang behavior, singularities, maximum excursion or rate of change,....). By doing so, this algorithm allows for native integration of experimental constraints such as maximum frequencies allowed, maximum amplitude, smooth ramping up and down of the pulse and many more. Moreover initial guesses, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [8] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either not possible to derive the gradient for the cost functional with respect to each time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct i",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:12019,Availability,avail,available,12019,"w parameter search by introducing a physically motivated function basis that builds up the pulse. Compared to the number of time slices needed to accurately simulate quantum dynamics (often equals basis dimension for Gradient based algorithms), this number is lower by orders of magnitude, allowing CRAB to efficiently optimize smooth pulses with realistic experimental constraints. It is important to point out, that CRAB does not make any suggestion on the basis function to be used. The basis must be chosen carefully considered, taking into account a priori knowledge of the system (such as symmetries, magnitudes of scales,...) and solution (e.g. sign, smoothness, bang-bang behavior, singularities, maximum excursion or rate of change,....). By doing so, this algorithm allows for native integration of experimental constraints such as maximum frequencies allowed, maximum amplitude, smooth ramping up and down of the pulse and many more. Moreover initial guesses, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [8] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either not possible to derive the gradient for the cost functional with respect to each time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration t",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:13071,Availability,error,errors,13071,"more. Moreover initial guesses, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [8] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either not possible to derive the gradient for the cost functional with respect to each time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, ...) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks listed above. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [9]. It has since been restructured and extended for flexibility and compatibility within QuTiP. Merging the GRAPE implementations is part of the nea",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:11830,Deployability,integrat,integration,11830,"s (CRAB) algorithm [6,7] comes into play: Since the pulse complexity is usually very low, it is sufficient to transform the optimal control problem to a few parameter search by introducing a physically motivated function basis that builds up the pulse. Compared to the number of time slices needed to accurately simulate quantum dynamics (often equals basis dimension for Gradient based algorithms), this number is lower by orders of magnitude, allowing CRAB to efficiently optimize smooth pulses with realistic experimental constraints. It is important to point out, that CRAB does not make any suggestion on the basis function to be used. The basis must be chosen carefully considered, taking into account a priori knowledge of the system (such as symmetries, magnitudes of scales,...) and solution (e.g. sign, smoothness, bang-bang behavior, singularities, maximum excursion or rate of change,....). By doing so, this algorithm allows for native integration of experimental constraints such as maximum frequencies allowed, maximum amplitude, smooth ramping up and down of the pulse and many more. Moreover initial guesses, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [8] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either not possible to derive the gradient for the cost functional with respect to each time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct i",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:12881,Deployability,integrat,integration,12881,"more. Moreover initial guesses, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [8] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either not possible to derive the gradient for the cost functional with respect to each time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, ...) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks listed above. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [9]. It has since been restructured and extended for flexibility and compatibility within QuTiP. Merging the GRAPE implementations is part of the nea",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:13023,Deployability,integrat,integration,13023,"more. Moreover initial guesses, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [8] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either not possible to derive the gradient for the cost functional with respect to each time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, ...) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks listed above. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [9]. It has since been restructured and extended for flexibility and compatibility within QuTiP. Merging the GRAPE implementations is part of the nea",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:13513,Deployability,integrat,integrated,13513,"time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, ...) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks listed above. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [9]. It has since been restructured and extended for flexibility and compatibility within QuTiP. Merging the GRAPE implementations is part of the near future plans. An implementation of the ‘dressed’ CRAB algorithm is also planned for the near future.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want t",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:14871,Deployability,configurat,configuration,14871,"d extended for flexibility and compatibility within QuTiP. Merging the GRAPE implementations is part of the near future plans. An implementation of the ‘dressed’ CRAB algorithm is also planned for the near future.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface (as in the notebook examples) then skip to the section on ‘Using the pulseoptim functions’.; ![qtrl-code_obj_model](./images/qtrl-code_object_model.png “Qtrl code object model”). The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfig; The OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file.; Optimizer; This acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm.; Dynamics; This is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplect",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:15095,Deployability,configurat,configuration,15095,"uture.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface (as in the notebook examples) then skip to the section on ‘Using the pulseoptim functions’.; ![qtrl-code_obj_model](./images/qtrl-code_object_model.png “Qtrl code object model”). The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfig; The OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file.; Optimizer; This acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm.; Dynamics; This is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators.; PulseGen; There are many subclasses that of pulse generators that generate different types of puls",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:17835,Deployability,configurat,configuration,17835,"lculate and report run statistics.; FidelityComputer; The subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses.; PropagatorComputer; This object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above.; TimeslotComputer; Here the time evolution is computed by calling the methods of the other computer objects.; OptimResult; The result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. A example of this method is given in [pulseoptim QFT](http://nbviewer.ipython.org/github/qutip/qutip-notebooks/blob/master/examples/example-control-pulseoptim-QFT.ipynb). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with ",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:18841,Deployability,update,updated,18841,"r; The subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses.; PropagatorComputer; This object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above.; TimeslotComputer; Here the time evolution is computed by calling the methods of the other computer objects.; OptimResult; The result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. A example of this method is given in [pulseoptim QFT](http://nbviewer.ipython.org/github/qutip/qutip-notebooks/blob/master/examples/example-control-pulseoptim-QFT.ipynb). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:8307,Energy Efficiency,efficient,efficient,8307,"dency to get stuck in local maxima. It is hard to determine whether one has found a global maximum or not - a local peak is likely not to be the highest mountain in the region. In quantum optimal control we can typically define an infidelity that has a lower bound of zero. We can then look to minimise the infidelity (from here on we will only consider optimising for infidelity minima). This means that we can terminate any pulse optimisation when the infidelity reaches zero (to a sufficient precision). This is however only possible for fully controllable systems; otherwise it is hard (if not impossible) to know that the minimum possible infidelity has been achieved. In the hill walking analogy the step size is roughly fixed to a stride, however, in computations the step size must be chosen. Clearly there is a trade-off here between the number of steps (or iterations) required to reach the minima and the possibility that we might step over a minima. In practice it is difficult to determine an efficient and effective step size.; The second order differentials of the infidelity with respect to the variables can be used to approximate the local landscape to a parabola. This way a step (or jump) can be made to where the minima would be if it were parabolic. This typically vastly reduces the number of iterations, and removes the need to guess a step size. The method where all the second differentials are calculated explicitly is called the Newton-Raphson method. However, calculating the second-order differentials (the Hessian matrix) can be computationally expensive, and so there are a class of methods known as quasi-Newton that approximate the Hessian based on successive iterations. The most popular of these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is the L-BFGS-B method in Scipy, which is a wrapper to the implementation described in [3]. This limited memory and bounded ",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:8595,Energy Efficiency,reduce,reduces,8595,"rom here on we will only consider optimising for infidelity minima). This means that we can terminate any pulse optimisation when the infidelity reaches zero (to a sufficient precision). This is however only possible for fully controllable systems; otherwise it is hard (if not impossible) to know that the minimum possible infidelity has been achieved. In the hill walking analogy the step size is roughly fixed to a stride, however, in computations the step size must be chosen. Clearly there is a trade-off here between the number of steps (or iterations) required to reach the minima and the possibility that we might step over a minima. In practice it is difficult to determine an efficient and effective step size.; The second order differentials of the infidelity with respect to the variables can be used to approximate the local landscape to a parabola. This way a step (or jump) can be made to where the minima would be if it were parabolic. This typically vastly reduces the number of iterations, and removes the need to guess a step size. The method where all the second differentials are calculated explicitly is called the Newton-Raphson method. However, calculating the second-order differentials (the Hessian matrix) can be computationally expensive, and so there are a class of methods known as quasi-Newton that approximate the Hessian based on successive iterations. The most popular of these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is the L-BFGS-B method in Scipy, which is a wrapper to the implementation described in [3]. This limited memory and bounded method does not need to store the entire Hessian, which reduces the computer memory required, and allows bounds to be set for variable values, which considering these are field amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be calculated exactly, rather than a",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:9358,Energy Efficiency,reduce,reduces,9358,"ity with respect to the variables can be used to approximate the local landscape to a parabola. This way a step (or jump) can be made to where the minima would be if it were parabolic. This typically vastly reduces the number of iterations, and removes the need to guess a step size. The method where all the second differentials are calculated explicitly is called the Newton-Raphson method. However, calculating the second-order differentials (the Hessian matrix) can be computationally expensive, and so there are a class of methods known as quasi-Newton that approximate the Hessian based on successive iterations. The most popular of these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is the L-BFGS-B method in Scipy, which is a wrapper to the implementation described in [3]. This limited memory and bounded method does not need to store the entire Hessian, which reduces the computer memory required, and allows bounds to be set for variable values, which considering these are field amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be calculated exactly, rather than approximated. For simple fidelity measures such as $f_{PSU}$ this is possible. Firstly the propagator gradient for each timeslot with respect to the control amplitudes is calculated. For closed systems, with unitary dynamics, a method using the eigendecomposition is used, which is efficient as it is also used in the propagator calculation (to exponentiate the combined Hamiltonian). More generally (for example open systems and symplectic dynamics) the Frechet derivative (or augmented matrix) method is used, which is described in [4]. For other optimisation goals it may not be possible to calculate analytic gradients. In these cases it is necessary to approximate the gradients, but this can be very expensive, and can lead to other algorithms out-performing GRA",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:9555,Energy Efficiency,efficient,efficient,9555,". This typically vastly reduces the number of iterations, and removes the need to guess a step size. The method where all the second differentials are calculated explicitly is called the Newton-Raphson method. However, calculating the second-order differentials (the Hessian matrix) can be computationally expensive, and so there are a class of methods known as quasi-Newton that approximate the Hessian based on successive iterations. The most popular of these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is the L-BFGS-B method in Scipy, which is a wrapper to the implementation described in [3]. This limited memory and bounded method does not need to store the entire Hessian, which reduces the computer memory required, and allows bounds to be set for variable values, which considering these are field amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be calculated exactly, rather than approximated. For simple fidelity measures such as $f_{PSU}$ this is possible. Firstly the propagator gradient for each timeslot with respect to the control amplitudes is calculated. For closed systems, with unitary dynamics, a method using the eigendecomposition is used, which is efficient as it is also used in the propagator calculation (to exponentiate the combined Hamiltonian). More generally (for example open systems and symplectic dynamics) the Frechet derivative (or augmented matrix) method is used, which is described in [4]. For other optimisation goals it may not be possible to calculate analytic gradients. In these cases it is necessary to approximate the gradients, but this can be very expensive, and can lead to other algorithms out-performing GRAPE. The CRAB Algorithm¶; It has been shown [5], the dimension of a quantum optimal control problem is a polynomial function of the dimension of the manifold of the time-polynomial re",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:9903,Energy Efficiency,efficient,efficient,9903," a class of methods known as quasi-Newton that approximate the Hessian based on successive iterations. The most popular of these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is the L-BFGS-B method in Scipy, which is a wrapper to the implementation described in [3]. This limited memory and bounded method does not need to store the entire Hessian, which reduces the computer memory required, and allows bounds to be set for variable values, which considering these are field amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be calculated exactly, rather than approximated. For simple fidelity measures such as $f_{PSU}$ this is possible. Firstly the propagator gradient for each timeslot with respect to the control amplitudes is calculated. For closed systems, with unitary dynamics, a method using the eigendecomposition is used, which is efficient as it is also used in the propagator calculation (to exponentiate the combined Hamiltonian). More generally (for example open systems and symplectic dynamics) the Frechet derivative (or augmented matrix) method is used, which is described in [4]. For other optimisation goals it may not be possible to calculate analytic gradients. In these cases it is necessary to approximate the gradients, but this can be very expensive, and can lead to other algorithms out-performing GRAPE. The CRAB Algorithm¶; It has been shown [5], the dimension of a quantum optimal control problem is a polynomial function of the dimension of the manifold of the time-polynomial reachable states, when allowing for a finite control precision and evolution time. You can think of this as the information content of the pulse (as being the only effective input) being very limited e.g. the pulse is compressible to a few bytes without loosing the target.; This is where the Chopped RAndom Basis (CRAB) algorithm [6,7",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:11343,Energy Efficiency,efficient,efficiently,11343," to approximate the gradients, but this can be very expensive, and can lead to other algorithms out-performing GRAPE. The CRAB Algorithm¶; It has been shown [5], the dimension of a quantum optimal control problem is a polynomial function of the dimension of the manifold of the time-polynomial reachable states, when allowing for a finite control precision and evolution time. You can think of this as the information content of the pulse (as being the only effective input) being very limited e.g. the pulse is compressible to a few bytes without loosing the target.; This is where the Chopped RAndom Basis (CRAB) algorithm [6,7] comes into play: Since the pulse complexity is usually very low, it is sufficient to transform the optimal control problem to a few parameter search by introducing a physically motivated function basis that builds up the pulse. Compared to the number of time slices needed to accurately simulate quantum dynamics (often equals basis dimension for Gradient based algorithms), this number is lower by orders of magnitude, allowing CRAB to efficiently optimize smooth pulses with realistic experimental constraints. It is important to point out, that CRAB does not make any suggestion on the basis function to be used. The basis must be chosen carefully considered, taking into account a priori knowledge of the system (such as symmetries, magnitudes of scales,...) and solution (e.g. sign, smoothness, bang-bang behavior, singularities, maximum excursion or rate of change,....). By doing so, this algorithm allows for native integration of experimental constraints such as maximum frequencies allowed, maximum amplitude, smooth ramping up and down of the pulse and many more. Moreover initial guesses, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [8] that",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:18476,Energy Efficiency,efficient,efficient,18476,"r; The subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses.; PropagatorComputer; This object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above.; TimeslotComputer; Here the time evolution is computed by calling the methods of the other computer objects.; OptimResult; The result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. A example of this method is given in [pulseoptim QFT](http://nbviewer.ipython.org/github/qutip/qutip-notebooks/blob/master/examples/example-control-pulseoptim-QFT.ipynb). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:4450,Integrability,depend,dependent,4450,"\psi(t)} = U(t)\ket{\psi_0}\]; where \(\psi_0\) is the state of the system at \(t=0\) and \(U(t)\) is a unitary operator on the Hilbert space containing the states. \(U(t)\) is a solution to the Schrödinger operator equation. \[\tfrac{d}{dt}U = -i H(t)U ,\quad U(0) = \mathbb{1}\]; We can use optimal control algorithms to determine a set of \(u_j\) that will drive our system from \(\newcommand{\ket}[1]{\left|{#1}\right\rangle} \ket{\psi_0}\) to \(\newcommand{\ket}[1]{\left|{#1}\right\rangle} \ket{\psi_1}\), this is state-to-state transfer, or drive the system from some arbitary state to a given state \(\newcommand{\ket}[1]{\left|{#1}\right\rangle} \ket{\psi_1}\), which is state preparation, or effect some unitary transformation \(U_{target}\), called gate synthesis. The latter of these is most important in quantum computation. The GRAPE algorithm¶; The **GR**adient **A**scent **P**ulse **E**ngineering was first proposed in [2]. Solutions to Schrödinger’s equation for a time-dependent Hamiltonian are not generally possible to obtain analytically. Therefore, a piecewise constant approximation to the pulse amplitudes is made. Time allowed for the system to evolve \(T\) is split into \(M\) timeslots (typically these are of equal duration), during which the control amplitude is assumed to remain constant. The combined Hamiltonian can then be approximated as:. \[H(t) \approx H(t_k) = H_0 + \sum_{j=1}^N u_{jk} H_j\quad\]; where \(k\) is a timeslot index, \(j\) is the control index, and \(N\) is the number of controls. Hence \(t_k\) is the evolution time at the start of the timeslot, and \(u_{jk}\) is the amplitude of control \(j\) throughout timeslot \(k\). The time evolution operator, or propagator, within the timeslot can then be calculated as:. \[X_k:=e^{-iH(t_k)\Delta t_k}\]; where \(\Delta t_k\) is the duration of the timeslot. The evolution up to (and including) any timeslot \(k\) (including the full evolution \(k=M\)) can the be calculated as. \[X(t_k):=X_k X_{k-1}\c",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:9222,Integrability,wrap,wrapper,9222,"ach the minima and the possibility that we might step over a minima. In practice it is difficult to determine an efficient and effective step size.; The second order differentials of the infidelity with respect to the variables can be used to approximate the local landscape to a parabola. This way a step (or jump) can be made to where the minima would be if it were parabolic. This typically vastly reduces the number of iterations, and removes the need to guess a step size. The method where all the second differentials are calculated explicitly is called the Newton-Raphson method. However, calculating the second-order differentials (the Hessian matrix) can be computationally expensive, and so there are a class of methods known as quasi-Newton that approximate the Hessian based on successive iterations. The most popular of these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is the L-BFGS-B method in Scipy, which is a wrapper to the implementation described in [3]. This limited memory and bounded method does not need to store the entire Hessian, which reduces the computer memory required, and allows bounds to be set for variable values, which considering these are field amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be calculated exactly, rather than approximated. For simple fidelity measures such as $f_{PSU}$ this is possible. Firstly the propagator gradient for each timeslot with respect to the control amplitudes is calculated. For closed systems, with unitary dynamics, a method using the eigendecomposition is used, which is efficient as it is also used in the propagator calculation (to exponentiate the combined Hamiltonian). More generally (for example open systems and symplectic dynamics) the Frechet derivative (or augmented matrix) method is used, which is described in [4]. For other optimisation goals it ma",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:11830,Integrability,integrat,integration,11830,"s (CRAB) algorithm [6,7] comes into play: Since the pulse complexity is usually very low, it is sufficient to transform the optimal control problem to a few parameter search by introducing a physically motivated function basis that builds up the pulse. Compared to the number of time slices needed to accurately simulate quantum dynamics (often equals basis dimension for Gradient based algorithms), this number is lower by orders of magnitude, allowing CRAB to efficiently optimize smooth pulses with realistic experimental constraints. It is important to point out, that CRAB does not make any suggestion on the basis function to be used. The basis must be chosen carefully considered, taking into account a priori knowledge of the system (such as symmetries, magnitudes of scales,...) and solution (e.g. sign, smoothness, bang-bang behavior, singularities, maximum excursion or rate of change,....). By doing so, this algorithm allows for native integration of experimental constraints such as maximum frequencies allowed, maximum amplitude, smooth ramping up and down of the pulse and many more. Moreover initial guesses, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [8] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either not possible to derive the gradient for the cost functional with respect to each time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct i",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:12881,Integrability,integrat,integration,12881,"more. Moreover initial guesses, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [8] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either not possible to derive the gradient for the cost functional with respect to each time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, ...) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks listed above. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [9]. It has since been restructured and extended for flexibility and compatibility within QuTiP. Merging the GRAPE implementations is part of the nea",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:13023,Integrability,integrat,integration,13023,"more. Moreover initial guesses, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [8] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either not possible to derive the gradient for the cost functional with respect to each time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, ...) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks listed above. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [9]. It has since been restructured and extended for flexibility and compatibility within QuTiP. Merging the GRAPE implementations is part of the nea",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:13513,Integrability,integrat,integrated,13513,"time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, ...) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks listed above. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [9]. It has since been restructured and extended for flexibility and compatibility within QuTiP. Merging the GRAPE implementations is part of the near future plans. An implementation of the ‘dressed’ CRAB algorithm is also planned for the near future.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want t",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:14506,Integrability,interface,interface,14506,"QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [9]. It has since been restructured and extended for flexibility and compatibility within QuTiP. Merging the GRAPE implementations is part of the near future plans. An implementation of the ‘dressed’ CRAB algorithm is also planned for the near future.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface (as in the notebook examples) then skip to the section on ‘Using the pulseoptim functions’.; ![qtrl-code_obj_model](./images/qtrl-code_object_model.png “Qtrl code object model”). The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfig; The OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file.; Optimizer; This acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm.; Dynamics; This is mainly a container for the lists that hold the dy",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:15142,Integrability,wrap,wrapper,15142," and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface (as in the notebook examples) then skip to the section on ‘Using the pulseoptim functions’.; ![qtrl-code_obj_model](./images/qtrl-code_object_model.png “Qtrl code object model”). The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfig; The OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file.; Optimizer; This acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm.; Dynamics; This is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators.; PulseGen; There are many subclasses that of pulse generators that generate different types of pulses as the initial amplitudes for the optimisation. Often the goal ",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:4633,Modifiability,evolve,evolve,4633,"tfrac{d}{dt}U = -i H(t)U ,\quad U(0) = \mathbb{1}\]; We can use optimal control algorithms to determine a set of \(u_j\) that will drive our system from \(\newcommand{\ket}[1]{\left|{#1}\right\rangle} \ket{\psi_0}\) to \(\newcommand{\ket}[1]{\left|{#1}\right\rangle} \ket{\psi_1}\), this is state-to-state transfer, or drive the system from some arbitary state to a given state \(\newcommand{\ket}[1]{\left|{#1}\right\rangle} \ket{\psi_1}\), which is state preparation, or effect some unitary transformation \(U_{target}\), called gate synthesis. The latter of these is most important in quantum computation. The GRAPE algorithm¶; The **GR**adient **A**scent **P**ulse **E**ngineering was first proposed in [2]. Solutions to Schrödinger’s equation for a time-dependent Hamiltonian are not generally possible to obtain analytically. Therefore, a piecewise constant approximation to the pulse amplitudes is made. Time allowed for the system to evolve \(T\) is split into \(M\) timeslots (typically these are of equal duration), during which the control amplitude is assumed to remain constant. The combined Hamiltonian can then be approximated as:. \[H(t) \approx H(t_k) = H_0 + \sum_{j=1}^N u_{jk} H_j\quad\]; where \(k\) is a timeslot index, \(j\) is the control index, and \(N\) is the number of controls. Hence \(t_k\) is the evolution time at the start of the timeslot, and \(u_{jk}\) is the amplitude of control \(j\) throughout timeslot \(k\). The time evolution operator, or propagator, within the timeslot can then be calculated as:. \[X_k:=e^{-iH(t_k)\Delta t_k}\]; where \(\Delta t_k\) is the duration of the timeslot. The evolution up to (and including) any timeslot \(k\) (including the full evolution \(k=M\)) can the be calculated as. \[X(t_k):=X_k X_{k-1}\cdots X_1 X_0\]; If the objective is state-to-state transfer then \(\newcommand{\ket}[1]{\left|{#1}\right\rangle} X_0=\ket{\psi_0}\) and the target \(\newcommand{\ket}[1]{\left|{#1}\right\rangle} X_{targ}=\ket{\psi_1}\), for gate s",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:6501,Modifiability,variab,variables,6501,"target \(\newcommand{\ket}[1]{\left|{#1}\right\rangle} X_{targ}=\ket{\psi_1}\), for gate synthesis \(X_0 = U(0) = \mathbb{1}\) and the target \(X_{targ}=U_{targ}\).; A figure of merit or fidelity is some measure of how close the evolution is to the target, based on the control amplitudes in the timeslots. The typical figure of merit for unitary systems is the normalised overlap of the evolution and the target. \[\newcommand{\tr}[0]{\operatorname{tr}} f_{PSU} = \tfrac{1}{d} \big| \tr \{X_{targ}^{\dagger} X(T)\} \big|\]; where \(d\) is the system dimension. In this figure of merit the absolute value is taken to ignore any differences in global phase, and \(0 \le f \le 1\). Typically the fidelity error (or infidelity) is more useful, in this case defined as \(\varepsilon = 1 - f_{PSU}\). There are many other possible objectives, and hence figures of merit.; As there are now \(N \times M\) variables (the \(u_{jk}\)) and one parameter to minimise \(\varepsilon\), then the problem becomes a finite multi-variable optimisation problem, for which there are many established methods, often referred to as ‘hill-climbing’ methods. The simplest of these to understand is that of steepest ascent (or descent). The gradient of the fidelity with respect to all the variables is calculated (or approximated) and a step is made in the variable space in the direction of steepest ascent (or descent). This method is a first order gradient method. In two dimensions this describes a method of climbing a hill by heading in the direction where the ground rises fastest. This analogy also clearly illustrates one of the main challenges in multi-variable optimisation, which is that all methods have a tendency to get stuck in local maxima. It is hard to determine whether one has found a global maximum or not - a local peak is likely not to be the highest mountain in the region. In quantum optimal control we can typically define an infidelity that has a lower bound of zero. We can then look to minimis",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:6615,Modifiability,variab,variable,6615,"target \(\newcommand{\ket}[1]{\left|{#1}\right\rangle} X_{targ}=\ket{\psi_1}\), for gate synthesis \(X_0 = U(0) = \mathbb{1}\) and the target \(X_{targ}=U_{targ}\).; A figure of merit or fidelity is some measure of how close the evolution is to the target, based on the control amplitudes in the timeslots. The typical figure of merit for unitary systems is the normalised overlap of the evolution and the target. \[\newcommand{\tr}[0]{\operatorname{tr}} f_{PSU} = \tfrac{1}{d} \big| \tr \{X_{targ}^{\dagger} X(T)\} \big|\]; where \(d\) is the system dimension. In this figure of merit the absolute value is taken to ignore any differences in global phase, and \(0 \le f \le 1\). Typically the fidelity error (or infidelity) is more useful, in this case defined as \(\varepsilon = 1 - f_{PSU}\). There are many other possible objectives, and hence figures of merit.; As there are now \(N \times M\) variables (the \(u_{jk}\)) and one parameter to minimise \(\varepsilon\), then the problem becomes a finite multi-variable optimisation problem, for which there are many established methods, often referred to as ‘hill-climbing’ methods. The simplest of these to understand is that of steepest ascent (or descent). The gradient of the fidelity with respect to all the variables is calculated (or approximated) and a step is made in the variable space in the direction of steepest ascent (or descent). This method is a first order gradient method. In two dimensions this describes a method of climbing a hill by heading in the direction where the ground rises fastest. This analogy also clearly illustrates one of the main challenges in multi-variable optimisation, which is that all methods have a tendency to get stuck in local maxima. It is hard to determine whether one has found a global maximum or not - a local peak is likely not to be the highest mountain in the region. In quantum optimal control we can typically define an infidelity that has a lower bound of zero. We can then look to minimis",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:6868,Modifiability,variab,variables,6868,". The typical figure of merit for unitary systems is the normalised overlap of the evolution and the target. \[\newcommand{\tr}[0]{\operatorname{tr}} f_{PSU} = \tfrac{1}{d} \big| \tr \{X_{targ}^{\dagger} X(T)\} \big|\]; where \(d\) is the system dimension. In this figure of merit the absolute value is taken to ignore any differences in global phase, and \(0 \le f \le 1\). Typically the fidelity error (or infidelity) is more useful, in this case defined as \(\varepsilon = 1 - f_{PSU}\). There are many other possible objectives, and hence figures of merit.; As there are now \(N \times M\) variables (the \(u_{jk}\)) and one parameter to minimise \(\varepsilon\), then the problem becomes a finite multi-variable optimisation problem, for which there are many established methods, often referred to as ‘hill-climbing’ methods. The simplest of these to understand is that of steepest ascent (or descent). The gradient of the fidelity with respect to all the variables is calculated (or approximated) and a step is made in the variable space in the direction of steepest ascent (or descent). This method is a first order gradient method. In two dimensions this describes a method of climbing a hill by heading in the direction where the ground rises fastest. This analogy also clearly illustrates one of the main challenges in multi-variable optimisation, which is that all methods have a tendency to get stuck in local maxima. It is hard to determine whether one has found a global maximum or not - a local peak is likely not to be the highest mountain in the region. In quantum optimal control we can typically define an infidelity that has a lower bound of zero. We can then look to minimise the infidelity (from here on we will only consider optimising for infidelity minima). This means that we can terminate any pulse optimisation when the infidelity reaches zero (to a sufficient precision). This is however only possible for fully controllable systems; otherwise it is hard (if not impossib",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:6936,Modifiability,variab,variable,6936,". The typical figure of merit for unitary systems is the normalised overlap of the evolution and the target. \[\newcommand{\tr}[0]{\operatorname{tr}} f_{PSU} = \tfrac{1}{d} \big| \tr \{X_{targ}^{\dagger} X(T)\} \big|\]; where \(d\) is the system dimension. In this figure of merit the absolute value is taken to ignore any differences in global phase, and \(0 \le f \le 1\). Typically the fidelity error (or infidelity) is more useful, in this case defined as \(\varepsilon = 1 - f_{PSU}\). There are many other possible objectives, and hence figures of merit.; As there are now \(N \times M\) variables (the \(u_{jk}\)) and one parameter to minimise \(\varepsilon\), then the problem becomes a finite multi-variable optimisation problem, for which there are many established methods, often referred to as ‘hill-climbing’ methods. The simplest of these to understand is that of steepest ascent (or descent). The gradient of the fidelity with respect to all the variables is calculated (or approximated) and a step is made in the variable space in the direction of steepest ascent (or descent). This method is a first order gradient method. In two dimensions this describes a method of climbing a hill by heading in the direction where the ground rises fastest. This analogy also clearly illustrates one of the main challenges in multi-variable optimisation, which is that all methods have a tendency to get stuck in local maxima. It is hard to determine whether one has found a global maximum or not - a local peak is likely not to be the highest mountain in the region. In quantum optimal control we can typically define an infidelity that has a lower bound of zero. We can then look to minimise the infidelity (from here on we will only consider optimising for infidelity minima). This means that we can terminate any pulse optimisation when the infidelity reaches zero (to a sufficient precision). This is however only possible for fully controllable systems; otherwise it is hard (if not impossib",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:7242,Modifiability,variab,variable,7242," phase, and \(0 \le f \le 1\). Typically the fidelity error (or infidelity) is more useful, in this case defined as \(\varepsilon = 1 - f_{PSU}\). There are many other possible objectives, and hence figures of merit.; As there are now \(N \times M\) variables (the \(u_{jk}\)) and one parameter to minimise \(\varepsilon\), then the problem becomes a finite multi-variable optimisation problem, for which there are many established methods, often referred to as ‘hill-climbing’ methods. The simplest of these to understand is that of steepest ascent (or descent). The gradient of the fidelity with respect to all the variables is calculated (or approximated) and a step is made in the variable space in the direction of steepest ascent (or descent). This method is a first order gradient method. In two dimensions this describes a method of climbing a hill by heading in the direction where the ground rises fastest. This analogy also clearly illustrates one of the main challenges in multi-variable optimisation, which is that all methods have a tendency to get stuck in local maxima. It is hard to determine whether one has found a global maximum or not - a local peak is likely not to be the highest mountain in the region. In quantum optimal control we can typically define an infidelity that has a lower bound of zero. We can then look to minimise the infidelity (from here on we will only consider optimising for infidelity minima). This means that we can terminate any pulse optimisation when the infidelity reaches zero (to a sufficient precision). This is however only possible for fully controllable systems; otherwise it is hard (if not impossible) to know that the minimum possible infidelity has been achieved. In the hill walking analogy the step size is roughly fixed to a stride, however, in computations the step size must be chosen. Clearly there is a trade-off here between the number of steps (or iterations) required to reach the minima and the possibility that we might step over",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:8412,Modifiability,variab,variables,8412,"ocal peak is likely not to be the highest mountain in the region. In quantum optimal control we can typically define an infidelity that has a lower bound of zero. We can then look to minimise the infidelity (from here on we will only consider optimising for infidelity minima). This means that we can terminate any pulse optimisation when the infidelity reaches zero (to a sufficient precision). This is however only possible for fully controllable systems; otherwise it is hard (if not impossible) to know that the minimum possible infidelity has been achieved. In the hill walking analogy the step size is roughly fixed to a stride, however, in computations the step size must be chosen. Clearly there is a trade-off here between the number of steps (or iterations) required to reach the minima and the possibility that we might step over a minima. In practice it is difficult to determine an efficient and effective step size.; The second order differentials of the infidelity with respect to the variables can be used to approximate the local landscape to a parabola. This way a step (or jump) can be made to where the minima would be if it were parabolic. This typically vastly reduces the number of iterations, and removes the need to guess a step size. The method where all the second differentials are calculated explicitly is called the Newton-Raphson method. However, calculating the second-order differentials (the Hessian matrix) can be computationally expensive, and so there are a class of methods known as quasi-Newton that approximate the Hessian based on successive iterations. The most popular of these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is the L-BFGS-B method in Scipy, which is a wrapper to the implementation described in [3]. This limited memory and bounded method does not need to store the entire Hessian, which reduces the computer memory required, and allows bound",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:9428,Modifiability,variab,variable,9428,"ity with respect to the variables can be used to approximate the local landscape to a parabola. This way a step (or jump) can be made to where the minima would be if it were parabolic. This typically vastly reduces the number of iterations, and removes the need to guess a step size. The method where all the second differentials are calculated explicitly is called the Newton-Raphson method. However, calculating the second-order differentials (the Hessian matrix) can be computationally expensive, and so there are a class of methods known as quasi-Newton that approximate the Hessian based on successive iterations. The most popular of these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is the L-BFGS-B method in Scipy, which is a wrapper to the implementation described in [3]. This limited memory and bounded method does not need to store the entire Hessian, which reduces the computer memory required, and allows bounds to be set for variable values, which considering these are field amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be calculated exactly, rather than approximated. For simple fidelity measures such as $f_{PSU}$ this is possible. Firstly the propagator gradient for each timeslot with respect to the control amplitudes is calculated. For closed systems, with unitary dynamics, a method using the eigendecomposition is used, which is efficient as it is also used in the propagator calculation (to exponentiate the combined Hamiltonian). More generally (for example open systems and symplectic dynamics) the Frechet derivative (or augmented matrix) method is used, which is described in [4]. For other optimisation goals it may not be possible to calculate analytic gradients. In these cases it is necessary to approximate the gradients, but this can be very expensive, and can lead to other algorithms out-performing GRA",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:13596,Modifiability,variab,variable,13596,"s trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, ...) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks listed above. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [9]. It has since been restructured and extended for flexibility and compatibility within QuTiP. Merging the GRAPE implementations is part of the near future plans. An implementation of the ‘dressed’ CRAB algorithm is also planned for the near future.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface (as in the notebook examples) then skip to the section on ‘Using the pulseoptim functions’.; !",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:13867,Modifiability,extend,extended,13867,"ect integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, ...) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks listed above. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [9]. It has since been restructured and extended for flexibility and compatibility within QuTiP. Merging the GRAPE implementations is part of the near future plans. An implementation of the ‘dressed’ CRAB algorithm is also planned for the near future.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface (as in the notebook examples) then skip to the section on ‘Using the pulseoptim functions’.; ![qtrl-code_obj_model](./images/qtrl-code_object_model.png “Qtrl code object model”). The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfig; The OptimConfig object is used simply to hold config",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:14259,Modifiability,config,configurability,14259,"ns of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks listed above. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [9]. It has since been restructured and extended for flexibility and compatibility within QuTiP. Merging the GRAPE implementations is part of the near future plans. An implementation of the ‘dressed’ CRAB algorithm is also planned for the near future.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface (as in the notebook examples) then skip to the section on ‘Using the pulseoptim functions’.; ![qtrl-code_obj_model](./images/qtrl-code_object_model.png “Qtrl code object model”). The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfig; The OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file.; Optimizer; This acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation al",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:14421,Modifiability,flexible,flexible,14421,"le notebooks listed above. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [9]. It has since been restructured and extended for flexibility and compatibility within QuTiP. Merging the GRAPE implementations is part of the near future plans. An implementation of the ‘dressed’ CRAB algorithm is also planned for the near future.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface (as in the notebook examples) then skip to the section on ‘Using the pulseoptim functions’.; ![qtrl-code_obj_model](./images/qtrl-code_object_model.png “Qtrl code object model”). The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfig; The OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file.; Optimizer; This acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the B",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:14871,Modifiability,config,configuration,14871,"d extended for flexibility and compatibility within QuTiP. Merging the GRAPE implementations is part of the near future plans. An implementation of the ‘dressed’ CRAB algorithm is also planned for the near future.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface (as in the notebook examples) then skip to the section on ‘Using the pulseoptim functions’.; ![qtrl-code_obj_model](./images/qtrl-code_object_model.png “Qtrl code object model”). The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfig; The OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file.; Optimizer; This acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm.; Dynamics; This is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplect",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:15095,Modifiability,config,configuration,15095,"uture.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface (as in the notebook examples) then skip to the section on ‘Using the pulseoptim functions’.; ![qtrl-code_obj_model](./images/qtrl-code_object_model.png “Qtrl code object model”). The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfig; The OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file.; Optimizer; This acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm.; Dynamics; This is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators.; PulseGen; There are many subclasses that of pulse generators that generate different types of puls",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:17835,Modifiability,config,configuration,17835,"lculate and report run statistics.; FidelityComputer; The subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses.; PropagatorComputer; This object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above.; TimeslotComputer; Here the time evolution is computed by calling the methods of the other computer objects.; OptimResult; The result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. A example of this method is given in [pulseoptim QFT](http://nbviewer.ipython.org/github/qutip/qutip-notebooks/blob/master/examples/example-control-pulseoptim-QFT.ipynb). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with ",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:18367,Modifiability,config,configure,18367,"r; The subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses.; PropagatorComputer; This object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above.; TimeslotComputer; Here the time evolution is computed by calling the methods of the other computer objects.; OptimResult; The result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. A example of this method is given in [pulseoptim QFT](http://nbviewer.ipython.org/github/qutip/qutip-notebooks/blob/master/examples/example-control-pulseoptim-QFT.ipynb). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:10375,Performance,perform,performing,10375,"need to store the entire Hessian, which reduces the computer memory required, and allows bounds to be set for variable values, which considering these are field amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be calculated exactly, rather than approximated. For simple fidelity measures such as $f_{PSU}$ this is possible. Firstly the propagator gradient for each timeslot with respect to the control amplitudes is calculated. For closed systems, with unitary dynamics, a method using the eigendecomposition is used, which is efficient as it is also used in the propagator calculation (to exponentiate the combined Hamiltonian). More generally (for example open systems and symplectic dynamics) the Frechet derivative (or augmented matrix) method is used, which is described in [4]. For other optimisation goals it may not be possible to calculate analytic gradients. In these cases it is necessary to approximate the gradients, but this can be very expensive, and can lead to other algorithms out-performing GRAPE. The CRAB Algorithm¶; It has been shown [5], the dimension of a quantum optimal control problem is a polynomial function of the dimension of the manifold of the time-polynomial reachable states, when allowing for a finite control precision and evolution time. You can think of this as the information content of the pulse (as being the only effective input) being very limited e.g. the pulse is compressible to a few bytes without loosing the target.; This is where the Chopped RAndom Basis (CRAB) algorithm [6,7] comes into play: Since the pulse complexity is usually very low, it is sufficient to transform the optimal control problem to a few parameter search by introducing a physically motivated function basis that builds up the pulse. Compared to the number of time slices needed to accurately simulate quantum dynamics (often equals basis dimension for Gradient based algorithms), this number is lower by orders of mag",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:11355,Performance,optimiz,optimize,11355," to approximate the gradients, but this can be very expensive, and can lead to other algorithms out-performing GRAPE. The CRAB Algorithm¶; It has been shown [5], the dimension of a quantum optimal control problem is a polynomial function of the dimension of the manifold of the time-polynomial reachable states, when allowing for a finite control precision and evolution time. You can think of this as the information content of the pulse (as being the only effective input) being very limited e.g. the pulse is compressible to a few bytes without loosing the target.; This is where the Chopped RAndom Basis (CRAB) algorithm [6,7] comes into play: Since the pulse complexity is usually very low, it is sufficient to transform the optimal control problem to a few parameter search by introducing a physically motivated function basis that builds up the pulse. Compared to the number of time slices needed to accurately simulate quantum dynamics (often equals basis dimension for Gradient based algorithms), this number is lower by orders of magnitude, allowing CRAB to efficiently optimize smooth pulses with realistic experimental constraints. It is important to point out, that CRAB does not make any suggestion on the basis function to be used. The basis must be chosen carefully considered, taking into account a priori knowledge of the system (such as symmetries, magnitudes of scales,...) and solution (e.g. sign, smoothness, bang-bang behavior, singularities, maximum excursion or rate of change,....). By doing so, this algorithm allows for native integration of experimental constraints such as maximum frequencies allowed, maximum amplitude, smooth ramping up and down of the pulse and many more. Moreover initial guesses, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [8] that",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:12974,Performance,optimiz,optimization,12974,"more. Moreover initial guesses, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [8] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either not possible to derive the gradient for the cost functional with respect to each time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, ...) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks listed above. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [9]. It has since been restructured and extended for flexibility and compatibility within QuTiP. Merging the GRAPE implementations is part of the nea",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:13556,Performance,optimiz,optimize,13556,"s trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, ...) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks listed above. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [9]. It has since been restructured and extended for flexibility and compatibility within QuTiP. Merging the GRAPE implementations is part of the near future plans. An implementation of the ‘dressed’ CRAB algorithm is also planned for the near future.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface (as in the notebook examples) then skip to the section on ‘Using the pulseoptim functions’.; !",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:13578,Performance,perform,perform,13578,"s trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, ...) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks listed above. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [9]. It has since been restructured and extended for flexibility and compatibility within QuTiP. Merging the GRAPE implementations is part of the near future plans. An implementation of the ‘dressed’ CRAB algorithm is also planned for the near future.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface (as in the notebook examples) then skip to the section on ‘Using the pulseoptim functions’.; !",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:15036,Performance,load,loadparams,15036,"uture.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface (as in the notebook examples) then skip to the section on ‘Using the pulseoptim functions’.; ![qtrl-code_obj_model](./images/qtrl-code_object_model.png “Qtrl code object model”). The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfig; The OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file.; Optimizer; This acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm.; Dynamics; This is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators.; PulseGen; There are many subclasses that of pulse generators that generate different types of puls",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:15163,Performance,optimiz,optimize,15163,"a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface (as in the notebook examples) then skip to the section on ‘Using the pulseoptim functions’.; ![qtrl-code_obj_model](./images/qtrl-code_object_model.png “Qtrl code object model”). The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfig; The OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file.; Optimizer; This acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm.; Dynamics; This is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators.; PulseGen; There are many subclasses that of pulse generators that generate different types of pulses as the initial amplitudes for the optimisation. Often the goal cannot be achieved from all starting conditions, and then typic",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:15187,Performance,perform,perform,15187,"a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface (as in the notebook examples) then skip to the section on ‘Using the pulseoptim functions’.; ![qtrl-code_obj_model](./images/qtrl-code_object_model.png “Qtrl code object model”). The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfig; The OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file.; Optimizer; This acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm.; Dynamics; This is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators.; PulseGen; There are many subclasses that of pulse generators that generate different types of pulses as the initial amplitudes for the optimisation. Often the goal cannot be achieved from all starting conditions, and then typic",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:16272,Performance,perform,performed,16272,"ing the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm.; Dynamics; This is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators.; PulseGen; There are many subclasses that of pulse generators that generate different types of pulses as the initial amplitudes for the optimisation. Often the goal cannot be achieved from all starting conditions, and then typically some kind of random pulse is used and repeated optimisations are performed until the desired infidelity is reached or the minimum infidelity found is reported. There is a specific subclass that is used by the CRAB algorithm to generate the pulses based on the basis coefficients that are being optimised. TerminationConditions; This is simply a convenient place to hold all the properties that will determine when the single optimisation run terminates. Limits can be set for number of iterations, time, and of course the target infidelity.; Stats; Performance data are optionally collected during the optimisation. This object is shared to a single location to store, calculate and report run statistics.; FidelityComputer; The subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses.; PropagatorComputer; This object computes propagators from one timeslot to the next and also the propagator gradient",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:17610,Performance,perform,performance,17610,"onvenient place to hold all the properties that will determine when the single optimisation run terminates. Limits can be set for number of iterations, time, and of course the target infidelity.; Stats; Performance data are optionally collected during the optimisation. This object is shared to a single location to store, calculate and report run statistics.; FidelityComputer; The subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses.; PropagatorComputer; This object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above.; TimeslotComputer; Here the time evolution is computed by calling the methods of the other computer objects.; OptimResult; The result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. A example of",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:6742,Usability,simpl,simplest,6742,"e of merit or fidelity is some measure of how close the evolution is to the target, based on the control amplitudes in the timeslots. The typical figure of merit for unitary systems is the normalised overlap of the evolution and the target. \[\newcommand{\tr}[0]{\operatorname{tr}} f_{PSU} = \tfrac{1}{d} \big| \tr \{X_{targ}^{\dagger} X(T)\} \big|\]; where \(d\) is the system dimension. In this figure of merit the absolute value is taken to ignore any differences in global phase, and \(0 \le f \le 1\). Typically the fidelity error (or infidelity) is more useful, in this case defined as \(\varepsilon = 1 - f_{PSU}\). There are many other possible objectives, and hence figures of merit.; As there are now \(N \times M\) variables (the \(u_{jk}\)) and one parameter to minimise \(\varepsilon\), then the problem becomes a finite multi-variable optimisation problem, for which there are many established methods, often referred to as ‘hill-climbing’ methods. The simplest of these to understand is that of steepest ascent (or descent). The gradient of the fidelity with respect to all the variables is calculated (or approximated) and a step is made in the variable space in the direction of steepest ascent (or descent). This method is a first order gradient method. In two dimensions this describes a method of climbing a hill by heading in the direction where the ground rises fastest. This analogy also clearly illustrates one of the main challenges in multi-variable optimisation, which is that all methods have a tendency to get stuck in local maxima. It is hard to determine whether one has found a global maximum or not - a local peak is likely not to be the highest mountain in the region. In quantum optimal control we can typically define an infidelity that has a lower bound of zero. We can then look to minimise the infidelity (from here on we will only consider optimising for infidelity minima). This means that we can terminate any pulse optimisation when the infidelity reaches ze",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:7186,Usability,clear,clearly,7186," phase, and \(0 \le f \le 1\). Typically the fidelity error (or infidelity) is more useful, in this case defined as \(\varepsilon = 1 - f_{PSU}\). There are many other possible objectives, and hence figures of merit.; As there are now \(N \times M\) variables (the \(u_{jk}\)) and one parameter to minimise \(\varepsilon\), then the problem becomes a finite multi-variable optimisation problem, for which there are many established methods, often referred to as ‘hill-climbing’ methods. The simplest of these to understand is that of steepest ascent (or descent). The gradient of the fidelity with respect to all the variables is calculated (or approximated) and a step is made in the variable space in the direction of steepest ascent (or descent). This method is a first order gradient method. In two dimensions this describes a method of climbing a hill by heading in the direction where the ground rises fastest. This analogy also clearly illustrates one of the main challenges in multi-variable optimisation, which is that all methods have a tendency to get stuck in local maxima. It is hard to determine whether one has found a global maximum or not - a local peak is likely not to be the highest mountain in the region. In quantum optimal control we can typically define an infidelity that has a lower bound of zero. We can then look to minimise the infidelity (from here on we will only consider optimising for infidelity minima). This means that we can terminate any pulse optimisation when the infidelity reaches zero (to a sufficient precision). This is however only possible for fully controllable systems; otherwise it is hard (if not impossible) to know that the minimum possible infidelity has been achieved. In the hill walking analogy the step size is roughly fixed to a stride, however, in computations the step size must be chosen. Clearly there is a trade-off here between the number of steps (or iterations) required to reach the minima and the possibility that we might step over",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:9639,Usability,simpl,simple,9639,"size. The method where all the second differentials are calculated explicitly is called the Newton-Raphson method. However, calculating the second-order differentials (the Hessian matrix) can be computationally expensive, and so there are a class of methods known as quasi-Newton that approximate the Hessian based on successive iterations. The most popular of these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is the L-BFGS-B method in Scipy, which is a wrapper to the implementation described in [3]. This limited memory and bounded method does not need to store the entire Hessian, which reduces the computer memory required, and allows bounds to be set for variable values, which considering these are field amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be calculated exactly, rather than approximated. For simple fidelity measures such as $f_{PSU}$ this is possible. Firstly the propagator gradient for each timeslot with respect to the control amplitudes is calculated. For closed systems, with unitary dynamics, a method using the eigendecomposition is used, which is efficient as it is also used in the propagator calculation (to exponentiate the combined Hamiltonian). More generally (for example open systems and symplectic dynamics) the Frechet derivative (or augmented matrix) method is used, which is described in [4]. For other optimisation goals it may not be possible to calculate analytic gradients. In these cases it is necessary to approximate the gradients, but this can be very expensive, and can lead to other algorithms out-performing GRAPE. The CRAB Algorithm¶; It has been shown [5], the dimension of a quantum optimal control problem is a polynomial function of the dimension of the manifold of the time-polynomial reachable states, when allowing for a finite control precision and evolution time. You can think o",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:14478,Usability,simpl,simple,14478,"QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [9]. It has since been restructured and extended for flexibility and compatibility within QuTiP. Merging the GRAPE implementations is part of the near future plans. An implementation of the ‘dressed’ CRAB algorithm is also planned for the near future.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface (as in the notebook examples) then skip to the section on ‘Using the pulseoptim functions’.; ![qtrl-code_obj_model](./images/qtrl-code_object_model.png “Qtrl code object model”). The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfig; The OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file.; Optimizer; This acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm.; Dynamics; This is mainly a container for the lists that hold the dy",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:14856,Usability,simpl,simply,14856,"d extended for flexibility and compatibility within QuTiP. Merging the GRAPE implementations is part of the near future plans. An implementation of the ‘dressed’ CRAB algorithm is also planned for the near future.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface (as in the notebook examples) then skip to the section on ‘Using the pulseoptim functions’.; ![qtrl-code_obj_model](./images/qtrl-code_object_model.png “Qtrl code object model”). The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfig; The OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file.; Optimizer; This acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm.; Dynamics; This is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplect",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:16543,Usability,simpl,simply,16543,"tors in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators.; PulseGen; There are many subclasses that of pulse generators that generate different types of pulses as the initial amplitudes for the optimisation. Often the goal cannot be achieved from all starting conditions, and then typically some kind of random pulse is used and repeated optimisations are performed until the desired infidelity is reached or the minimum infidelity found is reported. There is a specific subclass that is used by the CRAB algorithm to generate the pulses based on the basis coefficients that are being optimised. TerminationConditions; This is simply a convenient place to hold all the properties that will determine when the single optimisation run terminates. Limits can be set for number of iterations, time, and of course the target infidelity.; Stats; Performance data are optionally collected during the optimisation. This object is shared to a single location to store, calculate and report run statistics.; FidelityComputer; The subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses.; PropagatorComputer; This object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above.; TimeslotComputer; Here the time evolution is computed by calling the methods of the other computer objects.; OptimResult; The result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, ",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:17698,Usability,simpl,simplest,17698,"rget infidelity.; Stats; Performance data are optionally collected during the optimisation. This object is shared to a single location to store, calculate and report run statistics.; FidelityComputer; The subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses.; PropagatorComputer; This object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above.; TimeslotComputer; Here the time evolution is computed by calling the methods of the other computer objects.; OptimResult; The result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. A example of this method is given in [pulseoptim QFT](http://nbviewer.ipython.org/github/qutip/qutip-notebooks/blob/master/examples/example-control-pulseoptim-QFT.ipynb). Next ; Previous. ©",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-control.html:18206,Usability,simpl,simply,18206,"r; The subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses.; PropagatorComputer; This object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above.; TimeslotComputer; Here the time evolution is computed by calling the methods of the other computer objects.; OptimResult; The result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. A example of this method is given in [pulseoptim QFT](http://nbviewer.ipython.org/github/qutip/qutip-notebooks/blob/master/examples/example-control-pulseoptim-QFT.ipynb). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html
https://qutip.org/docs/4.0.2/guide/guide-correlation.html:2610,Availability,avail,available,2610,"ite. \[\left<A(t+\tau)B(t)\right> = {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho(t)\right\}\right]; = {\rm Tr}\left[A V(t+\tau, t)\left\{BV(t, 0)\left\{\rho(0)\right\}\right\}\right]\]; We therefore first calculate \(\rho(t)=V(t, 0)\left\{\rho(0)\right\}\) using one of the QuTiP evolution solvers with \(\rho(0)\) as initial state, and then again use the same solver to calculate \(V(t+\tau, t)\left\{B\rho(t)\right\}\) using \(B\rho(t)\) as initial state.; Note that if the initial state is the steady state, then \(\rho(t)=V(t, 0)\left\{\rho_{\rm ss}\right\}=\rho_{\rm ss}\) and. \[\left<A(t+\tau)B(t)\right> = {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho_{\rm ss}\right\}\right]; = {\rm Tr}\left[A V(\tau, 0)\left\{B\rho_{\rm ss}\right\}\right] = \left<A(\tau)B(0)\right>,\]; which is independent of \(t\), so that we only have one time coordinate \(\tau\).; QuTiP provides a family of functions that assists in the process of calculating two-time correlation functions. The available functions and their usage is shown in the table below. Each of these functions can use one of the following evolution solvers: Master-equation, Exponential series and the Monte-Carlo. The choice of solver is defined by the optional argument solver. QuTiP function; Correlation function. qutip.correlation.correlation or; qutip.correlation.correlation_2op_2t; \(\left<A(t+\tau)B(t)\right>\) or; \(\left<A(t)B(t+\tau)\right>\). qutip.correlation.correlation_ss or; qutip.correlation.correlation_2op_1t; \(\left<A(\tau)B(0)\right>\) or; \(\left<A(0)B(\tau)\right>\). qutip.correlation.correlation_4op_1t; \(\left<A(0)B(\tau)C(\tau)D(0)\right>\). qutip.correlation.correlation_4op_2t; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\). The most common use-case is to calculate correlation functions of the kind \(\left<A(\tau)B(0)\right>\), in which case we use the correlation function solvers that start from the steady state, e.g., the qutip.correlation.correlation_2op_1t function. These correlation function solvers return a ",MatchSource.WIKI,docs/4.0.2/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-correlation.html
https://qutip.org/docs/4.0.2/guide/guide-correlation.html:16757,Deployability,update,updated,16757,"bunched photons, they tend to appear together), and for a Fock state with \(n\) photons \(g^{(2)}(\tau = 0) = n(n - 1)/n^2 < 1\) and it increases with time (anti-bunched photons, more likely to arrive separated in time).; To calculate this type of correlation function with QuTiP, we can use qutip.correlation.correlation_4op_1t, which computes a correlation function on the form \(\left<A(0)B(\tau)C(\tau)D(0)\right>\) (four operators, one delay-time vector).; The following code calculates and plots \(g^{(2)}(\tau)\) as a function of \(\tau\) for a coherent, thermal and fock state.; import numpy as np; import pylab as plt; from qutip import *. N = 25; taus = np.linspace(0, 25.0, 200); a = destroy(N); H = 2 * np.pi * a.dag() * a. kappa = 0.25; n_th = 2.0 # bath temperature in terms of excitation number; c_ops = [np.sqrt(kappa * (1 + n_th)) * a, np.sqrt(kappa * n_th) * a.dag()]. states = [{'state': coherent_dm(N, np.sqrt(2)), 'label': ""coherent state""},; {'state': thermal_dm(N, 2), 'label': ""thermal state""},; {'state': fock_dm(N, 2), 'label': ""Fock state""}]. fig, ax = plt.subplots(1, 1). for state in states:; rho0 = state['state']. # first calculate the occupation number as a function of time; n = mesolve(H, rho0, taus, c_ops, [a.dag() * a]).expect[0]. # calculate the correlation function G2 and normalize with n(0)n(t) to; # obtain g2; G2 = correlation_3op_1t(H, rho0, taus, c_ops, a.dag(), a.dag()*a, a); g2 = G2 / (n[0] * n). ax.plot(taus, np.real(g2), label=state['label'], lw=2). ax.legend(loc=0); ax.set_xlabel(r'$\tau$'); ax.set_ylabel(r'$g^{(2)}(\tau)$'); plt.show(). (Source code, png, hires.png, pdf). For convenience, the steps for calculating the second-order coherence function have been collected in the function qutip.correlation.coherence_function_g2. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-correlation.html
https://qutip.org/docs/4.0.2/guide/guide-correlation.html:8774,Energy Efficiency,power,power,8774,,MatchSource.WIKI,docs/4.0.2/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-correlation.html
https://qutip.org/docs/4.0.2/guide/guide-correlation.html:9365,Energy Efficiency,power,power,9365,,MatchSource.WIKI,docs/4.0.2/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-correlation.html
https://qutip.org/docs/4.0.2/guide/guide-correlation.html:10470,Energy Efficiency,power,power,10470,"d atom frequency; g = 0.1 * 2 * np.pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = tensor(destroy(N), qeye(2)); sm = tensor(qeye(N), destroy(2)); H = wc * a.dag() * a + wa * sm.dag() * sm + g * (a.dag() * sm + a * sm.dag()). # collapse operators; n_th = 0.25; c_ops = [np.sqrt(kappa * (1 + n_th)) * a, np.sqrt(kappa * n_th) * a.dag(), np.sqrt(gamma) * sm]. # calculate the correlation function using the mesolve solver, and then fft to; # obtain the spectrum. Here we need to make sure to evaluate the correlation; # function for a sufficient long time and sufficiently high sampling rate so; # that the discrete Fourier transform (FFT) captures all the features in the; # resulting spectrum.; tlist = np.linspace(0, 100, 5000); corr = correlation_2op_1t(H, None, tlist, c_ops, a.dag(), a); wlist1, spec1 = spectrum_correlation_fft(tlist, corr). # calculate the power spectrum using spectrum, which internally uses essolve; # to solve for the dynamics (by default); wlist2 = np.linspace(0.25, 1.75, 200) * 2 * np.pi; spec2 = spectrum(H, wlist2, c_ops, a.dag(), a). # plot the spectra; fig, ax = plt.subplots(1, 1); ax.plot(wlist1 / (2 * np.pi), spec1, 'b', lw=2, label='eseries method'); ax.plot(wlist2 / (2 * np.pi), spec2, 'r--', lw=2, label='me+fft method'); ax.legend(); ax.set_xlabel('Frequency'); ax.set_ylabel('Power spectrum'); ax.set_title('Vacuum Rabi splitting'); ax.set_xlim(wlist2[0]/(2*np.pi), wlist2[-1]/(2*np.pi)); plt.show(). (Source code, png, hires.png, pdf). Non-steadystate correlation function¶; More generally, we can also calculate correlation functions of the kind \(\left<A(t_1+t_2)B(t_1)\right>\), i.e., the correlation function of a system that is not in its steadystate. In QuTiP, we can evoluate such correlation functions using the function qutip.correlation.correlation_2op_2t. The default behavior of this function is to return a matrix with the correlations as a function of the",MatchSource.WIKI,docs/4.0.2/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-correlation.html
https://qutip.org/docs/4.0.2/guide/guide-correlation.html:1162,Modifiability,evolve,evolved,1162,"tors; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function; Example: first-order optical coherence function; Example: second-order optical coherence function. Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Two-time correlation functions. Two-time correlation functions¶; With the QuTiP time-evolution functions (for example qutip.mesolve and qutip.mcsolve), a state vector or density matrix can be evolved from an initial state at \(t_0\) to an arbitrary time \(t\), \(\rho(t)=V(t, t_0)\left\{\rho(t_0)\right\}\), where \(V(t, t_0)\) is the propagator defined by the equation of motion. The resulting density matrix can then be used to evaluate the expectation values of arbitrary combinations of same-time operators.; To calculate two-time correlation functions on the form \(\left<A(t+\tau)B(t)\right>\), we can use the quantum regression theorem (see, e.g., [Gar03]) to write. \[\left<A(t+\tau)B(t)\right> = {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho(t)\right\}\right]; = {\rm Tr}\left[A V(t+\tau, t)\left\{BV(t, 0)\left\{\rho(0)\right\}\right\}\right]\]; We therefore first calculate \(\rho(t)=V(t, 0)\left\{\rho(0)\right\}\) using one of the QuTiP evolution solvers with \(\rho(0)\) as initial state, and then again use the same solver to calculate \(V(t+\tau, t)\left\{B\rho(t)\right\}\) using \(B\rho(t)\) as initial state.; Note that if the initial state is the steady state, then \(\rho(t)=V(t, 0)\left\{\rho_{\rm ss}\right\}=\rho_{\rm ss}\) and. \[\left<A(t+\",MatchSource.WIKI,docs/4.0.2/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-correlation.html
https://qutip.org/docs/4.0.2/guide/guide-correlation.html:9559,Modifiability,coupling,coupling,9559,,MatchSource.WIKI,docs/4.0.2/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-correlation.html
https://qutip.org/docs/4.0.2/guide/guide-correlation.html:9064,Performance,perform,performs,9064,,MatchSource.WIKI,docs/4.0.2/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-correlation.html
https://qutip.org/docs/4.0.2/guide/guide-dynamics.html:2035,Deployability,update,updated,2035,"ontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Bloch-Redfield master equation; Solving Problems with Time-dependent Hamiltonians; Floquet Formalism; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics. Time Evolution and Quantum System Dynamics¶. Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Setting Options for the Dynamics Solvers. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/guide/guide-dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-dynamics.html
https://qutip.org/docs/4.0.2/guide/guide-dynamics.html:476,Integrability,depend,dependent,476,". . Time Evolution and Quantum System Dynamics — QuTiP 4.0 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.0; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Bloch-Redfield master equation; Solving Problems with Time-dependent Hamiltonians; Floquet Formalism; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics. Time Evolution and Quantum System Dynamics¶. Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Setting Options for the Dynamics Solvers. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C.",MatchSource.WIKI,docs/4.0.2/guide/guide-dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-dynamics.html
https://qutip.org/docs/4.0.2/guide/guide-dynamics.html:1528,Integrability,depend,dependent,1528,"ontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Bloch-Redfield master equation; Solving Problems with Time-dependent Hamiltonians; Floquet Formalism; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics. Time Evolution and Quantum System Dynamics¶. Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Setting Options for the Dynamics Solvers. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/guide/guide-dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-dynamics.html
https://qutip.org/docs/4.0.2/guide/guide-eseries.html:8278,Deployability,update,updated,8278," [17]: es = ode2es(L, psi0). The qutip.essolve.ode2es function diagonalizes the Liouvillian \(L\) and creates an exponential series with the correct eigenfrequencies and amplitudes for the initial state \(\psi_0\) (psi0).; We can examine the resulting qutip.eseries object by printing a text representation:; In [18]: es; Out[18]: ; ESERIES object: 2 terms; Hilbert space dimensions: [[2], [2]]; Exponent #0 = (-1+0j); Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[-1. 0.]; [ 0. 1.]]; Exponent #1 = 0j; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. 0.]]. or by evaluating it and arbitrary points in time (here at 0.0 and 1.0):; In [19]: es.value([0.0, 1.0]); Out[19]: ; array([ Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 0. 0.]; [ 0. 1.]],; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 0.63212056 0. ]; [ 0. 0.36787944]]], dtype=object). and the expectation value of the exponential series can be calculated using the qutip.expect function:; In [20]: es_expect = expect(sigmaz(), es). The result es_expect is now an exponential series with c-numbers as amplitudes, which easily can be evaluated at arbitrary times:; In [21]: es_expect.value([0.0, 1.0, 2.0, 3.0]); Out[21]: array([-1. , 0.26424112, 0.72932943, 0.90042586]). In [22]: times = linspace(0.0, 10.0, 100). In [23]: sz_expect = es_expect.value(times). In [24]: from pylab import *. In [25]: plot(times, sz_expect, lw=2);. In [26]: xlabel(""Time"", fontsize=16); ....: ylabel(""Expectation value of sigma-z"", fontsize=16);; ....: . In [28]: title(""The expectation value of the $\sigma_{z}$ operator"", fontsize=16);. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/guide/guide-eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-eseries.html
https://qutip.org/docs/4.0.2/guide/guide-eseries.html:437,Integrability,depend,dependent,437,". . An Overview of the Eseries Class — QuTiP 4.0 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.0; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; An Overview of the Eseries Class. An Overview of the Eseries Class¶. Exponential-series representation of time-dependent quantum objects¶; The eseries object in QuTiP is a representation of an exponential-series expansion of time-dependent quantum objects (a concept borrowed from the quantum optics toolbox).; An exponential series is parameterized by its amplitude coefficients \(c_i\) and rates \(r_i\), so that the series takes the form \(E(t) = \sum_i c_i e^{r_it}\). The coefficients are typically quantum objects (type Qobj: states, operators, etc.), so that the value of the eseries also is a quantum object, and the rates can be either real or complex numbers (describing decay rates and oscillation frequencies, respectively). Note that all amplitude coefficients in an exponential series must be of the same dimensions and composition.; In QuTiP, an exponential series object is constructed by creating an instance of the class qutip.eseries:; In [1]: es1 = eseries(sigmax(), 1j). where the first argument is the amplitude coefficient (here, the sigma-X operator), and the second argument is the rate. T",MatchSource.WIKI,docs/4.0.2/guide/guide-eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-eseries.html
https://qutip.org/docs/4.0.2/guide/guide-eseries.html:998,Integrability,depend,dependent,998,"tum Toolbox in Python; . ; . 4.0; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; An Overview of the Eseries Class. An Overview of the Eseries Class¶. Exponential-series representation of time-dependent quantum objects¶; The eseries object in QuTiP is a representation of an exponential-series expansion of time-dependent quantum objects (a concept borrowed from the quantum optics toolbox).; An exponential series is parameterized by its amplitude coefficients \(c_i\) and rates \(r_i\), so that the series takes the form \(E(t) = \sum_i c_i e^{r_it}\). The coefficients are typically quantum objects (type Qobj: states, operators, etc.), so that the value of the eseries also is a quantum object, and the rates can be either real or complex numbers (describing decay rates and oscillation frequencies, respectively). Note that all amplitude coefficients in an exponential series must be of the same dimensions and composition.; In QuTiP, an exponential series object is constructed by creating an instance of the class qutip.eseries:; In [1]: es1 = eseries(sigmax(), 1j). where the first argument is the amplitude coefficient (here, the sigma-X operator), and the second argument is the rate. The eseries in this example represents the time-dependent operator \(\sigma_",MatchSource.WIKI,docs/4.0.2/guide/guide-eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-eseries.html
https://qutip.org/docs/4.0.2/guide/guide-eseries.html:1117,Integrability,depend,dependent,1117,"tum Toolbox in Python; . ; . 4.0; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; An Overview of the Eseries Class. An Overview of the Eseries Class¶. Exponential-series representation of time-dependent quantum objects¶; The eseries object in QuTiP is a representation of an exponential-series expansion of time-dependent quantum objects (a concept borrowed from the quantum optics toolbox).; An exponential series is parameterized by its amplitude coefficients \(c_i\) and rates \(r_i\), so that the series takes the form \(E(t) = \sum_i c_i e^{r_it}\). The coefficients are typically quantum objects (type Qobj: states, operators, etc.), so that the value of the eseries also is a quantum object, and the rates can be either real or complex numbers (describing decay rates and oscillation frequencies, respectively). Note that all amplitude coefficients in an exponential series must be of the same dimensions and composition.; In QuTiP, an exponential series object is constructed by creating an instance of the class qutip.eseries:; In [1]: es1 = eseries(sigmax(), 1j). where the first argument is the amplitude coefficient (here, the sigma-X operator), and the second argument is the rate. The eseries in this example represents the time-dependent operator \(\sigma_",MatchSource.WIKI,docs/4.0.2/guide/guide-eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-eseries.html
https://qutip.org/docs/4.0.2/guide/guide-eseries.html:2048,Integrability,depend,dependent,2048,"t in QuTiP is a representation of an exponential-series expansion of time-dependent quantum objects (a concept borrowed from the quantum optics toolbox).; An exponential series is parameterized by its amplitude coefficients \(c_i\) and rates \(r_i\), so that the series takes the form \(E(t) = \sum_i c_i e^{r_it}\). The coefficients are typically quantum objects (type Qobj: states, operators, etc.), so that the value of the eseries also is a quantum object, and the rates can be either real or complex numbers (describing decay rates and oscillation frequencies, respectively). Note that all amplitude coefficients in an exponential series must be of the same dimensions and composition.; In QuTiP, an exponential series object is constructed by creating an instance of the class qutip.eseries:; In [1]: es1 = eseries(sigmax(), 1j). where the first argument is the amplitude coefficient (here, the sigma-X operator), and the second argument is the rate. The eseries in this example represents the time-dependent operator \(\sigma_x e^{i t}\).; To add more terms to an qutip.eseries object we simply add objects using the + operator:; In [2]: omega=1.0. In [3]: es2 = (eseries(0.5 * sigmax(), 1j * omega) +; ...: eseries(0.5 * sigmax(), -1j * omega)); ...: . The qutip.eseries in this example represents the operator \(0.5 \sigma_x e^{i\omega t} + 0.5 \sigma_x e^{-i\omega t}\), which is the exponential series representation of \(\sigma_x \cos(\omega t)\). Alternatively, we can also specify a list of amplitudes and rates when the qutip.eseries is created:; In [4]: es2 = eseries([0.5 * sigmax(), 0.5 * sigmax()], [1j * omega, -1j * omega]). We can inspect the structure of an qutip.eseries object by printing it to the standard output console:; In [5]: es2; Out[5]: ; ESERIES object: 2 terms; Hilbert space dimensions: [[2], [2]]; Exponent #0 = -1j; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 0. 0.5]; [ 0.5 0. ]]; Exponent #1 = 1j; Quantum obj",MatchSource.WIKI,docs/4.0.2/guide/guide-eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-eseries.html
https://qutip.org/docs/4.0.2/guide/guide-eseries.html:3986,Integrability,depend,dependent,3986,"ta =; [[ 0. 0.5]; [ 0.5 0. ]]; Exponent #1 = 1j; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 0. 0.5]; [ 0.5 0. ]]. and we can evaluate it at time t by using the qutip.eseries.esval function:; In [6]: esval(es2, 0.0) # equivalent to es2.value(0.0); Out[6]: ; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 0. 1.]; [ 1. 0.]]. or for a list of times [0.0, 1.0 * pi, 2.0 * pi]:; In [7]: times = [0.0, 1.0 * pi, 2.0 * pi]. In [8]: esval(es2, times) # equivalent to es2.value(times); Out[8]: ; array([ Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 0. 1.]; [ 1. 0.]],; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 0. -1.]; [-1. 0.]],; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 0. 1.]; [ 1. 0.]]], dtype=object). To calculate the expectation value of an time-dependent operator represented by an qutip.eseries, we use the qutip.expect function. For example, consider the operator \(\sigma_x \cos(\omega t) + \sigma_z\sin(\omega t)\), and say we would like to know the expectation value of this operator for a spin in its excited state (rho = fock_dm(2,1) produce this state):; In [9]: es3 = (eseries([0.5*sigmaz(), 0.5*sigmaz()], [1j, -1j]) +; ...: eseries([-0.5j*sigmax(), 0.5j*sigmax()], [1j, -1j])); ...: . In [10]: rho = fock_dm(2, 1). In [11]: es3_expect = expect(rho, es3). In [12]: es3_expect; Out[12]: ; ESERIES object: 2 terms; Hilbert space dimensions: [[1, 1]]; Exponent #0 = (-0-1j); (-0.5+0j); Exponent #1 = 1j; (-0.5+0j). In [13]: es3_expect.value([0.0, pi/2]); ",MatchSource.WIKI,docs/4.0.2/guide/guide-eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-eseries.html
https://qutip.org/docs/4.0.2/guide/guide-eseries.html:1223,Modifiability,parameteriz,parameterized,1223,"es; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; An Overview of the Eseries Class. An Overview of the Eseries Class¶. Exponential-series representation of time-dependent quantum objects¶; The eseries object in QuTiP is a representation of an exponential-series expansion of time-dependent quantum objects (a concept borrowed from the quantum optics toolbox).; An exponential series is parameterized by its amplitude coefficients \(c_i\) and rates \(r_i\), so that the series takes the form \(E(t) = \sum_i c_i e^{r_it}\). The coefficients are typically quantum objects (type Qobj: states, operators, etc.), so that the value of the eseries also is a quantum object, and the rates can be either real or complex numbers (describing decay rates and oscillation frequencies, respectively). Note that all amplitude coefficients in an exponential series must be of the same dimensions and composition.; In QuTiP, an exponential series object is constructed by creating an instance of the class qutip.eseries:; In [1]: es1 = eseries(sigmax(), 1j). where the first argument is the amplitude coefficient (here, the sigma-X operator), and the second argument is the rate. The eseries in this example represents the time-dependent operator \(\sigma_x e^{i t}\).; To add more terms to an qutip.eseries object we simply add objects using the + operator:; In [2]: omega=1.0. In [3]: es2 = (eseries(0.5 * sigmax(), 1j * omega) +; ...: eseries(0.5 * sigmax",MatchSource.WIKI,docs/4.0.2/guide/guide-eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-eseries.html
https://qutip.org/docs/4.0.2/guide/guide-eseries.html:5643,Modifiability,evolve,evolve,5643," = 1j; (-0.5+0j). In [13]: es3_expect.value([0.0, pi/2]); ",MatchSource.WIKI,docs/4.0.2/guide/guide-eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-eseries.html
https://qutip.org/docs/4.0.2/guide/guide-eseries.html:5772,Modifiability,evolve,evolved,5772,,MatchSource.WIKI,docs/4.0.2/guide/guide-eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-eseries.html
https://qutip.org/docs/4.0.2/guide/guide-eseries.html:5858,Performance,perform,performed,5858,,MatchSource.WIKI,docs/4.0.2/guide/guide-eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-eseries.html
https://qutip.org/docs/4.0.2/guide/guide-eseries.html:2138,Usability,simpl,simply,2138,"owed from the quantum optics toolbox).; An exponential series is parameterized by its amplitude coefficients \(c_i\) and rates \(r_i\), so that the series takes the form \(E(t) = \sum_i c_i e^{r_it}\). The coefficients are typically quantum objects (type Qobj: states, operators, etc.), so that the value of the eseries also is a quantum object, and the rates can be either real or complex numbers (describing decay rates and oscillation frequencies, respectively). Note that all amplitude coefficients in an exponential series must be of the same dimensions and composition.; In QuTiP, an exponential series object is constructed by creating an instance of the class qutip.eseries:; In [1]: es1 = eseries(sigmax(), 1j). where the first argument is the amplitude coefficient (here, the sigma-X operator), and the second argument is the rate. The eseries in this example represents the time-dependent operator \(\sigma_x e^{i t}\).; To add more terms to an qutip.eseries object we simply add objects using the + operator:; In [2]: omega=1.0. In [3]: es2 = (eseries(0.5 * sigmax(), 1j * omega) +; ...: eseries(0.5 * sigmax(), -1j * omega)); ...: . The qutip.eseries in this example represents the operator \(0.5 \sigma_x e^{i\omega t} + 0.5 \sigma_x e^{-i\omega t}\), which is the exponential series representation of \(\sigma_x \cos(\omega t)\). Alternatively, we can also specify a list of amplitudes and rates when the qutip.eseries is created:; In [4]: es2 = eseries([0.5 * sigmax(), 0.5 * sigmax()], [1j * omega, -1j * omega]). We can inspect the structure of an qutip.eseries object by printing it to the standard output console:; In [5]: es2; Out[5]: ; ESERIES object: 2 terms; Hilbert space dimensions: [[2], [2]]; Exponent #0 = -1j; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 0. 0.5]; [ 0.5 0. ]]; Exponent #1 = 1j; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 0. 0.5]; [ 0.5 0. ]]. and we c",MatchSource.WIKI,docs/4.0.2/guide/guide-eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-eseries.html
https://qutip.org/docs/4.0.2/guide/guide-overview.html:1651,Availability,avail,available,1651,"tum Toolbox in Python; . ; . 4.0; . Frontmatter; Installation; Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at the end of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the Tree-diagram of the 306 user accessible functions and classes in QuTiP 3.2. Tree-diagram of the 306 user accessible functions and classes in QuTiP 3.2. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-overview.html
https://qutip.org/docs/4.0.2/guide/guide-overview.html:1970,Deployability,update,updated,1970,"tum Toolbox in Python; . ; . 4.0; . Frontmatter; Installation; Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at the end of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the Tree-diagram of the 306 user accessible functions and classes in QuTiP 3.2. Tree-diagram of the 306 user accessible functions and classes in QuTiP 3.2. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-overview.html
https://qutip.org/docs/4.0.2/guide/guide-overview.html:1719,Security,access,accessible,1719,"tum Toolbox in Python; . ; . 4.0; . Frontmatter; Installation; Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at the end of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the Tree-diagram of the 306 user accessible functions and classes in QuTiP 3.2. Tree-diagram of the 306 user accessible functions and classes in QuTiP 3.2. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-overview.html
https://qutip.org/docs/4.0.2/guide/guide-overview.html:1795,Security,access,accessible,1795,"tum Toolbox in Python; . ; . 4.0; . Frontmatter; Installation; Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at the end of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the Tree-diagram of the 306 user accessible functions and classes in QuTiP 3.2. Tree-diagram of the 306 user accessible functions and classes in QuTiP 3.2. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-overview.html
https://qutip.org/docs/4.0.2/guide/guide-overview.html:829,Usability,guid,guide,829,"﻿. . Guide Overview — QuTiP 4.0 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.0; . Frontmatter; Installation; Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at the end of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the Tree-diagram of the 306 user accessible functions and classes in QuTiP 3.2. Tree-diagram of the 306 user accessible functions and classes in QuTiP 3.2. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Buil",MatchSource.WIKI,docs/4.0.2/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-overview.html
https://qutip.org/docs/4.0.2/guide/guide-overview.html:918,Usability,guid,guide,918,"﻿. . Guide Overview — QuTiP 4.0 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.0; . Frontmatter; Installation; Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at the end of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the Tree-diagram of the 306 user accessible functions and classes in QuTiP 3.2. Tree-diagram of the 306 user accessible functions and classes in QuTiP 3.2. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Buil",MatchSource.WIKI,docs/4.0.2/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-overview.html
https://qutip.org/docs/4.0.2/guide/guide-overview.html:1127,Usability,guid,guide,1127,"tum Toolbox in Python; . ; . 4.0; . Frontmatter; Installation; Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at the end of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the Tree-diagram of the 306 user accessible functions and classes in QuTiP 3.2. Tree-diagram of the 306 user accessible functions and classes in QuTiP 3.2. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-overview.html
https://qutip.org/docs/4.0.2/guide/guide-overview.html:1265,Usability,guid,guide,1265,"tum Toolbox in Python; . ; . 4.0; . Frontmatter; Installation; Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at the end of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the Tree-diagram of the 306 user accessible functions and classes in QuTiP 3.2. Tree-diagram of the 306 user accessible functions and classes in QuTiP 3.2. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-overview.html
https://qutip.org/docs/4.0.2/guide/guide-parfor.html:6825,Deployability,configurat,configurations,6825,"ing task_kwargs argument, so there is no special reserved keyword arguments.; The qutip.parallel.parallel_map function also supports progressbar, using the keyword argument progress_bar which can be set to True or to an instance of qutip.ui.progressbar.BaseProgressBar. There is a function called qutip.parallel.serial_map that works as a non-parallel drop-in replacement for qutip.parallel.parallel_map, which allows easy switching between serial and parallel computation.; In [23]: import time. In [24]: def func(x): time.sleep(1). In [25]: result = parallel_map(func, range(50), progress_bar=True); 10.0%. Run time: 3.03s. Est. time left: 00:00:00:27; 20.0%. Run time: 5.03s. Est. time left: 00:00:00:20; 30.0%. Run time: 8.04s. Est. time left: 00:00:00:18; 40.0%. Run time: 10.04s. Est. time left: 00:00:00:15; 50.0%. Run time: 13.05s. Est. time left: 00:00:00:13; 60.0%. Run time: 15.05s. Est. time left: 00:00:00:10; 70.0%. Run time: 18.06s. Est. time left: 00:00:00:07; 80.0%. Run time: 20.06s. Est. time left: 00:00:00:05; 90.0%. Run time: 23.07s. Est. time left: 00:00:00:02; 100.0%. Run time: 25.07s. Est. time left: 00:00:00:00; Total run time: 25.12s. Parallel processing is useful for repeated tasks such as generating plots corresponding to the dynamical evolution of your system, or simultaneously simulating different parameter configurations. IPython-based parallel_map¶. Note; New in QuTiP 3. When QuTiP is used with IPython interpreter, there is an alternative parallel for-loop implementation in the QuTiP module qutip.ipynbtools, see qutip.ipynbtools.parallel_map. The advantage of this parallel_map implementation is based on IPythons powerful framework for parallelization, so the compute processes are not confined to run on the same host as the main process. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-parfor.html
https://qutip.org/docs/4.0.2/guide/guide-parfor.html:7393,Deployability,update,updated,7393,"ing task_kwargs argument, so there is no special reserved keyword arguments.; The qutip.parallel.parallel_map function also supports progressbar, using the keyword argument progress_bar which can be set to True or to an instance of qutip.ui.progressbar.BaseProgressBar. There is a function called qutip.parallel.serial_map that works as a non-parallel drop-in replacement for qutip.parallel.parallel_map, which allows easy switching between serial and parallel computation.; In [23]: import time. In [24]: def func(x): time.sleep(1). In [25]: result = parallel_map(func, range(50), progress_bar=True); 10.0%. Run time: 3.03s. Est. time left: 00:00:00:27; 20.0%. Run time: 5.03s. Est. time left: 00:00:00:20; 30.0%. Run time: 8.04s. Est. time left: 00:00:00:18; 40.0%. Run time: 10.04s. Est. time left: 00:00:00:15; 50.0%. Run time: 13.05s. Est. time left: 00:00:00:13; 60.0%. Run time: 15.05s. Est. time left: 00:00:00:10; 70.0%. Run time: 18.06s. Est. time left: 00:00:00:07; 80.0%. Run time: 20.06s. Est. time left: 00:00:00:05; 90.0%. Run time: 23.07s. Est. time left: 00:00:00:02; 100.0%. Run time: 25.07s. Est. time left: 00:00:00:00; Total run time: 25.12s. Parallel processing is useful for repeated tasks such as generating plots corresponding to the dynamical evolution of your system, or simultaneously simulating different parameter configurations. IPython-based parallel_map¶. Note; New in QuTiP 3. When QuTiP is used with IPython interpreter, there is an alternative parallel for-loop implementation in the QuTiP module qutip.ipynbtools, see qutip.ipynbtools.parallel_map. The advantage of this parallel_map implementation is based on IPythons powerful framework for parallelization, so the compute processes are not confined to run on the same host as the main process. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-parfor.html
https://qutip.org/docs/4.0.2/guide/guide-parfor.html:7138,Energy Efficiency,power,powerful,7138,"ing task_kwargs argument, so there is no special reserved keyword arguments.; The qutip.parallel.parallel_map function also supports progressbar, using the keyword argument progress_bar which can be set to True or to an instance of qutip.ui.progressbar.BaseProgressBar. There is a function called qutip.parallel.serial_map that works as a non-parallel drop-in replacement for qutip.parallel.parallel_map, which allows easy switching between serial and parallel computation.; In [23]: import time. In [24]: def func(x): time.sleep(1). In [25]: result = parallel_map(func, range(50), progress_bar=True); 10.0%. Run time: 3.03s. Est. time left: 00:00:00:27; 20.0%. Run time: 5.03s. Est. time left: 00:00:00:20; 30.0%. Run time: 8.04s. Est. time left: 00:00:00:18; 40.0%. Run time: 10.04s. Est. time left: 00:00:00:15; 50.0%. Run time: 13.05s. Est. time left: 00:00:00:13; 60.0%. Run time: 15.05s. Est. time left: 00:00:00:10; 70.0%. Run time: 18.06s. Est. time left: 00:00:00:07; 80.0%. Run time: 20.06s. Est. time left: 00:00:00:05; 90.0%. Run time: 23.07s. Est. time left: 00:00:00:02; 100.0%. Run time: 25.07s. Est. time left: 00:00:00:00; Total run time: 25.12s. Parallel processing is useful for repeated tasks such as generating plots corresponding to the dynamical evolution of your system, or simultaneously simulating different parameter configurations. IPython-based parallel_map¶. Note; New in QuTiP 3. When QuTiP is used with IPython interpreter, there is an alternative parallel for-loop implementation in the QuTiP module qutip.ipynbtools, see qutip.ipynbtools.parallel_map. The advantage of this parallel_map implementation is based on IPythons powerful framework for parallelization, so the compute processes are not confined to run on the same host as the main process. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-parfor.html
https://qutip.org/docs/4.0.2/guide/guide-parfor.html:1488,Modifiability,variab,variables,1488,"tum states and processes; Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Parallel computation. Parallel computation¶. Parallel map and parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parallel.parallel_map function or the qutip.parallel.parfor (parallel-for-loop) function.; To use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; In [1]: def func1(x): return x, x**2, x**3. In [2]: a, b, c = parfor(func1, range(10)). In [3]: print(a); [0 1 2 3 4 5 6 7 8 9]. In [4]: print(b); ",MatchSource.WIKI,docs/4.0.2/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-parfor.html
https://qutip.org/docs/4.0.2/guide/guide-parfor.html:1537,Modifiability,variab,variables,1537,"tum states and processes; Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Parallel computation. Parallel computation¶. Parallel map and parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parallel.parallel_map function or the qutip.parallel.parfor (parallel-for-loop) function.; To use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; In [1]: def func1(x): return x, x**2, x**3. In [2]: a, b, c = parfor(func1, range(10)). In [3]: print(a); [0 1 2 3 4 5 6 7 8 9]. In [4]: print(b); ",MatchSource.WIKI,docs/4.0.2/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-parfor.html
https://qutip.org/docs/4.0.2/guide/guide-parfor.html:6825,Modifiability,config,configurations,6825,"ing task_kwargs argument, so there is no special reserved keyword arguments.; The qutip.parallel.parallel_map function also supports progressbar, using the keyword argument progress_bar which can be set to True or to an instance of qutip.ui.progressbar.BaseProgressBar. There is a function called qutip.parallel.serial_map that works as a non-parallel drop-in replacement for qutip.parallel.parallel_map, which allows easy switching between serial and parallel computation.; In [23]: import time. In [24]: def func(x): time.sleep(1). In [25]: result = parallel_map(func, range(50), progress_bar=True); 10.0%. Run time: 3.03s. Est. time left: 00:00:00:27; 20.0%. Run time: 5.03s. Est. time left: 00:00:00:20; 30.0%. Run time: 8.04s. Est. time left: 00:00:00:18; 40.0%. Run time: 10.04s. Est. time left: 00:00:00:15; 50.0%. Run time: 13.05s. Est. time left: 00:00:00:13; 60.0%. Run time: 15.05s. Est. time left: 00:00:00:10; 70.0%. Run time: 18.06s. Est. time left: 00:00:00:07; 80.0%. Run time: 20.06s. Est. time left: 00:00:00:05; 90.0%. Run time: 23.07s. Est. time left: 00:00:00:02; 100.0%. Run time: 25.07s. Est. time left: 00:00:00:00; Total run time: 25.12s. Parallel processing is useful for repeated tasks such as generating plots corresponding to the dynamical evolution of your system, or simultaneously simulating different parameter configurations. IPython-based parallel_map¶. Note; New in QuTiP 3. When QuTiP is used with IPython interpreter, there is an alternative parallel for-loop implementation in the QuTiP module qutip.ipynbtools, see qutip.ipynbtools.parallel_map. The advantage of this parallel_map implementation is based on IPythons powerful framework for parallelization, so the compute processes are not confined to run on the same host as the main process. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-parfor.html
https://qutip.org/docs/4.0.2/guide/guide-parfor.html:1222,Performance,perform,performing,1222,"ects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Parallel computation. Parallel computation¶. Parallel map and parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parallel.parallel_map function or the qutip.parallel.parfor (parallel-for-loop) function.; To use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; In [1]: def func1(x): return x, x**2, x**3. In [2]: a, b, c = parfor(func1, range(10)). In [3]: print(a); [0 1 2 3 4 5 6 7 8 9]. In [4]: print(b); ",MatchSource.WIKI,docs/4.0.2/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-parfor.html
https://qutip.org/docs/4.0.2/guide/guide-parfor.html:1300,Performance,perform,performed,1300,"um System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Parallel computation. Parallel computation¶. Parallel map and parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parallel.parallel_map function or the qutip.parallel.parfor (parallel-for-loop) function.; To use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; In [1]: def func1(x): return x, x**2, x**3. In [2]: a, b, c = parfor(func1, range(10)). In [3]: print(a); [0 1 2 3 4 5 6 7 8 9]. In [4]: print(b); ",MatchSource.WIKI,docs/4.0.2/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-parfor.html
https://qutip.org/docs/4.0.2/guide/guide-parfor.html:5381,Performance,perform,performance,5381,"allel.parallel_map only iterate over the values arguments, the qutip.parallel.parfor function simultaneously iterates over all arguments:; In [20]: def sum_diff(x, y, z=0): return x + y, x - y, z. In [21]: parfor(sum_diff, [1, 2, 3], [4, 5, 6], z=5.0); Out[21]: [array([5, 7, 9]), array([-3, -3, -3]), array([ 5., 5., 5.])]. In [22]: parallel_map(sum_diff, [1, 2, 3], task_args=(np.array([4, 5, 6]),), task_kwargs=dict(z=5.0)); ",MatchSource.WIKI,docs/4.0.2/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-parfor.html
https://qutip.org/docs/4.0.2/guide/guide-parfor.html:2536,Safety,avoid,avoid,2536," example:; In [1]: def func1(x): return x, x**2, x**3. In [2]: a, b, c = parfor(func1, range(10)). In [3]: print(a); [0 1 2 3 4 5 6 7 8 9]. In [4]: print(b); ",MatchSource.WIKI,docs/4.0.2/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-parfor.html
https://qutip.org/docs/4.0.2/guide/guide-random.html:2633,Availability,down,down,2633,"473610+0.26899532j 0.00000000+0.j 0.21699323-0.14122294j; -0.12734561+0.05322338j 0.00000000+0.j ]; [ 0.00000000+0.j 0.21699323+0.14122294j 0.00000000+0.j; -0.11379132+0.23186375j 0.00000000+0.j ]; [ 0.00000000+0.j -0.12734561-0.05322338j -0.11379132-0.23186375j; 0.00000000+0.j -0.21668267-0.1563881j ]; [ 0.19439792+0.46184373j 0.00000000+0.j 0.00000000+0.j; -0.21668267+0.1563881j 0.49328238+0.j ]]. Random Variable Type; Sampling Functions; Dimensions. State vector (ket); rand_ket, rand_ket_haar; \(N \times 1\). Hermitian operator (oper); rand_herm; \(N \times 1\). Density operator (oper); rand_dm, rand_dm_hs, rand_dm_ginibre; \(N \times N\). Unitary operator (oper); rand_unitary, rand_unitary_haar; \(N \times N\). CPTP channel (super); rand_super, rand_super_bcsz; \((N \times N) \times (N \times N)\). In all cases, these functions can be called with a single parameter \(N\) that dimension of the relevant Hilbert space. The optional; dims keyword argument allows for the dimensions of a random state, unitary or channel to be broken down into subsystems.; In [2]: print rand_super_bcsz(7).dims; File ""<ipython-input-2-aef77a269b21>"", line 1; print rand_super_bcsz(7).dims; ^; SyntaxError: invalid syntax. In [3]: print rand_super_bcsz(6, dims=[[[2, 3], [2, 3]], [[2, 3], [2, 3]]]).dims; ",MatchSource.WIKI,docs/4.0.2/guide/guide-random.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-random.html
https://qutip.org/docs/4.0.2/guide/guide-random.html:9511,Deployability,update,updated,9511,,MatchSource.WIKI,docs/4.0.2/guide/guide-random.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-random.html
https://qutip.org/docs/4.0.2/guide/guide-random.html:1103,Testability,test,testing,1103,"ting Random Quantum States & Operators — QuTiP 4.0 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.0; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Generating Random Quantum States & Operators. Generating Random Quantum States & Operators¶; QuTiP includes a collection of random state, unitary and channel generators for simulations, Monte Carlo evaluation, theorem evaluation, and code testing.; Each of these objects can be sampled from one of several different distributions including the default distributions; used by QuTiP versions prior to 3.2.0.; For example, a random Hermitian operator can be sampled by calling rand_herm function:; In [1]: rand_herm(5); Out[1]: ; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[ 0.85238103+0.j 0.00473610-0.26899532j 0.00000000+0.j; 0.00000000+0.j 0.19439792-0.46184373j]; [ 0.00473610+0.26899532j 0.00000000+0.j 0.21699323-0.14122294j; -0.12734561+0.05322338j 0.00000000+0.j ]; [ 0.00000000+0.j 0.21699323+0.14122294j 0.00000000+0.j; -0.11379132+0.23186375j 0.00000000+0.j ]; [ 0.00000000+0.j -0.12734561-0.05322338j -0.11379132-0.23186375j; 0.00000000+0.j -0.21668267-0.1563881j ]; [ 0.19439792+0.46184373j 0.00000000+0.j 0.00000000+0.j; -0.21668267+0.1563881j 0.49328238+0.j ]]. Random Variable Type;",MatchSource.WIKI,docs/4.0.2/guide/guide-random.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-random.html
https://qutip.org/docs/4.0.2/guide/guide-saving.html:8903,Deployability,update,updated,8903," need to store both the real and imaginary parts, so instead we could use the numtype=”real” option:; In [26]: file_data_store('expect.dat', output_data.T, numtype=""real""). In [27]: !head -n5 expect.dat; # Generated by QuTiP: 100x4 real matrix in decimal format [',' separated values].; 0.0000000000,4.1806530217,-1.6468057879,-0.1184956481; 1.0101010101,3.3732071060,-0.7721165691,1.1079090288; 2.0202020202,2.8025239639,0.4712121856,1.0675527183; 3.0303030303,2.3752310795,1.0037440470,0.1395209926. and if we prefer scientific notation we can request that using the numformat=”exp” option; In [28]: file_data_store('expect.dat', output_data.T, numtype=""real"", numformat=""exp""). In [29]: !head -n 5 expect.dat; # Generated by QuTiP: 100x4 real matrix in exp format [',' separated values].; 0.0000000000e+00,4.1806530217e+00,-1.6468057879e+00,-1.1849564809e-01; 1.0101010101e+00,3.3732071060e+00,-7.7211656913e-01,1.1079090288e+00; 2.0202020202e+00,2.8025239639e+00,4.7121218559e-01,1.0675527183e+00; 3.0303030303e+00,2.3752310795e+00,1.0037440470e+00,1.3952099261e-01. Loading data previously stored using qutip.fileio.file_data_store (or some other software) is a even easier. Regardless of which deliminator was used, if data was stored as complex or real numbers, if it is in decimal or exponential form, the data can be loaded using the qutip.fileio.file_data_read, which only takes the filename as mandatory argument.; In [30]: input_data = file_data_read('expect.dat'). In [31]: shape(input_data); Out[31]: (100, 4). In [32]: from pylab import *. In [33]: plot(input_data[:,0], input_data[:,1]); # plot the data. (If a particularly obscure choice of deliminator was used it might be necessary to use the optional second argument, for example sep=”_” if _ is the deliminator). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-saving.html
https://qutip.org/docs/4.0.2/guide/guide-saving.html:601,Performance,load,loading,601,". . Saving QuTiP Objects and Data Sets — QuTiP 4.0 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.0; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Saving QuTiP Objects and Data Sets. Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a",MatchSource.WIKI,docs/4.0.2/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-saving.html
https://qutip.org/docs/4.0.2/guide/guide-saving.html:636,Performance,load,loading,636,". . Saving QuTiP Objects and Data Sets — QuTiP 4.0 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.0; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Saving QuTiP Objects and Data Sets. Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a",MatchSource.WIKI,docs/4.0.2/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-saving.html
https://qutip.org/docs/4.0.2/guide/guide-saving.html:1409,Performance,perform,performed,1409,"l Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Saving QuTiP Objects and Data Sets. Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [1]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [2]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steady",MatchSource.WIKI,docs/4.0.2/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-saving.html
https://qutip.org/docs/4.0.2/guide/guide-saving.html:1583,Performance,load,loading,1583,"jects; Storing and loading datasets. Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Saving QuTiP Objects and Data Sets. Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [1]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [2]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; In [3]: qsave(rho_ss, 'steadystate'). In [4]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calcula",MatchSource.WIKI,docs/4.0.2/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-saving.html
https://qutip.org/docs/4.0.2/guide/guide-saving.html:1620,Performance,load,load,1620,"jects; Storing and loading datasets. Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Saving QuTiP Objects and Data Sets. Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [1]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [2]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; In [3]: qsave(rho_ss, 'steadystate'). In [4]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calcula",MatchSource.WIKI,docs/4.0.2/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-saving.html
https://qutip.org/docs/4.0.2/guide/guide-saving.html:2043,Performance,load,loads,2043,"ocessed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [1]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [2]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; In [3]: qsave(rho_ss, 'steadystate'). In [4]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [5]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True. In [6]: a = destroy(10). In [7]: expect(a.dag() * a, rho_ss_loaded); Out[7]: 0.9902248289345061. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example stor",MatchSource.WIKI,docs/4.0.2/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-saving.html
https://qutip.org/docs/4.0.2/guide/guide-saving.html:2576,Performance,load,loaded,2576,"Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [1]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [2]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; In [3]: qsave(rho_ss, 'steadystate'). In [4]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [5]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True. In [6]: a = destroy(10). In [7]: expect(a.dag() * a, rho_ss_loaded); Out[7]: 0.9902248289345061. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [8]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [9]: psi0 = rand_ket(10). In [10]: times = np.linspace(0, 10, 10). In [11]: dm_list = mesolve(H, psi0, times, c_ops, []). In [12]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [13]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [14]: a = destroy(10). In [15]: expect(a",MatchSource.WIKI,docs/4.0.2/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-saving.html
https://qutip.org/docs/4.0.2/guide/guide-saving.html:2993,Performance,load,load,2993,"n qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [1]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [2]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; In [3]: qsave(rho_ss, 'steadystate'). In [4]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [5]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True. In [6]: a = destroy(10). In [7]: expect(a.dag() * a, rho_ss_loaded); Out[7]: 0.9902248289345061. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [8]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [9]: psi0 = rand_ket(10). In [10]: times = np.linspace(0, 10, 10). In [11]: dm_list = mesolve(H, psi0, times, c_ops, []). In [12]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [13]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [14]: a = destroy(10). In [15]: expect(a.dag() * a, dm_list_loaded.states); Out[15]: ; array([ 4.29179401, 3.37589742, 2.75659972, 2.30562634, 1.97257341,; 1.72505191, 1.54045945, 1.40251047, 1.2992826 , 1.22196967]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understoo",MatchSource.WIKI,docs/4.0.2/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-saving.html
https://qutip.org/docs/4.0.2/guide/guide-saving.html:3382,Performance,load,loaded,3382,"; In [3]: qsave(rho_ss, 'steadystate'). In [4]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [5]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True. In [6]: a = destroy(10). In [7]: expect(a.dag() * a, rho_ss_loaded); Out[7]: 0.9902248289345061. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [8]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [9]: psi0 = rand_ket(10). In [10]: times = np.linspace(0, 10, 10). In [11]: dm_list = mesolve(H, psi0, times, c_ops, []). In [12]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [13]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [14]: a = destroy(10). In [15]: expect(a.dag() * a, dm_list_loaded.states); Out[15]: ; array([ 4.29179401, 3.37589742, 2.75659972, 2.30562634, 1.97257341,; 1.72505191, 1.54045945, 1.40251047, 1.2992826 , 1.22196967]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions qutip.fileio.file_data_store and qutip.fileio.file_data_read we can store and load numpy arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format.; The qutip.fileio.file_data_store take",MatchSource.WIKI,docs/4.0.2/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-saving.html
https://qutip.org/docs/4.0.2/guide/guide-saving.html:3855,Performance,load,loading,3855,"9345061. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [8]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [9]: psi0 = rand_ket(10). In [10]: times = np.linspace(0, 10, 10). In [11]: dm_list = mesolve(H, psi0, times, c_ops, []). In [12]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [13]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [14]: a = destroy(10). In [15]: expect(a.dag() * a, dm_list_loaded.states); Out[15]: ; array([ 4.29179401, 3.37589742, 2.75659972, 2.30562634, 1.97257341,; 1.72505191, 1.54045945, 1.40251047, 1.2992826 , 1.22196967]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions qutip.fileio.file_data_store and qutip.fileio.file_data_read we can store and load numpy arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format.; The qutip.fileio.file_data_store takes two mandatory and three optional arguments:; >>> file_data_store(filename, data, numtype=""complex"", numformat=""decimal"", sep="",""). where filename is the name of the file, data is the data to be written to the file (must be a numpy array), numtype (optional) is a flag indicating numerical type that can take values complex or real, numformat (optional) specifies the numerical format that can take the v",MatchSource.WIKI,docs/4.0.2/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-saving.html
https://qutip.org/docs/4.0.2/guide/guide-saving.html:4239,Performance,load,load,4239,"i0, times, c_ops, []). In [12]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [13]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [14]: a = destroy(10). In [15]: expect(a.dag() * a, dm_list_loaded.states); Out[15]: ; array([ 4.29179401, 3.37589742, 2.75659972, 2.30562634, 1.97257341,; 1.72505191, 1.54045945, 1.40251047, 1.2992826 , 1.22196967]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions qutip.fileio.file_data_store and qutip.fileio.file_data_read we can store and load numpy arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format.; The qutip.fileio.file_data_store takes two mandatory and three optional arguments:; >>> file_data_store(filename, data, numtype=""complex"", numformat=""decimal"", sep="",""). where filename is the name of the file, data is the data to be written to the file (must be a numpy array), numtype (optional) is a flag indicating numerical type that can take values complex or real, numformat (optional) specifies the numerical format that can take the values exp for the format 1.0e1 and decimal for the format 10.0, and sep (optional) is an arbitrary single-character field separator (usually a tab, space, comma, semicolon, etc.).; A common use for the qutip.fileio.file_data_store function is to store the expectation values of a set of operators for a sequence of times, e.g., as returned by the qutip.mesolve function, which is what the following example does:; In [16]: a =",MatchSource.WIKI,docs/4.0.2/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-saving.html
https://qutip.org/docs/4.0.2/guide/guide-saving.html:8317,Performance,load,loaded,8317," need to store both the real and imaginary parts, so instead we could use the numtype=”real” option:; In [26]: file_data_store('expect.dat', output_data.T, numtype=""real""). In [27]: !head -n5 expect.dat; # Generated by QuTiP: 100x4 real matrix in decimal format [',' separated values].; 0.0000000000,4.1806530217,-1.6468057879,-0.1184956481; 1.0101010101,3.3732071060,-0.7721165691,1.1079090288; 2.0202020202,2.8025239639,0.4712121856,1.0675527183; 3.0303030303,2.3752310795,1.0037440470,0.1395209926. and if we prefer scientific notation we can request that using the numformat=”exp” option; In [28]: file_data_store('expect.dat', output_data.T, numtype=""real"", numformat=""exp""). In [29]: !head -n 5 expect.dat; # Generated by QuTiP: 100x4 real matrix in exp format [',' separated values].; 0.0000000000e+00,4.1806530217e+00,-1.6468057879e+00,-1.1849564809e-01; 1.0101010101e+00,3.3732071060e+00,-7.7211656913e-01,1.1079090288e+00; 2.0202020202e+00,2.8025239639e+00,4.7121218559e-01,1.0675527183e+00; 3.0303030303e+00,2.3752310795e+00,1.0037440470e+00,1.3952099261e-01. Loading data previously stored using qutip.fileio.file_data_store (or some other software) is a even easier. Regardless of which deliminator was used, if data was stored as complex or real numbers, if it is in decimal or exponential form, the data can be loaded using the qutip.fileio.file_data_read, which only takes the filename as mandatory argument.; In [30]: input_data = file_data_read('expect.dat'). In [31]: shape(input_data); Out[31]: (100, 4). In [32]: from pylab import *. In [33]: plot(input_data[:,0], input_data[:,1]); # plot the data. (If a particularly obscure choice of deliminator was used it might be necessary to use the optional second argument, for example sep=”_” if _ is the deliminator). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-saving.html
https://qutip.org/docs/4.0.2/guide/guide-saving.html:2145,Usability,simpl,simple,2145,"back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [1]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [2]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; In [3]: qsave(rho_ss, 'steadystate'). In [4]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [5]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True. In [6]: a = destroy(10). In [7]: expect(a.dag() * a, rho_ss_loaded); Out[7]: 0.9902248289345061. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [8]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, ",MatchSource.WIKI,docs/4.0.2/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-saving.html
https://qutip.org/docs/4.0.2/guide/guide-settings.html:1376,Availability,toler,tolerance,1376,"ries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Modifying Internal QuTiP Settings. Modifying Internal QuTiP Settings¶. User Accessible Parameters¶; In this section we show how to modify a few of the internal parameters used by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. atol; General tolerance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for the file .qutiprc in the user’s home directory. If this f",MatchSource.WIKI,docs/4.0.2/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-settings.html
https://qutip.org/docs/4.0.2/guide/guide-settings.html:1764,Availability,toler,tolerance,1764," QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Modifying Internal QuTiP Settings. Modifying Internal QuTiP Settings¶. User Accessible Parameters¶; In this section we show how to modify a few of the internal parameters used by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. atol; General tolerance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for the file .qutiprc in the user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample .qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are describ",MatchSource.WIKI,docs/4.0.2/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-settings.html
https://qutip.org/docs/4.0.2/guide/guide-settings.html:2819,Availability,toler,tolerance,2819,"; Description; Options. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. atol; General tolerance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for the file .qutiprc in the user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample .qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; # QuTiP Graphics; qutip_graphics=""YES""; # use auto tidyup; auto_tidyup=True; # detect hermiticity; auto_herm=True; # use auto tidyup absolute tolerance; auto_tidyup_atol=1e-12; # number of cpus; num_cpus=4; # debug; debug=False. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-settings.html
https://qutip.org/docs/4.0.2/guide/guide-settings.html:3034,Deployability,update,updated,3034,"; Description; Options. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. atol; General tolerance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for the file .qutiprc in the user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample .qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; # QuTiP Graphics; qutip_graphics=""YES""; # use auto tidyup; auto_tidyup=True; # detect hermiticity; auto_herm=True; # use auto tidyup absolute tolerance; auto_tidyup_atol=1e-12; # number of cpus; num_cpus=4; # debug; debug=False. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-settings.html
https://qutip.org/docs/4.0.2/guide/guide-settings.html:2409,Performance,load,loaded,2409,"; Description; Options. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. atol; General tolerance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for the file .qutiprc in the user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample .qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; # QuTiP Graphics; qutip_graphics=""YES""; # use auto tidyup; auto_tidyup=True; # detect hermiticity; auto_herm=True; # use auto tidyup absolute tolerance; auto_tidyup_atol=1e-12; # number of cpus; num_cpus=4; # debug; debug=False. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-settings.html
https://qutip.org/docs/4.0.2/guide/guide-settings.html:2756,Safety,detect,detect,2756,"; Description; Options. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. atol; General tolerance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for the file .qutiprc in the user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample .qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; # QuTiP Graphics; qutip_graphics=""YES""; # use auto tidyup; auto_tidyup=True; # detect hermiticity; auto_herm=True; # use auto tidyup absolute tolerance; auto_tidyup_atol=1e-12; # number of cpus; num_cpus=4; # debug; debug=False. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-settings.html
https://qutip.org/docs/4.0.2/guide/guide-settings.html:1826,Usability,simpl,simple,1826," Quantum Toolbox in Python. Docs »; Users Guide »; Modifying Internal QuTiP Settings. Modifying Internal QuTiP Settings¶. User Accessible Parameters¶; In this section we show how to modify a few of the internal parameters used by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. atol; General tolerance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for the file .qutiprc in the user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample .qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; # QuTiP Graphics; qutip_graphics=""YES""; # use auto tidyup; auto_tidyup=True; # detect hermiticity; auto_herm=True; # use auto tidyup ",MatchSource.WIKI,docs/4.0.2/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-settings.html
https://qutip.org/docs/4.0.2/guide/guide-settings.html:2582,Usability,simpl,simple,2582,"; Description; Options. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. atol; General tolerance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for the file .qutiprc in the user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample .qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; # QuTiP Graphics; qutip_graphics=""YES""; # use auto tidyup; auto_tidyup=True; # detect hermiticity; auto_herm=True; # use auto tidyup absolute tolerance; auto_tidyup_atol=1e-12; # number of cpus; num_cpus=4; # debug; debug=False. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-settings.html
https://qutip.org/docs/4.0.2/guide/guide-states.html:14144,Availability,down,downarrow,14144,"t us use the qutip.operators.sigmaz operator:; In [51]: sigmaz(); Out[51]: ; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. In [52]: sigmaz() * spin; ",MatchSource.WIKI,docs/4.0.2/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-states.html
https://qutip.org/docs/4.0.2/guide/guide-states.html:14843,Availability,down,downarrow,14843,"nswer is now apparent. Since the QuTiP qutip.operators.sigmaz function uses the standard z-basis representation of the sigma-z spin operator, the spin state corresponds to the \(\left|\uparrow\right>\) state of a two-level spin system while spin2 gives the \(\left|\downarrow\right>\) state. Therefore, in our previous example sigmap() * spin, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state.; While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators remain in the conventional form. Second, when the spin system is in the \(\left|\uparrow\right>\) state:; In [56]: sigmaz() * spin; Out[56]: ; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[ 1.]; [ 0.]]. the non-zero component is the zeroth-element of the underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The \(\left|\downarrow\right>\) state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited \(\left|\uparrow\right>\) state is label as \(\left|0\right>\), and the \(\left|\downarrow\right>\) state by \(\left|1\right>\).; If one wants to create spin operators for higher spin systems, then the qutip.operators.jmat function comes in handy. Expectation values¶; Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the qutip.expect function. To begin:; In [57]: vac = basis(5, 0). In [58]: one = basis(5, 1). In [59]: c = create(5). In [60]: N = num(5). In [61]: expect(N, vac); Out[61]: 0.0. In [62]: expect(N, one); ",MatchSource.WIKI,docs/4.0.2/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-states.html
https://qutip.org/docs/4.0.2/guide/guide-states.html:15109,Availability,down,downarrow,15109,"ponds to the \(\left|\uparrow\right>\) state of a two-level spin system while spin2 gives the \(\left|\downarrow\right>\) state. Therefore, in our previous example sigmap() * spin, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state.; While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators remain in the conventional form. Second, when the spin system is in the \(\left|\uparrow\right>\) state:; In [56]: sigmaz() * spin; Out[56]: ; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[ 1.]; [ 0.]]. the non-zero component is the zeroth-element of the underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The \(\left|\downarrow\right>\) state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited \(\left|\uparrow\right>\) state is label as \(\left|0\right>\), and the \(\left|\downarrow\right>\) state by \(\left|1\right>\).; If one wants to create spin operators for higher spin systems, then the qutip.operators.jmat function comes in handy. Expectation values¶; Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the qutip.expect function. To begin:; In [57]: vac = basis(5, 0). In [58]: one = basis(5, 1). In [59]: c = create(5). In [60]: N = num(5). In [61]: expect(N, vac); Out[61]: 0.0. In [62]: expect(N, one); ",MatchSource.WIKI,docs/4.0.2/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-states.html
https://qutip.org/docs/4.0.2/guide/guide-states.html:17041,Availability,down,down,17041,"arrays of state vectors or density matrices for the second input:; In [67]: states = [(c**k * vac).unit() for k in range(5)] # must normalize. In [68]: expect(N, states); Out[68]: array([ 0., 1., 2., 3., 4.]). In [69]: cat_list = [(basis(5, 4) + x * basis(5, 3)).unit(); ....: for x in [0, 1.0j, -1.0, -1.0j]]; ....: . In [70]: expect(c, cat_list); Out[70]: array([ 0.+0.j, 0.+1.j, -1.+0.j, 0.-1.j]). Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, than the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices.; Of course, the qutip.expect function works for spin states and operators:; In [71]: up = basis(2, 0). In [72]: down = basis(2, 1). In [73]: expect(sigmaz(), up); Out[73]: 1.0. In [74]: expect(sigmaz(), down); ",MatchSource.WIKI,docs/4.0.2/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-states.html
https://qutip.org/docs/4.0.2/guide/guide-states.html:17132,Availability,down,down,17132,"*k * vac).unit() for k in range(5)] # must normalize. In [68]: expect(N, states); Out[68]: array([ 0., 1., 2., 3., 4.]). In [69]: cat_list = [(basis(5, 4) + x * basis(5, 3)).unit(); ....: for x in [0, 1.0j, -1.0, -1.0j]]; ....: . In [70]: expect(c, cat_list); Out[70]: array([ 0.+0.j, 0.+1.j, -1.+0.j, 0.-1.j]). Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, than the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices.; Of course, the qutip.expect function works for spin states and operators:; In [71]: up = basis(2, 0). In [72]: down = basis(2, 1). In [73]: expect(sigmaz(), up); Out[73]: 1.0. In [74]: expect(sigmaz(), down); ",MatchSource.WIKI,docs/4.0.2/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-states.html
https://qutip.org/docs/4.0.2/guide/guide-states.html:37988,Deployability,update,updated,37988,"be shown that a map is completely positive if and only if its Choi matrix; is positive [Wat13]. QuTiP implements this check with the iscp; attribute. As an example, notice that the snippet above already calculates; the Choi matrix of the transpose map by acting it on half of an entangled; pair. We simply need to manually set the dims and superrep attributes to reflect the; structure of the underlying Hilbert space and the chosen representation.; In [139]: J = rho_out. In [140]: J.dims = [[[2], [2]], [[2], [2]]]; .....: J.superrep = 'choi'; .....: . In [142]: print(J.iscp); False. This confirms that the transpose map is not completely positive. On the other hand,; the transpose map does satisfy a weaker condition, namely that it is hermicity preserving.; That is, \(\Lambda(\rho) = (\Lambda(\rho))^\dagger\) for all \(\rho\) such that; \(\rho = \rho^\dagger\). To see this, we note that \((\rho^{\mathrm{T}})^\dagger; = \rho^*\), the complex conjugate of \(\rho\). By assumption, \(\rho = \rho^\dagger; = (\rho^*)^{\mathrm{T}}\), though, such that \(\Lambda(\rho) = \Lambda(\rho^\dagger) = \rho^*\).; We can confirm this by checking the ishp attribute:; In [143]: print(J.ishp); True. Next, we note that the transpose map does preserve the trace of its inputs, such that; \(\operatorname{Tr}(\Lambda[\rho]) = \operatorname{Tr}(\rho)\) for all \(\rho\).; This can be confirmed by the istp attribute:; In [144]: print(J.ishp); True. Finally, a map is called a quantum channel if it always maps valid states to valid; states. Formally, a map is a channel if it is both completely positive and trace preserving.; Thus, QuTiP provides a single attribute to quickly check that this is true.; In [145]: print(J.iscptp); False. In [146]: print(to_super(qeye(2)).iscptp); ",MatchSource.WIKI,docs/4.0.2/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-states.html
https://qutip.org/docs/4.0.2/guide/guide-states.html:11579,Energy Efficiency,energy,energy,11579,"153373552. In [39]: tracedist(y, y); ",MatchSource.WIKI,docs/4.0.2/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-states.html
https://qutip.org/docs/4.0.2/guide/guide-states.html:3788,Integrability,depend,dependence,3788,".]]. The raising operator has in indeed raised the state vec from the vacuum to the \(\left| 1\right>\) state. Instead of using the dagger Qobj.dag() method to raise the state, we could have also used the built in qutip.operators.create function to make a raising operator:; In [7]: c = create(5). In [8]: c * vac; Out[8]: ; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]]. which does the same thing. We can raise the vacuum state more than once by successively apply the raising operator:; In [9]: c * c * vac; Out[9]: ; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0. ]; [ 0. ]; [ 1.41421356]; [ 0. ]; [ 0. ]]. or just taking the square of the raising operator \(\left(\hat{a}^\dagger\right)^{2}\):; In [10]: c ** 2 * vac; Out[10]: ; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0. ]; [ 0. ]; [ 1.41421356]; [ 0. ]; [ 0. ]]. Applying the raising operator twice gives the expected \(\sqrt{n + 1}\) dependence. We can use the product of \(c * a\) to also apply the number operator to the state vector vac:; In [11]: c * a * vac; Out[11]: ; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]]. or on the \(\left| 1\right>\) state:; In [12]: c * a * (c * vac); Out[12]: ; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]]. or the \(\left| 2\right>\) state:; In [13]: c * a * (c**2 * vac); Out[13]: ; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0. ]; [ 0. ]; [ 2.82842712]; [ 0. ]; [ 0. ]]. Notice how in this last example, application of the number operator does not give the expected value \(n=2\), but rather \(2\sqrt{2}\). This is because this last state is not normalized to unity as \(c\left| n\right> = \sqrt{n+1}\left| n+1\right>\). Therefore, we should normalize our vector first:; In [14]: c * a * (c**2 ",MatchSource.WIKI,docs/4.0.2/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-states.html
https://qutip.org/docs/4.0.2/guide/guide-states.html:20532,Modifiability,extend,extended,20532,"trices, often called superoperators.; Using the Qobj, the spre and spost functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed.; In [93]: X = sigmax(). In [94]: S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the to_super function when given; type='oper' input.; In [95]: S2 = to_super(X). In [96]: (S - S2).norm(); Out[96]: 0.0. Quantum objects representing superoperators are denoted by type='super':; In [97]: S; Out[97]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[ 0. 0. 0. 1.]; [ 0. 0. 1. 0.]; [ 0. 1. 0. 0.]; [ 1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the iscp, istp; and iscptp attributes:; In [98]: S.iscp, S.istp, S.iscptp; Out[98]: (True, True, True). In addition, dynamical generators on this extended space, often called; Liouvillian superoperators, can be created using the liouvillian function. Each of these takes a Hamilonian along with; a list of collapse operators, and returns a type=""super"" object that can; be exponentiated to find the superoperator for that evolution.; In [99]: H = 10 * sigmaz(). In [100]: c1 = destroy(2). In [101]: L = liouvillian(H, [c1]). In [102]: L; Out[102]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[ 0.0 +0.j 0.0 +0.j 0.0 +0.j 1.0 +0.j]; [ 0.0 +0.j -0.5+20.j 0.0 +0.j 0.0 +0.j]; [ 0.0 +0.j 0.0 +0.j -0.5-20.j 0.0 +0.j]; [ 0.0 +0.j 0.0 +0.j 0.0 +0.j -1.0 +0.j]]. In [103]: S = (12 * L).expm(). For qubits, a particularly useful way to visualize superoperators is to plot them in the Pauli basis,; such that \(S_{\mu,\nu} = \langle\!\langle \sigma_{\mu} | S[\sigma_{\nu}] \rangle\!\rangle\). Because; the Pauli basis is Hermitian, \(S_{\mu,\nu}\) is a real number for all Hermitian-preserving superoperators; \(S\),; a",MatchSource.WIKI,docs/4.0.2/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-states.html
https://qutip.org/docs/4.0.2/guide/guide-states.html:1297,Performance,perform,performing,1297,"s; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators; Choi, Kraus, Stinespring and \(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Manipulating States and Operators. Manipulating States and Operators¶. Introduction¶; In the previous guide section Basic Operations on Quantum Objects, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the tutorials web page. State Vectors (kets or bras)¶; Here we begin by creating a Fock qutip.states.basis vacuum state vector \(\left|0\right>\) with in a Hilbert space with 5 number states, from 0 to 4:; In [1]: vac = basis(5, 0). In [2]: vac; Out[2]: ; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 1.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]]. and then create a lowering operator \(\left(\hat{a}\right)\) corresponding to 5 number states using the qutip.operators.destroy function:; In [3]: a = destroy(5). In [4]: a; Out[4]: ; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = False; Qobj data =; [[ 0. 1. 0. 0. 0. ]; [ 0. 0. 1.41421356 0. 0. ]; [ 0. 0. 0. 1.73205081 0. ]; [ 0. 0. 0. 0. 2. ]; [ 0. 0. 0. 0. 0. ]]. Now lets apply the destruction operator to our vacuum state vac,; In [5]: a * vac; Out[5",MatchSource.WIKI,docs/4.0.2/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-states.html
https://qutip.org/docs/4.0.2/guide/guide-states.html:35212,Performance,perform,perform,35212,"[ 0.0+0.j 0.1+0.j 0.0+0.1j 0.0+0.j ]; [ 0.0+0.j 0.0-0.1j 0.1+0.j 0.0+0.j ]; [ 0.1+0.j 0.0+0.j 0.0+0.j 0.1+0.j ]]. One convenient property of the \(\chi\) matrix is that the average; gate fidelity with the identity map can be read off directly from; the \(\chi_{00}\) element:; In [134]: print(average_gate_fidelity(S)); 0.95. In [135]: print(chi[0, 0] / 4); ",MatchSource.WIKI,docs/4.0.2/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-states.html
https://qutip.org/docs/4.0.2/guide/guide-states.html:20370,Security,expose,exposed,20370,"], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[ 0.]; [ 2.]; [ 1.]; [ 3.]]. Since \(\mathcal{H} \otimes \mathcal{H}\) is a vector space, linear maps; on this space can be represented as matrices, often called superoperators.; Using the Qobj, the spre and spost functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed.; In [93]: X = sigmax(). In [94]: S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the to_super function when given; type='oper' input.; In [95]: S2 = to_super(X). In [96]: (S - S2).norm(); Out[96]: 0.0. Quantum objects representing superoperators are denoted by type='super':; In [97]: S; Out[97]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[ 0. 0. 0. 1.]; [ 0. 0. 1. 0.]; [ 0. 1. 0. 0.]; [ 1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the iscp, istp; and iscptp attributes:; In [98]: S.iscp, S.istp, S.iscptp; Out[98]: (True, True, True). In addition, dynamical generators on this extended space, often called; Liouvillian superoperators, can be created using the liouvillian function. Each of these takes a Hamilonian along with; a list of collapse operators, and returns a type=""super"" object that can; be exponentiated to find the superoperator for that evolution.; In [99]: H = 10 * sigmaz(). In [100]: c1 = destroy(2). In [101]: L = liouvillian(H, [c1]). In [102]: L; Out[102]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[ 0.0 +0.j 0.0 +0.j 0.0 +0.j 1.0 +0.j]; [ 0.0 +0.j -0.5+20.j 0.0 +0.j 0.0 +0.j]; [ 0.0 +0.j 0.0 +0.j -0.5-20.j 0.0 +0.j]; [ 0.0 +0.j 0.0 +0.j 0.0 +0.j -1.0 +0.j]]. In [103]: S = (12 * L).expm(). For qubits, a particularly useful way to visualize superoperators is to plot them in the Pauli basis,; such that \(S",MatchSource.WIKI,docs/4.0.2/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-states.html
https://qutip.org/docs/4.0.2/guide/guide-states.html:1119,Usability,guid,guide,1119," Basic Operations on Quantum Objects; Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators; Choi, Kraus, Stinespring and \(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Manipulating States and Operators. Manipulating States and Operators¶. Introduction¶; In the previous guide section Basic Operations on Quantum Objects, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the tutorials web page. State Vectors (kets or bras)¶; Here we begin by creating a Fock qutip.states.basis vacuum state vector \(\left|0\right>\) with in a Hilbert space with 5 number states, from 0 to 4:; In [1]: vac = basis(5, 0). In [2]: vac; Out[2]: ; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 1.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]]. and then create a lowering operator \(\left(\hat{a}\right)\) corresponding to 5 number states using the qutip.operators.destroy function:; In [3]: a = destroy(5). In [4]: a; Out[4]: ; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = False; Qobj data =; [[ 0. 1. 0. 0. 0. ]; [ 0. 0. 1.41421356 0. 0. ]; [ 0. 0. 0. 1.73205081 0. ",MatchSource.WIKI,docs/4.0.2/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-states.html
https://qutip.org/docs/4.0.2/guide/guide-states.html:1274,Usability,guid,guide,1274,"s; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators; Choi, Kraus, Stinespring and \(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Manipulating States and Operators. Manipulating States and Operators¶. Introduction¶; In the previous guide section Basic Operations on Quantum Objects, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the tutorials web page. State Vectors (kets or bras)¶; Here we begin by creating a Fock qutip.states.basis vacuum state vector \(\left|0\right>\) with in a Hilbert space with 5 number states, from 0 to 4:; In [1]: vac = basis(5, 0). In [2]: vac; Out[2]: ; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 1.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]]. and then create a lowering operator \(\left(\hat{a}\right)\) corresponding to 5 number states using the qutip.operators.destroy function:; In [3]: a = destroy(5). In [4]: a; Out[4]: ; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = False; Qobj data =; [[ 0. 1. 0. 0. 0. ]; [ 0. 0. 1.41421356 0. 0. ]; [ 0. 0. 0. 1.73205081 0. ]; [ 0. 0. 0. 0. 2. ]; [ 0. 0. 0. 0. 0. ]]. Now lets apply the destruction operator to our vacuum state vac,; In [5]: a * vac; Out[5",MatchSource.WIKI,docs/4.0.2/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-states.html
https://qutip.org/docs/4.0.2/guide/guide-states.html:7658,Usability,simpl,simplest,7658,"Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.60655682+0.j ]; [ 0.00000000+0.60628133j]; [-0.43038740+0.j ]; [ 0.00000000-0.24104351j]; [ 0.14552147+0.j ]]. In [27]: d * s * vac; Out[27]: ; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.65893786+0.08139381j]; [ 0.10779462+0.51579735j]; [-0.37567217-0.01326853j]; [-0.02688063-0.23828775j]; [ 0.26352814+0.11512178j]]. Of course, displacing the vacuum gives a coherent state, which can also be generated using the built in qutip.states.coherent function. Density matrices¶; One of the main purpose of QuTiP is to explore the dynamics of open quantum systems, where the most general state of a system is not longer a state vector, but rather a density matrix. Since operations on density matrices operate identically to those of vectors, we will just briefly highlight creating and using these structures.; The simplest density matrix is created by forming the outer-product \(\left|\psi\right>\left<\psi\right|\) of a ket vector:; In [28]: ket = basis(5, 2). In [29]: ket * ket.dag(); Out[29]: ; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[ 0. 0. 0. 0. 0.]; [ 0. 0. 0. 0. 0.]; [ 0. 0. 1. 0. 0.]; [ 0. 0. 0. 0. 0.]; [ 0. 0. 0. 0. 0.]]. A similar task can also be accomplished via the qutip.states.fock_dm or qutip.states.ket2dm functions:; In [30]: fock_dm(5, 2); Out[30]: ; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[ 0. 0. 0. 0. 0.]; [ 0. 0. 0. 0. 0.]; [ 0. 0. 1. 0. 0.]; [ 0. 0. 0. 0. 0.]; [ 0. 0. 0. 0. 0.]]. In [31]: ket2dm(ket); Out[31]: ; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[ 0. 0. 0. 0. 0.]; [ 0. 0. 0. 0. 0.]; [ 0. 0. 1. 0. 0.]; [ 0. 0. 0. 0. 0.]; [ 0. 0. 0. 0. 0.]]. If we want to create a density matrix with equal classical probability of being found in the \(\left|2\right>\) or \(\left|4\right>\) number state",MatchSource.WIKI,docs/4.0.2/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-states.html
https://qutip.org/docs/4.0.2/guide/guide-states.html:23930,Usability,simpl,simply,23930,"to_choi(S). In [107]: print(J); Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[ 0. 0. 0. 0.]; [ 0. 1. 1. 0.]; [ 0. 1. 1. 0.]; [ 0. 0. 0. 0.]]. In [108]: print(to_choi(spre(qeye(2)))); ",MatchSource.WIKI,docs/4.0.2/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-states.html
https://qutip.org/docs/4.0.2/guide/guide-states.html:36375,Usability,simpl,simply,36375," \rho^{\mathrm{T}}\) is a positive map. We run into; problems, however, if we tensor \(\Lambda\) with the identity to get a partial; transpose map.; In [136]: rho = ket2dm(bell_state()). In [137]: rho_out = partial_transpose(rho, [0, 1]); .....: print(rho_out.eigenenergies()); .....: ; [-0.5 0.5 0.5 0.5]. Notice that even though we started with a positive map, we got an operator out; with negative eigenvalues. Complete positivity addresses this by requiring that; a map returns positive operators for all positive operators, and does so even; under tensoring with another map. The Choi matrix is very useful here, as it; can be shown that a map is completely positive if and only if its Choi matrix; is positive [Wat13]. QuTiP implements this check with the iscp; attribute. As an example, notice that the snippet above already calculates; the Choi matrix of the transpose map by acting it on half of an entangled; pair. We simply need to manually set the dims and superrep attributes to reflect the; structure of the underlying Hilbert space and the chosen representation.; In [139]: J = rho_out. In [140]: J.dims = [[[2], [2]], [[2], [2]]]; .....: J.superrep = 'choi'; .....: . In [142]: print(J.iscp); False. This confirms that the transpose map is not completely positive. On the other hand,; the transpose map does satisfy a weaker condition, namely that it is hermicity preserving.; That is, \(\Lambda(\rho) = (\Lambda(\rho))^\dagger\) for all \(\rho\) such that; \(\rho = \rho^\dagger\). To see this, we note that \((\rho^{\mathrm{T}})^\dagger; = \rho^*\), the complex conjugate of \(\rho\). By assumption, \(\rho = \rho^\dagger; = (\rho^*)^{\mathrm{T}}\), though, such that \(\Lambda(\rho) = \Lambda(\rho^\dagger) = \rho^*\).; We can confirm this by checking the ishp attribute:; In [143]: print(J.ishp); True. Next, we note that the transpose map does preserve the trace of its inputs, such that; \(\operatorname{Tr}(\Lambda[\rho]) = \operatorname{Tr}(\rho)\) for all \(\rho\).; This can ",MatchSource.WIKI,docs/4.0.2/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-states.html
https://qutip.org/docs/4.0.2/guide/guide-steady.html:5487,Availability,down,downside,5487,"n be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. However, in most cases, the default fill-in reducing algorithm is nearly optimal. Additional parameters may be used by calling the steady-state solver as:; rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on a bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'iterative-gmres', 'iterative-lgmres', and 'iterative-bicgstab' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. To overcome this, one can use a preconditioner \(M\) that solves for an approximate inverse for the (modified) Liouvillian, thus better conditioning the problem, leading to faster convergence. The use of a preconditioner can actually make these iterative methods faster than the other solution methods. The problem with precondioning is that it is only well defined for Hermitian matrices. Since the Liouvillian is non-Hermitian, the ability to find a good preconditioner is not guaranteed. And moreover, if a preconditioner is found, it is not guaranteed to have a good condition number. QuTiP can make use of an incomplete LU preconditioner when using the iterative 'gmres', 'lgmres', and 'bicgstab' solvers by setting use_precond=True. The preconditioner optionally makes use of a combination of symmetric and anti-symmetric matrix permutations that attempt to improve the precond",MatchSource.WIKI,docs/4.0.2/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-steady.html
