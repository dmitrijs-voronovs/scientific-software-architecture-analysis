id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:9,Testability,log,logic,9,"/// Adds logic in the loopBody MBB to generate MVE_VCTP, t2DoLoopDec and; /// t2DoLoopEnd. These are used by later passes to generate tail predicated; /// loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:23,Performance,load,loads,23,// Thumb1 post-indexed loads are really just single-register LDMs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate the required MBBs and add to parent function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:504,Deployability,update,updated,504,"// If any instructions are present in the current block after; // MVE_MEMCPYLOOPINST or MVE_MEMSETLOOPINST, split the current block and; // move the instructions into the newly created exit block. If there are no; // instructions add an explicit branch to the FallThrough block and then; // split.; //; // The split is required for two reasons:; // 1) A terminator(t2WhileLoopStart) will be placed at that site.; // 2) Since a TPLoopBody will be added later, any phis in successive blocks; // need to be updated. splitAt() already handles this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:7,Testability,log,logic,7,// Add logic for iteration count,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:39,Performance,load,loads,39,// Add the vectorized (and predicated) loads/store instructions,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:15,Safety,avoid,avoid,15,// Required to avoid conflict with the MachineVerifier during testing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:62,Testability,test,testing,62,// Required to avoid conflict with the MachineVerifier during testing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:3,Deployability,Update,Update,3,// Update machine-CFG edges,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:143,Testability,test,test,143,"// To insert an ABS instruction, we have to insert the; // diamond control-flow pattern. The incoming instruction knows the; // source vreg to test against 0, the destination vreg to set,; // the condition code register to branch on, the; // true/false values to select between, and a branch opcode to use.; // It transforms; // V1 = ABS V0; // into; // V2 = MOVS V0; // BCC (branch to SinkBB if V0 >= 0); // RSBBB: V3 = RSBri V2, 0 (compute ABS if V2 < 0); // SinkBB: V1 = PHI(V2, V3)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:267,Availability,redundant,redundant,267,"// Adjust potentially 's' setting instructions after isel, i.e. ADC, SBC, RSB,; // RSC. Coming out of isel, they have an implicit CPSR def, but the optional; // operand is still set to noreg. If needed, set the optional operand's; // register to CPSR, and remove the redundant implicit def.; //; // e.g. ADCS (..., implicit-def CPSR) -> ADC (... opt:def CPSR).; // Rename pseudo opcodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:267,Safety,redund,redundant,267,"// Adjust potentially 's' setting instructions after isel, i.e. ADC, SBC, RSB,; // RSC. Coming out of isel, they have an implicit CPSR def, but the optional; // operand is still set to noreg. If needed, set the optional operand's; // register to CPSR, and remove the redundant implicit def.; //; // e.g. ADCS (..., implicit-def CPSR) -> ADC (... opt:def CPSR).; // Rename pseudo opcodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:89,Performance,Optimiz,Optimization,89,//===----------------------------------------------------------------------===//; // ARM Optimization Hooks; //===----------------------------------------------------------------------===//; // Helper function that checks if N is a null or all ones constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:56,Safety,Detect,Detects,56,"// Return true if N is conditionally 0 or all ones.; // Detects these expressions where cc is an i1 value:; //; // (select cc 0, y) [AllOnes=0]; // (select cc y, 0) [AllOnes=0]; // (zext cc) [AllOnes=0]; // (sext cc) [AllOnes=0/1]; // (select cc -1, y) [AllOnes=1]; // (select cc y, -1) [AllOnes=1]; //; // Invert is set when N is the null/all ones constant when CC is false.; // OtherOp is set to the alternative value of N.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:1015,Availability,failure,failure,1015,"// Combine a constant select operand into its use:; //; // (add (select cc, 0, c), x) -> (select cc, x, (add, x, c)); // (sub x, (select cc, 0, c)) -> (select cc, x, (sub, x, c)); // (and (select cc, -1, c), x) -> (select cc, x, (and, x, c)) [AllOnes=1]; // (or (select cc, 0, c), x) -> (select cc, x, (or, x, c)); // (xor (select cc, 0, c), x) -> (select cc, x, (xor, x, c)); //; // The transform is rejected if the select doesn't have a constant operand that; // is null, or all ones when AllOnes is set.; //; // Also recognize sext/zext from i1:; //; // (add (zext cc), x) -> (select cc (add x, 1), x); // (add (sext cc), x) -> (select cc (add x, -1), x); //; // These transformations eventually create predicated instructions.; //; // @param N The node to transform.; // @param Slct The N operand that is a select.; // @param OtherOp The other N operand (x above).; // @param DCI Context.; // @param AllOnes Require the select constant to be all ones instead of null.; // @returns The new node, or SDValue() on failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:17,Modifiability,extend,extended,17,// Check for two extended operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:31,Integrability,depend,depending,31,// Form vpaddl.sN or vpaddl.uN depending on the kind of extension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:63,Availability,avail,available,63,"// Only perform optimization if after legalize, and if NEON is available. We; // also expected both operands to be BUILD_VECTORs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:8,Performance,perform,perform,8,"// Only perform optimization if after legalize, and if NEON is available. We; // also expected both operands to be BUILD_VECTORs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:16,Performance,optimiz,optimization,16,"// Only perform optimization if after legalize, and if NEON is available. We; // also expected both operands to be BUILD_VECTORs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:153,Modifiability,extend,extended,153,"// SMLALBB, SMLALBT, SMLALTB, SMLALTT multiply two 16-bit values and; // accumulates the product into a 64-bit value. The 16-bit values will; // be sign extended somehow or SRA'd into 32-bit values; // (addc (adde (mul 16bit, 16bit), lo), hi)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:403,Performance,loAd,loAdd,403,"// Look for multiply add opportunities.; // The pattern is a ISD::UMUL_LOHI followed by two add nodes, where; // each add nodes consumes a value from ISD::UMUL_LOHI and there is; // a glue link from the first add to the second add.; // If we find this pattern, we can replace the U/SMUL_LOHI, ADDC, and ADDE by; // a S/UMLAL instruction.; // UMUL_LOHI; // / :lo \ :hi; // V \ [no multiline comment]; // loAdd -> ADDC |; // \ :carry /; // V V; // ADDE <- hiAdd; //; // In the special case where only the higher part of a signed result is used; // and the add to the low part of the result of ISD::UMUL_LOHI adds or subtracts; // a constant with the exact value of 0x80000000, we recognize we are dealing; // with a ""rounded multiply and add"" (or subtract) and transform it into; // either a ARMISD::SMMLAR or ARMISD::SMMLSR respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:328,Performance,Perform,PerformUMLALCombine,328,"// UMAAL is similar to UMLAL except that it adds two unsigned values.; // While trying to combine for the other MLAL nodes, first search for the; // chance to use UMAAL. Check if Addc uses a node which has already; // been combined into a UMLAL. The other pattern is UMLAL using Addc/Adde; // as the addend, and it's handled in PerformUMLALCombine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:28,Energy Efficiency,reduce,reduced,28,// The types must match the reduced type too,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:121,Deployability,patch,patch,121,"// A special combine for the vqdmulh family of instructions. This is one of the; // potential set of patterns that could patch this instruction. The base pattern; // you would expect to be min(max(ashr(mul(mul(sext(x), 2), sext(y)), 16))).; // This matches the different min(max(ashr(mul(mul(sext(x), sext(y)), 2), 16))),; // which llvm will have optimized to min(ashr(mul(sext(x), sext(y)), 15))) as; // the max is unnecessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:347,Performance,optimiz,optimized,347,"// A special combine for the vqdmulh family of instructions. This is one of the; // potential set of patterns that could patch this instruction. The base pattern; // you would expect to be min(max(ashr(mul(mul(sext(x), 2), sext(y)), 16))).; // This matches the different min(max(ashr(mul(mul(sext(x), sext(y)), 2), 16))),; // which llvm will have optimized to min(ashr(mul(sext(x), sext(y)), 15))) as; // the max is unnecessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:3,Safety,Detect,Detect,3,"// Detect a SMIN, which for an i64 node will be a vselect/setcc, not a smin.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:40,Modifiability,extend,extend,40,// For types smaller than legal vectors extend to be legal and only use needed; // lanes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:110,Performance,optimiz,optimization,110,"// Transforms vselect(not(cond), lhs, rhs) into vselect(cond, rhs, lhs).; //; // We need to re-implement this optimization here as the implementation in the; // Target-Independent DAGCombiner does not handle the kind of constant we make; // (it calls isConstOrConstSplat with AllowTruncation set to false - and for; // good reason, allowing truncation there would break other targets).; //; // Currently, this is only done for MVE, as it's the only target that benefits; // from this transformation (e.g. VPNOT+VPSEL becomes a single VPSEL).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:3,Modifiability,Rewrite,Rewrite,3,"// Rewrite into vselect(cond, rhs, lhs).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:4,Performance,Perform,PerformADDECombine,4,"/// PerformADDECombine - Target-specific dag combine transform from; /// ARMISD::ADDC, ARMISD::ADDE, and ISD::MUL_LOHI to MLAL or; /// ARMISD::ADDC, ARMISD::ADDE and ARMISD::UMLAL to ARMISD::UMAAL",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:62,Availability,avail,available,62,// Only perform the checks after legalize when the pattern is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:8,Performance,perform,perform,8,// Only perform the checks after legalize when the pattern is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:4,Performance,Perform,PerformADDCombineWithOperands,4,"/// PerformADDCombineWithOperands - Try DAG combinations for an ADD with; /// operands N0 and N1. This is a helper for PerformADDCombine that is; /// called with the default operands, and if that fails, with commuted; /// operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:119,Performance,Perform,PerformADDCombine,119,"/// PerformADDCombineWithOperands - Try DAG combinations for an ADD with; /// operands N0 and N1. This is a helper for PerformADDCombine that is; /// called with the default operands, and if that fails, with commuted; /// operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:23,Energy Efficiency,reduce,reduce,23,"// And turn add(add(A, reduce(B)), add(C, reduce(D))) ->; // add(add(add(A, C), reduce(B)), reduce(D))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:42,Energy Efficiency,reduce,reduce,42,"// And turn add(add(A, reduce(B)), add(C, reduce(D))) ->; // add(add(add(A, C), reduce(B)), reduce(D))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:80,Energy Efficiency,reduce,reduce,80,"// And turn add(add(A, reduce(B)), add(C, reduce(D))) ->; // add(add(add(A, C), reduce(B)), reduce(D))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:92,Energy Efficiency,reduce,reduce,92,"// And turn add(add(A, reduce(B)), add(C, reduce(D))) ->; // add(add(add(A, C), reduce(B)), reduce(D))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:28,Performance,load,load,28,"// Distribute add(vecreduce(load(Y)), vecreduce(load(Z))); // Or add(add(X, vecreduce(load(Y))), vecreduce(load(Z))); // by ascending load offsets. This can help cores prefetch if the order of; // loads is more predictable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:48,Performance,load,load,48,"// Distribute add(vecreduce(load(Y)), vecreduce(load(Z))); // Or add(add(X, vecreduce(load(Y))), vecreduce(load(Z))); // by ascending load offsets. This can help cores prefetch if the order of; // loads is more predictable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:86,Performance,load,load,86,"// Distribute add(vecreduce(load(Y)), vecreduce(load(Z))); // Or add(add(X, vecreduce(load(Y))), vecreduce(load(Z))); // by ascending load offsets. This can help cores prefetch if the order of; // loads is more predictable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:107,Performance,load,load,107,"// Distribute add(vecreduce(load(Y)), vecreduce(load(Z))); // Or add(add(X, vecreduce(load(Y))), vecreduce(load(Z))); // by ascending load offsets. This can help cores prefetch if the order of; // loads is more predictable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:134,Performance,load,load,134,"// Distribute add(vecreduce(load(Y)), vecreduce(load(Z))); // Or add(add(X, vecreduce(load(Y))), vecreduce(load(Z))); // by ascending load offsets. This can help cores prefetch if the order of; // loads is more predictable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:197,Performance,load,loads,197,"// Distribute add(vecreduce(load(Y)), vecreduce(load(Z))); // Or add(add(X, vecreduce(load(Y))), vecreduce(load(Z))); // by ascending load offsets. This can help cores prefetch if the order of; // loads is more predictable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:211,Safety,predict,predictable,211,"// Distribute add(vecreduce(load(Y)), vecreduce(load(Z))); // Or add(add(X, vecreduce(load(Y))), vecreduce(load(Z))); // by ascending load offsets. This can help cores prefetch if the order of; // loads is more predictable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:40,Performance,load,load,40,"// Check if two reductions are known to load data where one is before/after; // another. Return negative if N0 loads data before N1, positive if N1 is; // before N0 and 0 otherwise if nothing is known.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:111,Performance,load,loads,111,"// Check if two reductions are known to load data where one is before/after; // another. Return negative if N0 loads data before N1, positive if N1 is; // before N0 and 0 otherwise if nothing is known.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:39,Performance,load,loads,39,// Return true if the two operands are loads to the same object and the; // offset of the first is known to be less than the offset of the second.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:68,Energy Efficiency,reduce,reduce,68,"// Note this is backward to how you would expect. We create; // add(reduce(load + 16), reduce(load + 0)) so that the; // add(reduce(load+16), X) is combined into VADDVA(X, load+16)), leaving; // the X as VADDV(load + 0)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:87,Energy Efficiency,reduce,reduce,87,"// Note this is backward to how you would expect. We create; // add(reduce(load + 16), reduce(load + 0)) so that the; // add(reduce(load+16), X) is combined into VADDVA(X, load+16)), leaving; // the X as VADDV(load + 0)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:125,Energy Efficiency,reduce,reduce,125,"// Note this is backward to how you would expect. We create; // add(reduce(load + 16), reduce(load + 0)) so that the; // add(reduce(load+16), X) is combined into VADDVA(X, load+16)), leaving; // the X as VADDV(load + 0)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:75,Performance,load,load,75,"// Note this is backward to how you would expect. We create; // add(reduce(load + 16), reduce(load + 0)) so that the; // add(reduce(load+16), X) is combined into VADDVA(X, load+16)), leaving; // the X as VADDV(load + 0)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:94,Performance,load,load,94,"// Note this is backward to how you would expect. We create; // add(reduce(load + 16), reduce(load + 0)) so that the; // add(reduce(load+16), X) is combined into VADDVA(X, load+16)), leaving; // the X as VADDV(load + 0)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:132,Performance,load,load,132,"// Note this is backward to how you would expect. We create; // add(reduce(load + 16), reduce(load + 0)) so that the; // add(reduce(load+16), X) is combined into VADDVA(X, load+16)), leaving; // the X as VADDV(load + 0)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:172,Performance,load,load,172,"// Note this is backward to how you would expect. We create; // add(reduce(load + 16), reduce(load + 0)) so that the; // add(reduce(load+16), X) is combined into VADDVA(X, load+16)), leaving; // the X as VADDV(load + 0)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:210,Performance,load,load,210,"// Note this is backward to how you would expect. We create; // add(reduce(load + 16), reduce(load + 0)) so that the; // add(reduce(load+16), X) is combined into VADDVA(X, load+16)), leaving; // the X as VADDV(load + 0)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:286,Usability,simpl,simplified,286,"// We are looking for a i64 add of a VADDLVx. Due to these being i64's, this; // will look like:; // t1: i32,i32 = ARMISD::VADDLVs x; // t2: i64 = build_pair t1, t1:1; // t3: i64 = add t2, y; // Otherwise we try to push the add up above VADDLVAx, to potentially allow; // the add to be simplified seperately.; // We also need to check for sext / zext and commutitive adds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:3,Safety,Avoid,Avoid,3,// Avoid making expensive immediates by commuting shifts. (This logic; // only applies to Thumb1 because ARM and Thumb2 immediates can be shifted; // for free.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:64,Testability,log,logic,64,// Avoid making expensive immediates by commuting shifts. (This logic; // only applies to Thumb1 because ARM and Thumb2 immediates can be shifted; // for free.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:93,Performance,Perform,PerformSHLSimplify,93,"// Turn off commute-with-shift transform after legalization, so it doesn't; // conflict with PerformSHLSimplify. (We could try to detect when; // PerformSHLSimplify would trigger more precisely, but it isn't; // really necessary.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:146,Performance,Perform,PerformSHLSimplify,146,"// Turn off commute-with-shift transform after legalization, so it doesn't; // conflict with PerformSHLSimplify. (We could try to detect when; // PerformSHLSimplify would trigger more precisely, but it isn't; // really necessary.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:130,Safety,detect,detect,130,"// Turn off commute-with-shift transform after legalization, so it doesn't; // conflict with PerformSHLSimplify. (We could try to detect when; // PerformSHLSimplify would trigger more precisely, but it isn't; // really necessary.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:34,Availability,mask,mask,34,// Only commute if the entire NOT mask is a hidden shifted mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:59,Availability,mask,mask,59,// Only commute if the entire NOT mask is a hidden shifted mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:342,Performance,perform,perform,342,"// DAG combiner will fold:; // (shl (add x, c1), c2) -> (add (shl x, c2), c1 << c2); // (shl (or x, c1), c2) -> (or (shl x, c2), c1 << c2; // Other code patterns that can be also be modified have the following form:; // b + ((a << 1) | 510); // b + ((a << 1) & 510); // b + ((a << 1) ^ 510); // b + ((a << 1) + 510); // Many instructions can perform the shift for free, but it requires both; // the operands to be registers. If c1 << c2 is too large, a mov immediate; // instruction will needed. So, unfold back to the original pattern if:; // - if c1 and c2 are small enough that they don't require mov imms.; // - the user(s) of the node can perform an shl; // No shifted operands for 16-bit instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:644,Performance,perform,perform,644,"// DAG combiner will fold:; // (shl (add x, c1), c2) -> (add (shl x, c2), c1 << c2); // (shl (or x, c1), c2) -> (or (shl x, c2), c1 << c2; // Other code patterns that can be also be modified have the following form:; // b + ((a << 1) | 510); // b + ((a << 1) & 510); // b + ((a << 1) ^ 510); // b + ((a << 1) + 510); // Many instructions can perform the shift for free, but it requires both; // the operands to be registers. If c1 << c2 is too large, a mov immediate; // instruction will needed. So, unfold back to the original pattern if:; // - if c1 and c2 are small enough that they don't require mov imms.; // - the user(s) of the node can perform an shl; // No shifted operands for 16-bit instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:34,Performance,perform,perform,34,// Check that all the users could perform the shl themselves.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:14,Performance,perform,performing,14,// Check that performing a lshr will not lose any information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:4,Performance,Perform,PerformADDCombine,4,/// PerformADDCombine - Target-specific dag combine xforms for ISD::ADD.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:4,Performance,Perform,PerformSUBCombine,4,/// PerformSUBCombine - Target-specific dag combine xforms for ISD::SUB.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:4,Performance,Perform,PerformVMULCombine,4,"/// PerformVMULCombine; /// Distribute (A + B) * C to (A * C) + (B * C) to take advantage of the; /// special multiplier accumulator forwarding.; /// vmul d3, d0, d2; /// vmla d3, d1, d2; /// is faster than; /// vadd d3, d0, d1; /// vmul d3, d3, d2; // However, for (A + B) * (A + B),; // vadd d2, d0, d1; // vmul d3, d0, d2; // vmla d3, d1, d2; // is slower than; // vadd d2, d0, d1; // vmul d3, d2, d2",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:142,Availability,mask,mask,142,"// Zero extends are a little more awkward. At the point we are matching; // this, we are looking for an AND with a (-1, 0, -1, 0) buildvector mask.; // That might be before of after a bitcast depending on how the and is; // placed. Because this has to look through bitcasts, it is currently only; // supported on LE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:192,Integrability,depend,depending,192,"// Zero extends are a little more awkward. At the point we are matching; // this, we are looking for an AND with a (-1, 0, -1, 0) buildvector mask.; // That might be before of after a bitcast depending on how the and is; // placed. Because this has to look through bitcasts, it is currently only; // supported on LE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:8,Modifiability,extend,extends,8,"// Zero extends are a little more awkward. At the point we are matching; // this, we are looking for an AND with a (-1, 0, -1, 0) buildvector mask.; // That might be before of after a bitcast depending on how the and is; // placed. Because this has to look through bitcasts, it is currently only; // supported on LE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:19,Usability,ux,uxtb,19,// Don't transform uxtb/uxth.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:24,Usability,ux,uxth,24,// Don't transform uxtb/uxth.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:32,Availability,mask,mask,32,// Clear irrelevant bits in the mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:3,Usability,Clear,Clear,3,// Clear irrelevant bits in the mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:109,Availability,mask,mask,109,"// We have a pattern of the form ""(and (shl x, c2) c1)"" or; // ""(and (srl x, c2) c1)"", where c1 is a shifted mask. Try to; // transform to a pair of shifts, to save materializing c1.; // First pattern: right shift, then mask off leading bits.; // FIXME: Use demanded bits?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:220,Availability,mask,mask,220,"// We have a pattern of the form ""(and (shl x, c2) c1)"" or; // ""(and (srl x, c2) c1)"", where c1 is a shifted mask. Try to; // transform to a pair of shifts, to save materializing c1.; // First pattern: right shift, then mask off leading bits.; // FIXME: Use demanded bits?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:45,Availability,mask,mask,45,"// First pattern, reversed: left shift, then mask off trailing bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:36,Availability,mask,mask,36,"// Second pattern: left shift, then mask off leading bits.; // FIXME: Use demanded bits?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:47,Availability,mask,mask,47,"// Second pattern, reversed: right shift, then mask off trailing bits.; // FIXME: Handle other patterns of known/demanded bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:195,Modifiability,extend,extended,195,"// Now we have:; // (or (srl (smul_lohi ?, ?), 16), (shl (smul_lohi ?, ?), 16))); // For SMUL[B|T] smul_lohi will take a 32-bit and a 16-bit arguments.; // For SMUWB the 16-bit value will signed extended somehow.; // For SMULWT only the SRA is required.; // Check both sides of SMUL_LOHI",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:15,Availability,avail,available,15,// BFI is only available on V6T2+,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:17,Availability,mask,mask,17,"// 1) or (and A, mask), val => ARMbfi A, val, mask; // iff (val & mask) == val; //; // 2) or (and A, mask), (and B, mask2) => ARMbfi A, (lsr B, amt), mask; // 2a) iff isBitFieldInvertedMask(mask) && isBitFieldInvertedMask(~mask2); // && mask == ~mask2; // 2b) iff isBitFieldInvertedMask(~mask) && isBitFieldInvertedMask(mask2); // && ~mask == mask2; // (i.e., copy a bitfield value into another bitfield of the same width)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:46,Availability,mask,mask,46,"// 1) or (and A, mask), val => ARMbfi A, val, mask; // iff (val & mask) == val; //; // 2) or (and A, mask), (and B, mask2) => ARMbfi A, (lsr B, amt), mask; // 2a) iff isBitFieldInvertedMask(mask) && isBitFieldInvertedMask(~mask2); // && mask == ~mask2; // 2b) iff isBitFieldInvertedMask(~mask) && isBitFieldInvertedMask(mask2); // && ~mask == mask2; // (i.e., copy a bitfield value into another bitfield of the same width)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:66,Availability,mask,mask,66,"// 1) or (and A, mask), val => ARMbfi A, val, mask; // iff (val & mask) == val; //; // 2) or (and A, mask), (and B, mask2) => ARMbfi A, (lsr B, amt), mask; // 2a) iff isBitFieldInvertedMask(mask) && isBitFieldInvertedMask(~mask2); // && mask == ~mask2; // 2b) iff isBitFieldInvertedMask(~mask) && isBitFieldInvertedMask(mask2); // && ~mask == mask2; // (i.e., copy a bitfield value into another bitfield of the same width)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:101,Availability,mask,mask,101,"// 1) or (and A, mask), val => ARMbfi A, val, mask; // iff (val & mask) == val; //; // 2) or (and A, mask), (and B, mask2) => ARMbfi A, (lsr B, amt), mask; // 2a) iff isBitFieldInvertedMask(mask) && isBitFieldInvertedMask(~mask2); // && mask == ~mask2; // 2b) iff isBitFieldInvertedMask(~mask) && isBitFieldInvertedMask(mask2); // && ~mask == mask2; // (i.e., copy a bitfield value into another bitfield of the same width)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:150,Availability,mask,mask,150,"// 1) or (and A, mask), val => ARMbfi A, val, mask; // iff (val & mask) == val; //; // 2) or (and A, mask), (and B, mask2) => ARMbfi A, (lsr B, amt), mask; // 2a) iff isBitFieldInvertedMask(mask) && isBitFieldInvertedMask(~mask2); // && mask == ~mask2; // 2b) iff isBitFieldInvertedMask(~mask) && isBitFieldInvertedMask(mask2); // && ~mask == mask2; // (i.e., copy a bitfield value into another bitfield of the same width)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:190,Availability,mask,mask,190,"// 1) or (and A, mask), val => ARMbfi A, val, mask; // iff (val & mask) == val; //; // 2) or (and A, mask), (and B, mask2) => ARMbfi A, (lsr B, amt), mask; // 2a) iff isBitFieldInvertedMask(mask) && isBitFieldInvertedMask(~mask2); // && mask == ~mask2; // 2b) iff isBitFieldInvertedMask(~mask) && isBitFieldInvertedMask(mask2); // && ~mask == mask2; // (i.e., copy a bitfield value into another bitfield of the same width)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:237,Availability,mask,mask,237,"// 1) or (and A, mask), val => ARMbfi A, val, mask; // iff (val & mask) == val; //; // 2) or (and A, mask), (and B, mask2) => ARMbfi A, (lsr B, amt), mask; // 2a) iff isBitFieldInvertedMask(mask) && isBitFieldInvertedMask(~mask2); // && mask == ~mask2; // 2b) iff isBitFieldInvertedMask(~mask) && isBitFieldInvertedMask(mask2); // && ~mask == mask2; // (i.e., copy a bitfield value into another bitfield of the same width)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:288,Availability,mask,mask,288,"// 1) or (and A, mask), val => ARMbfi A, val, mask; // iff (val & mask) == val; //; // 2) or (and A, mask), (and B, mask2) => ARMbfi A, (lsr B, amt), mask; // 2a) iff isBitFieldInvertedMask(mask) && isBitFieldInvertedMask(~mask2); // && mask == ~mask2; // 2b) iff isBitFieldInvertedMask(~mask) && isBitFieldInvertedMask(mask2); // && ~mask == mask2; // (i.e., copy a bitfield value into another bitfield of the same width)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:335,Availability,mask,mask,335,"// 1) or (and A, mask), val => ARMbfi A, val, mask; // iff (val & mask) == val; //; // 2) or (and A, mask), (and B, mask2) => ARMbfi A, (lsr B, amt), mask; // 2a) iff isBitFieldInvertedMask(mask) && isBitFieldInvertedMask(~mask2); // && mask == ~mask2; // 2b) iff isBitFieldInvertedMask(~mask) && isBitFieldInvertedMask(mask2); // && ~mask == mask2; // (i.e., copy a bitfield value into another bitfield of the same width)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:21,Availability,mask,mask,21,"// The value and the mask need to be constants so we can verify this is; // actually a bitfield set. If the mask is 0xffff, we can do better; // via a movt instruction, so don't use BFI in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:108,Availability,mask,mask,108,"// The value and the mask need to be constants so we can verify this is; // actually a bitfield set. If the mask is 0xffff, we can do better; // via a movt instruction, so don't use BFI in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:24,Availability,mask,mask,24,"// Case (1): or (and A, mask), val => ARMbfi A, val, mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:53,Availability,mask,mask,53,"// Case (1): or (and A, mask), val => ARMbfi A, val, mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:23,Availability,mask,mask,23,"// case (2) or (and A, mask), (and B, mask2) => ARMbfi A, (lsr B, amt), mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:72,Availability,mask,mask,72,"// case (2) or (and A, mask), (and B, mask2) => ARMbfi A, (lsr B, amt), mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:3,Availability,Mask,Mask,3,// Mask and ~Mask2 (or reverse) must be equivalent for the BFI pattern; // as is to match.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:50,Availability,mask,masks,50,"// The pack halfword instruction works better for masks that fit it,; // so use that when it's available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:95,Availability,avail,available,95,"// The pack halfword instruction works better for masks that fit it,; // so use that when it's available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:50,Availability,mask,masks,50,"// The pack halfword instruction works better for masks that fit it,; // so use that when it's available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:95,Availability,avail,available,95,"// The pack halfword instruction works better for masks that fit it,; // so use that when it's available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:38,Availability,mask,mask,38,"// Case (3): or (and (shl A, #shamt), mask), B => ARMbfi B, A, ~mask; // where lsb(mask) == #shamt and masked bits of B are known zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:64,Availability,mask,mask,64,"// Case (3): or (and (shl A, #shamt), mask), B => ARMbfi B, A, ~mask; // where lsb(mask) == #shamt and masked bits of B are known zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:83,Availability,mask,mask,83,"// Case (3): or (and (shl A, #shamt), mask), B => ARMbfi B, A, ~mask; // where lsb(mask) == #shamt and masked bits of B are known zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:103,Availability,mask,masked,103,"// Case (3): or (and (shl A, #shamt), mask), B => ARMbfi B, A, ~mask; // where lsb(mask) == #shamt and masked bits of B are known zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:4,Performance,Perform,PerformORCombine,4,/// PerformORCombine - Target-specific dag combine xforms for ISD::OR,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:18,Performance,optimiz,optimizes,18,"// The code below optimizes (or (and X, Y), Z).; // The AND operand needs to have a single user to make these optimizations; // profitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:110,Performance,optimiz,optimizations,110,"// The code below optimizes (or (and X, Y), Z).; // The AND operand needs to have a single user to make these optimizations; // profitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:96,Testability,log,logical,96,// Ensure that the bit width of the constants are the same and that; // the splat arguments are logical inverses as per the pattern we; // are trying to simplify.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:153,Usability,simpl,simplify,153,// Ensure that the bit width of the constants are the same and that; // the splat arguments are logical inverses as per the pattern we; // are trying to simplify.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:66,Usability,simpl,simpler,66,// Canonicalize the vector type to make instruction selection; // simpler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:67,Testability,test,testing,67,"// If the Base came from a SHR #C, we can deduce that it is really testing bit; // #C in the base of the SHR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:78,Usability,clear,cleared,78,"// (bfi A, (and B, Mask1), Mask2) -> (bfi A, B, Mask2) iff; // the bits being cleared by the AND are not demanded by the BFI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:109,Performance,perform,performed,109,"// Reassociate BFI(BFI (A, B, M1), C, M2) to BFI(BFI (A, C, M2), B, M1) so; // that lower bit insertions are performed first, providing that M1 and M2; // do no overlap. This can allow multiple BFI instructions to be combined; // together by the other folds above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:4,Performance,Perform,PerformVMOVRRDCombine,4,/// PerformVMOVRRDCombine - Target-specific dag combine xforms for; /// ARMISD::VMOVRRD.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:11,Performance,load,load,11,"// vmovrrd(load f64) -> (load i32), (load i32)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:25,Performance,load,load,25,"// vmovrrd(load f64) -> (load i32), (load i32)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:37,Performance,load,load,37,"// vmovrrd(load f64) -> (load i32), (load i32)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:53,Integrability,depend,depending,53,"// Handle buildvectors, pulling out the correct lane depending on; // endianness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:4,Performance,Perform,PerformVMOVDRRCombine,4,/// PerformVMOVDRRCombine - Target-specific dag combine xforms for; /// ARMISD::VMOVDRR. This is also used for BUILD_VECTORs with 2 operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:3,Deployability,Update,Update,3,"// Update Users, Chains, and Potential Glue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:17,Performance,load,load,17,// fold (VMOVhr (load x)) -> (load (f16*)x),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:30,Performance,load,load,30,// fold (VMOVhr (load x)) -> (load (f16*)x),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:17,Performance,load,load,17,// fold (VMOVrh (load x)) -> (zextload (i16*)x),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:109,Performance,load,loads,109,"/// hasNormalLoadOperand - Check if any of the operands of a BUILD_VECTOR node; /// are normal, non-volatile loads. If so, it is profitable to bitcast an; /// i64 vector to have f64 elements, since the value can then be loaded; /// directly into a VFP register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:220,Performance,load,loaded,220,"/// hasNormalLoadOperand - Check if any of the operands of a BUILD_VECTOR node; /// are normal, non-volatile loads. If so, it is profitable to bitcast an; /// i64 vector to have f64 elements, since the value can then be loaded; /// directly into a VFP register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:276,Usability,undo,undo,276,"// build_vector(N=ARMISD::VMOVRRD(X), N:1) -> bit_convert(X):; // VMOVRRD is introduced when legalizing i64 types. It forces the i64 value; // into a pair of GPRs, which is fine when the value is used as a scalar,; // but if the i64 value is converted to a vector, we need to undo the VMOVRRD.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:3,Performance,Load,Load,3,// Load i64 elements as f64 values so that type legalization does not split; // them up into i32 values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:4,Performance,Perform,PerformInsertEltCombine,4,/// PerformInsertEltCombine - Target-specific dag combine xforms for; /// ISD::INSERT_VECTOR_ELT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:18,Performance,load,load,18,"// Bitcast an i64 load inserted into a vector to f64.; // Otherwise, the i64 value will be legalized to a pair of i32 values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:67,Availability,mask,mask,67,"// The LLVM shufflevector instruction does not require the shuffle mask; // length to match the operand vector length, but ISD::VECTOR_SHUFFLE does; // have that requirement. When translating to ISD::VECTOR_SHUFFLE, if the; // operands do not match the mask length, they are extended by concatenating; // them with undef vectors. That is probably the right thing for other; // targets, but for NEON it is better to concatenate two double-register; // size vector operands into a single quad-register size vector. Do that; // transformation here:; // shuffle(concat(v1, undef), concat(v2, undef)) ->; // shuffle(concat(v1, v2), undef)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:253,Availability,mask,mask,253,"// The LLVM shufflevector instruction does not require the shuffle mask; // length to match the operand vector length, but ISD::VECTOR_SHUFFLE does; // have that requirement. When translating to ISD::VECTOR_SHUFFLE, if the; // operands do not match the mask length, they are extended by concatenating; // them with undef vectors. That is probably the right thing for other; // targets, but for NEON it is better to concatenate two double-register; // size vector operands into a single quad-register size vector. Do that; // transformation here:; // shuffle(concat(v1, undef), concat(v2, undef)) ->; // shuffle(concat(v1, v2), undef)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:275,Modifiability,extend,extended,275,"// The LLVM shufflevector instruction does not require the shuffle mask; // length to match the operand vector length, but ISD::VECTOR_SHUFFLE does; // have that requirement. When translating to ISD::VECTOR_SHUFFLE, if the; // operands do not match the mask length, they are extended by concatenating; // them with undef vectors. That is probably the right thing for other; // targets, but for NEON it is better to concatenate two double-register; // size vector operands into a single quad-register size vector. Do that; // transformation here:; // shuffle(concat(v1, undef), concat(v2, undef)) ->; // shuffle(concat(v1, v2), undef)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:25,Availability,mask,mask,25,// Translate the shuffle mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:71,Deployability,update,update,71,/// Load/store instruction that can be merged with a base address; /// update,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:4,Performance,Load,Load,4,/// Load/store instruction that can be merged with a base address; /// update,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:21,Deployability,update,updates,21,/// Instruction that updates a pointer,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:40,Performance,load,load,40,// Find the new opcode for the updating load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:45,Performance,load,load,45,// Find the size of memory referenced by the load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:134,Deployability,update,update,134,// VLD3/4 and VST3/4 for 128-bit vectors are implemented with two; // separate instructions that make it harder to use a non-constant update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:49,Deployability,update,update,49,"// OK, we found an ADD we can fold into the base update.; // Now, create a _UPD node, taking care of not breaking alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:273,Deployability,update,update,273,"// If this is a less-than-standard-aligned load/store, change the type to; // match the standard alignment.; // The alignment is overlooked when selecting _UPD variants; and it's; // easier to introduce bitcasts here than fix that.; // There are 3 ways to get to this base-update combine:; // - intrinsics: they are assumed to be properly aligned (to the standard; // alignment of the memory type), so we don't need to do anything.; // - ARMISD::VLDx nodes: they are only generated from the aforementioned; // intrinsics, so, likewise, there's nothing to do.; // - generic load/store instructions: the alignment is specified as an; // explicit operand, rather than implicitly as the standard alignment; // of the memory type (like the intrisics). We need to change the; // memory type to match the explicit alignment. That way, we don't; // generate non-standard-aligned ARMISD::VLDx nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:43,Performance,load,load,43,"// If this is a less-than-standard-aligned load/store, change the type to; // match the standard alignment.; // The alignment is overlooked when selecting _UPD variants; and it's; // easier to introduce bitcasts here than fix that.; // There are 3 ways to get to this base-update combine:; // - intrinsics: they are assumed to be properly aligned (to the standard; // alignment of the memory type), so we don't need to do anything.; // - ARMISD::VLDx nodes: they are only generated from the aforementioned; // intrinsics, so, likewise, there's nothing to do.; // - generic load/store instructions: the alignment is specified as an; // explicit operand, rather than implicitly as the standard alignment; // of the memory type (like the intrisics). We need to change the; // memory type to match the explicit alignment. That way, we don't; // generate non-standard-aligned ARMISD::VLDx nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:573,Performance,load,load,573,"// If this is a less-than-standard-aligned load/store, change the type to; // match the standard alignment.; // The alignment is overlooked when selecting _UPD variants; and it's; // easier to introduce bitcasts here than fix that.; // There are 3 ways to get to this base-update combine:; // - intrinsics: they are assumed to be properly aligned (to the standard; // alignment of the memory type), so we don't need to do anything.; // - ARMISD::VLDx nodes: they are only generated from the aforementioned; // intrinsics, so, likewise, there's nothing to do.; // - generic load/store instructions: the alignment is specified as an; // explicit operand, rather than implicitly as the standard alignment; // of the memory type (like the intrisics). We need to change the; // memory type to match the explicit alignment. That way, we don't; // generate non-standard-aligned ARMISD::VLDx nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:46,Performance,load,load,46,"// Don't set an explicit alignment on regular load/stores that we want; // to transform to VLD/VST 1_UPD nodes.; // This matches the behavior of regular load/stores, which only get an; // explicit alignment if the MMO alignment is larger than the standard; // alignment of the memory type.; // Intrinsics, however, always get an explicit alignment, set to the; // alignment of the MMO.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:153,Performance,load,load,153,"// Don't set an explicit alignment on regular load/stores that we want; // to transform to VLD/VST 1_UPD nodes.; // This matches the behavior of regular load/stores, which only get an; // explicit alignment if the MMO alignment is larger than the standard; // alignment of the memory type.; // Intrinsics, however, always get an explicit alignment, set to the; // alignment of the MMO.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:27,Performance,load,load,27,"// Create the new updating load/store node.; // First, create an SDVTList for the new updating node's results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:3,Performance,Load,Loads,3,"// Loads (and of course intrinsics) match the intrinsics' signature,; // so just add all but the alignment operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:3,Deployability,Update,Update,3,// Update the uses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:38,Performance,LOAD,LOAD,38,"// If this is an non-standard-aligned LOAD, the first result is the loaded; // value. Bitcast it to the expected result type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:68,Performance,load,loaded,68,"// If this is an non-standard-aligned LOAD, the first result is the loaded; // value. Bitcast it to the expected result type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:44,Performance,load,load,44,"// Check that the add is independent of the load/store.; // Otherwise, folding it would create a cycle. Search through Addr; // as well, since the User may not be a direct user of Addr and; // only share a base pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:165,Deployability,update,updates,165,"/// CombineBaseUpdate - Target-specific DAG combine function for VLDDUP,; /// NEON load/store intrinsics, and generic vector load/stores, to merge; /// base address updates.; /// For generic load/stores, the memory type is assumed to be a vector.; /// The caller is assumed to have checked legality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:83,Performance,load,load,83,"/// CombineBaseUpdate - Target-specific DAG combine function for VLDDUP,; /// NEON load/store intrinsics, and generic vector load/stores, to merge; /// base address updates.; /// For generic load/stores, the memory type is assumed to be a vector.; /// The caller is assumed to have checked legality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:125,Performance,load,load,125,"/// CombineBaseUpdate - Target-specific DAG combine function for VLDDUP,; /// NEON load/store intrinsics, and generic vector load/stores, to merge; /// base address updates.; /// For generic load/stores, the memory type is assumed to be a vector.; /// The caller is assumed to have checked legality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:191,Performance,load,load,191,"/// CombineBaseUpdate - Target-specific DAG combine function for VLDDUP,; /// NEON load/store intrinsics, and generic vector load/stores, to merge; /// base address updates.; /// For generic load/stores, the memory type is assumed to be a vector.; /// The caller is assumed to have checked legality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:38,Deployability,update,update,38,// Try to fold the load/store with an update that matches memory; // access size. This should work well for sequential loads.; //; // Filter out invalid updates as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:153,Deployability,update,updates,153,// Try to fold the load/store with an update that matches memory; // access size. This should work well for sequential loads.; //; // Filter out invalid updates as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:19,Performance,load,load,19,// Try to fold the load/store with an update that matches memory; // access size. This should work well for sequential loads.; //; // Filter out invalid updates as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:119,Performance,load,loads,119,// Try to fold the load/store with an update that matches memory; // access size. This should work well for sequential loads.; //; // Filter out invalid updates as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:69,Security,access,access,69,// Try to fold the load/store with an update that matches memory; // access size. This should work well for sequential loads.; //; // Filter out invalid updates as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:2,Usability,Simpl,SimpleConstIncOnly,2,/*SimpleConstIncOnly=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:46,Deployability,update,updates,46,"// Try to fold with other users. Non-constant updates are considered; // first, and constant updates are sorted to not break a sequence of; // strided accesses (if there is any).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:93,Deployability,update,updates,93,"// Try to fold with other users. Non-constant updates are considered; // first, and constant updates are sorted to not break a sequence of; // strided accesses (if there is any).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:151,Security,access,accesses,151,"// Try to fold with other users. Non-constant updates are considered; // first, and constant updates are sorted to not break a sequence of; // strided accesses (if there is any).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:2,Usability,Simpl,SimpleConstIncOnly,2,/*SimpleConstIncOnly=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:44,Performance,load,load,44,"// Check that the add is independent of the load/store. Otherwise, folding; // it would create a cycle. We can avoid searching through Addr as it's a; // predecessor to both.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:111,Safety,avoid,avoid,111,"// Check that the add is independent of the load/store. Otherwise, folding; // it would create a cycle. We can avoid searching through Addr as it's a; // predecessor to both.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:40,Performance,load,load,40,// Find the new opcode for the updating load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:45,Performance,load,load,45,// Find the size of memory referenced by the load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:27,Performance,load,load,27,"// Create the new updating load/store node.; // First, create an SDVTList for the new updating node's results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:3,Deployability,Update,Update,3,// Update the uses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:97,Performance,load,load,97,// First check that all the vldN-lane uses are VDUPLANEs and that the lane; // numbers match the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:3,Deployability,Update,Update,3,// Update the uses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:72,Deployability,Update,Update,72,// Now the vldN-lane intrinsic is dead except for its chain result.; // Update uses of the chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:4,Performance,Perform,PerformVDUPLANECombine,4,/// PerformVDUPLANECombine - Target-specific dag combine xforms for; /// ARMISD::VDUPLANE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:76,Availability,redundant,redundant,76,"// If the source is already a VMOVIMM or VMVNIMM splat, the VDUPLANE is; // redundant. Ignore bit_converts for now; element sizes are checked below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:76,Safety,redund,redundant,76,"// If the source is already a VMOVIMM or VMVNIMM splat, the VDUPLANE is; // redundant. Ignore bit_converts for now; element sizes are checked below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:4,Performance,Perform,PerformVDUPCombine,4,/// PerformVDUPCombine - Target-specific dag combine xforms for ARMISD::VDUP.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:14,Performance,LOAD,LOAD,14,// Match VDUP(LOAD) -> VLD1DUP.; // We match this pattern here rather than waiting for isel because the; // transform is only legal for unindexed loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:146,Performance,load,loads,146,// Match VDUP(LOAD) -> VLD1DUP.; // We match this pattern here rather than waiting for isel because the; // transform is only legal for unindexed loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:29,Performance,load,load,29,"// If this is a legal vector load, try to combine it into a VLD1_UPD.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:3,Performance,Optimiz,Optimize,3,"// Optimize trunc store (of multiple scalars) to shuffle and store. First,; // pack all of the elements in one place. Next, store to memory in fewer; // chunks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:29,Performance,perform,perform,29,// Create a type on which we perform the shuffle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:3,Performance,Perform,Perform,3,// Perform one or more big stores into memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:307,Modifiability,extend,extended,307,"// Test if the Trunc will be convertable to a VMOVN with a shuffle, and if so; // use the VMOVN over splitting the store. We are looking for patterns of:; // !rev: 0 N 1 N+1 2 N+2 ...; // rev: N 0 N+1 1 N+2 2 ...; // The shuffle may either be a single source (in which case N = NumElts/2) or; // two inputs extended with concat to the same size (in which case N =; // NumElts).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:3,Testability,Test,Test,3,"// Test if the Trunc will be convertable to a VMOVN with a shuffle, and if so; // use the VMOVN over splitting the store. We are looking for patterns of:; // !rev: 0 N 1 N+1 2 N+2 ...; // rev: N 0 N+1 1 N+2 2 ...; // The shuffle may either be a single source (in which case N = NumElts/2) or; // two inputs extended with concat to the same size (in which case N =; // NumElts).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:280,Availability,avail,available,280,"// Given a floating point store from an extracted vector, with an integer; // VGETLANE that already exists, store the existing VGETLANEu directly. This can; // help reduce fp register pressure, doesn't require the fp extract and allows; // use of more integer post-inc stores not available with vstr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:165,Energy Efficiency,reduce,reduce,165,"// Given a floating point store from an extracted vector, with an integer; // VGETLANE that already exists, store the existing VGETLANEu directly. This can; // help reduce fp register pressure, doesn't require the fp extract and allows; // use of more integer post-inc stores not available with vstr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:4,Performance,Perform,PerformSTORECombine,4,/// PerformSTORECombine - Target-specific dag combine xforms for; /// ISD::STORE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:119,Performance,cache,cache,119,// Split a store of a VMOVDRR into two integer stores to avoid mixing NEON and; // ARM stores of arguments in the same cache line.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:57,Safety,avoid,avoid,57,// Split a store of a VMOVDRR into two integer stores to avoid mixing NEON and; // ARM stores of arguments in the same cache line.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:204,Energy Efficiency,power,power,204,"/// PerformVCVTCombine - VCVT (floating-point to fixed-point, Advanced SIMD); /// can replace combinations of VMUL and VCVT (floating-point to integer); /// when the VMUL has a constant operand that is a power of 2.; ///; /// Example (assume d17 = <float 8.000000e+00, float 8.000000e+00>):; /// vmul.f32 d16, d17, d16; /// vcvt.s32.f32 d16, d16; /// becomes:; /// vcvt.s32.f32 d16, d16, #3",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:4,Performance,Perform,PerformVCVTCombine,4,"/// PerformVCVTCombine - VCVT (floating-point to fixed-point, Advanced SIMD); /// can replace combinations of VMUL and VCVT (floating-point to integer); /// when the VMUL has a constant operand that is a power of 2.; ///; /// Example (assume d17 = <float 8.000000e+00, float 8.000000e+00>):; /// vmul.f32 d16, d17, d16; /// vcvt.s32.f32 d16, d16; /// becomes:; /// vcvt.s32.f32 d16, d16, #3",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:204,Energy Efficiency,power,power,204,"/// PerformVDIVCombine - VCVT (fixed-point to floating-point, Advanced SIMD); /// can replace combinations of VCVT (integer to floating-point) and VDIV; /// when the VDIV has a constant operand that is a power of 2.; ///; /// Example (assume d17 = <float 8.000000e+00, float 8.000000e+00>):; /// vcvt.f32.s32 d16, d16; /// vdiv.f32 d16, d17, d16; /// becomes:; /// vcvt.f32.s32 d16, d16, #3",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:4,Performance,Perform,PerformVDIVCombine,4,"/// PerformVDIVCombine - VCVT (fixed-point to floating-point, Advanced SIMD); /// can replace combinations of VCVT (integer to floating-point) and VDIV; /// when the VDIV has a constant operand that is a power of 2.; ///; /// Example (assume d17 = <float 8.000000e+00, float 8.000000e+00>):; /// vcvt.f32.s32 d16, d16; /// vdiv.f32 d16, d17, d16; /// becomes:; /// vcvt.f32.s32 d16, d16, #3",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:119,Modifiability,extend,extend,119,"// These instructions only exist converting from i32 to f32. We can handle; // smaller integers by generating an extra extend, but larger ones would; // be lossy. We also can't handle anything other than 2 or 4 lanes, since; // these intructions only support v2i32/v4i32 types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:473,Modifiability,extend,extend,473,"// We are looking for something that will have illegal types if left alone,; // but that we can convert to a single instruction under MVE. For example; // vecreduce_add(sext(A, v8i32)) => VADDV.s16 A; // or; // vecreduce_add(mul(zext(A, v16i32), zext(B, v16i32))) => VMLADAV.u8 A, B; // The legal cases are:; // VADDV u/s 8/16/32; // VMLAV u/s 8/16/32; // VADDLV u/s 32; // VMLALV u/s 16/32; // If the input vector is smaller than legal (v4i8/v4i16 for example) we can; // extend it and use v4i32 instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:352,Energy Efficiency,reduce,reduce,352,"// For a vmla we are trying to match a larger pattern:; // ExtA = sext/zext A; // ExtB = sext/zext B; // Mul = mul ExtA, ExtB; // vecreduce.add Mul; // There might also be en extra extend between the mul and the addreduce, so; // long as the bitwidth is high enough to make them equivalent (for example; // original v8i16 might be mul at v8i32 and the reduce happens at v8i64).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:181,Modifiability,extend,extend,181,"// For a vmla we are trying to match a larger pattern:; // ExtA = sext/zext A; // ExtB = sext/zext B; // Mul = mul ExtA, ExtB; // vecreduce.add Mul; // There might also be en extra extend between the mul and the addreduce, so; // long as the bitwidth is high enough to make them equivalent (for example; // original v8i16 might be mul at v8i32 and the reduce happens at v8i64).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:160,Availability,Mask,Mask,160,"// Same as the pattern above with a select for the zero predicated lanes; // ExtA = sext/zext A; // ExtB = sext/zext B; // Mul = mul ExtA, ExtB; // N0 = select Mask, Mul, 0; // vecreduce.add N0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:110,Modifiability,extend,extended,110,"// Split illegal MVT::v16i8->i64 vector reductions into two legal v8i16->i64; // reductions. The operands are extended with MVEEXT, but as they are; // reductions the lane orders do not matter. MVEEXT may be combined with; // loads to produce two extending loads, or else they will be expanded to; // VREV/VMOVL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:247,Modifiability,extend,extending,247,"// Split illegal MVT::v16i8->i64 vector reductions into two legal v8i16->i64; // reductions. The operands are extended with MVEEXT, but as they are; // reductions the lane orders do not matter. MVEEXT may be combined with; // loads to produce two extending loads, or else they will be expanded to; // VREV/VMOVL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:226,Performance,load,loads,226,"// Split illegal MVT::v16i8->i64 vector reductions into two legal v8i16->i64; // reductions. The operands are extended with MVEEXT, but as they are; // reductions the lane orders do not matter. MVEEXT may be combined with; // loads to produce two extending loads, or else they will be expanded to; // VREV/VMOVL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:257,Performance,load,loads,257,"// Split illegal MVT::v16i8->i64 vector reductions into two legal v8i16->i64; // reductions. The operands are extended with MVEEXT, but as they are; // reductions the lane orders do not matter. MVEEXT may be combined with; // loads to produce two extending loads, or else they will be expanded to; // VREV/VMOVL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:43,Availability,mask,mask,43,// Check all elements are used once in the mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:119,Integrability,depend,depending,119,"// Only the bottom lanes from Qm (Op1) and either the top or bottom lanes from; // Qd (Op0) are demanded from a VMOVN, depending on whether we are inserting; // into the top or bottom lanes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:4,Performance,Perform,PerformIntrinsicCombine,4,/// PerformIntrinsicCombine - ARM-specific DAG combining for intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:298,Performance,load,loads,298,"// Vector shifts: check for immediate versions and lower them.; // Note: This is done during DAG combining instead of DAG legalizing because; // the build_vectors for 64-bit vector element shift counts are generally; // not legal, and it is hard to see their values after they get legalized to; // loads from a constant pool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:231,Usability,ux,uxth,231,"// These intrinsics all take an i32 scalar operand which is narrowed to the; // size of a single lane of the vector type they return. So we don't need; // any bits of that operand above that point, which allows us to eliminate; // uxth/sxth.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:89,Performance,Perform,PerformADDVecReduce,89,"// Turn this intrinsic straight into the appropriate ARMISD::VADDV node,; // which allow PerformADDVecReduce to turn it into VADDLV when possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:4,Performance,Perform,PerformShiftCombine,4,"/// PerformShiftCombine - Checks for immediate versions of vector shifts and; /// lowers them. As with the vector shift intrinsics, this is done during DAG; /// combining instead of DAG legalizing because the build_vectors for 64-bit; /// vector element shift counts are generally not legal, and it is hard to see; /// their values after they get legalized to loads from a constant pool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:360,Performance,load,loads,360,"/// PerformShiftCombine - Checks for immediate versions of vector shifts and; /// lowers them. As with the vector shift intrinsics, this is done during DAG; /// combining instead of DAG legalizing because the build_vectors for 64-bit; /// vector element shift counts are generally not legal, and it is hard to see; /// their values after they get legalized to loads from a constant pool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:19,Usability,ux,uxtb,19,// Don't transform uxtb/uxth.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:24,Usability,ux,uxth,24,// Don't transform uxtb/uxth.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:33,Modifiability,extend,extend,33,"// Look for a sign/zero/fpextend extend of a larger than legal load. This can be; // split into multiple extending loads, which are simpler to deal with than an; // arbitrary extend. For fp extends we use an integer extending load and a VCVTL; // to convert the type to an f32.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:105,Modifiability,extend,extending,105,"// Look for a sign/zero/fpextend extend of a larger than legal load. This can be; // split into multiple extending loads, which are simpler to deal with than an; // arbitrary extend. For fp extends we use an integer extending load and a VCVTL; // to convert the type to an f32.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:175,Modifiability,extend,extend,175,"// Look for a sign/zero/fpextend extend of a larger than legal load. This can be; // split into multiple extending loads, which are simpler to deal with than an; // arbitrary extend. For fp extends we use an integer extending load and a VCVTL; // to convert the type to an f32.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:190,Modifiability,extend,extends,190,"// Look for a sign/zero/fpextend extend of a larger than legal load. This can be; // split into multiple extending loads, which are simpler to deal with than an; // arbitrary extend. For fp extends we use an integer extending load and a VCVTL; // to convert the type to an f32.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:216,Modifiability,extend,extending,216,"// Look for a sign/zero/fpextend extend of a larger than legal load. This can be; // split into multiple extending loads, which are simpler to deal with than an; // arbitrary extend. For fp extends we use an integer extending load and a VCVTL; // to convert the type to an f32.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:63,Performance,load,load,63,"// Look for a sign/zero/fpextend extend of a larger than legal load. This can be; // split into multiple extending loads, which are simpler to deal with than an; // arbitrary extend. For fp extends we use an integer extending load and a VCVTL; // to convert the type to an f32.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:115,Performance,load,loads,115,"// Look for a sign/zero/fpextend extend of a larger than legal load. This can be; // split into multiple extending loads, which are simpler to deal with than an; // arbitrary extend. For fp extends we use an integer extending load and a VCVTL; // to convert the type to an f32.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:226,Performance,load,load,226,"// Look for a sign/zero/fpextend extend of a larger than legal load. This can be; // split into multiple extending loads, which are simpler to deal with than an; // arbitrary extend. For fp extends we use an integer extending load and a VCVTL; // to convert the type to an f32.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:132,Usability,simpl,simpler,132,"// Look for a sign/zero/fpextend extend of a larger than legal load. This can be; // split into multiple extending loads, which are simpler to deal with than an; // arbitrary extend. For fp extends we use an integer extending load and a VCVTL; // to convert the type to an f32.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:25,Performance,load,load,25,// Details about the old load,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:24,Modifiability,extend,extended,24,// Float truncs need to extended with VCVTB's into their floating point types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:4,Performance,Perform,PerformExtendCombine,4,"/// PerformExtendCombine - Target-specific DAG combining for ISD::SIGN_EXTEND,; /// ISD::ZERO_EXTEND, and ISD::ANY_EXTEND.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:4,Performance,Perform,PerformMinMaxCombine,4,/// PerformMinMaxCombine - Target-specific DAG combining for creating truncating; /// saturates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:54,Modifiability,extend,extended,54,"// Create a VQMOVNB with undef top lanes, then signed extended into the top; // half. That extend will hopefully be removed if only the bottom bits are; // demanded (though a truncating store, for example).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:91,Modifiability,extend,extend,91,"// Create a VQMOVNB with undef top lanes, then signed extended into the top; // half. That extend will hopefully be removed if only the bottom bits are; // demanded (though a truncating store, for example).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:92,Modifiability,extend,extend,92,"// Create a VQMOVNB with undef top lanes, then ZExt into the top half with; // an AND. That extend will hopefully be removed if only the bottom bits are; // demanded (though a truncating store, for example).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:9,Performance,perform,performing,9,"// We're performing an ""equal to zero"" compare. Swap the operands so we; // canonicalize on a ""not equal to zero"" compare.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:45,Availability,mask,mask,45,"// Confusingly, the operand is an *inverted* mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:125,Testability,test,test,125,"// The hwloop intrinsics that we're interested are used for control-flow,; // either for entering or exiting the loop:; // - test.start.loop.iterations will test whether its operand is zero. If it; // is zero, the proceeding branch should not enter the loop.; // - loop.decrement.reg also tests whether its operand is zero. If it is; // zero, the proceeding branch should not branch back to the beginning of; // the loop.; // So here, we need to check that how the brcond is using the result of each; // of the intrinsics to ensure that we're branching to the right place at the; // right time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:157,Testability,test,test,157,"// The hwloop intrinsics that we're interested are used for control-flow,; // either for entering or exiting the loop:; // - test.start.loop.iterations will test whether its operand is zero. If it; // is zero, the proceeding branch should not enter the loop.; // - loop.decrement.reg also tests whether its operand is zero. If it is; // zero, the proceeding branch should not branch back to the beginning of; // the loop.; // So here, we need to check that how the brcond is using the result of each; // of the intrinsics to ensure that we're branching to the right place at the; // right time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:289,Testability,test,tests,289,"// The hwloop intrinsics that we're interested are used for control-flow,; // either for entering or exiting the loop:; // - test.start.loop.iterations will test whether its operand is zero. If it; // is zero, the proceeding branch should not enter the loop.; // - loop.decrement.reg also tests whether its operand is zero. If it is; // zero, the proceeding branch should not branch back to the beginning of; // the loop.; // So here, we need to check that how the brcond is using the result of each; // of the intrinsics to ensure that we're branching to the right place at the; // right time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:3,Deployability,Update,Update,3,// Update the unconditional branch to branch to the given Dest.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:7,Testability,log,logic,7,"// The logic is the reverse of what we need for WLS, so find the other; // basic block target: the target of the proceeding br.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:3,Deployability,Update,Update,3,// Update LR count to the new value,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:3,Deployability,Update,Update,3,// Update chain,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:3,Deployability,Update,Update,3,// Update the unconditional branch to target the loop preheader if we've; // found the condition has been reversed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:4,Performance,Perform,PerformBRCONDCombine,4,/// PerformBRCONDCombine - Target-specific DAG combining for ARMISD::BRCOND.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:4,Performance,Perform,PerformCMOVCombine,4,/// PerformCMOVCombine - Target-specific DAG combining for ARMISD::CMOV.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:15,Availability,avail,available,15,// BFI is only available on V6T2+.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:252,Performance,optimiz,optimization,252,"// Simplify; // mov r1, r0; // cmp r1, x; // mov r0, y; // moveq r0, x; // to; // cmp r0, x; // movne r0, y; //; // mov r1, r0; // cmp r1, x; // mov r0, x; // movne r0, y; // to; // cmp r0, x; // movne r0, y; /// FIXME: Turn this into a target neutral optimization?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:3,Usability,Simpl,Simplify,3,"// Simplify; // mov r1, r0; // cmp r1, x; // mov r0, y; // moveq r0, x; // to; // cmp r0, x; // movne r0, y; //; // mov r1, r0; // cmp r1, x; // mov r0, x; // movne r0, y; // to; // cmp r0, x; // movne r0, y; /// FIXME: Turn this into a target neutral optimization?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:59,Safety,avoid,avoid,59,// Materialize a boolean comparison for integers so we can avoid branching.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:62,Energy Efficiency,power,power,62,"// On Thumb1, the DAG above may be further combined if z is a power of 2; // (z == 2 ^ K).; // CMOV (SUBS x, y), z, !=, (SUBS x, y):1 ->; // t1 = (USUBO (SUB x, y), 1); // t2 = (USUBO_CARRY (SUB x, y), t1:0, t1:1); // Result = if K != 0 then (SHL t2:0, K) else t2:0; //; // This also handles the special case of comparing against zero; it's; // essentially, the same pattern, except there's no SUBS:; // CMOV x, z, !=, (CMPZ x, 0) ->; // t1 = (USUBO x, 1); // t2 = (USUBO_CARRY x, t1:0, t1:1); // Result = if K != 0 then (SHL t2:0, K) else t2:0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:84,Performance,perform,performed,84,"// We may have a bitcast of something that has already had this bitcast; // combine performed on it, so skip past any VECTOR_REG_CASTs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:30,Availability,mask,mask,30,// Construct complete shuffle mask,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:148,Performance,perform,performing,148,"// If we are late in the legalization process and nothing has optimised; // the trunc to anything better, lower it to a stack store and reload,; // performing the truncation whilst keeping the lanes in the correct order:; // VSTRH.32 a, stack; VSTRH.32 b, stack+8; VLDRW.32 stack;",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:17,Performance,load,load,17,"// Take a MVEEXT(load x) and split that into (extload x, extload x+8)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:25,Performance,load,load,25,// Details about the old load,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:164,Modifiability,extend,extend,164,"// Perform combines for MVEEXT. If it has not be optimized to anything better; // before lowering, it gets converted to stack store and extloads performing the; // extend whilst still keeping the same lane ordering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:3,Performance,Perform,Perform,3,"// Perform combines for MVEEXT. If it has not be optimized to anything better; // before lowering, it gets converted to stack store and extloads performing the; // extend whilst still keeping the same lane ordering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:49,Performance,optimiz,optimized,49,"// Perform combines for MVEEXT. If it has not be optimized to anything better; // before lowering, it gets converted to stack store and extloads performing the; // extend whilst still keeping the same lane ordering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:145,Performance,perform,performing,145,"// Perform combines for MVEEXT. If it has not be optimized to anything better; // before lowering, it gets converted to stack store and extloads performing the; // extend whilst still keeping the same lane ordering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:10,Performance,load,load,10,"// MVEEXT(load) -> extload, extload",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:3,Integrability,Depend,Depends,3,// Depends what it gets converted into if the type is weird.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:13,Security,access,access,13,"// Unaligned access can use (for example) LRDB, LRDH, LDR",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:203,Security,access,accesses,203,"// For any little-endian targets with neon, we can support unaligned ld/st; // of D and Q (e.g. {D0,D1}) registers by using vld1.i8/vst1.i8.; // A big-endian target may also explicitly support unaligned accesses",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:44,Performance,load,loads,44,// These are for truncated stores/narrowing loads. They are fine so long as; // the alignment is at least the size of the item being loaded,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:133,Performance,load,loaded,133,// These are for truncated stores/narrowing loads. They are fine so long as; // the alignment is at least the size of the item being loaded,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:30,Testability,log,logic,30,// Let the target-independent logic figure it out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:42,Modifiability,extend,extend,42,// 8-bit and 16-bit loads implicitly zero-extend to 32-bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:20,Performance,load,loads,20,// 8-bit and 16-bit loads implicitly zero-extend to 32-bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:163,Modifiability,rewrite,rewrite,163,"// There are quite a few FP16 instructions (e.g. VNMLA, VNMLS, etc.) that; // negate values directly (fneg is free). So, we don't want to let the DAG; // combiner rewrite fneg into xors and some other instructions. For f16 and; // FullFP16 argument passing, some bitcast nodes may be introduced,; // triggering this DAG combine rewrite, so we are avoiding that with this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:328,Modifiability,rewrite,rewrite,328,"// There are quite a few FP16 instructions (e.g. VNMLA, VNMLS, etc.) that; // negate values directly (fneg is free). So, we don't want to let the DAG; // combiner rewrite fneg into xors and some other instructions. For f16 and; // FullFP16 argument passing, some bitcast nodes may be introduced,; // triggering this DAG combine rewrite, so we are avoiding that with this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:347,Safety,avoid,avoiding,347,"// There are quite a few FP16 instructions (e.g. VNMLA, VNMLS, etc.) that; // negate values directly (fneg is free). So, we don't want to let the DAG; // combiner rewrite fneg into xors and some other instructions. For f16 and; // FullFP16 argument passing, some bitcast nodes may be introduced,; // triggering this DAG combine rewrite, so we are avoiding that with this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:31,Modifiability,extend,extends,31,"/// Check if Ext1 and Ext2 are extends of the same type, doubling the bitwidth; /// of the vector elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:45,Safety,avoid,avoid,45,// All uses of the shuffle should be sunk to avoid duplicating it across gpr; // and vector registers,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:18,Performance,load,loadext,18,"// Don't create a loadext if we can fold the extension into a wide/long; // instruction.; // If there's more than one user instruction, the loadext is desirable no; // matter what. There can be two uses by the same instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:140,Performance,load,loadext,140,"// Don't create a loadext if we can fold the extension into a wide/long; // instruction.; // If there's more than one user instruction, the loadext is desirable no; // matter what. There can be two uses by the same instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:102,Availability,down,down,102,"// Assuming the caller doesn't have a zeroext or signext return parameter,; // truncation all the way down to i1 is valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:482,Safety,risk,risk,482,"/// isFMAFasterThanFMulAndFAdd - Return true if an FMA operation is faster; /// than a pair of fmul and fadd instructions. fmuladd intrinsics will be; /// expanded to FMAs when this method returns true, otherwise fmuladd is; /// expanded to fmul + fadd.; ///; /// ARM supports both fused and unfused multiply-add operations; we already; /// lower a pair of fmul and fadd to the latter so it's not clear that there; /// would be a gain or that the gain would be worthwhile enough to risk; /// correctness bugs.; ///; /// For MVE, we set this to true as it helps simplify the need for some; /// patterns (and we don't have the non-fused floating point instruction).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:397,Usability,clear,clear,397,"/// isFMAFasterThanFMulAndFAdd - Return true if an FMA operation is faster; /// than a pair of fmul and fadd instructions. fmuladd intrinsics will be; /// expanded to FMAs when this method returns true, otherwise fmuladd is; /// expanded to fmul + fadd.; ///; /// ARM supports both fused and unfused multiply-add operations; we already; /// lower a pair of fmul and fadd to the latter so it's not clear that there; /// would be a gain or that the gain would be worthwhile enough to risk; /// correctness bugs.; ///; /// For MVE, we set this to true as it helps simplify the need for some; /// patterns (and we don't have the non-fused floating point instruction).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:561,Usability,simpl,simplify,561,"/// isFMAFasterThanFMulAndFAdd - Return true if an FMA operation is faster; /// than a pair of fmul and fadd instructions. fmuladd intrinsics will be; /// expanded to FMAs when this method returns true, otherwise fmuladd is; /// expanded to fmul + fadd.; ///; /// ARM supports both fused and unfused multiply-add operations; we already; /// lower a pair of fmul and fadd to the latter so it's not clear that there; /// would be a gain or that the gain would be worthwhile enough to risk; /// correctness bugs.; ///; /// For MVE, we set this to true as it helps simplify the need for some; /// patterns (and we don't have the non-fused floating point instruction).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:16,Performance,load,load,16,"// On thumb1 we load most things (i32, i64, floats, etc) with a LDR; // Scale == 4;",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:128,Performance,load,load,128,/// isLegalAddressImmediate - Return true if the integer value can be used; /// as the offset of the target addressing mode for load / store of the; /// given type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:59,Performance,load,loads,59,"// Note, we allow ""void"" uses (basically, uses that aren't loads or; // stores), because arm allows folding a scale into many arithmetic; // operations. This should be made more precise and revisited later.; // Allow r << imm, but the imm has to be a multiple of two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:118,Performance,load,load,118,"/// isLegalAddressingMode - Return true if the addressing mode represented; /// by AM is legal for this target, for a load/store of the specified type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:38,Performance,load,load,38,// Can never fold addr of global into load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:59,Performance,load,loads,59,"// Note, we allow ""void"" uses (basically, uses that aren't loads or; // stores), because arm allows folding a scale into many arithmetic; // operations. This should be made more precise and revisited later.; // Allow r << imm, but the imm has to be a multiple of two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:48,Performance,load,load,48,// FIXME: Use VLDM / VSTM to emulate indexed FP load / store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:19,Availability,mask,masked,19,// We allow LE non-masked loads to change the type (for example use a vldrb.8; // as opposed to a vldrw.32). This can allow extra addressing modes or; // alignments for what is otherwise an equivalent instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:26,Performance,load,loads,26,// We allow LE non-masked loads to change the type (for example use a vldrb.8; // as opposed to a vldrw.32). This can allow extra addressing modes or; // alignments for what is otherwise an equivalent instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:88,Availability,mask,masked,88,"// Try to find a matching instruction based on s/zext, Alignment, Offset and; // (in BE/masked) type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:194,Performance,load,load,194,"/// getPreIndexedAddressParts - returns true by value, base pointer and; /// offset pointer and addressing mode by reference if the node's address; /// can be legally represented as pre-indexed load / store address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:167,Performance,load,load,167,"/// getPostIndexedAddressParts - returns true by value, base pointer and; /// offset pointer and addressing mode by reference if this node can be; /// combined with a load / store to form a post-indexed load / store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:203,Performance,load,load,203,"/// getPostIndexedAddressParts - returns true by value, base pointer and; /// offset pointer and addressing mode by reference if this node can be; /// combined with a load / store to form a post-indexed load / store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:90,Modifiability,extend,extending,90,"// Thumb-1 can do a limited post-inc load or store as an updating LDM. It; // must be non-extending/truncating, i32, with an offset of 4.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:37,Performance,load,load,37,"// Thumb-1 can do a limited post-inc load or store as an updating LDM. It; // must be non-extending/truncating, i32, with an offset of 4.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:53,Performance,load,load,53,"// Swap base ptr and offset to catch more post-index load / store when; // it's legal. In Thumb2 mode, offset must be an immediate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:29,Deployability,update,update,29,// Post-indexed load / store update the base pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:16,Performance,load,load,16,// Post-indexed load / store update the base pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:34,Availability,down,down,34,"// Conservatively, we can recurse down the first operand; // and just mask out all affected bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:70,Availability,mask,mask,70,"// Conservatively, we can recurse down the first operand; // and just mask out all affected bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:35,Availability,mask,mask,35,// The operand to BFI is already a mask suitable for removing the bits it; // sets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:9,Performance,optimiz,optimization,9,"// Delay optimization, so we don't have to deal with illegal types, or block; // optimizations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:81,Performance,optimiz,optimizations,81,"// Delay optimization, so we don't have to deal with illegal types, or block; // optimizations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:8,Performance,optimiz,optimize,8,// Only optimize AND for now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:10,Availability,mask,mask,10,"// If the mask is all zeros, let the target-independent code replace the; // result with zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:10,Availability,mask,mask,10,"// If the mask is all ones, erase the AND. (Currently, the target-independent; // code won't do this, so we have to do it explicitly to avoid an infinite; // loop in obscure cases.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:136,Safety,avoid,avoid,136,"// If the mask is all ones, erase the AND. (Currently, the target-independent; // code won't do this, so we have to do it explicitly to avoid an infinite; // loop in obscure cases.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:15,Availability,mask,mask,15,// Prefer uxtb mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:10,Usability,ux,uxtb,10,// Prefer uxtb mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:15,Availability,mask,mask,15,// Prefer uxth mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:10,Usability,ux,uxth,10,// Prefer uxth mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:123,Performance,optimiz,optimizations,123,"// [1, 255] is Thumb1 movs+ands, legal immediate for ARM/Thumb2.; // FIXME: Prefer a contiguous sequence of bits for other optimizations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:125,Performance,optimiz,optimizations,125,"// [-256, -2] is Thumb1 movs+bics, legal immediate for ARM/Thumb2.; // FIXME: Prefer a contiguous sequence of bits for other optimizations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:376,Energy Efficiency,efficient,efficient,376,"// At this point, we have to lower this constraint to something else, so we; // lower it to an ""r"" or ""w"". However, by doing this we will force the result; // to be in register, while the X constraint is much more permissive.; //; // Although we are correct (we are free to emit anything, without; // constraints), we might break use cases that would expect us to be more; // efficient and emit something else.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:61,Usability,clear,clear,61,// This must be a constant between -4095 and 4095. It is not clear; // what this constraint is intended for. Implemented for; // compatibility with GCC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:162,Performance,load,loaded,162,// A 32-bit value where only one byte has a nonzero value. Exclude; // zero to match GCC. This constraint is used by GCC internally for; // constants that can be loaded with a move/shift combination.; // It is not useful otherwise but is implemented for compatibility.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:5,Energy Efficiency,power,power,5,"// A power of two or a constant between 0 and 32. This is used in; // GCC for the shift amount on shifted register operands, but it is; // useful in general for any shift amounts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:179,Performance,load,load,179,"/// isFPImmLegal - Returns true if the target can instruction select the; /// specified FP immediate natively. If false, the legalizer will; /// materialize the FP immediate as a load from a constant pool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:40,Performance,load,load,40,/// getTgtMemIntrinsic - Represent NEON load and store intrinsics as; /// MemIntrinsicNodes. The associated MachineMemOperands record the alignment; /// specified in the intrinsic calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:57,Performance,load,loaded,57,// Conservatively set memVT to the entire set of vectors loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:12,Performance,load,loads,12,// volatile loads with NEON intrinsics not supported,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:57,Performance,load,loaded,57,// Conservatively set memVT to the entire set of vectors loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:12,Performance,load,loads,12,// volatile loads with NEON intrinsics not supported,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:57,Performance,load,loaded,57,// Conservatively set memVT to the entire set of vectors loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:12,Performance,load,loads,12,// volatile loads with MVE intrinsics not supported,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:50,Performance,load,load,50,/// Returns true if it is beneficial to convert a load of a constant; /// to just the constant itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:37,Security,access,accesses,37,"// Instead of using barriers, atomic accesses on these subtargets use; // libcalls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:3,Performance,Load,Loads,3,"// Loads and stores less than 64-bits are already atomic; ones above that; // are doomed anyway, so defer to the default libcall and blame the OS when; // things go wrong. Cortex M doesn't have ldrexd/strexd though, so don't emit; // anything for those.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:3,Performance,Load,Loads,3,"// Loads and stores less than 64-bits are already atomic; ones above that; // are doomed anyway, so defer to the default libcall and blame the OS when; // things go wrong. Cortex M doesn't have ldrexd/strexd though, so don't emit; // anything for those.; // FIXME: ldrd and strd are atomic if the CPU has LPAE (e.g. A15 has that; // guarantee, see DDI0406C ARM architecture reference manual,; // sections A8.8.72-74 LDRD)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:238,Energy Efficiency,monitor,monitor,238,"// At -O0, fast-regalloc cannot cope with the live vregs necessary to; // implement atomicrmw without spilling. If the target address is also on; // the stack and close enough to the spill slot, this can lead to a; // situation where the monitor always gets cleared and the atomic operation; // can never succeed. So at -O0 lower this operation to a CAS loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:258,Usability,clear,cleared,258,"// At -O0, fast-regalloc cannot cope with the live vregs necessary to; // implement atomicrmw without spilling. If the target address is also on; // the stack and close enough to the spill slot, this can lead to a; // situation where the monitor always gets cleared and the atomic operation; // can never succeed. So at -O0 lower this operation to a CAS loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:245,Energy Efficiency,monitor,monitor,245,"// At -O0, fast-regalloc cannot cope with the live vregs necessary to; // implement cmpxchg without spilling. If the address being exchanged is also; // on the stack and close enough to the spill slot, this can lead to a; // situation where the monitor always gets cleared and the atomic operation; // can never succeed. So at -O0 we need a late-expanded pseudo-inst instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:265,Usability,clear,cleared,265,"// At -O0, fast-regalloc cannot cope with the live vregs necessary to; // implement cmpxchg without spilling. If the address being exchanged is also; // on the stack and close enough to the spill slot, this can lead to a; // situation where the monitor always gets cleared and the atomic operation; // can never succeed. So at -O0 we need a late-expanded pseudo-inst instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:25,Modifiability,variab,variable,25,// MSVC CRT has a global variable holding security cookie.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:42,Security,secur,security,42,// MSVC CRT has a global variable holding security cookie.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:30,Security,validat,validate,30,// MSVC CRT has a function to validate security cookie.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:39,Security,secur,security,39,// MSVC CRT has a function to validate security cookie.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:25,Modifiability,variab,variable,25,// MSVC CRT has a global variable holding security cookie.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:42,Security,secur,security,42,// MSVC CRT has a global variable holding security cookie.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:30,Security,validat,validate,30,// MSVC CRT has a function to validate security cookie.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:39,Security,secur,security,39,// MSVC CRT has a function to validate security cookie.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:42,Availability,mask,mask,42,// Sink the `and` instruction only if the mask would fit into a modified; // immediate operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:64,Security,access,accesses,64,/// A helper function for determining the number of interleaved accesses we; /// will generate when lowering accesses of the given type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:109,Security,access,accesses,109,/// A helper function for determining the number of interleaved accesses we; /// will generate when lowering accesses of the given type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:126,Security,access,accesses,126,// Ensure the total vector size is 64 or a multiple of 128. Types larger than; // 128 will be split into multiple interleaved accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:25,Performance,load,load,25,"/// Lower an interleaved load into a vldN intrinsic.; ///; /// E.g. Lower an interleaved load (Factor = 2):; /// %wide.vec = load <8 x i32>, <8 x i32>* %ptr, align 4; /// %v0 = shuffle %wide.vec, undef, <0, 2, 4, 6> ; Extract even elements; /// %v1 = shuffle %wide.vec, undef, <1, 3, 5, 7> ; Extract odd elements; ///; /// Into:; /// %vld2 = { <4 x i32>, <4 x i32> } call llvm.arm.neon.vld2(%ptr, 4); /// %vec0 = extractelement { <4 x i32>, <4 x i32> } %vld2, i32 0; /// %vec1 = extractelement { <4 x i32>, <4 x i32> } %vld2, i32 1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:89,Performance,load,load,89,"/// Lower an interleaved load into a vldN intrinsic.; ///; /// E.g. Lower an interleaved load (Factor = 2):; /// %wide.vec = load <8 x i32>, <8 x i32>* %ptr, align 4; /// %v0 = shuffle %wide.vec, undef, <0, 2, 4, 6> ; Extract even elements; /// %v1 = shuffle %wide.vec, undef, <1, 3, 5, 7> ; Extract odd elements; ///; /// Into:; /// %vld2 = { <4 x i32>, <4 x i32> } call llvm.arm.neon.vld2(%ptr, 4); /// %vec0 = extractelement { <4 x i32>, <4 x i32> } %vld2, i32 0; /// %vec1 = extractelement { <4 x i32>, <4 x i32> } %vld2, i32 1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:125,Performance,load,load,125,"/// Lower an interleaved load into a vldN intrinsic.; ///; /// E.g. Lower an interleaved load (Factor = 2):; /// %wide.vec = load <8 x i32>, <8 x i32>* %ptr, align 4; /// %v0 = shuffle %wide.vec, undef, <0, 2, 4, 6> ; Extract even elements; /// %v1 = shuffle %wide.vec, undef, <1, 3, 5, 7> ; Extract odd elements; ///; /// Into:; /// %vld2 = { <4 x i32>, <4 x i32> } call llvm.arm.neon.vld2(%ptr, 4); /// %vec0 = extractelement { <4 x i32>, <4 x i32> } %vld2, i32 0; /// %vec1 = extractelement { <4 x i32>, <4 x i32> } %vld2, i32 1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:128,Security,access,accesses,128,"// Skip if we do not have NEON and skip illegal vector types. We can; // ""legalize"" wide vector types into multiple interleaved accesses as long as; // the vector types are divisible by 128.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:82,Performance,load,load,82,// A pointer vector can not be the return type of the ldN intrinsics. Need to; // load integer vectors first and then convert to pointer vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:27,Performance,load,load,27,// The base address of the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:44,Performance,load,load,44,"// If we're going to generate more than one load, reset the sub-vector type; // to something legal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:40,Performance,load,load,40,// Holds sub-vectors extracted from the load intrinsic return values. The; // sub-vectors are associated with the shufflevector instructions they will; // replace.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:37,Performance,load,load,37,"// If we're generating more than one load, compute the base address of; // subsequent loads as an offset from the previous.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:86,Performance,load,loads,86,"// If we're generating more than one load, compute the base address of; // subsequent loads as an offset from the previous.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:68,Performance,load,loaded,68,// Replace uses of each shufflevector with the corresponding vector loaded; // by ldN.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:91,Performance,load,load,91,"// Replace uses of the shufflevector instructions with the sub-vectors; // returned by the load intrinsic. If a shufflevector instruction is; // associated with more than one sub-vector, those sub-vectors will be; // concatenated into a single wide vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:709,Availability,mask,mask,709,"/// Lower an interleaved store into a vstN intrinsic.; ///; /// E.g. Lower an interleaved store (Factor = 3):; /// %i.vec = shuffle <8 x i32> %v0, <8 x i32> %v1,; /// <0, 4, 8, 1, 5, 9, 2, 6, 10, 3, 7, 11>; /// store <12 x i32> %i.vec, <12 x i32>* %ptr, align 4; ///; /// Into:; /// %sub.v0 = shuffle <8 x i32> %v0, <8 x i32> v1, <0, 1, 2, 3>; /// %sub.v1 = shuffle <8 x i32> %v0, <8 x i32> v1, <4, 5, 6, 7>; /// %sub.v2 = shuffle <8 x i32> %v0, <8 x i32> v1, <8, 9, 10, 11>; /// call void llvm.arm.neon.vst3(%ptr, %sub.v0, %sub.v1, %sub.v2, 4); ///; /// Note that the new shufflevectors will be removed and we'll only generate one; /// vst3 instruction in CodeGen.; ///; /// Example for a more general valid mask (Factor 3). Lower:; /// %i.vec = shuffle <32 x i32> %v0, <32 x i32> %v1,; /// <4, 32, 16, 5, 33, 17, 6, 34, 18, 7, 35, 19>; /// store <12 x i32> %i.vec, <12 x i32>* %ptr; ///; /// Into:; /// %sub.v0 = shuffle <32 x i32> %v0, <32 x i32> v1, <4, 5, 6, 7>; /// %sub.v1 = shuffle <32 x i32> %v0, <32 x i32> v1, <32, 33, 34, 35>; /// %sub.v2 = shuffle <32 x i32> %v0, <32 x i32> v1, <16, 17, 18, 19>; /// call void llvm.arm.neon.vst3(%ptr, %sub.v0, %sub.v1, %sub.v2, 4)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:128,Security,access,accesses,128,"// Skip if we do not have NEON and skip illegal vector types. We can; // ""legalize"" wide vector types into multiple interleaved accesses as long as; // the vector types are divisible by 128.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:3,Safety,Avoid,Avoid,3,// Avoid over-aligning vector parameters. It would require realigning the; // stack and waste space for no real benefit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:3,Deployability,Update,Update,3,// Update IsSplitCSR in ARMFunctionInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:171,Security,access,access,171,"// Create copy from CSR to a virtual register.; // FIXME: this currently does not emit CFI pseudo-instructions, it works; // fine for CXX_FAST_TLS since the C++-style TLS access functions should be; // nounwind. If we want to generalize this later, we may need to emit; // CFI pseudo-instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:44,Integrability,Interface,Interface,44,"//===- ARMISelLowering.h - ARM DAG Lowering Interface -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that ARM uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:405,Integrability,interface,interfaces,405,"//===- ARMISelLowering.h - ARM DAG Lowering Interface -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that ARM uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:3,Integrability,Wrap,Wrapper,3,"// Wrapper - A wrapper node for TargetConstantPool,; // TargetExternalSymbol, and TargetGlobalAddress.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:15,Integrability,wrap,wrapper,15,"// Wrapper - A wrapper node for TargetConstantPool,; // TargetExternalSymbol, and TargetGlobalAddress.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:3,Integrability,Wrap,WrapperPIC,3,// WrapperPIC - A wrapper node for TargetGlobalAddress in; // PIC mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:18,Integrability,wrap,wrapper,18,// WrapperPIC - A wrapper node for TargetGlobalAddress in; // PIC mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:3,Integrability,Wrap,WrapperJT,3,// WrapperJT - A wrapper node for TargetJumpTable; // Add pseudo op to model memcpy for struct byval.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:17,Integrability,wrap,wrapper,17,// WrapperJT - A wrapper node for TargetJumpTable; // Add pseudo op to model memcpy for struct byval.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:12,Security,secur,secure,12,// CMSE non-secure function call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:24,Performance,perform,performs,24,"// Really a part of LE, performs the sub",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:25,Modifiability,extend,extending,25,// Legalization aids for extending a vector into two/four vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:15,Performance,load,load,15,"// stack store/load sequence, if not optimized to anything else.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:37,Performance,optimiz,optimized,37,"// stack store/load sequence, if not optimized to anything else.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:10,Testability,test,test,10,// Vector test bits.; // Vector shift by vector,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:8,Modifiability,extend,extend,8,// zero-extend vector extract element,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:8,Modifiability,extend,extend,8,// sign-extend vector extract element; // Vector move immediate and move negated immediate:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:17,Usability,clear,clearing,17,"// Move H <-> R, clearing top 16 bits",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:27,Availability,mask,mask,27,// 1-register shuffle with mask,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:27,Availability,mask,mask,27,// 2-register shuffle with mask,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:24,Modifiability,extend,extending,24,"// MVE vcvt f16 -> f32, extending from either the bottom or top lanes; // MVE VIDUP instruction, taking a start value and increment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:17,Modifiability,extend,extend,17,"// sign- or zero-extend the elements of a vector to i32,",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:47,Availability,mask,mask,47,// Same as VADDV[su] but with a v4i1 predicate mask,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:17,Modifiability,extend,extend,17,"// sign- or zero-extend elements to i64 and sum, returning",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:48,Availability,mask,mask,48,// Same as VADDLV[su] but with a v4i1 predicate mask,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:49,Availability,mask,mask,49,// Same as VADDLVp[su] but with a v4i1 predicate mask,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:17,Modifiability,extend,extend,17,"// sign- or zero-extend the elements of two vectors to i32, multiply",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:43,Availability,mask,mask,43,// Same as VMLAV[su] with a v4i1 predicate mask,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:44,Availability,mask,mask,44,// Same as VMLALV[su] with a v4i1 predicate mask,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:45,Availability,mask,mask,45,// Same as VMLALVA[su] with a v4i1 predicate mask,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:44,Performance,load,load,44,// Conditional select increment.; // Vector load N-element structure to all lanes:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:39,Deployability,update,updates,39,// NEON loads with post-increment base updates:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:8,Performance,load,loads,8,// NEON loads with post-increment base updates:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:40,Deployability,update,updates,40,// NEON stores with post-increment base updates:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:3,Performance,Load,Load,3,// Load/Store of dual registers,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:7,Availability,mask,mask,7,// Bit mask selecting rounding mode,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:166,Integrability,interface,interface,166,// end namespace ARM; //===--------------------------------------------------------------------===//; // ARMTargetLowering - ARM Implementation of the TargetLowering interface,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:93,Security,access,accesses,93,"/// allowsMisalignedMemoryAccesses - Returns true if the target allows; /// unaligned memory accesses of the specified type. Returns whether it; /// is ""fast"" by reference in the second argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:118,Performance,load,load,118,"/// isLegalAddressingMode - Return true if the addressing mode represented; /// by AM is legal for this target, for a load/store of the specified type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:102,Performance,load,load,102,"/// Returns true if the addressing mode representing by AM is legal; /// for the Thumb1 target, for a load/store of the specified type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:194,Performance,load,load,194,"/// getPreIndexedAddressParts - returns true by value, base pointer and; /// offset pointer and addressing mode by reference if the node's address; /// can be legally represented as pre-indexed load / store address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:167,Performance,load,load,167,"/// getPostIndexedAddressParts - returns true by value, base pointer and; /// offset pointer and addressing mode by reference if this node can be; /// combined with a load / store to form a post-indexed load / store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:203,Performance,load,load,203,"/// getPostIndexedAddressParts - returns true by value, base pointer and; /// offset pointer and addressing mode by reference if this node can be; /// combined with a load / store to form a post-indexed load / store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:179,Performance,load,load,179,"/// isFPImmLegal - Returns true if the target can instruction select the; /// specified FP immediate natively. If false, the legalizer will; /// materialize the FP immediate as a load from a constant pool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:50,Performance,load,load,50,/// Returns true if it is beneficial to convert a load of a constant; /// to just the constant itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:52,Security,access,access,52,/// Returns true if \p VecTy is a legal interleaved access type. This; /// function checks the vector element type and the overall width of the; /// vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:38,Security,access,accesses,38,/// Returns the number of interleaved accesses that will be generated when; /// lowering accesses of the given type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:89,Security,access,accesses,89,/// Returns the number of interleaved accesses that will be generated when; /// lowering accesses of the given type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:94,Performance,optimiz,optimization,94,/// IsEligibleForTailCallOptimization - Check whether the call is eligible; /// for tail call optimization. Targets which want to do tail call; /// optimization should implement this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:148,Performance,optimiz,optimization,148,/// IsEligibleForTailCallOptimization - Check whether the call is eligible; /// for tail call optimization. Targets which want to do tail call; /// optimization should implement this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLegalizerInfo.cpp:307,Energy Efficiency,power,power,307,"/// FIXME: The following static functions are SizeChangeStrategy functions; /// that are meant to temporarily mimic the behaviour of the old legalization; /// based on doubling/halving non-legal types as closely as possible. This is; /// not entirly possible as only legalizing the types that are exactly a power; /// of 2 times the size of the legal types would require specifying all those; /// sizes explicitly.; /// In practice, not specifying those isn't a problem, and the below functions; /// should disappear quickly as we add support for legalizing non-power-of-2; /// sized types further.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLegalizerInfo.cpp:562,Energy Efficiency,power,power-of-,562,"/// FIXME: The following static functions are SizeChangeStrategy functions; /// that are meant to temporarily mimic the behaviour of the old legalization; /// based on doubling/halving non-legal types as closely as possible. This is; /// not entirly possible as only legalizing the types that are exactly a power; /// of 2 times the size of the legal types would require specifying all those; /// sizes explicitly.; /// In practice, not specifying those isn't a problem, and the below functions; /// should disappear quickly as we add support for legalizing non-power-of-2; /// sized types further.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLegalizerInfo.cpp:24,Performance,load,loads,24,// Just expand whatever loads and stores are left.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:39,Performance,load,load,39,"//===- ARMLoadStoreOptimizer.cpp - ARM load / store opt. pass -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file This file contains a pass that performs load / store related peephole; /// optimizations. This pass should be run after register allocation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:421,Performance,perform,performs,421,"//===- ARMLoadStoreOptimizer.cpp - ARM load / store opt. pass -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file This file contains a pass that performs load / store related peephole; /// optimizations. This pass should be run after register allocation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:430,Performance,load,load,430,"//===- ARMLoadStoreOptimizer.cpp - ARM load / store opt. pass -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file This file contains a pass that performs load / store related peephole; /// optimizations. This pass should be run after register allocation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:465,Performance,optimiz,optimizations,465,"//===- ARMLoadStoreOptimizer.cpp - ARM load / store opt. pass -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file This file contains a pass that performs load / store related peephole; /// optimizations. This pass should be run after register allocation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:209,Availability,robust,robust,209,/// This switch disables formation of double/multi instructions that could; /// potentially lead to (new) alignment traps even with CCR.UNALIGN_TRP; /// disabled. This can be used to create libraries that are robust even when; /// users provoke undefined behaviour by supplying misaligned pointers.; /// \see mayCombineMisaligned(),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:47,Performance,load,load,47,/// Post- register allocation pass the combine load / store instructions to; /// form ldm / stm instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:13,Performance,load,load,13,/// A set of load/store MachineInstrs with same base register sorted by; /// offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:5,Performance,Load,Load,5,///< Load/Store offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:36,Performance,load,load,36,/// List of instructions ordered by load/store offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:59,Energy Efficiency,schedul,schedule,59,/// Index in Instrs of the instruction being latest in the schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:61,Energy Efficiency,schedul,schedule,61,/// Index in Instrs of the instruction being earliest in the schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:80,Performance,load,load,80,"// If the instruction has live CPSR def, then it's not safe to fold it; // into load / store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:55,Safety,safe,safe,55,"// If the instruction has live CPSR def, then it's not safe to fold it; // into load / store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:4,Deployability,Update,Update,4,/// Update future uses of the base register with the offset introduced; /// due to writeback. This function only works on Thumb1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:97,Deployability,update,updateable,97,// Start updating any instructions with immediate offsets. Insert a SUB before; // the first non-updateable instruction (if any).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:50,Deployability,update,updated,50,"// Loads and stores with immediate offsets can be updated, but only if; // the new offset isn't negative.; // The MachineOperand containing the offset immediate is the last one; // before predicates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:3,Performance,Load,Loads,3,"// Loads and stores with immediate offsets can be updated, but only if; // the new offset isn't negative.; // The MachineOperand containing the offset immediate is the last one; // before predicates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:39,Integrability,depend,depending,39,"// The offsets are scaled by 1, 2 or 4 depending on the Opcode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:85,Deployability,update,update,85,"// SUBS/ADDS using this register, with a dead def of the CPSR.; // Merge it with the update; if the merged offset is too large,; // insert a new sub instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:9,Deployability,update,update,9,// Can't update the instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:36,Deployability,update,updated,36,"// An instruction above couldn't be updated, so insert a sub.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:72,Energy Efficiency,schedul,schedule,72,/// Compute live registers just before instruction \p Before (in normal schedule; /// direction). Computes backwards so multiple queries in the same block must; /// come in reverse order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:128,Performance,load,loaded,128,/// Create and insert a LDM or STM with Base as base register and registers in; /// Regs as the register operands that would be loaded / stored. It returns; /// true if the transformation is done.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:148,Performance,load,loads,148,"// If starting offset isn't zero, insert a MI to materialize a new base.; // But only do so if it is cost effective, i.e. merging more than two; // loads / stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:14,Performance,load,load,14,"// If it is a load, then just use one of the destination registers; // as the new base. Will no longer be writeback in Thumb1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:30,Performance,load,load,30,// FIXME: There are no Thumb1 load/store instructions with negative; // offsets. So the Base != ARM::SP might be unnecessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:11,Integrability,depend,depending,11,"// Thumb1: depending on immediate size, use either; // ADDS NewBase, Base, #imm3; // or; // MOV NewBase, Base; // ADDS NewBase, #imm8.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:38,Deployability,update,update,38,// The following ADDS/SUBS becomes an update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:38,Safety,safe,safe,38,"// Check if a Thumb1 LDM/STM merge is safe. This is the case if:; // - There is no writeback (LDM of base register),; // - the base register is killed by the merged instruction,; // - or it's safe to overwrite the condition flags, i.e. to insert a SUBS; // to reset the base register.; // Otherwise, don't merge.; // It's safe to return here since the code to materialize a new base register; // above is also conditional on SafeToClobberCPSR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:192,Safety,safe,safe,192,"// Check if a Thumb1 LDM/STM merge is safe. This is the case if:; // - There is no writeback (LDM of base register),; // - the base register is killed by the merged instruction,; // - or it's safe to overwrite the condition flags, i.e. to insert a SUBS; // to reset the base register.; // Otherwise, don't merge.; // It's safe to return here since the code to materialize a new base register; // above is also conditional on SafeToClobberCPSR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:322,Safety,safe,safe,322,"// Check if a Thumb1 LDM/STM merge is safe. This is the case if:; // - There is no writeback (LDM of base register),; // - the base register is killed by the merged instruction,; // - or it's safe to overwrite the condition flags, i.e. to insert a SUBS; // to reset the base register.; // Otherwise, don't merge.; // It's safe to return here since the code to materialize a new base register; // above is also conditional on SafeToClobberCPSR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:425,Safety,Safe,SafeToClobberCPSR,425,"// Check if a Thumb1 LDM/STM merge is safe. This is the case if:; // - There is no writeback (LDM of base register),; // - the base register is killed by the merged instruction,; // - or it's safe to overwrite the condition flags, i.e. to insert a SUBS; // to reset the base register.; // Otherwise, don't merge.; // It's safe to return here since the code to materialize a new base register; // above is also conditional on SafeToClobberCPSR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:3,Deployability,Update,Update,3,// Update tLDMIA with writeback if necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:17,Usability,simpl,simply,17,"// No writeback, simply build the MachineInstr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:22,Deployability,update,update,22,/// Call MergeOps and update MemOps and merges accordingly on success.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:19,Performance,load,loads,19,"// If the previous loads defined a super-reg, then we have to mark earlier; // operands undef; Replicate the super-reg def on the merged instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:20,Performance,load,loads,20,/// Return true for loads/stores that can be combined to a double/multi; /// operation without increasing the requirements for alignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:93,Performance,load,loads,93,// Stack pointer alignment is out of the programmers control so we can trust; // SP-relative loads/stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:24,Performance,load,load,24,/// Find candidates for load/store multiple merge in list of MemOpQueueEntries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:107,Availability,fault,faulted,107,// ARM errata 602117: LDRD with base in list may result in incorrect base; // register when interrupted or faulted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:22,Performance,load,load,22,// See if the current load/store may be part of a multi load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:56,Performance,load,load,56,// See if the current load/store may be part of a multi load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:18,Performance,load,load,18,"// For VFP / NEON load/store multiples, the registers must be; // consecutive and within the limit on the number of registers per; // instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:22,Performance,load,load,22,// See if the current load/store may be part of a double load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:57,Performance,load,load,57,// See if the current load/store may be part of a double load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:36,Performance,load,loads,36,// Thumb1 is already using updating loads/stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:175,Safety,hazard,hazards,175,"// We couldn't find an inc/dec to merge. But if the base is dead, we; // can still change to a writeback form as that will save us 2 bytes; // of code size. It can create WAW hazards though, so only do it if; // we're minimizing code size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:119,Performance,load,load,119,"// VLDM[SD]_UPD, VSTM[SD]_UPD; // (There are no base-updating versions of VLDR/VSTR instructions, but the; // updating load/store-multiple instructions can be used with only one; // register.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:31,Security,access,accesses,31,"// Don't touch volatile memory accesses - we may be changing their order.; // TODO: We could allow unordered and monotonic atomics here, but we need to; // make sure the resulting ldm/stm is correctly marked as atomic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:86,Safety,avoid,avoid,86,"// str <undef> could probably be eliminated entirely, but for now we just want; // to avoid making a mess of it.; // FIXME: Use str <undef> as a wildcard to enable better stm folding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:59,Security,access,accesses,59,"// FIXME: This is overly conservative; the new instruction accesses 4; // bytes, not 8.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:59,Security,access,accesses,59,"// FIXME: This is overly conservative; the new instruction accesses 4; // bytes, not 8.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:107,Availability,fault,faulted,107,// ARM errata 602117: LDRD with base in list may result in incorrect base; // register when interrupted or faulted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:50,Safety,safe,safe,50,// Ascending register numbers and no offset. It's safe to change it to a; // ldm or stm.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:16,Performance,load,load,16,"// If this is a load, make sure the first load does not clobber the base; // register before the second load reads it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:42,Performance,load,load,42,"// If this is a load, make sure the first load does not clobber the base; // register before the second load reads it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:104,Performance,load,load,104,"// If this is a load, make sure the first load does not clobber the base; // register before the second load reads it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:7,Performance,optimiz,optimization,7,/// An optimization pass to turn multiple LDR / STR ops of the same base and; /// incrementing offset into LDM / STM ops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:99,Performance,load,load,99,"// Watch out for:; // r4 := ldr [r0, #8]; // r4 := ldr [r0, #4]; // or; // r0 := ldr [r0]; // If a load overrides the base register or a register loaded by; // another load in our chain, we cannot take this instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:146,Performance,load,loaded,146,"// Watch out for:; // r4 := ldr [r0, #8]; // r4 := ldr [r0, #4]; // or; // r0 := ldr [r0]; // If a load overrides the base register or a register loaded by; // another load in our chain, we cannot take this instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:168,Performance,load,load,168,"// Watch out for:; // r4 := ldr [r0, #8]; // r4 := ldr [r0, #4]; // or; // r0 := ldr [r0]; // If a load overrides the base register or a register loaded by; // another load in our chain, we cannot take this instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:14,Safety,abort,abort,14,"// Collision, abort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:44,Performance,load,load,44,/// Pre- register allocation pass that move load / stores from consecutive; /// locations close to make it more likely they will be combined later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:66,Performance,tune,tune,66,"// Limit the number of instructions to be rescheduled.; // FIXME: tune this limit, and/or come up with some better heuristics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:22,Performance,load,loads,22,// Are there stores / loads / calls between them?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:7,Performance,load,loads,7,// The loads / stores of the same base are in order. Scan them from first to; // last and check for the following:; // 1. Any def of base.; // 2. Any gaps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:24,Deployability,continuous,continuous,24,// Check that we have a continuous set of offsets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:10,Performance,Tune,Tune,10,// FIXME: Tune this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:36,Performance,load,loads,36,// This is the new location for the loads / stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:82,Energy Efficiency,allocate,allocate,82,"// If we are moving a pair of loads / stores, see if it makes sense; // to try to allocate a pair of registers that can form register pairs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:30,Performance,load,loads,30,"// If we are moving a pair of loads / stores, see if it makes sense; // to try to allocate a pair of registers that can form register pairs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:54,Performance,load,loads,54,// Populate RegisterMap with all Registers defined by loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:3,Deployability,Update,Update,3,// Update the RegisterMap with the instruction that was moved because a; // DBG_VALUE_LIST may need to be moved again.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:103,Performance,load,load,103,// This map is used to track the relationship between the virtual; // register that is the result of a load that is moved and the DBG_VALUE; // MachineInstr pointer that uses that virtual register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:6,Energy Efficiency,schedul,schedule,6,// Re-schedule loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:15,Performance,load,loads,15,// Re-schedule loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:6,Energy Efficiency,schedul,schedule,6,// Re-schedule stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:2826,Deployability,update,updated,2826,"..; // %3 = ld ...; // %4 = ld ...; // The algorithm below does the following:; // In the beginning, the RegisterMap will have been populated with the virtual; // registers %2, and %3, the DbgValueSinkCandidates and the InstrMap will be; // empty. DbgValueSinkCandidates = {}, RegisterMap = {2 -> {}, 3 -> {}},; // InstrMap {}; // -> DBG_VALUE %2, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // After the first DBG_VALUE (denoted with an X) is processed, the; // DbgValueSinkCandidates and InstrMap will be populated and the RegisterMap; // entry for %2 will be populated as well. DbgValueSinkCandidates = {A -> X},; // RegisterMap = {2 -> {X}, 3 -> {}}, InstrMap {X -> 2}; // DBG_VALUE %2, A, .... # X; // -> DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // After the DBG_VALUE Y is processed, the DbgValueSinkCandidates is updated; // to now hold Y for A and the RegisterMap is also updated to remove X from; // %2, this is because both X and Y describe the same debug variable A. X is; // also updated to have a $noreg as the first operand.; // DbgValueSinkCandidates = {A -> {Y}}, RegisterMap = {2 -> {}, 3 -> {}},; // InstrMap = {X-> 2}; // DBG_VALUE $noreg, A, .... # X; // DBG_VALUE 0, A, ... # Y; // -> DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // After DBG_VALUE Z is processed, the DbgValueSinkCandidates is updated to; // hold Z fr A, the RegisterMap is updated to hold Z for %3, and the InstrMap; // is updated to have Z mapped to %3. This is again because Z describes the; // debug variable A, Y is not updated to have $noreg as first operand because; // its first operand is an immediate, not a register.; // DbgValueSinkCandidates = {A -> {Z}}, RegisterMap = {2 -> {}, 3 -> {Z}},; // InstrMap = {X -> 2, Z -> 3}; // DBG_VALUE $noreg, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // -> %2 = ld .",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:2886,Deployability,update,updated,2886,"..; // %3 = ld ...; // %4 = ld ...; // The algorithm below does the following:; // In the beginning, the RegisterMap will have been populated with the virtual; // registers %2, and %3, the DbgValueSinkCandidates and the InstrMap will be; // empty. DbgValueSinkCandidates = {}, RegisterMap = {2 -> {}, 3 -> {}},; // InstrMap {}; // -> DBG_VALUE %2, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // After the first DBG_VALUE (denoted with an X) is processed, the; // DbgValueSinkCandidates and InstrMap will be populated and the RegisterMap; // entry for %2 will be populated as well. DbgValueSinkCandidates = {A -> X},; // RegisterMap = {2 -> {X}, 3 -> {}}, InstrMap {X -> 2}; // DBG_VALUE %2, A, .... # X; // -> DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // After the DBG_VALUE Y is processed, the DbgValueSinkCandidates is updated; // to now hold Y for A and the RegisterMap is also updated to remove X from; // %2, this is because both X and Y describe the same debug variable A. X is; // also updated to have a $noreg as the first operand.; // DbgValueSinkCandidates = {A -> {Y}}, RegisterMap = {2 -> {}, 3 -> {}},; // InstrMap = {X-> 2}; // DBG_VALUE $noreg, A, .... # X; // DBG_VALUE 0, A, ... # Y; // -> DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // After DBG_VALUE Z is processed, the DbgValueSinkCandidates is updated to; // hold Z fr A, the RegisterMap is updated to hold Z for %3, and the InstrMap; // is updated to have Z mapped to %3. This is again because Z describes the; // debug variable A, Y is not updated to have $noreg as first operand because; // its first operand is an immediate, not a register.; // DbgValueSinkCandidates = {A -> {Z}}, RegisterMap = {2 -> {}, 3 -> {Z}},; // InstrMap = {X -> 2, Z -> 3}; // DBG_VALUE $noreg, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // -> %2 = ld .",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:2998,Deployability,update,updated,2998,"th the virtual; // registers %2, and %3, the DbgValueSinkCandidates and the InstrMap will be; // empty. DbgValueSinkCandidates = {}, RegisterMap = {2 -> {}, 3 -> {}},; // InstrMap {}; // -> DBG_VALUE %2, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // After the first DBG_VALUE (denoted with an X) is processed, the; // DbgValueSinkCandidates and InstrMap will be populated and the RegisterMap; // entry for %2 will be populated as well. DbgValueSinkCandidates = {A -> X},; // RegisterMap = {2 -> {X}, 3 -> {}}, InstrMap {X -> 2}; // DBG_VALUE %2, A, .... # X; // -> DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // After the DBG_VALUE Y is processed, the DbgValueSinkCandidates is updated; // to now hold Y for A and the RegisterMap is also updated to remove X from; // %2, this is because both X and Y describe the same debug variable A. X is; // also updated to have a $noreg as the first operand.; // DbgValueSinkCandidates = {A -> {Y}}, RegisterMap = {2 -> {}, 3 -> {}},; // InstrMap = {X-> 2}; // DBG_VALUE $noreg, A, .... # X; // DBG_VALUE 0, A, ... # Y; // -> DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // After DBG_VALUE Z is processed, the DbgValueSinkCandidates is updated to; // hold Z fr A, the RegisterMap is updated to hold Z for %3, and the InstrMap; // is updated to have Z mapped to %3. This is again because Z describes the; // debug variable A, Y is not updated to have $noreg as first operand because; // its first operand is an immediate, not a register.; // DbgValueSinkCandidates = {A -> {Z}}, RegisterMap = {2 -> {}, 3 -> {Z}},; // InstrMap = {X -> 2, Z -> 3}; // DBG_VALUE $noreg, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // -> %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // Nothing happens here since the RegisterMap for %2 contains no value.; // DbgValueSinkCandidates = {A -> {Z",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:3352,Deployability,update,updated,3352,"X) is processed, the; // DbgValueSinkCandidates and InstrMap will be populated and the RegisterMap; // entry for %2 will be populated as well. DbgValueSinkCandidates = {A -> X},; // RegisterMap = {2 -> {X}, 3 -> {}}, InstrMap {X -> 2}; // DBG_VALUE %2, A, .... # X; // -> DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // After the DBG_VALUE Y is processed, the DbgValueSinkCandidates is updated; // to now hold Y for A and the RegisterMap is also updated to remove X from; // %2, this is because both X and Y describe the same debug variable A. X is; // also updated to have a $noreg as the first operand.; // DbgValueSinkCandidates = {A -> {Y}}, RegisterMap = {2 -> {}, 3 -> {}},; // InstrMap = {X-> 2}; // DBG_VALUE $noreg, A, .... # X; // DBG_VALUE 0, A, ... # Y; // -> DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // After DBG_VALUE Z is processed, the DbgValueSinkCandidates is updated to; // hold Z fr A, the RegisterMap is updated to hold Z for %3, and the InstrMap; // is updated to have Z mapped to %3. This is again because Z describes the; // debug variable A, Y is not updated to have $noreg as first operand because; // its first operand is an immediate, not a register.; // DbgValueSinkCandidates = {A -> {Z}}, RegisterMap = {2 -> {}, 3 -> {Z}},; // InstrMap = {X -> 2, Z -> 3}; // DBG_VALUE $noreg, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // -> %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // Nothing happens here since the RegisterMap for %2 contains no value.; // DbgValueSinkCandidates = {A -> {Z}}, RegisterMap = {2 -> {}, 3 -> {Z}},; // InstrMap = {X -> 2, Z -> 3}; // DBG_VALUE $noreg, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // -> %3 = ld ...; // %4 = ld ...; // Since the RegisterMap contains Z as a value for %3, the MachineInstr; // pointer Z is copied to come after the load for %3 and the old Z's first; // op",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:3399,Deployability,update,updated,3399,"X) is processed, the; // DbgValueSinkCandidates and InstrMap will be populated and the RegisterMap; // entry for %2 will be populated as well. DbgValueSinkCandidates = {A -> X},; // RegisterMap = {2 -> {X}, 3 -> {}}, InstrMap {X -> 2}; // DBG_VALUE %2, A, .... # X; // -> DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // After the DBG_VALUE Y is processed, the DbgValueSinkCandidates is updated; // to now hold Y for A and the RegisterMap is also updated to remove X from; // %2, this is because both X and Y describe the same debug variable A. X is; // also updated to have a $noreg as the first operand.; // DbgValueSinkCandidates = {A -> {Y}}, RegisterMap = {2 -> {}, 3 -> {}},; // InstrMap = {X-> 2}; // DBG_VALUE $noreg, A, .... # X; // DBG_VALUE 0, A, ... # Y; // -> DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // After DBG_VALUE Z is processed, the DbgValueSinkCandidates is updated to; // hold Z fr A, the RegisterMap is updated to hold Z for %3, and the InstrMap; // is updated to have Z mapped to %3. This is again because Z describes the; // debug variable A, Y is not updated to have $noreg as first operand because; // its first operand is an immediate, not a register.; // DbgValueSinkCandidates = {A -> {Z}}, RegisterMap = {2 -> {}, 3 -> {Z}},; // InstrMap = {X -> 2, Z -> 3}; // DBG_VALUE $noreg, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // -> %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // Nothing happens here since the RegisterMap for %2 contains no value.; // DbgValueSinkCandidates = {A -> {Z}}, RegisterMap = {2 -> {}, 3 -> {Z}},; // InstrMap = {X -> 2, Z -> 3}; // DBG_VALUE $noreg, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // -> %3 = ld ...; // %4 = ld ...; // Since the RegisterMap contains Z as a value for %3, the MachineInstr; // pointer Z is copied to come after the load for %3 and the old Z's first; // op",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:3449,Deployability,update,updated,3449,"X) is processed, the; // DbgValueSinkCandidates and InstrMap will be populated and the RegisterMap; // entry for %2 will be populated as well. DbgValueSinkCandidates = {A -> X},; // RegisterMap = {2 -> {X}, 3 -> {}}, InstrMap {X -> 2}; // DBG_VALUE %2, A, .... # X; // -> DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // After the DBG_VALUE Y is processed, the DbgValueSinkCandidates is updated; // to now hold Y for A and the RegisterMap is also updated to remove X from; // %2, this is because both X and Y describe the same debug variable A. X is; // also updated to have a $noreg as the first operand.; // DbgValueSinkCandidates = {A -> {Y}}, RegisterMap = {2 -> {}, 3 -> {}},; // InstrMap = {X-> 2}; // DBG_VALUE $noreg, A, .... # X; // DBG_VALUE 0, A, ... # Y; // -> DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // After DBG_VALUE Z is processed, the DbgValueSinkCandidates is updated to; // hold Z fr A, the RegisterMap is updated to hold Z for %3, and the InstrMap; // is updated to have Z mapped to %3. This is again because Z describes the; // debug variable A, Y is not updated to have $noreg as first operand because; // its first operand is an immediate, not a register.; // DbgValueSinkCandidates = {A -> {Z}}, RegisterMap = {2 -> {}, 3 -> {Z}},; // InstrMap = {X -> 2, Z -> 3}; // DBG_VALUE $noreg, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // -> %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // Nothing happens here since the RegisterMap for %2 contains no value.; // DbgValueSinkCandidates = {A -> {Z}}, RegisterMap = {2 -> {}, 3 -> {Z}},; // InstrMap = {X -> 2, Z -> 3}; // DBG_VALUE $noreg, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // -> %3 = ld ...; // %4 = ld ...; // Since the RegisterMap contains Z as a value for %3, the MachineInstr; // pointer Z is copied to come after the load for %3 and the old Z's first; // op",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:3550,Deployability,update,updated,3550,"gisterMap = {2 -> {X}, 3 -> {}}, InstrMap {X -> 2}; // DBG_VALUE %2, A, .... # X; // -> DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // After the DBG_VALUE Y is processed, the DbgValueSinkCandidates is updated; // to now hold Y for A and the RegisterMap is also updated to remove X from; // %2, this is because both X and Y describe the same debug variable A. X is; // also updated to have a $noreg as the first operand.; // DbgValueSinkCandidates = {A -> {Y}}, RegisterMap = {2 -> {}, 3 -> {}},; // InstrMap = {X-> 2}; // DBG_VALUE $noreg, A, .... # X; // DBG_VALUE 0, A, ... # Y; // -> DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // After DBG_VALUE Z is processed, the DbgValueSinkCandidates is updated to; // hold Z fr A, the RegisterMap is updated to hold Z for %3, and the InstrMap; // is updated to have Z mapped to %3. This is again because Z describes the; // debug variable A, Y is not updated to have $noreg as first operand because; // its first operand is an immediate, not a register.; // DbgValueSinkCandidates = {A -> {Z}}, RegisterMap = {2 -> {}, 3 -> {Z}},; // InstrMap = {X -> 2, Z -> 3}; // DBG_VALUE $noreg, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // -> %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // Nothing happens here since the RegisterMap for %2 contains no value.; // DbgValueSinkCandidates = {A -> {Z}}, RegisterMap = {2 -> {}, 3 -> {Z}},; // InstrMap = {X -> 2, Z -> 3}; // DBG_VALUE $noreg, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // -> %3 = ld ...; // %4 = ld ...; // Since the RegisterMap contains Z as a value for %3, the MachineInstr; // pointer Z is copied to come after the load for %3 and the old Z's first; // operand is changed to $noreg the Basic Block iterator is moved to after the; // DBG_VALUE Z's new position.; // DbgValueSinkCandidates = {A -> {Z}}, RegisterMap = {2 -> {}, 3 -> {Z}},; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:1170,Modifiability,variab,variable,1170," info.; // Example:; // Before the Pre Register Allocation Load Store Pass; // inst_a; // %2 = ld ...; // inst_b; // DBG_VALUE %2, ""x"", ...; // %3 = ld ...; // After the Pass:; // inst_a; // inst_b; // DBG_VALUE %2, ""x"", ...; // %2 = ld ...; // %3 = ld ...; // The code below addresses this by moving the DBG_VALUE to the position; // immediately after the load.; // Example:; // After the code below:; // inst_a; // inst_b; // %2 = ld ...; // DBG_VALUE %2, ""x"", ...; // %3 = ld ...; // The algorithm works in two phases: First RescheduleOps() populates the; // RegisterMap with registers that were moved as keys, there is no value; // inserted. In the next phase, every MachineInstr in a basic block is; // iterated over. If it is a valid DBG_VALUE or DBG_VALUE_LIST and it uses one; // or more registers in the RegisterMap, the RegisterMap and InstrMap are; // populated with the MachineInstr. If the DBG_VALUE or DBG_VALUE_LIST; // describes debug information for a variable that already exists in the; // DbgValueSinkCandidates, the MachineInstr in the DbgValueSinkCandidates must; // be set to undef. If the current MachineInstr is a load that was moved,; // undef the corresponding DBG_VALUE or DBG_VALUE_LIST and clone it to below; // the load.; // To illustrate the above algorithm visually let's take this example.; // Before the Pre Register Allocation Load Store Pass:; // %2 = ld ...; // DBG_VALUE %2, A, .... # X; // DBG_VALUE 0, A, ... # Y; // %3 = ld ...; // DBG_VALUE %3, A, ..., # Z; // %4 = ld ...; // After Pre Register Allocation Load Store Pass:; // DBG_VALUE %2, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // The algorithm below does the following:; // In the beginning, the RegisterMap will have been populated with the virtual; // registers %2, and %3, the DbgValueSinkCandidates and the InstrMap will be; // empty. DbgValueSinkCandidates = {}, RegisterMap = {2 -> {}, 3 -> {}},; // InstrMap {}; // -",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:2972,Modifiability,variab,variable,2972,"..; // %3 = ld ...; // %4 = ld ...; // The algorithm below does the following:; // In the beginning, the RegisterMap will have been populated with the virtual; // registers %2, and %3, the DbgValueSinkCandidates and the InstrMap will be; // empty. DbgValueSinkCandidates = {}, RegisterMap = {2 -> {}, 3 -> {}},; // InstrMap {}; // -> DBG_VALUE %2, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // After the first DBG_VALUE (denoted with an X) is processed, the; // DbgValueSinkCandidates and InstrMap will be populated and the RegisterMap; // entry for %2 will be populated as well. DbgValueSinkCandidates = {A -> X},; // RegisterMap = {2 -> {X}, 3 -> {}}, InstrMap {X -> 2}; // DBG_VALUE %2, A, .... # X; // -> DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // After the DBG_VALUE Y is processed, the DbgValueSinkCandidates is updated; // to now hold Y for A and the RegisterMap is also updated to remove X from; // %2, this is because both X and Y describe the same debug variable A. X is; // also updated to have a $noreg as the first operand.; // DbgValueSinkCandidates = {A -> {Y}}, RegisterMap = {2 -> {}, 3 -> {}},; // InstrMap = {X-> 2}; // DBG_VALUE $noreg, A, .... # X; // DBG_VALUE 0, A, ... # Y; // -> DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // After DBG_VALUE Z is processed, the DbgValueSinkCandidates is updated to; // hold Z fr A, the RegisterMap is updated to hold Z for %3, and the InstrMap; // is updated to have Z mapped to %3. This is again because Z describes the; // debug variable A, Y is not updated to have $noreg as first operand because; // its first operand is an immediate, not a register.; // DbgValueSinkCandidates = {A -> {Z}}, RegisterMap = {2 -> {}, 3 -> {Z}},; // InstrMap = {X -> 2, Z -> 3}; // DBG_VALUE $noreg, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // -> %2 = ld .",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:3529,Modifiability,variab,variable,3529,"gisterMap = {2 -> {X}, 3 -> {}}, InstrMap {X -> 2}; // DBG_VALUE %2, A, .... # X; // -> DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // After the DBG_VALUE Y is processed, the DbgValueSinkCandidates is updated; // to now hold Y for A and the RegisterMap is also updated to remove X from; // %2, this is because both X and Y describe the same debug variable A. X is; // also updated to have a $noreg as the first operand.; // DbgValueSinkCandidates = {A -> {Y}}, RegisterMap = {2 -> {}, 3 -> {}},; // InstrMap = {X-> 2}; // DBG_VALUE $noreg, A, .... # X; // DBG_VALUE 0, A, ... # Y; // -> DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // After DBG_VALUE Z is processed, the DbgValueSinkCandidates is updated to; // hold Z fr A, the RegisterMap is updated to hold Z for %3, and the InstrMap; // is updated to have Z mapped to %3. This is again because Z describes the; // debug variable A, Y is not updated to have $noreg as first operand because; // its first operand is an immediate, not a register.; // DbgValueSinkCandidates = {A -> {Z}}, RegisterMap = {2 -> {}, 3 -> {Z}},; // InstrMap = {X -> 2, Z -> 3}; // DBG_VALUE $noreg, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // -> %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // Nothing happens here since the RegisterMap for %2 contains no value.; // DbgValueSinkCandidates = {A -> {Z}}, RegisterMap = {2 -> {}, 3 -> {Z}},; // InstrMap = {X -> 2, Z -> 3}; // DBG_VALUE $noreg, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // -> %3 = ld ...; // %4 = ld ...; // Since the RegisterMap contains Z as a value for %3, the MachineInstr; // pointer Z is copied to come after the load for %3 and the old Z's first; // operand is changed to $noreg the Basic Block iterator is moved to after the; // DBG_VALUE Z's new position.; // DbgValueSinkCandidates = {A -> {Z}}, RegisterMap = {2 -> {}, 3 -> {Z}},; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:5227,Modifiability,Variab,Variable,5227,"ndidates is updated to; // hold Z fr A, the RegisterMap is updated to hold Z for %3, and the InstrMap; // is updated to have Z mapped to %3. This is again because Z describes the; // debug variable A, Y is not updated to have $noreg as first operand because; // its first operand is an immediate, not a register.; // DbgValueSinkCandidates = {A -> {Z}}, RegisterMap = {2 -> {}, 3 -> {Z}},; // InstrMap = {X -> 2, Z -> 3}; // DBG_VALUE $noreg, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // -> %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // Nothing happens here since the RegisterMap for %2 contains no value.; // DbgValueSinkCandidates = {A -> {Z}}, RegisterMap = {2 -> {}, 3 -> {Z}},; // InstrMap = {X -> 2, Z -> 3}; // DBG_VALUE $noreg, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // -> %3 = ld ...; // %4 = ld ...; // Since the RegisterMap contains Z as a value for %3, the MachineInstr; // pointer Z is copied to come after the load for %3 and the old Z's first; // operand is changed to $noreg the Basic Block iterator is moved to after the; // DBG_VALUE Z's new position.; // DbgValueSinkCandidates = {A -> {Z}}, RegisterMap = {2 -> {}, 3 -> {Z}},; // InstrMap = {X -> 2, Z -> 3}; // DBG_VALUE $noreg, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE $noreg, A, ..., # Old Z; // %2 = ld ...; // %3 = ld ...; // DBG_VALUE %3, A, ..., # Z; // -> %4 = ld ...; // Nothing happens for %4 and the algorithm exits having processed the entire; // Basic Block.; // DbgValueSinkCandidates = {A -> {Z}}, RegisterMap = {2 -> {}, 3 -> {Z}},; // InstrMap = {X -> 2, Z -> 3}; // DBG_VALUE $noreg, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE $noreg, A, ..., # Old Z; // %2 = ld ...; // %3 = ld ...; // DBG_VALUE %3, A, ..., # Z; // %4 = ld ...; // This map is used to track the relationship between; // a Debug Variable and the DBG_VALUE MachineInstr pointer that describes the; // debug information for that Debug Variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:5331,Modifiability,Variab,Variable,5331,"ndidates is updated to; // hold Z fr A, the RegisterMap is updated to hold Z for %3, and the InstrMap; // is updated to have Z mapped to %3. This is again because Z describes the; // debug variable A, Y is not updated to have $noreg as first operand because; // its first operand is an immediate, not a register.; // DbgValueSinkCandidates = {A -> {Z}}, RegisterMap = {2 -> {}, 3 -> {Z}},; // InstrMap = {X -> 2, Z -> 3}; // DBG_VALUE $noreg, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // -> %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // Nothing happens here since the RegisterMap for %2 contains no value.; // DbgValueSinkCandidates = {A -> {Z}}, RegisterMap = {2 -> {}, 3 -> {Z}},; // InstrMap = {X -> 2, Z -> 3}; // DBG_VALUE $noreg, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // -> %3 = ld ...; // %4 = ld ...; // Since the RegisterMap contains Z as a value for %3, the MachineInstr; // pointer Z is copied to come after the load for %3 and the old Z's first; // operand is changed to $noreg the Basic Block iterator is moved to after the; // DBG_VALUE Z's new position.; // DbgValueSinkCandidates = {A -> {Z}}, RegisterMap = {2 -> {}, 3 -> {Z}},; // InstrMap = {X -> 2, Z -> 3}; // DBG_VALUE $noreg, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE $noreg, A, ..., # Old Z; // %2 = ld ...; // %3 = ld ...; // DBG_VALUE %3, A, ..., # Z; // -> %4 = ld ...; // Nothing happens for %4 and the algorithm exits having processed the entire; // Basic Block.; // DbgValueSinkCandidates = {A -> {Z}}, RegisterMap = {2 -> {}, 3 -> {Z}},; // InstrMap = {X -> 2, Z -> 3}; // DBG_VALUE $noreg, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE $noreg, A, ..., # Old Z; // %2 = ld ...; // %3 = ld ...; // DBG_VALUE %3, A, ..., # Z; // %4 = ld ...; // This map is used to track the relationship between; // a Debug Variable and the DBG_VALUE MachineInstr pointer that describes the; // debug information for that Debug Variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:38,Performance,load,loads,38,"// Reschedule DBG_VALUEs to match any loads that were moved. When a load is; // sunk beyond a DBG_VALUE that is referring to it, the DBG_VALUE becomes a; // use-before-def, resulting in a loss of debug info.; // Example:; // Before the Pre Register Allocation Load Store Pass; // inst_a; // %2 = ld ...; // inst_b; // DBG_VALUE %2, ""x"", ...; // %3 = ld ...; // After the Pass:; // inst_a; // inst_b; // DBG_VALUE %2, ""x"", ...; // %2 = ld ...; // %3 = ld ...; // The code below addresses this by moving the DBG_VALUE to the position; // immediately after the load.; // Example:; // After the code below:; // inst_a; // inst_b; // %2 = ld ...; // DBG_VALUE %2, ""x"", ...; // %3 = ld ...; // The algorithm works in two phases: First RescheduleOps() populates the; // RegisterMap with registers that were moved as keys, there is no value; // inserted. In the next phase, every MachineInstr in a basic block is; // iterated over. If it is a valid DBG_VALUE or DBG_VALUE_LIST and it uses one; // or more registers in the RegisterMap, the RegisterMap and InstrMap are; // populated with the MachineInstr. If the DBG_VALUE or DBG_VALUE_LIST; // describes debug information for a variable that already exists in the; // DbgValueSinkCandidates, the MachineInstr in the DbgValueSinkCandidates must; // be set to undef. If the current MachineInstr is a load that was moved,; // undef the corresponding DBG_VALUE or DBG_VALUE_LIST and clone it to below; // the load.; // To illustrate the above algorithm visually let's take this example.; // Before the Pre Register Allocation Load Store Pass:; // %2 = ld ...; // DBG_VALUE %2, A, .... # X; // DBG_VALUE 0, A, ... # Y; // %3 = ld ...; // DBG_VALUE %3, A, ..., # Z; // %4 = ld ...; // After Pre Register Allocation Load Store Pass:; // DBG_VALUE %2, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // The algorithm below does the following:; // In the beginning, the RegisterMap will have been ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:68,Performance,load,load,68,"// Reschedule DBG_VALUEs to match any loads that were moved. When a load is; // sunk beyond a DBG_VALUE that is referring to it, the DBG_VALUE becomes a; // use-before-def, resulting in a loss of debug info.; // Example:; // Before the Pre Register Allocation Load Store Pass; // inst_a; // %2 = ld ...; // inst_b; // DBG_VALUE %2, ""x"", ...; // %3 = ld ...; // After the Pass:; // inst_a; // inst_b; // DBG_VALUE %2, ""x"", ...; // %2 = ld ...; // %3 = ld ...; // The code below addresses this by moving the DBG_VALUE to the position; // immediately after the load.; // Example:; // After the code below:; // inst_a; // inst_b; // %2 = ld ...; // DBG_VALUE %2, ""x"", ...; // %3 = ld ...; // The algorithm works in two phases: First RescheduleOps() populates the; // RegisterMap with registers that were moved as keys, there is no value; // inserted. In the next phase, every MachineInstr in a basic block is; // iterated over. If it is a valid DBG_VALUE or DBG_VALUE_LIST and it uses one; // or more registers in the RegisterMap, the RegisterMap and InstrMap are; // populated with the MachineInstr. If the DBG_VALUE or DBG_VALUE_LIST; // describes debug information for a variable that already exists in the; // DbgValueSinkCandidates, the MachineInstr in the DbgValueSinkCandidates must; // be set to undef. If the current MachineInstr is a load that was moved,; // undef the corresponding DBG_VALUE or DBG_VALUE_LIST and clone it to below; // the load.; // To illustrate the above algorithm visually let's take this example.; // Before the Pre Register Allocation Load Store Pass:; // %2 = ld ...; // DBG_VALUE %2, A, .... # X; // DBG_VALUE 0, A, ... # Y; // %3 = ld ...; // DBG_VALUE %3, A, ..., # Z; // %4 = ld ...; // After Pre Register Allocation Load Store Pass:; // DBG_VALUE %2, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // The algorithm below does the following:; // In the beginning, the RegisterMap will have been ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:260,Performance,Load,Load,260,"// Reschedule DBG_VALUEs to match any loads that were moved. When a load is; // sunk beyond a DBG_VALUE that is referring to it, the DBG_VALUE becomes a; // use-before-def, resulting in a loss of debug info.; // Example:; // Before the Pre Register Allocation Load Store Pass; // inst_a; // %2 = ld ...; // inst_b; // DBG_VALUE %2, ""x"", ...; // %3 = ld ...; // After the Pass:; // inst_a; // inst_b; // DBG_VALUE %2, ""x"", ...; // %2 = ld ...; // %3 = ld ...; // The code below addresses this by moving the DBG_VALUE to the position; // immediately after the load.; // Example:; // After the code below:; // inst_a; // inst_b; // %2 = ld ...; // DBG_VALUE %2, ""x"", ...; // %3 = ld ...; // The algorithm works in two phases: First RescheduleOps() populates the; // RegisterMap with registers that were moved as keys, there is no value; // inserted. In the next phase, every MachineInstr in a basic block is; // iterated over. If it is a valid DBG_VALUE or DBG_VALUE_LIST and it uses one; // or more registers in the RegisterMap, the RegisterMap and InstrMap are; // populated with the MachineInstr. If the DBG_VALUE or DBG_VALUE_LIST; // describes debug information for a variable that already exists in the; // DbgValueSinkCandidates, the MachineInstr in the DbgValueSinkCandidates must; // be set to undef. If the current MachineInstr is a load that was moved,; // undef the corresponding DBG_VALUE or DBG_VALUE_LIST and clone it to below; // the load.; // To illustrate the above algorithm visually let's take this example.; // Before the Pre Register Allocation Load Store Pass:; // %2 = ld ...; // DBG_VALUE %2, A, .... # X; // DBG_VALUE 0, A, ... # Y; // %3 = ld ...; // DBG_VALUE %3, A, ..., # Z; // %4 = ld ...; // After Pre Register Allocation Load Store Pass:; // DBG_VALUE %2, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // The algorithm below does the following:; // In the beginning, the RegisterMap will have been ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:558,Performance,load,load,558,"// Reschedule DBG_VALUEs to match any loads that were moved. When a load is; // sunk beyond a DBG_VALUE that is referring to it, the DBG_VALUE becomes a; // use-before-def, resulting in a loss of debug info.; // Example:; // Before the Pre Register Allocation Load Store Pass; // inst_a; // %2 = ld ...; // inst_b; // DBG_VALUE %2, ""x"", ...; // %3 = ld ...; // After the Pass:; // inst_a; // inst_b; // DBG_VALUE %2, ""x"", ...; // %2 = ld ...; // %3 = ld ...; // The code below addresses this by moving the DBG_VALUE to the position; // immediately after the load.; // Example:; // After the code below:; // inst_a; // inst_b; // %2 = ld ...; // DBG_VALUE %2, ""x"", ...; // %3 = ld ...; // The algorithm works in two phases: First RescheduleOps() populates the; // RegisterMap with registers that were moved as keys, there is no value; // inserted. In the next phase, every MachineInstr in a basic block is; // iterated over. If it is a valid DBG_VALUE or DBG_VALUE_LIST and it uses one; // or more registers in the RegisterMap, the RegisterMap and InstrMap are; // populated with the MachineInstr. If the DBG_VALUE or DBG_VALUE_LIST; // describes debug information for a variable that already exists in the; // DbgValueSinkCandidates, the MachineInstr in the DbgValueSinkCandidates must; // be set to undef. If the current MachineInstr is a load that was moved,; // undef the corresponding DBG_VALUE or DBG_VALUE_LIST and clone it to below; // the load.; // To illustrate the above algorithm visually let's take this example.; // Before the Pre Register Allocation Load Store Pass:; // %2 = ld ...; // DBG_VALUE %2, A, .... # X; // DBG_VALUE 0, A, ... # Y; // %3 = ld ...; // DBG_VALUE %3, A, ..., # Z; // %4 = ld ...; // After Pre Register Allocation Load Store Pass:; // DBG_VALUE %2, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // The algorithm below does the following:; // In the beginning, the RegisterMap will have been ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:1340,Performance,load,load,1340,"/ inst_a; // inst_b; // DBG_VALUE %2, ""x"", ...; // %2 = ld ...; // %3 = ld ...; // The code below addresses this by moving the DBG_VALUE to the position; // immediately after the load.; // Example:; // After the code below:; // inst_a; // inst_b; // %2 = ld ...; // DBG_VALUE %2, ""x"", ...; // %3 = ld ...; // The algorithm works in two phases: First RescheduleOps() populates the; // RegisterMap with registers that were moved as keys, there is no value; // inserted. In the next phase, every MachineInstr in a basic block is; // iterated over. If it is a valid DBG_VALUE or DBG_VALUE_LIST and it uses one; // or more registers in the RegisterMap, the RegisterMap and InstrMap are; // populated with the MachineInstr. If the DBG_VALUE or DBG_VALUE_LIST; // describes debug information for a variable that already exists in the; // DbgValueSinkCandidates, the MachineInstr in the DbgValueSinkCandidates must; // be set to undef. If the current MachineInstr is a load that was moved,; // undef the corresponding DBG_VALUE or DBG_VALUE_LIST and clone it to below; // the load.; // To illustrate the above algorithm visually let's take this example.; // Before the Pre Register Allocation Load Store Pass:; // %2 = ld ...; // DBG_VALUE %2, A, .... # X; // DBG_VALUE 0, A, ... # Y; // %3 = ld ...; // DBG_VALUE %3, A, ..., # Z; // %4 = ld ...; // After Pre Register Allocation Load Store Pass:; // DBG_VALUE %2, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // The algorithm below does the following:; // In the beginning, the RegisterMap will have been populated with the virtual; // registers %2, and %3, the DbgValueSinkCandidates and the InstrMap will be; // empty. DbgValueSinkCandidates = {}, RegisterMap = {2 -> {}, 3 -> {}},; // InstrMap {}; // -> DBG_VALUE %2, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // After the first DBG_VALUE (denoted with ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:1447,Performance,load,load,1447,"/ inst_a; // inst_b; // DBG_VALUE %2, ""x"", ...; // %2 = ld ...; // %3 = ld ...; // The code below addresses this by moving the DBG_VALUE to the position; // immediately after the load.; // Example:; // After the code below:; // inst_a; // inst_b; // %2 = ld ...; // DBG_VALUE %2, ""x"", ...; // %3 = ld ...; // The algorithm works in two phases: First RescheduleOps() populates the; // RegisterMap with registers that were moved as keys, there is no value; // inserted. In the next phase, every MachineInstr in a basic block is; // iterated over. If it is a valid DBG_VALUE or DBG_VALUE_LIST and it uses one; // or more registers in the RegisterMap, the RegisterMap and InstrMap are; // populated with the MachineInstr. If the DBG_VALUE or DBG_VALUE_LIST; // describes debug information for a variable that already exists in the; // DbgValueSinkCandidates, the MachineInstr in the DbgValueSinkCandidates must; // be set to undef. If the current MachineInstr is a load that was moved,; // undef the corresponding DBG_VALUE or DBG_VALUE_LIST and clone it to below; // the load.; // To illustrate the above algorithm visually let's take this example.; // Before the Pre Register Allocation Load Store Pass:; // %2 = ld ...; // DBG_VALUE %2, A, .... # X; // DBG_VALUE 0, A, ... # Y; // %3 = ld ...; // DBG_VALUE %3, A, ..., # Z; // %4 = ld ...; // After Pre Register Allocation Load Store Pass:; // DBG_VALUE %2, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // The algorithm below does the following:; // In the beginning, the RegisterMap will have been populated with the virtual; // registers %2, and %3, the DbgValueSinkCandidates and the InstrMap will be; // empty. DbgValueSinkCandidates = {}, RegisterMap = {2 -> {}, 3 -> {}},; // InstrMap {}; // -> DBG_VALUE %2, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // After the first DBG_VALUE (denoted with ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:1564,Performance,Load,Load,1564,"oad.; // Example:; // After the code below:; // inst_a; // inst_b; // %2 = ld ...; // DBG_VALUE %2, ""x"", ...; // %3 = ld ...; // The algorithm works in two phases: First RescheduleOps() populates the; // RegisterMap with registers that were moved as keys, there is no value; // inserted. In the next phase, every MachineInstr in a basic block is; // iterated over. If it is a valid DBG_VALUE or DBG_VALUE_LIST and it uses one; // or more registers in the RegisterMap, the RegisterMap and InstrMap are; // populated with the MachineInstr. If the DBG_VALUE or DBG_VALUE_LIST; // describes debug information for a variable that already exists in the; // DbgValueSinkCandidates, the MachineInstr in the DbgValueSinkCandidates must; // be set to undef. If the current MachineInstr is a load that was moved,; // undef the corresponding DBG_VALUE or DBG_VALUE_LIST and clone it to below; // the load.; // To illustrate the above algorithm visually let's take this example.; // Before the Pre Register Allocation Load Store Pass:; // %2 = ld ...; // DBG_VALUE %2, A, .... # X; // DBG_VALUE 0, A, ... # Y; // %3 = ld ...; // DBG_VALUE %3, A, ..., # Z; // %4 = ld ...; // After Pre Register Allocation Load Store Pass:; // DBG_VALUE %2, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // The algorithm below does the following:; // In the beginning, the RegisterMap will have been populated with the virtual; // registers %2, and %3, the DbgValueSinkCandidates and the InstrMap will be; // empty. DbgValueSinkCandidates = {}, RegisterMap = {2 -> {}, 3 -> {}},; // InstrMap {}; // -> DBG_VALUE %2, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // After the first DBG_VALUE (denoted with an X) is processed, the; // DbgValueSinkCandidates and InstrMap will be populated and the RegisterMap; // entry for %2 will be populated as well. DbgValueSinkCandidates = {A -> X},",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:1751,Performance,Load,Load,1751,"s the; // RegisterMap with registers that were moved as keys, there is no value; // inserted. In the next phase, every MachineInstr in a basic block is; // iterated over. If it is a valid DBG_VALUE or DBG_VALUE_LIST and it uses one; // or more registers in the RegisterMap, the RegisterMap and InstrMap are; // populated with the MachineInstr. If the DBG_VALUE or DBG_VALUE_LIST; // describes debug information for a variable that already exists in the; // DbgValueSinkCandidates, the MachineInstr in the DbgValueSinkCandidates must; // be set to undef. If the current MachineInstr is a load that was moved,; // undef the corresponding DBG_VALUE or DBG_VALUE_LIST and clone it to below; // the load.; // To illustrate the above algorithm visually let's take this example.; // Before the Pre Register Allocation Load Store Pass:; // %2 = ld ...; // DBG_VALUE %2, A, .... # X; // DBG_VALUE 0, A, ... # Y; // %3 = ld ...; // DBG_VALUE %3, A, ..., # Z; // %4 = ld ...; // After Pre Register Allocation Load Store Pass:; // DBG_VALUE %2, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // The algorithm below does the following:; // In the beginning, the RegisterMap will have been populated with the virtual; // registers %2, and %3, the DbgValueSinkCandidates and the InstrMap will be; // empty. DbgValueSinkCandidates = {}, RegisterMap = {2 -> {}, 3 -> {}},; // InstrMap {}; // -> DBG_VALUE %2, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // After the first DBG_VALUE (denoted with an X) is processed, the; // DbgValueSinkCandidates and InstrMap will be populated and the RegisterMap; // entry for %2 will be populated as well. DbgValueSinkCandidates = {A -> X},; // RegisterMap = {2 -> {X}, 3 -> {}}, InstrMap {X -> 2}; // DBG_VALUE %2, A, .... # X; // -> DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // %3 = ld ...; // %4 = ld .",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:4343,Performance,load,load,4343,"ndidates is updated to; // hold Z fr A, the RegisterMap is updated to hold Z for %3, and the InstrMap; // is updated to have Z mapped to %3. This is again because Z describes the; // debug variable A, Y is not updated to have $noreg as first operand because; // its first operand is an immediate, not a register.; // DbgValueSinkCandidates = {A -> {Z}}, RegisterMap = {2 -> {}, 3 -> {Z}},; // InstrMap = {X -> 2, Z -> 3}; // DBG_VALUE $noreg, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // -> %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // Nothing happens here since the RegisterMap for %2 contains no value.; // DbgValueSinkCandidates = {A -> {Z}}, RegisterMap = {2 -> {}, 3 -> {Z}},; // InstrMap = {X -> 2, Z -> 3}; // DBG_VALUE $noreg, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // -> %3 = ld ...; // %4 = ld ...; // Since the RegisterMap contains Z as a value for %3, the MachineInstr; // pointer Z is copied to come after the load for %3 and the old Z's first; // operand is changed to $noreg the Basic Block iterator is moved to after the; // DBG_VALUE Z's new position.; // DbgValueSinkCandidates = {A -> {Z}}, RegisterMap = {2 -> {}, 3 -> {Z}},; // InstrMap = {X -> 2, Z -> 3}; // DBG_VALUE $noreg, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE $noreg, A, ..., # Old Z; // %2 = ld ...; // %3 = ld ...; // DBG_VALUE %3, A, ..., # Z; // -> %4 = ld ...; // Nothing happens for %4 and the algorithm exits having processed the entire; // Basic Block.; // DbgValueSinkCandidates = {A -> {Z}}, RegisterMap = {2 -> {}, 3 -> {Z}},; // InstrMap = {X -> 2, Z -> 3}; // DBG_VALUE $noreg, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE $noreg, A, ..., # Old Z; // %2 = ld ...; // %3 = ld ...; // DBG_VALUE %3, A, ..., # Z; // %4 = ld ...; // This map is used to track the relationship between; // a Debug Variable and the DBG_VALUE MachineInstr pointer that describes the; // debug information for that Debug Variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:130,Performance,load,load,130,"// If the first operand is a register and it exists in the RegisterMap, we; // know this is a DBG_VALUE that uses the result of a load that was moved,; // and is therefore a candidate to also be moved, add it to the; // RegisterMap and InstrMap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:47,Modifiability,variab,variable,47,"// If the current DBG_VALUE describes the same variable as one of the; // in-flight DBG_VALUEs, remove the candidate from the list and set it to; // undef. Moving one DBG_VALUE past another would result in the variable's; // value going back in time when stepping through the block in the; // debugger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:210,Modifiability,variab,variable,210,"// If the current DBG_VALUE describes the same variable as one of the; // in-flight DBG_VALUEs, remove the candidate from the list and set it to; // undef. Moving one DBG_VALUE past another would result in the variable's; // value going back in time when stepping through the block in the; // debugger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:29,Performance,load,load,29,"// If the first operand of a load matches with a DBG_VALUE in RegisterMap,; // then move that DBG_VALUE to below the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:117,Performance,load,load,117,"// If the first operand of a load matches with a DBG_VALUE in RegisterMap,; // then move that DBG_VALUE to below the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:3,Deployability,Update,Update,3,// Update RegisterMap with ClonedMI because it might have to be moved; // again.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:55,Security,access,access,55,"// Get the Base register operand index from the memory access MachineInst if we; // should attempt to distribute postinc on it. Return -1 if not of a valid; // instruction type. If it returns an index, it is assumed that instruction is a; // r+i indexing mode, and getBaseOperandIndex() + 1 is the Offset index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:18,Security,access,access,18,"// Given a memory access Opcode, check that the give Imm would be a valid Offset; // for this instruction (same as isLegalAddressImm), Or if the instruction; // could be easily converted to one where that was valid. For example converting; // t2LDRi12 to t2LDRi8 for negative offsets. Works in conjunction with; // AdjustBaseAndOffset below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:11,Performance,load,load,11,// Any MVE load/store,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:39,Performance,load,load,39,"// Given a Base Register, optimise the load/store uses to attempt to create more; // post-inc accesses and less register moves. We do this by taking zero offset; // loads/stores with an add, and convert them to a postinc load/store of the; // same type. Any subsequent accesses will be adjusted to use and account for; // the post-inc value.; // For example:; // LDR #0 LDR_POSTINC #16; // LDR #4 LDR #-12; // LDR #8 LDR #-8; // LDR #12 LDR #-4; // ADD #16; //; // At the same time if we do not find an increment but do find an existing; // pre/post inc instruction, we can still adjust the offsets of subsequent; // instructions to save the register move that would otherwise be needed for the; // in-place increment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:165,Performance,load,loads,165,"// Given a Base Register, optimise the load/store uses to attempt to create more; // post-inc accesses and less register moves. We do this by taking zero offset; // loads/stores with an add, and convert them to a postinc load/store of the; // same type. Any subsequent accesses will be adjusted to use and account for; // the post-inc value.; // For example:; // LDR #0 LDR_POSTINC #16; // LDR #4 LDR #-12; // LDR #8 LDR #-8; // LDR #12 LDR #-4; // ADD #16; //; // At the same time if we do not find an increment but do find an existing; // pre/post inc instruction, we can still adjust the offsets of subsequent; // instructions to save the register move that would otherwise be needed for the; // in-place increment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:221,Performance,load,load,221,"// Given a Base Register, optimise the load/store uses to attempt to create more; // post-inc accesses and less register moves. We do this by taking zero offset; // loads/stores with an add, and convert them to a postinc load/store of the; // same type. Any subsequent accesses will be adjusted to use and account for; // the post-inc value.; // For example:; // LDR #0 LDR_POSTINC #16; // LDR #4 LDR #-12; // LDR #8 LDR #-8; // LDR #12 LDR #-4; // ADD #16; //; // At the same time if we do not find an increment but do find an existing; // pre/post inc instruction, we can still adjust the offsets of subsequent; // instructions to save the register move that would otherwise be needed for the; // in-place increment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:94,Security,access,accesses,94,"// Given a Base Register, optimise the load/store uses to attempt to create more; // post-inc accesses and less register moves. We do this by taking zero offset; // loads/stores with an add, and convert them to a postinc load/store of the; // same type. Any subsequent accesses will be adjusted to use and account for; // the post-inc value.; // For example:; // LDR #0 LDR_POSTINC #16; // LDR #4 LDR #-12; // LDR #8 LDR #-8; // LDR #12 LDR #-4; // ADD #16; //; // At the same time if we do not find an increment but do find an existing; // pre/post inc instruction, we can still adjust the offsets of subsequent; // instructions to save the register move that would otherwise be needed for the; // in-place increment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:269,Security,access,accesses,269,"// Given a Base Register, optimise the load/store uses to attempt to create more; // post-inc accesses and less register moves. We do this by taking zero offset; // loads/stores with an add, and convert them to a postinc load/store of the; // same type. Any subsequent accesses will be adjusted to use and account for; // the post-inc value.; // For example:; // LDR #0 LDR_POSTINC #16; // LDR #4 LDR #-12; // LDR #8 LDR #-8; // LDR #12 LDR #-4; // ADD #16; //; // At the same time if we do not find an increment but do find an existing; // pre/post inc instruction, we can still adjust the offsets of subsequent; // instructions to save the register move that would otherwise be needed for the; // in-place increment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:43,Performance,load,load,43,// We are looking for:; // One zero offset load/store that can become postinc,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:56,Deployability,update,updated,56,// Other accesses after BaseAccess that will need to be updated to use the; // postinc value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:9,Security,access,accesses,9,// Other accesses after BaseAccess that will need to be updated to use the; // postinc value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:160,Deployability,update,update,160,"// If we already have a pre/post index load/store then set BaseAccess,; // IncrementOffset and NewBaseReg to the values it already produces,; // allowing us to update and subsequent uses of BaseOp reg with the; // incremented value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:39,Performance,load,load,39,"// If we already have a pre/post index load/store then set BaseAccess,; // IncrementOffset and NewBaseReg to the values it already produces,; // allowing us to update and subsequent uses of BaseOp reg with the; // incremented value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:284,Safety,detect,detect,284,"// And make sure that the negative value of increment can be added to all; // other offsets after the BaseAccess. We rely on either; // dominates(BaseAccess, OtherAccess) or dominates(OtherAccess, BaseAccess); // to keep things simple.; // This also adds a simple codesize metric, to detect if an instruction (like; // t2LDRBi12) which can often be shrunk to a thumb1 instruction (tLDRBi); // cannot because it is converted to something else (t2LDRBi8). We start this; // at -1 for the gain from removing the increment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:228,Usability,simpl,simple,228,"// And make sure that the negative value of increment can be added to all; // other offsets after the BaseAccess. We rely on either; // dominates(BaseAccess, OtherAccess) or dominates(OtherAccess, BaseAccess); // to keep things simple.; // This also adds a simple codesize metric, to detect if an instruction (like; // t2LDRBi12) which can often be shrunk to a thumb1 instruction (tLDRBi); // cannot because it is converted to something else (t2LDRBi8). We start this; // at -1 for the gain from removing the increment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:257,Usability,simpl,simple,257,"// And make sure that the negative value of increment can be added to all; // other offsets after the BaseAccess. We rely on either; // dominates(BaseAccess, OtherAccess) or dominates(OtherAccess, BaseAccess); // to keep things simple.; // This also adds a simple codesize metric, to detect if an instruction (like; // t2LDRBi12) which can often be shrunk to a thumb1 instruction (tLDRBi); // cannot because it is converted to something else (t2LDRBi8). We start this; // at -1 for the gain from removing the increment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:31,Performance,load,load,31,/// Returns an instance of the load / store optimization pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:44,Performance,optimiz,optimization,44,/// Returns an instance of the load / store optimization pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:2155,Availability,mask,mask,2155," we also look for the presence of the VCTP instruction,; /// which determines whether we can generated the tail-predicated low-overhead; /// loop form.; ///; /// Assumptions and Dependencies:; /// Low-overhead loops are constructed and executed using a setup instruction:; /// DLS, WLS, DLSTP or WLSTP and an instruction that loops back: LE or LETP.; /// WLS(TP) and LE(TP) are branching instructions with a (large) limited range; /// but fixed polarity: WLS can only branch forwards and LE can only branch; /// backwards. These restrictions mean that this pass is dependent upon block; /// layout and block sizes, which is why it's the last pass to run. The same is; /// true for ConstantIslands, but this pass does not increase the size of the; /// basic blocks, nor does it change the CFG. Instructions are mainly removed; /// during the transform and pseudo instructions are replaced by real ones. In; /// some cases, when we have to revert to a 'normal' loop, we have to introduce; /// multiple instructions for a single pseudo (see RevertWhile and; /// RevertLoopEnd). To handle this situation, t2WhileLoopStartLR and t2LoopEnd; /// are defined to be as large as this maximum sequence of replacement; /// instructions.; ///; /// A note on VPR.P0 (the lane mask):; /// VPT, VCMP, VPNOT and VCTP won't overwrite VPR.P0 when they update it in a; /// ""VPT Active"" context (which includes low-overhead loops and vpt blocks).; /// They will simply ""and"" the result of their calculation with the current; /// value of VPR.P0. You can think of it like this:; /// \verbatim; /// if VPT active: ; Between a DLSTP/LETP, or for predicated instrs; /// VPR.P0 &= Value; /// else; /// VPR.P0 = Value; /// \endverbatim; /// When we're inside the low-overhead loop (between DLSTP and LETP), we always; /// fall in the ""VPT active"" case, so we can consider that all VPR writes by; /// one of those instruction is actually a ""and"".; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:2226,Deployability,update,update,2226," we also look for the presence of the VCTP instruction,; /// which determines whether we can generated the tail-predicated low-overhead; /// loop form.; ///; /// Assumptions and Dependencies:; /// Low-overhead loops are constructed and executed using a setup instruction:; /// DLS, WLS, DLSTP or WLSTP and an instruction that loops back: LE or LETP.; /// WLS(TP) and LE(TP) are branching instructions with a (large) limited range; /// but fixed polarity: WLS can only branch forwards and LE can only branch; /// backwards. These restrictions mean that this pass is dependent upon block; /// layout and block sizes, which is why it's the last pass to run. The same is; /// true for ConstantIslands, but this pass does not increase the size of the; /// basic blocks, nor does it change the CFG. Instructions are mainly removed; /// during the transform and pseudo instructions are replaced by real ones. In; /// some cases, when we have to revert to a 'normal' loop, we have to introduce; /// multiple instructions for a single pseudo (see RevertWhile and; /// RevertLoopEnd). To handle this situation, t2WhileLoopStartLR and t2LoopEnd; /// are defined to be as large as this maximum sequence of replacement; /// instructions.; ///; /// A note on VPR.P0 (the lane mask):; /// VPT, VCMP, VPNOT and VCTP won't overwrite VPR.P0 when they update it in a; /// ""VPT Active"" context (which includes low-overhead loops and vpt blocks).; /// They will simply ""and"" the result of their calculation with the current; /// value of VPR.P0. You can think of it like this:; /// \verbatim; /// if VPT active: ; Between a DLSTP/LETP, or for predicated instrs; /// VPR.P0 &= Value; /// else; /// VPR.P0 = Value; /// \endverbatim; /// When we're inside the low-overhead loop (between DLSTP and LETP), we always; /// fall in the ""VPT active"" case, so we can consider that all VPR writes by; /// one of those instruction is actually a ""and"".; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:1071,Integrability,Depend,Dependencies,1071," with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// Finalize v8.1-m low-overhead loops by converting the associated pseudo; /// instructions into machine operations.; /// The expectation is that the loop contains three pseudo instructions:; /// - t2*LoopStart - placed in the preheader or pre-preheader. The do-loop; /// form should be in the preheader, whereas the while form should be in the; /// preheaders only predecessor.; /// - t2LoopDec - placed within in the loop body.; /// - t2LoopEnd - the loop latch terminator.; ///; /// In addition to this, we also look for the presence of the VCTP instruction,; /// which determines whether we can generated the tail-predicated low-overhead; /// loop form.; ///; /// Assumptions and Dependencies:; /// Low-overhead loops are constructed and executed using a setup instruction:; /// DLS, WLS, DLSTP or WLSTP and an instruction that loops back: LE or LETP.; /// WLS(TP) and LE(TP) are branching instructions with a (large) limited range; /// but fixed polarity: WLS can only branch forwards and LE can only branch; /// backwards. These restrictions mean that this pass is dependent upon block; /// layout and block sizes, which is why it's the last pass to run. The same is; /// true for ConstantIslands, but this pass does not increase the size of the; /// basic blocks, nor does it change the CFG. Instructions are mainly removed; /// during the transform and pseudo instructions are replaced by real ones. In; /// some cases, when we have to revert to a 'normal' loop, we have to introduce; /// multiple instructions for a single pseudo (see RevertWhile and; /// RevertLoopEnd). To handle this situation, t2WhileLoopStartLR and t2LoopEnd; /// are defined to be as large as this maximum sequence of replacement; /// instructions.; ///; /// A note on VPR.P",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:1458,Integrability,depend,dependent,1458,"to machine operations.; /// The expectation is that the loop contains three pseudo instructions:; /// - t2*LoopStart - placed in the preheader or pre-preheader. The do-loop; /// form should be in the preheader, whereas the while form should be in the; /// preheaders only predecessor.; /// - t2LoopDec - placed within in the loop body.; /// - t2LoopEnd - the loop latch terminator.; ///; /// In addition to this, we also look for the presence of the VCTP instruction,; /// which determines whether we can generated the tail-predicated low-overhead; /// loop form.; ///; /// Assumptions and Dependencies:; /// Low-overhead loops are constructed and executed using a setup instruction:; /// DLS, WLS, DLSTP or WLSTP and an instruction that loops back: LE or LETP.; /// WLS(TP) and LE(TP) are branching instructions with a (large) limited range; /// but fixed polarity: WLS can only branch forwards and LE can only branch; /// backwards. These restrictions mean that this pass is dependent upon block; /// layout and block sizes, which is why it's the last pass to run. The same is; /// true for ConstantIslands, but this pass does not increase the size of the; /// basic blocks, nor does it change the CFG. Instructions are mainly removed; /// during the transform and pseudo instructions are replaced by real ones. In; /// some cases, when we have to revert to a 'normal' loop, we have to introduce; /// multiple instructions for a single pseudo (see RevertWhile and; /// RevertLoopEnd). To handle this situation, t2WhileLoopStartLR and t2LoopEnd; /// are defined to be as large as this maximum sequence of replacement; /// instructions.; ///; /// A note on VPR.P0 (the lane mask):; /// VPT, VCMP, VPNOT and VCTP won't overwrite VPR.P0 when they update it in a; /// ""VPT Active"" context (which includes low-overhead loops and vpt blocks).; /// They will simply ""and"" the result of their calculation with the current; /// value of VPR.P0. You can think of it like this:; /// \verbatim; /// if VPT activ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:2334,Usability,simpl,simply,2334," we also look for the presence of the VCTP instruction,; /// which determines whether we can generated the tail-predicated low-overhead; /// loop form.; ///; /// Assumptions and Dependencies:; /// Low-overhead loops are constructed and executed using a setup instruction:; /// DLS, WLS, DLSTP or WLSTP and an instruction that loops back: LE or LETP.; /// WLS(TP) and LE(TP) are branching instructions with a (large) limited range; /// but fixed polarity: WLS can only branch forwards and LE can only branch; /// backwards. These restrictions mean that this pass is dependent upon block; /// layout and block sizes, which is why it's the last pass to run. The same is; /// true for ConstantIslands, but this pass does not increase the size of the; /// basic blocks, nor does it change the CFG. Instructions are mainly removed; /// during the transform and pseudo instructions are replaced by real ones. In; /// some cases, when we have to revert to a 'normal' loop, we have to introduce; /// multiple instructions for a single pseudo (see RevertWhile and; /// RevertLoopEnd). To handle this situation, t2WhileLoopStartLR and t2LoopEnd; /// are defined to be as large as this maximum sequence of replacement; /// instructions.; ///; /// A note on VPR.P0 (the lane mask):; /// VPT, VCMP, VPNOT and VCTP won't overwrite VPR.P0 when they update it in a; /// ""VPT Active"" context (which includes low-overhead loops and vpt blocks).; /// They will simply ""and"" the result of their calculation with the current; /// value of VPR.P0. You can think of it like this:; /// \verbatim; /// if VPT active: ; Between a DLSTP/LETP, or for predicated instrs; /// VPR.P0 &= Value; /// else; /// VPR.P0 = Value; /// \endverbatim; /// When we're inside the low-overhead loop (between DLSTP and LETP), we always; /// fall in the ""VPT active"" case, so we can consider that all VPR writes by; /// one of those instruction is actually a ""and"".; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:37,Usability,simpl,simple,37,"// For now, let's keep things really simple and only support a single; // block for tail predication.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:73,Performance,perform,perform,73,// Check that the predication in the loop will be equivalent once we; // perform the conversion. Also ensure that we can provide the number; // of elements to the loop start instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:25,Availability,avail,available,25,// Check that any values available outside of the loop will be the same; // after tail predication conversion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:144,Availability,avail,available,144,"// If the register is defined within loop, then we can't perform TP.; // TODO: Check whether this is just a mov of a register that would be; // available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:57,Performance,perform,perform,57,"// If the register is defined within loop, then we can't perform TP.; // TODO: Check whether this is just a mov of a register that would be; // available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:556,Availability,mask,mask,556,"// Could inserting the [W|D]LSTP cause some unintended affects? In a perfect; // world the [w|d]lstp instruction would be last instruction in the preheader; // and so it would only affect instructions within the loop body. But due to; // scheduling, and/or the logic in this pass (above), the insertion point can; // be moved earlier. So if the Loop Start isn't the last instruction in the; // preheader, and if the initial element count is smaller than the vector; // width, the Loop Start instruction will immediately generate one or more; // false lane mask which can, incorrectly, affect the proceeding MVE; // instructions in the preheader.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:238,Energy Efficiency,schedul,scheduling,238,"// Could inserting the [W|D]LSTP cause some unintended affects? In a perfect; // world the [w|d]lstp instruction would be last instruction in the preheader; // and so it would only affect instructions within the loop body. But due to; // scheduling, and/or the logic in this pass (above), the insertion point can; // be moved earlier. So if the Loop Start isn't the last instruction in the; // preheader, and if the initial element count is smaller than the vector; // width, the Loop Start instruction will immediately generate one or more; // false lane mask which can, incorrectly, affect the proceeding MVE; // instructions in the preheader.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:261,Testability,log,logic,261,"// Could inserting the [W|D]LSTP cause some unintended affects? In a perfect; // world the [w|d]lstp instruction would be last instruction in the preheader; // and so it would only affect instructions within the loop body. But due to; // scheduling, and/or the logic in this pass (above), the insertion point can; // be moved earlier. So if the Loop Start isn't the last instruction in the; // preheader, and if the initial element count is smaller than the vector; // width, the Loop Start instruction will immediately generate one or more; // false lane mask which can, incorrectly, affect the proceeding MVE; // instructions in the preheader.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:144,Availability,mask,mask,144,"// For any DoubleWidthResultInstrs we found whilst scanning instructions, they; // need to compute an output size that is smaller than the VCTP mask operates; // on. The VecSize of the DoubleWidthResult is the larger vector size - the; // size it extends into, so any VCTP VecSize <= is valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:247,Modifiability,extend,extends,247,"// For any DoubleWidthResultInstrs we found whilst scanning instructions, they; // need to compute an output size that is smaller than the VCTP mask operates; // on. The VecSize of the DoubleWidthResult is the larger vector size - the; // size it extends into, so any VCTP VecSize <= is valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:163,Availability,mask,masked,163,"// Can this instruction generate a non-zero result when given only zeroed; // operands? This allows us to know that, given operands with false bytes; // zeroed by masked loads, that the result will also contain zeros in those; // bytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:170,Performance,load,loads,170,"// Can this instruction generate a non-zero result when given only zeroed; // operands? This allows us to know that, given operands with false bytes; // zeroed by masked loads, that the result will also contain zeros in those; // bytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:133,Performance,perform,perform,133,// FIXME: VNEG FP and -0? I think we'll need to handle this once we allow; // fp16 -> fp32 vector conversions.; // Instructions that perform a NOT will generate 1s from 0s.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:279,Deployability,update,updated,279,"// Look at its register uses to see if it only can only receive zeros; // into its false lanes which would then produce zeros. Also check that; // the output register is also defined by an FalseLanesZero instruction; // so that if tail-predication happens, the lanes that aren't updated will; // still be zeros.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:14,Performance,load,loads,14,// Predicated loads will write zeros to the falsely predicated bytes of the; // destination register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:680,Availability,mask,masked,680,"// We want to find out if the tail-predicated version of this loop will; // produce the same values as the loop in its original form. For this to; // be true, the newly inserted implicit predication must not change the; // the (observable) results.; // We're doing this because many instructions in the loop will not be; // predicated and so the conversion from VPT predication to tail-predication; // can result in different values being produced; due to the tail-predication; // preventing many instructions from updating their falsely predicated; // lanes. This analysis assumes that all the instructions perform lane-wise; // operations and don't perform any exchanges.; // A masked load, whether through VPT or tail predication, will write zeros; // to any of the falsely predicated bytes. So, from the loads, we know that; // the false lanes are zeroed and here we're trying to track that those false; // lanes remain zero, or where they change, the differences are masked away; // by their user(s).; // All MVE stores have to be predicated, so we know that any predicate load; // operands, or stored results are equivalent already. Other explicitly; // predicated instructions will perform the same operation in the original; // loop and the tail-predicated form too. Because of this, we can insert; // loads, stores and other predicated instructions into our Predicated; // set and build from there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:972,Availability,mask,masked,972,"// We want to find out if the tail-predicated version of this loop will; // produce the same values as the loop in its original form. For this to; // be true, the newly inserted implicit predication must not change the; // the (observable) results.; // We're doing this because many instructions in the loop will not be; // predicated and so the conversion from VPT predication to tail-predication; // can result in different values being produced; due to the tail-predication; // preventing many instructions from updating their falsely predicated; // lanes. This analysis assumes that all the instructions perform lane-wise; // operations and don't perform any exchanges.; // A masked load, whether through VPT or tail predication, will write zeros; // to any of the falsely predicated bytes. So, from the loads, we know that; // the false lanes are zeroed and here we're trying to track that those false; // lanes remain zero, or where they change, the differences are masked away; // by their user(s).; // All MVE stores have to be predicated, so we know that any predicate load; // operands, or stored results are equivalent already. Other explicitly; // predicated instructions will perform the same operation in the original; // loop and the tail-predicated form too. Because of this, we can insert; // loads, stores and other predicated instructions into our Predicated; // set and build from there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:608,Performance,perform,perform,608,"// We want to find out if the tail-predicated version of this loop will; // produce the same values as the loop in its original form. For this to; // be true, the newly inserted implicit predication must not change the; // the (observable) results.; // We're doing this because many instructions in the loop will not be; // predicated and so the conversion from VPT predication to tail-predication; // can result in different values being produced; due to the tail-predication; // preventing many instructions from updating their falsely predicated; // lanes. This analysis assumes that all the instructions perform lane-wise; // operations and don't perform any exchanges.; // A masked load, whether through VPT or tail predication, will write zeros; // to any of the falsely predicated bytes. So, from the loads, we know that; // the false lanes are zeroed and here we're trying to track that those false; // lanes remain zero, or where they change, the differences are masked away; // by their user(s).; // All MVE stores have to be predicated, so we know that any predicate load; // operands, or stored results are equivalent already. Other explicitly; // predicated instructions will perform the same operation in the original; // loop and the tail-predicated form too. Because of this, we can insert; // loads, stores and other predicated instructions into our Predicated; // set and build from there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:651,Performance,perform,perform,651,"// We want to find out if the tail-predicated version of this loop will; // produce the same values as the loop in its original form. For this to; // be true, the newly inserted implicit predication must not change the; // the (observable) results.; // We're doing this because many instructions in the loop will not be; // predicated and so the conversion from VPT predication to tail-predication; // can result in different values being produced; due to the tail-predication; // preventing many instructions from updating their falsely predicated; // lanes. This analysis assumes that all the instructions perform lane-wise; // operations and don't perform any exchanges.; // A masked load, whether through VPT or tail predication, will write zeros; // to any of the falsely predicated bytes. So, from the loads, we know that; // the false lanes are zeroed and here we're trying to track that those false; // lanes remain zero, or where they change, the differences are masked away; // by their user(s).; // All MVE stores have to be predicated, so we know that any predicate load; // operands, or stored results are equivalent already. Other explicitly; // predicated instructions will perform the same operation in the original; // loop and the tail-predicated form too. Because of this, we can insert; // loads, stores and other predicated instructions into our Predicated; // set and build from there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:687,Performance,load,load,687,"// We want to find out if the tail-predicated version of this loop will; // produce the same values as the loop in its original form. For this to; // be true, the newly inserted implicit predication must not change the; // the (observable) results.; // We're doing this because many instructions in the loop will not be; // predicated and so the conversion from VPT predication to tail-predication; // can result in different values being produced; due to the tail-predication; // preventing many instructions from updating their falsely predicated; // lanes. This analysis assumes that all the instructions perform lane-wise; // operations and don't perform any exchanges.; // A masked load, whether through VPT or tail predication, will write zeros; // to any of the falsely predicated bytes. So, from the loads, we know that; // the false lanes are zeroed and here we're trying to track that those false; // lanes remain zero, or where they change, the differences are masked away; // by their user(s).; // All MVE stores have to be predicated, so we know that any predicate load; // operands, or stored results are equivalent already. Other explicitly; // predicated instructions will perform the same operation in the original; // loop and the tail-predicated form too. Because of this, we can insert; // loads, stores and other predicated instructions into our Predicated; // set and build from there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:808,Performance,load,loads,808,"// We want to find out if the tail-predicated version of this loop will; // produce the same values as the loop in its original form. For this to; // be true, the newly inserted implicit predication must not change the; // the (observable) results.; // We're doing this because many instructions in the loop will not be; // predicated and so the conversion from VPT predication to tail-predication; // can result in different values being produced; due to the tail-predication; // preventing many instructions from updating their falsely predicated; // lanes. This analysis assumes that all the instructions perform lane-wise; // operations and don't perform any exchanges.; // A masked load, whether through VPT or tail predication, will write zeros; // to any of the falsely predicated bytes. So, from the loads, we know that; // the false lanes are zeroed and here we're trying to track that those false; // lanes remain zero, or where they change, the differences are masked away; // by their user(s).; // All MVE stores have to be predicated, so we know that any predicate load; // operands, or stored results are equivalent already. Other explicitly; // predicated instructions will perform the same operation in the original; // loop and the tail-predicated form too. Because of this, we can insert; // loads, stores and other predicated instructions into our Predicated; // set and build from there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:1078,Performance,load,load,1078,"// We want to find out if the tail-predicated version of this loop will; // produce the same values as the loop in its original form. For this to; // be true, the newly inserted implicit predication must not change the; // the (observable) results.; // We're doing this because many instructions in the loop will not be; // predicated and so the conversion from VPT predication to tail-predication; // can result in different values being produced; due to the tail-predication; // preventing many instructions from updating their falsely predicated; // lanes. This analysis assumes that all the instructions perform lane-wise; // operations and don't perform any exchanges.; // A masked load, whether through VPT or tail predication, will write zeros; // to any of the falsely predicated bytes. So, from the loads, we know that; // the false lanes are zeroed and here we're trying to track that those false; // lanes remain zero, or where they change, the differences are masked away; // by their user(s).; // All MVE stores have to be predicated, so we know that any predicate load; // operands, or stored results are equivalent already. Other explicitly; // predicated instructions will perform the same operation in the original; // loop and the tail-predicated form too. Because of this, we can insert; // loads, stores and other predicated instructions into our Predicated; // set and build from there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:1189,Performance,perform,perform,1189,"// We want to find out if the tail-predicated version of this loop will; // produce the same values as the loop in its original form. For this to; // be true, the newly inserted implicit predication must not change the; // the (observable) results.; // We're doing this because many instructions in the loop will not be; // predicated and so the conversion from VPT predication to tail-predication; // can result in different values being produced; due to the tail-predication; // preventing many instructions from updating their falsely predicated; // lanes. This analysis assumes that all the instructions perform lane-wise; // operations and don't perform any exchanges.; // A masked load, whether through VPT or tail predication, will write zeros; // to any of the falsely predicated bytes. So, from the loads, we know that; // the false lanes are zeroed and here we're trying to track that those false; // lanes remain zero, or where they change, the differences are masked away; // by their user(s).; // All MVE stores have to be predicated, so we know that any predicate load; // operands, or stored results are equivalent already. Other explicitly; // predicated instructions will perform the same operation in the original; // loop and the tail-predicated form too. Because of this, we can insert; // loads, stores and other predicated instructions into our Predicated; // set and build from there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:1310,Performance,load,loads,1310,"// We want to find out if the tail-predicated version of this loop will; // produce the same values as the loop in its original form. For this to; // be true, the newly inserted implicit predication must not change the; // the (observable) results.; // We're doing this because many instructions in the loop will not be; // predicated and so the conversion from VPT predication to tail-predication; // can result in different values being produced; due to the tail-predication; // preventing many instructions from updating their falsely predicated; // lanes. This analysis assumes that all the instructions perform lane-wise; // operations and don't perform any exchanges.; // A masked load, whether through VPT or tail predication, will write zeros; // to any of the falsely predicated bytes. So, from the loads, we know that; // the false lanes are zeroed and here we're trying to track that those false; // lanes remain zero, or where they change, the differences are masked away; // by their user(s).; // All MVE stores have to be predicated, so we know that any predicate load; // operands, or stored results are equivalent already. Other explicitly; // predicated instructions will perform the same operation in the original; // loop and the tail-predicated form too. Because of this, we can insert; // loads, stores and other predicated instructions into our Predicated; // set and build from there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:272,Availability,mask,masked,272,"// Visit the unknowns in reverse so that we can start at the values being; // stored and then we can work towards the leaves, hopefully adding more; // instructions to Predicated. Successfully terminating the loop means that; // all the unknown values have to found to be masked by predicated user(s).; // For any unpredicated values, we store them in NonPredicated so that we; // can later check whether these form a reduction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:37,Availability,mask,masked,37,// Any unknown false lanes have been masked away by the user(s).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:99,Performance,perform,perform,99,"// We've already validated that any VPT predication within the loop will be; // equivalent when we perform the predication transformation; so we know that; // any VPT predicated instruction is predicated upon VCTP. Any live-out; // instruction needs to be predicated, so check this here. The instructions; // in NonPredicated have been found to be a reduction that we can ensure its; // legality. Any MQPRCopy found will need to validate its input as if it was; // live out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:17,Security,validat,validated,17,"// We've already validated that any VPT predication within the loop will be; // equivalent when we perform the predication transformation; so we know that; // any VPT predicated instruction is predicated upon VCTP. Any live-out; // instruction needs to be predicated, so check this here. The instructions; // in NonPredicated have been found to be a reduction that we can ensure its; // legality. Any MQPRCopy found will need to validate its input as if it was; // live out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:429,Security,validat,validate,429,"// We've already validated that any VPT predication within the loop will be; // equivalent when we perform the predication transformation; so we know that; // any VPT predicated instruction is predicated upon VCTP. Any live-out; // instruction needs to be predicated, so check this here. The instructions; // in NonPredicated have been found to be a reduction that we can ensure its; // legality. Any MQPRCopy found will need to validate its input as if it was; // live out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:95,Safety,safe,safe,95,"// TODO Maybe there's cases where the target doesn't have to be the header,; // but for now be safe and revert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:40,Security,access,accesses,40,// Search all blocks after the loop for accesses to the same stack slot.; // ReachingDefAnalysis doesn't work for sp as it relies on registers being; // live-out (which sp never is) to know what blocks to look in,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:58,Performance,load,loads,58,// If this block has a store to the stack slot before any loads then we; // can ignore the block,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:24,Performance,load,load,24,// If the store and the load are using the same stack slot then the; // store isn't valid for tail predication,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:179,Testability,assert,assert,179,"// TODO: Allow VPSEL and VPNOT, we currently cannot because:; // 1) It will use the VPR as a predicate operand, but doesn't have to be; // instead a VPT block, which means we can assert while building up; // the VPT block because we don't find another VPT or VPST to being a new; // one.; // 2) VPSEL still requires a VPR operand even after tail predicating,; // which means we can't remove it unless there is another; // instruction, such as vcmp, that can provide the VPR def.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:40,Deployability,update,update,40,"// If this instruction defines the VPR, update the predicate for the; // proceeding instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:3,Usability,Clear,Clear,3,"// Clear the existing predicate when we're not in VPT Active state,; // otherwise we add to it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:152,Performance,perform,performing,152,"// TODO: Though the call will require LE to execute again, does this; // mean we should revert? Always executing LE hopefully should be; // faster than performing a sub,cmp,br or even subs,br.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:3,Performance,Perform,Perform,3,"// Perform dead code elimation on the loop iteration count setup expression.; // If we are tail-predicating, the number of elements to be processed is the; // operand of the VCTP instruction in the vector body, see getCount(), which is; // register $r3 in this example:; //; // $lr = big-itercount-expression; // ..; // $lr = t2DoLoopStart renamable $lr; // vector.body:; // ..; // $vpr = MVE_VCTP32 renamable $r3; // renamable $lr = t2LoopDec killed renamable $lr, 1; // t2LoopEnd renamable $lr, %vector.body; // tB %end; //; // What we would like achieve here is to replace the do-loop start pseudo; // instruction t2DoLoopStart with:; //; // $lr = MVE_DLSTP_32 killed renamable $r3; //; // Thus, $r3 which defines the number of elements, is written to $lr,; // and then we want to delete the whole chain that used to define $lr,; // see the comment below how this chain could look like.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:30,Availability,mask,mask,30,"// Create a VPST (with a null mask for now, we'll recompute it; // later)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:86,Availability,mask,mask,86,"// The vctp will be removed, so either the entire block will be dead or; // the block mask of the vp(s)t will need to be recomputed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:58,Deployability,update,update,58,"// We've moved, removed and inserted new instructions, so update RDA.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMMachineFunctionInfo.h:3,Security,Secur,Security,3,// Security Extensions,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMMachineFunctionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMMachineFunctionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMMachineFunctionInfo.h:54,Deployability,rolling,rolling,54,/// CoalescedWeights - mapping of basic blocks to the rolling counter of; /// coalesced weights.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMMachineFunctionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMMachineFunctionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMMachineFunctionInfo.h:160,Modifiability,variab,variable,160,/// Indicate to the backend that \c GV has had its storage changed to inside; /// a constant pool. This means it no longer needs to be emitted as a; /// global variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMMachineFunctionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMMachineFunctionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMMacroFusion.cpp:435,Energy Efficiency,schedul,scheduling,435,"//===- ARMMacroFusion.cpp - ARM Macro Fusion ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file This file contains the ARM implementation of the DAG scheduling; /// mutation to pair instructions back to back.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMMacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMMacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMMacroFusion.h:431,Energy Efficiency,schedul,scheduling,431,"//===- ARMMacroFusion.h - ARM Macro Fusion ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file This file contains the ARM definition of the DAG scheduling mutation; /// to pair instructions back to back.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMMacroFusion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMMacroFusion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMMCInstLower.cpp:205,Deployability,patch,patching,205,"// We want to emit the following pattern:; //; // .Lxray_sled_N:; // ALIGN; // B #20; // ; 6 NOP instructions (24 bytes); // .tmpN; //; // We need the 24 bytes (6 instructions) because at runtime, we'd be patching; // over the full 28 bytes (7 instructions) with the following pattern:; //; // PUSH{ r0, lr }; // MOVW r0, #<lower 16 bits of function ID>; // MOVT r0, #<higher 16 bits of function ID>; // MOVW ip, #<lower 16 bits of address of __xray_FunctionEntry/Exit>; // MOVT ip, #<higher 16 bits of address of __xray_FunctionEntry/Exit>; // BLX ip; // POP{ r0, lr }; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMMCInstLower.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMMCInstLower.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMMCInstLower.cpp:262,Usability,clear,clear,262,"// Emit ""B #20"" instruction, which jumps over the next 24 bytes (because; // register pc is 8 bytes ahead of the jump instruction by the moment CPU; // is executing it).; // By analogy to ARMAsmPrinter::emitPseudoExpansionLowering() |case ARM::B|.; // It is not clear why |addReg(0)| is needed (the last operand).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMMCInstLower.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMMCInstLower.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMOptimizeBarriersPass.cpp:60,Security,access,access,60,"//===-- ARMOptimizeBarriersPass - two DMBs without a memory access in between,; //removed one -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===------------------------------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMOptimizeBarriersPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMOptimizeBarriersPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMOptimizeBarriersPass.cpp:39,Safety,safe,safely,39,// Returns whether the instruction can safely move past a DMB instruction; // The current implementation allows this iif MI does not have any possible; // memory access,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMOptimizeBarriersPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMOptimizeBarriersPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMOptimizeBarriersPass.cpp:162,Security,access,access,162,// Returns whether the instruction can safely move past a DMB instruction; // The current implementation allows this iif MI does not have any possible; // memory access,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMOptimizeBarriersPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMOptimizeBarriersPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp:428,Performance,perform,perform,428,"//===- ARMParallelDSP.cpp - Parallel DSP Pass -----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// Armv6 introduced instructions to perform 32-bit SIMD operations. The; /// purpose of this pass is do some IR pattern matching to create ACLE; /// DSP intrinsics, which map on these 32-bit SIMD operations.; /// This pass runs only when unaligned accesses is supported/enabled.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp:640,Security,access,accesses,640,"//===- ARMParallelDSP.cpp - Parallel DSP Pass -----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// Armv6 introduced instructions to perform 32-bit SIMD operations. The; /// purpose of this pass is do some IR pattern matching to create ACLE; /// DSP intrinsics, which map on these 32-bit SIMD operations.; /// This pass runs only when unaligned accesses is supported/enabled.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp:17,Performance,load,loads,17,// Container for loads to widen.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp:80,Performance,perform,perform,80,/// Represent a sequence of multiply-accumulate operations with the aim to; /// perform the multiplications in parallel.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp:84,Performance,perform,performs,84,"/// Try to match and generate: SMLAD, SMLADX - Signed Multiply Accumulate; /// Dual performs two signed 16x16-bit multiplications. It adds the; /// products to a 32-bit accumulate operand. Optionally, the instruction can; /// exchange the halfwords of the second operand before performing the; /// arithmetic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp:278,Performance,perform,performing,278,"/// Try to match and generate: SMLAD, SMLADX - Signed Multiply Accumulate; /// Dual performs two signed 16x16-bit multiplications. It adds the; /// products to a 32-bit accumulate operand. Optionally, the instruction can; /// exchange the halfwords of the second operand before performing the; /// arithmetic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp:19,Performance,load,load,19,// Check that this load could be paired.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp:63,Performance,load,loads,63,"/// Iterate through the block and record base, offset pairs of loads which can; /// be widened into a single load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp:109,Performance,load,load,109,"/// Iterate through the block and record base, offset pairs of loads which can; /// be widened into a single load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp:115,Modifiability,extend,extended,115,"// Collect loads and instruction that may write to memory. For now we only; // record loads which are simple, sign-extended and have a single user.; // TODO: Allow zero-extended loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp:169,Modifiability,extend,extended,169,"// Collect loads and instruction that may write to memory. For now we only; // record loads which are simple, sign-extended and have a single user.; // TODO: Allow zero-extended loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp:11,Performance,load,loads,11,"// Collect loads and instruction that may write to memory. For now we only; // record loads which are simple, sign-extended and have a single user.; // TODO: Allow zero-extended loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp:86,Performance,load,loads,86,"// Collect loads and instruction that may write to memory. For now we only; // record loads which are simple, sign-extended and have a single user.; // TODO: Allow zero-extended loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp:178,Performance,load,loads,178,"// Collect loads and instruction that may write to memory. For now we only; // record loads which are simple, sign-extended and have a single user.; // TODO: Allow zero-extended loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp:102,Usability,simpl,simple,102,"// Collect loads and instruction that may write to memory. For now we only; // record loads which are simple, sign-extended and have a single user.; // TODO: Allow zero-extended loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp:38,Performance,load,load,38,// Record any writes that may alias a load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp:53,Performance,load,loads,53,// Check whether there's not a write between the two loads which would; // prevent them from being safely merged.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp:99,Safety,safe,safely,99,// Check whether there's not a write between the two loads which would; // prevent them from being safely merged.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp:28,Performance,load,load,28,"// We can't move the second load backward, past a write, to merge; // with the first load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp:85,Performance,load,load,85,"// We can't move the second load backward, past a write, to merge; // with the first load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp:23,Performance,load,load,23,"// Record base, offset load pairs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp:211,Performance,load,load,211,"// The pass needs to identify integer add/sub reductions of 16-bit vector; // multiplications.; // To use SMLAD:; // 1) we first need to find integer add then look for this pattern:; //; // acc0 = ...; // ld0 = load i16; // sext0 = sext i16 %ld0 to i32; // ld1 = load i16; // sext1 = sext i16 %ld1 to i32; // mul0 = mul %sext0, %sext1; // ld2 = load i16; // sext2 = sext i16 %ld2 to i32; // ld3 = load i16; // sext3 = sext i16 %ld3 to i32; // mul1 = mul i32 %sext2, %sext3; // add0 = add i32 %mul0, %acc0; // acc1 = add i32 %add0, %mul1; //; // Which can be selected to:; //; // ldr r0; // ldr r1; // smlad r2, r0, r1, r2; //; // If constants are used instead of loads, these will need to be hoisted; // out and into a register.; //; // If loop invariants are used instead of loads, these need to be packed; // before the loop begins.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp:263,Performance,load,load,263,"// The pass needs to identify integer add/sub reductions of 16-bit vector; // multiplications.; // To use SMLAD:; // 1) we first need to find integer add then look for this pattern:; //; // acc0 = ...; // ld0 = load i16; // sext0 = sext i16 %ld0 to i32; // ld1 = load i16; // sext1 = sext i16 %ld1 to i32; // mul0 = mul %sext0, %sext1; // ld2 = load i16; // sext2 = sext i16 %ld2 to i32; // ld3 = load i16; // sext3 = sext i16 %ld3 to i32; // mul1 = mul i32 %sext2, %sext3; // add0 = add i32 %mul0, %acc0; // acc1 = add i32 %add0, %mul1; //; // Which can be selected to:; //; // ldr r0; // ldr r1; // smlad r2, r0, r1, r2; //; // If constants are used instead of loads, these will need to be hoisted; // out and into a register.; //; // If loop invariants are used instead of loads, these need to be packed; // before the loop begins.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp:345,Performance,load,load,345,"// The pass needs to identify integer add/sub reductions of 16-bit vector; // multiplications.; // To use SMLAD:; // 1) we first need to find integer add then look for this pattern:; //; // acc0 = ...; // ld0 = load i16; // sext0 = sext i16 %ld0 to i32; // ld1 = load i16; // sext1 = sext i16 %ld1 to i32; // mul0 = mul %sext0, %sext1; // ld2 = load i16; // sext2 = sext i16 %ld2 to i32; // ld3 = load i16; // sext3 = sext i16 %ld3 to i32; // mul1 = mul i32 %sext2, %sext3; // add0 = add i32 %mul0, %acc0; // acc1 = add i32 %add0, %mul1; //; // Which can be selected to:; //; // ldr r0; // ldr r1; // smlad r2, r0, r1, r2; //; // If constants are used instead of loads, these will need to be hoisted; // out and into a register.; //; // If loop invariants are used instead of loads, these need to be packed; // before the loop begins.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp:397,Performance,load,load,397,"// The pass needs to identify integer add/sub reductions of 16-bit vector; // multiplications.; // To use SMLAD:; // 1) we first need to find integer add then look for this pattern:; //; // acc0 = ...; // ld0 = load i16; // sext0 = sext i16 %ld0 to i32; // ld1 = load i16; // sext1 = sext i16 %ld1 to i32; // mul0 = mul %sext0, %sext1; // ld2 = load i16; // sext2 = sext i16 %ld2 to i32; // ld3 = load i16; // sext3 = sext i16 %ld3 to i32; // mul1 = mul i32 %sext2, %sext3; // add0 = add i32 %mul0, %acc0; // acc1 = add i32 %add0, %mul1; //; // Which can be selected to:; //; // ldr r0; // ldr r1; // smlad r2, r0, r1, r2; //; // If constants are used instead of loads, these will need to be hoisted; // out and into a register.; //; // If loop invariants are used instead of loads, these need to be packed; // before the loop begins.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp:663,Performance,load,loads,663,"// The pass needs to identify integer add/sub reductions of 16-bit vector; // multiplications.; // To use SMLAD:; // 1) we first need to find integer add then look for this pattern:; //; // acc0 = ...; // ld0 = load i16; // sext0 = sext i16 %ld0 to i32; // ld1 = load i16; // sext1 = sext i16 %ld1 to i32; // mul0 = mul %sext0, %sext1; // ld2 = load i16; // sext2 = sext i16 %ld2 to i32; // ld3 = load i16; // sext3 = sext i16 %ld3 to i32; // mul1 = mul i32 %sext2, %sext3; // add0 = add i32 %mul0, %acc0; // acc1 = add i32 %add0, %mul1; //; // Which can be selected to:; //; // ldr r0; // ldr r1; // smlad r2, r0, r1, r2; //; // If constants are used instead of loads, these will need to be hoisted; // out and into a register.; //; // If loop invariants are used instead of loads, these need to be packed; // before the loop begins.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp:776,Performance,load,loads,776,"// The pass needs to identify integer add/sub reductions of 16-bit vector; // multiplications.; // To use SMLAD:; // 1) we first need to find integer add then look for this pattern:; //; // acc0 = ...; // ld0 = load i16; // sext0 = sext i16 %ld0 to i32; // ld1 = load i16; // sext1 = sext i16 %ld1 to i32; // mul0 = mul %sext0, %sext1; // ld2 = load i16; // sext2 = sext i16 %ld2 to i32; // ld3 = load i16; // sext3 = sext i16 %ld3 to i32; // mul1 = mul i32 %sext2, %sext3; // add0 = add i32 %mul0, %acc0; // acc1 = add i32 %add0, %mul1; //; // Which can be selected to:; //; // ldr r0; // ldr r1; // smlad r2, r0, r1, r2; //; // If constants are used instead of loads, these will need to be hoisted; // out and into a register.; //; // If loop invariants are used instead of loads, these need to be packed; // before the loop begins.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp:50,Modifiability,extend,extended,50,// Check that the muls operate directly upon sign extended loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp:59,Performance,load,loads,59,// Check that the muls operate directly upon sign extended loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp:47,Performance,load,loads,47,"// The first elements of each vector should be loads with sexts. If we; // find that its two pairs of consecutive loads, then these can be; // transformed into two wider loads and the users can be replaced with; // DSP intrinsics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp:114,Performance,load,loads,114,"// The first elements of each vector should be loads with sexts. If we; // find that its two pairs of consecutive loads, then these can be; // transformed into two wider loads and the users can be replaced with; // DSP intrinsics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp:170,Performance,load,loads,170,"// The first elements of each vector should be loads with sexts. If we; // find that its two pairs of consecutive loads, then these can be; // transformed into two wider loads and the users can be replaced with; // DSP intrinsics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp:53,Performance,load,loads,53,// Check that each mul is operating on two different loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp:14,Performance,load,load,14,// Insert the load at the point of the original dominating load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp:59,Performance,load,load,59,// Insert the load at the point of the original dominating load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp:19,Performance,load,load,19,"// Create the wide load, while making sure to maintain the original alignment; // as this prevents ldrd from being generated when it could be illegal due to; // memory alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp:17,Performance,load,load,17,"// From the wide load, create two values that equal the original two loads.; // Loads[0] needs trunc while Loads[1] needs a lshr and trunc.; // TODO: Support big-endian as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp:69,Performance,load,loads,69,"// From the wide load, create two values that equal the original two loads.; // Loads[0] needs trunc while Loads[1] needs a lshr and trunc.; // TODO: Support big-endian as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp:80,Performance,Load,Loads,80,"// From the wide load, create two values that equal the original two loads.; // Loads[0] needs trunc while Loads[1] needs a lshr and trunc.; // TODO: Support big-endian as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp:107,Performance,Load,Loads,107,"// From the wide load, create two values that equal the original two loads.; // Loads[0] needs trunc while Loads[1] needs a lshr and trunc.; // TODO: Support big-endian as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMRegisterBankInfo.cpp:19,Testability,log,logic,19,// Try the default logic for non-generic instructions that are either copies; // or already have some operands assigned to banks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMRegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMRegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSelectionDAGInfo.cpp:3,Modifiability,Extend,Extend,3,// Extend or truncate the argument to be an i32 value for the call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSelectionDAGInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSelectionDAGInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSelectionDAGInfo.cpp:37,Performance,optimiz,optimizations,37,"// Do not generate inline TP loop if optimizations is disabled,; // or if optimization for size (-Os or -Oz) is on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSelectionDAGInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSelectionDAGInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSelectionDAGInfo.cpp:74,Performance,optimiz,optimization,74,"// Do not generate inline TP loop if optimizations is disabled,; // or if optimization for size (-Os or -Oz) is on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSelectionDAGInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSelectionDAGInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSelectionDAGInfo.cpp:22,Performance,load,loads,22,// Do repeated 4-byte loads and stores. To be improved.; // This requires 4-byte alignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSelectionDAGInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSelectionDAGInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSelectionDAGInfo.cpp:23,Performance,load,loads,23,// Emit a maximum of 4 loads in Thumb1 since we have fewer registers,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSelectionDAGInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSelectionDAGInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSelectionDAGInfo.cpp:141,Energy Efficiency,reduce,reduce,141,"// FIXME: We should invent a VMEMCPY pseudo-instruction that lowers to; // VLDM/VSTM and make this code emit it when appropriate. This would reduce; // pressure on the general purpose registers. However this seems harder to map; // onto the register allocator's view of the world.; // The number of MEMCPY pseudo-instructions to emit. We use up to; // MaxLoadsInLDM registers per mcopy, which will get lowered into ldm/stm; // later on. This is a lower bound on the number of MEMCPY operations we must; // emit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSelectionDAGInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSelectionDAGInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSelectionDAGInfo.cpp:58,Energy Efficiency,reduce,reduce,58,// Evenly distribute registers among MEMCPY operations to reduce register; // pressure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSelectionDAGInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSelectionDAGInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSelectionDAGInfo.cpp:9,Performance,load,loads,9,// Issue loads / stores for the trailing (1 - 3) bytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSelectionDAGInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSelectionDAGInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSLSHardening.cpp:192,Performance,optimiz,optimization,192,// FIXME: It probably would be possible to filter which thunks to produce; // based on which registers are actually used in indirect calls in this; // function. But would that be a worthwhile optimization?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSLSHardening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSLSHardening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSLSHardening.cpp:373,Safety,avoid,avoid,373,"// Since linkers are allowed to clobber R12 on function calls, the above; // mitigation only works if the original indirect call instruction was not; // using R12. Code generation before must make sure that no indirect call; // using R12 was produced if the mitigation is enabled.; // Also, the transformation is incorrect if the indirect call uses LR, so; // also have to avoid that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSLSHardening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSLSHardening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSLSHardening.cpp:348,Safety,avoid,avoid,348,"// Now copy the implicit operands from IndirectCall to BL and copy other; // necessary info.; // However, both IndirectCall and BL instructions implictly use SP and; // implicitly define LR. Blindly copying implicit operands would result in SP; // and LR operands to be present multiple times. While this may not be too; // much of an issue, let's avoid that for cleanliness, by removing those; // implicit operands from the BL created above before we copy over all; // implicit operands from the IndirectCall.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSLSHardening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSLSHardening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp:105,Testability,test,testing,105,"/// ForceFastISel - Use the fast-isel, even for subtargets where it is not; /// currently supported (for testing only).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp:159,Availability,avail,available,159,"// MCAsmInfo isn't always present (e.g. in opt) so we can't initialize this; // directly from it, but we can try to make sure they're consistent when both; // available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp:72,Testability,Assert,Assert,72,// FIXME: This used enable V6T2 support implicitly for Thumb2 mode.; // Assert this for now to make the change obvious.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp:14,Energy Efficiency,schedul,scheduling,14,// Initialize scheduling itinerary for the specified CPU.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp:146,Performance,load,load,146,"// 32 bit macho has no relocation for a-b if a is undefined, even if b is in; // the section that is being relocated. This means we have to use o load even; // for GVs that are known to be local to the dso.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp:315,Energy Efficiency,schedul,scheduler,315,"// The MachineScheduler can increase register usage, so we use more high; // registers and end up with more T2 instructions that cannot be converted to; // T1 instructions. At least until we do better at converting to thumb1; // instructions, on cortex-m at Oz where we are size-paranoid, don't use the; // Machine scheduler, relying on the DAG register pressure scheduler instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp:363,Energy Efficiency,schedul,scheduler,363,"// The MachineScheduler can increase register usage, so we use more high; // registers and end up with more T2 instructions that cannot be converted to; // T1 instructions. At least until we do better at converting to thumb1; // instructions, on cortex-m at Oz where we are size-paranoid, don't use the; // Machine scheduler, relying on the DAG register pressure scheduler instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp:43,Performance,optimiz,optimize,43,// Enable SubRegLiveness for MVE to better optimize s subregs for mqpr regs; // and q subregs for qqqqpr regs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp:56,Energy Efficiency,schedul,scheduling,56,// Thumb1 cores will generally not benefit from post-ra scheduling,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp:60,Energy Efficiency,allocate,allocated,60,"// For general targets, the prologue can grow when VFPs are allocated with; // stride 4 (more vpush instructions). But WatchOS uses a compact unwind; // format which it's more important to get right.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp:40,Testability,test,testing,40,"// Enable fast-isel for any target, for testing only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp:56,Testability,test,tested,56,// Limit fast-isel to the targets that are or have been tested.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp:3,Energy Efficiency,Allocate,Allocate,3,"// Allocate low registers first, so we can select more 16-bit instructions.; // We also (in ignoreCSRForAllocationOrder) override the default behaviour; // with regards to callee-saved registers, because pushing extra registers is; // much cheaper (in terms of code size) than using high registers. After; // that, we allocate r12 (doesn't need to be saved), lr (saving it means we; // can return with the pop, don't need an extra ""bx lr"") and then the rest of; // the high registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp:318,Energy Efficiency,allocate,allocate,318,"// Allocate low registers first, so we can select more 16-bit instructions.; // We also (in ignoreCSRForAllocationOrder) override the default behaviour; // with regards to callee-saved registers, because pushing extra registers is; // much cheaper (in terms of code size) than using high registers. After; // that, we allocate r12 (doesn't need to be saved), lr (saving it means we; // can return with the pop, don't need an extra ""bx lr"") and then the rest of; // the high registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp:14,Energy Efficiency,allocate,allocate,14,"// Otherwise, allocate in the default order, using LR first because saving it; // allows a shorter epilogue sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp:189,Energy Efficiency,allocate,allocated,189,"// To minimize code size in Thumb2, we prefer the usage of low regs (lower; // cost per use) so we can use narrow encoding. By default, caller-saved; // registers (e.g. lr, r12) are always allocated first, regardless of; // their cost per use. When optForMinSize, we prefer the low regs even if; // they are CSR because usually push/pop can be folded into existing ones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h:27,Performance,load,load,27,/// What kind of timing do load multiple/store multiple instructions have.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h:8,Performance,load,load,8,/// Can load/store 2 registers/cycle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h:8,Performance,load,load,8,"/// Can load/store 2 registers/cycle, but needs an extra cycle if the access; /// is not 64-bit aligned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h:70,Security,access,access,70,"/// Can load/store 2 registers/cycle, but needs an extra cycle if the access; /// is not 64-bit aligned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h:8,Performance,load,load,8,/// Can load/store 1 register/cycle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h:8,Performance,load,load,8,"/// Can load/store 1 register/cycle, but needs an extra cycle for address; /// computation and potentially also for register writeback.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h:114,Testability,stub,stubs,114,/// SupportsTailCall - True if the OS supports tail call. The dynamic linker; /// must be able to synthesize call stubs for interworking between ARM and; /// Thumb.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h:38,Deployability,update,updates,38,/// Clearance before partial register updates (in number of instructions),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h:4,Usability,Clear,Clearance,4,/// Clearance before partial register updates (in number of instructions),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h:27,Performance,load,load,27,"/// What kind of timing do load multiple/store multiple have (double issue,; /// single issue etc).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h:60,Performance,latency,latency,60,/// The adjustment that we need to apply to get the operand latency from the; /// operand cycle returned by the itinerary data for pre-ISel operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h:81,Security,access,accessed,81,"// ARM EABI is the bare-metal EABI described in ARM ABI documents and; // can be accessed via -target arm-none-eabi. This is NOT GNUEABI.; // FIXME: Add a flag for bare-metal for that target and set Triple::EABI; // even for GNUEABI, so we can make a distinction here and still conform to; // the EABI on GNU (and Android) mode. This requires change in Clang, too.; // FIXME: The Darwin exception is temporary, while we move users to; // ""*-*-*-macho"" triples as quickly as possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h:259,Security,access,access,259,"/// Returns true if the frame setup is split into two separate pushes (first; /// r0-r7,lr then r8-r11), principally so that the frame pointer is adjacent; /// to lr. This is always required on Thumb1-only targets, as the push and; /// pop instructions can't access the high registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h:28,Energy Efficiency,schedul,scheduler,28,/// Returns true if machine scheduler should be enabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h:28,Deployability,pipeline,pipeliner,28,/// Returns true if machine pipeliner should be enabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h:72,Energy Efficiency,schedul,scheduling,72,"/// Enable use of alias analysis during code generation (during MI; /// scheduling, DAGCombine, etc.).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h:27,Security,access,accessed,27,/// True if the GV will be accessed via an indirect symbol.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h:49,Security,access,access,49,/// Returns the constant pool modifier needed to access the GV.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h:82,Availability,avail,available,82,"/// Returns the correct return opcode for the current feature set.; /// Use BX if available to allow mixing thumb/arm code, but fall back; /// to plain mov pc,lr on ARMv4.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp:86,Integrability,depend,depend,86,// This needs to be done before we create a new subtarget since any; // creation will depend on the TM and the code generation flags on the; // function that reside in TargetOptions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp:28,Deployability,Configurat,Configuration,28,/// ARM Code Generator Pass Configuration Options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp:28,Modifiability,Config,Configuration,28,/// ARM Code Generator Pass Configuration Options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp:172,Usability,simpl,simplify,172,"// Cmpxchg instructions are often used with a subsequent comparison to; // determine whether it succeeded. We can exploit existing control-flow in; // ldrex/strex loops to simplify this, but it needs tidying up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp:28,Security,access,accesses,28,// Match interleaved memory accesses to ldN/stN intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp:262,Safety,safe,safe,262,// Merging of extern globals is enabled by default on non-Mach-O as we; // expect it to be generally either beneficial or harmless. On Mach-O it; // is disabled as we emit the .subsections_via_symbols directive which; // means that merging extern globals is not safe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp:82,Energy Efficiency,schedul,scheduling,82,// Expand some pseudo instructions into multiple instructions to allow; // proper scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp:174,Integrability,depend,depends,174,"// When optimising for size, always run the Thumb2SizeReduction pass before; // IfConversion. Otherwise, check whether IT blocks are restricted; // (e.g. in v8, IfConversion depends on Thumb instruction widths)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp:12,Energy Efficiency,schedul,scheduling,12,// Add both scheduling passes to give the subtarget an opportunity to pick; // between them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp:9,Performance,optimiz,optimize,9,// Don't optimize barriers or block placement at -O0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp:37,Safety,unsafe,unsafe,37,// Inserts fixup instructions before unsafe AES operations. Instructions may; // be inserted at the start of blocks and at within blocks so this pass has to; // come before those below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp:122,Performance,load,load,122,"// Inserts Constant Islands. Block sizes cannot be increased after this point,; // as this may push the branch ranges and load offsets of accessing constant; // pools out of range..",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp:138,Security,access,accessing,138,"// Inserts Constant Islands. Block sizes cannot be increased after this point,; // as this may push the branch ranges and load offsets of accessing constant; // pools out of range..",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.h:8,Deployability,Pipeline,Pipeline,8,// Pass Pipeline Configuration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.h:17,Deployability,Configurat,Configuration,17,// Pass Pipeline Configuration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.h:17,Modifiability,Config,Configuration,17,// Pass Pipeline Configuration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetObjectFile.cpp:20,Security,access,access,20,// Set execute-only access for the explicit section,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetObjectFile.h:19,Modifiability,variab,variable,19,/// Describe a TLS variable address within debug info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetObjectFile.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetObjectFile.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:21,Performance,load,load,21,"/// Convert a vector load intrinsic into a simple llvm load instruction.; /// This is beneficial when the underlying object being addressed comes; /// from a constant, since we get constant-folding for free.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:55,Performance,load,load,55,"/// Convert a vector load intrinsic into a simple llvm load instruction.; /// This is beneficial when the underlying object being addressed comes; /// from a constant, since we get constant-folding for free.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:43,Usability,simpl,simple,43,"/// Convert a vector load intrinsic into a simple llvm load instruction.; /// This is beneficial when the underlying object being addressed comes; /// from a constant, since we get constant-folding for free.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:62,Integrability,depend,depending,62,// The only odd/even lanes of operand 0 will only be demanded depending; // on whether this is a top/bottom instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:3,Performance,Load,Load,3,// Load from constantpool.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:66,Usability,simpl,simplified,66,"// Look for a FP Saturation pattern, where the instruction can be simplified to; // a fptosi.sat. max(min(fptosi)). The constant in this case is always free.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:3,Usability,UX,UXTB,3,// UXTB/UXTH,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:8,Usability,UX,UXTH,8,// UXTB/UXTH,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:191,Performance,perform,performance,191,"// FIXME: The vectorizer is highly sensistive to the cost of these; // instructions, which suggests that it may be using the costs incorrectly.; // But, for now, just make them free to avoid performance regressions for; // vector targets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:185,Safety,avoid,avoid,185,"// FIXME: The vectorizer is highly sensistive to the cost of these; // instructions, which suggests that it may be using the costs incorrectly.; // But, for now, just make them free to avoid performance regressions for; // vector targets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:19,Performance,throughput,throughput,19,// TODO: Allow non-throughput costs that aren't binary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:13,Availability,mask,masked,13,// Extending masked load/Truncating masked stores is expensive because we; // currently don't split them. This means that we'll likely end up; // loading/storing each element individually (hence the high cost).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:36,Availability,mask,masked,36,// Extending masked load/Truncating masked stores is expensive because we; // currently don't split them. This means that we'll likely end up; // loading/storing each element individually (hence the high cost).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:3,Modifiability,Extend,Extending,3,// Extending masked load/Truncating masked stores is expensive because we; // currently don't split them. This means that we'll likely end up; // loading/storing each element individually (hence the high cost).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:20,Performance,load,load,20,// Extending masked load/Truncating masked stores is expensive because we; // currently don't split them. This means that we'll likely end up; // loading/storing each element individually (hence the high cost).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:146,Performance,load,loading,146,// Extending masked load/Truncating masked stores is expensive because we; // currently don't split them. This means that we'll likely end up; // loading/storing each element individually (hence the high cost).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:7,Modifiability,extend,extend,7,// The extend of other kinds of load is free,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:32,Performance,load,load,32,// The extend of other kinds of load is free,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:17,Modifiability,extend,extend,17,"// The following extend from a legal type to an illegal type, so need to; // split the load. This introduced an extra load operation, but the; // extend is still ""free"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:146,Modifiability,extend,extend,146,"// The following extend from a legal type to an illegal type, so need to; // split the load. This introduced an extra load operation, but the; // extend is still ""free"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:87,Performance,load,load,87,"// The following extend from a legal type to an illegal type, so need to; // split the load. This introduced an extra load operation, but the; // extend is still ""free"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:118,Performance,load,load,118,"// The following extend from a legal type to an illegal type, so need to; // split the load. This introduced an extra load operation, but the; // extend is still ""free"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:58,Modifiability,extend,extends,58,// The truncate of a store is free. This is the mirror of extends above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:35,Modifiability,extend,extend,35,// NEON vector operations that can extend their inputs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:88,Availability,down,down,88,"// Some arithmetic, load and store operations have specific instructions; // to cast up/down their types automatically at no extra cost.; // TODO: Get these tables to know at least what the related operations are.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:20,Performance,load,load,20,"// Some arithmetic, load and store operations have specific instructions; // to cast up/down their types automatically at no extra cost.; // TODO: Get these tables to know at least what the related operations are.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:7,Modifiability,extend,extend,7,"// MVE extend costs, taken from codegen tests. i8->i16 or i16->i32 is one; // instruction, i8->i32 is two. i64 zexts are an VAND with a constant, sext; // are linearised so take more.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:40,Testability,test,tests,40,"// MVE extend costs, taken from codegen tests. i8->i16 or i16->i32 is one; // instruction, i8->i32 is two. i64 zexts are an VAND with a constant, sext; // are linearised so take more.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:140,Availability,avail,available,140,"// As general rule, fp converts that were not matched above are scalarized; // and cost 1 vcvt for each lane, so long as the instruction is available.; // If not it will become a series of function calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:27,Integrability,depend,dependent,27,// i16 -> i64 requires two dependent operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:94,Performance,throughput,throughput,94,// Penalize inserting into an D-subregister. We end up with a three times; // lower estimated throughput on swift.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:21,Performance,throughput,throughput,21,"// Default to cheap (throughput/size of 1 instruction) but adjust throughput; // for ""multiple beats"" potentially needed by MVE instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:66,Performance,throughput,throughput,66,"// Default to cheap (throughput/size of 1 instruction) but adjust throughput; // for ""multiple beats"" potentially needed by MVE instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:275,Performance,throughput,throughput,275,// Address computations in vectorized code with non-consecutive addresses will; // likely result in more instructions compared to scalar code where the; // computation can more often be merged into the index mode. The resulting; // extra micro-ops can significantly decrease throughput.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:78,Performance,optimiz,optimized,78,"// If a VCTP is part of a chain, it's already profitable and shouldn't be; // optimized, else LSR may block tail-predication.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:20,Modifiability,extend,extending,20,// We don't support extending fp types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:91,Performance,perform,performed,91,"/// Given a memcpy/memset/memmove instruction, return the number of memory; /// operations performed, via querying findOptimalMemOpLowering. Returns -1 if a; /// call is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:76,Performance,load,loaded,76,// MemOps will be poplulated with a list of data types that needs to be; // loaded and stored. That's why we multiply the number of elements by 2 to; // get the cost for this memcpy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:21,Performance,throughput,throughput,21,"// Default to cheap (throughput/size of 1 instruction) but adjust throughput; // for ""multiple beats"" potentially needed by MVE instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:66,Performance,throughput,throughput,66,"// Default to cheap (throughput/size of 1 instruction) but adjust throughput; // for ""multiple beats"" potentially needed by MVE instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:13,Performance,load,loads,13,// Unaligned loads/stores are extremely inefficient.; // We need 4 uops for vst.1/vld.1 vs 1uop for vldr/vstr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:51,Modifiability,extend,extending,51,// MVE can optimize a fpext(load(4xhalf)) using an extending integer load.; // Same for stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:11,Performance,optimiz,optimize,11,// MVE can optimize a fpext(load(4xhalf)) using an extending integer load.; // Same for stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:28,Performance,load,load,28,// MVE can optimize a fpext(load(4xhalf)) using an extending integer load.; // Same for stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:69,Performance,load,load,69,// MVE can optimize a fpext(load(4xhalf)) using an extending integer load.; // Same for stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:76,Security,Access,Accesses,76,// vldN/vstN only support legal vector types of size 64 or 128 in bits.; // Accesses having vector types that are a multiple of 128 bits can be; // matched to more than one vldN/vstN instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:136,Performance,load,load,136,"// Some smaller than legal interleaved patterns are cheap as we can make; // use of the vmovn or vrev patterns to interleave a standard load. This is; // true for v4i8, v8i8 and v4i16 at least (but not for v4f16 as it is; // promoted differently). The cost of 2 here is then a load and vrev or; // vmovn.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:277,Performance,load,load,277,"// Some smaller than legal interleaved patterns are cheap as we can make; // use of the vmovn or vrev patterns to interleave a standard load. This is; // true for v4i8, v8i8 and v4i16 at least (but not for v4f16 as it is; // promoted differently). The cost of 2 here is then a load and vrev or; // vmovn.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:67,Performance,load,loads,67,"// For now, it is assumed that for the MVE gather instructions the loads are; // all effectively serialised. This means the cost is the scalar cost; // multiplied by the number of elements being loaded. This is possibly very; // conservative, but even so we still end up vectorising loops because the; // cost per iteration for many loops is lower than for scalar loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:195,Performance,load,loaded,195,"// For now, it is assumed that for the MVE gather instructions the loads are; // all effectively serialised. This means the cost is the scalar cost; // multiplied by the number of elements being loaded. This is possibly very; // conservative, but even so we still end up vectorising loops because the; // cost per iteration for many loops is lower than for scalar loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:127,Availability,mask,masking,127,"// The scalarization cost should be a lot higher. We use the number of vector; // elements plus the scalarization overhead. If masking is required then a lot; // of little blocks will be needed and potentially a scalarized p0 mask,; // greatly increasing the cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:226,Availability,mask,mask,226,"// The scalarization cost should be a lot higher. We use the number of vector; // elements plus the scalarization overhead. If masking is required then a lot; // of little blocks will be needed and potentially a scalarized p0 mask,; // greatly increasing the cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:56,Modifiability,extend,extended,56,// Check whether there's a single user that asks for an extended type,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:3,Integrability,Depend,Dependent,3,"// Dependent of the caller of this function, a gather instruction will; // either have opcode Instruction::Load or be a call to the masked_gather; // intrinsic",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:107,Performance,Load,Load,107,"// Dependent of the caller of this function, a gather instruction will; // either have opcode Instruction::Load or be a call to the masked_gather; // intrinsic",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:80,Modifiability,extend,extended,80,"// For smaller types, we need to ensure that the gep's inputs are correctly; // extended from a small enough value. Other sizes (including i64) are; // scalarized for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:159,Integrability,depend,depending,159,"// In general floating point reductions are a series of elementwise; // operations, with free extracts on each step. These are either in-order or; // treewise depending on whether that is allowed by the fast math flags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:91,Performance,perform,perform,91,// For fp16 we need to extract the upper lane elements. MVE can add a; // VREV+FMIN/MAX to perform another vector step instead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:24,Performance,perform,perform,24,"// For i16/i8, MVE will perform a VREV + VORR/VAND/VEOR for the 64bit vector; // step.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:41,Performance,perform,perform,41,// From here we extract the elements and perform the and/or/xor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:195,Availability,mask,mask,195,"// The legal cases are:; // VADDV u/s 8/16/32; // VADDLV u/s 32; // Codegen currently cannot always handle larger than legal vectors very; // well, especially for predicated reductions where the mask needs to be; // split, so restrict to 128bit or smaller input types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:198,Availability,mask,mask,198,"// The legal cases are:; // VMLAV u/s 8/16/32; // VMLALV u/s 16/32; // Codegen currently cannot always handle larger than legal vectors very; // well, especially for predicated reductions where the mask needs to be; // split, so restrict to 128bit or smaller input types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:159,Integrability,depend,depending,159,"// In general floating point reductions are a series of elementwise; // operations, with free extracts on each step. These are either in-order or; // treewise depending on whether that is allowed by the fast math flags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:91,Performance,perform,perform,91,// For fp16 we need to extract the upper lane elements. MVE can add a; // VREV+FMIN/MAX to perform another vector step instead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:298,Safety,detect,detect,298,"// Currently we make a somewhat optimistic assumption that; // active_lane_mask's are always free. In reality it may be freely folded; // into a tail predicated loop, expanded into a VCPT or expanded into a lot; // of add/icmp code. We may need to improve this in the future, but being; // able to detect if it is free or not involves looking at a lot of other; // code. We currently assume that the vectorizer inserted these, and knew; // what it was doing in adding one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:83,Modifiability,extend,extend,83,"// This is a base cost of 1 for the vqadd, plus 3 extract shifts if we; // need to extend the type, as it uses shr(qadd(shl, shl)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:27,Performance,perform,perform,27,// We'll need a libcall to perform double precision operations on a single; // precision only FPU.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:35,Usability,clear,clear,35,"// Making a call will trash LR and clear LO_BRANCH_INFO, so there's little; // point in generating a hardware loop if that's going to happen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:81,Usability,simpl,simply,81,"// We don't allow icmp's, and because we only look at single block loops,; // we simply count the icmps, i.e. there should only be 1 for the backedge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:246,Performance,perform,performance,246,"// FIXME: This is a workaround for poor cost modelling. Min/Max intrinsics are; // not currently canonical, but soon will be. Code without them uses icmp, and; // so is not tail predicated as per the condition above. In order to get the; // same performance we treat min and max the same as an icmp for tailpred; // purposes for the moment (we often rely on non-tailpred and higher VF's to; // pick more optimial instructions like VQDMULH. They need to be recognized; // directly by the vectorizer).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:18,Modifiability,extend,extending,18,"// We could allow extending/narrowing FP loads/stores, but codegen is; // too inefficient so reject this for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:41,Performance,load,loads,41,"// We could allow extending/narrowing FP loads/stores, but codegen is; // too inefficient so reject this for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:3,Modifiability,Extend,Extends,3,// Extends have to be extending-loads,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:22,Modifiability,extend,extending-loads,22,// Extends have to be extending-loads,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:32,Performance,load,loads,32,// Extends have to be extending-loads,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:488,Availability,mask,masks,488,"// To set up a tail-predicated loop, we need to know the total number of; // elements processed by that loop. Thus, we need to determine the element; // size and:; // 1) it should be uniform for all operations in the vector loop, so we; // e.g. don't want any widening/narrowing operations.; // 2) it should be smaller than i64s because we don't have vector operations; // that work on i64s.; // 3) we don't want elements to be reversed or shuffled, to make sure the; // tail-predication masks/predicates the right lanes.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:133,Usability,simpl,simple,133,"// TODO: for now only allow consecutive strides of 1. We could support; // other strides as long as it is uniform, but let's keep it simple; // for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:53,Performance,load,load,53,// TODO: don't tail predicate if there is a reversed load?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:28,Performance,load,loading,28,"// Gather/scatters do allow loading from arbitrary strides, at; // least if they are loop invariant.; // TODO: Loop variant strides should in theory work, too, but; // this requires further testing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:190,Testability,test,testing,190,"// Gather/scatters do allow loading from arbitrary strides, at; // least if they are loop invariant.; // TODO: Loop variant strides should in theory work, too, but; // this requires further testing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:133,Availability,mask,masked,133,"// Creating a predicated vector loop is the first step for generating a; // tail-predicated hardware loop, for which we need the MVE masked; // load/stores instructions:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:144,Performance,load,load,144,"// Creating a predicated vector loop is the first step for generating a; // tail-predicated hardware loop, for which we need the MVE masked; // load/stores instructions:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:35,Availability,mask,mask,35,"// Intrinsic @llvm.get.active.lane.mask is supported.; // It is used in the MVETailPredication pass, which requires the number of; // elements processed by this vector loop to setup the tail-predicated; // loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:93,Availability,mask,mask,93,"// Enable Upper bound unrolling universally, providing that we do not see an; // active lane mask, which will be better kept as a loop to become tail; // predicated than to be conditionally unrolled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:60,Safety,predict,predictor,60,// Limit the CFG of the loop body for targets with a branch predictor.; // Allowing 4 blocks permits if-then-else diamonds in the body.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:46,Availability,avail,available,46,"// On v6m cores, there are very few registers available. We can easily end up; // spilling and reloading more registers in an unrolled loop. Look at the; // number of LCSSA phis as a rough measure of how many registers will need to; // be live out of the loop, reducing the default unroll count if more than 1; // value is needed. In the long run, all of this should be being learnt by a; // machine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:376,Usability,learn,learnt,376,"// On v6m cores, there are very few registers available. We can easily end up; // spilling and reloading more registers in an unrolled loop. Look at the; // number of LCSSA phis as a rough measure of how many registers will need to; // be live out of the loop, reducing the default unroll count if more than 1; // value is needed. In the long run, all of this should be being learnt by a; // machine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:10,Availability,avail,available,10,"// B.W is available in any Thumb2-supporting target, and also in every; // version of Armv8-M, even Baseline which does not include the rest of; // Thumb2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:8,Availability,avail,available,8,"// B is available in all versions of the Arm ISA, so the only question is; // whether that ISA is available at all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:98,Availability,avail,available,98,"// B is available in all versions of the Arm ISA, so the only question is; // whether that ISA is available at all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.h:234,Availability,avail,available,234,"// Currently the following features are excluded from InlineFeaturesAllowed.; // ModeThumb, FeatureNoARM, ModeSoftFloat, FeatureFP64, FeatureD32; // Depending on whether they are set or unset, different; // instructions/registers are available. For example, inlining a callee with; // -thumb-mode in a caller with +thumb-mode, may cause the assembler to; // fail if the callee uses ARM only instructions, e.g. in inline asm.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.h:149,Integrability,Depend,Depending,149,"// Currently the following features are excluded from InlineFeaturesAllowed.; // ModeThumb, FeatureNoARM, ModeSoftFloat, FeatureFP64, FeatureD32; // Depending on whether they are set or unset, different; // instructions/registers are available. For example, inlining a callee with; // -thumb-mode in a caller with +thumb-mode, may cause the assembler to; // fail if the callee uses ARM only instructions, e.g. in inline asm.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.h:198,Availability,mask,masked,198,"// For MVE, we have a custom lowering pass that will already have custom; // legalised any gathers that we can lower to MVE intrinsics, and want to; // expand all the rest. The pass runs before the masked intrinsic lowering; // pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.h:79,Modifiability,variab,variables,79,"// In the ROPI and RWPI relocation models we can't have pointers to global; // variables or functions in constant data, so don't convert switches to; // lookup tables if any of the values would need relocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MLxExpansionPass.cpp:52,Safety,avoid,avoid,52,"//===-- MLxExpansionPass.cpp - Expand MLx instrs to avoid hazards ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Expand VFP / NEON floating point MLA / MLS instructions (each to a pair of; // multiple and add / sub instructions) when special VMLx hazards are detected.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MLxExpansionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MLxExpansionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MLxExpansionPass.cpp:58,Safety,hazard,hazards,58,"//===-- MLxExpansionPass.cpp - Expand MLx instrs to avoid hazards ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Expand VFP / NEON floating point MLA / MLS instructions (each to a pair of; // multiple and add / sub instructions) when special VMLx hazards are detected.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MLxExpansionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MLxExpansionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MLxExpansionPass.cpp:517,Safety,hazard,hazards,517,"//===-- MLxExpansionPass.cpp - Expand MLx instrs to avoid hazards ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Expand VFP / NEON floating point MLA / MLS instructions (each to a pair of; // multiple and add / sub instructions) when special VMLx hazards are detected.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MLxExpansionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MLxExpansionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MLxExpansionPass.cpp:529,Safety,detect,detected,529,"//===-- MLxExpansionPass.cpp - Expand MLx instrs to avoid hazards ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Expand VFP / NEON floating point MLA / MLS instructions (each to a pair of; // multiple and add / sub instructions) when special VMLx hazards are detected.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MLxExpansionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MLxExpansionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MLxExpansionPass.cpp:10,Safety,Detect,Detect,10,// FIXME: Detect integer instructions properly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MLxExpansionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MLxExpansionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MLxExpansionPass.cpp:34,Safety,hazard,hazards,34,"// On Swift, we mostly care about hazards from multiplication instructions; // writing the accumulator and the pipelining of loop iterations by out-of-; // order execution.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MLxExpansionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MLxExpansionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MLxExpansionPass.cpp:295,Energy Efficiency,schedul,scheduler,295,"// If a VMLA.F is followed by an VADD.F or VMUL.F with no RAW hazard, the; // VADD.F or VMUL.F will stall 4 cycles before issue. The 4 cycle stall; // preserves the in-order retirement of the instructions.; // Look at the next few instructions, if *most* of them can cause hazards,; // then the scheduler can't *fix* this, we'd better break up the VMLA.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MLxExpansionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MLxExpansionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MLxExpansionPass.cpp:62,Safety,hazard,hazard,62,"// If a VMLA.F is followed by an VADD.F or VMUL.F with no RAW hazard, the; // VADD.F or VMUL.F will stall 4 cycles before issue. The 4 cycle stall; // preserves the in-order retirement of the instructions.; // Look at the next few instructions, if *most* of them can cause hazards,; // then the scheduler can't *fix* this, we'd better break up the VMLA.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MLxExpansionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MLxExpansionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MLxExpansionPass.cpp:273,Safety,hazard,hazards,273,"// If a VMLA.F is followed by an VADD.F or VMUL.F with no RAW hazard, the; // VADD.F or VMUL.F will stall 4 cycles before issue. The 4 cycle stall; // preserves the in-order retirement of the instructions.; // Look at the next few instructions, if *most* of them can cause hazards,; // then the scheduler can't *fix* this, we'd better break up the VMLA.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MLxExpansionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MLxExpansionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MLxExpansionPass.cpp:21,Safety,hazard,hazard,21,// Look for VMLx RAW hazard.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MLxExpansionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MLxExpansionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp:51,Modifiability,extend,extended,51,"// Offsets that are not of type <N x i32> are sign extended by the; // getelementptr instruction, and MVE gathers/scatters treat the offset as; // unsigned. Thus, if the element size is smaller than 32, we can only allow; // positive offsets - i.e., the offsets are not allowed to be variables we; // can't look into.; // Additionally, <N x i32> offsets have to either originate from a zext of a; // vector with element types smaller or equal the type of the gather we're; // looking at, or consist of constants that we can check are small enough; // to fit into the gather type.; // Thus we check that 0 < value < 2^TargetElemSize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp:284,Modifiability,variab,variables,284,"// Offsets that are not of type <N x i32> are sign extended by the; // getelementptr instruction, and MVE gathers/scatters treat the offset as; // unsigned. Thus, if the element size is smaller than 32, we can only allow; // positive offsets - i.e., the offsets are not allowed to be variables we; // can't look into.; // Additionally, <N x i32> offsets have to either originate from a zext of a; // vector with element types smaller or equal the type of the gather we're; // looking at, or consist of constants that we can check are small enough; // to fit into the gather type.; // Thus we check that 0 < value < 2^TargetElemSize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp:23,Performance,load,load,23,"// This can be a 32bit load/store scaled by 4, a 16bit load/store scaled by 2,; // or a 8bit, 16bit or 32bit load/store scaled by 1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp:55,Performance,load,load,55,"// This can be a 32bit load/store scaled by 4, a 16bit load/store scaled by 2,; // or a 8bit, 16bit or 32bit load/store scaled by 1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp:109,Performance,load,load,109,"// This can be a 32bit load/store scaled by 4, a 16bit load/store scaled by 2,; // or a 8bit, 16bit or 32bit load/store scaled by 1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp:9,Availability,mask,masked,9,"// @llvm.masked.gather.*(Ptrs, alignment, Mask, Src0); // Attempt to turn the masked gather in I into a MVE intrinsic; // Potentially optimising the addressing modes as we do so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp:42,Availability,Mask,Mask,42,"// @llvm.masked.gather.*(Ptrs, alignment, Mask, Src0); // Attempt to turn the masked gather in I into a MVE intrinsic; // Potentially optimising the addressing modes as we do so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp:78,Availability,mask,masked,78,"// @llvm.masked.gather.*(Ptrs, alignment, Mask, Src0); // Attempt to turn the masked gather in I into a MVE intrinsic; // Potentially optimising the addressing modes as we do so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp:18,Modifiability,extend,extending,18,"// If this was an extending gather, we need to get rid of the sext/zext; // sext/zext as well as of the gather itself",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp:127,Modifiability,extend,extend,127,// The size of the gather was already checked in isLegalTypeAndAlignment;; // if it was not a full vector width an appropriate extend should follow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp:30,Modifiability,extend,extend,30,"// If the gather has a single extend of the correct type, use an extending; // gather and replace the ext. In which case the correct root to replace; // is not the CallInst itself, but the instruction which extends it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp:65,Modifiability,extend,extending,65,"// If the gather has a single extend of the correct type, use an extending; // gather and replace the ext. In which case the correct root to replace; // is not the CallInst itself, but the instruction which extends it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp:207,Modifiability,extend,extends,207,"// If the gather has a single extend of the correct type, use an extending; // gather and replace the ext. In which case the correct root to replace; // is not the CallInst itself, but the instruction which extends it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp:9,Modifiability,extend,extend,9,"// If an extend hasn't been found and the type is an integer, create an; // extending gather and truncate back to the original type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp:76,Modifiability,extend,extending,76,"// If an extend hasn't been found and the type is an integer, create an; // extending gather and truncate back to the original type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp:9,Availability,mask,masked,9,"// @llvm.masked.scatter.*(data, ptrs, alignment, mask); // Attempt to turn the masked scatter in I into a MVE intrinsic; // Potentially optimising the addressing modes as we do so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp:49,Availability,mask,mask,49,"// @llvm.masked.scatter.*(data, ptrs, alignment, mask); // Attempt to turn the masked scatter in I into a MVE intrinsic; // Potentially optimising the addressing modes as we do so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp:79,Availability,mask,masked,79,"// @llvm.masked.scatter.*(data, ptrs, alignment, mask); // Attempt to turn the masked scatter in I into a MVE intrinsic; // Potentially optimising the addressing modes as we do so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp:67,Availability,mask,mask,67,"// int_arm_mve_vstr_scatter_base(_predicated) addr, offset, data(, mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp:43,Deployability,integrat,integrate,43,"// If the input has been truncated, try to integrate that trunc into the; // scatter instruction (we don't care about alignment here)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp:43,Integrability,integrat,integrate,43,"// If the input has been truncated, try to integrate that trunc into the; // scatter instruction (we don't care about alignment here)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp:18,Energy Efficiency,charge,charge,18,// The gep was in charge of making sure the offsets are scaled correctly; // - calculate that factor so it can be applied by hand,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp:88,Performance,load,load,88,"// Check whether this gather's offset is incremented by a constant - if so,; // and the load is of the right type, we can merge this into a QI gather",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp:81,Modifiability,variab,variable,81,"// Then the increment we are looking at is not an increment of the; // induction variable, and we don't want to do a writeback",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp:49,Energy Efficiency,reduce,reduces,49,// Order such that start index comes first (this reduces mov's),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp:93,Modifiability,variab,variable,93,// Create a new scalar add outside of the loop and transform it to a splat; // by which loop variable can be incremented,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp:90,Usability,simpl,simple,90,// Check whether all usages of this instruction are as offsets of; // gathers/scatters or simple arithmetics only used by gathers/scatters,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp:25,Performance,perform,perform,25,// A phi node we want to perform this function on should be from the; // loop header.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp:23,Usability,simpl,simple,23,// We're looking for a simple add recurrence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp:29,Safety,abort,abort,29,"// Something has gone wrong, abort",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp:56,Energy Efficiency,adapt,adapt,56,"// If the phi is not used by anything else, we can just adapt it when; // replacing the instruction; if it is, we'll have to duplicate it",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp:56,Modifiability,adapt,adapt,56,"// If the phi is not used by anything else, we can just adapt it when; // replacing the instruction; if it is, we'll have to duplicate it",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVELaneInterleavingPass.cpp:1795,Energy Efficiency,efficient,efficiently,1795,"LVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass interleaves around sext/zext/trunc instructions. MVE does not have; // a single sext/zext or trunc instruction that takes the bottom half of a; // vector and extends to a full width, like NEON has with MOVL. Instead it is; // expected that this happens through top/bottom instructions. So the MVE; // equivalent VMOVLT/B instructions take either the even or odd elements of the; // input and extend them to the larger type, producing a vector with half the; // number of elements each of double the bitwidth. As there is no simple; // instruction, we often have to turn sext/zext/trunc into a series of lane; // moves (or stack loads/stores, which we do not do yet).; //; // This pass takes vector code that starts at truncs, looks for interconnected; // blobs of operations that end with sext/zext (or constants/splats) of the; // form:; // %sa = sext v8i16 %a to v8i32; // %sb = sext v8i16 %b to v8i32; // %add = add v8i32 %sa, %sb; // %r = trunc %add to v8i16; // And adds shuffles to allow the use of VMOVL/VMOVN instrctions:; // %sha = shuffle v8i16 %a, undef, <0, 2, 4, 6, 1, 3, 5, 7>; // %sa = sext v8i16 %sha to v8i32; // %shb = shuffle v8i16 %b, undef, <0, 2, 4, 6, 1, 3, 5, 7>; // %sb = sext v8i16 %shb to v8i32; // %add = add v8i32 %sa, %sb; // %r = trunc %add to v8i16; // %shr = shuffle v8i16 %r, undef, <0, 4, 1, 5, 2, 6, 3, 7>; // Which can then be split and lowered to MVE instructions efficiently:; // %sa_b = VMOVLB.s16 %a; // %sa_t = VMOVLT.s16 %a; // %sb_b = VMOVLB.s16 %b; // %sb_t = VMOVLT.s16 %b; // %add_b = VADD.i32 %sa_b, %sb_b; // %add_t = VADD.i32 %sa_t, %sb_t; // %r = VMOVNT.i16 %add_b, %add_t; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVELaneInterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVELaneInterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVELaneInterleavingPass.cpp:551,Modifiability,extend,extends,551,"//===- MVELaneInterleaving.cpp - Inverleave for MVE instructions ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass interleaves around sext/zext/trunc instructions. MVE does not have; // a single sext/zext or trunc instruction that takes the bottom half of a; // vector and extends to a full width, like NEON has with MOVL. Instead it is; // expected that this happens through top/bottom instructions. So the MVE; // equivalent VMOVLT/B instructions take either the even or odd elements of the; // input and extend them to the larger type, producing a vector with half the; // number of elements each of double the bitwidth. As there is no simple; // instruction, we often have to turn sext/zext/trunc into a series of lane; // moves (or stack loads/stores, which we do not do yet).; //; // This pass takes vector code that starts at truncs, looks for interconnected; // blobs of operations that end with sext/zext (or constants/splats) of the; // form:; // %sa = sext v8i16 %a to v8i32; // %sb = sext v8i16 %b to v8i32; // %add = add v8i32 %sa, %sb; // %r = trunc %add to v8i16; // And adds shuffles to allow the use of VMOVL/VMOVN instrctions:; // %sha = shuffle v8i16 %a, undef, <0, 2, 4, 6, 1, 3, 5, 7>; // %sa = sext v8i16 %sha to v8i32; // %shb = shuffle v8i16 %b, undef, <0, 2, 4, 6, 1, 3, 5, 7>; // %sb = sext v8i16 %shb to v8i32; // %add = add v8i32 %sa, %sb; // %r = trunc %add to v8i16; // %shr = shuffle v8i16 %r, undef, <0, 4, 1, 5, 2, 6, 3, 7>; // Which can then be split and lowered to MVE instructions efficiently:; // %sa_b = VMOVLB.s16 %a; // %sa_t = VMOVLT.s16 %a; // %sb_b = VMOVLB.s16 %b; // %sb_t = VMOVLT.s16 %b; // %add_b = VADD.i32 %sa_b, %sb_b; // %add_t = VADD.i32 %sa_t, %sb_t; // %r = VMOVNT.i16",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVELaneInterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVELaneInterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVELaneInterleavingPass.cpp:785,Modifiability,extend,extend,785,"//===- MVELaneInterleaving.cpp - Inverleave for MVE instructions ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass interleaves around sext/zext/trunc instructions. MVE does not have; // a single sext/zext or trunc instruction that takes the bottom half of a; // vector and extends to a full width, like NEON has with MOVL. Instead it is; // expected that this happens through top/bottom instructions. So the MVE; // equivalent VMOVLT/B instructions take either the even or odd elements of the; // input and extend them to the larger type, producing a vector with half the; // number of elements each of double the bitwidth. As there is no simple; // instruction, we often have to turn sext/zext/trunc into a series of lane; // moves (or stack loads/stores, which we do not do yet).; //; // This pass takes vector code that starts at truncs, looks for interconnected; // blobs of operations that end with sext/zext (or constants/splats) of the; // form:; // %sa = sext v8i16 %a to v8i32; // %sb = sext v8i16 %b to v8i32; // %add = add v8i32 %sa, %sb; // %r = trunc %add to v8i16; // And adds shuffles to allow the use of VMOVL/VMOVN instrctions:; // %sha = shuffle v8i16 %a, undef, <0, 2, 4, 6, 1, 3, 5, 7>; // %sa = sext v8i16 %sha to v8i32; // %shb = shuffle v8i16 %b, undef, <0, 2, 4, 6, 1, 3, 5, 7>; // %sb = sext v8i16 %shb to v8i32; // %add = add v8i32 %sa, %sb; // %r = trunc %add to v8i16; // %shr = shuffle v8i16 %r, undef, <0, 4, 1, 5, 2, 6, 3, 7>; // Which can then be split and lowered to MVE instructions efficiently:; // %sa_b = VMOVLB.s16 %a; // %sa_t = VMOVLT.s16 %a; // %sb_b = VMOVLB.s16 %b; // %sb_t = VMOVLT.s16 %b; // %add_b = VADD.i32 %sa_b, %sb_b; // %add_t = VADD.i32 %sa_t, %sb_t; // %r = VMOVNT.i16",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVELaneInterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVELaneInterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVELaneInterleavingPass.cpp:1021,Performance,load,loads,1021,"//===- MVELaneInterleaving.cpp - Inverleave for MVE instructions ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass interleaves around sext/zext/trunc instructions. MVE does not have; // a single sext/zext or trunc instruction that takes the bottom half of a; // vector and extends to a full width, like NEON has with MOVL. Instead it is; // expected that this happens through top/bottom instructions. So the MVE; // equivalent VMOVLT/B instructions take either the even or odd elements of the; // input and extend them to the larger type, producing a vector with half the; // number of elements each of double the bitwidth. As there is no simple; // instruction, we often have to turn sext/zext/trunc into a series of lane; // moves (or stack loads/stores, which we do not do yet).; //; // This pass takes vector code that starts at truncs, looks for interconnected; // blobs of operations that end with sext/zext (or constants/splats) of the; // form:; // %sa = sext v8i16 %a to v8i32; // %sb = sext v8i16 %b to v8i32; // %add = add v8i32 %sa, %sb; // %r = trunc %add to v8i16; // And adds shuffles to allow the use of VMOVL/VMOVN instrctions:; // %sha = shuffle v8i16 %a, undef, <0, 2, 4, 6, 1, 3, 5, 7>; // %sa = sext v8i16 %sha to v8i32; // %shb = shuffle v8i16 %b, undef, <0, 2, 4, 6, 1, 3, 5, 7>; // %sb = sext v8i16 %shb to v8i32; // %add = add v8i32 %sa, %sb; // %r = trunc %add to v8i16; // %shr = shuffle v8i16 %r, undef, <0, 4, 1, 5, 2, 6, 3, 7>; // Which can then be split and lowered to MVE instructions efficiently:; // %sa_b = VMOVLB.s16 %a; // %sa_t = VMOVLT.s16 %a; // %sb_b = VMOVLB.s16 %b; // %sb_t = VMOVLT.s16 %b; // %add_b = VADD.i32 %sa_b, %sb_b; // %add_t = VADD.i32 %sa_t, %sb_t; // %r = VMOVNT.i16",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVELaneInterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVELaneInterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVELaneInterleavingPass.cpp:917,Usability,simpl,simple,917,"//===- MVELaneInterleaving.cpp - Inverleave for MVE instructions ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass interleaves around sext/zext/trunc instructions. MVE does not have; // a single sext/zext or trunc instruction that takes the bottom half of a; // vector and extends to a full width, like NEON has with MOVL. Instead it is; // expected that this happens through top/bottom instructions. So the MVE; // equivalent VMOVLT/B instructions take either the even or odd elements of the; // input and extend them to the larger type, producing a vector with half the; // number of elements each of double the bitwidth. As there is no simple; // instruction, we often have to turn sext/zext/trunc into a series of lane; // moves (or stack loads/stores, which we do not do yet).; //; // This pass takes vector code that starts at truncs, looks for interconnected; // blobs of operations that end with sext/zext (or constants/splats) of the; // form:; // %sa = sext v8i16 %a to v8i32; // %sb = sext v8i16 %b to v8i32; // %add = add v8i32 %sa, %sb; // %r = trunc %add to v8i16; // And adds shuffles to allow the use of VMOVL/VMOVN instrctions:; // %sha = shuffle v8i16 %a, undef, <0, 2, 4, 6, 1, 3, 5, 7>; // %sa = sext v8i16 %sha to v8i32; // %shb = shuffle v8i16 %b, undef, <0, 2, 4, 6, 1, 3, 5, 7>; // %sb = sext v8i16 %shb to v8i32; // %add = add v8i32 %sa, %sb; // %r = trunc %add to v8i16; // %shr = shuffle v8i16 %r, undef, <0, 4, 1, 5, 2, 6, 3, 7>; // Which can then be split and lowered to MVE instructions efficiently:; // %sa_b = VMOVLB.s16 %a; // %sa_t = VMOVLT.s16 %a; // %sb_b = VMOVLB.s16 %b; // %sb_t = VMOVLT.s16 %b; // %add_b = VADD.i32 %sa_b, %sb_b; // %add_t = VADD.i32 %sa_t, %sb_t; // %r = VMOVNT.i16",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVELaneInterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVELaneInterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVELaneInterleavingPass.cpp:474,Modifiability,extend,extends,474,"// This is not always beneficial to transform. Exts can be incorporated into; // loads, Truncs can be folded into stores.; // Truncs are usually the same number of instructions,; // VSTRH.32(A);VSTRH.32(B) vs VSTRH.16(VMOVNT A, B) with interleaving; // Exts are unfortunately more instructions in the general case:; // A=VLDRH.32; B=VLDRH.32;; // vs with interleaving:; // T=VLDRH.16; A=VMOVNB T; B=VMOVNT T; // But those VMOVL may be folded into a VMULL.; // But expensive extends/truncs are always good to remove. FPExts always; // involve extra VCVT's so are always considered to be beneficial to convert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVELaneInterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVELaneInterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVELaneInterleavingPass.cpp:81,Performance,load,loads,81,"// This is not always beneficial to transform. Exts can be incorporated into; // loads, Truncs can be folded into stores.; // Truncs are usually the same number of instructions,; // VSTRH.32(A);VSTRH.32(B) vs VSTRH.16(VMOVNT A, B) with interleaving; // Exts are unfortunately more instructions in the general case:; // A=VLDRH.32; B=VLDRH.32;; // vs with interleaving:; // T=VLDRH.16; A=VMOVNB T; B=VMOVNT T; // But those VMOVL may be folded into a VMULL.; // But expensive extends/truncs are always good to remove. FPExts always; // involve extra VCVT's so are always considered to be beneficial to convert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVELaneInterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVELaneInterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVELaneInterleavingPass.cpp:61,Modifiability,Extend,Extends,61,"// Otherwise, we know we have a load(ext), see if any of the Extends are a; // vmull. This is a simple heuristic and certainly not perfect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVELaneInterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVELaneInterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVELaneInterleavingPass.cpp:32,Performance,load,load,32,"// Otherwise, we know we have a load(ext), see if any of the Extends are a; // vmull. This is a simple heuristic and certainly not perfect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVELaneInterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVELaneInterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVELaneInterleavingPass.cpp:96,Usability,simpl,simple,96,"// Otherwise, we know we have a load(ext), see if any of the Extends are a; // vmull. This is a simple heuristic and certainly not perfect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVELaneInterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVELaneInterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVELaneInterleavingPass.cpp:3,Modifiability,Extend,Extend,3,// Extend leafs,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVELaneInterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVELaneInterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVELaneInterleavingPass.cpp:34,Modifiability,extend,extends,34,// Create new shuffles around the extends / truncs / other leaves.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVELaneInterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVELaneInterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp:1197,Availability,mask,mask,1197,"//===- MVETailPredication.cpp - MVE Tail Predication ------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// Armv8.1m introduced MVE, M-Profile Vector Extension, and low-overhead; /// branches to help accelerate DSP applications. These two extensions,; /// combined with a new form of predication called tail-predication, can be used; /// to provide implicit vector predication within a low-overhead loop.; /// This is implicit because the predicate of active/inactive lanes is; /// calculated by hardware, and thus does not need to be explicitly passed; /// to vector instructions. The instructions responsible for this are the; /// DLSTP and WLSTP instructions, which setup a tail-predicated loop and the; /// the total number of data elements processed by the loop. The loop-end; /// LETP instruction is responsible for decrementing and setting the remaining; /// elements to be processed and generating the mask of active lanes.; ///; /// The HardwareLoops pass inserts intrinsics identifying loops that the; /// backend will attempt to convert into a low-overhead loop. The vectorizer is; /// responsible for generating a vectorized loop in which the lanes are; /// predicated upon an get.active.lane.mask intrinsic. This pass looks at these; /// get.active.lane.mask intrinsic and attempts to convert them to VCTP; /// instructions. This will be picked up by the ARM Low-overhead loop pass later; /// in the backend, which performs the final transformation to a DLSTP or WLSTP; /// tail-predicated loop.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp:1492,Availability,mask,mask,1492,"//===- MVETailPredication.cpp - MVE Tail Predication ------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// Armv8.1m introduced MVE, M-Profile Vector Extension, and low-overhead; /// branches to help accelerate DSP applications. These two extensions,; /// combined with a new form of predication called tail-predication, can be used; /// to provide implicit vector predication within a low-overhead loop.; /// This is implicit because the predicate of active/inactive lanes is; /// calculated by hardware, and thus does not need to be explicitly passed; /// to vector instructions. The instructions responsible for this are the; /// DLSTP and WLSTP instructions, which setup a tail-predicated loop and the; /// the total number of data elements processed by the loop. The loop-end; /// LETP instruction is responsible for decrementing and setting the remaining; /// elements to be processed and generating the mask of active lanes.; ///; /// The HardwareLoops pass inserts intrinsics identifying loops that the; /// backend will attempt to convert into a low-overhead loop. The vectorizer is; /// responsible for generating a vectorized loop in which the lanes are; /// predicated upon an get.active.lane.mask intrinsic. This pass looks at these; /// get.active.lane.mask intrinsic and attempts to convert them to VCTP; /// instructions. This will be picked up by the ARM Low-overhead loop pass later; /// in the backend, which performs the final transformation to a DLSTP or WLSTP; /// tail-predicated loop.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp:1554,Availability,mask,mask,1554,"//===- MVETailPredication.cpp - MVE Tail Predication ------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// Armv8.1m introduced MVE, M-Profile Vector Extension, and low-overhead; /// branches to help accelerate DSP applications. These two extensions,; /// combined with a new form of predication called tail-predication, can be used; /// to provide implicit vector predication within a low-overhead loop.; /// This is implicit because the predicate of active/inactive lanes is; /// calculated by hardware, and thus does not need to be explicitly passed; /// to vector instructions. The instructions responsible for this are the; /// DLSTP and WLSTP instructions, which setup a tail-predicated loop and the; /// the total number of data elements processed by the loop. The loop-end; /// LETP instruction is responsible for decrementing and setting the remaining; /// elements to be processed and generating the mask of active lanes.; ///; /// The HardwareLoops pass inserts intrinsics identifying loops that the; /// backend will attempt to convert into a low-overhead loop. The vectorizer is; /// responsible for generating a vectorized loop in which the lanes are; /// predicated upon an get.active.lane.mask intrinsic. This pass looks at these; /// get.active.lane.mask intrinsic and attempts to convert them to VCTP; /// instructions. This will be picked up by the ARM Low-overhead loop pass later; /// in the backend, which performs the final transformation to a DLSTP or WLSTP; /// tail-predicated loop.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp:1715,Performance,perform,performs,1715,"//===- MVETailPredication.cpp - MVE Tail Predication ------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// Armv8.1m introduced MVE, M-Profile Vector Extension, and low-overhead; /// branches to help accelerate DSP applications. These two extensions,; /// combined with a new form of predication called tail-predication, can be used; /// to provide implicit vector predication within a low-overhead loop.; /// This is implicit because the predicate of active/inactive lanes is; /// calculated by hardware, and thus does not need to be explicitly passed; /// to vector instructions. The instructions responsible for this are the; /// DLSTP and WLSTP instructions, which setup a tail-predicated loop and the; /// the total number of data elements processed by the loop. The loop-end; /// LETP instruction is responsible for decrementing and setting the remaining; /// elements to be processed and generating the mask of active lanes.; ///; /// The HardwareLoops pass inserts intrinsics identifying loops that the; /// backend will attempt to convert into a low-overhead loop. The vectorizer is; /// responsible for generating a vectorized loop in which the lanes are; /// predicated upon an get.active.lane.mask intrinsic. This pass looks at these; /// get.active.lane.mask intrinsic and attempts to convert them to VCTP; /// instructions. This will be picked up by the ARM Low-overhead loop pass later; /// in the backend, which performs the final transformation to a DLSTP or WLSTP; /// tail-predicated loop.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp:68,Availability,mask,masks,68,/// Perform the relevant checks on the loop and convert active lane masks if; /// possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp:4,Performance,Perform,Perform,4,/// Perform the relevant checks on the loop and convert active lane masks if; /// possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp:69,Availability,mask,mask,69,"/// Perform several checks on the arguments of @llvm.get.active.lane.mask; /// intrinsic. E.g., check that the loop induction variable and the element; /// count are of the form we expect, and also perform overflow checks for; /// the new expressions that are created.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp:126,Modifiability,variab,variable,126,"/// Perform several checks on the arguments of @llvm.get.active.lane.mask; /// intrinsic. E.g., check that the loop induction variable and the element; /// count are of the form we expect, and also perform overflow checks for; /// the new expressions that are created.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp:4,Performance,Perform,Perform,4,"/// Perform several checks on the arguments of @llvm.get.active.lane.mask; /// intrinsic. E.g., check that the loop induction variable and the element; /// count are of the form we expect, and also perform overflow checks for; /// the new expressions that are created.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp:198,Performance,perform,perform,198,"/// Perform several checks on the arguments of @llvm.get.active.lane.mask; /// intrinsic. E.g., check that the loop induction variable and the element; /// count are of the form we expect, and also perform overflow checks for; /// the new expressions that are created.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp:7,Testability,test,test,7,// The test.set iteration could live in the pre-preheader.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp:74,Availability,mask,mask,74,"// The active lane intrinsic has this form:; //; // @llvm.get.active.lane.mask(IV, TC); //; // Here we perform checks that this intrinsic behaves as expected,; // which means:; //; // 1) Check that the TripCount (TC) belongs to this loop (originally).; // 2) The element count (TC) needs to be sufficiently large that the decrement; // of element counter doesn't overflow, which means that we need to prove:; // ceil(ElementCount / VectorWidth) >= TripCount; // by rounding up ElementCount up:; // ((ElementCount + (VectorWidth - 1)) / VectorWidth; // and evaluate if expression isKnownNonNegative:; // (((ElementCount + (VectorWidth - 1)) / VectorWidth) - TripCount; // 3) The IV must be an induction phi with an increment equal to the; // vector width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp:103,Performance,perform,perform,103,"// The active lane intrinsic has this form:; //; // @llvm.get.active.lane.mask(IV, TC); //; // Here we perform checks that this intrinsic behaves as expected,; // which means:; //; // 1) Check that the TripCount (TC) belongs to this loop (originally).; // 2) The element count (TC) needs to be sufficiently large that the decrement; // of element counter doesn't overflow, which means that we need to prove:; // ceil(ElementCount / VectorWidth) >= TripCount; // by rounding up ElementCount up:; // ((ElementCount + (VectorWidth - 1)) / VectorWidth; // and evaluate if expression isKnownNonNegative:; // (((ElementCount + (VectorWidth - 1)) / VectorWidth) - TripCount; // 3) The IV must be an induction phi with an increment equal to the; // vector width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp:12,Testability,test,tests,12,"// 1) Smoke tests that the original scalar loop TripCount (TC) belongs to; // this loop. The scalar tripcount corresponds the number of elements; // processed by the loop, so we will refer to that from this point on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp:108,Modifiability,variab,variable,108,"// 2) Find out if IV is an induction phi. Note that we can't use Loop; // helpers here to get the induction variable, because the hardware loop is; // no longer in loopsimplify form, and also the hwloop intrinsic uses a; // different counter. Using SCEV, we check that the induction is of the; // form i = i + 4, where the increment must be equal to the VectorWidth.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp:144,Availability,mask,mask,144,"// If the tripcount values are inconsistent, we can't insert the VCTP and; // trigger tail-predication; keep the intrinsic as a get.active.lane.mask; // and legalize this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp:18,Modifiability,variab,variable,18,// Prevent unused variable warnings with TC,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp:330,Testability,test,test,330,"// As an example, almost all the tripcount expressions (produced by the; // vectoriser) look like this:; //; // TC = ((-4 + (4 * ((3 + %N) /u 4))<nuw> - start) /u 4); //; // and ""ElementCount + (VW-1) / VW"":; //; // Ceil = ((3 + %N) /u 4); //; // Check for equality of TC and Ceil by calculating SCEV expression; // TC - Ceil and test it for zero.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp:234,Availability,Mask,MaskedValueIsZero,234,"// Check that the start value is a multiple of the VectorWidth.; // TODO: This could do with a method to check if the scev is a multiple of; // VectorWidth. For the moment we just check for constants, muls and unknowns; // (which use MaskedValueIsZero and seems to be the most common).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp:28,Availability,mask,mask,28,"// Replace @llvm.get.active.mask() with the ARM specific VCTP intrinic, and; // thus represent the effect of tail predication.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp:512,Performance,perform,performed,512,"//===-- MVETPAndVPTOptimisationsPass.cpp ----------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file This pass does a few optimisations related to Tail predicated loops; /// and MVE VPT blocks before register allocation is performed. For VPT blocks; /// the goal is to maximize the sizes of the blocks that will be created by the; /// MVE VPT Block Insertion pass (which runs after register allocation). For; /// tail predicated loops we transform the loop into something that will; /// hopefully make the backend ARMLowOverheadLoops pass's job easier.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp:271,Deployability,update,updated,271,"// Starting from PreHeader, search for invalid instructions back until the; // LoopStart block is reached. If invalid instructions are found, the loop start; // is reverted from a WhileLoopStart to a DoLoopStart on the same loop. Will; // return the new DLS LoopStart if updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp:500,Energy Efficiency,allocate,allocate,500,"// This function converts loops with t2LoopEnd and t2LoopEnd instructions into; // a single t2LoopEndDec instruction. To do that it needs to make sure that LR; // will be valid to be used for the low overhead loop, which means nothing else; // is using LR (especially calls) and there are no superfluous copies in the; // loop. The t2LoopEndDec is a branching terminator that produces a value (the; // decrement) around the loop edge, which means we need to be careful that they; // will be valid to allocate without any spilling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp:79,Usability,simpl,simpler,79,"// Remove any copies from the loop, to ensure the phi that remains is both; // simpler and contains no extra uses. Because t2LoopEndDec is a terminator; // that cannot spill, we need to be careful what remains in the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp:253,Usability,simpl,simpler,253,"// Convert t2DoLoopStart to t2DoLoopStartTP if the loop contains VCTP; // instructions. This keeps the VCTP count reg operand on the t2DoLoopStartTP; // instruction, making the backend ARMLowOverheadLoops passes job of finding the; // VCTP operand much simpler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp:181,Performance,optimiz,optimization,181,// Transforms; // <Instr that uses %A ('User' Operand)>; // Into; // %K = VPNOT %Target; // <Instr that uses %K ('User' Operand)>; // And returns the newly inserted VPNOT.; // This optimization is done in the hopes of preventing spills/reloads of VPR by; // reducing the number of VCCR values with overlapping lifetimes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp:44,Usability,clear,clear,44,"// Make the user use NewResult instead, and clear its kill flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp:33,Energy Efficiency,reduce,reduce,33,"// This optimisation attempts to reduce the number of overlapping lifetimes of; // VCCR values by replacing uses of old VCCR values with VPNOTs. For example,; // this replaces; // %A:vccr = (something); // %B:vccr = VPNOT %A; // %Foo = (some op that uses %B); // %Bar = (some op that uses %A); // With; // %A:vccr = (something); // %B:vccr = VPNOT %A; // %Foo = (some op that uses %B); // %TMP2:vccr = VPNOT %B; // %Bar = (some op that uses %A)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp:29,Performance,optimiz,optimize,29,// This second loop tries to optimize the remaining instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp:235,Availability,mask,mask,235,"// Scan through the block, looking for instructions that use constants moves; // into VPR that are the negative of one another. These are expected to be; // COPY's to VCCRRegClass, from a t2MOVi or t2MOVi16. The last seen constant; // mask is kept it or and VPNOT's of it are added or reused as we scan through; // the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp:38,Deployability,release,release,38,// Silence unused variable warning in release builds.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp:18,Modifiability,variab,variable,18,// Silence unused variable warning in release builds.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEVPTBlockPass.cpp:42,Integrability,depend,depending,42,"// Creates a T, TT, TTT or TTTT BlockMask depending on BlockSize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVEVPTBlockPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEVPTBlockPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEVPTBlockPass.cpp:199,Availability,Mask,Mask,199,"// Given an iterator (Iter) that points at an instruction with a ""Then""; // predicate, tries to create the largest block of continuous predicated; // instructions possible, and returns the VPT Block Mask of that block.; //; // This will try to perform some minor optimization in order to maximize the; // size of the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVEVPTBlockPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEVPTBlockPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEVPTBlockPass.cpp:124,Deployability,continuous,continuous,124,"// Given an iterator (Iter) that points at an instruction with a ""Then""; // predicate, tries to create the largest block of continuous predicated; // instructions possible, and returns the VPT Block Mask of that block.; //; // This will try to perform some minor optimization in order to maximize the; // size of the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVEVPTBlockPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEVPTBlockPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEVPTBlockPass.cpp:244,Performance,perform,perform,244,"// Given an iterator (Iter) that points at an instruction with a ""Then""; // predicate, tries to create the largest block of continuous predicated; // instructions possible, and returns the VPT Block Mask of that block.; //; // This will try to perform some minor optimization in order to maximize the; // size of the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVEVPTBlockPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEVPTBlockPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEVPTBlockPass.cpp:263,Performance,optimiz,optimization,263,"// Given an iterator (Iter) that points at an instruction with a ""Then""; // predicate, tries to create the largest block of continuous predicated; // instructions possible, and returns the VPT Block Mask of that block.; //; // This will try to perform some minor optimization in order to maximize the; // size of the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVEVPTBlockPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEVPTBlockPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEVPTBlockPass.cpp:130,Deployability,update,update,130,"// Replace the predicates of the instructions we're adding.; // Note that we are using ""Iter"" to iterate over the block so we can update; // it at the same time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVEVPTBlockPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEVPTBlockPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEVPTBlockPass.cpp:39,Availability,mask,mask,39,// Change the predicate and update the mask,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVEVPTBlockPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEVPTBlockPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEVPTBlockPass.cpp:28,Deployability,update,update,28,// Change the predicate and update the mask,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MVEVPTBlockPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEVPTBlockPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp:104,Performance,load,load,104,"// If it would take more than three instructions to adjust the stack pointer; // using tADDspi/tSUBspi, load an immediate instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp:72,Usability,simpl,simply,72,"// We have just finished pushing the previous FP into the stack,; // so simply capture the SP value as the new Frame Pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp:151,Energy Efficiency,allocate,allocated,151,"// If we need a base pointer, set it up here. It's whatever the value; // of the stack pointer is at this point. Any variable size objects; // will be allocated after this, so we can still use the base pointer; // to reference locals.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp:117,Modifiability,variab,variable,117,"// If we need a base pointer, set it up here. It's whatever the value; // of the stack pointer is at this point. Any variable size objects; // will be allocated after this, so we can still use the base pointer; // to reference locals.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp:20,Modifiability,variab,variable,20,// If the frame has variable sized objects then the epilogue must restore; // the sp from fp. We can assume there's an FP here since hasFP already; // checks for hasVarSizedObjects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp:59,Modifiability,extend,extends,59,"// Reset SP based on frame pointer only if the stack frame extends beyond; // frame pointer stack slot, the target is ELF and the function has FP, or; // the target uses var sized objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp:49,Availability,avail,available,49,"// Otherwise, remember that the register will be available to; // save a pop-friendly register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp:304,Deployability,update,update,304,"// If MBBI is a return instruction, or is a tPOP followed by a return; // instruction in the successor BB, we may be able to directly restore; // LR in the PC.; // This is only possible with v5T ops (v4T can't change the Thumb bit via; // a POP PC instruction), and only if we do not need to emit any SP update.; // Otherwise, we need a temporary register to pop the value; // and copy that value into LR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp:3,Performance,Load,Load,3,"// Load the LR via LDR tmp, [SP, #off]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp:56,Performance,perform,perform,56,"// We couldn't use the direct restoration above, so; // perform the opposite conversion: tPOP_RET to tPOP.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp:264,Availability,avail,available,264,"// Now push the high registers; // There are no store instructions that can access high registers directly,; // so we have to move them to low registers, and push them.; // This might take multiple pushes, as it is possible for there to; // be fewer low registers available than high registers which need saving.; // Find the first register to save.; // Registers must be processed in reverse order so that in case we need to use; // multiple PUSH instructions, the order of the registers on the stack still; // matches the unwind info. They need to be swicthed back to ascending order; // before adding to the PUSH instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp:76,Security,access,access,76,"// Now push the high registers; // There are no store instructions that can access high registers directly,; // so we have to move them to low registers, and push them.; // This might take multiple pushes, as it is possible for there to; // be fewer low registers available than high registers which need saving.; // Find the first register to save.; // Registers must be processed in reverse order so that in case we need to use; // multiple PUSH instructions, the order of the registers on the stack still; // matches the unwind info. They need to be swicthed back to ascending order; // before adding to the PUSH instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp:280,Availability,avail,available,280,"// Pop the high registers first; // There are no store instructions that can access high registers directly,; // so we have to pop into low registers and them move to the high registers.; // This might take multiple pops, as it is possible for there to; // be fewer low registers available than high registers which need restoring.; // Find the first register to restore.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp:77,Security,access,access,77,"// Pop the high registers first; // There are no store instructions that can access high registers directly,; // so we have to pop into low registers and them move to the high registers.; // This might take multiple pops, as it is possible for there to; // be fewer low registers available than high registers which need restoring.; // Find the first register to restore.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp:20,Availability,avail,available,20,// No copy regs are available to pop high regs. Let's make use of a return; // register and the scratch register (IP/R12) to copy things around.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.h:206,Integrability,wrap,wrapping,206,/// Check whether or not the given \p MBB can be used as a epilogue; /// for the target.; /// The epilogue will be inserted before the first terminator of that block.; /// This method is used by the shrink-wrapping pass to decide if; /// \p MBB will be correctly handled by the target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.h:19,Integrability,wrap,wrap,19,/// Disable shrink wrap as tBfar/BL will be used to adjust for long jumps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.h:246,Deployability,update,update,246,"/// Check if the frame lowering of \p MF needs a special fixup; /// code sequence for the epilogue.; /// Unlike T2 and ARM mode, the T1 pop instruction cannot restore; /// to LR, and we can't pop the value directly to the PC when; /// we need to update the SP after popping the value. So instead; /// we have to emit:; /// POP {r3}; /// ADD sp, #offset; /// BX r3; /// If this would clobber a return value, then generate this sequence instead:; /// MOV ip, r3; /// POP {r3}; /// ADD sp, #offset; /// MOV lr, r3; /// MOV r3, ip; /// BX lr",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1InstrInfo.cpp:17,Energy Efficiency,schedul,scheduler,17,"// In Thumb1 the scheduler may need to schedule a cross-copy between GPRS and CPSR; // but this is not always possible there, so allow the Scheduler to clone tADCS and tSBCS; // even if they have glue.; // FIXME. Actually implement the cross-copy where it is possible (post v6); // because these copies entail more spilling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1InstrInfo.cpp:39,Energy Efficiency,schedul,schedule,39,"// In Thumb1 the scheduler may need to schedule a cross-copy between GPRS and CPSR; // but this is not always possible there, so allow the Scheduler to clone tADCS and tSBCS; // even if they have glue.; // FIXME. Actually implement the cross-copy where it is possible (post v6); // because these copies entail more spilling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1InstrInfo.cpp:139,Energy Efficiency,Schedul,Scheduler,139,"// In Thumb1 the scheduler may need to schedule a cross-copy between GPRS and CPSR; // but this is not always possible there, so allow the Scheduler to clone tADCS and tSBCS; // even if they have glue.; // FIXME. Actually implement the cross-copy where it is possible (post v6); // because these copies entail more spilling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2InstrInfo.cpp:66,Deployability,update,update,66,"// If the first instruction of Tail is predicated, we may have to update; // the IT instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2InstrInfo.cpp:23,Performance,optimiz,optimizeSelect,23,"// Try to use the base optimizeSelect, which uses canFoldIntoMOVCC to fold the; // MOVCC into another instruction. If that fails on 8.1-M fall back to using a; // CSEL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2InstrInfo.cpp:29,Energy Efficiency,reduce,reduce,29,// Use one T2 instruction to reduce NumBytes; // FIXME: Move this to ARMAddressingModes.h?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2InstrInfo.cpp:42,Usability,clear,clear,42,"// We will handle these bits from offset, clear them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2InstrInfo.cpp:17,Modifiability,variab,variable,17,// squash unused-variable warning at -NDEBUG,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2InstrInfo.cpp:57,Usability,simpl,simplify,57,"// Otherwise, offset doesn't fit. Pull in what we can to simplify",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2InstrInfo.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite the BlockMask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2InstrInfo.h:24,Availability,Mask,Mask,24,"// Recomputes the Block Mask of Instr, a VPT or VPST instruction.; // This rebuilds the block mask of the instruction depending on the predicates; // of the instructions following it. This should only be used after the; // MVEVPTBlockInsertion pass has run, and should be used whenever a predicated; // instruction is added to/removed from the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2InstrInfo.h:94,Availability,mask,mask,94,"// Recomputes the Block Mask of Instr, a VPT or VPST instruction.; // This rebuilds the block mask of the instruction depending on the predicates; // of the instructions following it. This should only be used after the; // MVEVPTBlockInsertion pass has run, and should be used whenever a predicated; // instruction is added to/removed from the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2InstrInfo.h:118,Integrability,depend,depending,118,"// Recomputes the Block Mask of Instr, a VPT or VPST instruction.; // This rebuilds the block mask of the instruction depending on the predicates; // of the instructions following it. This should only be used after the; // MVEVPTBlockInsertion pass has run, and should be used whenever a predicated; // instruction is added to/removed from the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2ITBlockPass.cpp:126,Integrability,depend,dependencies,126,"/// TrackDefUses - Tracking what registers are being defined and used by; /// instructions in the IT block. This also tracks ""dependencies"", i.e. uses; /// in the IT block that are defined before the IT instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2ITBlockPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2ITBlockPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2ITBlockPass.cpp:158,Safety,safe,safer,158,"/// Clear kill flags for any uses in the given set. This will likely; /// conservatively remove more kill flags than are necessary, but removing them; /// is safer than incorrect kill flags remaining on instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2ITBlockPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2ITBlockPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2ITBlockPass.cpp:4,Usability,Clear,Clear,4,"/// Clear kill flags for any uses in the given set. This will likely; /// conservatively remove more kill flags than are necessary, but removing them; /// is safer than incorrect kill flags remaining on instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2ITBlockPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2ITBlockPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2ITBlockPass.cpp:126,Energy Efficiency,schedul,scheduled,126,"// llvm models select's as two-address instructions. That means a copy; // is inserted before a t2MOVccr, etc. If the copy is scheduled in; // between selects we would end up creating multiple IT blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2ITBlockPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2ITBlockPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2ITBlockPass.cpp:23,Safety,safe,safe,23,// First check if it's safe to move it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2ITBlockPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2ITBlockPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2ITBlockPass.cpp:15,Availability,mask,mask,15,// Finalize IT mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2ITBlockPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2ITBlockPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:4,Energy Efficiency,Reduce,ReduceTable,4,/// ReduceTable - A static table with information on mapping from wide; /// opcodes to narrow,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:40,Deployability,update,update,40,// 16-bit instruction does partial flag update,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:3,Safety,Avoid,Avoid,3,// Avoid movs with shifter operand (for Swift),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:51,Performance,load,load,51,// FIXME: Clean this up after splitting each Thumb load / store opcode; // into multiple ones.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:4,Energy Efficiency,Reduce,ReduceOpcodeMap,4,/// ReduceOpcodeMap - Maps wide opcode to index of entry in ReduceTable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:60,Energy Efficiency,Reduce,ReduceTable,60,/// ReduceOpcodeMap - Maps wide opcode to index of entry in ReduceTable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:20,Energy Efficiency,Reduce,Reduce,20,/// ReduceTo2Addr - Reduce a 32-bit instruction to a 16-bit two-address; /// instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:4,Energy Efficiency,Reduce,ReduceToNarrow,4,/// ReduceToNarrow - Reduce a 32-bit instruction to a 16-bit; /// non-two-address instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:21,Energy Efficiency,Reduce,Reduce,21,/// ReduceToNarrow - Reduce a 32-bit instruction to a 16-bit; /// non-two-address instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:4,Energy Efficiency,Reduce,ReduceMI,4,"/// ReduceMI - Attempt to reduce MI, return true on success.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:26,Energy Efficiency,reduce,reduce,26,"/// ReduceMI - Attempt to reduce MI, return true on success.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:4,Energy Efficiency,Reduce,ReduceMBB,4,/// ReduceMBB - Reduce width of instructions in the specified basic block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:16,Energy Efficiency,Reduce,Reduce,16,/// ReduceMBB - Reduce width of instructions in the specified basic block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:35,Performance,latency,latency,35,"// Was CPSR last defined by a high latency instruction?; // When CPSRDef is null, this refers to CPSR defs in predecessors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:42,Performance,latency,latency,42,// The flags leaving this block have high latency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:27,Performance,latency,latency,27,// Check for a likely high-latency flag def.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:117,Deployability,update,update,117,"/// canAddPseudoFlagDep - For A9 (and other out-of-order) implementations,; /// the 's' 16-bit instruction partially update CPSR. Abort the; /// transformation to avoid adding false dependency on last CPSR setting; /// instruction which hurts the ability for out-of-order execution engine; /// to do register renaming magic.; /// This function checks if there is a read-of-write dependency between the; /// last instruction that defines the CPSR and the current instruction. If there; /// is, then there is no harm done since the instruction cannot be retired; /// before the CPSR setting instruction anyway.; /// Note, we are not doing full dependency analysis here for the sake of compile; /// time. We're not looking for cases like:; /// r0 = muls ...; /// r1 = add.w r0, ...; /// ...; /// = mul.w r1; /// In this case it would have been ok to narrow the mul.w to muls since there; /// are indirect RAW dependency between the muls and the mul.w",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:182,Integrability,depend,dependency,182,"/// canAddPseudoFlagDep - For A9 (and other out-of-order) implementations,; /// the 's' 16-bit instruction partially update CPSR. Abort the; /// transformation to avoid adding false dependency on last CPSR setting; /// instruction which hurts the ability for out-of-order execution engine; /// to do register renaming magic.; /// This function checks if there is a read-of-write dependency between the; /// last instruction that defines the CPSR and the current instruction. If there; /// is, then there is no harm done since the instruction cannot be retired; /// before the CPSR setting instruction anyway.; /// Note, we are not doing full dependency analysis here for the sake of compile; /// time. We're not looking for cases like:; /// r0 = muls ...; /// r1 = add.w r0, ...; /// ...; /// = mul.w r1; /// In this case it would have been ok to narrow the mul.w to muls since there; /// are indirect RAW dependency between the muls and the mul.w",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:379,Integrability,depend,dependency,379,"/// canAddPseudoFlagDep - For A9 (and other out-of-order) implementations,; /// the 's' 16-bit instruction partially update CPSR. Abort the; /// transformation to avoid adding false dependency on last CPSR setting; /// instruction which hurts the ability for out-of-order execution engine; /// to do register renaming magic.; /// This function checks if there is a read-of-write dependency between the; /// last instruction that defines the CPSR and the current instruction. If there; /// is, then there is no harm done since the instruction cannot be retired; /// before the CPSR setting instruction anyway.; /// Note, we are not doing full dependency analysis here for the sake of compile; /// time. We're not looking for cases like:; /// r0 = muls ...; /// r1 = add.w r0, ...; /// ...; /// = mul.w r1; /// In this case it would have been ok to narrow the mul.w to muls since there; /// are indirect RAW dependency between the muls and the mul.w",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:642,Integrability,depend,dependency,642,"/// canAddPseudoFlagDep - For A9 (and other out-of-order) implementations,; /// the 's' 16-bit instruction partially update CPSR. Abort the; /// transformation to avoid adding false dependency on last CPSR setting; /// instruction which hurts the ability for out-of-order execution engine; /// to do register renaming magic.; /// This function checks if there is a read-of-write dependency between the; /// last instruction that defines the CPSR and the current instruction. If there; /// is, then there is no harm done since the instruction cannot be retired; /// before the CPSR setting instruction anyway.; /// Note, we are not doing full dependency analysis here for the sake of compile; /// time. We're not looking for cases like:; /// r0 = muls ...; /// r1 = add.w r0, ...; /// ...; /// = mul.w r1; /// In this case it would have been ok to narrow the mul.w to muls since there; /// are indirect RAW dependency between the muls and the mul.w",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:906,Integrability,depend,dependency,906,"/// canAddPseudoFlagDep - For A9 (and other out-of-order) implementations,; /// the 's' 16-bit instruction partially update CPSR. Abort the; /// transformation to avoid adding false dependency on last CPSR setting; /// instruction which hurts the ability for out-of-order execution engine; /// to do register renaming magic.; /// This function checks if there is a read-of-write dependency between the; /// last instruction that defines the CPSR and the current instruction. If there; /// is, then there is no harm done since the instruction cannot be retired; /// before the CPSR setting instruction anyway.; /// Note, we are not doing full dependency analysis here for the sake of compile; /// time. We're not looking for cases like:; /// r0 = muls ...; /// r1 = add.w r0, ...; /// ...; /// = mul.w r1; /// In this case it would have been ok to narrow the mul.w to muls since there; /// are indirect RAW dependency between the muls and the mul.w",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:130,Safety,Abort,Abort,130,"/// canAddPseudoFlagDep - For A9 (and other out-of-order) implementations,; /// the 's' 16-bit instruction partially update CPSR. Abort the; /// transformation to avoid adding false dependency on last CPSR setting; /// instruction which hurts the ability for out-of-order execution engine; /// to do register renaming magic.; /// This function checks if there is a read-of-write dependency between the; /// last instruction that defines the CPSR and the current instruction. If there; /// is, then there is no harm done since the instruction cannot be retired; /// before the CPSR setting instruction anyway.; /// Note, we are not doing full dependency analysis here for the sake of compile; /// time. We're not looking for cases like:; /// r0 = muls ...; /// r1 = add.w r0, ...; /// ...; /// = mul.w r1; /// In this case it would have been ok to narrow the mul.w to muls since there; /// are indirect RAW dependency between the muls and the mul.w",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:163,Safety,avoid,avoid,163,"/// canAddPseudoFlagDep - For A9 (and other out-of-order) implementations,; /// the 's' 16-bit instruction partially update CPSR. Abort the; /// transformation to avoid adding false dependency on last CPSR setting; /// instruction which hurts the ability for out-of-order execution engine; /// to do register renaming magic.; /// This function checks if there is a read-of-write dependency between the; /// last instruction that defines the CPSR and the current instruction. If there; /// is, then there is no harm done since the instruction cannot be retired; /// before the CPSR setting instruction anyway.; /// Note, we are not doing full dependency analysis here for the sake of compile; /// time. We're not looking for cases like:; /// r0 = muls ...; /// r1 = add.w r0, ...; /// ...; /// = mul.w r1; /// In this case it would have been ok to narrow the mul.w to muls since there; /// are indirect RAW dependency between the muls and the mul.w",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:34,Performance,Optimiz,OptimizeForSizeHarder,34,// Disable the check for -Oz (aka OptimizeForSizeHarder).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:116,Deployability,update,update,116,"// If this BB loops back to itself, conservatively avoid narrowing the; // first instruction that does partial flag update.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:51,Safety,avoid,avoid,51,"// If this BB loops back to itself, conservatively avoid narrowing the; // first instruction that does partial flag update.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:64,Integrability,depend,dependency,64,"// If the current CPSR has high latency, try to avoid the false dependency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:32,Performance,latency,latency,32,"// If the current CPSR has high latency, try to avoid the false dependency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:48,Safety,avoid,avoid,48,"// If the current CPSR has high latency, try to avoid the false dependency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:37,Integrability,depend,dependency,37,"// tMOVi8 usually doesn't start long dependency chains, and there are a lot; // of them, so always shrink them when CPSR doesn't have high latency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:139,Performance,latency,latency,139,"// tMOVi8 usually doesn't start long dependency chains, and there are a lot; // of them, so always shrink them when CPSR doesn't have high latency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:23,Integrability,depend,dependency,23,// No read-after-write dependency. The narrowing will add false dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:64,Integrability,depend,dependency,64,// No read-after-write dependency. The narrowing will add false dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:49,Performance,load,load,49,// We're creating a completely different type of load/store - LDM from LDR.; // For this reason we can't reuse the logic at the end of this function; we; // have to implement the MI building here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:115,Testability,log,logic,115,// We're creating a completely different type of load/store - LDM from LDR.; // For this reason we can't reuse the logic at the end of this function; we; // have to implement the MI building here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:18,Performance,load,load,18,// Add the 16-bit load / store instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:102,Performance,load,loaded,102,"// For the non-writeback version (this one), the base register must be; // one of the registers being loaded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:14,Energy Efficiency,reduce,reduced,14,"// t2STMIA is reduced to tSTMIA_UPD which has writeback. We can only do this; // if the base register is killed, as then it doesn't matter what its value; // is after the instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:18,Performance,load,load,18,// Add the 16-bit load / store instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:40,Energy Efficiency,reduce,reduce,40,"// If the source register is SP, try to reduce to tADDrSPi, otherwise; // it's a normal reduce.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:88,Energy Efficiency,reduce,reduce,88,"// If the source register is SP, try to reduce to tADDrSPi, otherwise; // it's a normal reduce.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:10,Energy Efficiency,reduce,reduce,10,// Try to reduce to tADDrSPi.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:10,Energy Efficiency,reduce,reduce,10,"// Try to reduce to the lo-reg only version first. Why there are two; // versions of the instruction is a mystery.; // It would be nice to just have two entries in the main table that; // are prioritized, but the table assumes a unique entry for each; // source insn opcode. So for now, we hack a local entry record to use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:73,Performance,optimiz,optimizing,73,// Don't issue movs with shifter operand for some CPUs unless we; // are optimizing for size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:77,Energy Efficiency,reduce,reduce,77,"// If the other operand also isn't the same as the destination, we; // can't reduce.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:51,Deployability,update,update,51,// Avoid adding a false dependency on partial flag update by some 16-bit; // instructions which has the 's' bit set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:24,Integrability,depend,dependency,24,// Avoid adding a false dependency on partial flag update by some 16-bit; // instructions which has the 's' bit set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:3,Safety,Avoid,Avoid,3,// Avoid adding a false dependency on partial flag update by some 16-bit; // instructions which has the 's' bit set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:73,Performance,optimiz,optimizing,73,// Don't issue movs with shifter operand for some CPUs unless we; // are optimizing for size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:51,Deployability,update,update,51,// Avoid adding a false dependency on partial flag update by some 16-bit; // instructions which has the 's' bit set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:24,Integrability,depend,dependency,24,// Avoid adding a false dependency on partial flag update by some 16-bit; // instructions which has the 's' bit set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:3,Safety,Avoid,Avoid,3,// Avoid adding a false dependency on partial flag update by some 16-bit; // instructions which has the 's' bit set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:116,Deployability,update,update,116,"// If this BB loops back to itself, conservatively avoid narrowing the; // first instruction that does partial flag update.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:51,Safety,avoid,avoid,51,"// If this BB loops back to itself, conservatively avoid narrowing the; // first instruction that does partial flag update.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:24,Energy Efficiency,schedul,scheduler,24,"// FIXME: Since post-ra scheduler operates on bundles, the CPSR kill; // marker is only on the BUNDLE instruction. Process the BUNDLE; // instruction as we finish with the bundled instruction to work around; // the inconsistency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:3,Performance,Optimiz,Optimizing,3,// Optimizing / minimizing size? Minimizing size implies optimizing for size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:57,Performance,optimiz,optimizing,57,// Optimizing / minimizing size? Minimizing size implies optimizing for size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.cpp:32,Performance,load,load,32,/// emitLoadConstPool - Emits a load from constpool to materialize the; /// specified immediate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.cpp:288,Performance,load,load,288,"/// emitThumbRegPlusImmInReg - Emits a series of instructions to materialize a; /// destreg = basereg + immediate in Thumb code. Materialize the immediate in a; /// register using mov / mvn (armv6-M >) sequences, movs / lsls / adds / lsls /; /// adds / lsls / adds sequences (armv6-M) or load the immediate from a; /// constpool entry.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.cpp:48,Performance,Load,Load,48,"// Subtract doesn't have high register version. Load the negative value; // if either base or dest register is a high register. Also, if do not; // issue sub as part of the sequence if condition register is to be; // preserved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.cpp:76,Availability,avail,available,76,"// Strategy:; // We need to select two types of instruction, maximizing the available; // immediate range of each. The instructions we use will depend on whether; // DestReg and BaseReg are low, high or the stack pointer.; // * CopyOpc - DestReg = BaseReg + imm; // This will be emitted once if DestReg != BaseReg, and never if; // DestReg == BaseReg.; // * ExtraOpc - DestReg = DestReg + imm; // This will be emitted as many times as necessary to add the; // full immediate.; // If the immediate ranges of these instructions are not large enough to cover; // NumBytes with a reasonable number of instructions, we fall back to using a; // value loaded from a constant pool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.cpp:144,Integrability,depend,depend,144,"// Strategy:; // We need to select two types of instruction, maximizing the available; // immediate range of each. The instructions we use will depend on whether; // DestReg and BaseReg are low, high or the stack pointer.; // * CopyOpc - DestReg = BaseReg + imm; // This will be emitted once if DestReg != BaseReg, and never if; // DestReg == BaseReg.; // * ExtraOpc - DestReg = DestReg + imm; // This will be emitted as many times as necessary to add the; // full immediate.; // If the immediate ranges of these instructions are not large enough to cover; // NumBytes with a reasonable number of instructions, we fall back to using a; // value loaded from a constant pool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.cpp:645,Performance,load,loaded,645,"// Strategy:; // We need to select two types of instruction, maximizing the available; // immediate range of each. The instructions we use will depend on whether; // DestReg and BaseReg are low, high or the stack pointer.; // * CopyOpc - DestReg = BaseReg + imm; // This will be emitted once if DestReg != BaseReg, and never if; // DestReg == BaseReg.; // * ExtraOpc - DestReg = DestReg + imm; // This will be emitted as many times as necessary to add the; // full immediate.; // If the immediate ranges of these instructions are not large enough to cover; // NumBytes with a reasonable number of instructions, we fall back to using a; // value loaded from a constant pool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.cpp:44,Availability,avail,available,44,// We need an extra instruction but none is available,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.cpp:92,Usability,simpl,simplify,92,"// The offset doesn't fit, but we may be able to put some of the offset into; // the ldr to simplify the generation of the rest of it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.cpp:200,Security,access,access,200,// PEI::scavengeFrameVirtualRegs() cannot accurately track SPAdj because the; // call frame setup/destroy instructions have already been eliminated. That; // means the stack pointer cannot be used to access the emergency spill slot; // when !hasReservedCallFrame().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.cpp:91,Performance,load,load,91,"// If FrameReg is a high register, add the reg values in a separate; // instruction as the load won't be able to access it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.cpp:113,Security,access,access,113,"// If FrameReg is a high register, add the reg values in a separate; // instruction as the load won't be able to access it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.cpp:91,Performance,load,load,91,"// If FrameReg is a high register, add the reg values in a separate; // instruction as the load won't be able to access it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.cpp:113,Security,access,access,113,"// If FrameReg is a high register, add the reg values in a separate; // instruction as the load won't be able to access it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.h:32,Performance,load,load,32,/// emitLoadConstPool - Emits a load from constpool to materialize the; /// specified immediate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.h:52,Deployability,Update,Update,52,// rewrite MI to access 'Offset' bytes from the FP. Update Offset to be; // however much remains to be handled. Return 'true' if no further; // work is required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.h:3,Modifiability,rewrite,rewrite,3,// rewrite MI to access 'Offset' bytes from the FP. Update Offset to be; // however much remains to be handled. Return 'true' if no further; // work is required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.h:17,Security,access,access,17,// rewrite MI to access 'Offset' bytes from the FP. Update Offset to be; // however much remains to be handled. Return 'true' if no further; // work is required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:206,Availability,Mask,Mask,206,"// Position==0 means we're not in an IT block at all. Position==1; // means we want the first state bit, which is always 0 (Then).; // Position==2 means we want the second state bit, stored at bit 3; // of Mask, and so on downwards. So (5 - Position) will shift the; // right bit down to bit 0, including the always-0 bit at bit 4 for; // the mandatory initial Then.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:222,Availability,down,downwards,222,"// Position==0 means we're not in an IT block at all. Position==1; // means we want the first state bit, which is always 0 (Then).; // Position==2 means we want the second state bit, stored at bit 3; // of Mask, and so on downwards. So (5 - Position) will shift the; // right bit down to bit 0, including the always-0 bit at bit 4 for; // the mandatory initial Then.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:280,Availability,down,down,280,"// Position==0 means we're not in an IT block at all. Position==1; // means we want the first state bit, which is always 0 (Then).; // Position==2 means we want the second state bit, stored at bit 3; // of Mask, and so on downwards. So (5 - Position) will shift the; // right bit down to bit 0, including the always-0 bit at bit 4 for; // the mandatory initial Then.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:13,Availability,mask,mask,13,"// Condition mask for instructions.; // Starting at first 1 (from lsb).; // '1' condition as indicated in IT.; // '0' inverse of condition (else).; // Count of instructions in IT block is; // 4 - trailingzeroes(mask); // Note that this does not have the same encoding; // as in the IT instruction, which also depends; // on the low bit of the condition code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:211,Availability,mask,mask,211,"// Condition mask for instructions.; // Starting at first 1 (from lsb).; // '1' condition as indicated in IT.; // '0' inverse of condition (else).; // Count of instructions in IT block is; // 4 - trailingzeroes(mask); // Note that this does not have the same encoding; // as in the IT instruction, which also depends; // on the low bit of the condition code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:309,Integrability,depend,depends,309,"// Condition mask for instructions.; // Starting at first 1 (from lsb).; // '1' condition as indicated in IT.; // '0' inverse of condition (else).; // Count of instructions in IT block is; // 4 - trailingzeroes(mask); // Note that this does not have the same encoding; // as in the IT instruction, which also depends; // on the low bit of the condition code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:148,Modifiability,extend,extend,148,"// true - The IT instruction was present in the; // input, we should not modify it.; // false - The IT instruction was added; // implicitly, we can extend it if that; // would be legal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:3,Usability,Clear,Clear,3,// Clear the IT state,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:3,Modifiability,Extend,Extend,3,// Extend the current implicit IT block to have one more slot with the given; // condition code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:23,Availability,down,down,23,// Move the trailing 1 down one bit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:63,Availability,mask,mask,63,"// Create a new explicit IT block with the given condition and mask.; // The mask should be in the format used in ARMOperand and; // MCOperand, with a 1 implying 'e', regardless of the low bit of; // the condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:77,Availability,mask,mask,77,"// Create a new explicit IT block with the given condition and mask.; // The mask should be in the format used in ARMOperand and; // MCOperand, with a 1 implying 'e', regardless of the low bit of; // the condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:3,Performance,Cache,Cache,3,// Cache the MCRegisterInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:25,Availability,avail,available,25,// Initialize the set of available features.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:43,Integrability,interface,interface,43,// Implementation of the MCTargetAsmParser interface:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:86,Modifiability,extend,extended,86,"// isImm0_4095Neg is used with 32-bit immediates only.; // 32-bit immediates are zero extended to 64-bit when parsed,; // thus simple -CE->getValue() results in a big negative number,; // not a small positive number as intended",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:127,Usability,simpl,simple,127,"// isImm0_4095Neg is used with 32-bit immediates only.; // 32-bit immediates are zero extended to 64-bit when parsed,; // thus simple -CE->getValue() results in a big negative number,; // not a small positive number as intended",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:14,Safety,avoid,avoid,14,// We want to avoid matching :upper16: and :lower16: as we want these; // expressions to match in isImm0_65535Expr(),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:31,Usability,simpl,simple,31,"// Thumb reg+reg addressing is simple. Just two registers, a base and; // an offset. No shifts, negations or any other complicating factors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:30,Integrability,depend,depending,30,"// And be in the right range, depending on the amount that it is shifted; // by. Shift 0, is equal to 7 unsigned bits, the sign bit is set; // separately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:39,Availability,mask,mask,39,// Munge the lsb/width into a bitfield mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:17,Availability,mask,mask,17,// Make a 32-bit mask w/ the referenced bits clear and all other bits set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:45,Usability,clear,clear,45,// Make a 32-bit mask w/ the referenced bits clear and all other bits set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:151,Availability,error,error-checked,151,"// When we come here, the VectorList field will identify a range; // of q-registers by its base register and length, and it will; // have already been error-checked to be the expected length of; // range and contain only q-regs in the range q0-q7. So we can; // count on the base register being in the range q0-q6 (for 2; // regs) or q0-q4 (for 4); //; // The MVE instructions taking a register range of this kind will; // need an operand in the MQQPR or MQQQQPR class, representing the; // entire range as a unit. So we must translate into that class,; // by finding the index of the base register in the MQPR reg; // class, and returning the super-register at the corresponding; // index in the target class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:72,Availability,Mask,Mask,72,// The immediate encodes the type of constant as well as the value.; // Mask in that this is an i8 splat.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:23,Availability,failure,failure,23,"// If no match, return failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:78,Availability,recover,recoverable,78,"// Try to parse a shifter (e.g., ""lsl <amt>""). On success, return 0.; // If a recoverable error occurs, return 1. If an irrecoverable error; // occurs, return -1. An irrecoverable error is one where tokens have been; // consumed in the process of trying to parse the shifter (i.e., when it is; // indeed a shifter operand, but malformed).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:90,Availability,error,error,90,"// Try to parse a shifter (e.g., ""lsl <amt>""). On success, return 0.; // If a recoverable error occurs, return 1. If an irrecoverable error; // occurs, return -1. An irrecoverable error is one where tokens have been; // consumed in the process of trying to parse the shifter (i.e., when it is; // indeed a shifter operand, but malformed).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:134,Availability,error,error,134,"// Try to parse a shifter (e.g., ""lsl <amt>""). On success, return 0.; // If a recoverable error occurs, return 1. If an irrecoverable error; // occurs, return -1. An irrecoverable error is one where tokens have been; // consumed in the process of trying to parse the shifter (i.e., when it is; // indeed a shifter operand, but malformed).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:180,Availability,error,error,180,"// Try to parse a shifter (e.g., ""lsl <amt>""). On success, return 0.; // If a recoverable error occurs, return 1. If an irrecoverable error; // occurs, return -1. An irrecoverable error is one where tokens have been; // consumed in the process of trying to parse the shifter (i.e., when it is; // indeed a shifter operand, but malformed).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:78,Safety,recover,recoverable,78,"// Try to parse a shifter (e.g., ""lsl <amt>""). On success, return 0.; // If a recoverable error occurs, return 1. If an irrecoverable error; // occurs, return -1. An irrecoverable error is one where tokens have been; // consumed in the process of trying to parse the shifter (i.e., when it is; // indeed a shifter operand, but malformed).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:7,Security,hash,hash,7,// Eat hash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:83,Energy Efficiency,efficient,efficient,83,"// Use the same layout as the tablegen'erated register name matcher. Ugly,; // but efficient.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:39,Availability,avail,available,39,"// ishld, oshld, nshld and ld are only available from ARMv8.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:39,Availability,mask,mask,39,/// parseMSRMaskOperand - Try to parse mask flags from MSR instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:34,Availability,mask,mask,34,"// FlagsVal contains the complete mask:; // 3-0: Mask; // 4: Special Reg (cpsr, apsr => 0; spsr => 1)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:49,Availability,Mask,Mask,49,"// FlagsVal contains the complete mask:; // 3-0: Mask; // 4: Special Reg (cpsr, apsr => 0; spsr => 1)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:7,Security,hash,hash,7,// Eat hash token.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:7,Security,hash,hash,7,// Eat hash token.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:63,Usability,UX,UXTB,63,"/// parseRotImm - Parse the shifter immediate operand for SXTB/UXTB family; /// of instructions. Legal values are:; /// ror #n 'n' in {0, 8, 16, 24}",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:7,Security,hash,hash,7,// Eat hash token.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:48,Usability,undo,undocumented,48,"// Shift amount must be in {0, 8, 16, 24} (0 is undocumented extension); // normally, zero is represented in asm by omitting the rotate operand; // entirely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:3,Security,Hash,Hash,3,// Hash (dollar) is optional as per the ARMARM,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:3,Safety,Avoid,Avoid,3,// Avoid parsing into complex operands (#:),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:11,Security,hash,hash,11,// Eat the hash (dollar),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:20,Security,hash,hash,20,// Eat the optional hash (dollar),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:7,Security,hash,hash,7,// Eat hash token.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:7,Security,hash,hash,7,// Eat hash token.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:7,Security,hash,hash,7,// Eat hash token.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:91,Availability,error,error,91,"/// Parse an ARM memory expression, return false if successful else return true; /// or an error. The first token must be a '[' when called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:175,Security,hash,hash,175,"// If we have a '#' or '$', it's an immediate offset, else assume it's a; // register offset. Be friendly and also accept a plain integer or expression; // (without a leading hash) for gas compatibility.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:7,Security,hash,hash,7,// Eat hash token.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:163,Integrability,rout,routine,163,"// Anything that can accept a floating point constant as an operand; // needs to go through here, as the regular parseExpression is; // integer only.; //; // This routine still creates a generic Immediate operand, containing; // a bitcast of the 64-bit floating point value. The various operands; // that accept floats can check whether the value is valid for them; // via the standard is*() predicates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:29,Deployability,toggle,toggle,29,"// If we had a '-' in front, toggle the sign bit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:107,Availability,error,error,107,"// If there wasn't a custom match, try the generic matcher below. Otherwise,; // there was a match, but an error occurred, in which case, just return that; // the operand parsing failed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:17,Availability,error,error,17,// irrecoverable error,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:42,Availability,mask,mask,42,"// The ""it"" instruction has the condition mask on the end of the mnemonic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:67,Availability,avail,available,67,"// Some Thumb instructions have two operand forms that are not; // available as three operand, convert to two operand form if possible.; //; // FIXME: We would really like to be able to tablegen'erate this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:65,Energy Efficiency,reduce,reduce,65,"// For most Thumb2 cases we just generate the 3 operand form and reduce; // it in processInstruction(), but the 3 operand form of ADD (t2ADDrr); // won't accept SP or PC so we do the transformation here taking care; // with immediate range in the 'add sp, sp #imm' case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:101,Availability,error,errors,101,"// We check the larger class QPR instead of just the legal class; // MQPR, to more accurately report errors when using Q registers; // outside of the allowed range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:445,Availability,error,error,445,"// The GNU assembler has aliases of ldrd and strd with the second register; // omitted. We don't have a way to do that in tablegen, so fix it up here.; //; // We have to be careful to not emit an invalid Rt2 here, because the rest of; // the assembly parser could then generate confusing diagnostics refering to; // it. If we do find anything that prevents us from doing the transformation we; // bail out, and let the assembly parser report an error on the instruction as; // it is written.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:248,Availability,error,error,248,"// Dual-register instruction have the following syntax:; // <mnemonic> <predicate>? <coproc>, <Rdest>, <Rdest+1>, <Rsrc>, ..., #imm; // This function tries to remove <Rdest+1> and replace <Rdest> with a pair; // operand. If the conversion fails an error is diagnosed, and the function; // returns true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:21,Availability,error,error,21,"// We always return 'error' for this, as we're done with this; // statement and don't need to match the 'instruction.""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:14,Availability,mask,mask,14,"// Handle the mask for IT and VPT instructions. In ARMOperand and; // MCOperand, this is stored in a format independent of the; // condition code: the lowest set bit indicates the end of the; // encoding, and above that, a 1 bit indicates 'else', and an 0; // indicates 'then'. E.g.; // IT -> 1000; // ITx -> x100 (ITT -> 0100, ITE -> 1100); // ITxy -> xy10 (e.g. ITET -> 1010); // ITxyz -> xyz1 (e.g. ITEET -> 1101); // Note: See the ARM::PredBlockMask enum in; // /lib/Target/ARM/Utils/ARMBaseInfo.h",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:501,Availability,error,error,501,"// FIXME: This is all a pretty gross hack. We should automatically handle; // optional operands like this via tblgen.; // Next, add the CCOut and ConditionCode operands, if needed.; //; // For mnemonics which can ever incorporate a carry setting bit or predication; // code, our matching model involves us always generating CCOut and; // ConditionCode operands to match the mnemonic ""as written"" and then we let; // the matcher deal with finding the right instruction or generating an; // appropriate error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:76,Availability,error,error,76,"// If we had a carry-set on an instruction that can't do that, issue an; // error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:83,Availability,error,error,83,"// If we had a predication code on an instruction that can't do that, issue an; // error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:87,Availability,error,error,87,"// If we had a VPT predication code on an instruction that can't do that, issue an; // error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:32,Availability,error,error,32,// For for ARM mode generate an error if the .n qualifier is used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:162,Availability,error,errors,162,"// The .n qualifier is always discarded as that is what the tables; // and matcher expect. In ARM mode the .w qualifier has no effect,; // so discard it to avoid errors that can be caused by the matcher.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:156,Safety,avoid,avoid,156,"// The .n qualifier is always discarded as that is what the tables; // and matcher expect. In ARM mode the .w qualifier has no effect,; // so discard it to avoid errors that can be caused by the matcher.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:312,Availability,error,error,312,"// Dual-register instructions use even-odd register pairs as their; // destination operand, in assembly such pair is spelled as two; // consecutive registers, without any special syntax. ConvertDualRegOperand; // tries to convert such operand into register pair, e.g. r2, r3 -> r2_r3.; // It returns true, if an error message has been emitted. If the function; // returns false, the function either succeeded or an error (e.g. missing; // operand) will be diagnosed elsewhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:415,Availability,error,error,415,"// Dual-register instructions use even-odd register pairs as their; // destination operand, in assembly such pair is spelled as two; // consecutive registers, without any special syntax. ConvertDualRegOperand; // tries to convert such operand into register pair, e.g. r2, r3 -> r2_r3.; // It returns true, if an error message has been emitted. If the function; // returns false, the function either succeeded or an error (e.g. missing; // operand) will be diagnosed elsewhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:318,Integrability,message,message,318,"// Dual-register instructions use even-odd register pairs as their; // destination operand, in assembly such pair is spelled as two; // consecutive registers, without any special syntax. ConvertDualRegOperand; // tries to convert such operand into register pair, e.g. r2, r3 -> r2_r3.; // It returns true, if an error message has been emitted. If the function; // returns false, the function either succeeded or an error (e.g. missing; // operand) will be diagnosed elsewhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:102,Integrability,depend,depending,102,"// For all other instructions, make sure only one of the two; // predication operands is left behind, depending on whether we should; // use the vector predication.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:3,Security,Validat,Validate,3,"// Validate context-sensitive operand constraints.; // return 'true' if register list contains non-low GPR registers,; // 'false' otherwise. If Reg is in the register list or is HiReg, set; // 'containsReg' to true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:165,Availability,mask,mask,165,"// Encoding is unpredictable if it ever results in a notional 'NV'; // predicate. Since we don't parse 'NV' directly this means an 'AL'; // predicate with an ""else"" mask bit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:152,Energy Efficiency,power,powers,152,"// Conditions only allowing a 't' are those with no set bit except; // the lowest-order one that indicates the end of the sequence. In; // other words, powers of 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:2,Performance,Load,Load,2,/*Load*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:2,Performance,Load,Load,2,/*Load*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:2,Performance,Load,Load,2,/*Load*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:2,Performance,Load,Load,2,/*Load*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:2,Performance,Load,Load,2,/*Load*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:2,Performance,Load,Load,2,/*Load*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:2,Performance,Load,Load,2,/*Load*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:46,Availability,avail,available,46,"// If we're parsing Thumb2, the .w variant is available and handles; // most cases that are normally illegal for a Thumb1 LDM instruction.; // We'll make the transformation in processInstruction() if necessary.; //; // Thumb LDM instructions are writeback iff the base register is not; // in the register list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:16,Performance,load,loading,16,// ARM variants loading and updating the same register are only officially; // UNPREDICTABLE on v7 upwards. Goodness knows what they did before.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:136,Availability,error,error,136,"// If the non-SP source operand and the destination operand are not the; // same, we need thumb2 (for the wide encoding), or we have an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:14,Safety,avoid,avoid,14,"// We want to avoid misleadingly allowing something like ""mov r0, <symbol>""; // especially when we turn it into a movw and the expression <symbol> does; // not have a :lower16: or :upper16 as part of the expression. We don't; // want the behavior of silently truncating, which can be unexpected and; // lead to bugs that are difficult to find since this is an easy mistake; // to make.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:76,Safety,avoid,avoid,76,"// Check if we have the wide qualifier, because if it's present we; // must avoid selecting a 16-bit thumb instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:175,Performance,load,load,175,"// Pseudo instruction ldr rt, =immediate is converted to a; // MOV rt, immediate if immediate is known and representable; // otherwise we create a constant pool entry that we load from.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:34,Integrability,depend,depends,34,// Which instruction to expand to depends on the CCOut operand and; // whether we're in an IT block if the register operands are low; // registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:34,Integrability,depend,depends,34,// Which instruction to expand to depends on the CCOut operand and; // whether we're in an IT block if the register operands are low; // registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:16,Performance,load,load,16,"// If this is a load of a single register, then we should use; // a post-indexed LDR instruction instead, per the ARM ARM.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:16,Performance,load,load,16,"// If this is a load of a single register via a 'pop', then we should use; // a post-indexed LDR instruction instead, per the ARM ARM.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:125,Availability,avail,available,125,"// If the non-SP source operand and the destination operand are not the; // same, we need to use the 32-bit encoding if it's available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:223,Availability,error,error,223,"// If the register list contains any high registers, or if the writeback; // doesn't match what tLDMIA can do, we need to use the 32-bit encoding; // instead if we're in Thumb2. Otherwise, this should have generated; // an error in validateInstruction().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:232,Security,validat,validateInstruction,232,"// If the register list contains any high registers, or if the writeback; // doesn't match what tLDMIA can do, we need to use the 32-bit encoding; // instead if we're in Thumb2. Otherwise, this should have generated; // an error in validateInstruction().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:165,Availability,error,error,165,"// If the register list contains any high registers, we need to use; // the 32-bit encoding instead if we're in Thumb2. Otherwise, this; // should have generated an error in validateInstruction().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:174,Security,validat,validateInstruction,174,"// If the register list contains any high registers, we need to use; // the 32-bit encoding instead if we're in Thumb2. Otherwise, this; // should have generated an error in validateInstruction().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:165,Availability,error,error,165,"// If the register list contains any high registers, we need to use; // the 32-bit encoding instead if we're in Thumb2. Otherwise, this; // should have generated an error in validateInstruction().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:174,Security,validat,validateInstruction,174,"// If the register list contains any high registers, we need to use; // the 32-bit encoding instead if we're in Thumb2. Otherwise, this; // should have generated an error in validateInstruction().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:179,Availability,avail,available,179,"// Assemblers should use the narrow encodings of these instructions when permissible.; // These instructions are special in that they are commutable, so shorter encodings; // are available more often.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:86,Integrability,depend,depending,86,// 16-bit thumb arithmetic instructions either require or preclude the 'S'; // suffix depending on whether they're in an IT block or not.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:48,Integrability,depend,depends,48,"// If we're parsing Thumb2, which form is legal depends on whether we're; // in an IT block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:183,Deployability,update,updated,183,"// This can happen in awkward cases with tied operands, e.g. a; // writeback load/store with a complex addressing mode in; // which there's an output operand corresponding to the; // updated written-back base register: the Tablegen-generated; // AsmMatcher will have written a placeholder operand to that; // slot in the form of an immediate 0, because it can't; // generate the register part of the complex addressing-mode; // operand ahead of time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:77,Performance,load,load,77,"// This can happen in awkward cases with tied operands, e.g. a; // writeback load/store with a complex addressing mode in; // which there's an output operand corresponding to the; // updated written-back base register: the Tablegen-generated; // AsmMatcher will have written a placeholder operand to that; // slot in the form of an immediate 0, because it can't; // generate the register part of the complex addressing-mode; // operand ahead of time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:40,Availability,error,error,40,"// If none of these succeed, return the error we got when trying to match; // outside any IT blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:89,Availability,error,errors,89,"// Still progress the IT block, otherwise one wrong condition causes; // nasty cascading errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:59,Security,validat,validate,59,// Only move forward at the very end so that everything in validate; // and process gets a consistent answer about whether we're in an IT; // block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:18,Availability,failure,failure,18,// Use Generic on failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:123,Availability,error,error,123,"// Warn about the implcit mode switch. GAS does not switch modes here,; // but instead stays in the old mode, reporting an error on any following; // instructions as the mode does not exist on the target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:37,Integrability,rout,routine,37,// Parse the name of the personality routine,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:3,Deployability,Update,Update,3,// Update the frame pointer register,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:8,Security,hash,hash,8,// skip hash token.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:8,Security,hash,hash,8,// skip hash token.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:54,Modifiability,variab,variable,54,/// parseDirectiveTLSDescSeq; /// ::= .tlsdescseq tls-variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:171,Availability,avail,available,171,"// Some diagnostics need to vary with subtarget features, so they are handled; // here. For example, the DPR class has either 16 or 32 registers, depending; // on the FPU available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:146,Integrability,depend,depending,146,"// Some diagnostics need to vary with subtarget features, so they are handled; // here. For example, the DPR class has either 16 or 32 registers, depending; // on the FPU available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:218,Availability,redundant,redundant,218,"// TODO: If operand didn't match, sub in a dummy one and run target; // predicate, so that we can avoid reporting near-misses that are invalid?; // TODO: Many operand types dont have SuperClasses set, so we report; // redundant ones.; // TODO: Some operands are superclasses of registers (e.g.; // MCK_RegShiftedImm), we don't have any way to represent that currently.; // TODO: This is not all ARM-specific, can some of it be factored out?; // Record some information about near-misses that we have already seen, so; // that we can avoid reporting redundant ones. For example, if there are; // variants of an instruction that take 8- and 16-bit immediates, we want; // to only report the widest one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:549,Availability,redundant,redundant,549,"// TODO: If operand didn't match, sub in a dummy one and run target; // predicate, so that we can avoid reporting near-misses that are invalid?; // TODO: Many operand types dont have SuperClasses set, so we report; // redundant ones.; // TODO: Some operands are superclasses of registers (e.g.; // MCK_RegShiftedImm), we don't have any way to represent that currently.; // TODO: This is not all ARM-specific, can some of it be factored out?; // Record some information about near-misses that we have already seen, so; // that we can avoid reporting redundant ones. For example, if there are; // variants of an instruction that take 8- and 16-bit immediates, we want; // to only report the widest one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:98,Safety,avoid,avoid,98,"// TODO: If operand didn't match, sub in a dummy one and run target; // predicate, so that we can avoid reporting near-misses that are invalid?; // TODO: Many operand types dont have SuperClasses set, so we report; // redundant ones.; // TODO: Some operands are superclasses of registers (e.g.; // MCK_RegShiftedImm), we don't have any way to represent that currently.; // TODO: This is not all ARM-specific, can some of it be factored out?; // Record some information about near-misses that we have already seen, so; // that we can avoid reporting redundant ones. For example, if there are; // variants of an instruction that take 8- and 16-bit immediates, we want; // to only report the widest one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:218,Safety,redund,redundant,218,"// TODO: If operand didn't match, sub in a dummy one and run target; // predicate, so that we can avoid reporting near-misses that are invalid?; // TODO: Many operand types dont have SuperClasses set, so we report; // redundant ones.; // TODO: Some operands are superclasses of registers (e.g.; // MCK_RegShiftedImm), we don't have any way to represent that currently.; // TODO: This is not all ARM-specific, can some of it be factored out?; // Record some information about near-misses that we have already seen, so; // that we can avoid reporting redundant ones. For example, if there are; // variants of an instruction that take 8- and 16-bit immediates, we want; // to only report the widest one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:533,Safety,avoid,avoid,533,"// TODO: If operand didn't match, sub in a dummy one and run target; // predicate, so that we can avoid reporting near-misses that are invalid?; // TODO: Many operand types dont have SuperClasses set, so we report; // redundant ones.; // TODO: Some operands are superclasses of registers (e.g.; // MCK_RegShiftedImm), we don't have any way to represent that currently.; // TODO: This is not all ARM-specific, can some of it be factored out?; // Record some information about near-misses that we have already seen, so; // that we can avoid reporting redundant ones. For example, if there are; // variants of an instruction that take 8- and 16-bit immediates, we want; // to only report the widest one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:549,Safety,redund,redundant,549,"// TODO: If operand didn't match, sub in a dummy one and run target; // predicate, so that we can avoid reporting near-misses that are invalid?; // TODO: Many operand types dont have SuperClasses set, so we report; // redundant ones.; // TODO: Some operands are superclasses of registers (e.g.; // MCK_RegShiftedImm), we don't have any way to represent that currently.; // TODO: This is not all ARM-specific, can some of it be factored out?; // Record some information about near-misses that we have already seen, so; // that we can avoid reporting redundant ones. For example, if there are; // variants of an instruction that take 8- and 16-bit immediates, we want; // to only report the widest one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:100,Safety,avoid,avoid,100,"// Process the near-misses in reverse order, so that we see more general ones; // first, and so can avoid emitting more specific ones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:262,Availability,error,error,262,"// If we have already emitted a message for a superclass, don't also report; // the sub-class. We consider all operand classes that we don't have a; // specialised diagnostic for to be equal for the propose of this check,; // so that we don't report the generic error multiple times on the same; // operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:32,Integrability,message,message,32,"// If we have already emitted a message for a superclass, don't also report; // the sub-class. We consider all operand classes that we don't have a; // specialised diagnostic for to be equal for the propose of this check,; // so that we don't report the generic error multiple times on the same; // operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:50,Availability,error,error,50,"// One near miss was found, report it as the sole error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:74,Availability,error,error,74,"// More than one near miss, so report a generic ""invalid instruction""; // error, followed by notes for each of the near-misses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:15,Availability,avail,available,15,"// FIXME: Only available in A-class, isel not predicated",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:190,Availability,Mask,Mask,190,// Called when decoding an IT instruction. Sets the IT state for; // the following instructions that for the IT block. Firstcond; // corresponds to the field in the IT instruction encoding; Mask; // is in the MCOperand format in which 1 means 'else' and 0 'then'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:133,Availability,down,down,133,// end anonymous namespace; // Forward declare these because the autogenerated code will reference them.; // Definitions are further down.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:481,Availability,avail,available,481,"// In a Thumb instruction stream, a halfword is a standalone 2-byte; // instruction if and only if its value is less than 0xE800.; // Otherwise, it's the first halfword of a 4-byte instruction.; //; // So, if we can see the upcoming halfword, we can judge on that; // basis, and maybe skip a whole 4-byte instruction that we don't; // know how to decode, without accidentally trying to interpret its; // second half as something else.; //; // If we don't have the instruction data available, we just have to; // recommend skipping the minimum sensible distance, which is 2; // bytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:101,Performance,load,load,101,/// tryAddingPcLoadReferenceComment - trys to add a comment as to what is being; /// referenced by a load instruction with the base register that is the Pc.; /// These can often be values in a literal pool near the Address of the; /// instruction. The Address of the instruction and its immediate Value are; /// used as a possible literal pool entry. The SymbolLookUp call back will; /// return the name of a symbol referenced by the literal pool's entry if; /// the referenced address is that of a symbol. Or it will return a pointer to; /// a literal 'C' string if the referenced address of the literal pool's entry; /// is an address into a section with 'C' string literals.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:170,Integrability,inject,inject,170,"// Thumb1 instructions don't have explicit S bits. Rather, they; // implicitly set CPSR. Since it's not represented in the encoding, the; // auto-generated decoder won't inject the CPSR operand. We need to fix; // that as a post-pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:170,Security,inject,inject,170,"// Thumb1 instructions don't have explicit S bits. Rather, they; // implicitly set CPSR. Since it's not represented in the encoding, the; // auto-generated decoder won't inject the CPSR operand. We need to fix; // that as a post-pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:244,Modifiability,rewrite,rewrite,244,"// Thumb VFP instructions are a special case. Because we share their; // encodings between ARM and Thumb modes, and they are predicable in ARM; // mode, the auto-generated decoder will give them an (incorrect); // predicate operand. We need to rewrite these operands based on the IT; // context as a post-pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:77,Availability,mask,mask,77,"// If we find an IT instruction, we need to parse its condition; // code and mask operands so that we can apply them correctly; // to the subsequent instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:3,Usability,Clear,Clear,3,// Clear bits 27-24,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:3,Usability,Clear,Clear,3,// Clear bits 27-24,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:3,Usability,Clear,Clear,3,// Clear bits 27-26,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:26,Availability,mask,mask,26,"// This operand encodes a mask of contiguous zeros between a specified MSB; // and LSB. To decode it, we create the mask of all bits MSB-and-lower,; // the mask of all bits LSB-and-lower, and then xor them to create; // the mask of that's all ones on [msb, lsb]. Finally we not it to; // create the final mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:116,Availability,mask,mask,116,"// This operand encodes a mask of contiguous zeros between a specified MSB; // and LSB. To decode it, we create the mask of all bits MSB-and-lower,; // the mask of all bits LSB-and-lower, and then xor them to create; // the mask of that's all ones on [msb, lsb]. Finally we not it to; // create the final mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:156,Availability,mask,mask,156,"// This operand encodes a mask of contiguous zeros between a specified MSB; // and LSB. To decode it, we create the mask of all bits MSB-and-lower,; // the mask of all bits LSB-and-lower, and then xor them to create; // the mask of that's all ones on [msb, lsb]. Finally we not it to; // create the final mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:224,Availability,mask,mask,224,"// This operand encodes a mask of contiguous zeros between a specified MSB; // and LSB. To decode it, we create the mask of all bits MSB-and-lower,; // the mask of all bits LSB-and-lower, and then xor them to create; // the mask of that's all ones on [msb, lsb]. Finally we not it to; // create the final mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:305,Availability,mask,mask,305,"// This operand encodes a mask of contiguous zeros between a specified MSB; // and LSB. To decode it, we create the mask of all bits MSB-and-lower,; // the mask of all bits LSB-and-lower, and then xor them to create; // the mask of that's all ones on [msb, lsb]. Finally we not it to; // create the final mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:6,Performance,load,loads,6,"// On loads, the writeback operand comes after Rt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:90,Availability,avail,available,90,"// The ""csync"" operand is not encoded into the ""tsb"" instruction (as this is; // the only available operand), but LLVM expects the instruction to have one; // operand, so we need to add the csync when decoding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:6,Performance,load,loads,6,"// On loads, the writeback operand comes after Rt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:115,Availability,failure,failure,115,"// imod == '01' --> UNPREDICTABLE; // NOTE: Even though this is technically UNPREDICTABLE, we choose to; // return failure here. The '01' imod value is unprintable, so there's; // nothing useful we could do even if we returned UNPREDICTABLE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:115,Availability,failure,failure,115,"// imod == '01' --> UNPREDICTABLE; // NOTE: Even though this is technically UNPREDICTABLE, we choose to; // return failure here. The '01' imod value is unprintable, so there's; // nothing useful we could do even if we returned UNPREDICTABLE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:23,Deployability,update,updated,23,"// The below have been updated to have explicit am6offset split; // between fixed and register offset. For those instructions not; // yet updated, we need to add an additional reg0 operand for the; // fixed variant.; //; // The fixed offset encodes as Rm == 0xd, so we check for that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:138,Deployability,update,updated,138,"// The below have been updated to have explicit am6offset split; // between fixed and register offset. For those instructions not; // yet updated, we need to add an additional reg0 operand for the; // fixed variant.; //; // The fixed offset encodes as Rm == 0xd, so we check for that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:9,Usability,clear,clear,9,// I bit clear => need input FPSCR,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:3,Security,Validat,Validate,3,// Validate the SYSm value first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:3,Availability,fault,faultmask,3,// faultmask,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:35,Availability,fault,faultmask,35,"// Values basepri, basepri_max and faultmask are only valid for v7m.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:55,Availability,mask,mask,55,"// The ARMv7-M architecture stores an additional 2-bit mask value in; // MSR bits {11-10}. The mask is used only with apsr, iapsr, eapsr and; // xpsr, it has to be 0b10 in other cases. Bit mask{1} indicates if; // the NZCVQ bits should be moved by the instruction. Bit mask{0}; // indicates the move for the GE{3:0} bits, the mask{0} bit can be set; // only if the processor includes the DSP extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:95,Availability,mask,mask,95,"// The ARMv7-M architecture stores an additional 2-bit mask value in; // MSR bits {11-10}. The mask is used only with apsr, iapsr, eapsr and; // xpsr, it has to be 0b10 in other cases. Bit mask{1} indicates if; // the NZCVQ bits should be moved by the instruction. Bit mask{0}; // indicates the move for the GE{3:0} bits, the mask{0} bit can be set; // only if the processor includes the DSP extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:189,Availability,mask,mask,189,"// The ARMv7-M architecture stores an additional 2-bit mask value in; // MSR bits {11-10}. The mask is used only with apsr, iapsr, eapsr and; // xpsr, it has to be 0b10 in other cases. Bit mask{1} indicates if; // the NZCVQ bits should be moved by the instruction. Bit mask{0}; // indicates the move for the GE{3:0} bits, the mask{0} bit can be set; // only if the processor includes the DSP extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:269,Availability,mask,mask,269,"// The ARMv7-M architecture stores an additional 2-bit mask value in; // MSR bits {11-10}. The mask is used only with apsr, iapsr, eapsr and; // xpsr, it has to be 0b10 in other cases. Bit mask{1} indicates if; // the NZCVQ bits should be moved by the instruction. Bit mask{0}; // indicates the move for the GE{3:0} bits, the mask{0} bit can be set; // only if the processor includes the DSP extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:326,Availability,mask,mask,326,"// The ARMv7-M architecture stores an additional 2-bit mask value in; // MSR bits {11-10}. The mask is used only with apsr, iapsr, eapsr and; // xpsr, it has to be 0b10 in other cases. Bit mask{1} indicates if; // the NZCVQ bits should be moved by the instruction. Bit mask{0}; // indicates the move for the GE{3:0} bits, the mask{0} bit can be set; // only if the processor includes the DSP extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:151,Testability,log,logic,151,"// The table of encodings for these banked registers comes from B9.2.3 of the; // ARM ARM. There are patterns, but nothing regular enough to make this logic; // neater. So by fiat, these values are UNPREDICTABLE:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:6,Availability,mask,masks,6,"// IT masks are encoded as a sequence of replacement low-order bits; // for the condition code. So if the low bit of the starting; // condition code is 1, then we have to flip all the bits above the; // terminating bit (which is the lowest 1 bit).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:32,Usability,clear,clear,32,"// If the top 3 bits of imm are clear, this is a VMOV (immediate)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:32,Usability,clear,clear,32,"// If the top 3 bits of imm are clear, this is a VMOV (immediate)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:83,Availability,reliab,reliably,83,"// Enforce all the rest of the instruction bits in LCTP, which; // won't have been reliably checked based on LCTP's own tablegen; // record, because we came to this decode by a roundabout route.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:188,Integrability,rout,route,188,"// Enforce all the rest of the instruction bits in LCTP, which; // won't have been reliably checked based on LCTP's own tablegen; // record, because we came to this decode by a roundabout route.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:13,Availability,mask,mask,13,"// Parse VPT mask and encode it in the MCInst as an immediate with the same; // format as the it_mask. That is, from the second 'e|t' encode 'e' as 1 and; // 't' as 0 and finish with a 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h:3,Availability,Mask,Mask,3,// Mask out the first hunk.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h:144,Performance,optimiz,optimized,144,"/// isSOImmTwoPartValNeg - Return true if the specified value can be obtained; /// by two SOImmVal, that -V = First + Second.; /// ""R+V"" can be optimized to (sub (sub R, First), Second).; /// ""R=V"" can be optimized to (sub (mvn R, ~(-First)), Second).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h:205,Performance,optimiz,optimized,205,"/// isSOImmTwoPartValNeg - Return true if the specified value can be obtained; /// by two SOImmVal, that -V = First + Second.; /// ""R+V"" can be optimized to (sub (sub R, First), Second).; /// ""R=V"" can be optimized to (sub (mvn R, ~(-First)), Second).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h:17,Availability,mask,masking,17,"// Likewise, try masking out a splat value first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h:7,Availability,mask,masking,7,// Try masking out a splat value first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h:3,Availability,Mask,Mask,3,// Mask out the first hunk,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h:219,Performance,load,load,219,"//===--------------------------------------------------------------------===//; // Addressing Mode #2; //===--------------------------------------------------------------------===//; //; // This is used for most simple load/store instructions.; //; // addrmode2 := reg +/- reg shop imm; // addrmode2 := reg +/- imm12; //; // The first operand is always a Reg. The second operand is a reg if in; // reg/reg form, otherwise it's reg#0. The third field encodes the operation; // in bit 12, the immediate in bits 0-11, and the shift op in 13-15. The; // fourth operand 16-17 encodes the index mode.; //; // If this addressing mode is a frame index (before prolog/epilog insertion; // and code rewriting), this operand will have the form: FI#, reg0, <offs>; // with no shift amount for the frame offset.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h:212,Usability,simpl,simple,212,"//===--------------------------------------------------------------------===//; // Addressing Mode #2; //===--------------------------------------------------------------------===//; //; // This is used for most simple load/store instructions.; //; // addrmode2 := reg +/- reg shop imm; // addrmode2 := reg +/- imm12; //; // The first operand is always a Reg. The second operand is a reg if in; // reg/reg form, otherwise it's reg#0. The third field encodes the operation; // in bit 12, the immediate in bits 0-11, and the shift op in 13-15. The; // fourth operand 16-17 encodes the index mode.; //; // If this addressing mode is a frame index (before prolog/epilog insertion; // and code rewriting), this operand will have the form: FI#, reg0, <offs>; // with no shift amount for the frame offset.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h:212,Modifiability,extend,extending,212,"//===--------------------------------------------------------------------===//; // Addressing Mode #3; //===--------------------------------------------------------------------===//; //; // This is used for sign-extending loads, and load/store-pair instructions.; //; // addrmode3 := reg +/- reg; // addrmode3 := reg +/- imm8; //; // The first operand is always a Reg. The second operand is a reg if in; // reg/reg form, otherwise it's reg#0. The third field encodes the operation; // in bit 8, the immediate in bits 0-7. The fourth operand 9-10 encodes the; // index mode.; /// getAM3Opc - This function encodes the addrmode3 opc field.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h:222,Performance,load,loads,222,"//===--------------------------------------------------------------------===//; // Addressing Mode #3; //===--------------------------------------------------------------------===//; //; // This is used for sign-extending loads, and load/store-pair instructions.; //; // addrmode3 := reg +/- reg; // addrmode3 := reg +/- imm8; //; // The first operand is always a Reg. The second operand is a reg if in; // reg/reg form, otherwise it's reg#0. The third field encodes the operation; // in bit 8, the immediate in bits 0-7. The fourth operand 9-10 encodes the; // index mode.; /// getAM3Opc - This function encodes the addrmode3 opc field.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h:233,Performance,load,load,233,"//===--------------------------------------------------------------------===//; // Addressing Mode #3; //===--------------------------------------------------------------------===//; //; // This is used for sign-extending loads, and load/store-pair instructions.; //; // addrmode3 := reg +/- reg; // addrmode3 := reg +/- imm8; //; // The first operand is always a Reg. The second operand is a reg if in; // reg/reg form, otherwise it's reg#0. The third field encodes the operation; // in bit 8, the immediate in bits 0-7. The fourth operand 9-10 encodes the; // index mode.; /// getAM3Opc - This function encodes the addrmode3 opc field.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h:207,Performance,load,load,207,"//===--------------------------------------------------------------------===//; // Addressing Mode #4; //===--------------------------------------------------------------------===//; //; // This is used for load / store multiple instructions.; //; // addrmode4 := reg, <mode>; //; // The four modes are:; // IA - Increment after; // IB - Increment before; // DA - Decrement after; // DB - Decrement before; // For VFP instructions, only the IA and DB modes are valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h:244,Performance,load,load,244,"//===--------------------------------------------------------------------===//; // Addressing Mode #5; //===--------------------------------------------------------------------===//; //; // This is used for coprocessor instructions, such as FP load/stores.; //; // addrmode5 := reg +/- imm8*4; //; // The first operand is always a Reg. The second operand encodes the; // operation (add or subtract) in bit 8 and the immediate in bits 0-7.; /// getAM5Opc - This function encodes the addrmode5 opc field.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h:256,Performance,load,load,256,"//===--------------------------------------------------------------------===//; // Addressing Mode #5 FP16; //===--------------------------------------------------------------------===//; //; // This is used for coprocessor instructions, such as 16-bit FP load/stores.; //; // addrmode5fp16 := reg +/- imm8*2; //; // The first operand is always a Reg. The second operand encodes the; // operation (add or subtract) in bit 8 and the immediate in bits 0-7.; /// getAM5FP16Opc - This function encodes the addrmode5fp16 opc field.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h:511,Integrability,depend,depend,511,"//===--------------------------------------------------------------------===//; // Addressing Mode #6; //===--------------------------------------------------------------------===//; //; // This is used for NEON load / store instructions.; //; // addrmode6 := reg with optional alignment; //; // This is stored in two operands [regaddr, align]. The first is the; // address register. The second operand is the value of the alignment; // specifier in bytes or zero if no explicit alignment.; // Valid alignments depend on the specific instruction.; //===--------------------------------------------------------------------===//; // NEON/MVE Modified Immediates; //===--------------------------------------------------------------------===//; //; // Several NEON and MVE instructions (e.g., VMOV) take a ""modified immediate""; // vector operand, where a small immediate encoded in the instruction; // specifies a full NEON vector value. These modified immediates are; // represented here as encoded integers. The low 8 bits hold the immediate; // value; bit 12 holds the ""Op"" field of the instruction, and bits 11-8 hold; // the ""Cmode"" field of the instruction. The interfaces below treat the; // Op and Cmode values as a single 5-bit value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h:1164,Integrability,interface,interfaces,1164,"//===--------------------------------------------------------------------===//; // Addressing Mode #6; //===--------------------------------------------------------------------===//; //; // This is used for NEON load / store instructions.; //; // addrmode6 := reg with optional alignment; //; // This is stored in two operands [regaddr, align]. The first is the; // address register. The second operand is the value of the alignment; // specifier in bytes or zero if no explicit alignment.; // Valid alignments depend on the specific instruction.; //===--------------------------------------------------------------------===//; // NEON/MVE Modified Immediates; //===--------------------------------------------------------------------===//; //; // Several NEON and MVE instructions (e.g., VMOV) take a ""modified immediate""; // vector operand, where a small immediate encoded in the instruction; // specifies a full NEON vector value. These modified immediates are; // represented here as encoded integers. The low 8 bits hold the immediate; // value; bit 12 holds the ""Op"" field of the instruction, and bits 11-8 hold; // the ""Cmode"" field of the instruction. The interfaces below treat the; // Op and Cmode values as a single 5-bit value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h:212,Performance,load,load,212,"//===--------------------------------------------------------------------===//; // Addressing Mode #6; //===--------------------------------------------------------------------===//; //; // This is used for NEON load / store instructions.; //; // addrmode6 := reg with optional alignment; //; // This is stored in two operands [regaddr, align]. The first is the; // address register. The second operand is the value of the alignment; // specifier in bytes or zero if no explicit alignment.; // Valid alignments depend on the specific instruction.; //===--------------------------------------------------------------------===//; // NEON/MVE Modified Immediates; //===--------------------------------------------------------------------===//; //; // Several NEON and MVE instructions (e.g., VMOV) take a ""modified immediate""; // vector operand, where a small immediate encoded in the instruction; // specifies a full NEON vector value. These modified immediates are; // represented here as encoded integers. The low 8 bits hold the immediate; // value; bit 12 holds the ""Op"" field of the instruction, and bits 11-8 hold; // the ""Cmode"" field of the instruction. The interfaces below treat the; // Op and Cmode values as a single 5-bit value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h:11,Security,validat,validation,11,"// Generic validation for single-byte immediate (0X00, 00X0, etc).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAsmBackend.cpp:87,Deployability,update,update,87,// The rest of instructions we're relaxing have the same operands.; // We just need to update to the proper opcode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAsmBackend.cpp:95,Availability,error,error,95,"// On CPUs supporting Thumb2, this will be relaxed to an ldr.w, otherwise we; // could have an error on our hands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAsmBackend.cpp:221,Availability,error,error,221,"// If the symbol is external the linker will handle it.; // FIXME: Should we handle it as an optimization?; // If the symbol is out of range, produce a relocation and hope the; // linker can handle it. GNU AS produces an error in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAsmBackend.cpp:93,Performance,optimiz,optimization,93,"// If the symbol is external the linker will handle it.; // FIXME: Should we handle it as an optimization?; // If the symbol is out of range, produce a relocation and hope the; // linker can handle it. GNU AS produces an error in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAsmBackend.cpp:57,Availability,mask,mask,57,"// For each byte of the fragment that the fixup touches, mask in the bits from; // the fixup value. The Value has been ""split up"" into the appropriate; // bitfields above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMBaseInfo.h:61,Availability,mask,mask,61,/// MO_OPTION_MASK - Most flags are mutually exclusive; this mask selects; /// just that part of the flag set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMBaseInfo.h:147,Testability,stub,stub,147,"/// MO_COFFSTUB - On a symbol operand ""FOO"", this indicates that the; /// reference is actually to the "".refptr.FOO"" symbol. This is used for; /// stub symbols on windows.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMBaseInfo.h:111,Testability,stub,stub,111,"/// MO_DLLIMPORT - On a symbol operand, this represents that the reference; /// to the symbol is for an import stub. This is used for DLL import; /// storage class indication on Windows.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMBaseInfo.h:120,Performance,load,load,120,"// The AddrMode enums are declared in ARMBaseInfo.h; // IndexMode - Unindex, pre-indexed, or post-indexed are valid for load; // and store ops only. Generic ""updating"" flag is used for ld/st multiple.; // The index mode enums are declared in ARMBaseInfo.h",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMBaseInfo.h:3,Performance,Load,Load,3,// Load and Store,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMBaseInfo.h:3,Modifiability,Extend,Extend,3,// Extend instructions,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMBaseInfo.h:122,Performance,perform,performed,122,"// Whether an instruction can be included in an MVE tail-predicated loop,; // though extra validity checks may need to be performed too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMBaseInfo.h:189,Modifiability,extend,extends,189,"// The vector element size for MVE instructions. 00 = i8, 01 = i16, 10 = i32; // and 11 = i64. This is the largest type if multiple are present, so a; // MVE_VMOVLs8bh is ize 01=i16, as it extends from a i8 to a i16. There are; // some caveats so cannot be used blindly, such as exchanging VMLADAVA's and; // complex instructions, which may use different input lanes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMELFObjectWriter.cpp:95,Usability,clear,clear,95,"// FIXME: This is extremely conservative. This really needs to use an; // explicit list with a clear explanation for why each realocation needs to; // point to the symbol, not to the section.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMELFObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMELFObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMELFObjectWriter.cpp:89,Safety,avoid,avoid,89,"// The mix of execute-only and non-execute-only at link time is; // non-execute-only. To avoid the empty implicitly created .text; // section from making the whole .text section non-execute-only, we; // mark it execute-only if it is empty and there is at least one; // execute-only section in the object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMELFObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMELFObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMELFStreamer.cpp:4,Modifiability,Extend,Extend,4,"/// Extend the generic ELFStreamer class so that it can emit mapping symbols at; /// the appropriate points in the object files. These symbols are defined in the; /// ARM ELF ABI: infocenter.arm.com/help/topic/com.arm.../IHI0044D_aaelf.pdf.; ///; /// In brief: $a, $t or $d should be emitted at the start of each contiguous; /// region of ARM code, Thumb code or data in a section. In practice, this; /// emission does not rely on explicit assembler directives but on inherent; /// properties of the directives doing the emission (e.g. "".byte"" is data, ""add; /// r0, r0, r0"" an instruction).; ///; /// As a result this system is orthogonal to the DataRegion infrastructure used; /// by MachO. Beware!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMELFStreamer.cpp:98,Integrability,depend,depending,98,"// 'Advanced_SIMD_arch' must be emitted not here, but within; // ARMAsmPrinter::emitAttributes(), depending on hasV8Ops() and hasV8_1a()",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMELFStreamer.cpp:166,Usability,simpl,simplify,166,"// The conformance tag must be emitted first when serialised into an; // object file. Specifically, the addenda to the ARM ABI states that; // (2.3.7.4):; //; // ""To simplify recognition by consumers in the common case of claiming; // conformity for the whole file, this tag should be emitted first in a; // file-scope sub-subsection of the first public subsection of the; // attributes section.""; //; // So it is special-cased in this comparison predicate when the; // attributes are sorted in finishAttributeSection().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMELFStreamer.cpp:17,Usability,clear,clear,17,"// MCELFStreamer clear's the assembler's e_flags. However, for; // arm we manually set the ABI version on streamer creation, so; // do the same here",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMELFStreamer.cpp:24,Integrability,depend,dependency,24,// The EHABI requires a dependency preserving R_ARM_NONE relocation to the; // personality routine to protect it from an arbitrary platform's static; // linker garbage collection. We disable this for Android where the unwinder; // is either dynamically linked or directly references the personality; // routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMELFStreamer.cpp:91,Integrability,rout,routine,91,// The EHABI requires a dependency preserving R_ARM_NONE relocation to the; // personality routine to protect it from an arbitrary platform's static; // linker garbage collection. We disable this for Android where the unwinder; // is either dynamically linked or directly references the personality; // routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMELFStreamer.cpp:303,Integrability,rout,routine,303,// The EHABI requires a dependency preserving R_ARM_NONE relocation to the; // personality routine to protect it from an arbitrary platform's static; // linker garbage collection. We disable this for Android where the unwinder; // is either dynamically linked or directly references the personality; // routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMELFStreamer.cpp:140,Security,authenticat,authentication,140,"// Collect the registers in the register list. Issue unwinding instructions in; // three parts: ordinary hardware registers, return address authentication; // code pseudo register, the rest of the registers. The RA PAC is kept in an; // architectural register (usually r12), but we treat it as a special case in; // order to distinguish between that register containing RA PAC or a general; // value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMFixupKinds.h:19,Performance,load,load,19,// Fixup for Thumb load/store from constant pool instrs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMFixupKinds.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMFixupKinds.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMInstPrinter.cpp:31,Availability,mask,mask,31,"// For writes, handle extended mask bits if the DSP extension is present.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMInstPrinter.cpp:22,Modifiability,extend,extended,22,"// For writes, handle extended mask bits if the DSP extension is present.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMInstPrinter.cpp:26,Availability,mask,mask,26,// Handle the basic 8-bit mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMInstPrinter.cpp:66,Safety,abort,abort,66,// Handle the undefined 15 CC value here for printing so we don't abort().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMInstPrinter.cpp:22,Safety,safe,safe,22,"// Normally, it's not safe to use register enum values directly with; // addition to get the next register, but for VFP registers, the; // sort order is guaranteed because they're all of the form D<n>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMInstPrinter.cpp:22,Safety,safe,safe,22,"// Normally, it's not safe to use register enum values directly with; // addition to get the next register, but for VFP registers, the; // sort order is guaranteed because they're all of the form D<n>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMInstPrinter.cpp:22,Safety,safe,safe,22,"// Normally, it's not safe to use register enum values directly with; // addition to get the next register, but for VFP registers, the; // sort order is guaranteed because they're all of the form D<n>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMInstPrinter.cpp:22,Safety,safe,safe,22,"// Normally, it's not safe to use register enum values directly with; // addition to get the next register, but for VFP registers, the; // sort order is guaranteed because they're all of the form D<n>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMInstPrinter.cpp:22,Safety,safe,safe,22,"// Normally, it's not safe to use register enum values directly with; // addition to get the next register, but for VFP registers, the; // sort order is guaranteed because they're all of the form D<n>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMInstPrinter.cpp:22,Safety,safe,safe,22,"// Normally, it's not safe to use register enum values directly with; // addition to get the next register, but for VFP registers, the; // sort order is guaranteed because they're all of the form D<n>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMInstPrinter.cpp:22,Safety,safe,safe,22,"// Normally, it's not safe to use register enum values directly with; // addition to get the next register, but for VFP registers, the; // sort order is guaranteed because they're all of the form D<n>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMInstPrinter.cpp:22,Safety,safe,safe,22,"// Normally, it's not safe to use register enum values directly with; // addition to get the next register, but for VFP registers, the; // sort order is guaranteed because they're all of the form D<n>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMachObjectWriter.cpp:158,Usability,Clear,Clear,158,"// The thumb bit shouldn't be set in the 'other-half' bit of the; // relocation, but it will be set in FixedValue if the base symbol; // is a thumb function. Clear it out here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMachObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMachObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMachObjectWriter.cpp:20,Modifiability,variab,variables,20,// Resolve constant variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMachObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMachObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp:100,Performance,load,load,100,/// getLdStSORegOpValue - Return encoding info for 'reg +/- reg shop imm'; /// operand as needed by load/store instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp:46,Performance,load,load,46,/// getLdStmModeOpValue - Return encoding for load/store multiple mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp:126,Modifiability,rewrite,rewrite,126,"// end anonymous namespace; /// NEONThumb2DataIPostEncoder - Post-process encoded NEON data-processing; /// instructions, and rewrite them to their Thumb2 form if we are currently in; /// Thumb2 mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp:51,Usability,simpl,simple,51,"// NEON Thumb2 data-processsing encodings are very simple: bit 24 is moved; // to bit 12 of the high half-word (i.e. bit 28), and bits 27-24 are; // set to 1111.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp:97,Modifiability,rewrite,rewrite,97,"/// NEONThumb2LoadStorePostEncoder - Post-process encoded NEON load/store; /// instructions, and rewrite them to their Thumb2 form if we are currently in; /// Thumb2 mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp:63,Performance,load,load,63,"/// NEONThumb2LoadStorePostEncoder - Post-process encoded NEON load/store; /// instructions, and rewrite them to their Thumb2 form if we are currently in; /// Thumb2 mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp:85,Modifiability,rewrite,rewrite,85,"/// NEONThumb2DupPostEncoder - Post-process encoded NEON vdup; /// instructions, and rewrite them to their Thumb2 form if we are currently in; /// Thumb2 mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp:51,Modifiability,rewrite,rewrite,51,"/// Post-process encoded NEON v8 instructions, and rewrite them to Thumb2 form; /// if we are in Thumb2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp:69,Modifiability,rewrite,rewrite,69,/// VFPThumb2PostEncoder - Post-process encoded VFP instructions and rewrite; /// them to their Thumb2 form if we are currently in Thumb2 mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp:77,Modifiability,coupling,coupling,77,"// FIXME: This really, really shouldn't use TargetMachine. We don't want; // coupling between MC and TM anywhere we can help it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp:83,Availability,mask,mask,83,"/// getITMaskOpValue - Return the architectural encoding of an IT; /// predication mask, given the MCOperand format.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp:6,Availability,mask,masks,6,"// IT masks are encoded as a sequence of replacement low-order bits; // for the condition code. So if the low bit of the starting; // condition code is 1, then we have to flip all the bits above the; // terminating bit (which is the lowest 1 bit).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp:120,Integrability,depend,depending,120,"// {4-0} = szimm5; // The value we are trying to encode is an immediate between either the; // range of [1-7] or [1-15] depending on whether we are dealing with the; // u8/s8 or the u16/s16 variants respectively.; // This value is encoded as follows, if ShiftImm is the value within those; // ranges then the encoding szimm5 = ShiftImm + size, where size is either 8; // or 16.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp:309,Security,validat,validateInstruction,309,"// If the expression doesn't have :upper16:, :lower16: on it, it's just a; // plain immediate expression, previously those evaluated to the lower 16 bits; // of the expression regardless of whether we have a movt or a movw, but that; // led to misleadingly results. This is disallowed in the AsmParser in; // validateInstruction() so this should never happen. The same holds for; // thumb1 :upper8_15:, :upper0_7:, lower8_15: or :lower0_7: with movs or adds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp:117,Usability,clear,clear,117,// Set shift operand (bit[6:4]).; // LSL - 000; // LSR - 010; // ASR - 100; // ROR - 110; // RRX - 110 and bit[11:8] clear.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp:44,Availability,mask,mask,44,"// 10 bits. lower 5 bits are the lsb of the mask, high five bits are the; // msb of the mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp:88,Availability,mask,mask,88,"// 10 bits. lower 5 bits are the lsb of the mask, high five bits are the; // msb of the mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp:7,Availability,Mask,Masks,7,"// VPT Masks are actually encoded as a series of invert/don't invert bits,; // rather than true/false bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp:37,Availability,mask,mask,37,// Check if we are at the end of the mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp:26,Availability,mask,mask,26,// Convert the bit in the mask based on the previous bit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCExpr.h:18,Security,Access,Accessors,18,/// @}; /// @name Accessors; /// @{; /// getOpcode - Get the kind of this expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCExpr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCExpr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCTargetDesc.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCTargetDesc.cpp:8,Performance,load,load,8,// Only load instructions can have PC-relative memory addressing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCTargetDesc.cpp:35,Deployability,update,update,35,// PC-relative addressing does not update the base register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCTargetDesc.cpp:109,Integrability,rout,route,109,// VLDR* instructions share the same opcode (and thus the same form) for Arm; // and Thumb. Use a bit longer route through STI in that case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCTargetDesc.cpp:24,Integrability,depend,depending,24,// Eveluate the address depending on the addressing mode,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCTargetDesc.h:51,Security,expose,exposed,51,"/// Create a ARM MCSubtargetInfo instance. This is exposed so Asm parser, etc.; /// do not need to go through TargetRegistry.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCTargetDesc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCTargetDesc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMTargetStreamer.cpp:89,Availability,avail,available,89,"/// Emit the build attributes that only depend on the hardware that we expect; // /to be available, and not on the ABI, or any source-language choices.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMTargetStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMTargetStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMTargetStreamer.cpp:40,Integrability,depend,depend,40,"/// Emit the build attributes that only depend on the hardware that we expect; // /to be available, and not on the ABI, or any source-language choices.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMTargetStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMTargetStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMTargetStreamer.cpp:121,Integrability,depend,depending,121,"// FPv5 and FP-ARMv8 have the same instructions, so are modeled as one; // FPU, but there are two different names for it depending on the CPU.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMTargetStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMTargetStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMTargetStreamer.cpp:258,Availability,down,downgrades,258,"// Hardware divide in ARM mode is part of base arch, starting from ARMv8.; // If only Thumb hwdiv is present, it must also be in base arch (ARMv7-R/M).; // It is not possible to produce DisallowDIV: if hwdiv is present in the base; // arch, supplying -hwdiv downgrades the effective arch, via ClearImpliedBits.; // AllowDIVExt is only emitted if hwdiv isn't available in the base arch;; // otherwise, the default value (AllowDIVIfExists) applies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMTargetStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMTargetStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMTargetStreamer.cpp:358,Availability,avail,available,358,"// Hardware divide in ARM mode is part of base arch, starting from ARMv8.; // If only Thumb hwdiv is present, it must also be in base arch (ARMv7-R/M).; // It is not possible to produce DisallowDIV: if hwdiv is present in the base; // arch, supplying -hwdiv downgrades the effective arch, via ClearImpliedBits.; // AllowDIVExt is only emitted if hwdiv isn't available in the base arch;; // otherwise, the default value (AllowDIVIfExists) applies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMTargetStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMTargetStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMTargetStreamer.cpp:293,Usability,Clear,ClearImpliedBits,293,"// Hardware divide in ARM mode is part of base arch, starting from ARMv8.; // If only Thumb hwdiv is present, it must also be in base arch (ARMv7-R/M).; // It is not possible to produce DisallowDIV: if hwdiv is present in the base; // arch, supplying -hwdiv downgrades the effective arch, via ClearImpliedBits.; // AllowDIVExt is only emitted if hwdiv isn't available in the base arch;; // otherwise, the default value (AllowDIVIfExists) applies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMTargetStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMTargetStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMUnwindOpAsm.cpp:38,Integrability,wrap,wrapper,38,"/// UnwindOpcodeStreamer - The simple wrapper over SmallVector to emit bytes; /// with MSB to LSB per uint32_t ordering. For example, the first byte will; /// be placed in Vec[3], and the following bytes will be placed in 2, 1, 0,; /// 7, 6, 5, 4, 11, 10, 9, 8, and so on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMUnwindOpAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMUnwindOpAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMUnwindOpAsm.cpp:31,Usability,simpl,simple,31,"/// UnwindOpcodeStreamer - The simple wrapper over SmallVector to emit bytes; /// with MSB to LSB per uint32_t ordering. For example, the first byte will; /// be placed in Vec[3], and the following bytes will be placed in 2, 1, 0,; /// 7, 6, 5, 4, 11, 10, 9, 8, and so on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMUnwindOpAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMUnwindOpAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMUnwindOpAsm.cpp:19,Availability,Mask,Mask,19,// Exclude r4.; // Mask off non-consecutive registers. Keep r4.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMUnwindOpAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMUnwindOpAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMUnwindOpAsm.cpp:29,Availability,mask,mask,29,// Emit this opcode when the mask covers every registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMUnwindOpAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMUnwindOpAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMUnwindOpAsm.cpp:29,Integrability,rout,routine,29,"// User-specifed personality routine: [ SIZE , OP1 , OP2 , ... ]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMUnwindOpAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMUnwindOpAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMWinCOFFStreamer.cpp:7,Deployability,continuous,continuous,7,// One continuous range from r4 to r8-r11,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMWinCOFFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMWinCOFFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMWinCOFFStreamer.cpp:7,Deployability,continuous,continuous,7,// One continuous range from r4 to r4-r7,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMWinCOFFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMWinCOFFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Utils/ARMBaseInfo.cpp:92,Availability,mask,mask,92,// lookup system register using 12-bit SYSm value.; // Note: the search is uniqued using M1 mask,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Utils/ARMBaseInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Utils/ARMBaseInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Utils/ARMBaseInfo.h:9,Usability,clear,clear,9,// Carry clear Less than,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Utils/ARMBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Utils/ARMBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Utils/ARMBaseInfo.h:4,Availability,Mask,Mask,4,"/// Mask values for IT and VPT Blocks, to be used by MCOperands.; /// Note that this is different from the ""real"" encoding used by the; /// instructions. In this encoding, the lowest set bit indicates the end of; /// the encoding, and above that, ""1"" indicates an else, while ""0"" indicates; /// a then.; /// Tx = x100; /// Txy = xy10; /// Txyz = xyz1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Utils/ARMBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Utils/ARMBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Utils/ARMBaseInfo.h:79,Integrability,depend,depending,79,"// namespace ARM; // Expands a PredBlockMask by adding an E or a T at the end, depending on Kind.; // e.g ExpandPredBlockMask(T, Then) = TT, ExpandPredBlockMask(TT, Else) = TTE,; // and so on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Utils/ARMBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Utils/ARMBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Utils/ARMBaseInfo.h:19,Testability,Test,TestFeatures,19,// returns true if TestFeatures are all present in FeaturesRequired,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Utils/ARMBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Utils/ARMBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Utils/ARMBaseInfo.h:92,Availability,mask,mask,92,// lookup system register using 12-bit SYSm value.; // Note: the search is uniqued using M1 mask,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/ARM/Utils/ARMBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Utils/ARMBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVR.h:26,Integrability,interface,interface,26,"//===-- AVR.h - Top-level interface for AVR representation ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the entry points for global functions defined in the LLVM; // AVR back-end.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVR.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVR.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVR.h:112,Modifiability,extend,extended,112,// Get the index of the program memory bank.; // -1: not program memory; // 0: ordinary program memory; // 1~5: extended program memory,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVR.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVR.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRAsmPrinter.cpp:474,Integrability,depend,dependent,474,"//===-- AVRAsmPrinter.cpp - AVR LLVM assembly writer ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a printer that converts from our internal representation; // of machine-dependent LLVM code to GAS-format AVR assembly language.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRAsmPrinter.cpp:116,Security,expose,expose,116,// TODO: We should be able to look up the alternative name for; // the register if it's given.; // TableGen doesn't expose a way of getting retrieving names; // for registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRAsmPrinter.cpp:20,Availability,avail,available,20,// Emit __SP_H__ if available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRAsmPrinter.cpp:20,Availability,avail,available,20,// Emit __EIND__ if available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRAsmPrinter.cpp:21,Availability,avail,available,21,// Emit __RAMPZ__ if available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp:555,Energy Efficiency,schedul,scheduling,555,"//===-- AVRExpandPseudoInsts.cpp - Expand pseudo instructions -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a pass that expands pseudo instructions into target; // instructions. This pass should be run after register allocation but before; // the post-regalloc scheduling pass.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp:20,Availability,redundant,redundant,20,"// ANDI Rd, 0xff is redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp:20,Safety,redund,redundant,20,"// ANDI Rd, 0xff is redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp:18,Availability,redundant,redundant,18,"// ORI Rd, 0x0 is redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp:18,Safety,redund,redundant,18,"// ORI Rd, 0x0 is redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp:17,Usability,clear,clears,17,"// ANDI Rd, 0x00 clears all input bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp:61,Energy Efficiency,allocate,allocate,61,// DstReg has an earlyclobber so the register allocator will allocate them in; // separate registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp:3,Performance,Load,Load,3,// Load low byte.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp:3,Performance,Load,Load,3,// Load high byte.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp:61,Energy Efficiency,allocate,allocate,61,// DstReg has an earlyclobber so the register allocator will allocate them in; // separate registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp:3,Energy Efficiency,Reduce,Reduced,3,"// Reduced tiny cores don't support load/store with displacement. However,; // they do support postincrement. So we'll simply adjust the pointer before; // and after and use postincrement to load multiple registers.; // Add offset. The offset can be 0 when expanding this instruction from the; // more specific LDWRdPtr instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp:36,Performance,load,load,36,"// Reduced tiny cores don't support load/store with displacement. However,; // they do support postincrement. So we'll simply adjust the pointer before; // and after and use postincrement to load multiple registers.; // Add offset. The offset can be 0 when expanding this instruction from the; // more specific LDWRdPtr instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp:191,Performance,load,load,191,"// Reduced tiny cores don't support load/store with displacement. However,; // they do support postincrement. So we'll simply adjust the pointer before; // and after and use postincrement to load multiple registers.; // Add offset. The offset can be 0 when expanding this instruction from the; // more specific LDWRdPtr instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp:119,Usability,simpl,simply,119,"// Reduced tiny cores don't support load/store with displacement. However,; // they do support postincrement. So we'll simply adjust the pointer before; // and after and use postincrement to load multiple registers.; // Add offset. The offset can be 0 when expanding this instruction from the; // more specific LDWRdPtr instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp:13,Performance,load,load,13,// Do a word load with postincrement. This will be lowered to a two byte; // load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp:77,Performance,load,load,77,// Do a word load with postincrement. This will be lowered to a two byte; // load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp:3,Performance,Load,Load,3,// Load low byte.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp:3,Performance,Load,Load,3,// Load high byte.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp:3,Performance,Load,Load,3,// Load low byte.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp:3,Performance,Load,Load,3,// Load high byte.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp:3,Performance,Load,Load,3,"// Load low byte, and copy to the low destination register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp:3,Performance,Load,Load,3,"// Load high byte, and copy to the high destination register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp:3,Performance,Load,Load,3,// Load byte.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp:135,Availability,avail,available,135,"// STD's maximum displacement is 63, so larger stores have to be split into a; // set of operations.; // For avrtiny chips, STD is not available at all so we always have to fall; // back to manual pointer adjustments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp:3,Usability,Clear,Clear,3,// Clear upper byte.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp:3,Usability,Clear,Clear,3,// Clear upper byte.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRFrameLowering.cpp:10,Usability,simpl,simplify,10,"// Always simplify call frame pseudo instructions, even when; // hasReservedCallFrame is false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRFrameLowering.cpp:175,Modifiability,variab,variable,175,// Reserve call frame memory in function prologue under the following; // conditions:; // - Y pointer is reserved to be the frame pointer.; // - The function does not contain variable sized objects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRFrameLowering.cpp:3,Deployability,Update,Update,3,// Update Y with the new base value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRFrameLowering.cpp:29,Integrability,depend,depending,29,// Select the optimal opcode depending on how big it is.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRFrameLowering.cpp:3,Deployability,Update,Update,3,"// Update the stack pointer.; // In many cases this can be done far more efficiently by pushing the; // relevant values directly to the stack. However, doing that correctly; // (in the right order, possibly skipping some empty space for undef; // values, etc) is tricky and thus left to be optimized in the future.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRFrameLowering.cpp:73,Energy Efficiency,efficient,efficiently,73,"// Update the stack pointer.; // In many cases this can be done far more efficiently by pushing the; // relevant values directly to the stack. However, doing that correctly; // (in the right order, possibly skipping some empty space for undef; // values, etc) is tricky and thus left to be optimized in the future.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRFrameLowering.cpp:290,Performance,optimiz,optimized,290,"// Update the stack pointer.; // In many cases this can be done far more efficiently by pushing the; // relevant values directly to the stack. However, doing that correctly; // (in the right order, possibly skipping some empty space for undef; // values, etc) is tricky and thus left to be optimized in the future.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRFrameLowering.cpp:59,Energy Efficiency,efficient,efficiently,59,// Note that small stack changes could be implemented more efficiently; // with a few pop instructions instead of the 8-9 instructions now; // required.; // Select the best opcode to adjust SP based on the offset size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRFrameLowering.cpp:143,Modifiability,variab,variable,143,// Check for the type of allocas present in the function. We only care; // about fixed size allocas so do not give false positives if only; // variable sized allocas are present.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRFrameLowering.cpp:3,Modifiability,Variab,Variable,3,// Variable sized objects have size 0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRInstrInfo.cpp:214,Energy Efficiency,efficient,efficient,214,// If we can modify the code and it ends in something like:; //; // jCC L1; // jmp L2; // L1:; // ...; // L2:; //; // Then we can change this to:; //; // jnCC L2; // L1:; // ...; // L2:; //; // Which is a bit more efficient.; // We conditionally jump to the fall-through block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp:9,Usability,simpl,simple,9,// Match simple Reg + uimm6 operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp:185,Security,access,access,185,// <#Frame index + const>; // Allow folding offsets bigger than 63 so the frame pointer can be used; // directly instead of copying it around by adjusting and restoring it for; // each access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp:24,Performance,load,load,24,// We only care if this load uses a POSTINC or PREDEC mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp:19,Performance,load,loads,19,// Progmem indexed loads only work in POSTINC mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp:43,Modifiability,extend,extended,43,// Feature ELPM is needed for loading from extended program memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp:30,Performance,load,loading,30,// Feature ELPM is needed for loading from extended program memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp:9,Safety,detect,detect,9,// If we detect proper case - correct virtual register class; // if needed and go to another inlineasm operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp:56,Performance,load,load,56,// Check if the opcode can be converted into an indexed load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp:26,Performance,load,load,26,"// This is a flash memory load, move the pointer into R31R30 and emit; // the lpm instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp:56,Performance,load,load,56,// Check if the opcode can be converted into an indexed load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp:27,Performance,load,load,27,// It is legal to fold the load into an indexed load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp:48,Performance,load,load,48,// It is legal to fold the load into an indexed load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp:24,Performance,load,load,24,"// Selecting an indexed load is not legal, fallback to a normal load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp:64,Performance,load,load,64,"// Selecting an indexed load is not legal, fallback to a normal load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp:14,Usability,clear,clear,14,// We need to clear R1. This is currently done (dirtily); // using a custom inserter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:405,Integrability,interface,interfaces,405,"//===-- AVRISelLowering.cpp - AVR DAG Lowering Implementation -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that AVR uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:50,Performance,load,load,50,// Add support for postincrement and predecrement load/stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:132,Modifiability,extend,extending,132,"// TODO: The generated code is pretty poor. Investigate using the; // same ""shift and subtract with carry"" trick that we do for; // extending 8-bit to 16-bit. This may require infrastructure; // improvements in how we treat 16-bit ""registers"" to be feasible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:3,Performance,Optimiz,Optimize,3,// Optimize int8/int16 shifts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:3,Performance,Optimiz,Optimize,3,// Optimize LSL when 4 <= ShiftAmount <= 6.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:3,Performance,Optimiz,Optimize,3,// Optimize LSR when 4 <= ShiftAmount <= 6.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:3,Performance,Optimiz,Optimize,3,// Optimize LSL when ShiftAmount == 7.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:3,Performance,Optimiz,Optimize,3,// Optimize LSR when ShiftAmount == 7.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:3,Performance,Optimiz,Optimize,3,// Optimize ASR when ShiftAmount == 6.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:3,Performance,Optimiz,Optimize,3,// Optimize ASR when ShiftAmount == 7.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:3,Performance,Optimiz,Optimize,3,// Optimize left rotation 3 bits to swap then right rotation 1 bit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:3,Performance,Optimiz,Optimize,3,// Optimize right rotation 3 bits to swap then left rotation 1 bit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:3,Performance,Optimiz,Optimize,3,// Optimize left rotation 7 bits to right rotation 1 bit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:3,Performance,Optimiz,Optimize,3,// Optimize right rotation 7 bits to left rotation 1 bit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:3,Performance,Optimiz,Optimize,3,// Optimize left/right rotation with the SWAP instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:11,Performance,optimiz,optimization,11,// Special optimization for int16 arithmetic right shift.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:16,Testability,test,test,16,// When using a test instruction AVRcc is already set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:94,Performance,load,load,94,"/// Return true if the addressing mode represented; /// by AM is legal for this target, for a load/store of the specified type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:166,Performance,load,load,166,"/// Returns true by value, base pointer and; /// offset pointer and addressing mode by reference if the node's address; /// can be legally represented as pre-indexed load / store address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:138,Performance,load,load,138,"/// Returns true by value, base pointer and; /// offset pointer and addressing mode by reference if this node can be; /// combined with a load / store to form a post-indexed load / store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:174,Performance,load,load,174,"/// Returns true by value, base pointer and; /// offset pointer and addressing mode by reference if this node can be; /// combined with a load / store to form a post-indexed load / store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:48,Performance,load,load,48,"// FIXME: We temporarily disable post increment load from program memory,; // due to bug https://github.com/llvm/llvm-project/issues/59914.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:36,Testability,assert,assertion,36,// CanLowerReturn() guarantees this assertion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:59,Safety,safe,safety,59,"// :NOTE: Clang should not promote any i8 into i16 but for safety the; // following code will handle zexts or sexts generated by other; // front ends. Otherwise:; // If this is an 8 bit value, it is really passed promoted; // to 16 bits. Insert an assert[sz]ext to capture this, then; // truncate to the right size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:248,Testability,assert,assert,248,"// :NOTE: Clang should not promote any i8 into i16 but for safety the; // following code will handle zexts or sexts generated by other; // front ends. Otherwise:; // If this is an 8 bit value, it is really passed promoted; // to 16 bits. Insert an assert[sz]ext to capture this, then; // truncate to the right size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:52,Performance,load,load,52,// Create the SelectionDAG nodes corresponding to a load; // from this parameter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:25,Modifiability,variab,variable,25,"// If the function takes variable number of arguments, make a frame index for; // the start of the first vararg value... for expansion of llvm.va_start.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:38,Performance,optimiz,optimization,38,// AVR does not yet support tail call optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:18,Availability,mask,mask,18,// Add a register mask operand representing the call-preserved registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:3,Deployability,Update,Update,3,// Update chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:3,Deployability,Update,Update,3,// Update machine-CFG edges by transferring all successors of the current; // block to the block containing instructions after shift.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:399,Energy Efficiency,reduce,reduce,399,"// Do a multibyte AVR shift. Insert shift instructions and put the output; // registers in the Regs array.; // Because AVR does not have a normal shift instruction (only a single bit shift; // instruction), we have to emulate this behavior with other instructions.; // It first tries large steps (moving registers around) and then smaller steps; // like single bit shifts.; // Large shifts actually reduce the number of shifted registers, so the below; // algorithms have to work independently of the number of registers that are; // shifted.; // For more information and background, see this blogpost:; // https://aykevl.nl/2021/02/avr-bitshift",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:16,Modifiability,extend,extend,16,// Sign or zero extend the most significant register into a new register.; // The HighByte is the byte that still has one (or two) bits from the; // original value. The ExtByte is purely a zero/sign extend byte (all bits; // are either 0 or 1).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:199,Modifiability,extend,extend,199,// Sign or zero extend the most significant register into a new register.; // The HighByte is the byte that still has one (or two) bits from the; // original value. The ExtByte is purely a zero/sign extend byte (all bits; // are either 0 or 1).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:8,Modifiability,extend,extend,8,// Sign-extend bit that was shifted out last.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:65,Modifiability,extend,extend,65,"// The highest bit of the original value is the same as the zero-extend; // byte, so HighByte and ExtByte are the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:34,Modifiability,extend,extending,34,// Use the zero register for zero extending.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:45,Modifiability,extend,extending,45,"// Move all to the right, while sign or zero extending.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:47,Usability,simpl,simply,47,"// For shift amounts of at least one register, simply rename the registers and; // zero the bottom registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:8,Modifiability,extend,extend,8,// Sign extend the most significant register into ShrExtendReg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:16,Modifiability,extend,extend,16,// Zero or sign extend the most significant register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:93,Testability,log,logical,93,"// Shift by four bits, using a complicated swap/eor/andi/eor sequence.; // It only works for logical shifts because the bits shifted in are all; // zeroes.; // To shift a single byte right, it produces code like this:; // swap r0; // andi r0, 0x0f; // For a two-byte (16-bit) shift, it adds the following instructions to shift; // the upper byte into the lower byte:; // swap r1; // eor r0, r1; // andi r1, 0x0f; // eor r0, r1; // For bigger shifts, it repeats the above sequence. For example, for a 3-byte; // (24-bit) shift it adds:; // swap r2; // eor r1, r2; // andi r2, 0x0f; // eor r1, r2",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:3,Safety,sanity check,sanity check,3,// sanity check,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:116,Integrability,depend,depending,116,"// Combine the 8-bit registers into 16-bit register pairs.; // This done either from LSB to MSB or from MSB to LSB, depending on the; // shift. It's an optimization so that the register allocator will use the; // fewest movs possible (which order we use isn't a correctness issue, just an; // optimization issue).; // - lsl prefers starting from the most significant byte (2nd case).; // - lshr prefers starting from the least significant byte (1st case).; // - for ashr it depends on the number of shifted bytes.; // Some shift operations still don't get the most optimal mov sequences even; // with this distinction. TODO: figure out why and try to fix it (but we're; // already equal to or faster than avr-gcc in all cases except ashr 8).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:474,Integrability,depend,depends,474,"// Combine the 8-bit registers into 16-bit register pairs.; // This done either from LSB to MSB or from MSB to LSB, depending on the; // shift. It's an optimization so that the register allocator will use the; // fewest movs possible (which order we use isn't a correctness issue, just an; // optimization issue).; // - lsl prefers starting from the most significant byte (2nd case).; // - lshr prefers starting from the least significant byte (1st case).; // - for ashr it depends on the number of shifted bytes.; // Some shift operations still don't get the most optimal mov sequences even; // with this distinction. TODO: figure out why and try to fix it (but we're; // already equal to or faster than avr-gcc in all cases except ashr 8).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:152,Performance,optimiz,optimization,152,"// Combine the 8-bit registers into 16-bit register pairs.; // This done either from LSB to MSB or from MSB to LSB, depending on the; // shift. It's an optimization so that the register allocator will use the; // fewest movs possible (which order we use isn't a correctness issue, just an; // optimization issue).; // - lsl prefers starting from the most significant byte (2nd case).; // - lshr prefers starting from the least significant byte (1st case).; // - for ashr it depends on the number of shifted bytes.; // Some shift operations still don't get the most optimal mov sequences even; // with this distinction. TODO: figure out why and try to fix it (but we're; // already equal to or faster than avr-gcc in all cases except ashr 8).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:293,Performance,optimiz,optimization,293,"// Combine the 8-bit registers into 16-bit register pairs.; // This done either from LSB to MSB or from MSB to LSB, depending on the; // shift. It's an optimization so that the register allocator will use the; // fewest movs possible (which order we use isn't a correctness issue, just an; // optimization issue).; // - lsl prefers starting from the most significant byte (2nd case).; // - lshr prefers starting from the least significant byte (1st case).; // - for ashr it depends on the number of shifted bytes.; // Some shift operations still don't get the most optimal mov sequences even; // with this distinction. TODO: figure out why and try to fix it (but we're; // already equal to or faster than avr-gcc in all cases except ashr 8).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:68,Usability,clear,clear,68,"// The mul instructions wreak havock on our zero_reg R1. We need to clear it; // after the result has been evacuated. This is probably not the best way to do; // it, but it works for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:3,Performance,Load,Load,3,// Load the original value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:3,Usability,Simpl,Simple,3,// Simple upper registers,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:3,Usability,Simpl,Simple,3,// Simple upper registers r16..r23.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h:45,Integrability,Interface,Interface,45,"//===-- AVRISelLowering.h - AVR DAG Lowering Interface ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that AVR uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h:405,Integrability,interface,interfaces,405,"//===-- AVRISelLowering.h - AVR DAG Lowering Interface ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that AVR uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h:6,Integrability,wrap,wrapper,6,"/// A wrapper node for TargetConstantPool,; /// TargetExternalSymbol, and TargetGlobalAddress.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h:5,Testability,Log,Logical,5,///< Logical shift left.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h:10,Testability,log,logical,10,///< Byte logical shift left N bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h:10,Testability,log,logical,10,///< Word logical shift left N bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h:26,Testability,log,logical,26,///< Higher 8-bit of word logical shift left.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h:10,Testability,log,logical,10,///< Wide logical shift left.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h:5,Testability,Log,Logical,5,///< Logical shift right.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h:10,Testability,log,logical,10,///< Byte logical shift right N bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h:10,Testability,log,logical,10,///< Word logical shift right N bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h:25,Testability,log,logical,25,///< Lower 8-bit of word logical shift right.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h:10,Testability,log,logical,10,///< Wide logical shift right.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h:22,Testability,log,logical,22,///< A loop of single logical shift left instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h:22,Testability,log,logical,22,///< A loop of single logical shift right instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h:280,Testability,TEST,TEST,280,"///< A loop of single arithmetic shift right instructions.; /// AVR conditional branches. Operand 0 is the chain operand, operand 1; /// is the block to branch if condition is true, operand 2 is the; /// condition code, and operand 3 is the flag operand produced by a CMP; /// or TEST instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h:4,Testability,Test,Test,4,/// Test for zero or minus instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h:42,Modifiability,variab,variable,42,"/// Operand 0 and operand 1 are selection variable, operand 2; /// is condition code and operand 3 is flag operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h:4,Performance,Perform,Performs,4,/// Performs target lowering for the AVR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRMachineFunctionInfo.h:92,Modifiability,variab,variable,92,/// Indicates if there are any fixed size allocas present.; /// Note that if there are only variable sized allocas this is set to false.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRMachineFunctionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRMachineFunctionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRMachineFunctionInfo.h:61,Integrability,rout,routine,61,/// Checks if the function is some form of interrupt service routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRMachineFunctionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRMachineFunctionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRRegisterInfo.cpp:21,Performance,load,load,21,"// This is actually ""load effective address"" of the stack slot; // instruction. We have only two-address instructions, thus we need to; // expand it into move + add.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRRegisterInfo.cpp:55,Performance,load,load,55,"// Skip over the FRMIDX instruction.; // Generally, to load a frame address two add instructions are emitted that; // could get folded into a single one:; // movw r31:r30, r29:r28; // adiw r31:r30, 29; // adiw r31:r30, 16; // to:; // movw r31:r30, r29:r28; // adiw r31:r30, 45",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRRegisterInfo.cpp:144,Energy Efficiency,reduce,reduced,144,"// On most AVRs, we can use an offset up to 62 for load/store with; // displacement (63 for byte values, 62 for word values). However, the; // ""reduced tiny"" cores don't support load/store with displacement. So for; // them, we force an offset of 0 meaning that any positive offset will require; // adjusting the frame pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRRegisterInfo.cpp:51,Performance,load,load,51,"// On most AVRs, we can use an offset up to 62 for load/store with; // displacement (63 for byte values, 62 for word values). However, the; // ""reduced tiny"" cores don't support load/store with displacement. So for; // them, we force an offset of 0 meaning that any positive offset will require; // adjusting the frame pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRRegisterInfo.cpp:178,Performance,load,load,178,"// On most AVRs, we can use an offset up to 62 for load/store with; // displacement (63 for byte values, 62 for word values). However, the; // ""reduced tiny"" cores don't support load/store with displacement. So for; // them, we force an offset of 0 meaning that any positive offset will require; // adjusting the frame pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRRegisterInfo.cpp:103,Performance,load,load,103,// If the offset is too big we have to adjust and restore the frame pointer; // to materialize a valid load/store with displacement.; //: TODO: consider using only one adiw/sbiw chain for more than one frame; //: index,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRSubtarget.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRSubtarget.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRSubtarget.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRTargetMachine.cpp:28,Deployability,Configurat,Configuration,28,/// AVR Code Generator Pass Configuration Options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRTargetMachine.cpp:28,Modifiability,Config,Configuration,28,/// AVR Code Generator Pass Configuration Options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRTargetMachine.cpp:102,Safety,avoid,avoided,102,"// Expand instructions like; // %result = shl i32 %n, %amount; // to a loop so that library calls are avoided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRTargetMachine.cpp:90,Deployability,Pipeline,Pipeline,90,//===----------------------------------------------------------------------===//; // Pass Pipeline Configuration; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRTargetMachine.cpp:99,Deployability,Configurat,Configuration,99,//===----------------------------------------------------------------------===//; // Pass Pipeline Configuration; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRTargetMachine.cpp:99,Modifiability,Config,Configuration,99,//===----------------------------------------------------------------------===//; // Pass Pipeline Configuration; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRTargetMachine.cpp:3,Deployability,Install,Install,3,// Install an instruction selector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRTargetMachine.h:233,Safety,safe,safe,233,"// While AVR has different address spaces, they are all represented by; // 16-bit pointers that can be freely casted between (of course, a pointer; // must be cast back to its original address space to be dereferenceable).; // To be safe, also check the pointer size in case we implement __memx; // pointers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRTargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRTargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRTargetObjectFile.cpp:43,Security,access,access,43,// The AVR subtarget should support LPM to access section '.progmem*.data'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRTargetObjectFile.cpp:44,Security,access,access,44,// The AVR subtarget should support ELPM to access section; // '.progmem[1|2|3|4|5].data'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AVRTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AsmParser/AVRAsmParser.cpp:35,Availability,error,error,35,"// TODO: See if we can do a better error than just ""invalid ..."".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AsmParser/AVRAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AsmParser/AVRAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AsmParser/AVRAsmParser.cpp:238,Testability,test,test,238,"// GCC supports case insensitive register names. Some of the AVR registers; // are all lower case, some are all upper case but non are mixed. We prefer; // to use the original names in the register definitions. That is why we; // have to test both upper and lower case here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AsmParser/AVRAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AsmParser/AVRAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AsmParser/AVRAsmParser.cpp:25,Integrability,wrap,wrap,25,// If we have a modifier wrap the inner expression,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AsmParser/AVRAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AsmParser/AVRAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AsmParser/AVRAsmParser.cpp:86,Performance,perform,perform,86,"// If the instruction uses a register pair but we got a single, lower; // register we perform a ""class cast"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/AsmParser/AVRAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AsmParser/AVRAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/Disassembler/AVRDisassembler.cpp:28,Performance,load,loaded,28,// Get the register will be loaded or stored.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/Disassembler/AVRDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/Disassembler/AVRDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/Disassembler/AVRDisassembler.cpp:57,Performance,load,load,57,"// Decode the following 14 instructions. Bit 9 indicates load(0) or store(1),; // bits 8~4 indicate the value register, bits 3-2 indicate the base address; // register (11-X, 10-Y, 00-Z), bits 1~0 indicate the mode (00-basic,; // 01-postinc, 10-predec).; // ST X, Rr : 1001 001r rrrr 1100; // ST X+, Rr : 1001 001r rrrr 1101; // ST -X, Rr : 1001 001r rrrr 1110; // ST Y+, Rr : 1001 001r rrrr 1001; // ST -Y, Rr : 1001 001r rrrr 1010; // ST Z+, Rr : 1001 001r rrrr 0001; // ST -Z, Rr : 1001 001r rrrr 0010; // LD Rd, X : 1001 000d dddd 1100; // LD Rd, X+ : 1001 000d dddd 1101; // LD Rd, -X : 1001 000d dddd 1110; // LD Rd, Y+ : 1001 000d dddd 1001; // LD Rd, -Y : 1001 000d dddd 1010; // LD Rd, Z+ : 1001 000d dddd 0001; // LD Rd, -Z : 1001 000d dddd 0010",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/Disassembler/AVRDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/Disassembler/AVRDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/Disassembler/AVRDisassembler.cpp:13,Performance,load,load,13,// This is a load instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/Disassembler/AVRDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/Disassembler/AVRDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/Disassembler/AVRDisassembler.cpp:22,Performance,load,load,22,"// Try to decode to a load/store instruction. ST/LD need a specified; // DecoderMethod, as they already have a specified PostEncoderMethod.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/Disassembler/AVRDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/Disassembler/AVRDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRAsmBackend.cpp:46,Availability,mask,mask,46,"// Because the value may be negative, we must mask out the sign bits",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRAsmBackend.cpp:46,Availability,mask,mask,46,"// Because the value may be negative, we must mask out the sign bits",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRAsmBackend.cpp:53,Usability,simpl,simple,53,/// Adjusts a program memory address.; /// This is a simple right-shift.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRAsmBackend.cpp:35,Availability,mask,mask,35,// The number of bits in the fixup mask,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRAsmBackend.cpp:57,Availability,mask,mask,57,"// For each byte of the fragment that the fixup touches, mask in the; // bits from the fixup value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRInstPrinter.cpp:128,Modifiability,rewrite,rewrite,128,"// First handle load and store instructions with postinc or predec; // of the form ""ld reg, X+"".; // TODO: We should be able to rewrite this using TableGen data.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRInstPrinter.cpp:16,Performance,load,load,16,"// First handle load and store instructions with postinc or predec; // of the form ""ld reg, X+"".; // TODO: We should be able to rewrite this using TableGen data.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRInstPrinter.cpp:162,Safety,avoid,avoid,162,"// Not all operands are correctly disassembled at the moment. This means; // that some machine instructions won't have all the necessary operands; // set.; // To avoid asserting, print <unknown> instead until the necessary support; // has been implemented.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRInstPrinter.cpp:168,Testability,assert,asserting,168,"// Not all operands are correctly disassembled at the moment. This means; // that some machine instructions won't have all the necessary operands; // set.; // To avoid asserting, print <unknown> instead until the necessary support; // has been implemented.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRInstPrinter.cpp:162,Safety,avoid,avoid,162,"// Not all operands are correctly disassembled at the moment. This means; // that some machine instructions won't have all the necessary operands; // set.; // To avoid asserting, print <unknown> instead until the necessary support; // has been implemented.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRInstPrinter.cpp:168,Testability,assert,asserting,168,"// Not all operands are correctly disassembled at the moment. This means; // that some machine instructions won't have all the necessary operands; // set.; // To avoid asserting, print <unknown> instead until the necessary support; // has been implemented.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRMCCodeEmitter.cpp:4,Performance,Perform,Performs,4,"/// Performs a post-encoding step on a `LD` or `ST` instruction.; ///; /// The encoding of the LD/ST family of instructions is inconsistent w.r.t; /// the pointer register and the addressing mode.; ///; /// The permutations of the format are as followed:; /// ld Rd, X `1001 000d dddd 1100`; /// ld Rd, X+ `1001 000d dddd 1101`; /// ld Rd, -X `1001 000d dddd 1110`; ///; /// ld Rd, Y `1000 000d dddd 1000`; /// ld Rd, Y+ `1001 000d dddd 1001`; /// ld Rd, -Y `1001 000d dddd 1010`; ///; /// ld Rd, Z `1000 000d dddd 0000`; /// ld Rd, Z+ `1001 000d dddd 0001`; /// ld Rd, -Z `1001 000d dddd 0010`; /// ^; /// |; /// Note this one inconsistent bit - it is 1 sometimes and 0 at other times.; /// There is no logical pattern. Looking at a truth table, the following; /// formula can be derived to fit the pattern:; //; /// ```; /// inconsistent_bit = is_predec OR is_postinc OR is_reg_x; /// ```; //; /// We manually set this bit in this post encoder method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRMCCodeEmitter.cpp:704,Testability,log,logical,704,"/// Performs a post-encoding step on a `LD` or `ST` instruction.; ///; /// The encoding of the LD/ST family of instructions is inconsistent w.r.t; /// the pointer register and the addressing mode.; ///; /// The permutations of the format are as followed:; /// ld Rd, X `1001 000d dddd 1100`; /// ld Rd, X+ `1001 000d dddd 1101`; /// ld Rd, -X `1001 000d dddd 1110`; ///; /// ld Rd, Y `1000 000d dddd 1000`; /// ld Rd, Y+ `1001 000d dddd 1001`; /// ld Rd, -Y `1001 000d dddd 1010`; ///; /// ld Rd, Z `1000 000d dddd 0000`; /// ld Rd, Z+ `1001 000d dddd 0001`; /// ld Rd, -Z `1001 000d dddd 0010`; /// ^; /// |; /// Note this one inconsistent bit - it is 1 sometimes and 0 at other times.; /// There is no logical pattern. Looking at a truth table, the following; /// formula can be derived to fit the pattern:; //; /// ```; /// inconsistent_bit = is_predec OR is_postinc OR is_reg_x; /// ```; //; /// We manually set this bit in this post encoder method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRMCCodeEmitter.cpp:83,Performance,perform,perform,83,"// If the expression is already an AVRMCExpr (i.e. a lo8(symbol),; // we shouldn't perform any more fixups. Without this check, we would; // instead create a fixup to the symbol named 'lo8(symbol)' which; // is not correct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRMCCodeEmitter.h:139,Testability,log,logical,139,/// Finishes up encoding an LD/ST instruction.; /// The purpose of this function is to set an bit in the instruction; /// which follows no logical pattern. See the implementation for details.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRMCCodeEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRMCCodeEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRMCCodeEmitter.h:39,Performance,load,load,39,/// Encodes the `PTRREGS` operand to a load or store instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRMCCodeEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRMCCodeEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRMCELFStreamer.cpp:398,Testability,stub,stub,398,"//===--------- AVRMCELFStreamer.cpp - AVR subclass of MCELFStreamer -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file is a stub that parses a MCInst bundle and passes the; // instructions on to the real streamer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRMCELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRMCELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRMCTargetDesc.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPF.h:26,Integrability,interface,interface,26,"//===-- BPF.h - Top-level interface for BPF representation ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:2714,Availability,avail,available,2714,"e.c.b, the compiler will generate code; // &e + 4; //; // The compile-once run-everywhere instead generates the following code; // r = 4; // &e + r; // The ""4"" in ""r = 4"" can be changed based on a particular kernel version.; // For example, on a particular kernel version, if struct s is changed to; //; // struct s {; // int new_field;; // int a;; // int b;; // }; //; // By repeating the member access on the host, the bpf loader can; // adjust ""r = 4"" as ""r = 8"".; //; // This feature relies on the following three intrinsic calls:; // addr = preserve_array_access_index(base, dimension, index); // addr = preserve_union_access_index(base, di_index); // !llvm.preserve.access.index <union_ditype>; // addr = preserve_struct_access_index(base, gep_index, di_index); // !llvm.preserve.access.index <struct_ditype>; //; // Bitfield member access needs special attention. User cannot take the; // address of a bitfield acceess. To facilitate kernel verifier; // for easy bitfield code optimization, a new clang intrinsic is introduced:; // uint32_t __builtin_preserve_field_info(member_access, info_kind); // In IR, a chain with two (or more) intrinsic calls will be generated:; // ...; // addr = preserve_struct_access_index(base, 1, 1) !struct s; // uint32_t result = bpf_preserve_field_info(addr, info_kind); //; // Suppose the info_kind is FIELD_SIGNEDNESS,; // The above two IR intrinsics will be replaced with; // a relocatable insn:; // signness = /* signness of member_access */; // and signness can be changed by bpf loader based on the; // types on the host.; //; // User can also test whether a field exists or not with; // uint32_t result = bpf_preserve_field_info(member_access, FIELD_EXISTENCE); // The field will be always available (result = 1) during initial; // compilation, but bpf loader can patch with the correct value; // on the target host where the member_access may or may not be available; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:2882,Availability,avail,available,2882,"e.c.b, the compiler will generate code; // &e + 4; //; // The compile-once run-everywhere instead generates the following code; // r = 4; // &e + r; // The ""4"" in ""r = 4"" can be changed based on a particular kernel version.; // For example, on a particular kernel version, if struct s is changed to; //; // struct s {; // int new_field;; // int a;; // int b;; // }; //; // By repeating the member access on the host, the bpf loader can; // adjust ""r = 4"" as ""r = 8"".; //; // This feature relies on the following three intrinsic calls:; // addr = preserve_array_access_index(base, dimension, index); // addr = preserve_union_access_index(base, di_index); // !llvm.preserve.access.index <union_ditype>; // addr = preserve_struct_access_index(base, gep_index, di_index); // !llvm.preserve.access.index <struct_ditype>; //; // Bitfield member access needs special attention. User cannot take the; // address of a bitfield acceess. To facilitate kernel verifier; // for easy bitfield code optimization, a new clang intrinsic is introduced:; // uint32_t __builtin_preserve_field_info(member_access, info_kind); // In IR, a chain with two (or more) intrinsic calls will be generated:; // ...; // addr = preserve_struct_access_index(base, 1, 1) !struct s; // uint32_t result = bpf_preserve_field_info(addr, info_kind); //; // Suppose the info_kind is FIELD_SIGNEDNESS,; // The above two IR intrinsics will be replaced with; // a relocatable insn:; // signness = /* signness of member_access */; // and signness can be changed by bpf loader based on the; // types on the host.; //; // User can also test whether a field exists or not with; // uint32_t result = bpf_preserve_field_info(member_access, FIELD_EXISTENCE); // The field will be always available (result = 1) during initial; // compilation, but bpf loader can patch with the correct value; // on the target host where the member_access may or may not be available; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:2788,Deployability,patch,patch,2788,"e.c.b, the compiler will generate code; // &e + 4; //; // The compile-once run-everywhere instead generates the following code; // r = 4; // &e + r; // The ""4"" in ""r = 4"" can be changed based on a particular kernel version.; // For example, on a particular kernel version, if struct s is changed to; //; // struct s {; // int new_field;; // int a;; // int b;; // }; //; // By repeating the member access on the host, the bpf loader can; // adjust ""r = 4"" as ""r = 8"".; //; // This feature relies on the following three intrinsic calls:; // addr = preserve_array_access_index(base, dimension, index); // addr = preserve_union_access_index(base, di_index); // !llvm.preserve.access.index <union_ditype>; // addr = preserve_struct_access_index(base, gep_index, di_index); // !llvm.preserve.access.index <struct_ditype>; //; // Bitfield member access needs special attention. User cannot take the; // address of a bitfield acceess. To facilitate kernel verifier; // for easy bitfield code optimization, a new clang intrinsic is introduced:; // uint32_t __builtin_preserve_field_info(member_access, info_kind); // In IR, a chain with two (or more) intrinsic calls will be generated:; // ...; // addr = preserve_struct_access_index(base, 1, 1) !struct s; // uint32_t result = bpf_preserve_field_info(addr, info_kind); //; // Suppose the info_kind is FIELD_SIGNEDNESS,; // The above two IR intrinsics will be replaced with; // a relocatable insn:; // signness = /* signness of member_access */; // and signness can be changed by bpf loader based on the; // types on the host.; //; // User can also test whether a field exists or not with; // uint32_t result = bpf_preserve_field_info(member_access, FIELD_EXISTENCE); // The field will be always available (result = 1) during initial; // compilation, but bpf loader can patch with the correct value; // on the target host where the member_access may or may not be available; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:744,Performance,load,loader,744,"//===------ BPFAbstractMemberAccess.cpp - Abstracting Member Accesses -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass abstracted struct/union member accesses in order to support; // compile-once run-everywhere (CO-RE). The CO-RE intends to compile the program; // which can run on different kernels. In particular, if bpf program tries to; // access a particular kernel data structure member, the details of the; // intermediate member access will be remembered so bpf loader can do; // necessary adjustment right before program loading.; //; // For example,; //; // struct s {; // int a;; // int b;; // };; // struct t {; // struct s c;; // int d;; // };; // struct t e;; //; // For the member access e.c.b, the compiler will generate code; // &e + 4; //; // The compile-once run-everywhere instead generates the following code; // r = 4; // &e + r; // The ""4"" in ""r = 4"" can be changed based on a particular kernel version.; // For example, on a particular kernel version, if struct s is changed to; //; // struct s {; // int new_field;; // int a;; // int b;; // }; //; // By repeating the member access on the host, the bpf loader can; // adjust ""r = 4"" as ""r = 8"".; //; // This feature relies on the following three intrinsic calls:; // addr = preserve_array_access_index(base, dimension, index); // addr = preserve_union_access_index(base, di_index); // !llvm.preserve.access.index <union_ditype>; // addr = preserve_struct_access_index(base, gep_index, di_index); // !llvm.preserve.access.index <struct_ditype>; //; // Bitfield member access needs special attention. User cannot take the; // address of a bitfield acceess. To facilitate kernel verifier; // for easy bitfield code optimization, a new clang intrinsic is i",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:804,Performance,load,loading,804,"//===------ BPFAbstractMemberAccess.cpp - Abstracting Member Accesses -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass abstracted struct/union member accesses in order to support; // compile-once run-everywhere (CO-RE). The CO-RE intends to compile the program; // which can run on different kernels. In particular, if bpf program tries to; // access a particular kernel data structure member, the details of the; // intermediate member access will be remembered so bpf loader can do; // necessary adjustment right before program loading.; //; // For example,; //; // struct s {; // int a;; // int b;; // };; // struct t {; // struct s c;; // int d;; // };; // struct t e;; //; // For the member access e.c.b, the compiler will generate code; // &e + 4; //; // The compile-once run-everywhere instead generates the following code; // r = 4; // &e + r; // The ""4"" in ""r = 4"" can be changed based on a particular kernel version.; // For example, on a particular kernel version, if struct s is changed to; //; // struct s {; // int new_field;; // int a;; // int b;; // }; //; // By repeating the member access on the host, the bpf loader can; // adjust ""r = 4"" as ""r = 8"".; //; // This feature relies on the following three intrinsic calls:; // addr = preserve_array_access_index(base, dimension, index); // addr = preserve_union_access_index(base, di_index); // !llvm.preserve.access.index <union_ditype>; // addr = preserve_struct_access_index(base, gep_index, di_index); // !llvm.preserve.access.index <struct_ditype>; //; // Bitfield member access needs special attention. User cannot take the; // address of a bitfield acceess. To facilitate kernel verifier; // for easy bitfield code optimization, a new clang intrinsic is i",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:1402,Performance,load,loader,1402,"------------------------------------------------===//; //; // This pass abstracted struct/union member accesses in order to support; // compile-once run-everywhere (CO-RE). The CO-RE intends to compile the program; // which can run on different kernels. In particular, if bpf program tries to; // access a particular kernel data structure member, the details of the; // intermediate member access will be remembered so bpf loader can do; // necessary adjustment right before program loading.; //; // For example,; //; // struct s {; // int a;; // int b;; // };; // struct t {; // struct s c;; // int d;; // };; // struct t e;; //; // For the member access e.c.b, the compiler will generate code; // &e + 4; //; // The compile-once run-everywhere instead generates the following code; // r = 4; // &e + r; // The ""4"" in ""r = 4"" can be changed based on a particular kernel version.; // For example, on a particular kernel version, if struct s is changed to; //; // struct s {; // int new_field;; // int a;; // int b;; // }; //; // By repeating the member access on the host, the bpf loader can; // adjust ""r = 4"" as ""r = 8"".; //; // This feature relies on the following three intrinsic calls:; // addr = preserve_array_access_index(base, dimension, index); // addr = preserve_union_access_index(base, di_index); // !llvm.preserve.access.index <union_ditype>; // addr = preserve_struct_access_index(base, gep_index, di_index); // !llvm.preserve.access.index <struct_ditype>; //; // Bitfield member access needs special attention. User cannot take the; // address of a bitfield acceess. To facilitate kernel verifier; // for easy bitfield code optimization, a new clang intrinsic is introduced:; // uint32_t __builtin_preserve_field_info(member_access, info_kind); // In IR, a chain with two (or more) intrinsic calls will be generated:; // ...; // addr = preserve_struct_access_index(base, 1, 1) !struct s; // uint32_t result = bpf_preserve_field_info(addr, info_kind); //; // Suppose the info_kind is FI",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:1961,Performance,optimiz,optimization,1961,"e.c.b, the compiler will generate code; // &e + 4; //; // The compile-once run-everywhere instead generates the following code; // r = 4; // &e + r; // The ""4"" in ""r = 4"" can be changed based on a particular kernel version.; // For example, on a particular kernel version, if struct s is changed to; //; // struct s {; // int new_field;; // int a;; // int b;; // }; //; // By repeating the member access on the host, the bpf loader can; // adjust ""r = 4"" as ""r = 8"".; //; // This feature relies on the following three intrinsic calls:; // addr = preserve_array_access_index(base, dimension, index); // addr = preserve_union_access_index(base, di_index); // !llvm.preserve.access.index <union_ditype>; // addr = preserve_struct_access_index(base, gep_index, di_index); // !llvm.preserve.access.index <struct_ditype>; //; // Bitfield member access needs special attention. User cannot take the; // address of a bitfield acceess. To facilitate kernel verifier; // for easy bitfield code optimization, a new clang intrinsic is introduced:; // uint32_t __builtin_preserve_field_info(member_access, info_kind); // In IR, a chain with two (or more) intrinsic calls will be generated:; // ...; // addr = preserve_struct_access_index(base, 1, 1) !struct s; // uint32_t result = bpf_preserve_field_info(addr, info_kind); //; // Suppose the info_kind is FIELD_SIGNEDNESS,; // The above two IR intrinsics will be replaced with; // a relocatable insn:; // signness = /* signness of member_access */; // and signness can be changed by bpf loader based on the; // types on the host.; //; // User can also test whether a field exists or not with; // uint32_t result = bpf_preserve_field_info(member_access, FIELD_EXISTENCE); // The field will be always available (result = 1) during initial; // compilation, but bpf loader can patch with the correct value; // on the target host where the member_access may or may not be available; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:2502,Performance,load,loader,2502,"e.c.b, the compiler will generate code; // &e + 4; //; // The compile-once run-everywhere instead generates the following code; // r = 4; // &e + r; // The ""4"" in ""r = 4"" can be changed based on a particular kernel version.; // For example, on a particular kernel version, if struct s is changed to; //; // struct s {; // int new_field;; // int a;; // int b;; // }; //; // By repeating the member access on the host, the bpf loader can; // adjust ""r = 4"" as ""r = 8"".; //; // This feature relies on the following three intrinsic calls:; // addr = preserve_array_access_index(base, dimension, index); // addr = preserve_union_access_index(base, di_index); // !llvm.preserve.access.index <union_ditype>; // addr = preserve_struct_access_index(base, gep_index, di_index); // !llvm.preserve.access.index <struct_ditype>; //; // Bitfield member access needs special attention. User cannot take the; // address of a bitfield acceess. To facilitate kernel verifier; // for easy bitfield code optimization, a new clang intrinsic is introduced:; // uint32_t __builtin_preserve_field_info(member_access, info_kind); // In IR, a chain with two (or more) intrinsic calls will be generated:; // ...; // addr = preserve_struct_access_index(base, 1, 1) !struct s; // uint32_t result = bpf_preserve_field_info(addr, info_kind); //; // Suppose the info_kind is FIELD_SIGNEDNESS,; // The above two IR intrinsics will be replaced with; // a relocatable insn:; // signness = /* signness of member_access */; // and signness can be changed by bpf loader based on the; // types on the host.; //; // User can also test whether a field exists or not with; // uint32_t result = bpf_preserve_field_info(member_access, FIELD_EXISTENCE); // The field will be always available (result = 1) during initial; // compilation, but bpf loader can patch with the correct value; // on the target host where the member_access may or may not be available; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:2777,Performance,load,loader,2777,"e.c.b, the compiler will generate code; // &e + 4; //; // The compile-once run-everywhere instead generates the following code; // r = 4; // &e + r; // The ""4"" in ""r = 4"" can be changed based on a particular kernel version.; // For example, on a particular kernel version, if struct s is changed to; //; // struct s {; // int new_field;; // int a;; // int b;; // }; //; // By repeating the member access on the host, the bpf loader can; // adjust ""r = 4"" as ""r = 8"".; //; // This feature relies on the following three intrinsic calls:; // addr = preserve_array_access_index(base, dimension, index); // addr = preserve_union_access_index(base, di_index); // !llvm.preserve.access.index <union_ditype>; // addr = preserve_struct_access_index(base, gep_index, di_index); // !llvm.preserve.access.index <struct_ditype>; //; // Bitfield member access needs special attention. User cannot take the; // address of a bitfield acceess. To facilitate kernel verifier; // for easy bitfield code optimization, a new clang intrinsic is introduced:; // uint32_t __builtin_preserve_field_info(member_access, info_kind); // In IR, a chain with two (or more) intrinsic calls will be generated:; // ...; // addr = preserve_struct_access_index(base, 1, 1) !struct s; // uint32_t result = bpf_preserve_field_info(addr, info_kind); //; // Suppose the info_kind is FIELD_SIGNEDNESS,; // The above two IR intrinsics will be replaced with; // a relocatable insn:; // signness = /* signness of member_access */; // and signness can be changed by bpf loader based on the; // types on the host.; //; // User can also test whether a field exists or not with; // uint32_t result = bpf_preserve_field_info(member_access, FIELD_EXISTENCE); // The field will be always available (result = 1) during initial; // compilation, but bpf loader can patch with the correct value; // on the target host where the member_access may or may not be available; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:61,Security,Access,Accesses,61,"//===------ BPFAbstractMemberAccess.cpp - Abstracting Member Accesses -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass abstracted struct/union member accesses in order to support; // compile-once run-everywhere (CO-RE). The CO-RE intends to compile the program; // which can run on different kernels. In particular, if bpf program tries to; // access a particular kernel data structure member, the details of the; // intermediate member access will be remembered so bpf loader can do; // necessary adjustment right before program loading.; //; // For example,; //; // struct s {; // int a;; // int b;; // };; // struct t {; // struct s c;; // int d;; // };; // struct t e;; //; // For the member access e.c.b, the compiler will generate code; // &e + 4; //; // The compile-once run-everywhere instead generates the following code; // r = 4; // &e + r; // The ""4"" in ""r = 4"" can be changed based on a particular kernel version.; // For example, on a particular kernel version, if struct s is changed to; //; // struct s {; // int new_field;; // int a;; // int b;; // }; //; // By repeating the member access on the host, the bpf loader can; // adjust ""r = 4"" as ""r = 8"".; //; // This feature relies on the following three intrinsic calls:; // addr = preserve_array_access_index(base, dimension, index); // addr = preserve_union_access_index(base, di_index); // !llvm.preserve.access.index <union_ditype>; // addr = preserve_struct_access_index(base, gep_index, di_index); // !llvm.preserve.access.index <struct_ditype>; //; // Bitfield member access needs special attention. User cannot take the; // address of a bitfield acceess. To facilitate kernel verifier; // for easy bitfield code optimization, a new clang intrinsic is i",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:424,Security,access,accesses,424,"//===------ BPFAbstractMemberAccess.cpp - Abstracting Member Accesses -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass abstracted struct/union member accesses in order to support; // compile-once run-everywhere (CO-RE). The CO-RE intends to compile the program; // which can run on different kernels. In particular, if bpf program tries to; // access a particular kernel data structure member, the details of the; // intermediate member access will be remembered so bpf loader can do; // necessary adjustment right before program loading.; //; // For example,; //; // struct s {; // int a;; // int b;; // };; // struct t {; // struct s c;; // int d;; // };; // struct t e;; //; // For the member access e.c.b, the compiler will generate code; // &e + 4; //; // The compile-once run-everywhere instead generates the following code; // r = 4; // &e + r; // The ""4"" in ""r = 4"" can be changed based on a particular kernel version.; // For example, on a particular kernel version, if struct s is changed to; //; // struct s {; // int new_field;; // int a;; // int b;; // }; //; // By repeating the member access on the host, the bpf loader can; // adjust ""r = 4"" as ""r = 8"".; //; // This feature relies on the following three intrinsic calls:; // addr = preserve_array_access_index(base, dimension, index); // addr = preserve_union_access_index(base, di_index); // !llvm.preserve.access.index <union_ditype>; // addr = preserve_struct_access_index(base, gep_index, di_index); // !llvm.preserve.access.index <struct_ditype>; //; // Bitfield member access needs special attention. User cannot take the; // address of a bitfield acceess. To facilitate kernel verifier; // for easy bitfield code optimization, a new clang intrinsic is i",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:618,Security,access,access,618,"//===------ BPFAbstractMemberAccess.cpp - Abstracting Member Accesses -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass abstracted struct/union member accesses in order to support; // compile-once run-everywhere (CO-RE). The CO-RE intends to compile the program; // which can run on different kernels. In particular, if bpf program tries to; // access a particular kernel data structure member, the details of the; // intermediate member access will be remembered so bpf loader can do; // necessary adjustment right before program loading.; //; // For example,; //; // struct s {; // int a;; // int b;; // };; // struct t {; // struct s c;; // int d;; // };; // struct t e;; //; // For the member access e.c.b, the compiler will generate code; // &e + 4; //; // The compile-once run-everywhere instead generates the following code; // r = 4; // &e + r; // The ""4"" in ""r = 4"" can be changed based on a particular kernel version.; // For example, on a particular kernel version, if struct s is changed to; //; // struct s {; // int new_field;; // int a;; // int b;; // }; //; // By repeating the member access on the host, the bpf loader can; // adjust ""r = 4"" as ""r = 8"".; //; // This feature relies on the following three intrinsic calls:; // addr = preserve_array_access_index(base, dimension, index); // addr = preserve_union_access_index(base, di_index); // !llvm.preserve.access.index <union_ditype>; // addr = preserve_struct_access_index(base, gep_index, di_index); // !llvm.preserve.access.index <struct_ditype>; //; // Bitfield member access needs special attention. User cannot take the; // address of a bitfield acceess. To facilitate kernel verifier; // for easy bitfield code optimization, a new clang intrinsic is i",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:711,Security,access,access,711,"//===------ BPFAbstractMemberAccess.cpp - Abstracting Member Accesses -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass abstracted struct/union member accesses in order to support; // compile-once run-everywhere (CO-RE). The CO-RE intends to compile the program; // which can run on different kernels. In particular, if bpf program tries to; // access a particular kernel data structure member, the details of the; // intermediate member access will be remembered so bpf loader can do; // necessary adjustment right before program loading.; //; // For example,; //; // struct s {; // int a;; // int b;; // };; // struct t {; // struct s c;; // int d;; // };; // struct t e;; //; // For the member access e.c.b, the compiler will generate code; // &e + 4; //; // The compile-once run-everywhere instead generates the following code; // r = 4; // &e + r; // The ""4"" in ""r = 4"" can be changed based on a particular kernel version.; // For example, on a particular kernel version, if struct s is changed to; //; // struct s {; // int new_field;; // int a;; // int b;; // }; //; // By repeating the member access on the host, the bpf loader can; // adjust ""r = 4"" as ""r = 8"".; //; // This feature relies on the following three intrinsic calls:; // addr = preserve_array_access_index(base, dimension, index); // addr = preserve_union_access_index(base, di_index); // !llvm.preserve.access.index <union_ditype>; // addr = preserve_struct_access_index(base, gep_index, di_index); // !llvm.preserve.access.index <struct_ditype>; //; // Bitfield member access needs special attention. User cannot take the; // address of a bitfield acceess. To facilitate kernel verifier; // for easy bitfield code optimization, a new clang intrinsic is i",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:970,Security,access,access,970,"//===------ BPFAbstractMemberAccess.cpp - Abstracting Member Accesses -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass abstracted struct/union member accesses in order to support; // compile-once run-everywhere (CO-RE). The CO-RE intends to compile the program; // which can run on different kernels. In particular, if bpf program tries to; // access a particular kernel data structure member, the details of the; // intermediate member access will be remembered so bpf loader can do; // necessary adjustment right before program loading.; //; // For example,; //; // struct s {; // int a;; // int b;; // };; // struct t {; // struct s c;; // int d;; // };; // struct t e;; //; // For the member access e.c.b, the compiler will generate code; // &e + 4; //; // The compile-once run-everywhere instead generates the following code; // r = 4; // &e + r; // The ""4"" in ""r = 4"" can be changed based on a particular kernel version.; // For example, on a particular kernel version, if struct s is changed to; //; // struct s {; // int new_field;; // int a;; // int b;; // }; //; // By repeating the member access on the host, the bpf loader can; // adjust ""r = 4"" as ""r = 8"".; //; // This feature relies on the following three intrinsic calls:; // addr = preserve_array_access_index(base, dimension, index); // addr = preserve_union_access_index(base, di_index); // !llvm.preserve.access.index <union_ditype>; // addr = preserve_struct_access_index(base, gep_index, di_index); // !llvm.preserve.access.index <struct_ditype>; //; // Bitfield member access needs special attention. User cannot take the; // address of a bitfield acceess. To facilitate kernel verifier; // for easy bitfield code optimization, a new clang intrinsic is i",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:1374,Security,access,access,1374,"------------------------------------------------===//; //; // This pass abstracted struct/union member accesses in order to support; // compile-once run-everywhere (CO-RE). The CO-RE intends to compile the program; // which can run on different kernels. In particular, if bpf program tries to; // access a particular kernel data structure member, the details of the; // intermediate member access will be remembered so bpf loader can do; // necessary adjustment right before program loading.; //; // For example,; //; // struct s {; // int a;; // int b;; // };; // struct t {; // struct s c;; // int d;; // };; // struct t e;; //; // For the member access e.c.b, the compiler will generate code; // &e + 4; //; // The compile-once run-everywhere instead generates the following code; // r = 4; // &e + r; // The ""4"" in ""r = 4"" can be changed based on a particular kernel version.; // For example, on a particular kernel version, if struct s is changed to; //; // struct s {; // int new_field;; // int a;; // int b;; // }; //; // By repeating the member access on the host, the bpf loader can; // adjust ""r = 4"" as ""r = 8"".; //; // This feature relies on the following three intrinsic calls:; // addr = preserve_array_access_index(base, dimension, index); // addr = preserve_union_access_index(base, di_index); // !llvm.preserve.access.index <union_ditype>; // addr = preserve_struct_access_index(base, gep_index, di_index); // !llvm.preserve.access.index <struct_ditype>; //; // Bitfield member access needs special attention. User cannot take the; // address of a bitfield acceess. To facilitate kernel verifier; // for easy bitfield code optimization, a new clang intrinsic is introduced:; // uint32_t __builtin_preserve_field_info(member_access, info_kind); // In IR, a chain with two (or more) intrinsic calls will be generated:; // ...; // addr = preserve_struct_access_index(base, 1, 1) !struct s; // uint32_t result = bpf_preserve_field_info(addr, info_kind); //; // Suppose the info_kind is FI",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:1649,Security,access,access,1649,"ructure member, the details of the; // intermediate member access will be remembered so bpf loader can do; // necessary adjustment right before program loading.; //; // For example,; //; // struct s {; // int a;; // int b;; // };; // struct t {; // struct s c;; // int d;; // };; // struct t e;; //; // For the member access e.c.b, the compiler will generate code; // &e + 4; //; // The compile-once run-everywhere instead generates the following code; // r = 4; // &e + r; // The ""4"" in ""r = 4"" can be changed based on a particular kernel version.; // For example, on a particular kernel version, if struct s is changed to; //; // struct s {; // int new_field;; // int a;; // int b;; // }; //; // By repeating the member access on the host, the bpf loader can; // adjust ""r = 4"" as ""r = 8"".; //; // This feature relies on the following three intrinsic calls:; // addr = preserve_array_access_index(base, dimension, index); // addr = preserve_union_access_index(base, di_index); // !llvm.preserve.access.index <union_ditype>; // addr = preserve_struct_access_index(base, gep_index, di_index); // !llvm.preserve.access.index <struct_ditype>; //; // Bitfield member access needs special attention. User cannot take the; // address of a bitfield acceess. To facilitate kernel verifier; // for easy bitfield code optimization, a new clang intrinsic is introduced:; // uint32_t __builtin_preserve_field_info(member_access, info_kind); // In IR, a chain with two (or more) intrinsic calls will be generated:; // ...; // addr = preserve_struct_access_index(base, 1, 1) !struct s; // uint32_t result = bpf_preserve_field_info(addr, info_kind); //; // Suppose the info_kind is FIELD_SIGNEDNESS,; // The above two IR intrinsics will be replaced with; // a relocatable insn:; // signness = /* signness of member_access */; // and signness can be changed by bpf loader based on the; // types on the host.; //; // User can also test whether a field exists or not with; // uint32_t result = bpf_preserve_field_info(",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:1763,Security,access,access,1763,"ssary adjustment right before program loading.; //; // For example,; //; // struct s {; // int a;; // int b;; // };; // struct t {; // struct s c;; // int d;; // };; // struct t e;; //; // For the member access e.c.b, the compiler will generate code; // &e + 4; //; // The compile-once run-everywhere instead generates the following code; // r = 4; // &e + r; // The ""4"" in ""r = 4"" can be changed based on a particular kernel version.; // For example, on a particular kernel version, if struct s is changed to; //; // struct s {; // int new_field;; // int a;; // int b;; // }; //; // By repeating the member access on the host, the bpf loader can; // adjust ""r = 4"" as ""r = 8"".; //; // This feature relies on the following three intrinsic calls:; // addr = preserve_array_access_index(base, dimension, index); // addr = preserve_union_access_index(base, di_index); // !llvm.preserve.access.index <union_ditype>; // addr = preserve_struct_access_index(base, gep_index, di_index); // !llvm.preserve.access.index <struct_ditype>; //; // Bitfield member access needs special attention. User cannot take the; // address of a bitfield acceess. To facilitate kernel verifier; // for easy bitfield code optimization, a new clang intrinsic is introduced:; // uint32_t __builtin_preserve_field_info(member_access, info_kind); // In IR, a chain with two (or more) intrinsic calls will be generated:; // ...; // addr = preserve_struct_access_index(base, 1, 1) !struct s; // uint32_t result = bpf_preserve_field_info(addr, info_kind); //; // Suppose the info_kind is FIELD_SIGNEDNESS,; // The above two IR intrinsics will be replaced with; // a relocatable insn:; // signness = /* signness of member_access */; // and signness can be changed by bpf loader based on the; // types on the host.; //; // User can also test whether a field exists or not with; // uint32_t result = bpf_preserve_field_info(member_access, FIELD_EXISTENCE); // The field will be always available (result = 1) during initial; // compilation",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:1816,Security,access,access,1816,"ing.; //; // For example,; //; // struct s {; // int a;; // int b;; // };; // struct t {; // struct s c;; // int d;; // };; // struct t e;; //; // For the member access e.c.b, the compiler will generate code; // &e + 4; //; // The compile-once run-everywhere instead generates the following code; // r = 4; // &e + r; // The ""4"" in ""r = 4"" can be changed based on a particular kernel version.; // For example, on a particular kernel version, if struct s is changed to; //; // struct s {; // int new_field;; // int a;; // int b;; // }; //; // By repeating the member access on the host, the bpf loader can; // adjust ""r = 4"" as ""r = 8"".; //; // This feature relies on the following three intrinsic calls:; // addr = preserve_array_access_index(base, dimension, index); // addr = preserve_union_access_index(base, di_index); // !llvm.preserve.access.index <union_ditype>; // addr = preserve_struct_access_index(base, gep_index, di_index); // !llvm.preserve.access.index <struct_ditype>; //; // Bitfield member access needs special attention. User cannot take the; // address of a bitfield acceess. To facilitate kernel verifier; // for easy bitfield code optimization, a new clang intrinsic is introduced:; // uint32_t __builtin_preserve_field_info(member_access, info_kind); // In IR, a chain with two (or more) intrinsic calls will be generated:; // ...; // addr = preserve_struct_access_index(base, 1, 1) !struct s; // uint32_t result = bpf_preserve_field_info(addr, info_kind); //; // Suppose the info_kind is FIELD_SIGNEDNESS,; // The above two IR intrinsics will be replaced with; // a relocatable insn:; // signness = /* signness of member_access */; // and signness can be changed by bpf loader based on the; // types on the host.; //; // User can also test whether a field exists or not with; // uint32_t result = bpf_preserve_field_info(member_access, FIELD_EXISTENCE); // The field will be always available (result = 1) during initial; // compilation, but bpf loader can patch with the correc",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:2567,Testability,test,test,2567,"e.c.b, the compiler will generate code; // &e + 4; //; // The compile-once run-everywhere instead generates the following code; // r = 4; // &e + r; // The ""4"" in ""r = 4"" can be changed based on a particular kernel version.; // For example, on a particular kernel version, if struct s is changed to; //; // struct s {; // int new_field;; // int a;; // int b;; // }; //; // By repeating the member access on the host, the bpf loader can; // adjust ""r = 4"" as ""r = 8"".; //; // This feature relies on the following three intrinsic calls:; // addr = preserve_array_access_index(base, dimension, index); // addr = preserve_union_access_index(base, di_index); // !llvm.preserve.access.index <union_ditype>; // addr = preserve_struct_access_index(base, gep_index, di_index); // !llvm.preserve.access.index <struct_ditype>; //; // Bitfield member access needs special attention. User cannot take the; // address of a bitfield acceess. To facilitate kernel verifier; // for easy bitfield code optimization, a new clang intrinsic is introduced:; // uint32_t __builtin_preserve_field_info(member_access, info_kind); // In IR, a chain with two (or more) intrinsic calls will be generated:; // ...; // addr = preserve_struct_access_index(base, 1, 1) !struct s; // uint32_t result = bpf_preserve_field_info(addr, info_kind); //; // Suppose the info_kind is FIELD_SIGNEDNESS,; // The above two IR intrinsics will be replaced with; // a relocatable insn:; // signness = /* signness of member_access */; // and signness can be changed by bpf loader based on the; // types on the host.; //; // User can also test whether a field exists or not with; // uint32_t result = bpf_preserve_field_info(member_access, FIELD_EXISTENCE); // The field will be always available (result = 1) during initial; // compilation, but bpf loader can patch with the correct value; // on the target host where the member_access may or may not be available; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:22,Security,access,access,22,/// Check whether the access index chain is valid. We check; /// here because there may be type casts between two; /// access indexes. We want to ensure memory access still valid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:119,Security,access,access,119,/// Check whether the access index chain is valid. We check; /// here because there may be type casts between two; /// access indexes. We want to ensure memory access still valid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:160,Security,access,access,160,/// Check whether the access index chain is valid. We check; /// here because there may be type casts between two; /// access indexes. We want to ensure memory access still valid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:102,Availability,error,error,102,"// If the Bits are within an aligned 8-byte, set the RecordAlignment; // to 8, other report the fatal error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:57,Security,access,accessed,57,// Signedness only checked when final array elements are accessed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:13,Availability,error,error,13,// Report an error if the field expression does not have signedness.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:89,Modifiability,extend,extended,89,"// The value is loaded into a value with FIELD_BYTE_SIZE size,; // and then zero or sign extended to U64.; // FIELD_LSHIFT_U64 and FIELD_RSHIFT_U64 are operations; // to extract the original value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:16,Performance,load,loaded,16,"// The value is loaded into a value with FIELD_BYTE_SIZE size,; // and then zero or sign extended to U64.; // FIELD_LSHIFT_U64 and FIELD_RSHIFT_U64 are operations; // to extract the original value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:21,Availability,error,error,21,"// This is called in error return path, no need to maintain CallStack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:208,Modifiability,variab,variable,208,"/// Compute the base of the whole preserve_* intrinsics chains, i.e., the base; /// pointer of the first preserve_*_access_index call, and construct the access; /// string, which will be the name of a global variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:153,Security,access,access,153,"/// Compute the base of the whole preserve_* intrinsics chains, i.e., the base; /// pointer of the first preserve_*_access_index call, and construct the access; /// string, which will be the name of a global variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:11,Security,access,access,11,// Put the access chain into a stack with the top as the head of the chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:111,Availability,avail,available,111,"// The access offset from the base of the head of chain is also; // calculated here as all debuginfo types are available.; // Get type name and calculate the first index.; // We only want to get type name from typedef, structure or union.; // If user wants a relocation like; // int *p; ... __builtin_preserve_access_index(&p[4]) ...; // or; // int a[10][20]; ... __builtin_preserve_access_index(&a[2][3]) ...; // we will skip them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:7,Security,access,access,7,"// The access offset from the base of the head of chain is also; // calculated here as all debuginfo types are available.; // Get type name and calculate the first index.; // We only want to get type name from typedef, structure or union.; // If user wants a relocation like; // int *p; ... __builtin_preserve_access_index(&p[4]) ...; // or; // int a[10][20]; ... __builtin_preserve_access_index(&a[2][3]) ...; // we will skip them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:3,Security,Access,AccessOffset,3,// AccessOffset or the requested field info,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:24,Security,access,access,24,// Traverse the rest of access chain to complete offset calculation; // and access key construction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:76,Security,access,access,76,// Traverse the rest of access chain to complete offset calculation; // and access key construction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:3,Security,Access,Access,3,// Access Index,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:72,Deployability,patch,patched,72,"// Access key is the; // ""llvm."" + type name + "":"" + reloc type + "":"" + patched imm + ""$"" +; // access string,; // uniquely identifying one relocation.; // The prefix ""llvm."" indicates this is a temporary global, which should; // not be emitted to ELF file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:3,Security,Access,Access,3,"// Access key is the; // ""llvm."" + type name + "":"" + reloc type + "":"" + patched imm + ""$"" +; // access string,; // uniquely identifying one relocation.; // The prefix ""llvm."" indicates this is a temporary global, which should; // not be emitted to ELF file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:96,Security,access,access,96,"// Access key is the; // ""llvm."" + type name + "":"" + reloc type + "":"" + patched imm + ""$"" +; // access string,; // uniquely identifying one relocation.; // The prefix ""llvm."" indicates this is a temporary global, which should; // not be emitted to ELF file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:97,Integrability,depend,depending,97,// The argument could be a global variable or a getelementptr with base to; // a global variable depending on whether the clang option `opaque-options`; // is set or not.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:34,Modifiability,variab,variable,34,// The argument could be a global variable or a getelementptr with base to; // a global variable depending on whether the clang option `opaque-options`; // is set or not.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:88,Modifiability,variab,variable,88,// The argument could be a global variable or a getelementptr with base to; // a global variable depending on whether the clang option `opaque-options`; // is set or not.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:19,Modifiability,variab,variable,19,// Load the global variable which represents the returned field info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:3,Performance,Load,Load,3,// Load the global variable which represents the returned field info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:366,Modifiability,variab,variable,366,"// For any original GEP Call and Base %2 like; // %4 = bitcast %struct.net_device** %dev1 to i64*; // it is transformed to:; // %6 = load llvm.sk_buff:0:50$0:0:0:2:0; // %7 = bitcast %struct.sk_buff* %2 to i8*; // %8 = getelementptr i8, i8* %7, %6; // %9 = bitcast i8* %8 to i64*; // using %9 instead of %4; // The original Call inst is removed.; // Load the global variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:133,Performance,load,load,133,"// For any original GEP Call and Base %2 like; // %4 = bitcast %struct.net_device** %dev1 to i64*; // it is transformed to:; // %6 = load llvm.sk_buff:0:50$0:0:0:2:0; // %7 = bitcast %struct.sk_buff* %2 to i8*; // %8 = getelementptr i8, i8* %7, %6; // %9 = bitcast i8* %8 to i64*; // using %9 instead of %4; // The original Call inst is removed.; // Load the global variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:350,Performance,Load,Load,350,"// For any original GEP Call and Base %2 like; // %4 = bitcast %struct.net_device** %dev1 to i64*; // it is transformed to:; // %6 = load llvm.sk_buff:0:50$0:0:0:2:0; // %7 = bitcast %struct.sk_buff* %2 to i8*; // %8 = getelementptr i8, i8* %7, %6; // %9 = bitcast i8* %8 to i64*; // using %9 instead of %4; // The original Call inst is removed.; // Load the global variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:102,Performance,load,load,102,"// For the following code,; // Block0:; // ...; // if (...) goto Block1 else ...; // Block1:; // %6 = load llvm.sk_buff:0:50$0:0:0:2:0; // %7 = bitcast %struct.sk_buff* %2 to i8*; // %8 = getelementptr i8, i8* %7, %6; // ...; // goto CommonExit; // Block2:; // ...; // if (...) goto Block3 else ...; // Block3:; // %6 = load llvm.bpf_map:0:40$0:0:0:2:0; // %7 = bitcast %struct.sk_buff* %2 to i8*; // %8 = getelementptr i8, i8* %7, %6; // ...; // goto CommonExit; // CommonExit; // SimplifyCFG may generate:; // Block0:; // ...; // if (...) goto Block_Common else ...; // Block2:; // ...; // if (...) goto Block_Common else ...; // Block_Common:; // PHI = [llvm.sk_buff:0:50$0:0:0:2:0, llvm.bpf_map:0:40$0:0:0:2:0]; // %6 = load PHI; // %7 = bitcast %struct.sk_buff* %2 to i8*; // %8 = getelementptr i8, i8* %7, %6; // ...; // goto CommonExit; // For the above code, we cannot perform proper relocation since; // ""load PHI"" has two possible relocations.; //; // To prevent above tail merging, we use __builtin_bpf_passthrough(); // where one of its parameters is a seq_num. Since two; // __builtin_bpf_passthrough() funcs will always have different seq_num,; // tail merging cannot happen. The __builtin_bpf_passthrough() will be; // removed in the beginning of Target IR passes.; //; // This approach is also used in other places when global var; // representing a relocation is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:320,Performance,load,load,320,"// For the following code,; // Block0:; // ...; // if (...) goto Block1 else ...; // Block1:; // %6 = load llvm.sk_buff:0:50$0:0:0:2:0; // %7 = bitcast %struct.sk_buff* %2 to i8*; // %8 = getelementptr i8, i8* %7, %6; // ...; // goto CommonExit; // Block2:; // ...; // if (...) goto Block3 else ...; // Block3:; // %6 = load llvm.bpf_map:0:40$0:0:0:2:0; // %7 = bitcast %struct.sk_buff* %2 to i8*; // %8 = getelementptr i8, i8* %7, %6; // ...; // goto CommonExit; // CommonExit; // SimplifyCFG may generate:; // Block0:; // ...; // if (...) goto Block_Common else ...; // Block2:; // ...; // if (...) goto Block_Common else ...; // Block_Common:; // PHI = [llvm.sk_buff:0:50$0:0:0:2:0, llvm.bpf_map:0:40$0:0:0:2:0]; // %6 = load PHI; // %7 = bitcast %struct.sk_buff* %2 to i8*; // %8 = getelementptr i8, i8* %7, %6; // ...; // goto CommonExit; // For the above code, we cannot perform proper relocation since; // ""load PHI"" has two possible relocations.; //; // To prevent above tail merging, we use __builtin_bpf_passthrough(); // where one of its parameters is a seq_num. Since two; // __builtin_bpf_passthrough() funcs will always have different seq_num,; // tail merging cannot happen. The __builtin_bpf_passthrough() will be; // removed in the beginning of Target IR passes.; //; // This approach is also used in other places when global var; // representing a relocation is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:724,Performance,load,load,724,"// For the following code,; // Block0:; // ...; // if (...) goto Block1 else ...; // Block1:; // %6 = load llvm.sk_buff:0:50$0:0:0:2:0; // %7 = bitcast %struct.sk_buff* %2 to i8*; // %8 = getelementptr i8, i8* %7, %6; // ...; // goto CommonExit; // Block2:; // ...; // if (...) goto Block3 else ...; // Block3:; // %6 = load llvm.bpf_map:0:40$0:0:0:2:0; // %7 = bitcast %struct.sk_buff* %2 to i8*; // %8 = getelementptr i8, i8* %7, %6; // ...; // goto CommonExit; // CommonExit; // SimplifyCFG may generate:; // Block0:; // ...; // if (...) goto Block_Common else ...; // Block2:; // ...; // if (...) goto Block_Common else ...; // Block_Common:; // PHI = [llvm.sk_buff:0:50$0:0:0:2:0, llvm.bpf_map:0:40$0:0:0:2:0]; // %6 = load PHI; // %7 = bitcast %struct.sk_buff* %2 to i8*; // %8 = getelementptr i8, i8* %7, %6; // ...; // goto CommonExit; // For the above code, we cannot perform proper relocation since; // ""load PHI"" has two possible relocations.; //; // To prevent above tail merging, we use __builtin_bpf_passthrough(); // where one of its parameters is a seq_num. Since two; // __builtin_bpf_passthrough() funcs will always have different seq_num,; // tail merging cannot happen. The __builtin_bpf_passthrough() will be; // removed in the beginning of Target IR passes.; //; // This approach is also used in other places when global var; // representing a relocation is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:877,Performance,perform,perform,877,"// For the following code,; // Block0:; // ...; // if (...) goto Block1 else ...; // Block1:; // %6 = load llvm.sk_buff:0:50$0:0:0:2:0; // %7 = bitcast %struct.sk_buff* %2 to i8*; // %8 = getelementptr i8, i8* %7, %6; // ...; // goto CommonExit; // Block2:; // ...; // if (...) goto Block3 else ...; // Block3:; // %6 = load llvm.bpf_map:0:40$0:0:0:2:0; // %7 = bitcast %struct.sk_buff* %2 to i8*; // %8 = getelementptr i8, i8* %7, %6; // ...; // goto CommonExit; // CommonExit; // SimplifyCFG may generate:; // Block0:; // ...; // if (...) goto Block_Common else ...; // Block2:; // ...; // if (...) goto Block_Common else ...; // Block_Common:; // PHI = [llvm.sk_buff:0:50$0:0:0:2:0, llvm.bpf_map:0:40$0:0:0:2:0]; // %6 = load PHI; // %7 = bitcast %struct.sk_buff* %2 to i8*; // %8 = getelementptr i8, i8* %7, %6; // ...; // goto CommonExit; // For the above code, we cannot perform proper relocation since; // ""load PHI"" has two possible relocations.; //; // To prevent above tail merging, we use __builtin_bpf_passthrough(); // where one of its parameters is a seq_num. Since two; // __builtin_bpf_passthrough() funcs will always have different seq_num,; // tail merging cannot happen. The __builtin_bpf_passthrough() will be; // removed in the beginning of Target IR passes.; //; // This approach is also used in other places when global var; // representing a relocation is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:914,Performance,load,load,914,"// For the following code,; // Block0:; // ...; // if (...) goto Block1 else ...; // Block1:; // %6 = load llvm.sk_buff:0:50$0:0:0:2:0; // %7 = bitcast %struct.sk_buff* %2 to i8*; // %8 = getelementptr i8, i8* %7, %6; // ...; // goto CommonExit; // Block2:; // ...; // if (...) goto Block3 else ...; // Block3:; // %6 = load llvm.bpf_map:0:40$0:0:0:2:0; // %7 = bitcast %struct.sk_buff* %2 to i8*; // %8 = getelementptr i8, i8* %7, %6; // ...; // goto CommonExit; // CommonExit; // SimplifyCFG may generate:; // Block0:; // ...; // if (...) goto Block_Common else ...; // Block2:; // ...; // if (...) goto Block_Common else ...; // Block_Common:; // PHI = [llvm.sk_buff:0:50$0:0:0:2:0, llvm.bpf_map:0:40$0:0:0:2:0]; // %6 = load PHI; // %7 = bitcast %struct.sk_buff* %2 to i8*; // %8 = getelementptr i8, i8* %7, %6; // ...; // goto CommonExit; // For the above code, we cannot perform proper relocation since; // ""load PHI"" has two possible relocations.; //; // To prevent above tail merging, we use __builtin_bpf_passthrough(); // where one of its parameters is a seq_num. Since two; // __builtin_bpf_passthrough() funcs will always have different seq_num,; // tail merging cannot happen. The __builtin_bpf_passthrough() will be; // removed in the beginning of Target IR passes.; //; // This approach is also used in other places when global var; // representing a relocation is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:482,Usability,Simpl,SimplifyCFG,482,"// For the following code,; // Block0:; // ...; // if (...) goto Block1 else ...; // Block1:; // %6 = load llvm.sk_buff:0:50$0:0:0:2:0; // %7 = bitcast %struct.sk_buff* %2 to i8*; // %8 = getelementptr i8, i8* %7, %6; // ...; // goto CommonExit; // Block2:; // ...; // if (...) goto Block3 else ...; // Block3:; // %6 = load llvm.bpf_map:0:40$0:0:0:2:0; // %7 = bitcast %struct.sk_buff* %2 to i8*; // %8 = getelementptr i8, i8* %7, %6; // ...; // goto CommonExit; // CommonExit; // SimplifyCFG may generate:; // Block0:; // ...; // if (...) goto Block_Common else ...; // Block2:; // ...; // if (...) goto Block_Common else ...; // Block_Common:; // PHI = [llvm.sk_buff:0:50$0:0:0:2:0, llvm.bpf_map:0:40$0:0:0:2:0]; // %6 = load PHI; // %7 = bitcast %struct.sk_buff* %2 to i8*; // %8 = getelementptr i8, i8* %7, %6; // ...; // goto CommonExit; // For the above code, we cannot perform proper relocation since; // ""load PHI"" has two possible relocations.; //; // To prevent above tail merging, we use __builtin_bpf_passthrough(); // where one of its parameters is a seq_num. Since two; // __builtin_bpf_passthrough() funcs will always have different seq_num,; // tail merging cannot happen. The __builtin_bpf_passthrough() will be; // removed in the beginning of Target IR passes.; //; // This approach is also used in other places when global var; // representing a relocation is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:105,Security,access,access,105,// Collect PreserveDIAccessIndex Intrinsic call chains.; // The call chains will be used to generate the access; // patterns similar to GEP.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAdjustOpt.cpp:48,Performance,Optimiz,Optimization,48,"//===---------------- BPFAdjustOpt.cpp - Adjust Optimization --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Adjust optimization to make the code more kernel verifier friendly.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAdjustOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAdjustOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAdjustOpt.cpp:390,Performance,optimiz,optimization,390,"//===---------------- BPFAdjustOpt.cpp - Adjust Optimization --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Adjust optimization to make the code more kernel verifier friendly.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAdjustOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAdjustOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAdjustOpt.cpp:87,Availability,mask,mask,87,"// Commit acabad9ff6bf (""[InstCombine] try to canonicalize icmp with; // trunc op into mask and cmp"") added a transformation to; // convert ""(conv)a < power_2_const"" to ""a & <const>"" in certain; // cases and bpf kernel verifier has to handle the resulted code; // conservatively and this may reject otherwise legitimate program.; // Here, we change related icmp code to a builtin which will; // be restored to original icmp code later to prevent that; // InstCombine transformatin.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAdjustOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAdjustOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAdjustOpt.cpp:79,Performance,optimiz,optimization,79,// To avoid combining conditionals in the same basic block by; // instrcombine optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAdjustOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAdjustOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAdjustOpt.cpp:6,Safety,avoid,avoid,6,// To avoid combining conditionals in the same basic block by; // instrcombine optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAdjustOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAdjustOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAdjustOpt.cpp:7,Testability,Log,LogicalOr,7,"// Use LogicalOr (accept `or i1` as well as `select i1 Op0, true, Op1`)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAdjustOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAdjustOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAdjustOpt.cpp:79,Performance,optimiz,optimization,79,// To avoid combining conditionals in the same basic block by; // instrcombine optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAdjustOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAdjustOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAdjustOpt.cpp:6,Safety,avoid,avoid,6,// To avoid combining conditionals in the same basic block by; // instrcombine optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAdjustOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAdjustOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAdjustOpt.cpp:6,Safety,avoid,avoid,6,// To avoid speculative hoisting certain computations out of; // a basic block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAdjustOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAdjustOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAdjustOpt.cpp:61,Performance,load,load,61,"// use in a different basic block, If there is a call or; // load/store insn before this instruction in this basic; // block. Most likely it cannot be hoisted out. Skip it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAdjustOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAdjustOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAdjustOpt.cpp:35,Usability,simpl,simple,35,// It should be used in a GEP or a simple arithmetic like; // ZEXT/SEXT which is used for GEP.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAdjustOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAdjustOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAsmPrinter.cpp:474,Integrability,depend,dependent,474,"//===-- BPFAsmPrinter.cpp - BPF LLVM assembly writer ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a printer that converts from our internal representation; // of machine-dependent LLVM code to the BPF assembly language.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAsmPrinter.cpp:32,Availability,avail,available,32,// Only emit BTF when debuginfo available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFCheckAndAdjustIR.cpp:641,Performance,optimiz,optimizations,641,"//===------------ BPFCheckAndAdjustIR.cpp - Check and Adjust IR -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Check IR and adjust IR for verifier friendly codes.; // The following are done for IR checking:; // - no relocation globals in PHI node.; // The following are done for IR adjustment:; // - remove __builtin_bpf_passthrough builtins. Target independent IR; // optimizations are done and those builtins can be removed.; // - remove llvm.bpf.getelementptr.and.load builtins.; // - remove llvm.bpf.getelementptr.and.store builtins.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFCheckAndAdjustIR.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFCheckAndAdjustIR.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFCheckAndAdjustIR.cpp:739,Performance,load,load,739,"//===------------ BPFCheckAndAdjustIR.cpp - Check and Adjust IR -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Check IR and adjust IR for verifier friendly codes.; // The following are done for IR checking:; // - no relocation globals in PHI node.; // The following are done for IR adjustment:; // - remove __builtin_bpf_passthrough builtins. Target independent IR; // optimizations are done and those builtins can be removed.; // - remove llvm.bpf.getelementptr.and.load builtins.; // - remove llvm.bpf.getelementptr.and.store builtins.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFCheckAndAdjustIR.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFCheckAndAdjustIR.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFCheckAndAdjustIR.cpp:371,Availability,error,error,371,"// Ensure relocation global won't appear in PHI node; // This may happen if the compiler generated the following code:; // B1:; // g1 = @llvm.skb_buff:0:1...; // ...; // goto B_COMMON; // B2:; // g2 = @llvm.skb_buff:0:2...; // ...; // goto B_COMMON; // B_COMMON:; // g = PHI(g1, g2); // x = load g; // ...; // If anything likes the above ""g = PHI(g1, g2)"", issue a fatal error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFCheckAndAdjustIR.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFCheckAndAdjustIR.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFCheckAndAdjustIR.cpp:291,Performance,load,load,291,"// Ensure relocation global won't appear in PHI node; // This may happen if the compiler generated the following code:; // B1:; // g1 = @llvm.skb_buff:0:1...; // ...; // goto B_COMMON; // B2:; // g2 = @llvm.skb_buff:0:2...; // ...; // goto B_COMMON; // B_COMMON:; // g = PHI(g1, g2); // x = load g; // ...; // If anything likes the above ""g = PHI(g1, g2)"", issue a fatal error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFCheckAndAdjustIR.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFCheckAndAdjustIR.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFCheckAndAdjustIR.cpp:81,Performance,optimiz,optimizations,81,"// Remove __builtin_bpf_passthrough()'s which are used to prevent; // certain IR optimizations. Now major IR optimizations are done,; // remove them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFCheckAndAdjustIR.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFCheckAndAdjustIR.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFCheckAndAdjustIR.cpp:109,Performance,optimiz,optimizations,109,"// Remove __builtin_bpf_passthrough()'s which are used to prevent; // certain IR optimizations. Now major IR optimizations are done,; // remove them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFCheckAndAdjustIR.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFCheckAndAdjustIR.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFCheckAndAdjustIR.cpp:77,Performance,optimiz,optimizations,77,"// Remove __builtin_bpf_compare()'s which are used to prevent; // certain IR optimizations. Now major IR optimizations are done,; // remove them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFCheckAndAdjustIR.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFCheckAndAdjustIR.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFCheckAndAdjustIR.cpp:105,Performance,optimiz,optimizations,105,"// Remove __builtin_bpf_compare()'s which are used to prevent; // certain IR optimizations. Now major IR optimizations are done,; // remove them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFCheckAndAdjustIR.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFCheckAndAdjustIR.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFCheckAndAdjustIR.cpp:301,Availability,failure,failures,301,"// Do the following transformation:; //; // x < min(a, b) -> x < a && x < b; // x > min(a, b) -> x > a || x > b; // x < max(a, b) -> x < a || x < b; // x > max(a, b) -> x > a && x > b; //; // Such patterns are introduced by LICM.cpp:hoistMinMax(); // transformation and might lead to BPF verification failures for; // older kernels.; //; // To minimize ""collateral"" changes only do it for icmp + min/max; // calls when icmp is inside a loop and min/max is outside of that; // loop.; //; // Verification failure happens when:; // - RHS operand of some `icmp LHS, RHS` is replaced by some RHS1;; // - verifier can recognize RHS as a constant scalar in some context;; // - verifier can't recognize RHS1 as a constant scalar in the same; // context;; //; // The ""constant scalar"" is not a compile time constant, but a register; // that holds a scalar value known to verifier at some point in time; // during abstract interpretation.; //; // See also:; // https://lore.kernel.org/bpf/20230406164505.1046801-1-yhs@fb.com/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFCheckAndAdjustIR.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFCheckAndAdjustIR.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFCheckAndAdjustIR.cpp:503,Availability,failure,failure,503,"// Do the following transformation:; //; // x < min(a, b) -> x < a && x < b; // x > min(a, b) -> x > a || x > b; // x < max(a, b) -> x < a || x < b; // x > max(a, b) -> x > a && x > b; //; // Such patterns are introduced by LICM.cpp:hoistMinMax(); // transformation and might lead to BPF verification failures for; // older kernels.; //; // To minimize ""collateral"" changes only do it for icmp + min/max; // calls when icmp is inside a loop and min/max is outside of that; // loop.; //; // Verification failure happens when:; // - RHS operand of some `icmp LHS, RHS` is replaced by some RHS1;; // - verifier can recognize RHS as a constant scalar in some context;; // - verifier can't recognize RHS1 as a constant scalar in the same; // context;; //; // The ""constant scalar"" is not a compile time constant, but a register; // that holds a scalar value known to verifier at some point in time; // during abstract interpretation.; //; // See also:; // https://lore.kernel.org/bpf/20230406164505.1046801-1-yhs@fb.com/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFCheckAndAdjustIR.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFCheckAndAdjustIR.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFCheckAndAdjustIR.cpp:3,Modifiability,Rewrite,Rewrites,3,// Rewrites the following builtins:; // - llvm.bpf.getelementptr.and.load; // - llvm.bpf.getelementptr.and.store; // As (load (getelementptr ...)) or (store (getelementptr ...)).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFCheckAndAdjustIR.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFCheckAndAdjustIR.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFCheckAndAdjustIR.cpp:69,Performance,load,load,69,// Rewrites the following builtins:; // - llvm.bpf.getelementptr.and.load; // - llvm.bpf.getelementptr.and.store; // As (load (getelementptr ...)) or (store (getelementptr ...)).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFCheckAndAdjustIR.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFCheckAndAdjustIR.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFCheckAndAdjustIR.cpp:121,Performance,load,load,121,// Rewrites the following builtins:; // - llvm.bpf.getelementptr.and.load; // - llvm.bpf.getelementptr.and.store; // As (load (getelementptr ...)) or (store (getelementptr ...)).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFCheckAndAdjustIR.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFCheckAndAdjustIR.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFCORE.h:59,Security,access,access,59,/// The attribute attached to globals representing a field access,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFCORE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFCORE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFIRPeephole.cpp:401,Performance,optimiz,optimization,401,"//===------------ BPFIRPeephole.cpp - IR Peephole Transformation ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // IR level peephole optimization, specifically removing @llvm.stacksave() and; // @llvm.stackrestore().; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFIRPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFIRPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFIRPeephole.cpp:519,Integrability,depend,depending,519,"// The following code pattern is handled:; // %3 = call i8* @llvm.stacksave(); // store i8* %3, i8** %saved_stack, align 8; // ...; // %4 = load i8*, i8** %saved_stack, align 8; // call void @llvm.stackrestore(i8* %4); // ...; // The goal is to remove the above four instructions,; // so we won't have instructions with r11 (stack pointer); // if eventually there is no variable length stack allocation.; // InstrCombine also tries to remove the above instructions,; // if it is proven safe (constant alloca etc.), but depending; // on code pattern, it may still miss some.; //; // With unconditionally removing these instructions, if alloca is; // constant, we are okay then. Otherwise, SelectionDag will complain; // since BPF does not support dynamic allocation yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFIRPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFIRPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFIRPeephole.cpp:370,Modifiability,variab,variable,370,"// The following code pattern is handled:; // %3 = call i8* @llvm.stacksave(); // store i8* %3, i8** %saved_stack, align 8; // ...; // %4 = load i8*, i8** %saved_stack, align 8; // call void @llvm.stackrestore(i8* %4); // ...; // The goal is to remove the above four instructions,; // so we won't have instructions with r11 (stack pointer); // if eventually there is no variable length stack allocation.; // InstrCombine also tries to remove the above instructions,; // if it is proven safe (constant alloca etc.), but depending; // on code pattern, it may still miss some.; //; // With unconditionally removing these instructions, if alloca is; // constant, we are okay then. Otherwise, SelectionDag will complain; // since BPF does not support dynamic allocation yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFIRPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFIRPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFIRPeephole.cpp:140,Performance,load,load,140,"// The following code pattern is handled:; // %3 = call i8* @llvm.stacksave(); // store i8* %3, i8** %saved_stack, align 8; // ...; // %4 = load i8*, i8** %saved_stack, align 8; // call void @llvm.stackrestore(i8* %4); // ...; // The goal is to remove the above four instructions,; // so we won't have instructions with r11 (stack pointer); // if eventually there is no variable length stack allocation.; // InstrCombine also tries to remove the above instructions,; // if it is proven safe (constant alloca etc.), but depending; // on code pattern, it may still miss some.; //; // With unconditionally removing these instructions, if alloca is; // constant, we are okay then. Otherwise, SelectionDag will complain; // since BPF does not support dynamic allocation yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFIRPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFIRPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFIRPeephole.cpp:486,Safety,safe,safe,486,"// The following code pattern is handled:; // %3 = call i8* @llvm.stacksave(); // store i8* %3, i8** %saved_stack, align 8; // ...; // %4 = load i8*, i8** %saved_stack, align 8; // call void @llvm.stackrestore(i8* %4); // ...; // The goal is to remove the above four instructions,; // so we won't have instructions with r11 (stack pointer); // if eventually there is no variable length stack allocation.; // InstrCombine also tries to remove the above instructions,; // if it is proven safe (constant alloca etc.), but depending; // on code pattern, it may still miss some.; //; // With unconditionally removing these instructions, if alloca is; // constant, we are okay then. Otherwise, SelectionDag will complain; // since BPF does not support dynamic allocation yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFIRPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFIRPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelDAGToDAG.cpp:30,Performance,Load,Load,30,// ComplexPattern used on BPF Load/Store instructions,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelDAGToDAG.cpp:41,Performance,load,loads,41,// hold up the constant values replacing loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelDAGToDAG.cpp:9,Safety,safe,safe,9,// It is safe to delete node now,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelDAGToDAG.cpp:265,Availability,redundant,redundant,265,"// Iterate through all nodes, interested in the following case:; //; // . loads from ConstantStruct or ConstantArray of constructs; // which can be turns into constant itself, with this we can; // avoid reading from read-only section at runtime.; //; // . Removing redundant AND for intrinsic narrow loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelDAGToDAG.cpp:74,Performance,load,loads,74,"// Iterate through all nodes, interested in the following case:; //; // . loads from ConstantStruct or ConstantArray of constructs; // which can be turns into constant itself, with this we can; // avoid reading from read-only section at runtime.; //; // . Removing redundant AND for intrinsic narrow loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelDAGToDAG.cpp:300,Performance,load,loads,300,"// Iterate through all nodes, interested in the following case:; //; // . loads from ConstantStruct or ConstantArray of constructs; // which can be turns into constant itself, with this we can; // avoid reading from read-only section at runtime.; //; // . Removing redundant AND for intrinsic narrow loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelDAGToDAG.cpp:197,Safety,avoid,avoid,197,"// Iterate through all nodes, interested in the following case:; //; // . loads from ConstantStruct or ConstantArray of constructs; // which can be turns into constant itself, with this we can; // avoid reading from read-only section at runtime.; //; // . Removing redundant AND for intrinsic narrow loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelDAGToDAG.cpp:265,Safety,redund,redundant,265,"// Iterate through all nodes, interested in the following case:; //; // . loads from ConstantStruct or ConstantArray of constructs; // which can be turns into constant itself, with this we can; // avoid reading from read-only section at runtime.; //; // . Removing redundant AND for intrinsic narrow loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelDAGToDAG.cpp:3,Testability,test,test,3,// test whether host endianness matches target,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelDAGToDAG.cpp:353,Modifiability,extend,extended,353,"// The Reg operand should be a virtual register, which is defined; // outside the current basic block. DAG combiner has done a pretty; // good job in removing truncating inside a single basic block except; // when the Reg operand comes from bpf_load_[byte | half | word] for; // which the generic optimizer doesn't understand their results are; // zero extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelDAGToDAG.cpp:297,Performance,optimiz,optimizer,297,"// The Reg operand should be a virtual register, which is defined; // outside the current basic block. DAG combiner has done a pretty; // good job in removing truncating inside a single basic block except; // when the Reg operand comes from bpf_load_[byte | half | word] for; // which the generic optimizer doesn't understand their results are; // zero extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp:404,Integrability,interface,interfaces,404,"//===-- BPFISelLowering.cpp - BPF DAG Lowering Implementation ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that BPF uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp:73,Availability,error,error,73,// Set unsupported atomic operations as Custom so; // we can emit better error messages than fatal error; // from selectiondag.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp:99,Availability,error,error,99,// Set unsupported atomic operations as Custom so; // we can emit better error messages than fatal error; // from selectiondag.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp:79,Integrability,message,messages,79,// Set unsupported atomic operations as Custom so; // we can emit better error messages than fatal error; // from selectiondag.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp:3,Modifiability,Extend,Extended,3,// Extended load operations for i1 types must be promoted,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp:12,Performance,load,load,12,// Extended load operations for i1 types must be promoted,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp:444,Deployability,pipeline,pipeline,444,"// LLVM generic code will try to expand memcpy into load/store pairs at this; // stage which is before quite a few IR optimization passes, therefore the; // loads and stores could potentially be moved apart from each other which; // will cause trouble to memcpy pattern matcher inside kernel eBPF JIT; // compilers.; //; // When -bpf-expand-memcpy-in-order specified, we want to defer the expand; // of memcpy to later stage in IR optimization pipeline so those load/store; // pairs won't be touched and could be kept in order. Hence, we set; // MaxStoresPerMem* to zero to disable the generic getMemcpyLoadsAndStores; // code path, and ask LLVM to use target expander EmitTargetCodeForMemcpy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp:52,Performance,load,load,52,"// LLVM generic code will try to expand memcpy into load/store pairs at this; // stage which is before quite a few IR optimization passes, therefore the; // loads and stores could potentially be moved apart from each other which; // will cause trouble to memcpy pattern matcher inside kernel eBPF JIT; // compilers.; //; // When -bpf-expand-memcpy-in-order specified, we want to defer the expand; // of memcpy to later stage in IR optimization pipeline so those load/store; // pairs won't be touched and could be kept in order. Hence, we set; // MaxStoresPerMem* to zero to disable the generic getMemcpyLoadsAndStores; // code path, and ask LLVM to use target expander EmitTargetCodeForMemcpy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp:118,Performance,optimiz,optimization,118,"// LLVM generic code will try to expand memcpy into load/store pairs at this; // stage which is before quite a few IR optimization passes, therefore the; // loads and stores could potentially be moved apart from each other which; // will cause trouble to memcpy pattern matcher inside kernel eBPF JIT; // compilers.; //; // When -bpf-expand-memcpy-in-order specified, we want to defer the expand; // of memcpy to later stage in IR optimization pipeline so those load/store; // pairs won't be touched and could be kept in order. Hence, we set; // MaxStoresPerMem* to zero to disable the generic getMemcpyLoadsAndStores; // code path, and ask LLVM to use target expander EmitTargetCodeForMemcpy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp:157,Performance,load,loads,157,"// LLVM generic code will try to expand memcpy into load/store pairs at this; // stage which is before quite a few IR optimization passes, therefore the; // loads and stores could potentially be moved apart from each other which; // will cause trouble to memcpy pattern matcher inside kernel eBPF JIT; // compilers.; //; // When -bpf-expand-memcpy-in-order specified, we want to defer the expand; // of memcpy to later stage in IR optimization pipeline so those load/store; // pairs won't be touched and could be kept in order. Hence, we set; // MaxStoresPerMem* to zero to disable the generic getMemcpyLoadsAndStores; // code path, and ask LLVM to use target expander EmitTargetCodeForMemcpy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp:431,Performance,optimiz,optimization,431,"// LLVM generic code will try to expand memcpy into load/store pairs at this; // stage which is before quite a few IR optimization passes, therefore the; // loads and stores could potentially be moved apart from each other which; // will cause trouble to memcpy pattern matcher inside kernel eBPF JIT; // compilers.; //; // When -bpf-expand-memcpy-in-order specified, we want to defer the expand; // of memcpy to later stage in IR optimization pipeline so those load/store; // pairs won't be touched and could be kept in order. Hence, we set; // MaxStoresPerMem* to zero to disable the generic getMemcpyLoadsAndStores; // code path, and ask LLVM to use target expander EmitTargetCodeForMemcpy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp:462,Performance,load,load,462,"// LLVM generic code will try to expand memcpy into load/store pairs at this; // stage which is before quite a few IR optimization passes, therefore the; // loads and stores could potentially be moved apart from each other which; // will cause trouble to memcpy pattern matcher inside kernel eBPF JIT; // compilers.; //; // When -bpf-expand-memcpy-in-order specified, we want to defer the expand; // of memcpy to later stage in IR optimization pipeline so those load/store; // pairs won't be touched and could be kept in order. Hence, we set; // MaxStoresPerMem* to zero to disable the generic getMemcpyLoadsAndStores; // code path, and ask LLVM to use target expander EmitTargetCodeForMemcpy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp:31,Availability,error,error,31,"// We'll still produce a fatal error downstream, but this diagnostic is more; // user-friendly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp:37,Availability,down,downstream,37,"// We'll still produce a fatal error downstream, but this diagnostic is more; // user-friendly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp:81,Usability,user-friendly,user-friendly,81,"// We'll still produce a fatal error downstream, but this diagnostic is more; // user-friendly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp:76,Testability,assert,assert,76,"// If this is an value that has been promoted to wider types, insert an; // assert[sz]ext to capture this, then truncate to the right size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp:41,Performance,optimiz,optimization,41,// BPF target does not support tail call optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp:61,Safety,avoid,avoiding,61,"// Guarantee that all emitted copies are stuck together,; // avoiding something bad.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp:3,Deployability,Update,Update,3,// Update chain.; // Add the glue if we have it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp:247,Performance,load,load,247,"// This function does custom insertion during lowering BPFISD::MEMCPY which; // only has two register operands from memcpy semantics, the copy source; // address and the copy destination address.; //; // Because we will expand BPFISD::MEMCPY into load/store pairs, we will need; // a third scratch register to serve as the destination register of load and; // source register of store.; //; // The scratch register here is with the Define | Dead | EarlyClobber flags.; // The EarlyClobber flag has the semantic property that the operand it is; // attached to is clobbered before the rest of the inputs are read. Hence it; // must be unique among the operands to the instruction. The Define flag is; // needed to coerce the machine verifier that an Undef value isn't a problem; // as we anyway is loading memory into it. The Dead flag is needed as the; // value in scratch isn't supposed to be used by any other instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp:347,Performance,load,load,347,"// This function does custom insertion during lowering BPFISD::MEMCPY which; // only has two register operands from memcpy semantics, the copy source; // address and the copy destination address.; //; // Because we will expand BPFISD::MEMCPY into load/store pairs, we will need; // a third scratch register to serve as the destination register of load and; // source register of store.; //; // The scratch register here is with the Define | Dead | EarlyClobber flags.; // The EarlyClobber flag has the semantic property that the operand it is; // attached to is clobbered before the rest of the inputs are read. Hence it; // must be unique among the operands to the instruction. The Define flag is; // needed to coerce the machine verifier that an Undef value isn't a problem; // as we anyway is loading memory into it. The Dead flag is needed as the; // value in scratch isn't supposed to be used by any other instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp:796,Performance,load,loading,796,"// This function does custom insertion during lowering BPFISD::MEMCPY which; // only has two register operands from memcpy semantics, the copy source; // address and the copy destination address.; //; // Because we will expand BPFISD::MEMCPY into load/store pairs, we will need; // a third scratch register to serve as the destination register of load and; // source register of store.; //; // The scratch register here is with the Define | Dead | EarlyClobber flags.; // The EarlyClobber flag has the semantic property that the operand it is; // attached to is clobbered before the rest of the inputs are read. Hence it; // must be unique among the operands to the instruction. The Define flag is; // needed to coerce the machine verifier that an Undef value isn't a problem; // as we anyway is loading memory into it. The Dead flag is needed as the; // value in scratch isn't supposed to be used by any other instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp:3,Deployability,Update,Update,3,// Update machine-CFG edges by transferring all successors of the current; // block to the new block which will contain the Phi node for the select.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp:199,Modifiability,extend,extended,199,"// eBPF at the moment only has 64-bit comparison. Any 32-bit comparison need; // to be promoted, however if the 32-bit comparison operands are destination; // registers then they are implicitly zero-extended already, there is no; // need of explicit zero-extend sequence for them.; //; // We simply do extension for all situations in this method, but we will; // try to remove those unnecessary in BPFMIPeephole pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp:255,Modifiability,extend,extend,255,"// eBPF at the moment only has 64-bit comparison. Any 32-bit comparison need; // to be promoted, however if the 32-bit comparison operands are destination; // registers then they are implicitly zero-extended already, there is no; // need of explicit zero-extend sequence for them.; //; // We simply do extension for all situations in this method, but we will; // try to remove those unnecessary in BPFMIPeephole pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp:292,Usability,simpl,simply,292,"// eBPF at the moment only has 64-bit comparison. Any 32-bit comparison need; // to be promoted, however if the 32-bit comparison operands are destination; // registers then they are implicitly zero-extended already, there is no; // need of explicit zero-extend sequence for them.; //; // We simply do extension for all situations in this method, but we will; // try to remove those unnecessary in BPFMIPeephole pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp:3,Deployability,Update,Update,3,// Update machine-CFG edges,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp:22,Integrability,depend,depending,22,"// ""r+i"" or just ""i"", depending on HasBaseReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.h:45,Integrability,Interface,Interface,45,"//===-- BPFISelLowering.h - BPF DAG Lowering Interface ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that BPF uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.h:405,Integrability,interface,interfaces,405,"//===-- BPFISelLowering.h - BPF DAG Lowering Interface ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that BPF uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.h:20,Performance,load,load,20,"// Prevent reducing load width during SelectionDag phase.; // Otherwise, we may transform the following; // ctx = ctx + reloc_offset; // ... (*(u32 *)ctx) & 0x8000...; // to; // ctx = ctx + reloc_offset; // ... (*(u8 *)(ctx + 1)) & 0x80 ...; // which will be rejected by the verifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIChecking.cpp:420,Availability,error,errors,420,"//===-------------- BPFMIChecking.cpp - MI Checking Legality -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs checking to signal errors for certain illegal usages at; // MachineInstruction layer. Specially, the result of XADD{32,64} insn should; // not be used. The pass is done at the PreEmit pass right before the; // machine code is emitted at which point the register liveness information; // is still available.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIChecking.cpp:697,Availability,avail,available,697,"//===-------------- BPFMIChecking.cpp - MI Checking Legality -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs checking to signal errors for certain illegal usages at; // MachineInstruction layer. Specially, the result of XADD{32,64} insn should; // not be used. The pass is done at the PreEmit pass right before the; // machine code is emitted at which point the register liveness information; // is still available.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIChecking.cpp:392,Performance,perform,performs,392,"//===-------------- BPFMIChecking.cpp - MI Checking Legality -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs checking to signal errors for certain illegal usages at; // MachineInstruction layer. Specially, the result of XADD{32,64} insn should; // not be used. The pass is done at the PreEmit pass right before the; // machine code is emitted at which point the register liveness information; // is still available.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIChecking.cpp:20,Modifiability,variab,variables,20,// Initialize class variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIChecking.cpp:20,Modifiability,variab,variables,20,// Initialize class variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIChecking.cpp:1806,Availability,avail,available,1806,"en the; // source and destination operands of XADD are GPR32, there is no sub-register; // dead info. If we rely on the generic MachineInstr::allDefsAreDead, then we; // will raise false alarm on GPR32 Def.; //; // To support GPR32 Def, ideally we could just enable sub-registr liveness track; // on BPF backend, then allDefsAreDead could work on GPR32 Def. This requires; // implementing TargetSubtargetInfo::enableSubRegLiveness on BPF.; //; // However, sub-register liveness tracking module inside LLVM is actually; // designed for the situation where one register could be split into more than; // one sub-registers for which case each sub-register could have their own; // liveness and kill one of them doesn't kill others. So, tracking liveness for; // each make sense.; //; // For BPF, each 64-bit register could only have one 32-bit sub-register. This; // is exactly the case which LLVM think brings no benefits for doing; // sub-register tracking, because the live range of sub-register must always; // equal to its parent register, therefore liveness tracking is disabled even; // the back-end has implemented enableSubRegLiveness. The detailed information; // is at r232695:; //; // Author: Matthias Braun <matze@braunis.de>; // Date: Thu Mar 19 00:21:58 2015 +0000; // Do not track subregister liveness when it brings no benefits; //; // Hence, for BPF, we enhance MachineInstr::allDefsAreDead. Given the solo; // sub-register always has the same liveness as its parent register, LLVM is; // already attaching a implicit 64-bit register Def whenever the there is; // a sub-register Def. The liveness of the implicit 64-bit Def is available.; // For example, for ""lock *(u32 *)(r0 + 4) += w9"", the MachineOperand info could; // be:; //; // $w9 = XADDW32 killed $r0, 4, $w9(tied-def 0),; // implicit killed $r9, implicit-def dead $r9; //; // Even though w9 is not marked as Dead, the parent register r9 is marked as; // Dead correctly, and it is safe to use such information or our purpose.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIChecking.cpp:1533,Modifiability,enhance,enhance,1533,"en the; // source and destination operands of XADD are GPR32, there is no sub-register; // dead info. If we rely on the generic MachineInstr::allDefsAreDead, then we; // will raise false alarm on GPR32 Def.; //; // To support GPR32 Def, ideally we could just enable sub-registr liveness track; // on BPF backend, then allDefsAreDead could work on GPR32 Def. This requires; // implementing TargetSubtargetInfo::enableSubRegLiveness on BPF.; //; // However, sub-register liveness tracking module inside LLVM is actually; // designed for the situation where one register could be split into more than; // one sub-registers for which case each sub-register could have their own; // liveness and kill one of them doesn't kill others. So, tracking liveness for; // each make sense.; //; // For BPF, each 64-bit register could only have one 32-bit sub-register. This; // is exactly the case which LLVM think brings no benefits for doing; // sub-register tracking, because the live range of sub-register must always; // equal to its parent register, therefore liveness tracking is disabled even; // the back-end has implemented enableSubRegLiveness. The detailed information; // is at r232695:; //; // Author: Matthias Braun <matze@braunis.de>; // Date: Thu Mar 19 00:21:58 2015 +0000; // Do not track subregister liveness when it brings no benefits; //; // Hence, for BPF, we enhance MachineInstr::allDefsAreDead. Given the solo; // sub-register always has the same liveness as its parent register, LLVM is; // already attaching a implicit 64-bit register Def whenever the there is; // a sub-register Def. The liveness of the implicit 64-bit Def is available.; // For example, for ""lock *(u32 *)(r0 + 4) += w9"", the MachineOperand info could; // be:; //; // $w9 = XADDW32 killed $r0, 4, $w9(tied-def 0),; // implicit killed $r9, implicit-def dead $r9; //; // Even though w9 is not marked as Dead, the parent register r9 is marked as; // Dead correctly, and it is safe to use such information or our purpose.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIChecking.cpp:2120,Safety,safe,safe,2120,"en the; // source and destination operands of XADD are GPR32, there is no sub-register; // dead info. If we rely on the generic MachineInstr::allDefsAreDead, then we; // will raise false alarm on GPR32 Def.; //; // To support GPR32 Def, ideally we could just enable sub-registr liveness track; // on BPF backend, then allDefsAreDead could work on GPR32 Def. This requires; // implementing TargetSubtargetInfo::enableSubRegLiveness on BPF.; //; // However, sub-register liveness tracking module inside LLVM is actually; // designed for the situation where one register could be split into more than; // one sub-registers for which case each sub-register could have their own; // liveness and kill one of them doesn't kill others. So, tracking liveness for; // each make sense.; //; // For BPF, each 64-bit register could only have one 32-bit sub-register. This; // is exactly the case which LLVM think brings no benefits for doing; // sub-register tracking, because the live range of sub-register must always; // equal to its parent register, therefore liveness tracking is disabled even; // the back-end has implemented enableSubRegLiveness. The detailed information; // is at r232695:; //; // Author: Matthias Braun <matze@braunis.de>; // Date: Thu Mar 19 00:21:58 2015 +0000; // Do not track subregister liveness when it brings no benefits; //; // Hence, for BPF, we enhance MachineInstr::allDefsAreDead. Given the solo; // sub-register always has the same liveness as its parent register, LLVM is; // already attaching a implicit 64-bit register Def whenever the there is; // a sub-register Def. The liveness of the implicit 64-bit Def is available.; // For example, for ""lock *(u32 *)(r0 + 4) += w9"", the MachineOperand info could; // be:; //; // $w9 = XADDW32 killed $r0, 4, $w9(tied-def 0),; // implicit killed $r9, implicit-def dead $r9; //; // Even though w9 is not marked as Dead, the parent register r9 is marked as; // Dead correctly, and it is safe to use such information or our purpose.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIChecking.cpp:22,Safety,safe,safe,22,"// No GPR32 live Def, safe to return false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIChecking.cpp:103,Safety,safe,safe,103,"// No GPR64 dead Def, so all those GPR32 live Def can't have alias, therefore; // must be truely live, safe to return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIPeephole.cpp:923,Availability,redundant,redundant,923,"//===-------------- BPFMIPeephole.cpp - MI Peephole Cleanups -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs peephole optimizations to cleanup ugly code sequences at; // MachineInstruction layer.; //; // Currently, there are two optimizations implemented:; // - One pre-RA MachineSSA pass to eliminate type promotion sequences, those; // zero extend 32-bit subregisters to 64-bit registers, if the compiler; // could prove the subregisters is defined by 32-bit operations in which; // case the upper half of the underlying 64-bit registers were zeroed; // implicitly.; //; // - One post-RA PreEmit pass to do final cleanup on some redundant; // instructions generated due to bad RA on subregister.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIPeephole.cpp:635,Modifiability,extend,extend,635,"//===-------------- BPFMIPeephole.cpp - MI Peephole Cleanups -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs peephole optimizations to cleanup ugly code sequences at; // MachineInstruction layer.; //; // Currently, there are two optimizations implemented:; // - One pre-RA MachineSSA pass to eliminate type promotion sequences, those; // zero extend 32-bit subregisters to 64-bit registers, if the compiler; // could prove the subregisters is defined by 32-bit operations in which; // case the upper half of the underlying 64-bit registers were zeroed; // implicitly.; //; // - One post-RA PreEmit pass to do final cleanup on some redundant; // instructions generated due to bad RA on subregister.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIPeephole.cpp:392,Performance,perform,performs,392,"//===-------------- BPFMIPeephole.cpp - MI Peephole Cleanups -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs peephole optimizations to cleanup ugly code sequences at; // MachineInstruction layer.; //; // Currently, there are two optimizations implemented:; // - One pre-RA MachineSSA pass to eliminate type promotion sequences, those; // zero extend 32-bit subregisters to 64-bit registers, if the compiler; // could prove the subregisters is defined by 32-bit operations in which; // case the upper half of the underlying 64-bit registers were zeroed; // implicitly.; //; // - One post-RA PreEmit pass to do final cleanup on some redundant; // instructions generated due to bad RA on subregister.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIPeephole.cpp:410,Performance,optimiz,optimizations,410,"//===-------------- BPFMIPeephole.cpp - MI Peephole Cleanups -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs peephole optimizations to cleanup ugly code sequences at; // MachineInstruction layer.; //; // Currently, there are two optimizations implemented:; // - One pre-RA MachineSSA pass to eliminate type promotion sequences, those; // zero extend 32-bit subregisters to 64-bit registers, if the compiler; // could prove the subregisters is defined by 32-bit operations in which; // case the upper half of the underlying 64-bit registers were zeroed; // implicitly.; //; // - One post-RA PreEmit pass to do final cleanup on some redundant; // instructions generated due to bad RA on subregister.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIPeephole.cpp:521,Performance,optimiz,optimizations,521,"//===-------------- BPFMIPeephole.cpp - MI Peephole Cleanups -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs peephole optimizations to cleanup ugly code sequences at; // MachineInstruction layer.; //; // Currently, there are two optimizations implemented:; // - One pre-RA MachineSSA pass to eliminate type promotion sequences, those; // zero extend 32-bit subregisters to 64-bit registers, if the compiler; // could prove the subregisters is defined by 32-bit operations in which; // case the upper half of the underlying 64-bit registers were zeroed; // implicitly.; //; // - One post-RA PreEmit pass to do final cleanup on some redundant; // instructions generated due to bad RA on subregister.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIPeephole.cpp:923,Safety,redund,redundant,923,"//===-------------- BPFMIPeephole.cpp - MI Peephole Cleanups -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs peephole optimizations to cleanup ugly code sequences at; // MachineInstruction layer.; //; // Currently, there are two optimizations implemented:; // - One pre-RA MachineSSA pass to eliminate type promotion sequences, those; // zero extend 32-bit subregisters to 64-bit registers, if the compiler; // could prove the subregisters is defined by 32-bit operations in which; // case the upper half of the underlying 64-bit registers were zeroed; // implicitly.; //; // - One post-RA PreEmit pass to do final cleanup on some redundant; // instructions generated due to bad RA on subregister.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIPeephole.cpp:20,Modifiability,variab,variables,20,// Initialize class variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIPeephole.cpp:20,Modifiability,variab,variables,20,// Initialize class variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIPeephole.cpp:85,Modifiability,extend,extended,85,"// Eliminate MOV_32_64 if possible.; // MOV_32_64 rA, wB; //; // If wB has been zero extended, replace it with a SUBREG_TO_REG.; // This is to workaround BPF programs where pkt->{data, data_end}; // is encoded as u32, but actually the verifier populates them; // as 64bit pointer. The MOV_32_64 will zero out the top 32 bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIPeephole.cpp:20,Modifiability,variab,variables,20,// Initialize class variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIPeephole.cpp:20,Modifiability,variab,variables,20,// Initialize class variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIPeephole.cpp:52,Usability,simpl,simple,52,"// We have four cases here:; // (1). no terminator, simple follow through.; // (2). jmp to another bb.; // (3). conditional jmp to another bb or follow through.; // (4). conditional jmp followed by an unconditional jmp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIPeephole.cpp:23,Usability,simpl,simple,23,"// (1). no terminator, simple follow through.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp:52,Deployability,Patch,Patchable,52,"//===----- BPFMISimplifyPatchable.cpp - MI Simplify Patchable Insts -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass targets a subset of instructions like below; // ld_imm64 r1, @global; // ldd r2, r1, 0; // add r3, struct_base_reg, r2; //; // Here @global should represent an AMA (abstruct member access).; // Such an access is subject to bpf load time patching. After this pass, the; // code becomes; // ld_imm64 r1, @global; // add r3, struct_base_reg, r1; //; // Eventually, at BTF output stage, a relocation record will be generated; // for ld_imm64 which should be replaced later by bpf loader:; // r1 = <calculated field_info>; // add r3, struct_base_reg, r1; //; // This pass also removes the intermediate load generated in IR pass for; // __builtin_btf_type_id() intrinsic.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp:630,Deployability,patch,patching,630,"//===----- BPFMISimplifyPatchable.cpp - MI Simplify Patchable Insts -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass targets a subset of instructions like below; // ld_imm64 r1, @global; // ldd r2, r1, 0; // add r3, struct_base_reg, r2; //; // Here @global should represent an AMA (abstruct member access).; // Such an access is subject to bpf load time patching. After this pass, the; // code becomes; // ld_imm64 r1, @global; // add r3, struct_base_reg, r1; //; // Eventually, at BTF output stage, a relocation record will be generated; // for ld_imm64 which should be replaced later by bpf loader:; // r1 = <calculated field_info>; // add r3, struct_base_reg, r1; //; // This pass also removes the intermediate load generated in IR pass for; // __builtin_btf_type_id() intrinsic.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp:620,Performance,load,load,620,"//===----- BPFMISimplifyPatchable.cpp - MI Simplify Patchable Insts -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass targets a subset of instructions like below; // ld_imm64 r1, @global; // ldd r2, r1, 0; // add r3, struct_base_reg, r2; //; // Here @global should represent an AMA (abstruct member access).; // Such an access is subject to bpf load time patching. After this pass, the; // code becomes; // ld_imm64 r1, @global; // add r3, struct_base_reg, r1; //; // Eventually, at BTF output stage, a relocation record will be generated; // for ld_imm64 which should be replaced later by bpf loader:; // r1 = <calculated field_info>; // add r3, struct_base_reg, r1; //; // This pass also removes the intermediate load generated in IR pass for; // __builtin_btf_type_id() intrinsic.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp:869,Performance,load,loader,869,"//===----- BPFMISimplifyPatchable.cpp - MI Simplify Patchable Insts -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass targets a subset of instructions like below; // ld_imm64 r1, @global; // ldd r2, r1, 0; // add r3, struct_base_reg, r2; //; // Here @global should represent an AMA (abstruct member access).; // Such an access is subject to bpf load time patching. After this pass, the; // code becomes; // ld_imm64 r1, @global; // add r3, struct_base_reg, r1; //; // Eventually, at BTF output stage, a relocation record will be generated; // for ld_imm64 which should be replaced later by bpf loader:; // r1 = <calculated field_info>; // add r3, struct_base_reg, r1; //; // This pass also removes the intermediate load generated in IR pass for; // __builtin_btf_type_id() intrinsic.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp:990,Performance,load,load,990,"//===----- BPFMISimplifyPatchable.cpp - MI Simplify Patchable Insts -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass targets a subset of instructions like below; // ld_imm64 r1, @global; // ldd r2, r1, 0; // add r3, struct_base_reg, r2; //; // Here @global should represent an AMA (abstruct member access).; // Such an access is subject to bpf load time patching. After this pass, the; // code becomes; // ld_imm64 r1, @global; // add r3, struct_base_reg, r1; //; // Eventually, at BTF output stage, a relocation record will be generated; // for ld_imm64 which should be replaced later by bpf loader:; // r1 = <calculated field_info>; // add r3, struct_base_reg, r1; //; // This pass also removes the intermediate load generated in IR pass for; // __builtin_btf_type_id() intrinsic.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp:574,Security,access,access,574,"//===----- BPFMISimplifyPatchable.cpp - MI Simplify Patchable Insts -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass targets a subset of instructions like below; // ld_imm64 r1, @global; // ldd r2, r1, 0; // add r3, struct_base_reg, r2; //; // Here @global should represent an AMA (abstruct member access).; // Such an access is subject to bpf load time patching. After this pass, the; // code becomes; // ld_imm64 r1, @global; // add r3, struct_base_reg, r1; //; // Eventually, at BTF output stage, a relocation record will be generated; // for ld_imm64 which should be replaced later by bpf loader:; // r1 = <calculated field_info>; // add r3, struct_base_reg, r1; //; // This pass also removes the intermediate load generated in IR pass for; // __builtin_btf_type_id() intrinsic.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp:595,Security,access,access,595,"//===----- BPFMISimplifyPatchable.cpp - MI Simplify Patchable Insts -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass targets a subset of instructions like below; // ld_imm64 r1, @global; // ldd r2, r1, 0; // add r3, struct_base_reg, r2; //; // Here @global should represent an AMA (abstruct member access).; // Such an access is subject to bpf load time patching. After this pass, the; // code becomes; // ld_imm64 r1, @global; // add r3, struct_base_reg, r1; //; // Eventually, at BTF output stage, a relocation record will be generated; // for ld_imm64 which should be replaced later by bpf loader:; // r1 = <calculated field_info>; // add r3, struct_base_reg, r1; //; // This pass also removes the intermediate load generated in IR pass for; // __builtin_btf_type_id() intrinsic.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp:43,Usability,Simpl,Simplify,43,"//===----- BPFMISimplifyPatchable.cpp - MI Simplify Patchable Insts -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass targets a subset of instructions like below; // ld_imm64 r1, @global; // ldd r2, r1, 0; // add r3, struct_base_reg, r2; //; // Here @global should represent an AMA (abstruct member access).; // Such an access is subject to bpf load time patching. After this pass, the; // code becomes; // ld_imm64 r1, @global; // add r3, struct_base_reg, r1; //; // Eventually, at BTF output stage, a relocation record will be generated; // for ld_imm64 which should be replaced later by bpf loader:; // r1 = <calculated field_info>; // add r3, struct_base_reg, r1; //; // This pass also removes the intermediate load generated in IR pass for; // __builtin_btf_type_id() intrinsic.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp:20,Modifiability,variab,variables,20,// Initialize class variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp:20,Modifiability,variab,variables,20,// Initialize class variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp:10,Performance,optimiz,optimize,10,"// We can optimize such a pattern:; // %1:gpr = LD_imm64 @""llvm.s:0:4$0:2""; // %2:gpr32 = LDW32 %1:gpr, 0; // %3:gpr = SUBREG_TO_REG 0, %2:gpr32, %subreg.sub_32; // %4:gpr = ADD_rr %0:gpr, %3:gpr; // or similar patterns below for non-alu32 case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp:596,Deployability,update,updated,596,"// In situations like below it is not known if usage is a kill; // after setReg():; //; // .-> %2:gpr = LD_imm64 @""llvm.t:0:0$0:0""; // |; // |`----------------.; // | %3:gpr = LDD %2:gpr, 0; // | %4:gpr = ADD_rr %0:gpr(tied-def 0), killed %3:gpr <--- (1); // | %5:gpr = LDD killed %4:gpr, 0 ^^^^^^^^^^^^^; // | STD killed %5:gpr, %1:gpr, 0 this is I; // `----------------.; // %6:gpr = LDD %2:gpr, 0; // %7:gpr = ADD_rr %0:gpr(tied-def 0), killed %6:gpr <--- (2); // %8:gpr = LDD killed %7:gpr, 0 ^^^^^^^^^^^^^; // STD killed %8:gpr, %1:gpr, 0 this is I; //; // Instructions (1) and (2) would be updated by setReg() to:; //; // ADD_rr %0:gpr(tied-def 0), %2:gpr; //; // %2:gpr is not killed at (1), so it is necessary to remove kill flag; // from I.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp:82,Availability,down,downstream,82,"// Check to see whether we could do some optimization; // to attach relocation to downstream dependent instructions.; // Two kinds of patterns are recognized below:; // Pattern 1:; // %1 = LD_imm64 @""llvm.b:0:4$0:1"" <== patch_imm = 4; // %2 = LDD %1, 0 <== this insn will be removed; // %3 = ADD_rr %0, %2; // %4 = LDW[32] %3, 0 OR STW[32] %4, %3, 0; // The `%4 = ...` will be transformed to; // CORE_[ALU32_]MEM(%4, mem_opcode, %0, @""llvm.b:0:4$0:1""); // and later on, BTF emit phase will translate to; // %4 = LDW[32] %0, 4 STW[32] %4, %0, 4; // and attach a relocation to it.; // Pattern 2:; // %15 = LD_imm64 @""llvm.t:5:63$0:2"" <== relocation type 5; // %16 = LDD %15, 0 <== this insn will be removed; // %17 = SRA_rr %14, %16; // The `%17 = ...` will be transformed to; // %17 = CORE_SHIFT(SRA_ri, %14, @""llvm.t:5:63$0:2""); // and later on, BTF emit phase will translate to; // %r4 = SRA_ri %r4, 63",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp:93,Integrability,depend,dependent,93,"// Check to see whether we could do some optimization; // to attach relocation to downstream dependent instructions.; // Two kinds of patterns are recognized below:; // Pattern 1:; // %1 = LD_imm64 @""llvm.b:0:4$0:1"" <== patch_imm = 4; // %2 = LDD %1, 0 <== this insn will be removed; // %3 = ADD_rr %0, %2; // %4 = LDW[32] %3, 0 OR STW[32] %4, %3, 0; // The `%4 = ...` will be transformed to; // CORE_[ALU32_]MEM(%4, mem_opcode, %0, @""llvm.b:0:4$0:1""); // and later on, BTF emit phase will translate to; // %4 = LDW[32] %0, 4 STW[32] %4, %0, 4; // and attach a relocation to it.; // Pattern 2:; // %15 = LD_imm64 @""llvm.t:5:63$0:2"" <== relocation type 5; // %16 = LDD %15, 0 <== this insn will be removed; // %17 = SRA_rr %14, %16; // The `%17 = ...` will be transformed to; // %17 = CORE_SHIFT(SRA_ri, %14, @""llvm.t:5:63$0:2""); // and later on, BTF emit phase will translate to; // %r4 = SRA_ri %r4, 63",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp:41,Performance,optimiz,optimization,41,"// Check to see whether we could do some optimization; // to attach relocation to downstream dependent instructions.; // Two kinds of patterns are recognized below:; // Pattern 1:; // %1 = LD_imm64 @""llvm.b:0:4$0:1"" <== patch_imm = 4; // %2 = LDD %1, 0 <== this insn will be removed; // %3 = ADD_rr %0, %2; // %4 = LDW[32] %3, 0 OR STW[32] %4, %3, 0; // The `%4 = ...` will be transformed to; // CORE_[ALU32_]MEM(%4, mem_opcode, %0, @""llvm.b:0:4$0:1""); // and later on, BTF emit phase will translate to; // %4 = LDW[32] %0, 4 STW[32] %4, %0, 4; // and attach a relocation to it.; // Pattern 2:; // %15 = LD_imm64 @""llvm.t:5:63$0:2"" <== relocation type 5; // %16 = LDD %15, 0 <== this insn will be removed; // %17 = SRA_rr %14, %16; // The `%17 = ...` will be transformed to; // %17 = CORE_SHIFT(SRA_ri, %14, @""llvm.t:5:63$0:2""); // and later on, BTF emit phase will translate to; // %r4 = SRA_ri %r4, 63",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp:20,Performance,Load,Load,20,/// Remove unneeded Load instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp:33,Performance,LOAD,LOAD,33,"// Ensure the register format is LOAD <reg>, <reg>, 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp:10,Modifiability,variab,variables,10,// Global variables representing structure offset or type id.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveDIType.cpp:19,Modifiability,variab,variable,19,// Load the global variable which represents the type info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveDIType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveDIType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveDIType.cpp:3,Performance,Load,Load,3,// Load the global variable which represents the type info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveDIType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveDIType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp:1136,Modifiability,rewrite,rewrite,1136,"//llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // TLDR: replaces llvm.preserve.static.offset + GEP + load / store; // with llvm.bpf.getelementptr.and.load / store; //; // This file implements BPFPreserveStaticOffsetPass transformation.; // This transformation address two BPF verifier specific issues:; //; // (a) Access to the fields of some structural types is allowed only; // using load and store instructions with static immediate offsets.; //; // Examples of such types are `struct __sk_buff` and `struct; // bpf_sock_ops`. This is so because offsets of the fields of; // these structures do not match real offsets in the running; // kernel. During BPF program load LDX and STX instructions; // referring to the fields of these types are rewritten so that; // offsets match real offsets. For this rewrite to happen field; // offsets have to be encoded as immediate operands of the; // instructions.; //; // See kernel/bpf/verifier.c:convert_ctx_access function in the; // Linux kernel source tree for details.; //; // (b) Pointers to context parameters of BPF programs must not be; // modified before access.; //; // During BPF program verification a tag PTR_TO_CTX is tracked for; // register values. In case if register with such tag is modified; // BPF program is not allowed to read or write memory using this; // register. See kernel/bpf/verifier.c:check_mem_access function; // in the Linux kernel source tree for details.; //; // The following sequence of the IR instructions:; //; // %x = getelementptr %ptr, %constant_offset; // %y = load %x; //; // Is translated as a single machine instruction:; //; // LDW %ptr, %constant_offset; //; // In order for cases (a) and (b) to work the sequence %x-%y above has; // to be preserved by the IR passes.; //; // However, several optimization passes might sink `load` instruction; // or hoist ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp:434,Performance,load,load,434,"//===------ BPFPreserveStaticOffset.cpp -----------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // TLDR: replaces llvm.preserve.static.offset + GEP + load / store; // with llvm.bpf.getelementptr.and.load / store; //; // This file implements BPFPreserveStaticOffsetPass transformation.; // This transformation address two BPF verifier specific issues:; //; // (a) Access to the fields of some structural types is allowed only; // using load and store instructions with static immediate offsets.; //; // Examples of such types are `struct __sk_buff` and `struct; // bpf_sock_ops`. This is so because offsets of the fields of; // these structures do not match real offsets in the running; // kernel. During BPF program load LDX and STX instructions; // referring to the fields of these types are rewritten so that; // offsets match real offsets. For this rewrite to happen field; // offsets have to be encoded as immediate operands of the; // instructions.; //; // See kernel/bpf/verifier.c:convert_ctx_access function in the; // Linux kernel source tree for details.; //; // (b) Pointers to context parameters of BPF programs must not be; // modified before access.; //; // During BPF program verification a tag PTR_TO_CTX is tracked for; // register values. In case if register with such tag is modified; // BPF program is not allowed to read or write memory using this; // register. See kernel/bpf/verifier.c:check_mem_access function; // in the Linux kernel source tree for details.; //; // The following sequence of the IR instructions:; //; // %x = getelementptr %ptr, %constant_offset; // %y = load %x; //; // Is translated as a single machine instruction:; //; // LDW %ptr, %constant_offset; //; // In order for ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp:483,Performance,load,load,483,"//===------ BPFPreserveStaticOffset.cpp -----------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // TLDR: replaces llvm.preserve.static.offset + GEP + load / store; // with llvm.bpf.getelementptr.and.load / store; //; // This file implements BPFPreserveStaticOffsetPass transformation.; // This transformation address two BPF verifier specific issues:; //; // (a) Access to the fields of some structural types is allowed only; // using load and store instructions with static immediate offsets.; //; // Examples of such types are `struct __sk_buff` and `struct; // bpf_sock_ops`. This is so because offsets of the fields of; // these structures do not match real offsets in the running; // kernel. During BPF program load LDX and STX instructions; // referring to the fields of these types are rewritten so that; // offsets match real offsets. For this rewrite to happen field; // offsets have to be encoded as immediate operands of the; // instructions.; //; // See kernel/bpf/verifier.c:convert_ctx_access function in the; // Linux kernel source tree for details.; //; // (b) Pointers to context parameters of BPF programs must not be; // modified before access.; //; // During BPF program verification a tag PTR_TO_CTX is tracked for; // register values. In case if register with such tag is modified; // BPF program is not allowed to read or write memory using this; // register. See kernel/bpf/verifier.c:check_mem_access function; // in the Linux kernel source tree for details.; //; // The following sequence of the IR instructions:; //; // %x = getelementptr %ptr, %constant_offset; // %y = load %x; //; // Is translated as a single machine instruction:; //; // LDW %ptr, %constant_offset; //; // In order for ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp:719,Performance,load,load,719,"//===------ BPFPreserveStaticOffset.cpp -----------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // TLDR: replaces llvm.preserve.static.offset + GEP + load / store; // with llvm.bpf.getelementptr.and.load / store; //; // This file implements BPFPreserveStaticOffsetPass transformation.; // This transformation address two BPF verifier specific issues:; //; // (a) Access to the fields of some structural types is allowed only; // using load and store instructions with static immediate offsets.; //; // Examples of such types are `struct __sk_buff` and `struct; // bpf_sock_ops`. This is so because offsets of the fields of; // these structures do not match real offsets in the running; // kernel. During BPF program load LDX and STX instructions; // referring to the fields of these types are rewritten so that; // offsets match real offsets. For this rewrite to happen field; // offsets have to be encoded as immediate operands of the; // instructions.; //; // See kernel/bpf/verifier.c:convert_ctx_access function in the; // Linux kernel source tree for details.; //; // (b) Pointers to context parameters of BPF programs must not be; // modified before access.; //; // During BPF program verification a tag PTR_TO_CTX is tracked for; // register values. In case if register with such tag is modified; // BPF program is not allowed to read or write memory using this; // register. See kernel/bpf/verifier.c:check_mem_access function; // in the Linux kernel source tree for details.; //; // The following sequence of the IR instructions:; //; // %x = getelementptr %ptr, %constant_offset; // %y = load %x; //; // Is translated as a single machine instruction:; //; // LDW %ptr, %constant_offset; //; // In order for ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp:1000,Performance,load,load,1000,"----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // TLDR: replaces llvm.preserve.static.offset + GEP + load / store; // with llvm.bpf.getelementptr.and.load / store; //; // This file implements BPFPreserveStaticOffsetPass transformation.; // This transformation address two BPF verifier specific issues:; //; // (a) Access to the fields of some structural types is allowed only; // using load and store instructions with static immediate offsets.; //; // Examples of such types are `struct __sk_buff` and `struct; // bpf_sock_ops`. This is so because offsets of the fields of; // these structures do not match real offsets in the running; // kernel. During BPF program load LDX and STX instructions; // referring to the fields of these types are rewritten so that; // offsets match real offsets. For this rewrite to happen field; // offsets have to be encoded as immediate operands of the; // instructions.; //; // See kernel/bpf/verifier.c:convert_ctx_access function in the; // Linux kernel source tree for details.; //; // (b) Pointers to context parameters of BPF programs must not be; // modified before access.; //; // During BPF program verification a tag PTR_TO_CTX is tracked for; // register values. In case if register with such tag is modified; // BPF program is not allowed to read or write memory using this; // register. See kernel/bpf/verifier.c:check_mem_access function; // in the Linux kernel source tree for details.; //; // The following sequence of the IR instructions:; //; // %x = getelementptr %ptr, %constant_offset; // %y = load %x; //; // Is translated as a single machine instruction:; //; // LDW %ptr, %constant_offset; //; // In order for cases (a) and (b) to work the sequence %x-%y above h",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp:1882,Performance,load,load,1882," not match real offsets in the running; // kernel. During BPF program load LDX and STX instructions; // referring to the fields of these types are rewritten so that; // offsets match real offsets. For this rewrite to happen field; // offsets have to be encoded as immediate operands of the; // instructions.; //; // See kernel/bpf/verifier.c:convert_ctx_access function in the; // Linux kernel source tree for details.; //; // (b) Pointers to context parameters of BPF programs must not be; // modified before access.; //; // During BPF program verification a tag PTR_TO_CTX is tracked for; // register values. In case if register with such tag is modified; // BPF program is not allowed to read or write memory using this; // register. See kernel/bpf/verifier.c:check_mem_access function; // in the Linux kernel source tree for details.; //; // The following sequence of the IR instructions:; //; // %x = getelementptr %ptr, %constant_offset; // %y = load %x; //; // Is translated as a single machine instruction:; //; // LDW %ptr, %constant_offset; //; // In order for cases (a) and (b) to work the sequence %x-%y above has; // to be preserved by the IR passes.; //; // However, several optimization passes might sink `load` instruction; // or hoist `getelementptr` instruction so that the instructions are; // no longer in sequence. Examples of such passes are:; // SimplifyCFGPass, InstCombinePass, GVNPass.; // After such modification the verifier would reject the BPF program.; //; // To avoid this issue the patterns like (load/store (getelementptr ...)); // are replaced by calls to BPF specific intrinsic functions:; // - llvm.bpf.getelementptr.and.load; // - llvm.bpf.getelementptr.and.store; //; // These calls are lowered back to (load/store (getelementptr ...)); // by BPFCheckAndAdjustIR pass right before the translation from IR to; // machine instructions.; //; // The transformation is split into the following steps:; // - When IR is generated from AST the calls to intrinsic functi",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp:2119,Performance,optimiz,optimization,2119," be encoded as immediate operands of the; // instructions.; //; // See kernel/bpf/verifier.c:convert_ctx_access function in the; // Linux kernel source tree for details.; //; // (b) Pointers to context parameters of BPF programs must not be; // modified before access.; //; // During BPF program verification a tag PTR_TO_CTX is tracked for; // register values. In case if register with such tag is modified; // BPF program is not allowed to read or write memory using this; // register. See kernel/bpf/verifier.c:check_mem_access function; // in the Linux kernel source tree for details.; //; // The following sequence of the IR instructions:; //; // %x = getelementptr %ptr, %constant_offset; // %y = load %x; //; // Is translated as a single machine instruction:; //; // LDW %ptr, %constant_offset; //; // In order for cases (a) and (b) to work the sequence %x-%y above has; // to be preserved by the IR passes.; //; // However, several optimization passes might sink `load` instruction; // or hoist `getelementptr` instruction so that the instructions are; // no longer in sequence. Examples of such passes are:; // SimplifyCFGPass, InstCombinePass, GVNPass.; // After such modification the verifier would reject the BPF program.; //; // To avoid this issue the patterns like (load/store (getelementptr ...)); // are replaced by calls to BPF specific intrinsic functions:; // - llvm.bpf.getelementptr.and.load; // - llvm.bpf.getelementptr.and.store; //; // These calls are lowered back to (load/store (getelementptr ...)); // by BPFCheckAndAdjustIR pass right before the translation from IR to; // machine instructions.; //; // The transformation is split into the following steps:; // - When IR is generated from AST the calls to intrinsic function; // llvm.preserve.static.offset are inserted.; // - BPFPreserveStaticOffsetPass is executed as early as possible; // with AllowPatial set to true, this handles marked GEP chains; // with constant offsets.; // - BPFPreserveStaticOffsetPass is exec",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp:2151,Performance,load,load,2151," be encoded as immediate operands of the; // instructions.; //; // See kernel/bpf/verifier.c:convert_ctx_access function in the; // Linux kernel source tree for details.; //; // (b) Pointers to context parameters of BPF programs must not be; // modified before access.; //; // During BPF program verification a tag PTR_TO_CTX is tracked for; // register values. In case if register with such tag is modified; // BPF program is not allowed to read or write memory using this; // register. See kernel/bpf/verifier.c:check_mem_access function; // in the Linux kernel source tree for details.; //; // The following sequence of the IR instructions:; //; // %x = getelementptr %ptr, %constant_offset; // %y = load %x; //; // Is translated as a single machine instruction:; //; // LDW %ptr, %constant_offset; //; // In order for cases (a) and (b) to work the sequence %x-%y above has; // to be preserved by the IR passes.; //; // However, several optimization passes might sink `load` instruction; // or hoist `getelementptr` instruction so that the instructions are; // no longer in sequence. Examples of such passes are:; // SimplifyCFGPass, InstCombinePass, GVNPass.; // After such modification the verifier would reject the BPF program.; //; // To avoid this issue the patterns like (load/store (getelementptr ...)); // are replaced by calls to BPF specific intrinsic functions:; // - llvm.bpf.getelementptr.and.load; // - llvm.bpf.getelementptr.and.store; //; // These calls are lowered back to (load/store (getelementptr ...)); // by BPFCheckAndAdjustIR pass right before the translation from IR to; // machine instructions.; //; // The transformation is split into the following steps:; // - When IR is generated from AST the calls to intrinsic function; // llvm.preserve.static.offset are inserted.; // - BPFPreserveStaticOffsetPass is executed as early as possible; // with AllowPatial set to true, this handles marked GEP chains; // with constant offsets.; // - BPFPreserveStaticOffsetPass is exec",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp:2460,Performance,load,load,2460,"//; // During BPF program verification a tag PTR_TO_CTX is tracked for; // register values. In case if register with such tag is modified; // BPF program is not allowed to read or write memory using this; // register. See kernel/bpf/verifier.c:check_mem_access function; // in the Linux kernel source tree for details.; //; // The following sequence of the IR instructions:; //; // %x = getelementptr %ptr, %constant_offset; // %y = load %x; //; // Is translated as a single machine instruction:; //; // LDW %ptr, %constant_offset; //; // In order for cases (a) and (b) to work the sequence %x-%y above has; // to be preserved by the IR passes.; //; // However, several optimization passes might sink `load` instruction; // or hoist `getelementptr` instruction so that the instructions are; // no longer in sequence. Examples of such passes are:; // SimplifyCFGPass, InstCombinePass, GVNPass.; // After such modification the verifier would reject the BPF program.; //; // To avoid this issue the patterns like (load/store (getelementptr ...)); // are replaced by calls to BPF specific intrinsic functions:; // - llvm.bpf.getelementptr.and.load; // - llvm.bpf.getelementptr.and.store; //; // These calls are lowered back to (load/store (getelementptr ...)); // by BPFCheckAndAdjustIR pass right before the translation from IR to; // machine instructions.; //; // The transformation is split into the following steps:; // - When IR is generated from AST the calls to intrinsic function; // llvm.preserve.static.offset are inserted.; // - BPFPreserveStaticOffsetPass is executed as early as possible; // with AllowPatial set to true, this handles marked GEP chains; // with constant offsets.; // - BPFPreserveStaticOffsetPass is executed at ScalarOptimizerLateEPCallback; // with AllowPatial set to false, this handles marked GEP chains; // with offsets that became constant after loop unrolling, e.g.; // to handle the following code:; //; // struct context { int x[4]; } __attribute__((preserve_static_",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp:2588,Performance,load,load,2588,"rogram is not allowed to read or write memory using this; // register. See kernel/bpf/verifier.c:check_mem_access function; // in the Linux kernel source tree for details.; //; // The following sequence of the IR instructions:; //; // %x = getelementptr %ptr, %constant_offset; // %y = load %x; //; // Is translated as a single machine instruction:; //; // LDW %ptr, %constant_offset; //; // In order for cases (a) and (b) to work the sequence %x-%y above has; // to be preserved by the IR passes.; //; // However, several optimization passes might sink `load` instruction; // or hoist `getelementptr` instruction so that the instructions are; // no longer in sequence. Examples of such passes are:; // SimplifyCFGPass, InstCombinePass, GVNPass.; // After such modification the verifier would reject the BPF program.; //; // To avoid this issue the patterns like (load/store (getelementptr ...)); // are replaced by calls to BPF specific intrinsic functions:; // - llvm.bpf.getelementptr.and.load; // - llvm.bpf.getelementptr.and.store; //; // These calls are lowered back to (load/store (getelementptr ...)); // by BPFCheckAndAdjustIR pass right before the translation from IR to; // machine instructions.; //; // The transformation is split into the following steps:; // - When IR is generated from AST the calls to intrinsic function; // llvm.preserve.static.offset are inserted.; // - BPFPreserveStaticOffsetPass is executed as early as possible; // with AllowPatial set to true, this handles marked GEP chains; // with constant offsets.; // - BPFPreserveStaticOffsetPass is executed at ScalarOptimizerLateEPCallback; // with AllowPatial set to false, this handles marked GEP chains; // with offsets that became constant after loop unrolling, e.g.; // to handle the following code:; //; // struct context { int x[4]; } __attribute__((preserve_static_offset));; //; // struct context *ctx = ...;; // #pragma clang loop unroll(full); // for (int i = 0; i < 4; ++i); // foo(ctx->x[i]);; //; // The e",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp:2673,Performance,load,load,2673,"er. See kernel/bpf/verifier.c:check_mem_access function; // in the Linux kernel source tree for details.; //; // The following sequence of the IR instructions:; //; // %x = getelementptr %ptr, %constant_offset; // %y = load %x; //; // Is translated as a single machine instruction:; //; // LDW %ptr, %constant_offset; //; // In order for cases (a) and (b) to work the sequence %x-%y above has; // to be preserved by the IR passes.; //; // However, several optimization passes might sink `load` instruction; // or hoist `getelementptr` instruction so that the instructions are; // no longer in sequence. Examples of such passes are:; // SimplifyCFGPass, InstCombinePass, GVNPass.; // After such modification the verifier would reject the BPF program.; //; // To avoid this issue the patterns like (load/store (getelementptr ...)); // are replaced by calls to BPF specific intrinsic functions:; // - llvm.bpf.getelementptr.and.load; // - llvm.bpf.getelementptr.and.store; //; // These calls are lowered back to (load/store (getelementptr ...)); // by BPFCheckAndAdjustIR pass right before the translation from IR to; // machine instructions.; //; // The transformation is split into the following steps:; // - When IR is generated from AST the calls to intrinsic function; // llvm.preserve.static.offset are inserted.; // - BPFPreserveStaticOffsetPass is executed as early as possible; // with AllowPatial set to true, this handles marked GEP chains; // with constant offsets.; // - BPFPreserveStaticOffsetPass is executed at ScalarOptimizerLateEPCallback; // with AllowPatial set to false, this handles marked GEP chains; // with offsets that became constant after loop unrolling, e.g.; // to handle the following code:; //; // struct context { int x[4]; } __attribute__((preserve_static_offset));; //; // struct context *ctx = ...;; // #pragma clang loop unroll(full); // for (int i = 0; i < 4; ++i); // foo(ctx->x[i]);; //; // The early BPFPreserveStaticOffsetPass run is necessary to allow; // addi",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp:3746,Performance,optimiz,optimization,3746,"m.; //; // To avoid this issue the patterns like (load/store (getelementptr ...)); // are replaced by calls to BPF specific intrinsic functions:; // - llvm.bpf.getelementptr.and.load; // - llvm.bpf.getelementptr.and.store; //; // These calls are lowered back to (load/store (getelementptr ...)); // by BPFCheckAndAdjustIR pass right before the translation from IR to; // machine instructions.; //; // The transformation is split into the following steps:; // - When IR is generated from AST the calls to intrinsic function; // llvm.preserve.static.offset are inserted.; // - BPFPreserveStaticOffsetPass is executed as early as possible; // with AllowPatial set to true, this handles marked GEP chains; // with constant offsets.; // - BPFPreserveStaticOffsetPass is executed at ScalarOptimizerLateEPCallback; // with AllowPatial set to false, this handles marked GEP chains; // with offsets that became constant after loop unrolling, e.g.; // to handle the following code:; //; // struct context { int x[4]; } __attribute__((preserve_static_offset));; //; // struct context *ctx = ...;; // #pragma clang loop unroll(full); // for (int i = 0; i < 4; ++i); // foo(ctx->x[i]);; //; // The early BPFPreserveStaticOffsetPass run is necessary to allow; // additional GVN / CSE opportunities after functions inlining.; // The relative order of optimization applied to function:; // - early stage (1); // - ...; // - function inlining (2); // - ...; // - loop unrolling; // - ...; // - ScalarOptimizerLateEPCallback (3); //; // When function A is inlined into function B all optimizations for A; // are already done, while some passes remain for B. In case if; // BPFPreserveStaticOffsetPass is done at (3) but not done at (1); // the code after (2) would contain a mix of; // (load (gep %p)) and (get.and.load %p) usages:; // - the (load (gep %p)) would come from the calling function;; // - the (get.and.load %p) would come from the callee function.; // Thus clobbering CSE / GVN passes done after inlining.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp:3976,Performance,optimiz,optimizations,3976,"m.; //; // To avoid this issue the patterns like (load/store (getelementptr ...)); // are replaced by calls to BPF specific intrinsic functions:; // - llvm.bpf.getelementptr.and.load; // - llvm.bpf.getelementptr.and.store; //; // These calls are lowered back to (load/store (getelementptr ...)); // by BPFCheckAndAdjustIR pass right before the translation from IR to; // machine instructions.; //; // The transformation is split into the following steps:; // - When IR is generated from AST the calls to intrinsic function; // llvm.preserve.static.offset are inserted.; // - BPFPreserveStaticOffsetPass is executed as early as possible; // with AllowPatial set to true, this handles marked GEP chains; // with constant offsets.; // - BPFPreserveStaticOffsetPass is executed at ScalarOptimizerLateEPCallback; // with AllowPatial set to false, this handles marked GEP chains; // with offsets that became constant after loop unrolling, e.g.; // to handle the following code:; //; // struct context { int x[4]; } __attribute__((preserve_static_offset));; //; // struct context *ctx = ...;; // #pragma clang loop unroll(full); // for (int i = 0; i < 4; ++i); // foo(ctx->x[i]);; //; // The early BPFPreserveStaticOffsetPass run is necessary to allow; // additional GVN / CSE opportunities after functions inlining.; // The relative order of optimization applied to function:; // - early stage (1); // - ...; // - function inlining (2); // - ...; // - loop unrolling; // - ...; // - ScalarOptimizerLateEPCallback (3); //; // When function A is inlined into function B all optimizations for A; // are already done, while some passes remain for B. In case if; // BPFPreserveStaticOffsetPass is done at (3) but not done at (1); // the code after (2) would contain a mix of; // (load (gep %p)) and (get.and.load %p) usages:; // - the (load (gep %p)) would come from the calling function;; // - the (get.and.load %p) would come from the callee function.; // Thus clobbering CSE / GVN passes done after inlining.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp:4179,Performance,load,load,4179,"m.; //; // To avoid this issue the patterns like (load/store (getelementptr ...)); // are replaced by calls to BPF specific intrinsic functions:; // - llvm.bpf.getelementptr.and.load; // - llvm.bpf.getelementptr.and.store; //; // These calls are lowered back to (load/store (getelementptr ...)); // by BPFCheckAndAdjustIR pass right before the translation from IR to; // machine instructions.; //; // The transformation is split into the following steps:; // - When IR is generated from AST the calls to intrinsic function; // llvm.preserve.static.offset are inserted.; // - BPFPreserveStaticOffsetPass is executed as early as possible; // with AllowPatial set to true, this handles marked GEP chains; // with constant offsets.; // - BPFPreserveStaticOffsetPass is executed at ScalarOptimizerLateEPCallback; // with AllowPatial set to false, this handles marked GEP chains; // with offsets that became constant after loop unrolling, e.g.; // to handle the following code:; //; // struct context { int x[4]; } __attribute__((preserve_static_offset));; //; // struct context *ctx = ...;; // #pragma clang loop unroll(full); // for (int i = 0; i < 4; ++i); // foo(ctx->x[i]);; //; // The early BPFPreserveStaticOffsetPass run is necessary to allow; // additional GVN / CSE opportunities after functions inlining.; // The relative order of optimization applied to function:; // - early stage (1); // - ...; // - function inlining (2); // - ...; // - loop unrolling; // - ...; // - ScalarOptimizerLateEPCallback (3); //; // When function A is inlined into function B all optimizations for A; // are already done, while some passes remain for B. In case if; // BPFPreserveStaticOffsetPass is done at (3) but not done at (1); // the code after (2) would contain a mix of; // (load (gep %p)) and (get.and.load %p) usages:; // - the (load (gep %p)) would come from the calling function;; // - the (get.and.load %p) would come from the callee function.; // Thus clobbering CSE / GVN passes done after inlining.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp:4207,Performance,load,load,4207,"m.; //; // To avoid this issue the patterns like (load/store (getelementptr ...)); // are replaced by calls to BPF specific intrinsic functions:; // - llvm.bpf.getelementptr.and.load; // - llvm.bpf.getelementptr.and.store; //; // These calls are lowered back to (load/store (getelementptr ...)); // by BPFCheckAndAdjustIR pass right before the translation from IR to; // machine instructions.; //; // The transformation is split into the following steps:; // - When IR is generated from AST the calls to intrinsic function; // llvm.preserve.static.offset are inserted.; // - BPFPreserveStaticOffsetPass is executed as early as possible; // with AllowPatial set to true, this handles marked GEP chains; // with constant offsets.; // - BPFPreserveStaticOffsetPass is executed at ScalarOptimizerLateEPCallback; // with AllowPatial set to false, this handles marked GEP chains; // with offsets that became constant after loop unrolling, e.g.; // to handle the following code:; //; // struct context { int x[4]; } __attribute__((preserve_static_offset));; //; // struct context *ctx = ...;; // #pragma clang loop unroll(full); // for (int i = 0; i < 4; ++i); // foo(ctx->x[i]);; //; // The early BPFPreserveStaticOffsetPass run is necessary to allow; // additional GVN / CSE opportunities after functions inlining.; // The relative order of optimization applied to function:; // - early stage (1); // - ...; // - function inlining (2); // - ...; // - loop unrolling; // - ...; // - ScalarOptimizerLateEPCallback (3); //; // When function A is inlined into function B all optimizations for A; // are already done, while some passes remain for B. In case if; // BPFPreserveStaticOffsetPass is done at (3) but not done at (1); // the code after (2) would contain a mix of; // (load (gep %p)) and (get.and.load %p) usages:; // - the (load (gep %p)) would come from the calling function;; // - the (get.and.load %p) would come from the callee function.; // Thus clobbering CSE / GVN passes done after inlining.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp:4235,Performance,load,load,4235,"m.; //; // To avoid this issue the patterns like (load/store (getelementptr ...)); // are replaced by calls to BPF specific intrinsic functions:; // - llvm.bpf.getelementptr.and.load; // - llvm.bpf.getelementptr.and.store; //; // These calls are lowered back to (load/store (getelementptr ...)); // by BPFCheckAndAdjustIR pass right before the translation from IR to; // machine instructions.; //; // The transformation is split into the following steps:; // - When IR is generated from AST the calls to intrinsic function; // llvm.preserve.static.offset are inserted.; // - BPFPreserveStaticOffsetPass is executed as early as possible; // with AllowPatial set to true, this handles marked GEP chains; // with constant offsets.; // - BPFPreserveStaticOffsetPass is executed at ScalarOptimizerLateEPCallback; // with AllowPatial set to false, this handles marked GEP chains; // with offsets that became constant after loop unrolling, e.g.; // to handle the following code:; //; // struct context { int x[4]; } __attribute__((preserve_static_offset));; //; // struct context *ctx = ...;; // #pragma clang loop unroll(full); // for (int i = 0; i < 4; ++i); // foo(ctx->x[i]);; //; // The early BPFPreserveStaticOffsetPass run is necessary to allow; // additional GVN / CSE opportunities after functions inlining.; // The relative order of optimization applied to function:; // - early stage (1); // - ...; // - function inlining (2); // - ...; // - loop unrolling; // - ...; // - ScalarOptimizerLateEPCallback (3); //; // When function A is inlined into function B all optimizations for A; // are already done, while some passes remain for B. In case if; // BPFPreserveStaticOffsetPass is done at (3) but not done at (1); // the code after (2) would contain a mix of; // (load (gep %p)) and (get.and.load %p) usages:; // - the (load (gep %p)) would come from the calling function;; // - the (get.and.load %p) would come from the callee function.; // Thus clobbering CSE / GVN passes done after inlining.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp:4307,Performance,load,load,4307,"m.; //; // To avoid this issue the patterns like (load/store (getelementptr ...)); // are replaced by calls to BPF specific intrinsic functions:; // - llvm.bpf.getelementptr.and.load; // - llvm.bpf.getelementptr.and.store; //; // These calls are lowered back to (load/store (getelementptr ...)); // by BPFCheckAndAdjustIR pass right before the translation from IR to; // machine instructions.; //; // The transformation is split into the following steps:; // - When IR is generated from AST the calls to intrinsic function; // llvm.preserve.static.offset are inserted.; // - BPFPreserveStaticOffsetPass is executed as early as possible; // with AllowPatial set to true, this handles marked GEP chains; // with constant offsets.; // - BPFPreserveStaticOffsetPass is executed at ScalarOptimizerLateEPCallback; // with AllowPatial set to false, this handles marked GEP chains; // with offsets that became constant after loop unrolling, e.g.; // to handle the following code:; //; // struct context { int x[4]; } __attribute__((preserve_static_offset));; //; // struct context *ctx = ...;; // #pragma clang loop unroll(full); // for (int i = 0; i < 4; ++i); // foo(ctx->x[i]);; //; // The early BPFPreserveStaticOffsetPass run is necessary to allow; // additional GVN / CSE opportunities after functions inlining.; // The relative order of optimization applied to function:; // - early stage (1); // - ...; // - function inlining (2); // - ...; // - loop unrolling; // - ...; // - ScalarOptimizerLateEPCallback (3); //; // When function A is inlined into function B all optimizations for A; // are already done, while some passes remain for B. In case if; // BPFPreserveStaticOffsetPass is done at (3) but not done at (1); // the code after (2) would contain a mix of; // (load (gep %p)) and (get.and.load %p) usages:; // - the (load (gep %p)) would come from the calling function;; // - the (get.and.load %p) would come from the callee function.; // Thus clobbering CSE / GVN passes done after inlining.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp:2424,Safety,avoid,avoid,2424,"//; // During BPF program verification a tag PTR_TO_CTX is tracked for; // register values. In case if register with such tag is modified; // BPF program is not allowed to read or write memory using this; // register. See kernel/bpf/verifier.c:check_mem_access function; // in the Linux kernel source tree for details.; //; // The following sequence of the IR instructions:; //; // %x = getelementptr %ptr, %constant_offset; // %y = load %x; //; // Is translated as a single machine instruction:; //; // LDW %ptr, %constant_offset; //; // In order for cases (a) and (b) to work the sequence %x-%y above has; // to be preserved by the IR passes.; //; // However, several optimization passes might sink `load` instruction; // or hoist `getelementptr` instruction so that the instructions are; // no longer in sequence. Examples of such passes are:; // SimplifyCFGPass, InstCombinePass, GVNPass.; // After such modification the verifier would reject the BPF program.; //; // To avoid this issue the patterns like (load/store (getelementptr ...)); // are replaced by calls to BPF specific intrinsic functions:; // - llvm.bpf.getelementptr.and.load; // - llvm.bpf.getelementptr.and.store; //; // These calls are lowered back to (load/store (getelementptr ...)); // by BPFCheckAndAdjustIR pass right before the translation from IR to; // machine instructions.; //; // The transformation is split into the following steps:; // - When IR is generated from AST the calls to intrinsic function; // llvm.preserve.static.offset are inserted.; // - BPFPreserveStaticOffsetPass is executed as early as possible; // with AllowPatial set to true, this handles marked GEP chains; // with constant offsets.; // - BPFPreserveStaticOffsetPass is executed at ScalarOptimizerLateEPCallback; // with AllowPatial set to false, this handles marked GEP chains; // with offsets that became constant after loop unrolling, e.g.; // to handle the following code:; //; // struct context { int x[4]; } __attribute__((preserve_static_",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp:647,Security,Access,Access,647,"//===------ BPFPreserveStaticOffset.cpp -----------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // TLDR: replaces llvm.preserve.static.offset + GEP + load / store; // with llvm.bpf.getelementptr.and.load / store; //; // This file implements BPFPreserveStaticOffsetPass transformation.; // This transformation address two BPF verifier specific issues:; //; // (a) Access to the fields of some structural types is allowed only; // using load and store instructions with static immediate offsets.; //; // Examples of such types are `struct __sk_buff` and `struct; // bpf_sock_ops`. This is so because offsets of the fields of; // these structures do not match real offsets in the running; // kernel. During BPF program load LDX and STX instructions; // referring to the fields of these types are rewritten so that; // offsets match real offsets. For this rewrite to happen field; // offsets have to be encoded as immediate operands of the; // instructions.; //; // See kernel/bpf/verifier.c:convert_ctx_access function in the; // Linux kernel source tree for details.; //; // (b) Pointers to context parameters of BPF programs must not be; // modified before access.; //; // During BPF program verification a tag PTR_TO_CTX is tracked for; // register values. In case if register with such tag is modified; // BPF program is not allowed to read or write memory using this; // register. See kernel/bpf/verifier.c:check_mem_access function; // in the Linux kernel source tree for details.; //; // The following sequence of the IR instructions:; //; // %x = getelementptr %ptr, %constant_offset; // %y = load %x; //; // Is translated as a single machine instruction:; //; // LDW %ptr, %constant_offset; //; // In order for ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp:1440,Security,access,access,1440," llvm.preserve.static.offset + GEP + load / store; // with llvm.bpf.getelementptr.and.load / store; //; // This file implements BPFPreserveStaticOffsetPass transformation.; // This transformation address two BPF verifier specific issues:; //; // (a) Access to the fields of some structural types is allowed only; // using load and store instructions with static immediate offsets.; //; // Examples of such types are `struct __sk_buff` and `struct; // bpf_sock_ops`. This is so because offsets of the fields of; // these structures do not match real offsets in the running; // kernel. During BPF program load LDX and STX instructions; // referring to the fields of these types are rewritten so that; // offsets match real offsets. For this rewrite to happen field; // offsets have to be encoded as immediate operands of the; // instructions.; //; // See kernel/bpf/verifier.c:convert_ctx_access function in the; // Linux kernel source tree for details.; //; // (b) Pointers to context parameters of BPF programs must not be; // modified before access.; //; // During BPF program verification a tag PTR_TO_CTX is tracked for; // register values. In case if register with such tag is modified; // BPF program is not allowed to read or write memory using this; // register. See kernel/bpf/verifier.c:check_mem_access function; // in the Linux kernel source tree for details.; //; // The following sequence of the IR instructions:; //; // %x = getelementptr %ptr, %constant_offset; // %y = load %x; //; // Is translated as a single machine instruction:; //; // LDW %ptr, %constant_offset; //; // In order for cases (a) and (b) to work the sequence %x-%y above has; // to be preserved by the IR passes.; //; // However, several optimization passes might sink `load` instruction; // or hoist `getelementptr` instruction so that the instructions are; // no longer in sequence. Examples of such passes are:; // SimplifyCFGPass, InstCombinePass, GVNPass.; // After such modification the verifier would reject th",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp:2299,Usability,Simpl,SimplifyCFGPass,2299,"the; // Linux kernel source tree for details.; //; // (b) Pointers to context parameters of BPF programs must not be; // modified before access.; //; // During BPF program verification a tag PTR_TO_CTX is tracked for; // register values. In case if register with such tag is modified; // BPF program is not allowed to read or write memory using this; // register. See kernel/bpf/verifier.c:check_mem_access function; // in the Linux kernel source tree for details.; //; // The following sequence of the IR instructions:; //; // %x = getelementptr %ptr, %constant_offset; // %y = load %x; //; // Is translated as a single machine instruction:; //; // LDW %ptr, %constant_offset; //; // In order for cases (a) and (b) to work the sequence %x-%y above has; // to be preserved by the IR passes.; //; // However, several optimization passes might sink `load` instruction; // or hoist `getelementptr` instruction so that the instructions are; // no longer in sequence. Examples of such passes are:; // SimplifyCFGPass, InstCombinePass, GVNPass.; // After such modification the verifier would reject the BPF program.; //; // To avoid this issue the patterns like (load/store (getelementptr ...)); // are replaced by calls to BPF specific intrinsic functions:; // - llvm.bpf.getelementptr.and.load; // - llvm.bpf.getelementptr.and.store; //; // These calls are lowered back to (load/store (getelementptr ...)); // by BPFCheckAndAdjustIR pass right before the translation from IR to; // machine instructions.; //; // The transformation is split into the following steps:; // - When IR is generated from AST the calls to intrinsic function; // llvm.preserve.static.offset are inserted.; // - BPFPreserveStaticOffsetPass is executed as early as possible; // with AllowPatial set to true, this handles marked GEP chains; // with constant offsets.; // - BPFPreserveStaticOffsetPass is executed at ScalarOptimizerLateEPCallback; // with AllowPatial set to false, this handles marked GEP chains; // with offsets tha",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp:937,Integrability,message,message,937,"// A DFS traversal of GEP chain trees starting from Root.; //; // Recursion descends through GEP instructions and; // llvm.preserve.static.offset calls. Recursion stops at any other; // instruction. If load or store instruction is reached it is replaced; // by a call to `llvm.bpf.getelementptr.and.load` or; // `llvm.bpf.getelementptr.and.store` intrinsic.; // If `llvm.bpf.getelementptr.and.load/store` is reached the accumulated; // GEPs are merged into the intrinsic call.; // If nested calls to `llvm.preserve.static.offset` are encountered these; // calls are marked for deletion.; //; // Parameters description:; // - Insn - current position in the tree; // - GEPs - GEP instructions for the current branch; // - Visited - a list of visited instructions in DFS order,; // order is important for unused instruction deletion.; // - AllowPartial - when true GEP chains that can't be folded are; // not reported, otherwise diagnostic message is show for such chains.; // - StillUsed - set to true if one of the GEP chains could not be; // folded, makes sense when AllowPartial is false, means that root; // preserve.static.offset call is still in use and should remain; // until the next run of this pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp:202,Performance,load,load,202,"// A DFS traversal of GEP chain trees starting from Root.; //; // Recursion descends through GEP instructions and; // llvm.preserve.static.offset calls. Recursion stops at any other; // instruction. If load or store instruction is reached it is replaced; // by a call to `llvm.bpf.getelementptr.and.load` or; // `llvm.bpf.getelementptr.and.store` intrinsic.; // If `llvm.bpf.getelementptr.and.load/store` is reached the accumulated; // GEPs are merged into the intrinsic call.; // If nested calls to `llvm.preserve.static.offset` are encountered these; // calls are marked for deletion.; //; // Parameters description:; // - Insn - current position in the tree; // - GEPs - GEP instructions for the current branch; // - Visited - a list of visited instructions in DFS order,; // order is important for unused instruction deletion.; // - AllowPartial - when true GEP chains that can't be folded are; // not reported, otherwise diagnostic message is show for such chains.; // - StillUsed - set to true if one of the GEP chains could not be; // folded, makes sense when AllowPartial is false, means that root; // preserve.static.offset call is still in use and should remain; // until the next run of this pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp:299,Performance,load,load,299,"// A DFS traversal of GEP chain trees starting from Root.; //; // Recursion descends through GEP instructions and; // llvm.preserve.static.offset calls. Recursion stops at any other; // instruction. If load or store instruction is reached it is replaced; // by a call to `llvm.bpf.getelementptr.and.load` or; // `llvm.bpf.getelementptr.and.store` intrinsic.; // If `llvm.bpf.getelementptr.and.load/store` is reached the accumulated; // GEPs are merged into the intrinsic call.; // If nested calls to `llvm.preserve.static.offset` are encountered these; // calls are marked for deletion.; //; // Parameters description:; // - Insn - current position in the tree; // - GEPs - GEP instructions for the current branch; // - Visited - a list of visited instructions in DFS order,; // order is important for unused instruction deletion.; // - AllowPartial - when true GEP chains that can't be folded are; // not reported, otherwise diagnostic message is show for such chains.; // - StillUsed - set to true if one of the GEP chains could not be; // folded, makes sense when AllowPartial is false, means that root; // preserve.static.offset call is still in use and should remain; // until the next run of this pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp:393,Performance,load,load,393,"// A DFS traversal of GEP chain trees starting from Root.; //; // Recursion descends through GEP instructions and; // llvm.preserve.static.offset calls. Recursion stops at any other; // instruction. If load or store instruction is reached it is replaced; // by a call to `llvm.bpf.getelementptr.and.load` or; // `llvm.bpf.getelementptr.and.store` intrinsic.; // If `llvm.bpf.getelementptr.and.load/store` is reached the accumulated; // GEPs are merged into the intrinsic call.; // If nested calls to `llvm.preserve.static.offset` are encountered these; // calls are marked for deletion.; //; // Parameters description:; // - Insn - current position in the tree; // - GEPs - GEP instructions for the current branch; // - Visited - a list of visited instructions in DFS order,; // order is important for unused instruction deletion.; // - AllowPartial - when true GEP chains that can't be folded are; // not reported, otherwise diagnostic message is show for such chains.; // - StillUsed - set to true if one of the GEP chains could not be; // folded, makes sense when AllowPartial is false, means that root; // preserve.static.offset call is still in use and should remain; // until the next run of this pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp:43,Performance,load,load,43,// Do nothing for (preserve.static.offset (load/store ..)) or for; // GEPs with zero indices. Such constructs lead to zero offset and; // are simplified by other passes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp:142,Usability,simpl,simplified,142,// Do nothing for (preserve.static.offset (load/store ..)) or for; // GEPs with zero indices. Such constructs lead to zero offset and; // are simplified by other passes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp:64,Performance,Load,Load,64,"// This case can't be merged with the above because; // `delete Load` / `delete Store` wants a concrete type,; // destructor of Instruction is protected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp:80,Performance,load,load,80,// Look for sequences:; // - llvm.preserve.static.offset -> getelementptr... -> load; // - llvm.preserve.static.offset -> getelementptr... -> store; // And replace those with calls to intrinsics:; // - llvm.bpf.getelementptr.and.load; // - llvm.bpf.getelementptr.and.store,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp:229,Performance,load,load,229,// Look for sequences:; // - llvm.preserve.static.offset -> getelementptr... -> load; // - llvm.preserve.static.offset -> getelementptr... -> store; // And replace those with calls to intrinsics:; // - llvm.bpf.getelementptr.and.load; // - llvm.bpf.getelementptr.and.store,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFSubtarget.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFSubtarget.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFTargetMachine.cpp:27,Deployability,Configurat,Configuration,27,// BPF Code Generator Pass Configuration Options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFTargetMachine.cpp:27,Modifiability,Config,Configuration,27,// BPF Code Generator Pass Configuration Options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFTargetMachine.cpp:48,Usability,Simpl,SimplifyCFGPass,48,// Run this after loop unrolling but before; // SimplifyCFGPass(... .sinkCommonInsts(true)),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFTargetMachine.cpp:3,Deployability,Install,Install,3,// Install an instruction selector pass using; // the ISelDag to gen BPF code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BPFTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp:11,Safety,avoid,avoid,11,"/// Try to avoid chasing pointees, esp. structure pointees which may; /// unnecessary bring in a lot of types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp:24,Availability,CheckPoint,CheckPointer,24,/// Visit a type entry. CheckPointer is true if the type has; /// one of its predecessors as one struct/union member. SeenPointer; /// is true if CheckPointer is true and one of its predecessors; /// is a pointer. The goal of CheckPointer and SeenPointer is to; /// do pruning for struct/union types so some of these types; /// will not be emitted in BTF and rather forward declarations; /// will be generated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp:146,Availability,CheckPoint,CheckPointer,146,/// Visit a type entry. CheckPointer is true if the type has; /// one of its predecessors as one struct/union member. SeenPointer; /// is true if CheckPointer is true and one of its predecessors; /// is a pointer. The goal of CheckPointer and SeenPointer is to; /// do pruning for struct/union types so some of these types; /// will not be emitted in BTF and rather forward declarations; /// will be generated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp:226,Availability,CheckPoint,CheckPointer,226,/// Visit a type entry. CheckPointer is true if the type has; /// one of its predecessors as one struct/union member. SeenPointer; /// is true if CheckPointer is true and one of its predecessors; /// is a pointer. The goal of CheckPointer and SeenPointer is to; /// do pruning for struct/union types so some of these types; /// will not be emitted in BTF and rather forward declarations; /// will be generated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp:386,Safety,avoid,avoid,386,"// To handle the case like the following:; // struct t;; // typedef struct t _t;; // struct s1 { _t *c; };; // int test1(struct s1 *arg) { ... }; //; // struct t { int a; int b; };; // struct s2 { _t c; }; // int test2(struct s2 *arg) { ... }; //; // During traversing test1() argument, ""_t"" is recorded; // in DIToIdMap and a forward declaration fixup is created; // for ""struct t"" to avoid pointee type traversal.; //; // During traversing test2() argument, even if we see ""_t"" is; // already defined, we should keep moving to eventually; // bring in types for ""struct t"". Otherwise, the ""struct s2""; // definition won't be correct.; //; // In the above, we have following debuginfo:; // {ptr, struct_member} -> typedef -> struct; // and BTF type for 'typedef' is generated while 'struct' may; // be in FixUp. But let us generalize the above to handle; // {different types} -> [various derived types]+ -> another type.; // For example,; // {func_param, struct_member} -> const -> ptr -> volatile -> struct; // We will traverse const/ptr/volatile which already have corresponding; // BTF types and generate type for 'struct' which might be in Fixup; // state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp:26,Availability,avail,available,26,"// If file content is not available, let LineOff = 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp:68,Security,access,accessing,68,/// On-demand populate types as requested from abstract member; /// accessing or preserve debuginfo type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp:16,Modifiability,variab,variable,16,// Not a global variable. Maybe an extern function reference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp:24,Performance,load,load,24,"// relocation insn is a load, store or shift insn.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp:42,Modifiability,variab,variable,42,// Create a .rodata datasec if the global variable is an initialized; // constant with private linkage and if it won't be in .rodata.str<#>; // and .rodata.cst<#> sections.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp:52,Modifiability,variab,variables,52,// Only support the following globals:; // . static variables; // . non-static weak or non-weak global variables; // . weak or non-weak extern global variables; // Whether DataSec is readonly or not can be found from corresponding ELF; // section flags. Whether a BTF_KIND_VAR is a weak symbol or not; // can be found from the corresponding ELF symbol table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp:103,Modifiability,variab,variables,103,// Only support the following globals:; // . static variables; // . non-static weak or non-weak global variables; // . weak or non-weak extern global variables; // Whether DataSec is readonly or not can be found from corresponding ELF; // section flags. Whether a BTF_KIND_VAR is a weak symbol or not; // can be found from the corresponding ELF symbol table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp:150,Modifiability,variab,variables,150,// Only support the following globals:; // . static variables; // . non-static weak or non-weak global variables; // . weak or non-weak extern global variables; // Whether DataSec is readonly or not can be found from corresponding ELF; // section flags. Whether a BTF_KIND_VAR is a weak symbol or not; // can be found from the corresponding ELF symbol table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp:36,Modifiability,variab,variable,36,// An empty SecName means an extern variable without section attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp:16,Deployability,patch,patchable,16,/// Emit proper patchable instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp:24,Modifiability,variab,variables,24,// Collect global types/variables except MapDef globals.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.h:117,Availability,avail,available,117,/// Complete BTF type generation after all related DebugInfo types; /// have been visited so their BTF type id's are available; /// for cross referece.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.h:11,Modifiability,variab,variable,11,/// Handle variable instances,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.h:85,Safety,avoid,avoid,85,/// A mapping from string table offset to the index; /// of the Table. It is used to avoid putting; /// duplicated strings in the table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.h:13,Deployability,patch,patch,13,///< What to patch the instruction,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.h:23,Modifiability,variab,variables,23,/// Generate types and variables for globals.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.h:19,Modifiability,variab,variables,19,/// Process global variables referenced by relocation instructions; /// and extern function references.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/MCTargetDesc/BPFAsmBackend.cpp:29,Modifiability,variab,variables,29,"// The Value is 0 for global variables, and the in-section offset; // for static variables. Write to the immediate field of the inst.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/MCTargetDesc/BPFAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/MCTargetDesc/BPFAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/MCTargetDesc/BPFAsmBackend.cpp:81,Modifiability,variab,variables,81,"// The Value is 0 for global variables, and the in-section offset; // for static variables. Write to the immediate field of the inst.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/MCTargetDesc/BPFAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/MCTargetDesc/BPFAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/MCTargetDesc/BPFELFObjectWriter.cpp:44,Modifiability,variab,variable,44,// .BTF generates FK_Data_4 relocations for variable; // offset in DataSec kind.; // The reloc symbol should be in data section.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/MCTargetDesc/BPFELFObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/MCTargetDesc/BPFELFObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/MCTargetDesc/BPFMCTargetDesc.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/BPF/MCTargetDesc/BPFMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/MCTargetDesc/BPFMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKY.h:27,Integrability,interface,interface,27,"//===-- CSKY.h - Top-level interface for CSKY--------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the entry points for global functions defined in the LLVM; // CSKY back-end.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKY.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKY.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYAsmPrinter.cpp:474,Integrability,depend,dependent,474,"//===-- CSKYAsmPrinter.cpp - CSKY LLVM assembly writer --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a printer that converts from our internal representation; // of machine-dependent LLVM code to the CSKY assembly language.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYAsmPrinter.cpp:3,Usability,Simpl,Simple,3,// Simple pseudo-instructions have their lowering (with expansion to real; // instructions) auto-generated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYAsmPrinter.cpp:3,Performance,Tune,TuneCPU,3,"/* TuneCPU doesn't impact emission of ELF attributes, ELF attributes only; care about arch related features, so we can set TuneCPU as CPU. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYAsmPrinter.cpp:123,Performance,Tune,TuneCPU,123,"/* TuneCPU doesn't impact emission of ELF attributes, ELF attributes only; care about arch related features, so we can set TuneCPU as CPU. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYAsmPrinter.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYAsmPrinter.h:47,Usability,simpl,simple,47,/// tblgen'erated driver function for lowering simple MI->MC; /// pseudo instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYAsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYAsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYCallingConv.h:57,Integrability,Rout,Routines,57,"//=== CSKYCallingConv.h - CSKY Custom Calling Convention Routines -*-C++-*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the custom routines for the CSKY Calling Convention that; // aren't done by tablegen.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYCallingConv.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYCallingConv.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYCallingConv.h:413,Integrability,rout,routines,413,"//=== CSKYCallingConv.h - CSKY Custom Calling Convention Routines -*-C++-*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the custom routines for the CSKY Calling Convention that; // aren't done by tablegen.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYCallingConv.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYCallingConv.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp:53,Performance,load,loads,53,"//===- CSKYConstantIslandPass.cpp - Emit PC Relative loads ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //; // Loading constants inline is expensive on CSKY and it's in general better; // to place the constant nearby in code space and then it can be loaded with a; // simple 16/32 bit load instruction like lrw.; //; // The constants can be not just numbers but addresses of functions and labels.; // This can be particularly helpful in static relocation mode for embedded; // non-linux targets.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp:387,Performance,Load,Loading,387,"//===- CSKYConstantIslandPass.cpp - Emit PC Relative loads ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //; // Loading constants inline is expensive on CSKY and it's in general better; // to place the constant nearby in code space and then it can be loaded with a; // simple 16/32 bit load instruction like lrw.; //; // The constants can be not just numbers but addresses of functions and labels.; // This can be particularly helpful in static relocation mode for embedded; // non-linux targets.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp:526,Performance,load,loaded,526,"//===- CSKYConstantIslandPass.cpp - Emit PC Relative loads ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //; // Loading constants inline is expensive on CSKY and it's in general better; // to place the constant nearby in code space and then it can be loaded with a; // simple 16/32 bit load instruction like lrw.; //; // The constants can be not just numbers but addresses of functions and labels.; // This can be particularly helpful in static relocation mode for embedded; // non-linux targets.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp:561,Performance,load,load,561,"//===- CSKYConstantIslandPass.cpp - Emit PC Relative loads ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //; // Loading constants inline is expensive on CSKY and it's in general better; // to place the constant nearby in code space and then it can be loaded with a; // simple 16/32 bit load instruction like lrw.; //; // The constants can be not just numbers but addresses of functions and labels.; // This can be particularly helpful in static relocation mode for embedded; // non-linux targets.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp:544,Usability,simpl,simple,544,"//===- CSKYConstantIslandPass.cpp - Emit PC Relative loads ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //; // Loading constants inline is expensive on CSKY and it's in general better; // to place the constant nearby in code space and then it can be loaded with a; // simple 16/32 bit load instruction like lrw.; //; // The constants can be not just numbers but addresses of functions and labels.; // This can be particularly helpful in static relocation mode for embedded; // non-linux targets.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp:742,Usability,resume,resume,742,"/// CPUser - One user of a constant pool, keeping the machine instruction; /// pointer, the constant pool being referenced, and the max displacement; /// allowed from the instruction to the CP. The HighWaterMark records the; /// highest basic block where a new CPEntry can be placed. To ensure this; /// pass terminates, the CP entries are initially placed at the end of the; /// function and then move monotonically to lower addresses. The; /// exception to this rule is when the current CP entry for a particular; /// CPUser is out of range, but there is another CP entry for the same; /// constant value in range. We want to use the existing in-range CP; /// entry, but if it later moves out of range, the search for new water; /// should resume where it left off. The HighWaterMark is used to record; /// that point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp:3,Performance,Perform,Perform,3,"// Perform the initial placement of the constant pool entries. To start with,; // we put them all at the end of the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp:3,Usability,Clear,Clear,3,"// Clear NewWaterList now. If we split a block for branches, it should; // appear as ""new water"" for the next iteration of constant pool placement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp:25,Performance,Perform,Perform,25,"/// doInitialPlacement - Perform the initial placement of the constant pool; /// entries. To start with, we put them all at the end of the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp:99,Deployability,update,updates,99,/// computeBlockSize - Compute the size and some alignment information for MBB.; /// This function updates BBInfo directly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp:4,Deployability,update,updateForInsertedWaterBlock,4,"/// updateForInsertedWaterBlock - When a block is newly inserted into the; /// machine function, it upsets all of the block numbers. Renumber the blocks; /// and update the arrays that parallel this numbering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp:162,Deployability,update,update,162,"/// updateForInsertedWaterBlock - When a block is newly inserted into the; /// machine function, it upsets all of the block numbers. Renumber the blocks; /// and update the arrays that parallel this numbering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp:77,Availability,avail,available,77,"// Next, update WaterList. Specifically, we need to add NewMBB as having; // available water after it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp:9,Deployability,update,update,9,"// Next, update WaterList. Specifically, we need to add NewMBB as having; // available water after it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp:107,Deployability,Update,Update,107,"/// Split the basic block containing MI into two blocks, which are joined by; /// an unconditional branch. Update data structures and renumber blocks to; /// account for this change and returns the newly created block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp:164,Availability,avail,available,164,// Add an unconditional branch from OrigBB to NewBB.; // Note the new unconditional branch is not being recorded.; // There doesn't seem to be meaningful DebugInfo available; this doesn't; // correspond to anything in the source.; // TODO: Add support for 16bit instr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp:3,Deployability,Update,Update,3,// Update the CFG. All succs of OrigBB are now succs of NewBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp:3,Deployability,Update,Update,3,"// Update internal data structures to account for the newly inserted MBB.; // This is almost the same as updateForInsertedWaterBlock, except that; // the Water goes after OrigBB, not NewBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp:105,Deployability,update,updateForInsertedWaterBlock,105,"// Update internal data structures to account for the newly inserted MBB.; // This is almost the same as updateForInsertedWaterBlock, except that; // the Water goes after OrigBB, not NewBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp:78,Availability,avail,available,78,"// Next, update WaterList. Specifically, we need to add OrigMBB as having; // available water after it (but not if it's already there, which happens; // when splitting before a conditional branch that is followed by an; // unconditional branch - in that case we want to insert NewBB).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp:9,Deployability,update,update,9,"// Next, update WaterList. Specifically, we need to add OrigMBB as having; // available water after it (but not if it's already there, which happens; // when splitting before a conditional branch that is followed by an; // unconditional branch - in that case we want to insert NewBB).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp:146,Deployability,update,updated,146,"// If the original WaterList entry was ""new water"" on this iteration,; // propagate that to the new island. This is just keeping NewWaterList; // updated to match the WaterList, which will be updated below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp:192,Deployability,update,updated,192,"// If the original WaterList entry was ""new water"" on this iteration,; // propagate that to the new island. This is just keeping NewWaterList; // updated to match the WaterList, which will be updated below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp:28,Deployability,Update,Update,28,// We are adding new water. Update NewWaterList.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp:156,Energy Efficiency,reduce,reduces,156,// Remove the original WaterList entry; we want subsequent insertions in; // this vicinity to go after the one we're about to insert. This; // considerably reduces the number of times we have to move the same CPE; // more than once and is also important to ensure the algorithm terminates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp:3,Deployability,Update,Update,3,// Update internal data structures to account for the newly inserted MBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp:69,Deployability,Update,Update,69,/// removeDeadCPEMI - Remove a dead constant pool entry instruction. Update; /// sizes and offsets of impacted basic blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp:245,Deployability,update,updated,245,"// Add an unconditional branch to the destination and invert the branch; // condition to jump over it:; // bteqz L1; // =>; // bnez L2; // b L1; // L2:; // If the branch is at the end of its MBB and that has a fall-through block,; // direct the updated conditional branch to the fall-through block. Otherwise,; // split the MBB before the next instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp:56,Usability,simpl,simply,56,// Last MI in the BB is an unconditional branch. Can we simply invert the; // condition and swap destinations:; // beqz L1; // b L2; // =>; // bnez L2; // b L1,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp:141,Deployability,update,update,141,"// BBInfo[SplitBB].Offset is wrong temporarily, fixed below; // The conditional successor will be swapped between the BBs after this, so; // update CFG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp:76,Deployability,update,update,76,// Insert a new conditional branch and a new unconditional branch.; // Also update the ImmBranch as well as adding a new entry for the new branch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantPoolValue.h:166,Performance,load,load,166,"// namespace CSKYCP; /// CSKYConstantPoolValue - CSKY specific constantpool value. This is used to; /// represent PC-relative displacement between the address of the load; /// instruction and the constant being loaded, i.e. (&GV-(LPIC+8)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantPoolValue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantPoolValue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantPoolValue.h:211,Performance,load,loaded,211,"// namespace CSKYCP; /// CSKYConstantPoolValue - CSKY specific constantpool value. This is used to; /// represent PC-relative displacement between the address of the load; /// instruction and the constant being loaded, i.e. (&GV-(LPIC+8)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantPoolValue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantPoolValue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantPoolValue.h:18,Performance,load,loaded,18,// Constant being loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantPoolValue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantPoolValue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantPoolValue.h:19,Performance,load,loaded,19,// ExtSymbol being loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantPoolValue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantPoolValue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYFrameLowering.cpp:6,Safety,avoid,avoid,6,"// To avoid the BP value clobbered by a function call, we need to choose a; // callee saved register to save the value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYFrameLowering.cpp:30,Energy Efficiency,allocate,allocate,30,// Get the number of bytes to allocate from the FrameInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYFrameLowering.cpp:3,Deployability,Update,Update,3,// Update frame info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYFrameLowering.cpp:122,Energy Efficiency,allocate,allocate,122,// FIXME (note copied from Lanai): This appears to be overallocating. Needs; // investigation. Get the number of bytes to allocate from the FrameInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYFrameLowering.cpp:37,Energy Efficiency,allocate,allocate,37,// Early exit if there is no need to allocate on the stack,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYFrameLowering.cpp:183,Modifiability,variab,variable,183,"// FP will be used to restore the frame in the epilogue, so we need; // another base register BP to record SP after re-alignment. SP will; // track the current stack after allocating variable sized objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYFrameLowering.cpp:57,Modifiability,variab,variables,57,// Not preserve stack space within prologue for outgoing variables when the; // function contains variable size objects and let eliminateCallFramePseudoInstr; // preserve stack space for it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYFrameLowering.cpp:98,Modifiability,variab,variable,98,// Not preserve stack space within prologue for outgoing variables when the; // function contains variable size objects and let eliminateCallFramePseudoInstr; // preserve stack space for it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYFrameLowering.cpp:281,Energy Efficiency,allocate,allocate,281,"// If space has not been reserved for a call frame, ADJCALLSTACKDOWN and; // ADJCALLSTACKUP must be converted to instructions manipulating the stack; // pointer. This is necessary when there is a variable length stack; // allocation (e.g. alloca), which means it's not possible to allocate; // space for outgoing arguments from within the function prologue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYFrameLowering.cpp:196,Modifiability,variab,variable,196,"// If space has not been reserved for a call frame, ADJCALLSTACKDOWN and; // ADJCALLSTACKUP must be converted to instructions manipulating the stack; // pointer. This is necessary when there is a variable length stack; // allocation (e.g. alloca), which means it's not possible to allocate; // space for outgoing arguments from within the function prologue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYInstrInfo.cpp:3,Performance,Optimiz,Optimize,3,// Optimize for 16bit,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelDAGToDAG.cpp:326,Deployability,update,update,326,"// Memory operands to inline asm in the SelectionDAG are modeled with two; // operands: a constant of value InlineAsm::Kind::Mem followed by the input; // operand. If we get here and we have a Kind::Mem, skip the next operand; // (so it doesn't get misinterpreted), and continue. We do this here because; // it's important to update the OpChanged array correctly before moving on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelDAGToDAG.cpp:3,Deployability,Update,Update,3,// Update the original glue user.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelDAGToDAG.cpp:19,Usability,simpl,simple,19,// We just support simple memory operands that have a single address; // operand and need no special handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelLowering.cpp:404,Integrability,interface,interfaces,404,"//===-- CSKYISelLowering.cpp - CSKY DAG Lowering Implementation ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that CSKY uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelLowering.cpp:23,Modifiability,variab,variable,23,"// Offset of the first variable argument from stack pointer, and size of; // the vararg save area. For now, the varargs save area is either zero or; // large enough to hold a0-a4.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelLowering.cpp:24,Energy Efficiency,allocate,allocated,24,"// If all registers are allocated, then all varargs must be passed on the; // stack and we don't need to save any argregs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelLowering.cpp:39,Modifiability,variab,variable,39,// Record the frame index of the first variable argument; // which is a value necessary to VASTART.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelLowering.cpp:3,Deployability,Update,Update,3,// Update chain.; // Add the glue node if we have it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelLowering.cpp:21,Integrability,rout,routines,21,// Interrupt service routines use different return instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelLowering.cpp:3,Performance,Queue,Queue,3,// Queue up the argument copies and emit them at the end.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelLowering.cpp:18,Availability,mask,mask,18,// Add a register mask operand representing the call-preserved registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelLowering.cpp:251,Availability,avail,available,251,"// Since TargetLowering::getRegForInlineAsmConstraint uses the name of the; // TableGen record rather than the AsmName to choose registers for InlineAsm; // constraints, plus we want to match those names to the widest floating point; // register type available, manually select floating point registers here.; //; // The second case is the ABI name of the register, so that frontends can also; // use the ABI names in register constraint lists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelLowering.cpp:3,Deployability,Update,Update,3,// Update machine-CFG edges,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelLowering.h:404,Integrability,interface,interfaces,404,"//===-- CSKYISelLowering.cpp - CSKY DAG Lowering Implementation ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that CSKY uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYRegisterInfo.cpp:43,Energy Efficiency,allocate,allocate,43,// Reserve the base register if we need to allocate; // variable-sized objects at runtime.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYRegisterInfo.cpp:56,Modifiability,variab,variable-sized,56,// Reserve the base register if we need to allocate; // variable-sized objects at runtime.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYTargetMachine.cpp:86,Integrability,depend,depend,86,// This needs to be done before we create a new subtarget since any; // creation will depend on the TM and the code generation flags on the; // function that reside in TargetOptions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/AsmParser/CSKYAsmParser.cpp:120,Performance,perform,performed,120,"// Helper to actually emit an instruction to the MCStreamer. Also, when; // possible, compression of the instruction is performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/AsmParser/CSKYAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/AsmParser/CSKYAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/AsmParser/CSKYAsmParser.cpp:3,Performance,Cache,Cache,3,// Cache the MCRegisterInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/AsmParser/CSKYAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/AsmParser/CSKYAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/AsmParser/CSKYAsmParser.cpp:28,Availability,error,error,28,"// Handle the case when the error message is of specific type; // other than the generic Match_InvalidOperand, and the; // corresponding operand is missing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/AsmParser/CSKYAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/AsmParser/CSKYAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/AsmParser/CSKYAsmParser.cpp:34,Integrability,message,message,34,"// Handle the case when the error message is of specific type; // other than the generic Match_InvalidOperand, and the; // corresponding operand is missing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/AsmParser/CSKYAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/AsmParser/CSKYAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/AsmParser/CSKYAsmParser.cpp:151,Availability,failure,failure,151,"// Attempts to match Name as a register (either using the default name or; // alternative ABI names), setting RegNo to the matching register. Upon; // failure, returns true and sets RegNo to 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/AsmParser/CSKYAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/AsmParser/CSKYAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/Disassembler/CSKYDisassembler.cpp:8,Modifiability,extend,extend,8,// Sign-extend the number in the bottom N bits of Imm,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/Disassembler/CSKYDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/Disassembler/CSKYDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/MCTargetDesc/CSKYAsmBackend.cpp:57,Availability,mask,mask,57,"// For each byte of the fragment that the fixup touches, mask in the; // bits from the fixup value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/MCTargetDesc/CSKYAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/MCTargetDesc/CSKYAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/MCTargetDesc/CSKYMCCodeEmitter.cpp:50,Integrability,interface,interface,50,"//===-- CSKYMCCodeEmitter.cpp - CSKY Code Emitter interface ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the CSKYMCCodeEmitter class.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/MCTargetDesc/CSKYMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/MCTargetDesc/CSKYMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/MCTargetDesc/CSKYMCCodeEmitter.h:50,Integrability,interface,interface,50,"//===-- CSKYMCCodeEmitter.cpp - CSKY Code Emitter interface ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the CSKYMCCodeEmitter class.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/MCTargetDesc/CSKYMCCodeEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/MCTargetDesc/CSKYMCCodeEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/MCTargetDesc/CSKYMCTargetDesc.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/CSKY/MCTargetDesc/CSKYMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/MCTargetDesc/CSKYMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/CBufferDataLayout.cpp:43,Usability,learn,learn,43,// Implement cbuffer layout in; // https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-packing-rules,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/CBufferDataLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/CBufferDataLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DirectXAsmPrinter.cpp:34,Testability,stub,stub,34,// The DXILAsmPrinter is mostly a stub because DXIL is just LLVM bitcode which; // gets embedded into a DXContainer file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/DirectXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DirectXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DirectXFrameLowering.h:476,Testability,stub,stub,476,"//===-- DirectXFrameLowering.h - Frame lowering for DirectX --*- C++ ---*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This class implements DirectX-specific bits of TargetFrameLowering class.; // This is just a stub because the current DXIL backend does not actually lower; // through the MC layer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/DirectXFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DirectXFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXContainerGlobals.cpp:7,Security,Hash,Hash,7,// The Hash's IncludesSource flag gets set whenever the hashed shader includes; // debug information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/DXContainerGlobals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXContainerGlobals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXContainerGlobals.cpp:56,Security,hash,hashed,56,// The Hash's IncludesSource flag gets set whenever the hashed shader includes; // debug information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/DXContainerGlobals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXContainerGlobals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILOpBuilder.cpp:36,Availability,error,error,36,// FIXME: find the issue and report error in clang instead of check it in; // backend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILOpBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILOpBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILOpBuilder.cpp:3,Integrability,Depend,Dependent,3,// Dependent on name to dedup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILOpBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILOpBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILResource.cpp:47,Performance,load,load,47,// FIXME: share CBufferDataLayout with CBuffer load lowering.; // See https://github.com/llvm/llvm-project/issues/58381,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILResource.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILResource.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILResource.h:180,Deployability,patch,patch,180,"// FIXME: Fully computing the resource structures requires analyzing the IR; // because some flags are set based on what operations are performed on the; // resource. This partial patch handles some of the leg work, but not all of it.; // See issue https://github.com/llvm/llvm-project/issues/57936.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILResource.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILResource.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILResource.h:136,Performance,perform,performed,136,"// FIXME: Fully computing the resource structures requires analyzing the IR; // because some flags are set based on what operations are performed on the; // resource. This partial patch handles some of the leg work, but not all of it.; // See issue https://github.com/llvm/llvm-project/issues/57936.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILResource.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILResource.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILResourceAnalysis.h:23,Security,expose,exposes,23,/// Analysis pass that exposes the \c DXILResource for a module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILResourceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILResourceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILShaderFlags.h:4,Integrability,Wrap,Wrapper,4,/// Wrapper pass for the legacy pass manager.; ///; /// This is required because the passes that will depend on this are codegen; /// passes which run through the legacy pass manager.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILShaderFlags.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILShaderFlags.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILShaderFlags.h:102,Integrability,depend,depend,102,/// Wrapper pass for the legacy pass manager.; ///; /// This is required because the passes that will depend on this are codegen; /// passes which run through the legacy pass manager.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILShaderFlags.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILShaderFlags.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DirectXIRPasses/PointerTypeAnalysis.cpp:158,Safety,safe,safe,158,"// HLSL doesn't support pointers, so it is unlikely to get more than one; // or two levels of indirection in the IR. Because of this, recursion is; // pretty safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/DirectXIRPasses/PointerTypeAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DirectXIRPasses/PointerTypeAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DirectXIRPasses/PointerTypeAnalysis.h:251,Usability,simpl,simple,251,"/// An analysis to compute the \c PointerTypes for pointers in a \c Module.; /// Since this analysis is only run during codegen and the new pass manager; /// doesn't support codegen passes, this is wrtten as a function in a namespace.; /// It is very simple to transform it into a proper analysis pass.; /// This code relies on typed pointers existing as LLVM types, but could be; /// migrated to a custom Type if PointerType loses typed support.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/DirectXIRPasses/PointerTypeAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DirectXIRPasses/PointerTypeAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp:3,Performance,Cache,Cache,3,// Cache some types,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp:46,Usability,GUID,GUIDs,46,"/// Map that holds the correspondence between GUIDs in the summary index,; /// that came from indirect call profiles, and a value id generated by this; /// class to use in the VST and summary block records.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp:45,Usability,GUID,GUIDToValueMap,45,/// Tracks the last value id recorded in the GUIDToValueMap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp:26,Energy Efficiency,allocate,allocated,26,/// Pointer to the buffer allocated by caller for bitcode writing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp:19,Usability,GUID,GUID,19,// Expect that any GUID value had a value Id assigned by an; // earlier call to assignValueId.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp:47,Modifiability,variab,variable,47,// DIAssignID is experimental feature to track variable location in IR..; // FIXME: translate DIAssignID to debug info DXIL supports.; // See https://github.com/llvm/llvm-project/issues/58989,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp:107,Modifiability,variab,variables,107,"/// Emit top-level description of module, including target triple, inline asm,; /// descriptors for global variables, and function prototype info.; /// Returns the bit offset to backpatch with the location of the real VST.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp:83,Modifiability,Variab,Variable,83,// Use getGlobalObjectValueTypeID to look up the enumerated type ID for; // Global Variable types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp:19,Modifiability,variab,variable,19,// Emit the global variable information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp:92,Performance,load,load,92,"// Emit all abbrevs upfront, so that the reader can jump in the middle of the; // block and load any metadata.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp:9,Availability,redundant,redundant,9,"// It is redundant to fully-specify this here, but nice to make it explicit; // so that it is clear the DXIL module version is different.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp:9,Safety,redund,redundant,9,"// It is redundant to fully-specify this here, but nice to make it explicit; // so that it is clear the DXIL module version is different.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp:94,Usability,clear,clear,94,"// It is redundant to fully-specify this here, but nice to make it explicit; // so that it is clear the DXIL module version is different.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp:105,Modifiability,variab,variables,105,"// Emit top-level description of module, including target triple, inline asm,; // descriptors for global variables, and function prototype info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.cpp:63,Safety,avoid,avoid,63,// Explicitly sequence get-size and insert-value operations to avoid UB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.cpp:19,Performance,cache,cache,19,"// Note: we cannot cache this lookup above, since inserting into the map; // changes the map's size, and thus affects the other IDs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.cpp:161,Safety,predict,predictValueUseListOrderImpl,161,"// In the reader, initializers of GlobalValues are set *after* all the; // globals have been read. Rather than awkwardly modeling this behaviour; // directly in predictValueUseListOrderImpl(), just assign IDs to; // initializers of GlobalValues before GlobalValues themselves to model this; // implicitly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.cpp:175,Safety,predict,predictValueUseListOrderImpl,175,"// Initializers of GlobalValues are processed in; // BitcodeReader::ResolveGlobalAndAliasInits(). Match the order there rather; // than ValueEnumerator, and match the code in predictValueUseListOrderImpl(); // by giving IDs in reverse order.; //; // Since GlobalValues never reference each other directly (just through; // initializers), their relative IDs only matter for determining order of; // uses in their initializers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.cpp:3,Safety,Predict,Predict,3,// Predict use-list order for this one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.cpp:11,Safety,predict,predicted,11,// Already predicted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.cpp:17,Safety,predict,prediction,17,// Do the actual prediction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.cpp:24,Modifiability,variab,variables,24,// Enumerate the global variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.cpp:24,Modifiability,variab,variable,24,// Enumerate the global variable initializers and attributes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.cpp:110,Modifiability,variab,variable,110,// FIXME: Pass GV to EnumerateMetadata and arrange for the bitcode writer; // to write metadata to the global variable's own metadata block; // (PR28134).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.cpp:106,Safety,detect,detect,106,// ConstantAsMetadata doesn't reference anything. We may as well shuffle it; // to the front since we can detect it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.cpp:427,Modifiability,variab,variable,427,"// If a constant has operands, enumerate them. This makes sure that if a; // constant has uses (for example an array of const ints), that they are; // inserted also.; // We prefer to enumerate them with values before we enumerate the user; // itself. This makes it more likely that we can avoid forward references; // in the reader. We know that there can be no cycles in the constants; // graph that don't go through a global variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.cpp:289,Safety,avoid,avoid,289,"// If a constant has operands, enumerate them. This makes sure that if a; // constant has uses (for example an array of const ints), that they are; // inserted also.; // We prefer to enumerate them with values before we enumerate the user; // itself. This makes it more likely that we can avoid forward references; // in the reader. We know that there can be no cycles in the constants; // graph that don't go through a global variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.cpp:118,Safety,safe,safe,118,"// If it is a non-anonymous struct, mark the type as being visited so that we; // don't recursively visit it. This is safe because we allow forward; // references of these in the bitcode reader.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.cpp:292,Availability,avail,available,292,"// Check to see if we got the pointer another way. This can happen when; // enumerating recursive types that hit the base case deeper than they start.; //; // If this is actually a struct that we are treating as forward ref'able,; // then emit the definition now that all of its contents are available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.cpp:55,Availability,avail,available,55,// Add the function's parameter attributes so they are available for use in; // the function's instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.h:66,Performance,optimiz,optimization,66,"/// Reorder the reachable metadata.; ///; /// This is not just an optimization, but is mandatory for emitting MDString; /// correctly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.h:297,Safety,avoid,avoids,297,"/// Enumerate reachable metadata in (almost) post-order.; ///; /// Enumerate all the metadata reachable from MD. We want to minimize the; /// cost of reading bitcode records, and so the primary consideration is that; /// operands of uniqued nodes are resolved before the nodes are read. This; /// avoids re-uniquing them on the context and factors away RAUW support.; ///; /// This algorithm guarantees that subgraphs of uniqued nodes are in; /// post-order. Distinct subgraphs reachable only from a single uniqued node; /// will be in post-order.; ///; /// \note The relative order of a distinct and uniqued node is irrelevant.; /// \a organizeMetadata() will later partition distinct nodes ahead of; /// uniqued ones.; ///{",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILWriterPass.cpp:3,Availability,Recover,Recover,3,// Recover triple.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILWriterPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILWriterPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILWriterPass.cpp:3,Safety,Recover,Recover,3,// Recover triple.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILWriterPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILWriterPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILWriterPass.h:64,Modifiability,variab,variable,64,/// Create and return a pass that writes the module to a global variable in the; /// module for later emission in the MCStreamer. Note that this pass is designed; /// for use with the legacy pass manager because it is run in CodeGen only.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILWriterPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILWriterPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/MCTargetDesc/DirectXMCTargetDesc.cpp:29,Testability,stub,stub,29,// DXILInstPrinter is a null stub because DXIL instructions aren't printed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/MCTargetDesc/DirectXMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/MCTargetDesc/DirectXMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/MCTargetDesc/DirectXMCTargetDesc.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/MCTargetDesc/DirectXMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/MCTargetDesc/DirectXMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/MCTargetDesc/DirectXMCTargetDesc.h:46,Integrability,Interface,Interface,46,"//===- DirectXMCTargetDesc.h - DirectX Target Interface ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains DirectX target interface.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/MCTargetDesc/DirectXMCTargetDesc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/MCTargetDesc/DirectXMCTargetDesc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/MCTargetDesc/DirectXMCTargetDesc.h:430,Integrability,interface,interface,430,"//===- DirectXMCTargetDesc.h - DirectX Target Interface ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains DirectX target interface.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/MCTargetDesc/DirectXMCTargetDesc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/MCTargetDesc/DirectXMCTargetDesc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/MCTargetDesc/DirectXMCTargetDesc.h:19,Testability,stub,stub,19,// Include DirectX stub register info,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/MCTargetDesc/DirectXMCTargetDesc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/MCTargetDesc/DirectXMCTargetDesc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/MCTargetDesc/DirectXMCTargetDesc.h:19,Testability,stub,stub,19,// Include DirectX stub instruction info,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/DirectX/MCTargetDesc/DirectXMCTargetDesc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/MCTargetDesc/DirectXMCTargetDesc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp:688,Usability,clear,clear,688,"//===- BitTracker.cpp -----------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // SSA-based bit propagation.; //; // The purpose of this code is, for a given virtual register, to provide; // information about the value of each bit in the register. The values; // of bits are represented by the class BitValue, and take one of four; // cases: 0, 1, ""ref"" and ""bottom"". The 0 and 1 are rather clear, the; // ""ref"" value means that the bit is a copy of another bit (which itself; // cannot be a copy of yet another bit---such chains are not allowed).; // A ""ref"" value is associated with a BitRef structure, which indicates; // which virtual register, and which bit in that register is the origin; // of the value. For example, given an instruction; // %2 = ASL %1, 1; // assuming that nothing is known about bits of %1, bit 1 of %2; // will be a ""ref"" to (%1, 0). If there is a subsequent instruction; // %3 = ASL %2, 2; // then bit 3 of %3 will be a ""ref"" to (%1, 0) as well.; // The ""bottom"" case means that the bit's value cannot be determined,; // and that this virtual register actually defines it. The ""bottom"" case; // is discussed in detail in BitTracker.h. In fact, ""bottom"" is a ""ref; // to self"", so for the %1 above, the bit 0 of it will be a ""ref"" to; // (%1, 0), bit 1 will be a ""ref"" to (%1, 1), etc.; //; // The tracker implements the Wegman-Zadeck algorithm, originally developed; // for SSA-based constant propagation. Each register is represented as; // a sequence of bits, with the convention that bit 0 is the least signi-; // ficant bit. Each bit is propagated individually. The class RegisterCell; // implements the register's representation, and is also the subject of; // the latti",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp:79,Testability,log,logical,79,"// Instead of printing each bit value individually, try to group them; // into logical segments, such as sequences of 0 or 1 bits or references; // to consecutive bits (e.g. ""bits 3-5 are same as bits 7-9 of reg xyz"").; // ""Start"" will be the index of the beginning of the most recent segment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp:25,Deployability,update,update,25,"// If we were allowed to update a cell for a part of a register, the meet; // operation would need to be parametrized by the register number and the; // exact part of the register, so that the computer BitRefs correspond to; // the actual bits of the ""self"" register.; // While this cannot happen in the current implementation, I'm not sure; // if this should be ruled out in the future.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp:21,Availability,mask,mask,21,// M must be a valid mask for *this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp:7,Availability,mask,masked,7,// The masked part of *this must have the same number of bits; // as the source.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp:8,Modifiability,extend,extend,8,"// Sign-extend ""inreg"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp:48,Performance,queue,queue,48,"// This is a comparison function for a priority queue: give higher priority; // to earlier instructions.; // This operator is used as ""less"", so returning ""true"" gives InstB higher; // priority (because then InstA < InstB).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp:56,Deployability,update,update,56,"// Iterate over all definitions of the instruction, and update the; // cells accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp:48,Deployability,update,updated,48,"// Bits that are already ""bottom"" should not be updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp:117,Performance,optimiz,optimization,117,"// Visit an individual instruction. This could be a newly added instruction,; // or one that has been modified by an optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp:42,Deployability,update,updates,42,// Make sure to flush all the pending use updates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp:152,Performance,queue,queue,152,"// The call to visitNonBranch could propagate the changes until a branch; // is actually visited. This could result in adding CFG edges to the flow; // queue. Since the queue won't be processed, clear it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp:169,Performance,queue,queue,169,"// The call to visitNonBranch could propagate the changes until a branch; // is actually visited. This could result in adding CFG edges to the flow; // queue. Since the queue won't be processed, clear it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp:195,Usability,clear,clear,195,"// The call to visitNonBranch could propagate the changes until a branch; // is actually visited. This could result in adding CFG edges to the flow; // queue. Since the queue won't be processed, clear it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp:128,Deployability,update,updates,128,"// If this block has already been visited through a flow graph edge,; // then the instructions have already been processed. Any updates to; // the cells would now only happen through visitUsesOf...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp:67,Performance,queue,queue,67,"// If block end has been reached, add the fall-through edge to the queue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp:65,Deployability,update,update,65,// Handle the remaining sequence of branches. This function will update; // the work queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp:85,Performance,queue,queue,85,// Handle the remaining sequence of branches. This function will update; // the work queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h:12,Performance,queue,queue,12,"// Priority queue of instructions using modified registers, ordered by; // their relative position in a basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h:10,Safety,avoid,avoid,10,// Set to avoid adding duplicate entries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h:8,Performance,queue,queue,8,// Work queue of register uses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h:8,Performance,queue,queue,8,// Work queue of CFG edges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h:3,Performance,Cache,Cache,3,// Cache of reached blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h:534,Usability,simpl,simple,534,"// Bit value same as the one described in RefI.; // Conceptually, there is no explicit ""bottom"" value: the lattice's; // bottom will be expressed as a ""ref to itself"", which, in the context; // of registers, could be read as ""this value of this bit is defined by; // this bit"".; // The ordering is:; // x <= Top,; // Self <= x, where ""Self"" is ""ref to itself"".; // This makes the value lattice different for each virtual register; // (even for each bit in the same virtual register), since the ""bottom""; // for one register will be a simple ""ref"" for another register.; // Since we do not store the ""Self"" bit and register number, the meet; // operation will need to take it as a parameter.; //; // In practice there is a special case for values that are not associa-; // ted with any specific virtual register. An example would be a value; // corresponding to a bit of a physical register, or an intermediate; // value obtained in some computation (such as instruction evaluation).; // Such cases are identical to the usual Ref type, but the register; // number is 0. In such case the Pos field of the reference is ignored.; //; // What is worthy of notice is that in value V (that is a ""ref""), as long; // as the RefI.Reg is not 0, it may actually be the same register as the; // one in which V will be contained. If the RefI.Pos refers to the posi-; // tion of V, then V is assumed to be ""bottom"" (as a ""ref to itself""),; // otherwise V is taken to be identical to the referenced bit of the; // same register.; // If RefI.Reg is 0, however, such a reference to the same register is; // not possible. Any value V that is a ""ref"", and whose RefI.Reg is 0; // is treated as ""bottom"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h:239,Deployability,update,update,239,"// The ""meet"" operation is the ""."" operation in a semilattice (L, ., T, B):; // (1) x.x = x; // (2) x.y = y.x; // (3) x.(y.z) = (x.y).z; // (4) x.T = x (i.e. T = ""top""); // (5) x.B = B (i.e. B = ""bottom""); //; // This ""meet"" function will update the value of the ""*this"" object with; // the newly calculated one, and return ""true"" if the value of *this has; // changed, and ""false"" otherwise.; // To prove that it satisfies the conditions (1)-(5), it is sufficient; // to show that a relation; // x <= y <=> x.y = x; // defines a partial order (i.e. that ""meet"" is same as ""infimum"").",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h:91,Availability,mask,mask,91,"// A sequence of bits starting from index B up to and including index E.; // If E < B, the mask represents two sections: [0..E] and [B..W) where; // W is the width of the register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h:35,Safety,avoid,avoid,35,// The DefaultBitN is here only to avoid frequent reallocation of the; // memory in the vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h:49,Deployability,update,update,49,// A class to evaluate target's instructions and update the cell maps.; // This is used internally by the bit tracker. A target that wants to; // utilize this should implement the evaluation functions (noted below); // in a subclass of this class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h:125,Integrability,wrap,wrapper,125,"// A result of any operation should use refs to the source cells, not; // the cells directly. This function is a convenience wrapper to quickly; // generate a ref for a cell corresponding to a register reference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h:3,Testability,Log,Logical,3,// Logical.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h:12,Usability,clear,clear,12,"// Set bit, clear bit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h:77,Availability,mask,mask,77,"// User-provided functions for individual targets:; // Return a sub-register mask that indicates which bits in Reg belong; // to the subregister Sub. These bits are assumed to be contiguous in; // the super-register, and have the same ordering in the sub-register; // as in the super-register. It is valid to call this function with; // Sub == 0, in this case, the function should return a mask that spans; // the entire register Reg (which is what the default implementation; // does).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h:390,Availability,mask,mask,390,"// User-provided functions for individual targets:; // Return a sub-register mask that indicates which bits in Reg belong; // to the subregister Sub. These bits are assumed to be contiguous in; // the super-register, and have the same ordering in the sub-register; // as in the super-register. It is valid to call this function with; // Sub == 0, in this case, the function should return a mask that spans; // the entire register Reg (which is what the default implementation; // does).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/Hexagon.h:28,Integrability,interface,interface,28,"//=-- Hexagon.h - Top-level interface for Hexagon representation --*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the entry points for global functions defined in the LLVM; // Hexagon back-end.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/Hexagon.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/Hexagon.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonAsmPrinter.cpp:474,Integrability,depend,dependent,474,"//===- HexagonAsmPrinter.cpp - Print machine instrs to Hexagon assembly ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a printer that converts from our internal representation; // of machine-dependent LLVM code to Hexagon assembly language. This printer is; // the output mechanism used by `llc'.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonAsmPrinter.cpp:21,Testability,assert,assert,21,// This should be an assert in the frontend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonAsmPrinter.cpp:10,Energy Efficiency,reduce,reduce,10,"// Vector reduce complex multiply by scalar, Rt & 1 map to :hi else :lo; // The insn is mapped from the 4 operand to the 3 operand raw form taking; // 3 register pairs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonAsmPrinter.cpp:217,Deployability,patch,patching,217,"// We want to emit the following pattern:; //; // .L_xray_sled_N:; // <xray_sled_base>:; // { 	jump .Ltmp0 }; // { nop; // nop; // nop; // nop }; // .Ltmp0:; //; // We need the 4 nop words because at runtime, we'd be patching over the; // full 5 words with the following pattern:; //; // <xray_sled_n>:; // { 	immext(#...) // upper 26-bits of trampoline; // r6 = ##... // lower 6-bits of trampoline; // immext(#...) // upper 26-bits of func id; // r7 = ##... } // lower 6 bits of func id; // { 	callr r6 }; //; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:5,Testability,test,test,5,// A.test(B) <=> A-B != {},MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:94,Availability,down,down,94,"// The purpose of this class is to provide a common facility to traverse; // the function top-down or bottom-up via the dominator tree, and keep; // track of the available registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:162,Availability,avail,available,162,"// The purpose of this class is to provide a common facility to traverse; // the function top-down or bottom-up via the dominator tree, and keep; // track of the available registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:186,Integrability,depend,depend,186,"// For an instruction with opcode Opc, calculate the set of bits that it; // uses in a register in operand OpN. This only calculates the set of used; // bits for cases where it does not depend on any operands (as is the case; // in shifts, for example). For concrete instructions from a program, the; // operand may be a subregister of a larger register, while Bits would; // correspond to the larger register in its entirety. Because of that,; // the parameter Begin can be used to indicate which bit of Bits should be; // considered the LSB of the operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:13,Availability,redundant,redundant,13,"// Eliminate redundant instructions; //; // This transformation will identify instructions where the output register; // is the same as one of its input registers. This only works on instructions; // that define a single register (unlike post-increment loads, for example).; // The equality check is actually more detailed: the code calculates which; // bits of the output are used, and only compares these bits with the input; // registers.; // If the output matches an input, the instruction is replaced with COPY.; // The copies will be removed by another transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:253,Performance,load,loads,253,"// Eliminate redundant instructions; //; // This transformation will identify instructions where the output register; // is the same as one of its input registers. This only works on instructions; // that define a single register (unlike post-increment loads, for example).; // The equality check is actually more detailed: the code calculates which; // bits of the output are used, and only compares these bits with the input; // registers.; // If the output matches an input, the instruction is replaced with COPY.; // The copies will be removed by another transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:13,Safety,redund,redundant,13,"// Eliminate redundant instructions; //; // This transformation will identify instructions where the output register; // is the same as one of its input registers. This only works on instructions; // that define a single register (unlike post-increment loads, for example).; // The equality check is actually more detailed: the code calculates which; // bits of the output are used, and only compares these bits with the input; // registers.; // If the output matches an input, the instruction is replaced with COPY.; // The copies will be removed by another transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:145,Integrability,depend,dependent,145,"// This pass can create copies between registers that don't have the; // exact same values. Updating the tracker has to involve updating; // all dependent cells. Example:; // %1 = inst %2 ; %1 != %2, but used bits are equal; //; // %3 = copy %2 ; <- inserted; // ... = %3 ; <- replaced from %2; // Indirectly, we can create a ""copy"" between %1 and %2 even; // though their exact values do not match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:126,Performance,load,load,126,// Recognize instructions that produce constant values known at compile-time.; // Replace them with register definitions that load these constants directly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:21,Availability,avail,available,21,"// Identify pairs of available registers which hold identical values.; // In such cases, only one of them needs to be calculated, the other one; // will be defined as a copy of the first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:34,Usability,simpl,simplified,34,// Recognize patterns that can be simplified and replace them with the; // simpler forms.; // This is by no means complete,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:75,Usability,simpl,simpler,75,// Recognize patterns that can be simplified and replace them with the; // simpler forms.; // This is by no means complete,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:3,Performance,Cache,Cache,3,// Cache of created instructions to avoid creating duplicates.; // XXX Currently only used by genBitSplit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:36,Safety,avoid,avoid,36,// Cache of created instructions to avoid creating duplicates.; // XXX Currently only used by genBitSplit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:45,Availability,avail,available,45,"// XXX This could be searching in the set of available registers, in case; // the match is not exact.; // Match 16-bit chunks, where the RC[B..B+15] references exactly one; // register and all the bits B..B+15 match between RC and the register.; // This is meant to match ""v1[0-15]"", where v1 = { [0]:0 [1-15]:v1... },; // and RC = { [0]:0 [1-15]:v1[1-15]... }.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:110,Modifiability,extend,extenders,110,"// If MI stores a value known at compile-time, and the value is within a range; // that avoids using constant-extenders, replace it with a store-immediate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:88,Safety,avoid,avoids,88,"// If MI stores a value known at compile-time, and the value is within a range; // that avoids using constant-extenders, replace it with a store-immediate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:3,Safety,Avoid,Avoid,3,// Avoid stores to frame-indices (due to an unknown offset).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:48,Modifiability,extend,extenders,48,// Only consider 8-bit values to avoid constant-extenders.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:33,Safety,avoid,avoid,33,// Only consider 8-bit values to avoid constant-extenders.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:96,Modifiability,extend,extend,96,"// If MI produces halfword of the input in the low half of the output,; // replace it with zero-extend or extractu.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:91,Modifiability,extend,extend,91,"// If MI resets high bits of a register and keeps the lower ones, replace it; // with zero-extend byte/half, and-immediate, or extractu, as appropriate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:5,Usability,simpl,simplistic,5,"// A simplistic analysis: assume the source register (the one being split); // is fully unknown, and that all its bits are self-references.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:35,Availability,avail,available,35,// Check if the target register is available here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:20,Usability,simpl,simplification,20,"// Check for tstbit simplification opportunity, where the bit being checked; // can be tracked back to another register. For example:; // %2 = S2_lsr_i_r %1, 5; // %3 = S2_tstbit_i %2, 0; // =>; // %3 = S2_tstbit_i %1, 5",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:58,Modifiability,extend,extended,58,"// Detect whether RD is a bitfield extract (sign- or zero-extended) of; // some register from the AVs set. Create a new corresponding instruction; // at the location of MI. The intent is to recognize situations where; // a sequence of instructions performs an operation that is equivalent to; // an extract operation, such as a shift left followed by a shift right.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:248,Performance,perform,performs,248,"// Detect whether RD is a bitfield extract (sign- or zero-extended) of; // some register from the AVs set. Create a new corresponding instruction; // at the location of MI. The intent is to recognize situations where; // a sequence of instructions performs an operation that is equivalent to; // an extract operation, such as a shift left followed by a shift right.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:3,Safety,Detect,Detect,3,"// Detect whether RD is a bitfield extract (sign- or zero-extended) of; // some register from the AVs set. Create a new corresponding instruction; // at the location of MI. The intent is to recognize situations where; // a sequence of instructions performs an operation that is equivalent to; // an extract operation, such as a shift left followed by a shift right.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:282,Modifiability,extend,extended,282,"// Observation:; // If the cell has a form of 00..0xx..x with k zeros and n remaining; // bits, this could be an extractu of the n bits, but it could also be; // an extractu of a longer field which happens to have 0s in the top; // bit positions.; // The same logic applies to sign-extended fields.; //; // Do not check for the extended extracts, since it would expand the; // search space quite a bit. The search may be expensive as it is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:328,Modifiability,extend,extended,328,"// Observation:; // If the cell has a form of 00..0xx..x with k zeros and n remaining; // bits, this could be an extractu of the n bits, but it could also be; // an extractu of a longer field which happens to have 0s in the top; // bit positions.; // The same logic applies to sign-extended fields.; //; // Do not check for the extended extracts, since it would expand the; // search space quite a bit. The search may be expensive as it is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:260,Testability,log,logic,260,"// Observation:; // If the cell has a form of 00..0xx..x with k zeros and n remaining; // bits, this could be an extractu of the n bits, but it could also be; // an extractu of a longer field which happens to have 0s in the top; // bit positions.; // The same logic applies to sign-extended fields.; //; // Do not check for the extended extracts, since it would expand the; // search space quite a bit. The search may be expensive as it is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:50,Modifiability,extend,extended,50,// The sign bit must be a part of the field being extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:30,Modifiability,extend,extended,30,// This could still be a sign-extended extract.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:176,Security,access,accessed,176,"// The assumption here is that if the source (R) is longer than the; // destination, then the destination is a sequence of words of; // size RW, and each such word in R can be accessed via a subregister.; //; // If the beginning and the end of the field cross the subregister; // boundary, advance to the next subregister.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:56,Performance,optimiz,optimized,56,// Don't generate the same instruction as the one being optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:91,Performance,load,load,91,"// If the source register is known to be 0 or non-0, the comparison can; // be folded to a load of a constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:3,Availability,Avail,Available,3,// Available registers for IG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:3,Availability,Avail,Available,3,// Available registers for RIE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:3,Availability,Avail,Available,3,// Available registers for CG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:3,Availability,Avail,Available,3,// Available registers for CP.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:3,Availability,Avail,Available,3,// Available registers for BS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:331,Testability,test,testcase,331,"// Recognize loops where the code at the end of the loop matches the code; // before the entry of the loop, and the matching code is such that is can; // be simplified. This pass relies on the bit simplification above and only; // prepares code in a way that can be handled by the bit simplifcation.; //; // This is the motivating testcase (and explanation):; //; // {; // loop0(.LBB0_2, r1) // %for.body.preheader; // r5:4 = memd(r0++#8); // }; // {; // r3 = lsr(r4, #16); // r7:6 = combine(r5, r5); // }; // {; // r3 = insert(r5, #16, #16); // r7:6 = vlsrw(r7:6, #16); // }; // .LBB0_2:; // {; // memh(r2+#4) = r5; // memh(r2+#6) = r6 # R6 is really R5.H; // }; // {; // r2 = add(r2, #8); // memh(r2+#0) = r4; // memh(r2+#2) = r3 # R3 is really R4.H; // }; // {; // r5:4 = memd(r0++#8); // }; // { # ""Shuffling"" code that sets up R3 and R6; // r3 = lsr(r4, #16) # so that their halves can be stored in the; // r7:6 = combine(r5, r5) # next iteration. This could be folded into; // } # the stores if the code was at the beginning; // { # of the loop iteration. Since the same code; // r3 = insert(r5, #16, #16) # precedes the loop, it can actually be moved; // r7:6 = vlsrw(r7:6, #16) # there.; // }:endloop0; //; //; // The outcome:; //; // {; // loop0(.LBB0_2, r1); // r5:4 = memd(r0++#8); // }; // .LBB0_2:; // {; // memh(r2+#4) = r5; // memh(r2+#6) = r5.h; // }; // {; // r2 = add(r2, #8); // memh(r2+#0) = r4; // memh(r2+#2) = r4.h; // }; // {; // r5:4 = memd(r0++#8); // }:endloop0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:157,Usability,simpl,simplified,157,"// Recognize loops where the code at the end of the loop matches the code; // before the entry of the loop, and the matching code is such that is can; // be simplified. This pass relies on the bit simplification above and only; // prepares code in a way that can be handled by the bit simplifcation.; //; // This is the motivating testcase (and explanation):; //; // {; // loop0(.LBB0_2, r1) // %for.body.preheader; // r5:4 = memd(r0++#8); // }; // {; // r3 = lsr(r4, #16); // r7:6 = combine(r5, r5); // }; // {; // r3 = insert(r5, #16, #16); // r7:6 = vlsrw(r7:6, #16); // }; // .LBB0_2:; // {; // memh(r2+#4) = r5; // memh(r2+#6) = r6 # R6 is really R5.H; // }; // {; // r2 = add(r2, #8); // memh(r2+#0) = r4; // memh(r2+#2) = r3 # R3 is really R4.H; // }; // {; // r5:4 = memd(r0++#8); // }; // { # ""Shuffling"" code that sets up R3 and R6; // r3 = lsr(r4, #16) # so that their halves can be stored in the; // r7:6 = combine(r5, r5) # next iteration. This could be folded into; // } # the stores if the code was at the beginning; // { # of the loop iteration. Since the same code; // r3 = insert(r5, #16, #16) # precedes the loop, it can actually be moved; // r7:6 = vlsrw(r7:6, #16) # there.; // }:endloop0; //; //; // The outcome:; //; // {; // loop0(.LBB0_2, r1); // r5:4 = memd(r0++#8); // }; // .LBB0_2:; // {; // memh(r2+#4) = r5; // memh(r2+#6) = r5.h; // }; // {; // r2 = add(r2, #8); // memh(r2+#0) = r4; // memh(r2+#2) = r4.h; // }; // {; // r5:4 = memd(r0++#8); // }:endloop0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:197,Usability,simpl,simplification,197,"// Recognize loops where the code at the end of the loop matches the code; // before the entry of the loop, and the matching code is such that is can; // be simplified. This pass relies on the bit simplification above and only; // prepares code in a way that can be handled by the bit simplifcation.; //; // This is the motivating testcase (and explanation):; //; // {; // loop0(.LBB0_2, r1) // %for.body.preheader; // r5:4 = memd(r0++#8); // }; // {; // r3 = lsr(r4, #16); // r7:6 = combine(r5, r5); // }; // {; // r3 = insert(r5, #16, #16); // r7:6 = vlsrw(r7:6, #16); // }; // .LBB0_2:; // {; // memh(r2+#4) = r5; // memh(r2+#6) = r6 # R6 is really R5.H; // }; // {; // r2 = add(r2, #8); // memh(r2+#0) = r4; // memh(r2+#2) = r3 # R3 is really R4.H; // }; // {; // r5:4 = memd(r0++#8); // }; // { # ""Shuffling"" code that sets up R3 and R6; // r3 = lsr(r4, #16) # so that their halves can be stored in the; // r7:6 = combine(r5, r5) # next iteration. This could be folded into; // } # the stores if the code was at the beginning; // { # of the loop iteration. Since the same code; // r3 = insert(r5, #16, #16) # precedes the loop, it can actually be moved; // r7:6 = vlsrw(r7:6, #16) # there.; // }:endloop0; //; //; // The outcome:; //; // {; // loop0(.LBB0_2, r1); // r5:4 = memd(r0++#8); // }; // .LBB0_2:; // {; // memh(r2+#4) = r5; // memh(r2+#6) = r5.h; // }; // {; // r2 = add(r2, #8); // memh(r2+#0) = r4; // memh(r2+#2) = r4.h; // }; // {; // r5:4 = memd(r0++#8); // }:endloop0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:285,Usability,simpl,simplifcation,285,"// Recognize loops where the code at the end of the loop matches the code; // before the entry of the loop, and the matching code is such that is can; // be simplified. This pass relies on the bit simplification above and only; // prepares code in a way that can be handled by the bit simplifcation.; //; // This is the motivating testcase (and explanation):; //; // {; // loop0(.LBB0_2, r1) // %for.body.preheader; // r5:4 = memd(r0++#8); // }; // {; // r3 = lsr(r4, #16); // r7:6 = combine(r5, r5); // }; // {; // r3 = insert(r5, #16, #16); // r7:6 = vlsrw(r7:6, #16); // }; // .LBB0_2:; // {; // memh(r2+#4) = r5; // memh(r2+#6) = r6 # R6 is really R5.H; // }; // {; // r2 = add(r2, #8); // memh(r2+#0) = r4; // memh(r2+#2) = r3 # R3 is really R4.H; // }; // {; // r5:4 = memd(r0++#8); // }; // { # ""Shuffling"" code that sets up R3 and R6; // r3 = lsr(r4, #16) # so that their halves can be stored in the; // r7:6 = combine(r5, r5) # next iteration. This could be folded into; // } # the stores if the code was at the beginning; // { # of the loop iteration. Since the same code; // r3 = insert(r5, #16, #16) # precedes the loop, it can actually be moved; // r7:6 = vlsrw(r7:6, #16) # there.; // }:endloop0; //; //; // The outcome:; //; // {; // loop0(.LBB0_2, r1); // r5:4 = memd(r0++#8); // }; // .LBB0_2:; // {; // memh(r2+#4) = r5; // memh(r2+#6) = r5.h; // }; // {; // r2 = add(r2, #8); // memh(r2+#0) = r4; // memh(r2+#2) = r4.h; // }; // {; // r5:4 = memd(r0++#8); // }:endloop0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:153,Integrability,depend,dependent,153,"// Partition the list of shuffling instructions into instruction groups,; // where each group has to be moved as a whole (i.e. a group is a chain of; // dependent instructions). A group produces a single live output register,; // which is meant to be the input of the loop phi node (although this is; // not checked here yet). It also uses a single register as its input,; // which is some value produced in the loop body. After moving the group; // to the beginning of the loop, that input register would need to be; // the loop-carried register (through a phi node) instead of the (currently; // loop-carried) output register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp:466,Energy Efficiency,meter,meter,466,"// Populate the VRX map (VR to extension-type).; // Go over all the formal parameters of the function. If a given parameter; // P is sign- or zero-extended, locate the virtual register holding that; // parameter and create an entry in the VRX map indicating the type of ex-; // tension (and the source type).; // This is a bit complicated to do accurately, since the memory layout in-; // formation is necessary to precisely determine whether an aggregate para-; // meter will be passed in a register or in memory. What is given in MRI; // is the association between the physical register that is live-in (i.e.; // holds an argument), and the virtual register that this value will be; // copied into. This, by itself, is not sufficient to map back the virtual; // register to a formal parameter from Function (since consecutive live-ins; // from MRI may not correspond to consecutive formal parameters from Func-; // tion). To avoid the complications with in-memory arguments, only consi-; // der the initial sequence of formal parameters that are known to be; // passed via registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp:147,Modifiability,extend,extended,147,"// Populate the VRX map (VR to extension-type).; // Go over all the formal parameters of the function. If a given parameter; // P is sign- or zero-extended, locate the virtual register holding that; // parameter and create an entry in the VRX map indicating the type of ex-; // tension (and the source type).; // This is a bit complicated to do accurately, since the memory layout in-; // formation is necessary to precisely determine whether an aggregate para-; // meter will be passed in a register or in memory. What is given in MRI; // is the association between the physical register that is live-in (i.e.; // holds an argument), and the virtual register that this value will be; // copied into. This, by itself, is not sufficient to map back the virtual; // register to a formal parameter from Function (since consecutive live-ins; // from MRI may not correspond to consecutive formal parameters from Func-; // tion). To avoid the complications with in-memory arguments, only consi-; // der the initial sequence of formal parameters that are known to be; // passed via registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp:927,Safety,avoid,avoid,927,"// Populate the VRX map (VR to extension-type).; // Go over all the formal parameters of the function. If a given parameter; // P is sign- or zero-extended, locate the virtual register holding that; // parameter and create an entry in the VRX map indicating the type of ex-; // tension (and the source type).; // This is a bit complicated to do accurately, since the memory layout in-; // formation is necessary to precisely determine whether an aggregate para-; // meter will be passed in a register or in memory. What is given in MRI; // is the association between the physical register that is live-in (i.e.; // holds an argument), and the virtual register that this value will be; // copied into. This, by itself, is not sufficient to map back the virtual; // register to a formal parameter from Function (since consecutive live-ins; // from MRI may not correspond to consecutive formal parameters from Func-; // tion). To avoid the complications with in-memory arguments, only consi-; // der the initial sequence of formal parameters that are known to be; // passed via registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp:43,Testability,assert,assert,43,// The main purpose of this operator is to assert with bad argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp:120,Modifiability,extend,extended,120,"// Check COPY instructions that copy formal parameters into virtual; // registers. Such parameters can be sign- or zero-extended at the; // call site, and we should take advantage of this knowledge. The MRI; // keeps a list of pairs of live-in physical and virtual registers,; // which provides information about which virtual registers will hold; // the argument values. The function will still contain instructions; // defining those virtual registers, and in practice those are COPY; // instructions from a physical to a virtual register. In such cases,; // applying the argument extension to the virtual register can be seen; // as simply mirroring the extension that had already been applied to; // the physical register at the call site. If the defining instruction; // was not a COPY, it would not be clear how to mirror that extension; // on the callee's side. For that reason, only check COPY instructions; // for potential extensions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp:636,Usability,simpl,simply,636,"// Check COPY instructions that copy formal parameters into virtual; // registers. Such parameters can be sign- or zero-extended at the; // call site, and we should take advantage of this knowledge. The MRI; // keeps a list of pairs of live-in physical and virtual registers,; // which provides information about which virtual registers will hold; // the argument values. The function will still contain instructions; // defining those virtual registers, and in practice those are COPY; // instructions from a physical to a virtual register. In such cases,; // applying the argument extension to the virtual register can be seen; // as simply mirroring the extension that had already been applied to; // the physical register at the call site. If the defining instruction; // was not a COPY, it would not be clear how to mirror that extension; // on the callee's side. For that reason, only check COPY instructions; // for potential extensions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp:808,Usability,clear,clear,808,"// Check COPY instructions that copy formal parameters into virtual; // registers. Such parameters can be sign- or zero-extended at the; // call site, and we should take advantage of this knowledge. The MRI; // keeps a list of pairs of live-in physical and virtual registers,; // which provides information about which virtual registers will hold; // the argument values. The function will still contain instructions; // defining those virtual registers, and in practice those are COPY; // instructions from a physical to a virtual register. In such cases,; // applying the argument extension to the virtual register can be seen; // as simply mirroring the extension that had already been applied to; // the physical register at the call site. If the defining instruction; // was not a COPY, it would not be clear how to mirror that extension; // on the callee's side. For that reason, only check COPY instructions; // for potential extensions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp:206,Safety,avoid,avoid,206,"// Beyond this point, if any operand is a global, skip that instruction.; // The reason is that certain instructions that can take an immediate; // operand can also have a global symbol in that operand. To avoid; // checking what kind of operand a given instruction has individually; // for each instruction, do it here. Global symbols as operands gene-; // rally do not provide any useful information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp:24,Testability,Log,Logical,24,//case M2_mpysu_up:; // Logical/bitwise:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp:27,Modifiability,extend,extended,27,"// The input is first sign-extended to 64 bits, then the output; // is truncated back to 32 bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp:16,Modifiability,extend,extends,16,"// If the width extends beyond the register size, pad the register; // with 0 bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp:25,Modifiability,extend,extend,25,"// Ext is short, need to extend it with 0s or sign bit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp:34,Testability,test,test,34,"// If instruction is S2_tstbit_i, test for 1, otherwise test for 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp:56,Testability,test,test,56,"// If instruction is S2_tstbit_i, test for 1, otherwise test for 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp:3,Usability,Simpl,Simple,3,"// Simple branch: if([!]Pn) jump ...; // i.e. Op0 = predicate, Op1 = branch target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp:4,Testability,Test,Test,4,"// ""Test.is(!Negated)"" means ""branch condition is true"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp:56,Performance,load,loads,56,"// If MI defines a formal parameter, but is not a copy (loads are handled; // in evaluateLoad), then it's not clear what to do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp:110,Usability,clear,clear,110,"// If MI defines a formal parameter, but is not a copy (loads are handled; // in evaluateLoad), then it's not clear what to do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp:111,Modifiability,extend,extends,111,"// Store RD's cell into the map. This will associate the cell with a virtual; // register, and make zero-/sign-extends possible (otherwise we would be ex-; // tending ""self"" bit values, which will have no effect, since ""self"" values; // cannot be references to anything).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBlockRanges.cpp:57,Usability,simpl,simpler,57,// Exclusion of non-overlapping ranges makes some checks simpler; // later in this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBlockRanges.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBlockRanges.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBlockRanges.cpp:26,Modifiability,extend,extends,26,"// Add the part of A that extends on the ""less"" side of B.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBlockRanges.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBlockRanges.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBlockRanges.cpp:3,Deployability,Update,Update,3,// Update maps for defs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBlockRanges.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBlockRanges.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBlockRanges.cpp:3,Deployability,Update,Update,3,// Update maps for clobbers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBlockRanges.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBlockRanges.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBranchRelaxation.cpp:63,Safety,safe,safety,63,"// Since we have no exact knowledge of code layout, allow some safety buffer; // for jump target. This is measured in bytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBranchRelaxation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBranchRelaxation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBranchRelaxation.cpp:19,Modifiability,extend,extendable,19,// Assume that all extendable branches will be extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBranchRelaxation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBranchRelaxation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBranchRelaxation.cpp:47,Modifiability,extend,extended,47,// Assume that all extendable branches will be extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBranchRelaxation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBranchRelaxation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBranchRelaxation.cpp:164,Modifiability,extend,extenders,164,"/// relaxBranches - For Hexagon, if the jump target/loop label is too far from; /// the jump/loop instruction then, we need to make sure that we have constant; /// extenders set for jumps and loops.; /// There are six iterations in this phase. It's self explanatory below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBranchRelaxation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBranchRelaxation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBranchRelaxation.cpp:25,Modifiability,extend,extended,25,// Mark given operand as extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBranchRelaxation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBranchRelaxation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCFGOptimizer.cpp:37,Performance,optimiz,optimizations,37,"//===- HexagonCFGOptimizer.cpp - CFG optimizations ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCFGOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCFGOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCFGOptimizer.cpp:13,Performance,perform,performs,13,"// This code performs the conversion for case 2, which moves; // the block to the fall-thru case (BB3 in the code above).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCFGOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCFGOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCFGOptimizer.cpp:51,Energy Efficiency,schedul,scheduler,51,// Correct live-in information. Is used by post-RA scheduler; // The live-in to LayoutSucc is now all values live-in to; // JumpAroundTarget.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCFGOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCFGOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp:359,Usability,simpl,simply,359,"// Note: GEP indices generally traverse nested types, and so a GepNode; // (representing a single index) can be associated with some composite; // type. The exception is the GEP input, which is a pointer, and not; // a composite type (at least not in the sense of having sub-types).; // Also, the corresponding index plays a different role as well: it is; // simply added to the input pointer. Since pointer types are becoming; // opaque (i.e. are no longer going to include the pointee type), the; // two pieces of information (1) the fact that it's a pointer, and; // (2) the pointee type, need to be stored separately. The pointee type; // will be stored in the PTy member, while the fact that the node; // operates on a pointer will be reflected by the flag ""Pointer"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp:37,Deployability,update,update,37,"// After last node has been created, update the use information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp:9,Performance,cache,cache,9,// Don't cache the result for nodes with different hashes. The hash; // comparison is fast enough.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp:51,Security,hash,hashes,51,// Don't cache the result for nodes with different hashes. The hash; // comparison is fast enough.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp:63,Security,hash,hash,63,// Don't cache the result for nodes with different hashes. The hash; // comparison is fast enough.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp:63,Performance,cache,caches,63,"// Compute the equivalence relation for the gep nodes. Use two caches,; // one for equality and the other for non-equality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp:3,Performance,Cache,Caches,3,// Caches.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp:3,Deployability,Update,Update,3,"// Update the min element's flags, and user list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp:217,Availability,avail,available,217,"// Recalculate the placement for Node, assuming that the locations of; // its children in Loc are valid.; // Return nullptr if there is no valid placement for Node (for example, it; // uses an index value that is not available at the location required; // to dominate all children, etc.).; // Find the nearest common dominator for:; // - all users, if the node is used, and; // - all children.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp:197,Availability,avail,available,197,"// If the child is only used in GEP instructions (i.e. is not used in; // non-GEP instructions), the nearest dominator computed for it may; // have been null. In such case it won't have a location available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp:3,Safety,Avoid,Avoid,3,// Avoid putting nodes into empty blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp:28,Deployability,Update,Update,28,"// Otherwise, DomB is fine. Update the location map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp:54,Performance,load,loads,54,"// Collect all used nodes together with the uses from loads and stores,; // where the GEP node could be folded into the load/store instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp:120,Performance,load,load,120,"// Collect all used nodes together with the uses from loads and stores,; // where the GEP node could be folded into the load/store instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp:3,Performance,Load,Loads,3,// Loads/stores that use the node N.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:13,Modifiability,extend,extend,13,"// If D < 0, extend Min, otherwise extend Max.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:35,Modifiability,extend,extend,35,"// If D < 0, extend Min, otherwise extend Max.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:32,Modifiability,extend,extender,32,"// A subexpression in which the extender is used. In general, this; // represents an expression where adding D to the extender will be; // equivalent to adding D to the expression as a whole. In other; // words, expr(add(##V,D) = add(expr(##V),D).; // The original motivation for this are the io/ur addressing modes,; // where the offset is extended. Consider the io example:; // In memw(Rs+##V), the ##V could be replaced by a register Rt to; // form the rr mode: memw(Rt+Rs<<0). In such case, however, the; // register Rt must have exactly the value of ##V. If there was; // another instruction memw(Rs+##V+4), it would need a different Rt.; // Now, if Rt was initialized as ""##V+Rs<<0"", both of these; // instructions could use the same Rt, just with different offsets.; // Here it's clear that ""initializer+4"" should be the same as if; // the offset 4 was added to the ##V in the initializer.; // The only kinds of expressions that support the requirement of; // commuting with addition are addition and subtraction from ##V.; // Include shifting the Rs to account for the ur addressing mode:; // ##Val + Rs << S; // ##Val - Rs",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:118,Modifiability,extend,extender,118,"// A subexpression in which the extender is used. In general, this; // represents an expression where adding D to the extender will be; // equivalent to adding D to the expression as a whole. In other; // words, expr(add(##V,D) = add(expr(##V),D).; // The original motivation for this are the io/ur addressing modes,; // where the offset is extended. Consider the io example:; // In memw(Rs+##V), the ##V could be replaced by a register Rt to; // form the rr mode: memw(Rt+Rs<<0). In such case, however, the; // register Rt must have exactly the value of ##V. If there was; // another instruction memw(Rs+##V+4), it would need a different Rt.; // Now, if Rt was initialized as ""##V+Rs<<0"", both of these; // instructions could use the same Rt, just with different offsets.; // Here it's clear that ""initializer+4"" should be the same as if; // the offset 4 was added to the ##V in the initializer.; // The only kinds of expressions that support the requirement of; // commuting with addition are addition and subtraction from ##V.; // Include shifting the Rs to account for the ur addressing mode:; // ##Val + Rs << S; // ##Val - Rs",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:341,Modifiability,extend,extended,341,"// A subexpression in which the extender is used. In general, this; // represents an expression where adding D to the extender will be; // equivalent to adding D to the expression as a whole. In other; // words, expr(add(##V,D) = add(expr(##V),D).; // The original motivation for this are the io/ur addressing modes,; // where the offset is extended. Consider the io example:; // In memw(Rs+##V), the ##V could be replaced by a register Rt to; // form the rr mode: memw(Rt+Rs<<0). In such case, however, the; // register Rt must have exactly the value of ##V. If there was; // another instruction memw(Rs+##V+4), it would need a different Rt.; // Now, if Rt was initialized as ""##V+Rs<<0"", both of these; // instructions could use the same Rt, just with different offsets.; // Here it's clear that ""initializer+4"" should be the same as if; // the offset 4 was added to the ##V in the initializer.; // The only kinds of expressions that support the requirement of; // commuting with addition are addition and subtraction from ##V.; // Include shifting the Rs to account for the ur addressing mode:; // ##Val + Rs << S; // ##Val - Rs",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:787,Usability,clear,clear,787,"// A subexpression in which the extender is used. In general, this; // represents an expression where adding D to the extender will be; // equivalent to adding D to the expression as a whole. In other; // words, expr(add(##V,D) = add(expr(##V),D).; // The original motivation for this are the io/ur addressing modes,; // where the offset is extended. Consider the io example:; // In memw(Rs+##V), the ##V could be replaced by a register Rt to; // form the rr mode: memw(Rt+Rs<<0). In such case, however, the; // register Rt must have exactly the value of ##V. If there was; // another instruction memw(Rs+##V+4), it would need a different Rt.; // Now, if Rt was initialized as ""##V+Rs<<0"", both of these; // instructions could use the same Rt, just with different offsets.; // Here it's clear that ""initializer+4"" should be the same as if; // the offset 4 was added to the ##V in the initializer.; // The only kinds of expressions that support the requirement of; // commuting with addition are addition and subtraction from ##V.; // Include shifting the Rs to account for the ur addressing mode:; // ##Val + Rs << S; // ##Val - Rs",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:51,Modifiability,extend,extender,51,// Expression is trivial if it does not modify the extender.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:34,Modifiability,extend,extender,34,// The subexpression in which the extender is used (e.g. address; // computation).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:81,Usability,simpl,simply,81,"// We got to the node we need to remove. If any of its children are; // missing, simply replace it with the other child.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:32,Integrability,depend,depend,32,"// Do not use GUIDs, since they depend on the source path. Moving the; // source file to a different directory could cause different GUID; // values for a pair of given symbols. These symbols could then compare; // ""less"" in one directory, but ""greater"" in another.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:14,Usability,GUID,GUIDs,14,"// Do not use GUIDs, since they depend on the source path. Moving the; // source file to a different directory could cause different GUID; // values for a pair of given symbols. These symbols could then compare; // ""less"" in one directory, but ""greater"" in another.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:133,Usability,GUID,GUID,133,"// Do not use GUIDs, since they depend on the source path. Moving the; // source file to a different directory could cause different GUID; // values for a pair of given symbols. These symbols could then compare; // ""less"" in one directory, but ""greater"" in another.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:256,Modifiability,extend,extender,256,"// Return the allowable deviation from the current value of Rb (i.e. the; // range of values that can be added to the current value) which the; // instruction MI can accommodate.; // The instruction MI is a user of register Rb, which is defined via an; // extender. It may be possible for MI to be tweaked to work for a register; // defined with a slightly different value. For example; // ... = L2_loadrub_io Rb, 1; // can be modifed to be; // ... = L2_loadrub_io Rb', 0; // if Rb' = Rb+1.; // The range for Rb would be [Min+1, Max+1], where [Min, Max] is a range; // for L2_loadrub with offset 0. That means that Rb could be replaced with; // Rc, where Rc-Rb belongs to [Min+1, Max+1].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:34,Modifiability,extend,extended,34,// Instructions that are constant-extended may be replaced with something; // else that no longer offers the same range as the original.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:64,Modifiability,extend,extender,64,"// Return the allowable deviation from the current value of the extender ED,; // for which the instruction corresponding to ED can be modified without; // using an extender.; // The instruction uses the extender directly. It will be replaced with; // another instruction, say MJ, where the extender will be replaced with a; // register. MJ can allow some variability with respect to the value of; // that register, as is the case with indexed memory instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:164,Modifiability,extend,extender,164,"// Return the allowable deviation from the current value of the extender ED,; // for which the instruction corresponding to ED can be modified without; // using an extender.; // The instruction uses the extender directly. It will be replaced with; // another instruction, say MJ, where the extender will be replaced with a; // register. MJ can allow some variability with respect to the value of; // that register, as is the case with indexed memory instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:203,Modifiability,extend,extender,203,"// Return the allowable deviation from the current value of the extender ED,; // for which the instruction corresponding to ED can be modified without; // using an extender.; // The instruction uses the extender directly. It will be replaced with; // another instruction, say MJ, where the extender will be replaced with a; // register. MJ can allow some variability with respect to the value of; // that register, as is the case with indexed memory instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:290,Modifiability,extend,extender,290,"// Return the allowable deviation from the current value of the extender ED,; // for which the instruction corresponding to ED can be modified without; // using an extender.; // The instruction uses the extender directly. It will be replaced with; // another instruction, say MJ, where the extender will be replaced with a; // register. MJ can allow some variability with respect to the value of; // that register, as is the case with indexed memory instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:355,Modifiability,variab,variability,355,"// Return the allowable deviation from the current value of the extender ED,; // for which the instruction corresponding to ED can be modified without; // using an extender.; // The instruction uses the extender directly. It will be replaced with; // another instruction, say MJ, where the extender will be replaced with a; // register. MJ can allow some variability with respect to the value of; // that register, as is the case with indexed memory instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:51,Availability,avail,available,51,// The only way that there can be a non-zero range available is if; // the instruction using ED will be converted to an indexed memory; // instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:125,Modifiability,extend,extended,125,"// (__: ## + Rs<<0); // Store-immediates are treated as non-memory operations, since; // it's the value being stored that is extended (as opposed to; // a part of the address).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:41,Modifiability,extend,extenders,41,// Basic correctness: make sure that all extenders in the range [Begin..End); // share the same root ER.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:118,Modifiability,Extend,Extender,118,"// Construct the list of ranges, such that for each P in Ranges[I],; // a register Reg = ER+P can be used in place of Extender[I]. If the; // instruction allows, uses in the form of Reg+Off are considered; // (here, Off = required_value - P).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:219,Deployability,update,updated,219,"// For each extender that is a def, visit all uses of the defined register,; // and produce an offset range that works for all uses. The def doesn't; // have to be checked, because it can become dead if all uses can be updated; // to use a different reg/offset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:12,Modifiability,extend,extender,12,"// For each extender that is a def, visit all uses of the defined register,; // and produce an offset range that works for all uses. The def doesn't; // have to be checked, because it can become dead if all uses can be updated; // to use a different reg/offset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:77,Availability,avail,available,77,"// Visit all non-def extenders. For each one, determine the offset range; // available for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:21,Modifiability,extend,extenders,21,"// Visit all non-def extenders. For each one, determine the offset range; // available for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:54,Modifiability,extend,extender,54,"// Build the assignment map: candidate C -> { list of extender indexes }.; // This has to be done iteratively:; // - pick the candidate that covers the maximum number of extenders,; // - add the candidate to the map,; // - remove the extenders from the pool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:170,Modifiability,extend,extenders,170,"// Build the assignment map: candidate C -> { list of extender indexes }.; // This has to be done iteratively:; // - pick the candidate that covers the maximum number of extenders,; // - add the candidate to the map,; // - remove the extenders from the pool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:234,Modifiability,extend,extenders,234,"// Build the assignment map: candidate C -> { list of extender indexes }.; // This has to be done iteratively:; // - pick the candidate that covers the maximum number of extenders,; // - add the candidate to the map,; // - remove the extenders from the pool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:57,Modifiability,extend,extenders,57,// Find the best candidate with respect to the number of extenders covered.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:350,Energy Efficiency,reduce,reduce,350,"// There is some ambiguity in what initializer should be used, if the; // descriptor's subexpression is non-trivial: it can be the entire; // subexpression (which is what has been done so far), or it can be; // the extender's value itself, if all corresponding extenders have the; // exact value of the initializer (i.e. require offset of 0).; // To reduce the number of initializers, merge such special cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:215,Modifiability,extend,extender,215,"// There is some ambiguity in what initializer should be used, if the; // descriptor's subexpression is non-trivial: it can be the entire; // subexpression (which is what has been done so far), or it can be; // the extender's value itself, if all corresponding extenders have the; // exact value of the initializer (i.e. require offset of 0).; // To reduce the number of initializers, merge such special cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:261,Modifiability,extend,extenders,261,"// There is some ambiguity in what initializer should be used, if the; // descriptor's subexpression is non-trivial: it can be the entire; // subexpression (which is what has been done so far), or it can be; // the extender's value itself, if all corresponding extenders have the; // exact value of the initializer (i.e. require offset of 0).; // To reduce the number of initializers, merge such special cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:25,Modifiability,extend,extenders,25,"// Finally, check if all extenders have the same value as the initializer.; // Make sure that extenders that are a part of a stack address are not; // merged with those that aren't. Stack addresses need an offset field; // (to be used by frame index elimination), while non-stack expressions; // can be replaced with forms (such as rr) that do not have such a field.; // Example:; //; // Collected 3 extenders; // =2. imm:0 off:32968 bb#2: %7 = ## + __ << 0, def; // 0. imm:0 off:267 bb#0: __ = ## + SS#1 << 0; // 1. imm:0 off:267 bb#1: __ = ## + SS#1 << 0; // Ranges; // 0. [-756,267]a1+0; // 1. [-756,267]a1+0; // 2. [201,65735]a1+0; // RangeMap; // [-756,267]a1+0 -> 0 1; // [201,65735]a1+0 -> 2; // IMap (before fixup) = {; // [imm:0 off:267, ## + __ << 0] -> { 2 }; // [imm:0 off:267, ## + SS#1 << 0] -> { 0 1 }; // }; // IMap (after fixup) = {; // [imm:0 off:267, ## + __ << 0] -> { 2 0 1 }; // [imm:0 off:267, ## + SS#1 << 0] -> { }; // }; // Inserted def in bb#0 for initializer: [imm:0 off:267, ## + __ << 0]; // %12:intregs = A2_tfrsi 267; //; // The result was; // %12:intregs = A2_tfrsi 267; // S4_pstorerbt_rr %3, %12, %stack.1, 0, killed %4; // Which became; // r0 = #267; // if (p0.new) memb(r0+r29<<#4) = r2",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:94,Modifiability,extend,extenders,94,"// Finally, check if all extenders have the same value as the initializer.; // Make sure that extenders that are a part of a stack address are not; // merged with those that aren't. Stack addresses need an offset field; // (to be used by frame index elimination), while non-stack expressions; // can be replaced with forms (such as rr) that do not have such a field.; // Example:; //; // Collected 3 extenders; // =2. imm:0 off:32968 bb#2: %7 = ## + __ << 0, def; // 0. imm:0 off:267 bb#0: __ = ## + SS#1 << 0; // 1. imm:0 off:267 bb#1: __ = ## + SS#1 << 0; // Ranges; // 0. [-756,267]a1+0; // 1. [-756,267]a1+0; // 2. [201,65735]a1+0; // RangeMap; // [-756,267]a1+0 -> 0 1; // [201,65735]a1+0 -> 2; // IMap (before fixup) = {; // [imm:0 off:267, ## + __ << 0] -> { 2 }; // [imm:0 off:267, ## + SS#1 << 0] -> { 0 1 }; // }; // IMap (after fixup) = {; // [imm:0 off:267, ## + __ << 0] -> { 2 0 1 }; // [imm:0 off:267, ## + SS#1 << 0] -> { }; // }; // Inserted def in bb#0 for initializer: [imm:0 off:267, ## + __ << 0]; // %12:intregs = A2_tfrsi 267; //; // The result was; // %12:intregs = A2_tfrsi 267; // S4_pstorerbt_rr %3, %12, %stack.1, 0, killed %4; // Which became; // r0 = #267; // if (p0.new) memb(r0+r29<<#4) = r2",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:400,Modifiability,extend,extenders,400,"// Finally, check if all extenders have the same value as the initializer.; // Make sure that extenders that are a part of a stack address are not; // merged with those that aren't. Stack addresses need an offset field; // (to be used by frame index elimination), while non-stack expressions; // can be replaced with forms (such as rr) that do not have such a field.; // Example:; //; // Collected 3 extenders; // =2. imm:0 off:32968 bb#2: %7 = ## + __ << 0, def; // 0. imm:0 off:267 bb#0: __ = ## + SS#1 << 0; // 1. imm:0 off:267 bb#1: __ = ## + SS#1 << 0; // Ranges; // 0. [-756,267]a1+0; // 1. [-756,267]a1+0; // 2. [201,65735]a1+0; // RangeMap; // [-756,267]a1+0 -> 0 1; // [201,65735]a1+0 -> 2; // IMap (before fixup) = {; // [imm:0 off:267, ## + __ << 0] -> { 2 }; // [imm:0 off:267, ## + SS#1 << 0] -> { 0 1 }; // }; // IMap (after fixup) = {; // [imm:0 off:267, ## + __ << 0] -> { 2 0 1 }; // [imm:0 off:267, ## + SS#1 << 0] -> { }; // }; // Inserted def in bb#0 for initializer: [imm:0 off:267, ## + __ << 0]; // %12:intregs = A2_tfrsi 267; //; // The result was; // %12:intregs = A2_tfrsi 267; // S4_pstorerbt_rr %3, %12, %stack.1, 0, killed %4; // Which became; // r0 = #267; // if (p0.new) memb(r0+r29<<#4) = r2",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:41,Usability,simpl,simple,41,"// The placement calculation is somewhat simple right now: it finds a; // single location for the def that dominates all refs. Since this may; // place the def far from the uses, producing several locations for; // defs that collectively dominate all refs could be better.; // For now only do the single one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:110,Testability,assert,assertion,110,// This should be guaranteed given that the entire expression is used; // at each instruction in Refs. Add an assertion just in case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:20,Availability,avail,available,20,"// No compounds are available. It is not clear whether we should; // even process such extenders where the initializer cannot be; // a single instruction, but do it for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:87,Modifiability,extend,extenders,87,"// No compounds are available. It is not clear whether we should; // even process such extenders where the initializer cannot be; // a single instruction, but do it for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:41,Usability,clear,clear,41,"// No compounds are available. It is not clear whether we should; // even process such extenders where the initializer cannot be; // a single instruction, but do it for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:15,Modifiability,extend,extender,15,// Replace the extender at index Idx with the register ExtR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:199,Modifiability,extend,extender,199,"// With a few exceptions, direct replacement amounts to creating an; // instruction with a corresponding register opcode, with all operands; // the same, except for the register used in place of the extender.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:49,Modifiability,extend,extender,49,// Copy all operands except the one that has the extender.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:105,Modifiability,extend,extenders,105,"// For memory instructions, there is an asymmetry in the addressing; // modes. Addressing modes allowing extenders can be replaced with; // addressing modes that use registers, but the order of operands; // (or even their number) may be different.; // Replacements:; // BaseImmOffset (io) -> BaseRegOffset (rr); // BaseLongOffset (ur) -> BaseRegOffset (rr)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:3,Performance,Load,Loads,3,"// Loads: Rd = L4_loadri_ur Rs, S, ##; // Stores: S4_storeri_ur Rs, S, ##, Rt",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:26,Performance,load,loads,26,"// First, add the def for loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:15,Modifiability,extend,extender,15,// Replace the extender ED with a form corresponding to the initializer ExtI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:390,Usability,simpl,simply,390,"// A2_tfrsi is a special case: it's replaced with A2_addi, which introduces; // another range. One range is the one that's common to all tfrsi's uses,; // this one is the range of immediates in A2_addi. When calculating ranges,; // the addi's 16-bit argument was included, so now we need to make it such; // that the produced value is in the range for the uses alone.; // Most of the time, simply adding Diff will make the addi produce exact; // result, but if Diff is outside of the 16-bit range, some adjustment; // will be needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:148,Usability,simpl,simplicity,148,"// If addi/subri are replaced with the exactly matching initializer,; // they amount to COPY.; // Check that the initializer is an exact match (for simplicity).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:69,Performance,load,loads,69,"// Construct the new indexed instruction.; // First, add the def for loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:56,Deployability,update,updated,56,"// If it's a def, remember all operands that need to be updated.; // If ED is a def, and Diff is not 0, then all uses of the register Rd; // defined by ED must be in the form (Rd, imm), i.e. the immediate offset; // must follow the Rd in the operand list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:3,Deployability,Update,Update,3,// Update offsets of the def's uses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:174,Deployability,update,updated,174,"// If it was an absolute-set instruction, the ""set"" part has been removed.; // ExtR will now be the register with the extended value, and since all; // users of Rd have been updated, all that needs to be done is to replace; // Rd with ExtR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:118,Modifiability,extend,extended,118,"// If it was an absolute-set instruction, the ""set"" part has been removed.; // ExtR will now be the register with the extended value, and since all; // users of Rd have been updated, all that needs to be done is to replace; // Rd with ExtR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp:6,Safety,avoid,avoid,6,"// To avoid creating ""top"" entries, return a const reference to; // this cell in ""get"". Also, have a ""Bottom"" cell to return from; // get when a value of a physical register is requested.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp:106,Integrability,interface,interface,106,"// The ""evaluator/rewriter"" of machine instructions. This is an abstract; // base class that provides the interface that the propagator will use,; // as well as some helper functions that are target-independent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp:18,Modifiability,rewrite,rewriter,18,"// The ""evaluator/rewriter"" of machine instructions. This is an abstract; // base class that provides the interface that the propagator will use,; // as well as some helper functions that are target-independent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp:16,Integrability,interface,interface,16,"// The required interface:; // - A set of three ""evaluate"" functions. Each returns ""true"" if the; // computation succeeded, ""false"" otherwise.; // (1) Given an instruction MI, and the map with input values ""Inputs"",; // compute the set of output values ""Outputs"". An example of when; // the computation can ""fail"" is if MI is not an instruction that; // is recognized by the evaluator.; // (2) Given a register R (as reg:subreg), compute the cell that; // corresponds to the ""subreg"" part of the given register.; // (3) Given a branch instruction BrI, compute the set of target blocks.; // If the branch can fall-through, add null (0) to the list of; // possible targets.; // - A function ""rewrite"", that given the cell map after propagation,; // could rewrite instruction MI in a more beneficial form. Return; // ""true"" if a change has been made, ""false"" otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp:690,Modifiability,rewrite,rewrite,690,"// The required interface:; // - A set of three ""evaluate"" functions. Each returns ""true"" if the; // computation succeeded, ""false"" otherwise.; // (1) Given an instruction MI, and the map with input values ""Inputs"",; // compute the set of output values ""Outputs"". An example of when; // the computation can ""fail"" is if MI is not an instruction that; // is recognized by the evaluator.; // (2) Given a register R (as reg:subreg), compute the cell that; // corresponds to the ""subreg"" part of the given register.; // (3) Given a branch instruction BrI, compute the set of target blocks.; // If the branch can fall-through, add null (0) to the list of; // possible targets.; // - A function ""rewrite"", that given the cell map after propagation,; // could rewrite instruction MI in a more beneficial form. Return; // ""true"" if a change has been made, ""false"" otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp:753,Modifiability,rewrite,rewrite,753,"// The required interface:; // - A set of three ""evaluate"" functions. Each returns ""true"" if the; // computation succeeded, ""false"" otherwise.; // (1) Given an instruction MI, and the map with input values ""Inputs"",; // compute the set of output values ""Outputs"". An example of when; // the computation can ""fail"" is if MI is not an instruction that; // is recognized by the evaluator.; // (2) Given a register R (as reg:subreg), compute the cell that; // corresponds to the ""subreg"" part of the given register.; // (3) Given a branch instruction BrI, compute the set of target blocks.; // If the branch can fall-through, add null (0) to the list of; // possible targets.; // - A function ""rewrite"", that given the cell map after propagation,; // could rewrite instruction MI in a more beneficial form. Return; // ""true"" if a change has been made, ""false"" otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp:3,Testability,Log,Logical,3,// Logical operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp:37,Deployability,integrat,integrate,37,// Top/bottom cases covered. Need to integrate L's set into ours.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp:37,Integrability,integrat,integrate,37,// Top/bottom cases covered. Need to integrate L's set into ours.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp:67,Deployability,update,update,67,"// Add a new constant to the cell. This is actually where the cell update; // happens. If a cell has room for more constants, the new constant is added.; // Otherwise, the cell is converted to a ""property"" cell (i.e. a cell that; // will track properties of the associated values, and not the values; // themselves. Care is taken to handle special cases, like ""bottom"", etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp:3,Deployability,Update,Update,3,"// Update outputs. If the value was not computed, set all the; // def cells to bottom.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp:213,Performance,queue,queue,213,"// Starting at a given branch, visit remaining branches in the block.; // Traverse over the subsequent branches for as long as the preceding one; // can fall through. Add all the possible targets to the flow work queue,; // including the potential fall-through to the layout-successor block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp:113,Performance,queue,queue,113,"// Do not process non-executable instructions. They can become exceutable; // later (via a flow-edge in the work queue). In such case, the instruc-; // tion will be visited at that time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp:78,Performance,queue,queue,78,"// If the block didn't have a branch, add all successor edges to the; // work queue. (There should really be only one successor in such case.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp:175,Availability,down,downstream,175,"// Rewrite all instructions based on the collected cell information.; //; // Traverse the instructions in a post-order, so that rewriting an; // instruction can make changes ""downstream"" in terms of control-flow; // without affecting the rewriting process. (We should not change; // instructions that have not yet been visited by the rewriter.); // The reason for this is that the rewriter can introduce new vregs,; // and replace uses of old vregs (which had corresponding cells; // computed during propagation) with these new vregs (which at this; // point would not have any cells, and would appear to be ""top"").; // If an attempt was made to evaluate an instruction with a fresh; // ""top"" vreg, it would cause an error (abend) in the evaluator.; // Collect the post-order-traversal block ordering. The subsequent; // traversal/rewrite will update block successors, so it's safer; // if the visiting order it computed ahead of time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp:717,Availability,error,error,717,"// Rewrite all instructions based on the collected cell information.; //; // Traverse the instructions in a post-order, so that rewriting an; // instruction can make changes ""downstream"" in terms of control-flow; // without affecting the rewriting process. (We should not change; // instructions that have not yet been visited by the rewriter.); // The reason for this is that the rewriter can introduce new vregs,; // and replace uses of old vregs (which had corresponding cells; // computed during propagation) with these new vregs (which at this; // point would not have any cells, and would appear to be ""top"").; // If an attempt was made to evaluate an instruction with a fresh; // ""top"" vreg, it would cause an error (abend) in the evaluator.; // Collect the post-order-traversal block ordering. The subsequent; // traversal/rewrite will update block successors, so it's safer; // if the visiting order it computed ahead of time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp:844,Deployability,update,update,844,"// Rewrite all instructions based on the collected cell information.; //; // Traverse the instructions in a post-order, so that rewriting an; // instruction can make changes ""downstream"" in terms of control-flow; // without affecting the rewriting process. (We should not change; // instructions that have not yet been visited by the rewriter.); // The reason for this is that the rewriter can introduce new vregs,; // and replace uses of old vregs (which had corresponding cells; // computed during propagation) with these new vregs (which at this; // point would not have any cells, and would appear to be ""top"").; // If an attempt was made to evaluate an instruction with a fresh; // ""top"" vreg, it would cause an error (abend) in the evaluator.; // Collect the post-order-traversal block ordering. The subsequent; // traversal/rewrite will update block successors, so it's safer; // if the visiting order it computed ahead of time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp:3,Modifiability,Rewrite,Rewrite,3,"// Rewrite all instructions based on the collected cell information.; //; // Traverse the instructions in a post-order, so that rewriting an; // instruction can make changes ""downstream"" in terms of control-flow; // without affecting the rewriting process. (We should not change; // instructions that have not yet been visited by the rewriter.); // The reason for this is that the rewriter can introduce new vregs,; // and replace uses of old vregs (which had corresponding cells; // computed during propagation) with these new vregs (which at this; // point would not have any cells, and would appear to be ""top"").; // If an attempt was made to evaluate an instruction with a fresh; // ""top"" vreg, it would cause an error (abend) in the evaluator.; // Collect the post-order-traversal block ordering. The subsequent; // traversal/rewrite will update block successors, so it's safer; // if the visiting order it computed ahead of time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp:334,Modifiability,rewrite,rewriter,334,"// Rewrite all instructions based on the collected cell information.; //; // Traverse the instructions in a post-order, so that rewriting an; // instruction can make changes ""downstream"" in terms of control-flow; // without affecting the rewriting process. (We should not change; // instructions that have not yet been visited by the rewriter.); // The reason for this is that the rewriter can introduce new vregs,; // and replace uses of old vregs (which had corresponding cells; // computed during propagation) with these new vregs (which at this; // point would not have any cells, and would appear to be ""top"").; // If an attempt was made to evaluate an instruction with a fresh; // ""top"" vreg, it would cause an error (abend) in the evaluator.; // Collect the post-order-traversal block ordering. The subsequent; // traversal/rewrite will update block successors, so it's safer; // if the visiting order it computed ahead of time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp:381,Modifiability,rewrite,rewriter,381,"// Rewrite all instructions based on the collected cell information.; //; // Traverse the instructions in a post-order, so that rewriting an; // instruction can make changes ""downstream"" in terms of control-flow; // without affecting the rewriting process. (We should not change; // instructions that have not yet been visited by the rewriter.); // The reason for this is that the rewriter can introduce new vregs,; // and replace uses of old vregs (which had corresponding cells; // computed during propagation) with these new vregs (which at this; // point would not have any cells, and would appear to be ""top"").; // If an attempt was made to evaluate an instruction with a fresh; // ""top"" vreg, it would cause an error (abend) in the evaluator.; // Collect the post-order-traversal block ordering. The subsequent; // traversal/rewrite will update block successors, so it's safer; // if the visiting order it computed ahead of time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp:831,Modifiability,rewrite,rewrite,831,"// Rewrite all instructions based on the collected cell information.; //; // Traverse the instructions in a post-order, so that rewriting an; // instruction can make changes ""downstream"" in terms of control-flow; // without affecting the rewriting process. (We should not change; // instructions that have not yet been visited by the rewriter.); // The reason for this is that the rewriter can introduce new vregs,; // and replace uses of old vregs (which had corresponding cells; // computed during propagation) with these new vregs (which at this; // point would not have any cells, and would appear to be ""top"").; // If an attempt was made to evaluate an instruction with a fresh; // ""top"" vreg, it would cause an error (abend) in the evaluator.; // Collect the post-order-traversal block ordering. The subsequent; // traversal/rewrite will update block successors, so it's safer; // if the visiting order it computed ahead of time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp:877,Safety,safe,safer,877,"// Rewrite all instructions based on the collected cell information.; //; // Traverse the instructions in a post-order, so that rewriting an; // instruction can make changes ""downstream"" in terms of control-flow; // without affecting the rewriting process. (We should not change; // instructions that have not yet been visited by the rewriter.); // The reason for this is that the rewriter can introduce new vregs,; // and replace uses of old vregs (which had corresponding cells; // computed during propagation) with these new vregs (which at this; // point would not have any cells, and would appear to be ""top"").; // If an attempt was made to evaluate an instruction with a fresh; // ""top"" vreg, it would cause an error (abend) in the evaluator.; // Collect the post-order-traversal block ordering. The subsequent; // traversal/rewrite will update block successors, so it's safer; // if the visiting order it computed ahead of time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp:116,Deployability,update,update,116,"// Walk the block backwards (which usually begin with the branches).; // If any branch is rewritten, we may need to update the successor; // information for this block. Unless the block's successors can be; // precisely determined (which may not be the case for indirect; // branches), we cannot modify any branch.; // Compute the successor information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite the executable instructions. Skip branches if we don't; // have block successor information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp:23,Modifiability,rewrite,rewrite,23,"// The rewriting could rewrite PHI nodes to non-PHI nodes, causing; // regular instructions to appear in between PHI nodes. Bring all; // the PHI nodes to the beginning of the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp:3,Deployability,Update,Update,3,// Update the block successor information: remove unnecessary successors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp:14,Testability,log,logical,14,// The actual logical value of the comparison is same as IsTrue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp:14,Testability,log,logical,14,// The actual logical value of the comparison is same as IsTrue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp:22,Modifiability,extend,extended,22,// V is a 64-bit sign-extended value. Convert it to APInt of desired; // width.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp:139,Safety,safe,safety,139,"// The operand of CONST32 can be a blockaddress, e.g.; // %0 = CONST32 <blockaddress(@eat, %l)>; // Do this check for all instructions for safety.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp:134,Energy Efficiency,reduce,reduce,134,"// If the requested bitfield extends beyond the most significant bit,; // the extra bits are treated as 0s. To emulate this behavior, reduce; // the number of requested bits, and make the extract unsigned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp:29,Modifiability,extend,extends,29,"// If the requested bitfield extends beyond the most significant bit,; // the extra bits are treated as 0s. To emulate this behavior, reduce; // the number of requested bits, and make the extract unsigned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp:3,Usability,Simpl,Simple,3,"// Simple branch: if([!]Pn) jump ...; // i.e. Op0 = predicate, Op1 = branch target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp:132,Modifiability,rewrite,rewrite,132,"// If not all defs have been rewritten (i.e. the instruction defines; // a register that is not compile-time constant), then try to rewrite; // register operands that are known to be constant with immediates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp:3,Safety,Avoid,Avoid,3,// Avoid generating TFRIs for register transfers---this will keep the; // coalescing opportunities.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp:3,Usability,clear,clear,3,// clear all the kill flags of this new instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp:25,Modifiability,extend,extended,25,// Only combine constant extended A2_tfrsi if we are in aggressive mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp:39,Modifiability,extend,extended,39,// There is no combine of two constant extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp:38,Modifiability,extend,extended,38,"// There is a combine of two constant extended values into CONST64,; // provided both constants are true immediates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp:39,Modifiability,extend,extended,39,"// There is no combine of two constant extended values, unless handled above; // Make both 8-bit size checks to allow both combine (#,##) and combine(##,#)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp:26,Safety,unsafe,unsafe,26,/// Returns true if it is unsafe to move a copy instruction from \p UseReg to; /// \p DestReg over the instruction \p MI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp:49,Safety,safe,safe,49,/// isSafeToMoveTogether - Returns true if it is safe to move I1 next to I2 such; /// that the two instructions can be paired in a combine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp:74,Integrability,depend,dependence,74,// It is not safe to move I1 and I2 into one combine if I2 has a true; // dependence on I1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp:13,Safety,safe,safe,13,// It is not safe to move I1 and I2 into one combine if I2 has a true; // dependence on I1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp:3,Deployability,Update,Update,3,// Update first use of the killed operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp:3,Deployability,Update,Update,3,// Update the intermediate instruction to with the kill flag.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp:98,Deployability,update,update,98,"// Track killed operands. If we move across an instruction that kills our; // operand, we need to update the kill information on the moved I1. It kills; // the operand now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp:3,Deployability,Update,Update,3,// Update I1 to set the kill flag. This flag will later be picked up by; // the new COMBINE instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp:7,Safety,safe,safe,7,// Not safe. Stop searching.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp:38,Modifiability,extend,extended,38,// There is a combine of two constant extended values into CONST64.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp:178,Modifiability,extend,extended,178,"// First preference should be given to Hexagon::A2_combineii instruction; // as it can include U6 (in Hexagon::A4_combineii) as well.; // In this instruction, HiOperand is const extended, if required.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp:43,Modifiability,extend,extended,43,"// In this instruction, LoOperand is const extended, if required.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp:742,Deployability,patch,patch,742,"//===- HexagonEarlyIfConv.cpp ---------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements a Hexagon-specific if-conversion pass that runs on the; // SSA form.; // In SSA it is not straightforward to represent instructions that condi-; // tionally define registers, since a conditionally-defined register may; // only be used under the same condition on which the definition was based.; // To avoid complications of this nature, this patch will only generate; // predicated stores, and speculate other instructions from the ""if-conver-; // ted"" block.; // The code will recognize CFG patterns where a block with a conditional; // branch ""splits"" into a ""true block"" and a ""false block"". Either of these; // could be omitted (in case of a triangle, for example).; // If after conversion of the side block(s) the CFG allows it, the resul-; // ting blocks may be merged. If the ""join"" block contained PHI nodes, they; // will be replaced with MUX (or MUX-like) instructions to maintain the; // semantics of the PHI.; //; // Example:; //; // %40 = L2_loadrub_io killed %39, 1; // %41 = S2_tstbit_i killed %40, 0; // J2_jumpt killed %41, <%bb.5>, implicit dead %pc; // J2_jump <%bb.4>, implicit dead %pc; // Successors according to CFG: %bb.4(62) %bb.5(62); //; // %bb.4: derived from LLVM BB %if.then; // Predecessors according to CFG: %bb.3; // %11 = A2_addp %6, %10; // S2_storerd_io %32, 16, %11; // Successors according to CFG: %bb.5; //; // %bb.5: derived from LLVM BB %if.end; // Predecessors according to CFG: %bb.3 %bb.4; // %12 = PHI %6, <%bb.3>, %11, <%bb.4>; // %13 = A2_addp %7, %12; // %42 = C2_cmpeqi %9, 10; // J2_jumpf killed %42, <%bb.3>, implicit dead %pc; // J2_jump <%bb.6>, im",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp:701,Safety,avoid,avoid,701,"//===- HexagonEarlyIfConv.cpp ---------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements a Hexagon-specific if-conversion pass that runs on the; // SSA form.; // In SSA it is not straightforward to represent instructions that condi-; // tionally define registers, since a conditionally-defined register may; // only be used under the same condition on which the definition was based.; // To avoid complications of this nature, this patch will only generate; // predicated stores, and speculate other instructions from the ""if-conver-; // ted"" block.; // The code will recognize CFG patterns where a block with a conditional; // branch ""splits"" into a ""true block"" and a ""false block"". Either of these; // could be omitted (in case of a triangle, for example).; // If after conversion of the side block(s) the CFG allows it, the resul-; // ting blocks may be merged. If the ""join"" block contained PHI nodes, they; // will be replaced with MUX (or MUX-like) instructions to maintain the; // semantics of the PHI.; //; // Example:; //; // %40 = L2_loadrub_io killed %39, 1; // %41 = S2_tstbit_i killed %40, 0; // J2_jumpt killed %41, <%bb.5>, implicit dead %pc; // J2_jump <%bb.4>, implicit dead %pc; // Successors according to CFG: %bb.4(62) %bb.5(62); //; // %bb.4: derived from LLVM BB %if.then; // Predecessors according to CFG: %bb.3; // %11 = A2_addp %6, %10; // S2_storerd_io %32, 16, %11; // Successors according to CFG: %bb.5; //; // %bb.5: derived from LLVM BB %if.end; // Predecessors according to CFG: %bb.3 %bb.4; // %12 = PHI %6, <%bb.3>, %11, <%bb.4>; // %13 = A2_addp %7, %12; // %42 = C2_cmpeqi %9, 10; // J2_jumpf killed %42, <%bb.3>, implicit dead %pc; // J2_jump <%bb.6>, im",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp:3,Safety,Detect,Detect,3,"// Detect triangle first. In case of a triangle, one of the blocks TB/FB; // can fall through into the other, in other words, it will be executed; // in both cases. We only want to predicate the block that is executed; // conditionally.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp:212,Deployability,update,update,212,"// Look for predicate registers defined by this instruction. It's ok; // to speculate such an instruction, but the predicate register cannot; // be used outside of this block (or else it won't be possible to; // update the use of it after predication). PHI uses will be updated; // to use a result of a MUX, and a MUX cannot be created for predicate; // registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp:270,Deployability,update,updated,270,"// Look for predicate registers defined by this instruction. It's ok; // to speculate such an instruction, but the predicate register cannot; // be used outside of this block (or else it won't be possible to; // update the use of it after predication). PHI uses will be updated; // to use a result of a MUX, and a MUX cannot be created for predicate; // registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp:565,Availability,down,down,565,"// Check the PHIs in the join block. If any of them use a register; // that is defined as IMPLICIT_DEF, do not convert this. This can; // legitimately happen if one side of the split never executes, but; // the compiler is unable to prove it. That side may then seem to; // provide an ""undef"" value to the join block, however it will never; // execute at run-time. If we convert this case, the ""undef"" will; // be used in a MUX instruction, and that may seem like actually; // using an undefined value to other optimizations. This could lead; // to trouble further down the optimization stream, cause assertions; // to fail, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp:511,Performance,optimiz,optimizations,511,"// Check the PHIs in the join block. If any of them use a register; // that is defined as IMPLICIT_DEF, do not convert this. This can; // legitimately happen if one side of the split never executes, but; // the compiler is unable to prove it. That side may then seem to; // provide an ""undef"" value to the join block, however it will never; // execute at run-time. If we convert this case, the ""undef"" will; // be used in a MUX instruction, and that may seem like actually; // using an undefined value to other optimizations. This could lead; // to trouble further down the optimization stream, cause assertions; // to fail, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp:574,Performance,optimiz,optimization,574,"// Check the PHIs in the join block. If any of them use a register; // that is defined as IMPLICIT_DEF, do not convert this. This can; // legitimately happen if one side of the split never executes, but; // the compiler is unable to prove it. That side may then seem to; // provide an ""undef"" value to the join block, however it will never; // execute at run-time. If we convert this case, the ""undef"" will; // be used in a MUX instruction, and that may seem like actually; // using an undefined value to other optimizations. This could lead; // to trouble further down the optimization stream, cause assertions; // to fail, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp:601,Testability,assert,assertions,601,"// Check the PHIs in the join block. If any of them use a register; // that is defined as IMPLICIT_DEF, do not convert this. This can; // legitimately happen if one side of the split never executes, but; // the compiler is unable to prove it. That side may then seem to; // provide an ""undef"" value to the join block, however it will never; // execute at run-time. If we convert this case, the ""undef"" will; // be used in a MUX instruction, and that may seem like actually; // using an undefined value to other optimizations. This could lead; // to trouble further down the optimization stream, cause assertions; // to fail, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp:127,Deployability,update,updated,127,"// If both incoming blocks are one of the TrueB/FalseB/SplitB, then; // a MUX may be needed. Otherwise the PHI will need to be updated at; // no extra cost.; // Find the interesting PHI operands for further checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp:54,Deployability,update,updated,54,"// Count the number of PHI nodes that will need to be updated (converted; // to MUX). Those can be later converted to predicated instructions, so; // they aren't always adding extra cost.; // KLUDGE: Also, count the number of predicate register definitions in; // each block. The scheduler may increase the pressure of these and cause; // expensive spills (e.g. bitmnp01).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp:280,Energy Efficiency,schedul,scheduler,280,"// Count the number of PHI nodes that will need to be updated (converted; // to MUX). Those can be later converted to predicated instructions, so; // they aren't always adding extra cost.; // KLUDGE: Also, count the number of predicate register definitions in; // each block. The scheduler may increase the pressure of these and cause; // expensive spills (e.g. bitmnp01).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp:75,Safety,avoid,avoid,75,"// We will change CFG/DT during this traversal, so take precautions to; // avoid problems related to invalidated iterators. In fact, processing; // a child C of B cannot cause another child to be removed, but it can; // cause a new child to be added (which was a child of C before C itself; // was removed. This new child C, however, would have been processed; // prior to processing B, so there is no need to process it again.; // Simply keep a list of children of B, and traverse that list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp:432,Usability,Simpl,Simply,432,"// We will change CFG/DT during this traversal, so take precautions to; // avoid problems related to invalidated iterators. In fact, processing; // a child C of B cannot cause another child to be removed, but it can; // cause a new child to be added (which was a child of C before C itself; // was removed. This new child C, however, would have been processed; // prior to processing B, so there is no need to process it again.; // Simply keep a list of children of B, and traverse that list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp:16,Availability,down,down,16,"// When walking down the dominator tree, we want to traverse through; // blocks from nested (other) loops, because they can dominate blocks; // that are in L. Skip the non-L blocks only after the tree traversal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp:122,Modifiability,extend,extended,122,// HexagonInstrInfo::isPredicable will consider these stores are non-; // -predicable if the offset would become constant-extended after; // predication.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp:74,Safety,abort,abort,74,// Print the offending instruction unconditionally as we are about to; // abort.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp:97,Deployability,Update,Update,97,// Visit all PHI nodes in the WhereB block and generate MUX instructions; // in the split block. Update the PHI nodes with the values of the MUX.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp:53,Deployability,update,update,53,"// Regenerate new terminators in the split block and update the successors.; // First, remember any information that may be needed later and remove the; // existing terminators/successors from the split block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp:27,Deployability,update,update,27,"// Insert new branches and update the successors of the split block. This; // may create unconditional branches to the layout successor, etc., but; // that will be cleaned up later. For now, make sure that correct code is; // generated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp:28,Deployability,update,update,28,// What is left to do is to update the PHI nodes that could have entries; // referring to predicated blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp:14,Deployability,update,update,14,"// Nothing to update in SSB, since SSB's predecessors haven't changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp:45,Deployability,update,update,45,"// MRI.replaceVregUsesWith does not allow to update the subregister,; // so instead of doing the use-iteration here, create a copy into a; // ""non-subregistered"" register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp:135,Deployability,update,update,135,"// By now, the split block has only one successor (SB), and SB has only; // one predecessor. We can try to merge them. We will need to update ter-; // minators in FP.Split+SB, and that requires working analyzeBranch, which; // fails on Hexagon for blocks that have EH_LABELs. However, if SB ends; // with an unconditional branch, we won't need to touch the terminators.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:1612,Availability,down,down,1612," placed between register coalescing and machine instruction; // scheduler.; // In this place in the optimization sequence, live interval analysis had; // been performed, and the live intervals should be preserved. A large part; // of the code deals with preserving the liveness information.; //; // Liveness tracking aside, the main functionality of this pass is divided; // into two steps. The first step is to replace an instruction; // %0 = C2_mux %1, %2, %3; // with a pair of conditional transfers; // %0 = A2_tfrt %1, %2; // %0 = A2_tfrf %1, %3; // It is the intention that the execution of this pass could be terminated; // after this step, and the code generated would be functionally correct.; //; // If the uses of the source values %1 and %2 are kills, and their; // definitions are predicable, then in the second step, the conditional; // transfers will then be rewritten as predicated instructions. E.g.; // %0 = A2_or %1, %2; // %3 = A2_tfrt %99, killed %0; // will be rewritten as; // %3 = A2_port %99, %1, %2; //; // This replacement has two variants: ""up"" and ""down"". Consider this case:; // %0 = A2_or %1, %2; // ... [intervening instructions] ...; // %3 = A2_tfrt %99, killed %0; // variant ""up"":; // %3 = A2_port %99, %1, %2; // ... [intervening instructions, %0->vreg3] ...; // [deleted]; // variant ""down"":; // [deleted]; // ... [intervening instructions] ...; // %3 = A2_port %99, %1, %2; //; // Both, one or none of these variants may be valid, and checks are made; // to rule out inapplicable variants.; //; // As an additional optimization, before either of the two steps above is; // executed, the pass attempts to coalesce the target register with one of; // the source registers, e.g. given an instruction; // %3 = C2_mux %0, %1, %2; // %3 will be coalesced with either %1 or %2. If this succeeds,; // the instruction would then be (for example); // %3 = C2_mux %0, %3, %2; // and, under certain circumstances, this could result in only one predicated; // instruction:; /",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:1856,Availability,down,down,1856,"e, the main functionality of this pass is divided; // into two steps. The first step is to replace an instruction; // %0 = C2_mux %1, %2, %3; // with a pair of conditional transfers; // %0 = A2_tfrt %1, %2; // %0 = A2_tfrf %1, %3; // It is the intention that the execution of this pass could be terminated; // after this step, and the code generated would be functionally correct.; //; // If the uses of the source values %1 and %2 are kills, and their; // definitions are predicable, then in the second step, the conditional; // transfers will then be rewritten as predicated instructions. E.g.; // %0 = A2_or %1, %2; // %3 = A2_tfrt %99, killed %0; // will be rewritten as; // %3 = A2_port %99, %1, %2; //; // This replacement has two variants: ""up"" and ""down"". Consider this case:; // %0 = A2_or %1, %2; // ... [intervening instructions] ...; // %3 = A2_tfrt %99, killed %0; // variant ""up"":; // %3 = A2_port %99, %1, %2; // ... [intervening instructions, %0->vreg3] ...; // [deleted]; // variant ""down"":; // [deleted]; // ... [intervening instructions] ...; // %3 = A2_port %99, %1, %2; //; // Both, one or none of these variants may be valid, and checks are made; // to rule out inapplicable variants.; //; // As an additional optimization, before either of the two steps above is; // executed, the pass attempts to coalesce the target register with one of; // the source registers, e.g. given an instruction; // %3 = C2_mux %0, %1, %2; // %3 will be coalesced with either %1 or %2. If this succeeds,; // the instruction would then be (for example); // %3 = C2_mux %0, %3, %2; // and, under certain circumstances, this could result in only one predicated; // instruction:; // %3 = A2_tfrf %0, %2; //; // Splitting a definition of a register into two predicated transfers; // creates a complication in liveness tracking. Live interval computation; // will see both instructions as actual definitions, and will mark the; // first one as dead. The definition is not actually dead, and this; // situ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:3429,Deployability,update,updated,3429,"hese variants may be valid, and checks are made; // to rule out inapplicable variants.; //; // As an additional optimization, before either of the two steps above is; // executed, the pass attempts to coalesce the target register with one of; // the source registers, e.g. given an instruction; // %3 = C2_mux %0, %1, %2; // %3 will be coalesced with either %1 or %2. If this succeeds,; // the instruction would then be (for example); // %3 = C2_mux %0, %3, %2; // and, under certain circumstances, this could result in only one predicated; // instruction:; // %3 = A2_tfrf %0, %2; //; // Splitting a definition of a register into two predicated transfers; // creates a complication in liveness tracking. Live interval computation; // will see both instructions as actual definitions, and will mark the; // first one as dead. The definition is not actually dead, and this; // situation will need to be fixed. For example:; // dead %1 = A2_tfrt ... ; marked as dead; // %1 = A2_tfrf ...; //; // Since any of the individual predicated transfers may end up getting; // removed (in case it is an identity copy), some pre-existing def may; // be marked as dead after live interval recomputation:; // dead %1 = ... ; marked as dead; // ...; // %1 = A2_tfrf ... ; if A2_tfrt is removed; // This case happens if %1 was used as a source in A2_tfrt, which means; // that is it actually live at the A2_tfrf, and so the now dead definition; // of %1 will need to be updated to non-dead at some point.; //; // This issue could be remedied by adding implicit uses to the predicated; // transfers, but this will create a problem with subsequent predication,; // since the transfers will no longer be possible to reorder. To avoid; // that, the initial splitting will not add any implicit uses. These; // implicit uses will be added later, after predication. The extra price,; // however, is that finding the locations where the implicit uses need; // to be added, and updating the live ranges will be more involved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:598,Energy Efficiency,schedul,scheduler,598,"//===- HexagonExpandCondsets.cpp ------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Replace mux instructions with the corresponding legal instructions.; // It is meant to work post-SSA, but still on virtual registers. It was; // originally placed between register coalescing and machine instruction; // scheduler.; // In this place in the optimization sequence, live interval analysis had; // been performed, and the live intervals should be preserved. A large part; // of the code deals with preserving the liveness information.; //; // Liveness tracking aside, the main functionality of this pass is divided; // into two steps. The first step is to replace an instruction; // %0 = C2_mux %1, %2, %3; // with a pair of conditional transfers; // %0 = A2_tfrt %1, %2; // %0 = A2_tfrf %1, %3; // It is the intention that the execution of this pass could be terminated; // after this step, and the code generated would be functionally correct.; //; // If the uses of the source values %1 and %2 are kills, and their; // definitions are predicable, then in the second step, the conditional; // transfers will then be rewritten as predicated instructions. E.g.; // %0 = A2_or %1, %2; // %3 = A2_tfrt %99, killed %0; // will be rewritten as; // %3 = A2_port %99, %1, %2; //; // This replacement has two variants: ""up"" and ""down"". Consider this case:; // %0 = A2_or %1, %2; // ... [intervening instructions] ...; // %3 = A2_tfrt %99, killed %0; // variant ""up"":; // %3 = A2_port %99, %1, %2; // ... [intervening instructions, %0->vreg3] ...; // [deleted]; // variant ""down"":; // [deleted]; // ... [intervening instructions] ...; // %3 = A2_port %99, %1, %2; //; // Both, one or none of these variants may be valid",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:634,Performance,optimiz,optimization,634,"//===- HexagonExpandCondsets.cpp ------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Replace mux instructions with the corresponding legal instructions.; // It is meant to work post-SSA, but still on virtual registers. It was; // originally placed between register coalescing and machine instruction; // scheduler.; // In this place in the optimization sequence, live interval analysis had; // been performed, and the live intervals should be preserved. A large part; // of the code deals with preserving the liveness information.; //; // Liveness tracking aside, the main functionality of this pass is divided; // into two steps. The first step is to replace an instruction; // %0 = C2_mux %1, %2, %3; // with a pair of conditional transfers; // %0 = A2_tfrt %1, %2; // %0 = A2_tfrf %1, %3; // It is the intention that the execution of this pass could be terminated; // after this step, and the code generated would be functionally correct.; //; // If the uses of the source values %1 and %2 are kills, and their; // definitions are predicable, then in the second step, the conditional; // transfers will then be rewritten as predicated instructions. E.g.; // %0 = A2_or %1, %2; // %3 = A2_tfrt %99, killed %0; // will be rewritten as; // %3 = A2_port %99, %1, %2; //; // This replacement has two variants: ""up"" and ""down"". Consider this case:; // %0 = A2_or %1, %2; // ... [intervening instructions] ...; // %3 = A2_tfrt %99, killed %0; // variant ""up"":; // %3 = A2_port %99, %1, %2; // ... [intervening instructions, %0->vreg3] ...; // [deleted]; // variant ""down"":; // [deleted]; // ... [intervening instructions] ...; // %3 = A2_port %99, %1, %2; //; // Both, one or none of these variants may be valid",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:693,Performance,perform,performed,693,"//===- HexagonExpandCondsets.cpp ------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Replace mux instructions with the corresponding legal instructions.; // It is meant to work post-SSA, but still on virtual registers. It was; // originally placed between register coalescing and machine instruction; // scheduler.; // In this place in the optimization sequence, live interval analysis had; // been performed, and the live intervals should be preserved. A large part; // of the code deals with preserving the liveness information.; //; // Liveness tracking aside, the main functionality of this pass is divided; // into two steps. The first step is to replace an instruction; // %0 = C2_mux %1, %2, %3; // with a pair of conditional transfers; // %0 = A2_tfrt %1, %2; // %0 = A2_tfrf %1, %3; // It is the intention that the execution of this pass could be terminated; // after this step, and the code generated would be functionally correct.; //; // If the uses of the source values %1 and %2 are kills, and their; // definitions are predicable, then in the second step, the conditional; // transfers will then be rewritten as predicated instructions. E.g.; // %0 = A2_or %1, %2; // %3 = A2_tfrt %99, killed %0; // will be rewritten as; // %3 = A2_port %99, %1, %2; //; // This replacement has two variants: ""up"" and ""down"". Consider this case:; // %0 = A2_or %1, %2; // ... [intervening instructions] ...; // %3 = A2_tfrt %99, killed %0; // variant ""up"":; // %3 = A2_port %99, %1, %2; // ... [intervening instructions, %0->vreg3] ...; // [deleted]; // variant ""down"":; // [deleted]; // ... [intervening instructions] ...; // %3 = A2_port %99, %1, %2; //; // Both, one or none of these variants may be valid",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:2087,Performance,optimiz,optimization,2087,"minated; // after this step, and the code generated would be functionally correct.; //; // If the uses of the source values %1 and %2 are kills, and their; // definitions are predicable, then in the second step, the conditional; // transfers will then be rewritten as predicated instructions. E.g.; // %0 = A2_or %1, %2; // %3 = A2_tfrt %99, killed %0; // will be rewritten as; // %3 = A2_port %99, %1, %2; //; // This replacement has two variants: ""up"" and ""down"". Consider this case:; // %0 = A2_or %1, %2; // ... [intervening instructions] ...; // %3 = A2_tfrt %99, killed %0; // variant ""up"":; // %3 = A2_port %99, %1, %2; // ... [intervening instructions, %0->vreg3] ...; // [deleted]; // variant ""down"":; // [deleted]; // ... [intervening instructions] ...; // %3 = A2_port %99, %1, %2; //; // Both, one or none of these variants may be valid, and checks are made; // to rule out inapplicable variants.; //; // As an additional optimization, before either of the two steps above is; // executed, the pass attempts to coalesce the target register with one of; // the source registers, e.g. given an instruction; // %3 = C2_mux %0, %1, %2; // %3 will be coalesced with either %1 or %2. If this succeeds,; // the instruction would then be (for example); // %3 = C2_mux %0, %3, %2; // and, under certain circumstances, this could result in only one predicated; // instruction:; // %3 = A2_tfrf %0, %2; //; // Splitting a definition of a register into two predicated transfers; // creates a complication in liveness tracking. Live interval computation; // will see both instructions as actual definitions, and will mark the; // first one as dead. The definition is not actually dead, and this; // situation will need to be fixed. For example:; // dead %1 = A2_tfrt ... ; marked as dead; // %1 = A2_tfrf ...; //; // Since any of the individual predicated transfers may end up getting; // removed (in case it is an identity copy), some pre-existing def may; // be marked as dead after live interval re",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:3684,Safety,avoid,avoid,3684,"hese variants may be valid, and checks are made; // to rule out inapplicable variants.; //; // As an additional optimization, before either of the two steps above is; // executed, the pass attempts to coalesce the target register with one of; // the source registers, e.g. given an instruction; // %3 = C2_mux %0, %1, %2; // %3 will be coalesced with either %1 or %2. If this succeeds,; // the instruction would then be (for example); // %3 = C2_mux %0, %3, %2; // and, under certain circumstances, this could result in only one predicated; // instruction:; // %3 = A2_tfrf %0, %2; //; // Splitting a definition of a register into two predicated transfers; // creates a complication in liveness tracking. Live interval computation; // will see both instructions as actual definitions, and will mark the; // first one as dead. The definition is not actually dead, and this; // situation will need to be fixed. For example:; // dead %1 = A2_tfrt ... ; marked as dead; // %1 = A2_tfrf ...; //; // Since any of the individual predicated transfers may end up getting; // removed (in case it is an identity copy), some pre-existing def may; // be marked as dead after live interval recomputation:; // dead %1 = ... ; marked as dead; // ...; // %1 = A2_tfrf ... ; if A2_tfrt is removed; // This case happens if %1 was used as a source in A2_tfrt, which means; // that is it actually live at the A2_tfrf, and so the now dead definition; // of %1 will need to be updated to non-dead at some point.; //; // This issue could be remedied by adding implicit uses to the predicated; // transfers, but this will create a problem with subsequent predication,; // since the transfers will no longer be possible to reorder. To avoid; // that, the initial splitting will not add any implicit uses. These; // implicit uses will be added later, after predication. The extra price,; // however, is that finding the locations where the implicit uses need; // to be added, and updating the live ranges will be more involved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:50,Availability,mask,mask,50,// Set the <kill> flag on a use of Reg whose lane mask is contained in LM.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:17,Modifiability,extend,extend,17,"// First, try to extend live range within individual basic blocks. This; // will leave us only with dead defs that do not reach any predicated; // defs in the same block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:433,Modifiability,extend,extendToIndices,433,"// If the defs from this range reach SI via all predecessors, it is live.; // It can happen that SI is reached by the defs through some paths, but; // not all. In the IR coming into this optimization, SI would not be; // considered live, since the defs would then not jointly dominate SI.; // That means that SI is an overwriting def, and no implicit use is; // needed at this point. Do not add SI to the extension points, since; // extendToIndices will abort if there is no joint dominance.; // If the abort was avoided by adding extra undefs added to Undefs,; // extendToIndices could actually indicate that SI is live, contrary; // to the original IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:565,Modifiability,extend,extendToIndices,565,"// If the defs from this range reach SI via all predecessors, it is live.; // It can happen that SI is reached by the defs through some paths, but; // not all. In the IR coming into this optimization, SI would not be; // considered live, since the defs would then not jointly dominate SI.; // That means that SI is an overwriting def, and no implicit use is; // needed at this point. Do not add SI to the extension points, since; // extendToIndices will abort if there is no joint dominance.; // If the abort was avoided by adding extra undefs added to Undefs,; // extendToIndices could actually indicate that SI is live, contrary; // to the original IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:187,Performance,optimiz,optimization,187,"// If the defs from this range reach SI via all predecessors, it is live.; // It can happen that SI is reached by the defs through some paths, but; // not all. In the IR coming into this optimization, SI would not be; // considered live, since the defs would then not jointly dominate SI.; // That means that SI is an overwriting def, and no implicit use is; // needed at this point. Do not add SI to the extension points, since; // extendToIndices will abort if there is no joint dominance.; // If the abort was avoided by adding extra undefs added to Undefs,; // extendToIndices could actually indicate that SI is live, contrary; // to the original IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:454,Safety,abort,abort,454,"// If the defs from this range reach SI via all predecessors, it is live.; // It can happen that SI is reached by the defs through some paths, but; // not all. In the IR coming into this optimization, SI would not be; // considered live, since the defs would then not jointly dominate SI.; // That means that SI is an overwriting def, and no implicit use is; // needed at this point. Do not add SI to the extension points, since; // extendToIndices will abort if there is no joint dominance.; // If the abort was avoided by adding extra undefs added to Undefs,; // extendToIndices could actually indicate that SI is live, contrary; // to the original IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:503,Safety,abort,abort,503,"// If the defs from this range reach SI via all predecessors, it is live.; // It can happen that SI is reached by the defs through some paths, but; // not all. In the IR coming into this optimization, SI would not be; // considered live, since the defs would then not jointly dominate SI.; // That means that SI is an overwriting def, and no implicit use is; // needed at this point. Do not add SI to the extension points, since; // extendToIndices will abort if there is no joint dominance.; // If the abort was avoided by adding extra undefs added to Undefs,; // extendToIndices could actually indicate that SI is live, contrary; // to the original IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:513,Safety,avoid,avoided,513,"// If the defs from this range reach SI via all predecessors, it is live.; // It can happen that SI is reached by the defs through some paths, but; // not all. In the IR coming into this optimization, SI would not be; // considered live, since the defs would then not jointly dominate SI.; // That means that SI is an overwriting def, and no implicit use is; // needed at this point. Do not add SI to the extension points, since; // extendToIndices will abort if there is no joint dominance.; // If the abort was avoided by adding extra undefs added to Undefs,; // extendToIndices could actually indicate that SI is live, contrary; // to the original IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:77,Availability,mask,masks,77,"// This function can be called for the same register with different; // lane masks. If the def in this instruction was for the whole; // register, we can get here more than once. Avoid adding multiple; // implicit uses (or adding an implicit use when an explicit one is; // present).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:179,Safety,Avoid,Avoid,179,"// This function can be called for the same register with different; // lane masks. If the def in this instruction was for the whole; // register, we can get here more than once. Avoid adding multiple; // implicit uses (or adding an implicit use when an explicit one is; // present).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:27,Modifiability,extend,extend,27,"// Fixing <dead> flags may extend live ranges, so reset <kill> flags; // after that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:9,Safety,avoid,avoid,9,"// Don't avoid identity copies here (i.e. if the source and the destination; // are the same registers). It is actually better to generate them here,; // since this would cause the copy to potentially be predicated in the next; // step. The predication will remove such a copy if it is unable to; /// predicate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:81,Performance,perform,performs,81,/// Replace a MUX instruction MI with a pair A2_tfrt/A2_tfrf. This function; /// performs all necessary changes to complete the replacement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:16,Deployability,update,update,16,// Copy regs to update first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:63,Performance,load,loads,63,// Reject instructions with multiple defs (e.g. post-increment loads).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:110,Integrability,depend,depending,110,"// Check the defs. If the PredR is defined, invalidate it. If RD is; // defined, return the instruction or 0, depending on the circumstances.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:245,Integrability,depend,depend,245,/// Check if the instruction MI can be safely moved over a set of instructions; /// whose side-effects (in terms of register defs and uses) are expressed in; /// the maps Defs and Uses. These maps reflect the conditional defs and uses; /// that depend on the same predicate register to allow moving instructions; /// over instructions predicated on the opposite condition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:39,Safety,safe,safely,39,/// Check if the instruction MI can be safely moved over a set of instructions; /// whose side-effects (in terms of register defs and uses) are expressed in; /// the maps Defs and Uses. These maps reflect the conditional defs and uses; /// that depend on the same predicate register to allow moving instructions; /// over instructions predicated on the opposite condition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:26,Safety,safe,safely,26,"// In order to be able to safely move MI over instructions that define; // ""Defs"" and use ""Uses"", no def operand from MI can be defined or used; // and no use operand can be defined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:29,Security,access,accessing,29,/// Check if the instruction accessing memory (TheI) can be moved to the; /// location ToI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:614,Deployability,update,update,614,"// The problem with updating live intervals is that we can move one def; // past another def. In particular, this can happen when moving an A2_tfrt; // over an A2_tfrf defining the same register. From the point of view of; // live intervals, these two instructions are two separate definitions,; // and each one starts another live segment. LiveIntervals's ""handleMove""; // does not allow such moves, so we need to handle it ourselves. To avoid; // invalidating liveness data while we are using it, the move will be; // implemented in 4 steps: (1) add a clone of the instruction MI at the; // target location, (2) update liveness, (3) delete the old instruction,; // and (4) update liveness again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:675,Deployability,update,update,675,"// The problem with updating live intervals is that we can move one def; // past another def. In particular, this can happen when moving an A2_tfrt; // over an A2_tfrf defining the same register. From the point of view of; // live intervals, these two instructions are two separate definitions,; // and each one starts another live segment. LiveIntervals's ""handleMove""; // does not allow such moves, so we need to handle it ourselves. To avoid; // invalidating liveness data while we are using it, the move will be; // implemented in 4 steps: (1) add a clone of the instruction MI at the; // target location, (2) update liveness, (3) delete the old instruction,; // and (4) update liveness again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:439,Safety,avoid,avoid,439,"// The problem with updating live intervals is that we can move one def; // past another def. In particular, this can happen when moving an A2_tfrt; // over an A2_tfrf defining the same register. From the point of view of; // live intervals, these two instructions are two separate definitions,; // and each one starts another live segment. LiveIntervals's ""handleMove""; // does not allow such moves, so we need to handle it ourselves. To avoid; // invalidating liveness data while we are using it, the move will be; // implemented in 4 steps: (1) add a clone of the instruction MI at the; // target location, (2) update liveness, (3) delete the old instruction,; // and (4) update liveness again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:104,Usability,simpl,simpler,104,"// The source operand should be a <kill>. This is not strictly necessary,; // but it makes things a lot simpler. Otherwise, we would need to rename; // some registers, which would complicate the transformation considerably.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:3,Safety,Avoid,Avoid,3,// Avoid predicating instructions that define a subregister if subregister; // liveness tracking is not enabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:393,Availability,down,down,393,"// The situation:; // RT = DefI; // ...; // RD = TfrI ..., RT; // If the register-in-the-middle (RT) is used or redefined between; // DefI and TfrI, we may not be able proceed with this transformation.; // We can ignore a def that will not execute together with TfrI, and a; // use that will. If there is such a use (that does execute together with; // TfrI), we will not be able to move DefI down. If there is a use that; // executed if TfrI's condition is false, then RT must be available; // unconditionally (cannot be predicated).; // Essentially, we need to be able to rename RT to RD in this segment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:481,Availability,avail,available,481,"// The situation:; // RT = DefI; // ...; // RD = TfrI ..., RT; // If the register-in-the-middle (RT) is used or redefined between; // DefI and TfrI, we may not be able proceed with this transformation.; // We can ignore a def that will not execute together with TfrI, and a; // use that will. If there is such a use (that does execute together with; // TfrI), we will not be able to move DefI down. If there is a use that; // executed if TfrI's condition is false, then RT must be available; // unconditionally (cannot be predicated).; // Essentially, we need to be able to rename RT to RD in this segment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:124,Availability,down,down,124,"// If the predicate register is defined between DefI and TfrI, the only; // potential thing to do would be to move the DefI down to TfrI, and then; // predicate. The reaching def (DefI) must be movable down to the location; // of the TfrI.; // If the target register of the TfrI (RD) is not used or defined between; // DefI and TfrI, consider moving TfrI up to DefI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:202,Availability,down,down,202,"// If the predicate register is defined between DefI and TfrI, the only; // potential thing to do would be to move the DefI down to TfrI, and then; // predicate. The reaching def (DefI) must be movable down to the location; // of the TfrI.; // If the target register of the TfrI (RD) is not used or defined between; // DefI and TfrI, consider moving TfrI up to DefI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:88,Availability,down,down,88,"// The TfrI does not access memory, but DefI could. Check if it's safe; // to move DefI down to TfrI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:66,Safety,safe,safe,66,"// The TfrI does not access memory, but DefI could. Check if it's safe; // to move DefI down to TfrI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:21,Security,access,access,21,"// The TfrI does not access memory, but DefI could. Check if it's safe; // to move DefI down to TfrI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:46,Energy Efficiency,schedul,scheduling,46,"// Coalescing could have a negative impact on scheduling, so try to limit; // to some reasonable extent. Only consider coalescing segments, when one; // of them does not cross basic block boundaries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:422,Integrability,depend,dependency,422,"// Consider this case:; // %1 = instr1 ...; // %2 = instr2 ...; // %0 = C2_mux ..., %1, %2; // If %0 was coalesced with %1, we could end up with the following; // code:; // %0 = instr1 ...; // %2 = instr2 ...; // %0 = A2_tfrf ..., %2; // which will later become:; // %0 = instr1 ...; // %0 = instr2_cNotPt ...; // i.e. there will be an unconditional definition (instr1) of %0; // followed by a conditional one. The output dependency was there before; // and it unavoidable, but if instr1 is predicable, we will no longer be; // able to predicate it here.; // To avoid this scenario, don't coalesce the destination register with; // a source register that is defined by a predicable instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:562,Safety,avoid,avoid,562,"// Consider this case:; // %1 = instr1 ...; // %2 = instr2 ...; // %0 = C2_mux ..., %1, %2; // If %0 was coalesced with %1, we could end up with the following; // code:; // %0 = instr1 ...; // %2 = instr2 ...; // %0 = A2_tfrf ..., %2; // which will later become:; // %0 = instr1 ...; // %0 = instr2_cNotPt ...; // i.e. there will be an unconditional definition (instr1) of %0; // followed by a conditional one. The output dependency was there before; // and it unavoidable, but if instr1 is predicable, we will no longer be; // able to predicate it here.; // To avoid this scenario, don't coalesce the destination register with; // a source register that is defined by a predicable instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:3,Deployability,Update,Update,3,"// Update kill flags on all source operands. This is done here because; // at this moment (when expand-condsets runs), there are no kill flags; // in the IR (they have been removed by live range analysis).; // Updating them right before we split is the easiest, because splitting; // adds definitions which would interfere with updating kills afterwards.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:78,Deployability,update,update,78,"// First, simply split all muxes into a pair of conditional transfers; // and update the live intervals to reflect the new arrangement. The; // goal is to update the kill flags, since predication will rely on; // them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:155,Deployability,update,update,155,"// First, simply split all muxes into a pair of conditional transfers; // and update the live intervals to reflect the new arrangement. The; // goal is to update the kill flags, since predication will rely on; // them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:10,Usability,simpl,simply,10,"// First, simply split all muxes into a pair of conditional transfers; // and update the live intervals to reflect the new arrangement. The; // goal is to update the kill flags, since predication will rely on; // them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:64,Deployability,update,update,64,"// The contents of Condsets are invalid here anyway.; // Do not update live ranges after splitting. Recalculation of live; // intervals removes kill flags, which were preserved by splitting on; // the source operands of condsets. These kill flags are needed by; // predication, and after splitting they are difficult to recalculate; // (because of predicated defs), so make sure they are left untouched.; // Predication does not use live intervals.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFixupHwLoops.cpp:513,Modifiability,extend,extender,513,"//===---- HexagonFixupHwLoops.cpp - Fixup HW loops too far from LOOPn. ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; // The loop start address in the LOOPn instruction is encoded as a distance; // from the LOOPn instruction itself. If the start address is too far from; // the LOOPn instruction, the instruction needs to use a constant extender.; // This pass will identify and convert such LOOPn instructions to a proper; // form.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFixupHwLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFixupHwLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFixupHwLoops.cpp:47,Modifiability,extend,extended,47,/// Replace loop instruction with the constant extended; /// version if the loop label is too far from the loop instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFixupHwLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFixupHwLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFixupHwLoops.cpp:48,Modifiability,extend,extended,48,/// Replace loop instructions with the constant extended version.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFixupHwLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFixupHwLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:2906,Availability,avail,available,2906,"p"", where ""p"" is the smallest pad; // that aligns AP to the required boundary (a maximum of the alignments of; // all stack objects, fixed- and variable-sized). All local objects[1] will; // then use AP as the base pointer.; // [1] The exception is with ""fixed"" stack objects. ""Fixed"" stack objects get; // their name from being allocated at fixed locations on the stack, relative; // to the FP. In the presence of dynamic allocation and local alignment, such; // objects can only be accessed through the FP.; //; // Illustration of the AP:; // FP --+; // |; // ---------------+---------------------+-----+-----------------------++-+--; // Rest of the | Local stack objects | Pad | Fixed stack objects |LR|; // stack frame | (aligned) | | (CSR, spills, etc.) |FP|; // ---------------+---------------------+-----+-----------------+-----+--+--; // |<-- Multiple of the -->|; // stack alignment +-- AP; //; // The AP is set up at the beginning of the function. Since it is not a dedi-; // cated (reserved) register, it needs to be kept live throughout the function; // to be available as the base register for local object accesses.; // Normally, an address of a stack objects is obtained by a pseudo-instruction; // PS_fi. To access local objects with the AP register present, a different; // pseudo-instruction needs to be used: PS_fia. The PS_fia takes one extra; // argument compared to PS_fi: the first input register is the AP register.; // This keeps the register live between its definition and its uses.; // The AP register is originally set up using pseudo-instruction PS_aligna:; // AP = PS_aligna A; // where; // A - required stack alignment; // The alignment value must be the maximum of all alignments required by; // any stack object.; // The dynamic allocation uses a pseudo-instruction PS_alloca:; // Rd = PS_alloca Rs, A; // where; // Rd - address of the allocated space; // Rs - minimum size (the actual allocated can be larger to accommodate; // alignment); // A - required alignment",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:1292,Energy Efficiency,allocate,allocated,1292,"--------------+-----------------++-+-------; // | parameter area for | variable-size | fixed-size |LR| arg; // | called functions | local objects | local objects |FP|; // --+----------------------+------------------+-----------------+--+-------; // <- size known -> <- size unknown -> <- size known ->; //; // Low address High address; //; // <--- stack growth; //; //; // - In any circumstances, the outgoing function arguments are always accessi-; // ble using the SP, and the incoming arguments are accessible using the FP.; // - If the local objects are not aligned, they can always be accessed using; // the FP.; // - If there are no variable-sized objects, the local objects can always be; // accessed using the SP, regardless whether they are aligned or not. (The; // alignment padding will be at the bottom of the stack (highest address),; // and so the offset with respect to the SP will be known at the compile-; // -time.); //; // The only complication occurs if there are both, local aligned objects, and; // dynamically allocated (variable-sized) objects. The alignment pad will be; // placed between the FP and the local objects, thus preventing the use of the; // FP to access the local objects. At the same time, the variable-sized objects; // will be between the SP and the local objects, thus introducing an unknown; // distance from the SP to the locals.; //; // To avoid this problem, a new register is created that holds the aligned; // address of the bottom of the stack, referred in the sources as AP (aligned; // pointer). The AP will be equal to ""FP-p"", where ""p"" is the smallest pad; // that aligns AP to the required boundary (a maximum of the alignments of; // all stack objects, fixed- and variable-sized). All local objects[1] will; // then use AP as the base pointer.; // [1] The exception is with ""fixed"" stack objects. ""Fixed"" stack objects get; // their name from being allocated at fixed locations on the stack, relative; // to the FP. In the presence of dynamic al",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:2163,Energy Efficiency,allocate,allocated,2163,"he compile-; // -time.); //; // The only complication occurs if there are both, local aligned objects, and; // dynamically allocated (variable-sized) objects. The alignment pad will be; // placed between the FP and the local objects, thus preventing the use of the; // FP to access the local objects. At the same time, the variable-sized objects; // will be between the SP and the local objects, thus introducing an unknown; // distance from the SP to the locals.; //; // To avoid this problem, a new register is created that holds the aligned; // address of the bottom of the stack, referred in the sources as AP (aligned; // pointer). The AP will be equal to ""FP-p"", where ""p"" is the smallest pad; // that aligns AP to the required boundary (a maximum of the alignments of; // all stack objects, fixed- and variable-sized). All local objects[1] will; // then use AP as the base pointer.; // [1] The exception is with ""fixed"" stack objects. ""Fixed"" stack objects get; // their name from being allocated at fixed locations on the stack, relative; // to the FP. In the presence of dynamic allocation and local alignment, such; // objects can only be accessed through the FP.; //; // Illustration of the AP:; // FP --+; // |; // ---------------+---------------------+-----+-----------------------++-+--; // Rest of the | Local stack objects | Pad | Fixed stack objects |LR|; // stack frame | (aligned) | | (CSR, spills, etc.) |FP|; // ---------------+---------------------+-----+-----------------+-----+--+--; // |<-- Multiple of the -->|; // stack alignment +-- AP; //; // The AP is set up at the beginning of the function. Since it is not a dedi-; // cated (reserved) register, it needs to be kept live throughout the function; // to be available as the base register for local object accesses.; // Normally, an address of a stack objects is obtained by a pseudo-instruction; // PS_fi. To access local objects with the AP register present, a different; // pseudo-instruction needs to be used: PS_fia. ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:3704,Energy Efficiency,allocate,allocated,3704,"p"", where ""p"" is the smallest pad; // that aligns AP to the required boundary (a maximum of the alignments of; // all stack objects, fixed- and variable-sized). All local objects[1] will; // then use AP as the base pointer.; // [1] The exception is with ""fixed"" stack objects. ""Fixed"" stack objects get; // their name from being allocated at fixed locations on the stack, relative; // to the FP. In the presence of dynamic allocation and local alignment, such; // objects can only be accessed through the FP.; //; // Illustration of the AP:; // FP --+; // |; // ---------------+---------------------+-----+-----------------------++-+--; // Rest of the | Local stack objects | Pad | Fixed stack objects |LR|; // stack frame | (aligned) | | (CSR, spills, etc.) |FP|; // ---------------+---------------------+-----+-----------------+-----+--+--; // |<-- Multiple of the -->|; // stack alignment +-- AP; //; // The AP is set up at the beginning of the function. Since it is not a dedi-; // cated (reserved) register, it needs to be kept live throughout the function; // to be available as the base register for local object accesses.; // Normally, an address of a stack objects is obtained by a pseudo-instruction; // PS_fi. To access local objects with the AP register present, a different; // pseudo-instruction needs to be used: PS_fia. The PS_fia takes one extra; // argument compared to PS_fi: the first input register is the AP register.; // This keeps the register live between its definition and its uses.; // The AP register is originally set up using pseudo-instruction PS_aligna:; // AP = PS_aligna A; // where; // A - required stack alignment; // The alignment value must be the maximum of all alignments required by; // any stack object.; // The dynamic allocation uses a pseudo-instruction PS_alloca:; // Rd = PS_alloca Rs, A; // where; // Rd - address of the allocated space; // Rs - minimum size (the actual allocated can be larger to accommodate; // alignment); // A - required alignment",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:3754,Energy Efficiency,allocate,allocated,3754,"p"", where ""p"" is the smallest pad; // that aligns AP to the required boundary (a maximum of the alignments of; // all stack objects, fixed- and variable-sized). All local objects[1] will; // then use AP as the base pointer.; // [1] The exception is with ""fixed"" stack objects. ""Fixed"" stack objects get; // their name from being allocated at fixed locations on the stack, relative; // to the FP. In the presence of dynamic allocation and local alignment, such; // objects can only be accessed through the FP.; //; // Illustration of the AP:; // FP --+; // |; // ---------------+---------------------+-----+-----------------------++-+--; // Rest of the | Local stack objects | Pad | Fixed stack objects |LR|; // stack frame | (aligned) | | (CSR, spills, etc.) |FP|; // ---------------+---------------------+-----+-----------------+-----+--+--; // |<-- Multiple of the -->|; // stack alignment +-- AP; //; // The AP is set up at the beginning of the function. Since it is not a dedi-; // cated (reserved) register, it needs to be kept live throughout the function; // to be available as the base register for local object accesses.; // Normally, an address of a stack objects is obtained by a pseudo-instruction; // PS_fi. To access local objects with the AP register present, a different; // pseudo-instruction needs to be used: PS_fia. The PS_fia takes one extra; // argument compared to PS_fi: the first input register is the AP register.; // This keeps the register live between its definition and its uses.; // The AP register is originally set up using pseudo-instruction PS_aligna:; // AP = PS_aligna A; // where; // A - required stack alignment; // The alignment value must be the maximum of all alignments required by; // any stack object.; // The dynamic allocation uses a pseudo-instruction PS_alloca:; // Rd = PS_alloca Rs, A; // where; // Rd - address of the allocated space; // Rs - minimum size (the actual allocated can be larger to accommodate; // alignment); // A - required alignment",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:330,Modifiability,variab,variable-size,330,"// Hexagon stack frame layout as defined by the ABI:; //; // Incoming arguments; // passed via stack; // |; // |; // SP during function's FP during function's |; // +-- runtime (top of stack) runtime (bottom) --+ |; // | | |; // --++---------------------+------------------+-----------------++-+-------; // | parameter area for | variable-size | fixed-size |LR| arg; // | called functions | local objects | local objects |FP|; // --+----------------------+------------------+-----------------+--+-------; // <- size known -> <- size unknown -> <- size known ->; //; // Low address High address; //; // <--- stack growth; //; //; // - In any circumstances, the outgoing function arguments are always accessi-; // ble using the SP, and the incoming arguments are accessible using the FP.; // - If the local objects are not aligned, they can always be accessed using; // the FP.; // - If there are no variable-sized objects, the local objects can always be; // accessed using the SP, regardless whether they are aligned or not. (The; // alignment padding will be at the bottom of the stack (highest address),; // and so the offset with respect to the SP will be known at the compile-; // -time.); //; // The only complication occurs if there are both, local aligned objects, and; // dynamically allocated (variable-sized) objects. The alignment pad will be; // placed between the FP and the local objects, thus preventing the use of the; // FP to access the local objects. At the same time, the variable-sized objects; // will be between the SP and the local objects, thus introducing an unknown; // distance from the SP to the locals.; //; // To avoid this problem, a new register is created that holds the aligned; // address of the bottom of the stack, referred in the sources as AP (aligned; // pointer). The AP will be equal to ""FP-p"", where ""p"" is the smallest pad; // that aligns AP to the required boundary (a maximum of the alignments of; // all stack objects, fixed- and variable-sized). All lo",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:898,Modifiability,variab,variable-sized,898,"// Hexagon stack frame layout as defined by the ABI:; //; // Incoming arguments; // passed via stack; // |; // |; // SP during function's FP during function's |; // +-- runtime (top of stack) runtime (bottom) --+ |; // | | |; // --++---------------------+------------------+-----------------++-+-------; // | parameter area for | variable-size | fixed-size |LR| arg; // | called functions | local objects | local objects |FP|; // --+----------------------+------------------+-----------------+--+-------; // <- size known -> <- size unknown -> <- size known ->; //; // Low address High address; //; // <--- stack growth; //; //; // - In any circumstances, the outgoing function arguments are always accessi-; // ble using the SP, and the incoming arguments are accessible using the FP.; // - If the local objects are not aligned, they can always be accessed using; // the FP.; // - If there are no variable-sized objects, the local objects can always be; // accessed using the SP, regardless whether they are aligned or not. (The; // alignment padding will be at the bottom of the stack (highest address),; // and so the offset with respect to the SP will be known at the compile-; // -time.); //; // The only complication occurs if there are both, local aligned objects, and; // dynamically allocated (variable-sized) objects. The alignment pad will be; // placed between the FP and the local objects, thus preventing the use of the; // FP to access the local objects. At the same time, the variable-sized objects; // will be between the SP and the local objects, thus introducing an unknown; // distance from the SP to the locals.; //; // To avoid this problem, a new register is created that holds the aligned; // address of the bottom of the stack, referred in the sources as AP (aligned; // pointer). The AP will be equal to ""FP-p"", where ""p"" is the smallest pad; // that aligns AP to the required boundary (a maximum of the alignments of; // all stack objects, fixed- and variable-sized). All lo",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:1303,Modifiability,variab,variable-sized,1303,"--------------+-----------------++-+-------; // | parameter area for | variable-size | fixed-size |LR| arg; // | called functions | local objects | local objects |FP|; // --+----------------------+------------------+-----------------+--+-------; // <- size known -> <- size unknown -> <- size known ->; //; // Low address High address; //; // <--- stack growth; //; //; // - In any circumstances, the outgoing function arguments are always accessi-; // ble using the SP, and the incoming arguments are accessible using the FP.; // - If the local objects are not aligned, they can always be accessed using; // the FP.; // - If there are no variable-sized objects, the local objects can always be; // accessed using the SP, regardless whether they are aligned or not. (The; // alignment padding will be at the bottom of the stack (highest address),; // and so the offset with respect to the SP will be known at the compile-; // -time.); //; // The only complication occurs if there are both, local aligned objects, and; // dynamically allocated (variable-sized) objects. The alignment pad will be; // placed between the FP and the local objects, thus preventing the use of the; // FP to access the local objects. At the same time, the variable-sized objects; // will be between the SP and the local objects, thus introducing an unknown; // distance from the SP to the locals.; //; // To avoid this problem, a new register is created that holds the aligned; // address of the bottom of the stack, referred in the sources as AP (aligned; // pointer). The AP will be equal to ""FP-p"", where ""p"" is the smallest pad; // that aligns AP to the required boundary (a maximum of the alignments of; // all stack objects, fixed- and variable-sized). All local objects[1] will; // then use AP as the base pointer.; // [1] The exception is with ""fixed"" stack objects. ""Fixed"" stack objects get; // their name from being allocated at fixed locations on the stack, relative; // to the FP. In the presence of dynamic al",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:1492,Modifiability,variab,variable-sized,1492,"e known ->; //; // Low address High address; //; // <--- stack growth; //; //; // - In any circumstances, the outgoing function arguments are always accessi-; // ble using the SP, and the incoming arguments are accessible using the FP.; // - If the local objects are not aligned, they can always be accessed using; // the FP.; // - If there are no variable-sized objects, the local objects can always be; // accessed using the SP, regardless whether they are aligned or not. (The; // alignment padding will be at the bottom of the stack (highest address),; // and so the offset with respect to the SP will be known at the compile-; // -time.); //; // The only complication occurs if there are both, local aligned objects, and; // dynamically allocated (variable-sized) objects. The alignment pad will be; // placed between the FP and the local objects, thus preventing the use of the; // FP to access the local objects. At the same time, the variable-sized objects; // will be between the SP and the local objects, thus introducing an unknown; // distance from the SP to the locals.; //; // To avoid this problem, a new register is created that holds the aligned; // address of the bottom of the stack, referred in the sources as AP (aligned; // pointer). The AP will be equal to ""FP-p"", where ""p"" is the smallest pad; // that aligns AP to the required boundary (a maximum of the alignments of; // all stack objects, fixed- and variable-sized). All local objects[1] will; // then use AP as the base pointer.; // [1] The exception is with ""fixed"" stack objects. ""Fixed"" stack objects get; // their name from being allocated at fixed locations on the stack, relative; // to the FP. In the presence of dynamic allocation and local alignment, such; // objects can only be accessed through the FP.; //; // Illustration of the AP:; // FP --+; // |; // ---------------+---------------------+-----+-----------------------++-+--; // Rest of the | Local stack objects | Pad | Fixed stack objects |LR|; // stack ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:1978,Modifiability,variab,variable-sized,1978,"ariable-sized objects, the local objects can always be; // accessed using the SP, regardless whether they are aligned or not. (The; // alignment padding will be at the bottom of the stack (highest address),; // and so the offset with respect to the SP will be known at the compile-; // -time.); //; // The only complication occurs if there are both, local aligned objects, and; // dynamically allocated (variable-sized) objects. The alignment pad will be; // placed between the FP and the local objects, thus preventing the use of the; // FP to access the local objects. At the same time, the variable-sized objects; // will be between the SP and the local objects, thus introducing an unknown; // distance from the SP to the locals.; //; // To avoid this problem, a new register is created that holds the aligned; // address of the bottom of the stack, referred in the sources as AP (aligned; // pointer). The AP will be equal to ""FP-p"", where ""p"" is the smallest pad; // that aligns AP to the required boundary (a maximum of the alignments of; // all stack objects, fixed- and variable-sized). All local objects[1] will; // then use AP as the base pointer.; // [1] The exception is with ""fixed"" stack objects. ""Fixed"" stack objects get; // their name from being allocated at fixed locations on the stack, relative; // to the FP. In the presence of dynamic allocation and local alignment, such; // objects can only be accessed through the FP.; //; // Illustration of the AP:; // FP --+; // |; // ---------------+---------------------+-----+-----------------------++-+--; // Rest of the | Local stack objects | Pad | Fixed stack objects |LR|; // stack frame | (aligned) | | (CSR, spills, etc.) |FP|; // ---------------+---------------------+-----+-----------------+-----+--+--; // |<-- Multiple of the -->|; // stack alignment +-- AP; //; // The AP is set up at the beginning of the function. Since it is not a dedi-; // cated (reserved) register, it needs to be kept live throughout the function; // ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:1644,Safety,avoid,avoid,1644,"ing the SP, and the incoming arguments are accessible using the FP.; // - If the local objects are not aligned, they can always be accessed using; // the FP.; // - If there are no variable-sized objects, the local objects can always be; // accessed using the SP, regardless whether they are aligned or not. (The; // alignment padding will be at the bottom of the stack (highest address),; // and so the offset with respect to the SP will be known at the compile-; // -time.); //; // The only complication occurs if there are both, local aligned objects, and; // dynamically allocated (variable-sized) objects. The alignment pad will be; // placed between the FP and the local objects, thus preventing the use of the; // FP to access the local objects. At the same time, the variable-sized objects; // will be between the SP and the local objects, thus introducing an unknown; // distance from the SP to the locals.; //; // To avoid this problem, a new register is created that holds the aligned; // address of the bottom of the stack, referred in the sources as AP (aligned; // pointer). The AP will be equal to ""FP-p"", where ""p"" is the smallest pad; // that aligns AP to the required boundary (a maximum of the alignments of; // all stack objects, fixed- and variable-sized). All local objects[1] will; // then use AP as the base pointer.; // [1] The exception is with ""fixed"" stack objects. ""Fixed"" stack objects get; // their name from being allocated at fixed locations on the stack, relative; // to the FP. In the presence of dynamic allocation and local alignment, such; // objects can only be accessed through the FP.; //; // Illustration of the AP:; // FP --+; // |; // ---------------+---------------------+-----+-----------------------++-+--; // Rest of the | Local stack objects | Pad | Fixed stack objects |LR|; // stack frame | (aligned) | | (CSR, spills, etc.) |FP|; // ---------------+---------------------+-----+-----------------+-----+--+--; // |<-- Multiple of the -->|; // stack ali",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:699,Security,access,accessi,699,"// Hexagon stack frame layout as defined by the ABI:; //; // Incoming arguments; // passed via stack; // |; // |; // SP during function's FP during function's |; // +-- runtime (top of stack) runtime (bottom) --+ |; // | | |; // --++---------------------+------------------+-----------------++-+-------; // | parameter area for | variable-size | fixed-size |LR| arg; // | called functions | local objects | local objects |FP|; // --+----------------------+------------------+-----------------+--+-------; // <- size known -> <- size unknown -> <- size known ->; //; // Low address High address; //; // <--- stack growth; //; //; // - In any circumstances, the outgoing function arguments are always accessi-; // ble using the SP, and the incoming arguments are accessible using the FP.; // - If the local objects are not aligned, they can always be accessed using; // the FP.; // - If there are no variable-sized objects, the local objects can always be; // accessed using the SP, regardless whether they are aligned or not. (The; // alignment padding will be at the bottom of the stack (highest address),; // and so the offset with respect to the SP will be known at the compile-; // -time.); //; // The only complication occurs if there are both, local aligned objects, and; // dynamically allocated (variable-sized) objects. The alignment pad will be; // placed between the FP and the local objects, thus preventing the use of the; // FP to access the local objects. At the same time, the variable-sized objects; // will be between the SP and the local objects, thus introducing an unknown; // distance from the SP to the locals.; //; // To avoid this problem, a new register is created that holds the aligned; // address of the bottom of the stack, referred in the sources as AP (aligned; // pointer). The AP will be equal to ""FP-p"", where ""p"" is the smallest pad; // that aligns AP to the required boundary (a maximum of the alignments of; // all stack objects, fixed- and variable-sized). All lo",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:761,Security,access,accessible,761,"// Hexagon stack frame layout as defined by the ABI:; //; // Incoming arguments; // passed via stack; // |; // |; // SP during function's FP during function's |; // +-- runtime (top of stack) runtime (bottom) --+ |; // | | |; // --++---------------------+------------------+-----------------++-+-------; // | parameter area for | variable-size | fixed-size |LR| arg; // | called functions | local objects | local objects |FP|; // --+----------------------+------------------+-----------------+--+-------; // <- size known -> <- size unknown -> <- size known ->; //; // Low address High address; //; // <--- stack growth; //; //; // - In any circumstances, the outgoing function arguments are always accessi-; // ble using the SP, and the incoming arguments are accessible using the FP.; // - If the local objects are not aligned, they can always be accessed using; // the FP.; // - If there are no variable-sized objects, the local objects can always be; // accessed using the SP, regardless whether they are aligned or not. (The; // alignment padding will be at the bottom of the stack (highest address),; // and so the offset with respect to the SP will be known at the compile-; // -time.); //; // The only complication occurs if there are both, local aligned objects, and; // dynamically allocated (variable-sized) objects. The alignment pad will be; // placed between the FP and the local objects, thus preventing the use of the; // FP to access the local objects. At the same time, the variable-sized objects; // will be between the SP and the local objects, thus introducing an unknown; // distance from the SP to the locals.; //; // To avoid this problem, a new register is created that holds the aligned; // address of the bottom of the stack, referred in the sources as AP (aligned; // pointer). The AP will be equal to ""FP-p"", where ""p"" is the smallest pad; // that aligns AP to the required boundary (a maximum of the alignments of; // all stack objects, fixed- and variable-sized). All lo",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:849,Security,access,accessed,849,"// Hexagon stack frame layout as defined by the ABI:; //; // Incoming arguments; // passed via stack; // |; // |; // SP during function's FP during function's |; // +-- runtime (top of stack) runtime (bottom) --+ |; // | | |; // --++---------------------+------------------+-----------------++-+-------; // | parameter area for | variable-size | fixed-size |LR| arg; // | called functions | local objects | local objects |FP|; // --+----------------------+------------------+-----------------+--+-------; // <- size known -> <- size unknown -> <- size known ->; //; // Low address High address; //; // <--- stack growth; //; //; // - In any circumstances, the outgoing function arguments are always accessi-; // ble using the SP, and the incoming arguments are accessible using the FP.; // - If the local objects are not aligned, they can always be accessed using; // the FP.; // - If there are no variable-sized objects, the local objects can always be; // accessed using the SP, regardless whether they are aligned or not. (The; // alignment padding will be at the bottom of the stack (highest address),; // and so the offset with respect to the SP will be known at the compile-; // -time.); //; // The only complication occurs if there are both, local aligned objects, and; // dynamically allocated (variable-sized) objects. The alignment pad will be; // placed between the FP and the local objects, thus preventing the use of the; // FP to access the local objects. At the same time, the variable-sized objects; // will be between the SP and the local objects, thus introducing an unknown; // distance from the SP to the locals.; //; // To avoid this problem, a new register is created that holds the aligned; // address of the bottom of the stack, referred in the sources as AP (aligned; // pointer). The AP will be equal to ""FP-p"", where ""p"" is the smallest pad; // that aligns AP to the required boundary (a maximum of the alignments of; // all stack objects, fixed- and variable-sized). All lo",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:958,Security,access,accessed,958,"// Hexagon stack frame layout as defined by the ABI:; //; // Incoming arguments; // passed via stack; // |; // |; // SP during function's FP during function's |; // +-- runtime (top of stack) runtime (bottom) --+ |; // | | |; // --++---------------------+------------------+-----------------++-+-------; // | parameter area for | variable-size | fixed-size |LR| arg; // | called functions | local objects | local objects |FP|; // --+----------------------+------------------+-----------------+--+-------; // <- size known -> <- size unknown -> <- size known ->; //; // Low address High address; //; // <--- stack growth; //; //; // - In any circumstances, the outgoing function arguments are always accessi-; // ble using the SP, and the incoming arguments are accessible using the FP.; // - If the local objects are not aligned, they can always be accessed using; // the FP.; // - If there are no variable-sized objects, the local objects can always be; // accessed using the SP, regardless whether they are aligned or not. (The; // alignment padding will be at the bottom of the stack (highest address),; // and so the offset with respect to the SP will be known at the compile-; // -time.); //; // The only complication occurs if there are both, local aligned objects, and; // dynamically allocated (variable-sized) objects. The alignment pad will be; // placed between the FP and the local objects, thus preventing the use of the; // FP to access the local objects. At the same time, the variable-sized objects; // will be between the SP and the local objects, thus introducing an unknown; // distance from the SP to the locals.; //; // To avoid this problem, a new register is created that holds the aligned; // address of the bottom of the stack, referred in the sources as AP (aligned; // pointer). The AP will be equal to ""FP-p"", where ""p"" is the smallest pad; // that aligns AP to the required boundary (a maximum of the alignments of; // all stack objects, fixed- and variable-sized). All lo",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:1444,Security,access,access,1444,"bjects | local objects |FP|; // --+----------------------+------------------+-----------------+--+-------; // <- size known -> <- size unknown -> <- size known ->; //; // Low address High address; //; // <--- stack growth; //; //; // - In any circumstances, the outgoing function arguments are always accessi-; // ble using the SP, and the incoming arguments are accessible using the FP.; // - If the local objects are not aligned, they can always be accessed using; // the FP.; // - If there are no variable-sized objects, the local objects can always be; // accessed using the SP, regardless whether they are aligned or not. (The; // alignment padding will be at the bottom of the stack (highest address),; // and so the offset with respect to the SP will be known at the compile-; // -time.); //; // The only complication occurs if there are both, local aligned objects, and; // dynamically allocated (variable-sized) objects. The alignment pad will be; // placed between the FP and the local objects, thus preventing the use of the; // FP to access the local objects. At the same time, the variable-sized objects; // will be between the SP and the local objects, thus introducing an unknown; // distance from the SP to the locals.; //; // To avoid this problem, a new register is created that holds the aligned; // address of the bottom of the stack, referred in the sources as AP (aligned; // pointer). The AP will be equal to ""FP-p"", where ""p"" is the smallest pad; // that aligns AP to the required boundary (a maximum of the alignments of; // all stack objects, fixed- and variable-sized). All local objects[1] will; // then use AP as the base pointer.; // [1] The exception is with ""fixed"" stack objects. ""Fixed"" stack objects get; // their name from being allocated at fixed locations on the stack, relative; // to the FP. In the presence of dynamic allocation and local alignment, such; // objects can only be accessed through the FP.; //; // Illustration of the AP:; // FP --+; // |; // --",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:2318,Security,access,accessed,2318,"ically allocated (variable-sized) objects. The alignment pad will be; // placed between the FP and the local objects, thus preventing the use of the; // FP to access the local objects. At the same time, the variable-sized objects; // will be between the SP and the local objects, thus introducing an unknown; // distance from the SP to the locals.; //; // To avoid this problem, a new register is created that holds the aligned; // address of the bottom of the stack, referred in the sources as AP (aligned; // pointer). The AP will be equal to ""FP-p"", where ""p"" is the smallest pad; // that aligns AP to the required boundary (a maximum of the alignments of; // all stack objects, fixed- and variable-sized). All local objects[1] will; // then use AP as the base pointer.; // [1] The exception is with ""fixed"" stack objects. ""Fixed"" stack objects get; // their name from being allocated at fixed locations on the stack, relative; // to the FP. In the presence of dynamic allocation and local alignment, such; // objects can only be accessed through the FP.; //; // Illustration of the AP:; // FP --+; // |; // ---------------+---------------------+-----+-----------------------++-+--; // Rest of the | Local stack objects | Pad | Fixed stack objects |LR|; // stack frame | (aligned) | | (CSR, spills, etc.) |FP|; // ---------------+---------------------+-----+-----------------+-----+--+--; // |<-- Multiple of the -->|; // stack alignment +-- AP; //; // The AP is set up at the beginning of the function. Since it is not a dedi-; // cated (reserved) register, it needs to be kept live throughout the function; // to be available as the base register for local object accesses.; // Normally, an address of a stack objects is obtained by a pseudo-instruction; // PS_fi. To access local objects with the AP register present, a different; // pseudo-instruction needs to be used: PS_fia. The PS_fia takes one extra; // argument compared to PS_fi: the first input register is the AP register.; // This kee",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:2954,Security,access,accesses,2954,"p"", where ""p"" is the smallest pad; // that aligns AP to the required boundary (a maximum of the alignments of; // all stack objects, fixed- and variable-sized). All local objects[1] will; // then use AP as the base pointer.; // [1] The exception is with ""fixed"" stack objects. ""Fixed"" stack objects get; // their name from being allocated at fixed locations on the stack, relative; // to the FP. In the presence of dynamic allocation and local alignment, such; // objects can only be accessed through the FP.; //; // Illustration of the AP:; // FP --+; // |; // ---------------+---------------------+-----+-----------------------++-+--; // Rest of the | Local stack objects | Pad | Fixed stack objects |LR|; // stack frame | (aligned) | | (CSR, spills, etc.) |FP|; // ---------------+---------------------+-----+-----------------+-----+--+--; // |<-- Multiple of the -->|; // stack alignment +-- AP; //; // The AP is set up at the beginning of the function. Since it is not a dedi-; // cated (reserved) register, it needs to be kept live throughout the function; // to be available as the base register for local object accesses.; // Normally, an address of a stack objects is obtained by a pseudo-instruction; // PS_fi. To access local objects with the AP register present, a different; // pseudo-instruction needs to be used: PS_fia. The PS_fia takes one extra; // argument compared to PS_fi: the first input register is the AP register.; // This keeps the register live between its definition and its uses.; // The AP register is originally set up using pseudo-instruction PS_aligna:; // AP = PS_aligna A; // where; // A - required stack alignment; // The alignment value must be the maximum of all alignments required by; // any stack object.; // The dynamic allocation uses a pseudo-instruction PS_alloca:; // Rd = PS_alloca Rs, A; // where; // Rd - address of the allocated space; // Rs - minimum size (the actual allocated can be larger to accommodate; // alignment); // A - required alignment",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:3058,Security,access,access,3058,"p"", where ""p"" is the smallest pad; // that aligns AP to the required boundary (a maximum of the alignments of; // all stack objects, fixed- and variable-sized). All local objects[1] will; // then use AP as the base pointer.; // [1] The exception is with ""fixed"" stack objects. ""Fixed"" stack objects get; // their name from being allocated at fixed locations on the stack, relative; // to the FP. In the presence of dynamic allocation and local alignment, such; // objects can only be accessed through the FP.; //; // Illustration of the AP:; // FP --+; // |; // ---------------+---------------------+-----+-----------------------++-+--; // Rest of the | Local stack objects | Pad | Fixed stack objects |LR|; // stack frame | (aligned) | | (CSR, spills, etc.) |FP|; // ---------------+---------------------+-----+-----------------+-----+--+--; // |<-- Multiple of the -->|; // stack alignment +-- AP; //; // The AP is set up at the beginning of the function. Since it is not a dedi-; // cated (reserved) register, it needs to be kept live throughout the function; // to be available as the base register for local object accesses.; // Normally, an address of a stack objects is obtained by a pseudo-instruction; // PS_fi. To access local objects with the AP register present, a different; // pseudo-instruction needs to be used: PS_fia. The PS_fia takes one extra; // argument compared to PS_fi: the first input register is the AP register.; // This keeps the register live between its definition and its uses.; // The AP register is originally set up using pseudo-instruction PS_aligna:; // AP = PS_aligna A; // where; // A - required stack alignment; // The alignment value must be the maximum of all alignments required by; // any stack object.; // The dynamic allocation uses a pseudo-instruction PS_alloca:; // Rd = PS_alloca Rs, A; // where; // Rd - address of the allocated space; // Rs - minimum size (the actual allocated can be larger to accommodate; // alignment); // A - required alignment",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:22,Integrability,wrap,wrapping,22,"/// Implements shrink-wrapping of the stack frame. By default, stack frame; /// is created in the function entry block, and is cleaned up in every block; /// that returns. This function finds alternate blocks: one for the frame; /// setup (prolog) and one for the cleanup (epilog).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:140,Usability,simpl,simpli,140,"// Don't process functions that have loops, at least for now. Placement; // of prolog and epilog must take loop structure into account. For simpli-; // city don't do it right now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:249,Integrability,wrap,wrapping,249,"/// Perform most of the PEI work here:; /// - saving/restoring of the callee-saved registers,; /// - stack frame creation and destruction.; /// Normally, this work is distributed among various functions, but doing it; /// in one place allows shrink-wrapping of the stack frame.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:4,Performance,Perform,Perform,4,"/// Perform most of the PEI work here:; /// - saving/restoring of the callee-saved registers,; /// - stack frame creation and destruction.; /// Normally, this work is distributed among various functions, but doing it; /// in one place allows shrink-wrapping of the stack frame.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:35,Safety,safe,safely,35,/// Returns true if the target can safely skip saving callee-saved registers; /// for noreturn nounwind functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:72,Energy Efficiency,allocate,allocate,72,// Calculate the total stack frame size.; // Get the number of bytes to allocate from the FrameInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:30,Energy Efficiency,allocate,allocate,30,// Get the number of bytes to allocate from the FrameInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:25,Performance,load,load,25,// Determine the kind of load/store that should be used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:186,Modifiability,variab,variable,186,"// Get the start location of the load. NumBytes is basically the; // offset from the stack pointer of previous function, which would be; // the caller in this case, as this function has variable argument; // list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:33,Performance,load,load,33,"// Get the start location of the load. NumBytes is basically the; // offset from the stack pointer of previous function, which would be; // the caller in this case, as this function has variable argument; // list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:3,Performance,Load,Load,3,// Load the value of the named argument on stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:37,Modifiability,variab,variable,37,"// If the number of registers having variable arguments is odd,; // leave 4 bytes of padding to get to the location where first; // variable argument which was passed through register was copied.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:132,Modifiability,variab,variable,132,"// If the number of registers having variable arguments is odd,; // leave 4 bytes of padding to get to the location where first; // variable argument which was passed through register was copied.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:36,Safety,avoid,avoid,36,// Create a dummy memory operand to avoid allocframe from being treated as; // a volatile memory reference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:119,Integrability,depend,dependency,119,// Add implicit uses of all callee-saved registers to the reached; // return instructions. This is to prevent the anti-dependency breaker; // from renaming these registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:363,Usability,simpl,simply,363,"// If the function has a frame pointer (i.e. has an allocframe),; // then the CFA has been defined in terms of FP. Any offsets in; // the following CFI instructions have to be defined relative; // to FP, which points to the bottom of the stack frame.; // The function getFrameIndexReference can still choose to use SP; // for the offset calculation, so we cannot simply call it here.; // Instead, get the offset (relative to the FP) directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:674,Availability,error,error,674,"// It may happen that AP will be absent even HasAlloca && HasExtraAlign; // is true. HasExtraAlign may be set because of vector spills, without; // aligned locals or aligned outgoing function arguments. Since vector; // spills will ultimately be ""unaligned"", it is safe to use FP as the; // base register.; // In fact, in such a scenario the stack is actually not required to be; // aligned, although it may end up being aligned anyway, since this; // particular case is not easily detectable. The alignment will be; // unnecessary, but not incorrect.; // Unfortunately there is no quick way to verify that the above is; // indeed the case (and that it's not a result of an error), so just; // assume that missing AP will be replaced by FP.; // (A better fix would be to rematerialize AP from FP and always align; // vector spills.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:265,Safety,safe,safe,265,"// It may happen that AP will be absent even HasAlloca && HasExtraAlign; // is true. HasExtraAlign may be set because of vector spills, without; // aligned locals or aligned outgoing function arguments. Since vector; // spills will ultimately be ""unaligned"", it is safe to use FP as the; // base register.; // In fact, in such a scenario the stack is actually not required to be; // aligned, although it may end up being aligned anyway, since this; // particular case is not easily detectable. The alignment will be; // unnecessary, but not incorrect.; // Unfortunately there is no quick way to verify that the above is; // indeed the case (and that it's not a result of an error), so just; // assume that missing AP will be replaced by FP.; // (A better fix would be to rematerialize AP from FP and always align; // vector spills.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:482,Safety,detect,detectable,482,"// It may happen that AP will be absent even HasAlloca && HasExtraAlign; // is true. HasExtraAlign may be set because of vector spills, without; // aligned locals or aligned outgoing function arguments. Since vector; // spills will ultimately be ""unaligned"", it is safe to use FP as the; // base register.; // In fact, in such a scenario the stack is actually not required to be; // aligned, although it may end up being aligned anyway, since this; // particular case is not easily detectable. The alignment will be; // unnecessary, but not incorrect.; // Unfortunately there is no quick way to verify that the above is; // indeed the case (and that it's not a result of an error), so just; // assume that missing AP will be replaced by FP.; // (A better fix would be to rematerialize AP from FP and always align; // vector spills.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:228,Security,access,access,228,"// Default: use SP (except at -O0).; // Use FP at -O0, except when there are objects with extra alignment.; // That additional alignment requirement may cause a pad to be inserted,; // which will make it impossible to use FP to access objects located; // past the pad.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:95,Security,access,access,95,// Fixed and preallocated objects will be located before any padding; // so FP must be used to access them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:935,Energy Efficiency,reduce,reduce,935,"// Having FP implies allocframe. Allocframe will store extra 8 bytes:; // FP/LR. If the base register is used to access an object across these; // 8 bytes, then the offset will need to be adjusted by 8.; //; // After allocframe:; // HexagonISelLowering adds 8 to ---+; // the offsets of all stack-based |; // arguments (*) |; // |; // getObjectOffset < 0 0 8 getObjectOffset >= 8; // ------------------------+-----+------------------------> increasing; // <local objects> |FP/LR| <input arguments> addresses; // -----------------+------+-----+------------------------>; // | |; // SP/AP point --+ +-- FP points here (**); // somewhere on; // this side of FP/LR; //; // (*) See LowerFormalArguments. The FP/LR is assumed to be present.; // (**) *FP == old-FP. FP+0..7 are the bytes of FP/LR.; // The lowering assumes that FP/LR is present, and so the offsets of; // the formal arguments start at 8. If FP/LR is not there we need to; // reduce the offset by 8.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:113,Security,access,access,113,"// Having FP implies allocframe. Allocframe will store extra 8 bytes:; // FP/LR. If the base register is used to access an object across these; // 8 bytes, then the offset will need to be adjusted by 8.; //; // After allocframe:; // HexagonISelLowering adds 8 to ---+; // the offsets of all stack-based |; // arguments (*) |; // |; // getObjectOffset < 0 0 8 getObjectOffset >= 8; // ------------------------+-----+------------------------> increasing; // <local objects> |FP/LR| <input arguments> addresses; // -----------------+------+-----+------------------------>; // | |; // SP/AP point --+ +-- FP points here (**); // somewhere on; // this side of FP/LR; //; // (*) See LowerFormalArguments. The FP/LR is assumed to be present.; // (**) *FP == old-FP. FP+0..7 are the bytes of FP/LR.; // The lowering assumes that FP/LR is present, and so the offsets of; // the formal arguments start at 8. If FP/LR is not there we need to; // reduce the offset by 8.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:261,Availability,avail,available,261,"// If this function has uses aligned stack and also has variable sized stack; // objects, then we need to map all spill slots to fixed positions, so that; // they can be accessed through FP. Otherwise they would have to be accessed; // via AP, which may not be available at the particular place in the program.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:56,Modifiability,variab,variable,56,"// If this function has uses aligned stack and also has variable sized stack; // objects, then we need to map all spill slots to fixed positions, so that; // they can be accessed through FP. Otherwise they would have to be accessed; // via AP, which may not be available at the particular place in the program.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:170,Security,access,accessed,170,"// If this function has uses aligned stack and also has variable sized stack; // objects, then we need to map all spill slots to fixed positions, so that; // they can be accessed through FP. Otherwise they would have to be accessed; // via AP, which may not be available at the particular place in the program.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:223,Security,access,accessed,223,"// If this function has uses aligned stack and also has variable sized stack; // objects, then we need to map all spill slots to fixed positions, so that; // they can be accessed through FP. Otherwise they would have to be accessed; // via AP, which may not be available at the particular place in the program.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:56,Availability,avail,available,56,/// Returns true if there are no caller-saved registers available in class RC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:43,Performance,load,load,43,"// TmpR0 = A2_tfrsi 0x01010101; // TmpR1 = load FI, 0; // DstR = V6_vandvrt TmpR1, TmpR0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:3,Performance,Load,Load,3,// Load low part.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:3,Performance,Load,Load,3,// Load high part.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:18,Performance,load,load,18,"// If it's both a load and a store, then we won't handle it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:133,Performance,load,load,133,"// Check for register classes of the register used as the source for; // the store, and the register used as the destination for the load.; // Also, only accept base+imm_offset addressing modes. Other addressing; // modes can have side-effects (post-increments, etc.). For stack; // slots they are very unlikely, so there is not much loss due to; // this restriction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:18,Performance,load,loaded,18,"// When a slot is loaded from in a block without being stored to in the; // same block, it is live-on-entry to this block. To avoid CFG analysis,; // consider this slot to be live-on-exit from all blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:126,Safety,avoid,avoid,126,"// When a slot is loaded from in a block without being stored to in the; // same block, it is live-on-entry to this block. To avoid CFG analysis,; // consider this slot to be live-on-exit from all blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:13,Performance,load,loads,13,"// eliminate loads, when all loads eliminated, eliminate all stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:29,Performance,load,loads,29,"// eliminate loads, when all loads eliminated, eliminate all stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:3,Deployability,Update,Update,3,// Update store's source register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:3,Deployability,Update,Update,3,// Update the dead map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:152,Modifiability,variab,variable-sized,152,"// Do not check for max stack object alignment here, because the stack; // may not be complete yet. Assume that we will need PS_aligna if there; // are variable-sized objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:239,Performance,perform,performed,239,"/// Determine whether the callee-saved register saves and restores should; /// be generated via inline code. If this function returns ""true"", inline; /// code will be generated. If this function returns ""false"", additional; /// checks are performed, which may still lead to the inline code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:55,Performance,load,load,55,// A fairly simplistic guess as to whether a potential load/store to a; // stack location could require an extra register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:12,Usability,simpl,simplistic,12,// A fairly simplistic guess as to whether a potential load/store to a; // stack location could require an extra register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:115,Modifiability,extend,extendable,115,"// Check if the function has store-immediate instructions that access; // the stack. Since the offset field is not extendable, if the stack; // size exceeds the offset limit (6 bits, shifted), the stores will; // require a new base register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:63,Security,access,access,63,"// Check if the function has store-immediate instructions that access; // the stack. Since the offset field is not extendable, if the stack; // size exceeds the offset limit (6 bits, shifted), the stores will; // require a new base register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:23,Security,access,access,23,// Log_2 of the memory access size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.h:46,Modifiability,variab,variable,46,// First register which could possibly hold a variable argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.h:170,Integrability,wrap,wrapping,170,"// All of the prolog/epilog functionality, including saving and restoring; // callee-saved registers is handled in emitPrologue. This is to have the; // logic for shrink-wrapping in one place.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.h:153,Testability,log,logic,153,"// All of the prolog/epilog functionality, including saving and restoring; // callee-saved registers is handled in emitPrologue. This is to have the; // logic for shrink-wrapping in one place.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.h:29,Safety,avoid,avoid,29,// Override this function to avoid calling hasFP before CSI is set; // (the default implementation calls hasFP).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenExtract.cpp:331,Testability,log,logical,331,"// This prevents generating extract instructions that have the offset of 0.; // One of the reasons for ""extract"" is to put a sequence of bits in a regis-; // ter, starting at offset 0 (so that these bits can then be used by an; // ""insert""). If the bits are already at offset 0, it is better not to gene-; // rate ""extract"", since logical bit operations can be merged into compound; // instructions (as opposed to ""extract"").",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenExtract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenExtract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenExtract.cpp:26,Availability,mask,mask,26,// CM is the shifted-left mask. Shift it back right to remove the zero; // bits on least-significant positions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenExtract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenExtract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenExtract.cpp:144,Availability,mask,mask,144,// The width of the extracted field is the minimum of the original bits; // that remain after the shifts and the number of contiguous 1s in the mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenExtract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenExtract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenExtract.cpp:56,Availability,mask,mask,56,"// Check if the extracted bits are contained within the mask that it is; // and-ed with. The extract operation will copy these bits, and so the; // mask cannot any holes in it that would clear any of the bits of the; // extracted field.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenExtract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenExtract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenExtract.cpp:148,Availability,mask,mask,148,"// Check if the extracted bits are contained within the mask that it is; // and-ed with. The extract operation will copy these bits, and so the; // mask cannot any holes in it that would clear any of the bits of the; // extracted field.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenExtract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenExtract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenExtract.cpp:187,Usability,clear,clear,187,"// Check if the extracted bits are contained within the mask that it is; // and-ed with. The extract operation will copy these bits, and so the; // mask cannot any holes in it that would clear any of the bits of the; // extracted field.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenExtract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenExtract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenExtract.cpp:130,Availability,mask,mask,130,"// If the shift right was arithmetic, it could have included some 1 bits.; // It is still ok to generate extract, but only if the mask eliminates; // those bits (i.e. M does not have any bits set beyond U).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenExtract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenExtract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenExtract.cpp:189,Availability,mask,mask,189,"// Check if M starts with a contiguous sequence of W times 1 bits. Get; // the low U bits of M (which eliminates the 0 bits shifted in on the; // left), and check if the result is APInt's ""mask"":",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenExtract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenExtract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp:83,Modifiability,extend,extenders,83,"// Whether to construct constant values via ""insert"". Could eliminate constant; // extenders, but often not practical.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp:113,Safety,detect,detect,113,// The preprocessor gets confused when the DEBUG macro is passed larger; // chunks of code. Use this function to detect debugging.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp:16,Testability,test,test,16,// A.BitVector::test(B) <=> A-B != {},MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp:160,Performance,cache,cache,160,"// A utility to establish an ordering between virtual registers:; // VRegA < VRegB <=> RegisterOrdering[VRegA] < RegisterOrdering[VRegB]; // This is meant as a cache for the ordering of virtual registers defined; // by a potentially expensive comparison function, or obtained by a proce-; // dure that should not be repeated each time two registers are compared.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp:131,Energy Efficiency,reduce,reduce,131,"// Cache for the BitTracker's cell map. Map lookup has a logarithmic; // complexity, this class will memoize the lookup results to reduce; // the access time for repeated lookups of the same cell.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp:3,Performance,Cache,Cache,3,"// Cache for the BitTracker's cell map. Map lookup has a logarithmic; // complexity, this class will memoize the lookup results to reduce; // the access time for repeated lookups of the same cell.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp:146,Security,access,access,146,"// Cache for the BitTracker's cell map. Map lookup has a logarithmic; // complexity, this class will memoize the lookup results to reduce; // the access time for repeated lookups of the same cell.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp:57,Testability,log,logarithmic,57,"// Cache for the BitTracker's cell map. Map lookup has a logarithmic; // complexity, this class will memoize the lookup results to reduce; // the access time for repeated lookups of the same cell.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp:46,Performance,cache,cached,46,"// If we have already computed it, return the cached result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp:368,Energy Efficiency,reduce,reduce,368,// The registers in AVs are ordered according to the lexical order of; // the corresponding register cells. This means that the range of regis-; // ters in AVs that match a prefix of length L+1 will be contained in; // the range that matches a prefix of length L. This means that we can; // keep narrowing the search space as the prefix length goes up. This; // helps reduce the overall complexity of the search.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp:89,Deployability,patch,patch,89,// TODO (future): Record identical registers.; // Look for a register whose prefix could patch the range [FD..LD]; // where VR and SrcR differ.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp:107,Availability,avail,available,107,"// Keep a separate set of registers defined in this block, so that we; // can remove them from the list of available registers once all DT; // successors have been processed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp:176,Modifiability,extend,extenders,176,"// If VR's cell contains a reference to VR, then VR cannot be defined; // via ""insert"". If VR is a constant that can be generated in a single; // instruction (without constant extenders), generating it via insert; // makes no sense.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp:49,Availability,avail,available,49,// Insert the defined registers into the list of available registers; // after they have been processed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp:547,Modifiability,extend,extending,547,"// Check if a given register has bits that are references to any other; // registers. This is to detect situations where the instruction that; // defines register R takes register Q as an operand, but R itself does; // not contain any bits from Q. Loads are examples of how this could; // happen:; // R = load Q; // In this case (assuming we do not have any knowledge about the loaded; // value), we must not treat R as a ""conveyance"" of the bits from Q.; // (The information in BT about R's bits would have them as constants,; // in case of zero-extending loads, or refs to R.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp:248,Performance,Load,Loads,248,"// Check if a given register has bits that are references to any other; // registers. This is to detect situations where the instruction that; // defines register R takes register Q as an operand, but R itself does; // not contain any bits from Q. Loads are examples of how this could; // happen:; // R = load Q; // In this case (assuming we do not have any knowledge about the loaded; // value), we must not treat R as a ""conveyance"" of the bits from Q.; // (The information in BT about R's bits would have them as constants,; // in case of zero-extending loads, or refs to R.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp:305,Performance,load,load,305,"// Check if a given register has bits that are references to any other; // registers. This is to detect situations where the instruction that; // defines register R takes register Q as an operand, but R itself does; // not contain any bits from Q. Loads are examples of how this could; // happen:; // R = load Q; // In this case (assuming we do not have any knowledge about the loaded; // value), we must not treat R as a ""conveyance"" of the bits from Q.; // (The information in BT about R's bits would have them as constants,; // in case of zero-extending loads, or refs to R.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp:378,Performance,load,loaded,378,"// Check if a given register has bits that are references to any other; // registers. This is to detect situations where the instruction that; // defines register R takes register Q as an operand, but R itself does; // not contain any bits from Q. Loads are examples of how this could; // happen:; // R = load Q; // In this case (assuming we do not have any knowledge about the loaded; // value), we must not treat R as a ""conveyance"" of the bits from Q.; // (The information in BT about R's bits would have them as constants,; // in case of zero-extending loads, or refs to R.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp:557,Performance,load,loads,557,"// Check if a given register has bits that are references to any other; // registers. This is to detect situations where the instruction that; // defines register R takes register Q as an operand, but R itself does; // not contain any bits from Q. Loads are examples of how this could; // happen:; // R = load Q; // In this case (assuming we do not have any knowledge about the loaded; // value), we must not treat R as a ""conveyance"" of the bits from Q.; // (The information in BT about R's bits would have them as constants,; // in case of zero-extending loads, or refs to R.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp:97,Safety,detect,detect,97,"// Check if a given register has bits that are references to any other; // registers. This is to detect situations where the instruction that; // defines register R takes register Q as an operand, but R itself does; // not contain any bits from Q. Loads are examples of how this could; // happen:; // R = load Q; // In this case (assuming we do not have any knowledge about the loaded; // value), we must not treat R as a ""conveyance"" of the bits from Q.; // (The information in BT about R's bits would have them as constants,; // in case of zero-extending loads, or refs to R.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp:36,Safety,avoid,avoid,36,"// Do not iterate past PHI nodes to avoid infinite loops. This can; // make the final set a bit less accurate, but the removable register; // sets are an approximation anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp:270,Energy Efficiency,reduce,reduce,270,"// First, examine the IF candidates for register VR whose removable-regis-; // ter sets are empty. This means that a given candidate will not help eli-; // minate any registers, but since ""insert"" is not a constant-extendable; // instruction, using such a candidate may reduce code size if the defini-; // tion of VR is constant-extended.; // If there exists a candidate with a non-empty set, the ones with empty; // sets will not be used and can be removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp:215,Modifiability,extend,extendable,215,"// First, examine the IF candidates for register VR whose removable-regis-; // ter sets are empty. This means that a given candidate will not help eli-; // minate any registers, but since ""insert"" is not a constant-extendable; // instruction, using such a candidate may reduce code size if the defini-; // tion of VR is constant-extended.; // If there exists a candidate with a non-empty set, the ones with empty; // sets will not be used and can be removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp:329,Modifiability,extend,extended,329,"// First, examine the IF candidates for register VR whose removable-regis-; // ter sets are empty. This means that a given candidate will not help eli-; // minate any registers, but since ""insert"" is not a constant-extendable; // instruction, using such a candidate may reduce code size if the defini-; // tion of VR is constant-extended.; // If there exists a candidate with a non-empty set, the ones with empty; // sets will not be used and can be removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp:40,Modifiability,extend,extended,40,"// The definition of VR is not constant-extended, or there is a candidate; // with a non-empty set. Remove all candidates with empty sets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp:36,Modifiability,extend,extended,36,"// The definition of VR is constant-extended, and all candidates have; // empty removable-register sets. Pick the maximum candidate, and remove; // all others. The ""maximum"" does not have any special meaning here, it; // is only so that the candidate that will remain on the list is selec-; // ted deterministically.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp:44,Usability,clear,clear,44,"// Get the minimum element, remember it and clear the list. If the; // element found is adequate, we will put it back on the list, other-; // wise the list will remain empty, and the entry for this register; // will be removed (i.e. this register will not be replaced by insert).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenMux.cpp:815,Energy Efficiency,schedul,scheduler,815,"//===- HexagonGenMux.cpp --------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // During instruction selection, MUX instructions are generated for; // conditional assignments. Since such assignments often present an; // opportunity to predicate instructions, HexagonExpandCondsets; // expands MUXes into pairs of conditional transfers, and then proceeds; // with predication of the producers/consumers of the registers involved.; // This happens after exiting from the SSA form, but before the machine; // instruction scheduler. After the scheduler and after the register; // allocation there can be cases of pairs of conditional transfers; // resulting from a MUX where neither of them was further predicated. If; // these transfers are now placed far enough from the instruction defining; // the predicate register, they cannot use the .new form. In such cases it; // is better to collapse them back to a single MUX instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenMux.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenMux.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenMux.cpp:836,Energy Efficiency,schedul,scheduler,836,"//===- HexagonGenMux.cpp --------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // During instruction selection, MUX instructions are generated for; // conditional assignments. Since such assignments often present an; // opportunity to predicate instructions, HexagonExpandCondsets; // expands MUXes into pairs of conditional transfers, and then proceeds; // with predication of the producers/consumers of the registers involved.; // This happens after exiting from the SSA form, but before the machine; // instruction scheduler. After the scheduler and after the register; // allocation there can be cases of pairs of conditional transfers; // resulting from a MUX where neither of them was further predicated. If; // these transfers are now placed far enough from the instruction defining; // the predicate register, they cannot use the .new form. In such cases it; // is better to collapse them back to a single MUX instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenMux.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenMux.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenMux.cpp:46,Modifiability,extend,extendable,46,"// Neither is a register. The first source is extendable, but the second; // is not (s8).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenMux.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenMux.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenMux.cpp:193,Availability,down,down,193,"// The predicate register is not defined in the last few instructions.; // Check if the conversion to MUX is possible (either ""up"", i.e. at the; // place of the earlier partial definition, or ""down"", where the later; // definition is located). Examine all defs and uses between these two; // definitions.; // SR1, SR2 - source registers from the first and the second definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenMux.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenMux.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenMux.cpp:11,Availability,down,down,11,"// Prefer ""down"", since this will move the MUX farther away from the; // predicate definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenMux.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenMux.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenMux.cpp:64,Security,validat,validate,64,"// Basic correctness check: since we are deleting instructions, validate the; // iterators. There is a possibility that one of Def1 or Def2 is translated; // to ""mux"" and being considered for other ""mux"" instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenMux.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenMux.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenMux.cpp:38,Safety,safe,safe,38,"// This isn't 100% accurate, but it's safe.; // It won't detect (as a kill) a case like this; // r0 = add r0, 1 <-- r0 should be ""killed""; // ... = r0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenMux.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenMux.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenMux.cpp:57,Safety,detect,detect,57,"// This isn't 100% accurate, but it's safe.; // It won't detect (as a kill) a case like this; // r0 = add r0, 1 <-- r0 should be ""killed""; // ... = r0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenMux.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenMux.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenPredicate.cpp:23,Performance,queue,queue,23,// Add operands to the queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenPredicate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenPredicate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:619,Integrability,depend,depending,619,"//===- HexagonHardwareLoops.cpp - Identify and generate hardware loops ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies loops where we can generate the Hexagon hardware; // loop instruction. The hardware loop can perform loop branches with a; // zero-cycle overhead.; //; // The pattern that defines the induction variable can changed depending on; // prior optimizations. For example, the IndVarSimplify phase run by 'opt'; // normalizes induction variables, and the Loop Strength Reduction pass; // run by 'llc' may also make changes to the induction variable.; // The pattern detected by this phase is due to running Strength Reduction.; //; // Criteria for hardware loops:; // - Countable loops (w/ ind. var for a trip count); // - Assumes loops are normalized by IndVarSimplify; // - Try inner-most loops first; // - No function calls in loops.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:598,Modifiability,variab,variable,598,"//===- HexagonHardwareLoops.cpp - Identify and generate hardware loops ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies loops where we can generate the Hexagon hardware; // loop instruction. The hardware loop can perform loop branches with a; // zero-cycle overhead.; //; // The pattern that defines the induction variable can changed depending on; // prior optimizations. For example, the IndVarSimplify phase run by 'opt'; // normalizes induction variables, and the Loop Strength Reduction pass; // run by 'llc' may also make changes to the induction variable.; // The pattern detected by this phase is due to running Strength Reduction.; //; // Criteria for hardware loops:; // - Countable loops (w/ ind. var for a trip count); // - Assumes loops are normalized by IndVarSimplify; // - Try inner-most loops first; // - No function calls in loops.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:733,Modifiability,variab,variables,733,"//===- HexagonHardwareLoops.cpp - Identify and generate hardware loops ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies loops where we can generate the Hexagon hardware; // loop instruction. The hardware loop can perform loop branches with a; // zero-cycle overhead.; //; // The pattern that defines the induction variable can changed depending on; // prior optimizations. For example, the IndVarSimplify phase run by 'opt'; // normalizes induction variables, and the Loop Strength Reduction pass; // run by 'llc' may also make changes to the induction variable.; // The pattern detected by this phase is due to running Strength Reduction.; //; // Criteria for hardware loops:; // - Countable loops (w/ ind. var for a trip count); // - Assumes loops are normalized by IndVarSimplify; // - Try inner-most loops first; // - No function calls in loops.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:837,Modifiability,variab,variable,837,"//===- HexagonHardwareLoops.cpp - Identify and generate hardware loops ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies loops where we can generate the Hexagon hardware; // loop instruction. The hardware loop can perform loop branches with a; // zero-cycle overhead.; //; // The pattern that defines the induction variable can changed depending on; // prior optimizations. For example, the IndVarSimplify phase run by 'opt'; // normalizes induction variables, and the Loop Strength Reduction pass; // run by 'llc' may also make changes to the induction variable.; // The pattern detected by this phase is due to running Strength Reduction.; //; // Criteria for hardware loops:; // - Countable loops (w/ ind. var for a trip count); // - Assumes loops are normalized by IndVarSimplify; // - Try inner-most loops first; // - No function calls in loops.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:497,Performance,perform,perform,497,"//===- HexagonHardwareLoops.cpp - Identify and generate hardware loops ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies loops where we can generate the Hexagon hardware; // loop instruction. The hardware loop can perform loop branches with a; // zero-cycle overhead.; //; // The pattern that defines the induction variable can changed depending on; // prior optimizations. For example, the IndVarSimplify phase run by 'opt'; // normalizes induction variables, and the Loop Strength Reduction pass; // run by 'llc' may also make changes to the induction variable.; // The pattern detected by this phase is due to running Strength Reduction.; //; // Criteria for hardware loops:; // - Countable loops (w/ ind. var for a trip count); // - Assumes loops are normalized by IndVarSimplify; // - Try inner-most loops first; // - No function calls in loops.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:642,Performance,optimiz,optimizations,642,"//===- HexagonHardwareLoops.cpp - Identify and generate hardware loops ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies loops where we can generate the Hexagon hardware; // loop instruction. The hardware loop can perform loop branches with a; // zero-cycle overhead.; //; // The pattern that defines the induction variable can changed depending on; // prior optimizations. For example, the IndVarSimplify phase run by 'opt'; // normalizes induction variables, and the Loop Strength Reduction pass; // run by 'llc' may also make changes to the induction variable.; // The pattern detected by this phase is due to running Strength Reduction.; //; // Criteria for hardware loops:; // - Countable loops (w/ ind. var for a trip count); // - Assumes loops are normalized by IndVarSimplify; // - Try inner-most loops first; // - No function calls in loops.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:863,Safety,detect,detected,863,"//===- HexagonHardwareLoops.cpp - Identify and generate hardware loops ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies loops where we can generate the Hexagon hardware; // loop instruction. The hardware loop can perform loop branches with a; // zero-cycle overhead.; //; // The pattern that defines the induction variable can changed depending on; // prior optimizations. For example, the IndVarSimplify phase run by 'opt'; // normalizes induction variables, and the Loop Strength Reduction pass; // run by 'llc' may also make changes to the induction variable.; // The pattern detected by this phase is due to running Strength Reduction.; //; // Criteria for hardware loops:; // - Countable loops (w/ ind. var for a trip count); // - Assumes loops are normalized by IndVarSimplify; // - Try inner-most loops first; // - No function calls in loops.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:86,Deployability,pipeline,pipeliner,86,"// Turn it off by default. If a preheader block is not created here, the; // software pipeliner may be unable to find a block suitable to serve as; // a preheader. In that case SWP will not run.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:72,Modifiability,variab,variable,72,"/// Find the register that contains the loop controlling; /// induction variable.; /// If successful, it will return true and set the \p Reg, \p IVBump; /// and \p IVOp arguments. Otherwise it will return false.; /// The returned induction register is the register R that follows the; /// following induction pattern:; /// loop:; /// R = phi ..., [ R.next, LatchBlock ]; /// R.next = R + #bump; /// if (R.next < #N) goto loop; /// IVBump is the immediate value added to R, and IVOp is the instruction; /// ""R.next = R + #bump"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:315,Availability,avail,available,315,"/// Return the expression that represents the number of times; /// a loop iterates. The function takes the operands that represent the; /// loop start value, loop end value, and induction value. Based upon; /// these operands, the function attempts to compute the trip count.; /// If the trip count is not directly available (as an immediate value,; /// or a register), the function will attempt to insert computation of it; /// to the loop's preheader.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:82,Performance,perform,perform,82,"/// Given a loop, check if we can convert it to a hardware loop.; /// If so, then perform the conversion and return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:80,Integrability,wrap,wrap,80,"/// Return true if the Phi may generate a value that may underflow,; /// or may wrap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:33,Modifiability,variab,variable,33,/// Return true if the induction variable may underflow an unsigned; /// value in the first iteration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:39,Modifiability,variab,variable,39,"/// Fix the data flow of the induction variable.; /// The desired flow is: phi ---> bump -+-> comparison-in-latch.; /// |; /// +-> back to phi; /// where ""bump"" is the increment of the induction variable:; /// iv = iv + #const.; /// Due to some prior code transformations, the actual flow may look; /// like this:; /// phi -+-> bump ---> back to phi; /// |; /// +-> comparison-in-latch (against upper_bound-bump),; /// i.e. the comparison that controls the loop execution may be using; /// the value of the induction variable from before the increment.; ///; /// Return true if the loop's flow is the desired one (i.e. it's; /// either been fixed, or no fixing was necessary).; /// Otherwise, return false. This can happen if the induction variable; /// couldn't be identified, or if the value in the latch's comparison; /// cannot be adjusted to reflect the post-bump value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:195,Modifiability,variab,variable,195,"/// Fix the data flow of the induction variable.; /// The desired flow is: phi ---> bump -+-> comparison-in-latch.; /// |; /// +-> back to phi; /// where ""bump"" is the increment of the induction variable:; /// iv = iv + #const.; /// Due to some prior code transformations, the actual flow may look; /// like this:; /// phi -+-> bump ---> back to phi; /// |; /// +-> comparison-in-latch (against upper_bound-bump),; /// i.e. the comparison that controls the loop execution may be using; /// the value of the induction variable from before the increment.; ///; /// Return true if the loop's flow is the desired one (i.e. it's; /// either been fixed, or no fixing was necessary).; /// Otherwise, return false. This can happen if the induction variable; /// couldn't be identified, or if the value in the latch's comparison; /// cannot be adjusted to reflect the post-bump value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:517,Modifiability,variab,variable,517,"/// Fix the data flow of the induction variable.; /// The desired flow is: phi ---> bump -+-> comparison-in-latch.; /// |; /// +-> back to phi; /// where ""bump"" is the increment of the induction variable:; /// iv = iv + #const.; /// Due to some prior code transformations, the actual flow may look; /// like this:; /// phi -+-> bump ---> back to phi; /// |; /// +-> comparison-in-latch (against upper_bound-bump),; /// i.e. the comparison that controls the loop execution may be using; /// the value of the induction variable from before the increment.; ///; /// Return true if the loop's flow is the desired one (i.e. it's; /// either been fixed, or no fixing was necessary).; /// Otherwise, return false. This can happen if the induction variable; /// couldn't be identified, or if the value in the latch's comparison; /// cannot be adjusted to reflect the post-bump value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:740,Modifiability,variab,variable,740,"/// Fix the data flow of the induction variable.; /// The desired flow is: phi ---> bump -+-> comparison-in-latch.; /// |; /// +-> back to phi; /// where ""bump"" is the increment of the induction variable:; /// iv = iv + #const.; /// Due to some prior code transformations, the actual flow may look; /// like this:; /// phi -+-> bump ---> back to phi; /// |; /// +-> comparison-in-latch (against upper_bound-bump),; /// i.e. the comparison that controls the loop execution may be using; /// the value of the induction variable from before the increment.; ///; /// Return true if the loop's flow is the desired one (i.e. it's; /// either been fixed, or no fixing was necessary).; /// Otherwise, return false. This can happen if the induction variable; /// couldn't be identified, or if the value in the latch's comparison; /// cannot be adjusted to reflect the post-bump value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:120,Availability,mask,mask,120,"// Fail if the compare was not analyzed, or it's not comparing a register; // with an immediate value. Not checking the mask here, since we handle; // the individual compare opcodes (including A4_cmpb*) later on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:262,Modifiability,variab,variable,262,"/// Analyze the statements in a loop to determine if the loop has; /// a computable trip count and, if so, return a value that represents; /// the trip count expression.; ///; /// This function iterates over the phi nodes in the loop to check for; /// induction variable patterns that are used in the calculation for; /// the number of time the loop is executed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:171,Integrability,depend,depends,171,// Look for the cmp instruction to determine if we can get a useful trip; // count. The trip count can be either a register or an immediate. The; // location of the value depends upon the type (reg or imm).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:17,Integrability,wrap,wrap-arounds,17,// Avoid certain wrap-arounds. This doesn't detect all wrap-arounds.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:55,Integrability,wrap,wrap-arounds,55,// Avoid certain wrap-arounds. This doesn't detect all wrap-arounds.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:3,Safety,Avoid,Avoid,3,// Avoid certain wrap-arounds. This doesn't detect all wrap-arounds.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:44,Safety,detect,detect,44,// Avoid certain wrap-arounds. This doesn't detect all wrap-arounds.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:57,Availability,down,down,57,"// Loop going while iv is ""less"" with the iv value going down. Must wrap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:68,Integrability,wrap,wrap,68,"// Loop going while iv is ""less"" with the iv value going down. Must wrap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:69,Integrability,wrap,wrap,69,"// Loop going while iv is ""greater"" with the iv value going up. Must wrap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:96,Availability,avail,available,96,"// A general case: Start and End are some values, but the actual; // iteration count may not be available. If it is not, insert; // a computation of it into the preheader.; // If the induction variable bump is not a power of 2, quit.; // Othwerise we'd need a general integer division.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:216,Energy Efficiency,power,power,216,"// A general case: Start and End are some values, but the actual; // iteration count may not be available. If it is not, insert; // a computation of it into the preheader.; // If the induction variable bump is not a power of 2, quit.; // Othwerise we'd need a general integer division.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:193,Modifiability,variab,variable,193,"// A general case: Start and End are some values, but the actual; // iteration count may not be available. If it is not, insert; // a computation of it into the preheader.; // If the induction variable bump is not a power of 2, quit.; // Othwerise we'd need a general integer division.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:192,Availability,down,downwards,192,"// If Start is an immediate and End is a register, the trip count; // will be ""reg - imm"". Hexagon's ""subtract immediate"" instruction; // is actually ""reg + -imm"".; // If the loop IV is going downwards, i.e. if the bump is negative,; // then the iteration count (computed as End-Start) will need to be; // negated. To avoid the negation, just swap Start and End.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:318,Safety,avoid,avoid,318,"// If Start is an immediate and End is a register, the trip count; // will be ""reg - imm"". Hexagon's ""subtract immediate"" instruction; // is actually ""reg + -imm"".; // If the loop IV is going downwards, i.e. if the bump is negative,; // then the iteration count (computed as End-Start) will need to be; // negated. To avoid the negation, just swap Start and End.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:248,Safety,avoid,avoid,248,"// To compute the iteration count, we would need this computation:; // Count = (End - Start + (IVBump-1)) / IVBump; // or, when CmpHasEqual:; // Count = (End - Start + (IVBump-1)+1) / IVBump; // The ""IVBump-1"" part is the adjustment (AdjV). We can avoid; // generating an instruction specifically to add it if we can adjust; // the immediate values for Start or End.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:3,Safety,Avoid,Avoid,3,"// Avoid special case, where the start value is an imm(0).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:122,Safety,avoid,avoid,122,"// If the loop has been unrolled, we should use the original loop count; // instead of recalculating the value. This will avoid additional; // 'Add' instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:20,Energy Efficiency,power,power,20,// The IV bump is a power of two. Log_2(IV bump) is the shift amount.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:89,Performance,perform,perform,89,"/// Check if the loop is a candidate for converting to a hardware; /// loop. If so, then perform the transformation.; ///; /// This function works on innermost loops first. A loop can be converted; /// if it is a counting loop; either a register value or an immediate.; ///; /// The code makes several assumptions about the representation of the loop; /// in llvm.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:20,Modifiability,variab,variable,20,// Is the induction variable bump feeding the latch condition?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:21,Availability,avail,available,21,// Is the trip count available in the preheader?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:33,Modifiability,variab,variable,33,"/// Return true if the induction variable can underflow in the first iteration.; /// An example, is an initial unsigned value that is 0 and is decrement in the; /// first itertion of a do-while loop. In this case, we cannot generate a; /// hardware loop because the endloop instruction does not decrement the loop; /// counter if it is <= 1. We only need to perform this analysis if the; /// initial value is a register.; ///; /// This function assumes the initial value may underfow unless proven; /// otherwise. If the type is signed, then we don't care because signed; /// underflow is undefined. We attempt to prove the initial value is not; /// zero by perfoming a crude analysis of the loop counter. This function; /// checks if the initial value is used in any comparison prior to the loop; /// and, if so, assumes the comparison is a range check. This is inexact,; /// but will catch the simple cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:358,Performance,perform,perform,358,"/// Return true if the induction variable can underflow in the first iteration.; /// An example, is an initial unsigned value that is 0 and is decrement in the; /// first itertion of a do-while loop. In this case, we cannot generate a; /// hardware loop because the endloop instruction does not decrement the loop; /// counter if it is <= 1. We only need to perform this analysis if the; /// initial value is a register.; ///; /// This function assumes the initial value may underfow unless proven; /// otherwise. If the type is signed, then we don't care because signed; /// underflow is undefined. We attempt to prove the initial value is not; /// zero by perfoming a crude analysis of the loop counter. This function; /// checks if the initial value is used in any comparison prior to the loop; /// and, if so, assumes the comparison is a range check. This is inexact,; /// but will catch the simple cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:896,Usability,simpl,simple,896,"/// Return true if the induction variable can underflow in the first iteration.; /// An example, is an initial unsigned value that is 0 and is decrement in the; /// first itertion of a do-while loop. In this case, we cannot generate a; /// hardware loop because the endloop instruction does not decrement the loop; /// counter if it is <= 1. We only need to perform this analysis if the; /// initial value is a register.; ///; /// This function assumes the initial value may underfow unless proven; /// otherwise. If the type is signed, then we don't care because signed; /// underflow is undefined. We attempt to prove the initial value is not; /// zero by perfoming a crude analysis of the loop counter. This function; /// checks if the initial value is used in any comparison prior to the loop; /// and, if so, assumes the comparison is a range check. This is inexact,; /// but will catch the simple cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:197,Testability,test,test,197,"// Iterate over the uses of the initial value. If the initial value is used; // in a compare, then we assume this is a range check that ensures the loop; // doesn't underflow. This is not an exact test and should be improved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:97,Performance,perform,performed,97,// OK - this is a hack that needs to be improved. We really need to analyze; // the instructions performed on the initial value. This works on the simplest; // cases only.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:147,Usability,simpl,simplest,147,// OK - this is a hack that needs to be improved. We really need to analyze; // the instructions performed on the initial value. This works on the simplest; // cases only.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:23,Safety,avoid,avoid,23,"// Call recursively to avoid an extra check whether operand(1) is; // indeed an immediate (it could be a global address, for example),; // plus we can handle COPY at the same time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:37,Modifiability,variab,variables,37,"// Register candidates for induction variables, with their associated bumps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:109,Deployability,update,updated,109,"// This is a success. If the register used in the comparison is one that; // we have identified as a bumped (updated) induction register, there is; // nothing to do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:98,Modifiability,extend,extended,98,// Most comparisons of register against an immediate value allow; // the immediate to be constant-extended. There are some exceptions; // though. Make sure the new combination will work.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:3,Deployability,Update,Update,3,// Update the dominator information with the new preheader.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp:427,Energy Efficiency,schedul,scheduling,427,"//===-- HexagonHazardRecognizer.cpp - Hexagon Post RA Hazard Recognizer ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the hazard recognizer for scheduling on Hexagon.; // Use a DFA based hazard recognizer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp:54,Safety,Hazard,Hazard,54,"//===-- HexagonHazardRecognizer.cpp - Hexagon Post RA Hazard Recognizer ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the hazard recognizer for scheduling on Hexagon.; // Use a DFA based hazard recognizer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp:405,Safety,hazard,hazard,405,"//===-- HexagonHazardRecognizer.cpp - Hexagon Post RA Hazard Recognizer ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the hazard recognizer for scheduling on Hexagon.; // Use a DFA based hazard recognizer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp:470,Safety,hazard,hazard,470,"//===-- HexagonHazardRecognizer.cpp - Hexagon Post RA Hazard Recognizer ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the hazard recognizer for scheduling on Hexagon.; // Use a DFA based hazard recognizer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp:79,Safety,hazard,hazard,79,// The .new store version uses different resources so check if it; // causes a hazard.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp:330,Energy Efficiency,schedul,scheduled,330,"/// Handle the cases when we prefer one instruction over another. Case 1 - we; /// prefer not to generate multiple loads in the packet to avoid a potential; /// bank conflict. Case 2 - if a packet contains a dot cur instruction, then we; /// prefer the instruction that can use the dot cur result. However, if the use; /// is not scheduled in the same packet, then prefer other instructions in the; /// subsequent packet. Case 3 - we prefer a vector store that can be converted; /// to a .new store. The packetizer will not generate the .new store if the; /// store doesn't have resources to fit in the packet (but the .new store may; /// have resources). We attempt to schedule the store as soon as possible to; /// help packetize the two instructions together.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp:670,Energy Efficiency,schedul,schedule,670,"/// Handle the cases when we prefer one instruction over another. Case 1 - we; /// prefer not to generate multiple loads in the packet to avoid a potential; /// bank conflict. Case 2 - if a packet contains a dot cur instruction, then we; /// prefer the instruction that can use the dot cur result. However, if the use; /// is not scheduled in the same packet, then prefer other instructions in the; /// subsequent packet. Case 3 - we prefer a vector store that can be converted; /// to a .new store. The packetizer will not generate the .new store if the; /// store doesn't have resources to fit in the packet (but the .new store may; /// have resources). We attempt to schedule the store as soon as possible to; /// help packetize the two instructions together.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp:115,Performance,load,loads,115,"/// Handle the cases when we prefer one instruction over another. Case 1 - we; /// prefer not to generate multiple loads in the packet to avoid a potential; /// bank conflict. Case 2 - if a packet contains a dot cur instruction, then we; /// prefer the instruction that can use the dot cur result. However, if the use; /// is not scheduled in the same packet, then prefer other instructions in the; /// subsequent packet. Case 3 - we prefer a vector store that can be converted; /// to a .new store. The packetizer will not generate the .new store if the; /// store doesn't have resources to fit in the packet (but the .new store may; /// have resources). We attempt to schedule the store as soon as possible to; /// help packetize the two instructions together.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp:138,Safety,avoid,avoid,138,"/// Handle the cases when we prefer one instruction over another. Case 1 - we; /// prefer not to generate multiple loads in the packet to avoid a potential; /// bank conflict. Case 2 - if a packet contains a dot cur instruction, then we; /// prefer the instruction that can use the dot cur result. However, if the use; /// is not scheduled in the same packet, then prefer other instructions in the; /// subsequent packet. Case 3 - we prefer a vector store that can be converted; /// to a .new store. The packetizer will not generate the .new store if the; /// store doesn't have resources to fit in the packet (but the .new store may; /// have resources). We attempt to schedule the store as soon as possible to; /// help packetize the two instructions together.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp:8,Energy Efficiency,schedul,scheduling,8,"// When scheduling a dot cur instruction, check if there is an instruction; // that can use the dot cur in the same packet. If so, we'll attempt to; // schedule it before other instructions. We only do this if the load has a; // single zero-latency use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp:152,Energy Efficiency,schedul,schedule,152,"// When scheduling a dot cur instruction, check if there is an instruction; // that can use the dot cur in the same packet. If so, we'll attempt to; // schedule it before other instructions. We only do this if the load has a; // single zero-latency use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp:214,Performance,load,load,214,"// When scheduling a dot cur instruction, check if there is an instruction; // that can use the dot cur in the same packet. If so, we'll attempt to; // schedule it before other instructions. We only do this if the load has a; // single zero-latency use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp:241,Performance,latency,latency,241,"// When scheduling a dot cur instruction, check if there is an instruction; // that can use the dot cur in the same packet. If so, we'll attempt to; // schedule it before other instructions. We only do this if the load has a; // single zero-latency use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h:423,Energy Efficiency,schedul,scheduling,423,"//===--- HexagonHazardRecognizer.h - Hexagon Post RA Hazard Recognizer ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This file defines the hazard recognizer for scheduling on Hexagon.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h:53,Safety,Hazard,Hazard,53,"//===--- HexagonHazardRecognizer.h - Hexagon Post RA Hazard Recognizer ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This file defines the hazard recognizer for scheduling on Hexagon.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h:401,Safety,hazard,hazard,401,"//===--- HexagonHazardRecognizer.h - Hexagon Post RA Hazard Recognizer ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This file defines the hazard recognizer for scheduling on Hexagon.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h:84,Energy Efficiency,schedul,scheduling,84,// If the packet contains a potential dot cur instruction. This is; // used for the scheduling priority function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h:29,Performance,load,load,29,"// Does the packet contain a load. Used to restrict another load, if possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h:60,Performance,load,load,60,"// Does the packet contain a load. Used to restrict another load, if possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h:241,Availability,avail,available,241,"// Check if we should prefer a vector store that will become a .new version.; // The .new store uses different resources than a normal store, and the; // packetizer will not generate the .new if the regular store does not have; // resources available (even if the .new version does). To help, the schedule; // attempts to schedule the .new as soon as possible in the packet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h:297,Energy Efficiency,schedul,schedule,297,"// Check if we should prefer a vector store that will become a .new version.; // The .new store uses different resources than a normal store, and the; // packetizer will not generate the .new if the regular store does not have; // resources available (even if the .new version does). To help, the schedule; // attempts to schedule the .new as soon as possible in the packet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h:322,Energy Efficiency,schedul,schedule,322,"// Check if we should prefer a vector store that will become a .new version.; // The .new store uses different resources than a normal store, and the; // packetizer will not generate the .new if the regular store does not have; // resources available (even if the .new version does). To help, the schedule; // attempts to schedule the .new as soon as possible in the packet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h:82,Energy Efficiency,schedul,scheduled,82,/// This callback is invoked when a new block of instructions is about to be; /// scheduled. The hazard state is set to an initialized state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h:97,Safety,hazard,hazard,97,/// This callback is invoked when a new block of instructions is about to be; /// scheduled. The hazard state is set to an initialized state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h:266,Availability,avail,available,266,"/// Return the hazard type of emitting this node. There are three; /// possible results. Either:; /// * NoHazard: it is legal to issue this instruction on this cycle.; /// * Hazard: issuing this instruction would stall the machine. If some; /// other instruction is available, issue it first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h:15,Safety,hazard,hazard,15,"/// Return the hazard type of emitting this node. There are three; /// possible results. Either:; /// * NoHazard: it is legal to issue this instruction on this cycle.; /// * Hazard: issuing this instruction would stall the machine. If some; /// other instruction is available, issue it first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h:174,Safety,Hazard,Hazard,174,"/// Return the hazard type of emitting this node. There are three; /// possible results. Either:; /// * NoHazard: it is legal to issue this instruction on this cycle.; /// * Hazard: issuing this instruction would stall the machine. If some; /// other instruction is available, issue it first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h:66,Energy Efficiency,schedul,scheduled,66,"/// This callback is invoked when an instruction is emitted to be scheduled,; /// to advance the hazard state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h:97,Safety,hazard,hazard,97,"/// This callback is invoked when an instruction is emitted to be scheduled,; /// to advance the hazard state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h:153,Availability,avail,available,153,"/// This callback may be invoked if getHazardType returns NoHazard. If, even; /// though there is no hazard, it would be better to schedule another; /// available instruction, this callback should return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h:131,Energy Efficiency,schedul,schedule,131,"/// This callback may be invoked if getHazardType returns NoHazard. If, even; /// though there is no hazard, it would be better to schedule another; /// available instruction, this callback should return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h:101,Safety,hazard,hazard,101,"/// This callback may be invoked if getHazardType returns NoHazard. If, even; /// though there is no hazard, it would be better to schedule another; /// available instruction, this callback should return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h:51,Availability,down,down,51,"/// This callback is invoked whenever the next top-down instruction to be; /// scheduled cannot issue in the current cycle, either because of latency; /// or resource conflicts. This should increment the internal state of the; /// hazard recognizer so that previously ""Hazard"" instructions will now not; /// be hazards.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h:79,Energy Efficiency,schedul,scheduled,79,"/// This callback is invoked whenever the next top-down instruction to be; /// scheduled cannot issue in the current cycle, either because of latency; /// or resource conflicts. This should increment the internal state of the; /// hazard recognizer so that previously ""Hazard"" instructions will now not; /// be hazards.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h:142,Performance,latency,latency,142,"/// This callback is invoked whenever the next top-down instruction to be; /// scheduled cannot issue in the current cycle, either because of latency; /// or resource conflicts. This should increment the internal state of the; /// hazard recognizer so that previously ""Hazard"" instructions will now not; /// be hazards.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h:231,Safety,hazard,hazard,231,"/// This callback is invoked whenever the next top-down instruction to be; /// scheduled cannot issue in the current cycle, either because of latency; /// or resource conflicts. This should increment the internal state of the; /// hazard recognizer so that previously ""Hazard"" instructions will now not; /// be hazards.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h:269,Safety,Hazard,Hazard,269,"/// This callback is invoked whenever the next top-down instruction to be; /// scheduled cannot issue in the current cycle, either because of latency; /// or resource conflicts. This should increment the internal state of the; /// hazard recognizer so that previously ""Hazard"" instructions will now not; /// be hazards.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h:311,Safety,hazard,hazards,311,"/// This callback is invoked whenever the next top-down instruction to be; /// scheduled cannot issue in the current cycle, either because of latency; /// or resource conflicts. This should increment the internal state of the; /// hazard recognizer so that previously ""Hazard"" instructions will now not; /// be hazards.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:92,Modifiability,extend,extendend,92,// Check if the A2_tfrsi instruction is cheap or not. If the operand has; // to be constant-extendend it is not cheap since it occupies two slots; // in a packet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:110,Modifiability,extend,extended,110,"// If the instruction has a global address as operand, it is not cheap; // since the operand will be constant extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:77,Modifiability,extend,extended,77,"// If the instruction has an operand of size > 16bits, its will be; // const-extended and hence, it is not cheap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:48,Deployability,update,updates,48,"// Do not sink floating point instructions that updates USR register.; // Example:; // feclearexcept; // F2_conv_w2sf; // fetestexcept; // MachineSink sinks F2_conv_w2sf and we are not able to catch exceptions.; // TODO: On some of these floating point instructions, USR is marked as Use.; // In reality, these instructions also Def the USR. If USR is marked as Def,; // some of the assumptions in assembler packetization are broken.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:12,Integrability,depend,dependent,12,"// Position dependent, so check twice for swap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:80,Performance,load,load,80,"/// isLoadFromStackSlot - If the specified machine instruction is a direct; /// load from a stack slot, return the virtual or physical register number of; /// the destination along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than loading from the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:208,Performance,load,loaded,208,"/// isLoadFromStackSlot - If the specified machine instruction is a direct; /// load from a stack slot, return the virtual or physical register number of; /// the destination along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than loading from the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:335,Performance,load,loading,335,"/// isLoadFromStackSlot - If the specified machine instruction is a direct; /// load from a stack slot, return the virtual or physical register number of; /// the destination along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than loading from the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:205,Performance,load,loaded,205,"/// isStoreToStackSlot - If the specified machine instruction is a direct; /// store to a stack slot, return the virtual or physical register number of; /// the source reg along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than storing to the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:79,Performance,load,load,79,/// This function checks if the instruction or bundle of instructions; /// has load from stack slot and returns frameindex and machine memory; /// operand of that instruction if true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:337,Integrability,depend,depend,337,"/// This function can analyze one/two way branching only and should (mostly) be; /// called by target independent side.; /// First entry is always the opcode of the branching instruction, except when; /// the Cond vector is supposed to be empty, e.g., when analyzeBranch fails, a; /// BB with only unconditional jump. Subsequent entries depend upon the opcode,; /// e.g. Jump_c p will have; /// Cond[0] = Jump_c; /// Cond[1] = p; /// HW-loop ENDLOOP:; /// Cond[0] = ENDLOOP; /// Cond[1] = MBB; /// New value jump:; /// Cond[0] = Hexagon::CMPEQri_f_Jumpnv_t_V4 -- specific opcode; /// Cond[1] = R; /// Cond[2] = Imm",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:35,Performance,Optimiz,Optimization,35,"// Due to a bug in TailMerging/CFG Optimization, we need to add a; // special case handling of a predicated jump followed by an; // unconditional jump. If not, Tail Merging and CFG Optimization go; // into an infinite loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:181,Performance,Optimiz,Optimization,181,"// Due to a bug in TailMerging/CFG Optimization, we need to add a; // special case handling of a predicated jump followed by an; // unconditional jump. If not, Tail Merging and CFG Optimization go; // into an infinite loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:106,Deployability,update,update,106,"// The loop trip count is a run-time value. We generate code to subtract; // one from the trip count, and update the loop instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:223,Energy Efficiency,reduce,reduce,223,"// The call to the custom handler is being treated as a special one as the; // callee is responsible for saving and restoring all the registers; // (including caller saved registers) it needs to modify. This is; // done to reduce the impact of instrumentation on the code being; // instrumented/profiled.; // NOTE: R14, R15 and R28 are reserved for PLT handling. These registers; // are in the Def list of the Hexagon::PS_call_instrprof_custom and; // therefore will be handled appropriately duing register allocation.; // TODO: It may be a good idea to add a separate pseudo instruction for; // static relocation which doesn't need to reserve r14, r15 and r28.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:25,Performance,load,load,25,// Generate a misaligned load that is guaranteed to cause a crash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:14,Performance,load,load,14,// Misaligned load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:135,Safety,avoid,avoid,135,"// We have to predicate MI ""in place"", i.e. after this function returns,; // MI will need to be transformed into a predicated form. To avoid com-; // plicated manipulations with the operands (handling tied operands,; // etc.), build a new temporary instruction, then overwrite MI with it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:7,Performance,load,loads,7,"// HVX loads are not predicable on v60, but are on v62.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:25,Energy Efficiency,schedul,scheduling,25,"// Debug info is never a scheduling boundary. It's necessary to be explicit; // due to the special treatment of IT instructions below, otherwise a; // dbg_value followed by an IT will result in the IT instruction being; // considered a scheduling hazard, which is wrong. It should be the actual; // instruction preceding the dbg_value instruction(s), just like it is; // when debug info is not present.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:236,Energy Efficiency,schedul,scheduling,236,"// Debug info is never a scheduling boundary. It's necessary to be explicit; // due to the special treatment of IT instructions below, otherwise a; // dbg_value followed by an IT will result in the IT instruction being; // considered a scheduling hazard, which is wrong. It should be the actual; // instruction preceding the dbg_value instruction(s), just like it is; // when debug info is not present.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:247,Safety,hazard,hazard,247,"// Debug info is never a scheduling boundary. It's necessary to be explicit; // due to the special treatment of IT instructions below, otherwise a; // dbg_value followed by an IT will result in the IT instruction being; // considered a scheduling hazard, which is wrong. It should be the actual; // instruction preceding the dbg_value instruction(s), just like it is; // when debug info is not present.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:35,Energy Efficiency,schedul,scheduled,35,// Terminators and labels can't be scheduled around.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:335,Modifiability,Variab,Variable-length,335,"/// Measure the specified inline asm to determine an approximation of its; /// length.; /// Comments (which run till the next SeparatorString or newline) do not; /// count as an instruction.; /// Any other non-whitespace text is considered an instruction, with; /// multiple instructions separated by SeparatorString or newlines.; /// Variable-length instructions are not handled here; this function; /// may be overloaded in the target code to do that.; /// Hexagon counts the number of ##'s and adjust for that many; /// constant exenders.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:34,Modifiability,extend,extenders,34,// Add to size number of constant extenders seen * 4.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:7,Availability,mask,mask,7,// Set mask and the first source register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:82,Integrability,depend,dependent,82,"// Instructions that are pure loads, not loads and stores like memops are not; // dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:30,Performance,load,loads,30,"// Instructions that are pure loads, not loads and stores like memops are not; // dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:41,Performance,load,loads,41,"// Instructions that are pure loads, not loads and stores like memops are not; // dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:11,Security,access,access,11,// Get the access sizes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:17,Security,access,access,17,// This is a mem access with the same base register and known offsets from it.; // Reason about it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:23,Modifiability,extend,extended,23,// Instruction must be extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:85,Modifiability,extend,extended,85,"// If this is a Machine BB address we are talking about, and it is; // not marked as extended, say so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:44,Modifiability,extend,extendable,44,// We could be using an instruction with an extendable immediate and shoehorn; // a global address into it. If it is a global address it will be constant; // extended. We do this for COMBINE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:158,Modifiability,extend,extended,158,// We could be using an instruction with an extendable immediate and shoehorn; // a global address into it. If it is a global address it will be constant; // extended. We do this for COMBINE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:10,Modifiability,extend,extendable,10,"// If the extendable operand is not 'Immediate' type, the instruction should; // have 'isExtended' flag set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:13,Integrability,depend,dependency,13,// True data dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:82,Deployability,patch,patches,82,// TODO: This is largely obsolete now. Will need to be removed; // in consecutive patches.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:86,Modifiability,extend,extended,86,// This returns true in two cases:; // - The OP code itself indicates that this is an extended instruction.; // - One of MOs has been marked with HMOTF_ConstExtended flag.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:38,Modifiability,extend,extended,38,// First check if this is permanently extended op code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:196,Modifiability,extend,extendable,196,// Return true if a given MI can accommodate given offset.; // Use abs estimate as oppose to the exact number.; // TODO: This will need to be changed to use MC level; // definition of instruction extendable field size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:43,Modifiability,extend,extendable,43,// Returns true if a particular operand is extendable for an instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:3,Energy Efficiency,Schedul,Schedule,3,// Schedule this ASAP.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:50,Performance,Load,Load,50,// Check if the Offset is a valid auto-inc imm by Load/Store Type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:526,Performance,load,load,526,"// This function is to check whether the ""Offset"" is in the correct range of; // the given ""Opcode"". If ""Offset"" is not in the correct range, ""A2_addi"" is; // inserted to calculate the final address. Due to this reason, the function; // assumes that the ""Offset"" has correct alignment.; // We used to assert if the offset was not properly aligned, however,; // there are cases where a misaligned pointer recast can cause this; // problem, and we need to allow for it. The front end warns of such; // misaligns with respect to load size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:301,Testability,assert,assert,301,"// This function is to check whether the ""Offset"" is in the correct range of; // the given ""Opcode"". If ""Offset"" is not in the correct range, ""A2_addi"" is; // inserted to calculate the final address. Due to this reason, the function; // assumes that the ""Offset"" has correct alignment.; // We used to assert if the offset was not properly aligned, however,; // there are cases where a misaligned pointer recast can cause this; // problem, and we need to allow for it. The front end warns of such; // misaligns with respect to load size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:54,Modifiability,extend,extendable,54,// Handle these two compare instructions that are not extendable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:7,Performance,latency,latency,7,// Add latency to instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:47,Performance,load,load,47,/// Get the base register and byte offset of a load/store instr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:62,Modifiability,extend,extended,62,// Returns true if an instruction can be converted into a non-extended; // equivalent instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:87,Modifiability,extend,extended,87,"// Check if the instruction has a register form that uses register in place; // of the extended operand, if so return that as the non-extended form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:134,Modifiability,extend,extended,134,"// Check if the instruction has a register form that uses register in place; // of the extended operand, if so return that as the non-extended form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:3,Performance,Load,Load,3,// Load/store with absolute addressing mode can be converted into; // base+offset mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:3,Performance,Load,Load,3,// Load/store with base+offset addressing mode can be converted into; // base+register offset addressing mode. However left shift operand should; // be set to 0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:55,Performance,load,load,55,"// Returns true, if a LD insn can be promoted to a cur load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:52,Integrability,depend,dependent,52,// There is no stall when ProdMI and ConsMI are not dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:16,Energy Efficiency,Schedul,Scheduling,16,"// When Forward Scheduling is enabled, there is no stall if ProdMI and ConsMI; // are scheduled in consecutive packets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:86,Energy Efficiency,schedul,scheduled,86,"// When Forward Scheduling is enabled, there is no stall if ProdMI and ConsMI; // are scheduled in consecutive packets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:49,Performance,load,load,49,"// Returns the base register in a memory access (load/store). The offset is; // returned in Offset and the access size is returned in AccessSize.; // If the base operand has a subregister or the offset field does not contain; // an immediate value, return nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:41,Security,access,access,41,"// Returns the base register in a memory access (load/store). The offset is; // returned in Offset and the access size is returned in AccessSize.; // If the base operand has a subregister or the offset field does not contain; // an immediate value, return nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:107,Security,access,access,107,"// Returns the base register in a memory access (load/store). The offset is; // returned in Offset and the access size is returned in AccessSize.; // If the base operand has a subregister or the offset field does not contain; // an immediate value, return nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:134,Security,Access,AccessSize,134,"// Returns the base register in a memory access (load/store). The offset is; // returned in Offset and the access size is returned in AccessSize.; // If the base operand has a subregister or the offset field does not contain; // an immediate value, return nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:18,Deployability,update,updates,18,"// Post increment updates its EA after the mem access,; // so we need to treat its offset as zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:47,Security,access,access,47,"// Post increment updates its EA after the mem access,; // so we need to treat its offset as zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:42,Modifiability,extend,extended,42,// Returns Operand Index for the constant extended instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:68,Modifiability,extend,extended,68,// Rd = #u6; // Do not test for #u6 size since the const is getting extended; // regardless and compound could be formed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:23,Testability,test,test,23,// Rd = #u6; // Do not test for #u6 size since the const is getting extended; // regardless and compound could be formed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:80,Testability,test,test,80,// Transfer and jump:; // Rd=#U6 ; jump #r9:2; // Rd=Rs ; jump #r9:2; // Do not test for jump range here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:3040,Availability,failure,failure,3040,"cluded; // from the ""Conditional Store"" list. Because a predicated new value store; // would NOT be promoted to a double dot new store. See diagram below:; // This function returns yes for those stores that are predicated but not; // yet promoted to predicate dot new instructions.; //; // +---------------------+; // /-----| if (p0) memw(..)=r0 |---------\~; // || +---------------------+ ||; // promote || /\ /\ || promote; // || /||\ /||\ ||; // \||/ demote || \||/; // \/ || || \/; // +-------------------------+ || +-------------------------+; // | if (p0.new) memw(..)=r0 | || | if (p0) memw(..)=r0.new |; // +-------------------------+ || +-------------------------+; // || || ||; // || demote \||/; // promote || \/ NOT possible; // || || /\~; // \||/ || /||\~; // \/ || ||; // +-----------------------------+; // | if (p0.new) memw(..)=r0.new |; // +-----------------------------+; // Double Dot New Store; //; // Returns the most basic instruction for the .new predicated instructions and; // new-value stores.; // For example, all of the following instructions will be converted back to the; // same instruction:; // 1) if (p0.new) memw(R0+#0) = R1.new --->; // 2) if (p0) memw(R0+#0)= R1.new -------> if (p0) memw(R0+#0) = R1; // 3) if (p0.new) memw(R0+#0) = R1 --->; //; // To understand the translation of instruction 1 to its original form, consider; // a packet with 3 instructions.; // { p0 = cmp.eq(R0,R1); // if (p0.new) R2 = add(R3, R4); // R5 = add (R3, R1); // }; // if (p0) memw(R5+#0) = R2 <--- trying to include it in the previous packet; //; // This instruction can be part of the previous packet only if both p0 and R2; // are promoted to .new values. This promotion happens in steps, first; // predicate register is promoted to .new and in the next iteration R2 is; // promoted. Therefore, in case of dependence check failure (due to R5) during; // next iteration, it should be converted back to its most basic form.; // Return the new value instruction for a given store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:3023,Integrability,depend,dependence,3023,"cluded; // from the ""Conditional Store"" list. Because a predicated new value store; // would NOT be promoted to a double dot new store. See diagram below:; // This function returns yes for those stores that are predicated but not; // yet promoted to predicate dot new instructions.; //; // +---------------------+; // /-----| if (p0) memw(..)=r0 |---------\~; // || +---------------------+ ||; // promote || /\ /\ || promote; // || /||\ /||\ ||; // \||/ demote || \||/; // \/ || || \/; // +-------------------------+ || +-------------------------+; // | if (p0.new) memw(..)=r0 | || | if (p0) memw(..)=r0.new |; // +-------------------------+ || +-------------------------+; // || || ||; // || demote \||/; // promote || \/ NOT possible; // || || /\~; // \||/ || /||\~; // \/ || ||; // +-----------------------------+; // | if (p0.new) memw(..)=r0.new |; // +-----------------------------+; // Double Dot New Store; //; // Returns the most basic instruction for the .new predicated instructions and; // new-value stores.; // For example, all of the following instructions will be converted back to the; // same instruction:; // 1) if (p0.new) memw(R0+#0) = R1.new --->; // 2) if (p0) memw(R0+#0)= R1.new -------> if (p0) memw(R0+#0) = R1; // 3) if (p0.new) memw(R0+#0) = R1 --->; //; // To understand the translation of instruction 1 to its original form, consider; // a packet with 3 instructions.; // { p0 = cmp.eq(R0,R1); // if (p0.new) R2 = add(R3, R4); // R5 = add (R3, R1); // }; // if (p0) memw(R5+#0) = R2 <--- trying to include it in the previous packet; //; // This instruction can be part of the previous packet only if both p0 and R2; // are promoted to .new values. This promotion happens in steps, first; // predicate register is promoted to .new and in the next iteration R2 is; // promoted. Therefore, in case of dependence check failure (due to R5) during; // next iteration, it should be converted back to its most basic form.; // Return the new value instruction for a given store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:34,Safety,predict,prediction,34,"// All Hexagon architectures have prediction bits on dot-new branches,; // but only Hexagon V60+ has prediction bits on dot-old ones. Make sure; // to pick the right opcode when converting back to dot-old.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:101,Safety,predict,prediction,101,"// All Hexagon architectures have prediction bits on dot-new branches,; // but only Hexagon V60+ has prediction bits on dot-old ones. Make sure; // to pick the right opcode when converting back to dot-old.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:68,Modifiability,extend,extended,68,// Rd = #u6; // Do not test for #u6 size since the const is getting extended; // regardless and compound could be formed.; // Rd = #-1,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:23,Testability,test,test,23,// Rd = #u6; // Do not test for #u6 size since the const is getting extended; // regardless and compound could be formed.; // Rd = #-1,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:135,Energy Efficiency,schedul,scheduling,135,"/// getOperandLatency - Compute and return the use operand latency of a given; /// pair of def and use.; /// In most cases, the static scheduling itinerary was enough to determine the; /// operand latency. But it may not be possible for instructions with variable; /// number of defs / uses.; ///; /// This is a raw interface to the itinerary that may be directly overriden by; /// a target. Use computeOperandLatency to get the best estimate of latency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:316,Integrability,interface,interface,316,"/// getOperandLatency - Compute and return the use operand latency of a given; /// pair of def and use.; /// In most cases, the static scheduling itinerary was enough to determine the; /// operand latency. But it may not be possible for instructions with variable; /// number of defs / uses.; ///; /// This is a raw interface to the itinerary that may be directly overriden by; /// a target. Use computeOperandLatency to get the best estimate of latency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:255,Modifiability,variab,variable,255,"/// getOperandLatency - Compute and return the use operand latency of a given; /// pair of def and use.; /// In most cases, the static scheduling itinerary was enough to determine the; /// operand latency. But it may not be possible for instructions with variable; /// number of defs / uses.; ///; /// This is a raw interface to the itinerary that may be directly overriden by; /// a target. Use computeOperandLatency to get the best estimate of latency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:59,Performance,latency,latency,59,"/// getOperandLatency - Compute and return the use operand latency of a given; /// pair of def and use.; /// In most cases, the static scheduling itinerary was enough to determine the; /// operand latency. But it may not be possible for instructions with variable; /// number of defs / uses.; ///; /// This is a raw interface to the itinerary that may be directly overriden by; /// a target. Use computeOperandLatency to get the best estimate of latency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:197,Performance,latency,latency,197,"/// getOperandLatency - Compute and return the use operand latency of a given; /// pair of def and use.; /// In most cases, the static scheduling itinerary was enough to determine the; /// operand latency. But it may not be possible for instructions with variable; /// number of defs / uses.; ///; /// This is a raw interface to the itinerary that may be directly overriden by; /// a target. Use computeOperandLatency to get the best estimate of latency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:446,Performance,latency,latency,446,"/// getOperandLatency - Compute and return the use operand latency of a given; /// pair of def and use.; /// In most cases, the static scheduling itinerary was enough to determine the; /// operand latency. But it may not be possible for instructions with variable; /// number of defs / uses.; ///; /// This is a raw interface to the itinerary that may be directly overriden by; /// a target. Use computeOperandLatency to get the best estimate of latency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:32,Performance,latency,latency,32,"// We should never have 0 cycle latency between two instructions unless; // they can be packetized together. However, this decision can't be made; // here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:27,Testability,log,logic,27,// inverts the predication logic.; // p -> NotP; // NotP -> P,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:49,Modifiability,extend,extended,49,// Returns the max value that doesn't need to be extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:29,Energy Efficiency,Schedul,Scheduler,29,"// Workaround for the Global Scheduler. Sometimes, it creates; // A4_ext as a Pseudo instruction and calls this function to see if; // it can be added to an existing bundle. Since the instruction doesn't; // belong to any BB yet, we can't use getUnits API.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:17,Security,access,access,17,// Handle vector access sizes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:49,Modifiability,extend,extended,49,// Returns the min value that doesn't need to be extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:29,Modifiability,extend,extended,29,// Returns opcode of the non-extended equivalent instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:87,Modifiability,extend,extended,87,"// Check if the instruction has a register form that uses register in place; // of the extended operand, if so return that as the non-extended form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:134,Modifiability,extend,extended,134,"// Check if the instruction has a register form that uses register in place; // of the extended operand, if so return that as the non-extended form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:149,Modifiability,extend,extender,149,"// Return the number of bytes required to encode the instruction.; // Hexagon instructions are fixed length, 4 bytes, unless they; // use a constant extender, which requires another 4 bytes.; // For debug instructions and prolog labels, return 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:86,Modifiability,extend,extender,86,/// immediateExtend - Changes the instruction in place to one using an immediate; /// extender.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:25,Modifiability,extend,extendable,25,// Find which operand is extendable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:25,Modifiability,extend,extended,25,// Mark given operand as extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:27,Testability,log,logic,27,// inverts the predication logic.; // p -> NotP; // NotP -> P,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:22,Safety,predict,prediction,22,// Reverse the branch prediction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:27,Security,validat,validation,27,// TODO: Add more rigorous validation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h:90,Performance,load,load,90,"/// TargetInstrInfo overrides.; /// If the specified machine instruction is a direct; /// load from a stack slot, return the virtual or physical register number of; /// the destination along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than loading from the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h:218,Performance,load,loaded,218,"/// TargetInstrInfo overrides.; /// If the specified machine instruction is a direct; /// load from a stack slot, return the virtual or physical register number of; /// the destination along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than loading from the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h:345,Performance,load,loading,345,"/// TargetInstrInfo overrides.; /// If the specified machine instruction is a direct; /// load from a stack slot, return the virtual or physical register number of; /// the destination along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than loading from the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h:184,Performance,load,loaded,184,"/// If the specified machine instruction is a direct; /// store to a stack slot, return the virtual or physical register number of; /// the source reg along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than storing to the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h:68,Performance,load,load,68,/// Check if the instruction or the bundle of instructions has; /// load from stack slots. Return the frameindex and machine memory operand; /// if true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h:1294,Integrability,rout,routine,1294,"/// Analyze the branching code at the end of MBB, returning; /// true if it cannot be understood (e.g. it's a switch dispatch or isn't; /// implemented for a target). Upon success, this returns false and returns; /// with the following information in various cases:; ///; /// 1. If this block ends with no branches (it just falls through to its succ); /// just return false, leaving TBB/FBB null.; /// 2. If this block ends with only an unconditional branch, it sets TBB to be; /// the destination block.; /// 3. If this block ends with a conditional branch and it falls through to a; /// successor block, it sets TBB to be the branch destination block and a; /// list of operands that evaluate the condition. These operands can be; /// passed to other TargetInstrInfo methods to create new branches.; /// 4. If this block ends with a conditional branch followed by an; /// unconditional branch, it returns the 'true' destination in TBB, the; /// 'false' destination in FBB, and a list of operands that evaluate the; /// condition. These operands can be passed to other TargetInstrInfo; /// methods to create new branches.; ///; /// Note that removeBranch and insertBranch must be implemented to support; /// cases where this method returns success.; ///; /// If AllowModify is true, then this routine is allowed to modify the basic; /// block (e.g. delete instructions after the unconditional branch).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h:123,Deployability,Pipeline,PipelinerLoopInfo,123,"/// Analyze loop L, which must be a single-basic-block loop, and if the; /// conditions can be understood enough produce a PipelinerLoopInfo object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h:95,Performance,latency,latency,95,"/// Return true if it's profitable to predicate; /// instructions with accumulated instruction latency of ""NumCycles""; /// of the specified basic block, where the probability of the instructions; /// being executed is given by Probability, and Confidence is a measure; /// of our confidence that it will be properly predicted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h:316,Safety,predict,predicted,316,"/// Return true if it's profitable to predicate; /// instructions with accumulated instruction latency of ""NumCycles""; /// of the specified basic block, where the probability of the instructions; /// being executed is given by Probability, and Confidence is a measure; /// of our confidence that it will be properly predicted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h:368,Safety,predict,predicted,368,"/// Second variant of isProfitableToIfCvt. This one; /// checks for the case where two basic blocks from true and false path; /// of a if-then-else (diamond) are predicated on mutally exclusive; /// predicates, where the probability of the true path being taken is given; /// by Probability, and Confidence is a measure of our confidence that it; /// will be properly predicted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h:343,Safety,predict,predicted,343,"/// Return true if it's profitable for if-converter to duplicate instructions; /// of specified accumulated instruction latencies in the specified MBB to; /// enable if-conversion.; /// The probability of the instructions being executed is given by; /// Probability, and Confidence is a measure of our confidence that it; /// will be properly predicted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h:4,Performance,Load,Load,4,/// Load the specified register of the given register class from the specified; /// stack frame index. The load instruction is to be added to the given; /// machine basic block before the specified machine instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h:107,Performance,load,load,107,/// Load the specified register of the given register class from the specified; /// stack frame index. The load instruction is to be added to the given; /// machine basic block before the specified machine instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h:47,Performance,load,load,47,/// Get the base register and byte offset of a load/store instr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h:57,Energy Efficiency,schedul,scheduling,57,/// Test if the given instruction should be considered a scheduling boundary.; /// This primarily includes labels and terminators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h:4,Testability,Test,Test,4,/// Test if the given instruction should be considered a scheduling boundary.; /// This primarily includes labels and terminators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h:4,Energy Efficiency,Allocate,Allocate,4,/// Allocate and return a hazard recognizer to use for this target when; /// scheduling the machine instructions after register allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h:77,Energy Efficiency,schedul,scheduling,77,/// Allocate and return a hazard recognizer to use for this target when; /// scheduling the machine instructions after register allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h:26,Safety,hazard,hazard,26,/// Allocate and return a hazard recognizer to use for this target when; /// scheduling the machine instructions after register allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h:28,Performance,latency,latency,28,"/// Compute the instruction latency of a given instruction.; /// If the instruction has higher cost when predicated, it's returned via; /// PredCost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h:38,Energy Efficiency,schedul,scheduling,38,/// Create machine specific model for scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h:105,Security,access,access,105,"// Sometimes, it is possible for the target; // to tell, even without aliasing information, that two MIs access different; // memory addresses. This function returns true if two MIs access different; // memory addresses and false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h:182,Security,access,access,182,"// Sometimes, it is possible for the target; // to tell, even without aliasing information, that two MIs access different; // memory addresses. This function returns true if two MIs access different; // memory addresses and false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h:135,Energy Efficiency,schedul,scheduling,135,"/// getOperandLatency - Compute and return the use operand latency of a given; /// pair of def and use.; /// In most cases, the static scheduling itinerary was enough to determine the; /// operand latency. But it may not be possible for instructions with variable; /// number of defs / uses.; ///; /// This is a raw interface to the itinerary that may be directly overriden by; /// a target. Use computeOperandLatency to get the best estimate of latency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h:316,Integrability,interface,interface,316,"/// getOperandLatency - Compute and return the use operand latency of a given; /// pair of def and use.; /// In most cases, the static scheduling itinerary was enough to determine the; /// operand latency. But it may not be possible for instructions with variable; /// number of defs / uses.; ///; /// This is a raw interface to the itinerary that may be directly overriden by; /// a target. Use computeOperandLatency to get the best estimate of latency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h:255,Modifiability,variab,variable,255,"/// getOperandLatency - Compute and return the use operand latency of a given; /// pair of def and use.; /// In most cases, the static scheduling itinerary was enough to determine the; /// operand latency. But it may not be possible for instructions with variable; /// number of defs / uses.; ///; /// This is a raw interface to the itinerary that may be directly overriden by; /// a target. Use computeOperandLatency to get the best estimate of latency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h:59,Performance,latency,latency,59,"/// getOperandLatency - Compute and return the use operand latency of a given; /// pair of def and use.; /// In most cases, the static scheduling itinerary was enough to determine the; /// operand latency. But it may not be possible for instructions with variable; /// number of defs / uses.; ///; /// This is a raw interface to the itinerary that may be directly overriden by; /// a target. Use computeOperandLatency to get the best estimate of latency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h:197,Performance,latency,latency,197,"/// getOperandLatency - Compute and return the use operand latency of a given; /// pair of def and use.; /// In most cases, the static scheduling itinerary was enough to determine the; /// operand latency. But it may not be possible for instructions with variable; /// number of defs / uses.; ///; /// This is a raw interface to the itinerary that may be directly overriden by; /// a target. Use computeOperandLatency to get the best estimate of latency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h:446,Performance,latency,latency,446,"/// getOperandLatency - Compute and return the use operand latency of a given; /// pair of def and use.; /// In most cases, the static scheduling itinerary was enough to determine the; /// operand latency. But it may not be possible for instructions with variable; /// number of defs / uses.; ///; /// This is a raw interface to the itinerary that may be directly overriden by; /// a target. Use computeOperandLatency to get the best estimate of latency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h:130,Safety,safe,safe,130,// Return true if the instruction should be sunk by MachineSink.; // MachineSink determines on its own whether the instruction is safe to sink;; // this gives the target a hook to override the default behavior with regards; // to which instructions should be sunk.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h:128,Availability,avail,available,128,"/// getInstrTimingClassLatency - Compute the instruction latency of a given; /// instruction using Timing Class information, if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h:57,Performance,latency,latency,57,"/// getInstrTimingClassLatency - Compute the instruction latency of a given; /// instruction using Timing Class information, if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h:155,Energy Efficiency,consumption,consumption,155,"// When TinyCore with Duplexes is enabled, this function is used to translate; // tiny-instructions to big-instructions and vice versa to get the slot; // consumption.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:118,Energy Efficiency,schedul,scheduling,118,"/// createHexagonISelDag - This pass converts a legalized DAG into a; /// Hexagon-specific DAG, ready for instruction scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:18,Modifiability,extend,extended,18,// Check for zero extended loads. Treat any-extend loads as zero extended; // loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:44,Modifiability,extend,extend,44,// Check for zero extended loads. Treat any-extend loads as zero extended; // loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:65,Modifiability,extend,extended,65,// Check for zero extended loads. Treat any-extend loads as zero extended; // loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:27,Performance,load,loads,27,// Check for zero extended loads. Treat any-extend loads as zero extended; // loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:51,Performance,load,loads,51,// Check for zero extended loads. Treat any-extend loads as zero extended; // loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:78,Performance,load,loads,78,// Check for zero extended loads. Treat any-extend loads as zero extended; // loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:3,Performance,Load,Loaded,3,// Loaded value Next address Chain,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:10,Modifiability,extend,extending,10,"// A load extending to i64 will actually produce i32, which will then; // need to be extended to i64.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:85,Modifiability,extend,extended,85,"// A load extending to i64 will actually produce i32, which will then; // need to be extended to i64.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:5,Performance,load,load,5,"// A load extending to i64 will actually produce i32, which will then; // need to be extended to i64.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:11,Modifiability,extend,extended,11,// Loaded (extended) value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:3,Performance,Load,Loaded,3,// Loaded (extended) value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:11,Modifiability,extend,extended,11,// Loaded (extended) value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:3,Performance,Load,Loaded,3,// Loaded (extended) value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:8,Performance,Load,LoadN,8,"// The ""LoadN"" is just a machine load instruction. The intrinsic also; // involves storing it. Generate an appropriate store to the location; // given in the intrinsic's operand(3).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:33,Performance,load,load,33,"// The ""LoadN"" is just a machine load instruction. The intrinsic also; // involves storing it. Generate an appropriate store to the location; // given in the intrinsic's operand(3).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:38,Deployability,Update,Updated,38,"// Load's results are { Loaded value, Updated pointer, Chain }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:3,Performance,Load,Load,3,"// Load's results are { Loaded value, Updated pointer, Chain }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:24,Performance,Load,Loaded,24,"// Load's results are { Loaded value, Updated pointer, Chain }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:22,Performance,load,load,22,"// The intrinsics for load circ/brev perform two operations:; // 1. Load a value V from the specified location, using the addressing; // mode corresponding to the intrinsic.; // 2. Store V into a specified location. This location is typically a; // local, temporary object.; // In many cases, the program using these intrinsics will immediately; // load V again from the local object. In those cases, when certain; // conditions are met, the last load can be removed.; // This function identifies and optimizes this pattern. If the pattern; // cannot be optimized, it returns nullptr, which will cause the load; // to be selected separately from the intrinsic (which will be handled; // in SelectIntrinsicWChain).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:37,Performance,perform,perform,37,"// The intrinsics for load circ/brev perform two operations:; // 1. Load a value V from the specified location, using the addressing; // mode corresponding to the intrinsic.; // 2. Store V into a specified location. This location is typically a; // local, temporary object.; // In many cases, the program using these intrinsics will immediately; // load V again from the local object. In those cases, when certain; // conditions are met, the last load can be removed.; // This function identifies and optimizes this pattern. If the pattern; // cannot be optimized, it returns nullptr, which will cause the load; // to be selected separately from the intrinsic (which will be handled; // in SelectIntrinsicWChain).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:68,Performance,Load,Load,68,"// The intrinsics for load circ/brev perform two operations:; // 1. Load a value V from the specified location, using the addressing; // mode corresponding to the intrinsic.; // 2. Store V into a specified location. This location is typically a; // local, temporary object.; // In many cases, the program using these intrinsics will immediately; // load V again from the local object. In those cases, when certain; // conditions are met, the last load can be removed.; // This function identifies and optimizes this pattern. If the pattern; // cannot be optimized, it returns nullptr, which will cause the load; // to be selected separately from the intrinsic (which will be handled; // in SelectIntrinsicWChain).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:349,Performance,load,load,349,"// The intrinsics for load circ/brev perform two operations:; // 1. Load a value V from the specified location, using the addressing; // mode corresponding to the intrinsic.; // 2. Store V into a specified location. This location is typically a; // local, temporary object.; // In many cases, the program using these intrinsics will immediately; // load V again from the local object. In those cases, when certain; // conditions are met, the last load can be removed.; // This function identifies and optimizes this pattern. If the pattern; // cannot be optimized, it returns nullptr, which will cause the load; // to be selected separately from the intrinsic (which will be handled; // in SelectIntrinsicWChain).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:447,Performance,load,load,447,"// The intrinsics for load circ/brev perform two operations:; // 1. Load a value V from the specified location, using the addressing; // mode corresponding to the intrinsic.; // 2. Store V into a specified location. This location is typically a; // local, temporary object.; // In many cases, the program using these intrinsics will immediately; // load V again from the local object. In those cases, when certain; // conditions are met, the last load can be removed.; // This function identifies and optimizes this pattern. If the pattern; // cannot be optimized, it returns nullptr, which will cause the load; // to be selected separately from the intrinsic (which will be handled; // in SelectIntrinsicWChain).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:501,Performance,optimiz,optimizes,501,"// The intrinsics for load circ/brev perform two operations:; // 1. Load a value V from the specified location, using the addressing; // mode corresponding to the intrinsic.; // 2. Store V into a specified location. This location is typically a; // local, temporary object.; // In many cases, the program using these intrinsics will immediately; // load V again from the local object. In those cases, when certain; // conditions are met, the last load can be removed.; // This function identifies and optimizes this pattern. If the pattern; // cannot be optimized, it returns nullptr, which will cause the load; // to be selected separately from the intrinsic (which will be handled; // in SelectIntrinsicWChain).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:554,Performance,optimiz,optimized,554,"// The intrinsics for load circ/brev perform two operations:; // 1. Load a value V from the specified location, using the addressing; // mode corresponding to the intrinsic.; // 2. Store V into a specified location. This location is typically a; // local, temporary object.; // In many cases, the program using these intrinsics will immediately; // load V again from the local object. In those cases, when certain; // conditions are met, the last load can be removed.; // This function identifies and optimizes this pattern. If the pattern; // cannot be optimized, it returns nullptr, which will cause the load; // to be selected separately from the intrinsic (which will be handled; // in SelectIntrinsicWChain).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:606,Performance,load,load,606,"// The intrinsics for load circ/brev perform two operations:; // 1. Load a value V from the specified location, using the addressing; // mode corresponding to the intrinsic.; // 2. Store V into a specified location. This location is typically a; // local, temporary object.; // In many cases, the program using these intrinsics will immediately; // load V again from the local object. In those cases, when certain; // conditions are met, the last load can be removed.; // This function identifies and optimizes this pattern. If the pattern; // cannot be optimized, it returns nullptr, which will cause the load; // to be selected separately from the intrinsic (which will be handled; // in SelectIntrinsicWChain).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:19,Performance,load,load,19,"// Assume that the load and the intrinsic are connected directly with a; // chain:; // t1: i32,ch = int.load ..., ..., ..., Loc, ... // <-- C; // t2: i32,ch = load t1:1, Loc, ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:104,Performance,load,load,104,"// Assume that the load and the intrinsic are connected directly with a; // chain:; // t1: i32,ch = int.load ..., ..., ..., Loc, ... // <-- C; // t2: i32,ch = load t1:1, Loc, ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:159,Performance,load,load,159,"// Assume that the load and the intrinsic are connected directly with a; // chain:; // t1: i32,ch = int.load ..., ..., ..., Loc, ... // <-- C; // t2: i32,ch = load t1:1, Loc, ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:188,Modifiability,variab,variable,188,// The second load can only be eliminated if its extension type matches; // that of the load instruction corresponding to the intrinsic. The user; // can provide an address of an unsigned variable to store the result of; // a sign-extending intrinsic into (or the other way around).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:231,Modifiability,extend,extending,231,// The second load can only be eliminated if its extension type matches; // that of the load instruction corresponding to the intrinsic. The user; // can provide an address of an unsigned variable to store the result of; // a sign-extending intrinsic into (or the other way around).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:14,Performance,load,load,14,// The second load can only be eliminated if its extension type matches; // that of the load instruction corresponding to the intrinsic. The user; // can provide an address of an unsigned variable to store the result of; // a sign-extending intrinsic into (or the other way around).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:88,Performance,load,load,88,// The second load can only be eliminated if its extension type matches; // that of the load instruction corresponding to the intrinsic. The user; // can provide an address of an unsigned variable to store the result of; // a sign-extending intrinsic into (or the other way around).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:41,Performance,load,loaded,41,// Make sure the target location for the loaded value in the load intrinsic; // is the location from which LD (or N) is loading.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:61,Performance,load,load,61,// Make sure the target location for the loaded value in the load intrinsic; // is the location from which LD (or N) is loading.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:120,Performance,load,loading,120,// Make sure the target location for the loaded value in the load intrinsic; // is the location from which LD (or N) is loading.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:138,Performance,load,load,138,"// This transformation will leave the intrinsic dead. If it remains in; // the DAG, the selection code will see it again, but without the load,; // and it will generate a store that is normally required for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:27,Performance,load,load,27,// Convert the bit-reverse load intrinsic to appropriate target instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:10,Performance,load,load,10,// Handle load.*_pci case which has 6 operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:10,Performance,load,load,10,"// Handle load.*_pcr case which has 5 operands.; // Operands: { Base, Modifier, Start, Chain }.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:18,Performance,load,loads,18,// Handle indexed loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:35,Performance,load,load,35,// Handle patterns using circ/brev load intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:40,Performance,load,load,40,//; // Handling intrinsics for circular load and bitreverse load.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:60,Performance,load,load,60,//; // Handling intrinsics for circular load and bitreverse load.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:22,Performance,load,load,22,// Handle bit-reverse load intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:146,Energy Efficiency,allocate,allocated,146,"// Use PS_fi when:; // - the object is fixed, or; // - there are no objects with higher-than-default alignment, or; // - there are no dynamically allocated objects.; // Otherwise, use PS_fia.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:30,Safety,avoid,avoid,30,"// Handle these nodes here to avoid having to write patterns for all; // combinations of input/output types. In all cases, the resulting; // instruction is the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:124,Performance,load,loaded,124,"// I is an operand of U. Check if U is an arithmetic (binary) operation; // usable in a memop, where the other operand is a loaded value, and the; // result of U is stored in the same location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:76,Usability,usab,usable,76,"// I is an operand of U. Check if U is an arithmetic (binary) operation; // usable in a memop, where the other operand is a loaded value, and the; // result of U is stored in the same location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:40,Performance,load,load,40,"// Check if one of the inputs to U is a load instruction and the output; // is used by a store instruction. If so and they also have the same; // base pointer, then don't preoprocess this node sequence as it; // can be matched to a memop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:200,Performance,load,loads,200,"// Transform: (store ch val (add x (add (shl y c) e))); // to: (store ch val (add x (shl (add y d) c))),; // where e = (shl d c) for some integer d.; // The purpose of this is to enable generation of loads/stores with; // shifted addressing mode, i.e. mem(x+y<<#c). For that, the shift; // value c must be 0, 1 or 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:45,Availability,Mask,Mask,45,"// Transform: (load ch (add x (and (srl y c) Mask))); // to: (load ch (add x (shl (srl y d) d-c))); // where; // Mask = 00..0 111..1 0.0; // | | +-- d-c 0s, and d-c is 0, 1 or 2.; // | +-------- 1s; // +-------------- at most c 0s; // Motivating example:; // DAG combiner optimizes (add x (shl (srl y 5) 2)); // to (add x (and (srl y 3) 1FFFFFFC)); // which results in a constant-extended and(##...,lsr). This transformation; // undoes this simplification for cases where the shl can be folded into; // an addressing mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:113,Availability,Mask,Mask,113,"// Transform: (load ch (add x (and (srl y c) Mask))); // to: (load ch (add x (shl (srl y d) d-c))); // where; // Mask = 00..0 111..1 0.0; // | | +-- d-c 0s, and d-c is 0, 1 or 2.; // | +-------- 1s; // +-------------- at most c 0s; // Motivating example:; // DAG combiner optimizes (add x (shl (srl y 5) 2)); // to (add x (and (srl y 3) 1FFFFFFC)); // which results in a constant-extended and(##...,lsr). This transformation; // undoes this simplification for cases where the shl can be folded into; // an addressing mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:380,Modifiability,extend,extended,380,"// Transform: (load ch (add x (and (srl y c) Mask))); // to: (load ch (add x (shl (srl y d) d-c))); // where; // Mask = 00..0 111..1 0.0; // | | +-- d-c 0s, and d-c is 0, 1 or 2.; // | +-------- 1s; // +-------------- at most c 0s; // Motivating example:; // DAG combiner optimizes (add x (shl (srl y 5) 2)); // to (add x (and (srl y 3) 1FFFFFFC)); // which results in a constant-extended and(##...,lsr). This transformation; // undoes this simplification for cases where the shl can be folded into; // an addressing mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:15,Performance,load,load,15,"// Transform: (load ch (add x (and (srl y c) Mask))); // to: (load ch (add x (shl (srl y d) d-c))); // where; // Mask = 00..0 111..1 0.0; // | | +-- d-c 0s, and d-c is 0, 1 or 2.; // | +-------- 1s; // +-------------- at most c 0s; // Motivating example:; // DAG combiner optimizes (add x (shl (srl y 5) 2)); // to (add x (and (srl y 3) 1FFFFFFC)); // which results in a constant-extended and(##...,lsr). This transformation; // undoes this simplification for cases where the shl can be folded into; // an addressing mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:62,Performance,load,load,62,"// Transform: (load ch (add x (and (srl y c) Mask))); // to: (load ch (add x (shl (srl y d) d-c))); // where; // Mask = 00..0 111..1 0.0; // | | +-- d-c 0s, and d-c is 0, 1 or 2.; // | +-------- 1s; // +-------------- at most c 0s; // Motivating example:; // DAG combiner optimizes (add x (shl (srl y 5) 2)); // to (add x (and (srl y 3) 1FFFFFFC)); // which results in a constant-extended and(##...,lsr). This transformation; // undoes this simplification for cases where the shl can be folded into; // an addressing mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:272,Performance,optimiz,optimizes,272,"// Transform: (load ch (add x (and (srl y c) Mask))); // to: (load ch (add x (shl (srl y d) d-c))); // where; // Mask = 00..0 111..1 0.0; // | | +-- d-c 0s, and d-c is 0, 1 or 2.; // | +-------- 1s; // +-------------- at most c 0s; // Motivating example:; // DAG combiner optimizes (add x (shl (srl y 5) 2)); // to (add x (and (srl y 3) 1FFFFFFC)); // which results in a constant-extended and(##...,lsr). This transformation; // undoes this simplification for cases where the shl can be folded into; // an addressing mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:429,Usability,undo,undoes,429,"// Transform: (load ch (add x (and (srl y c) Mask))); // to: (load ch (add x (shl (srl y d) d-c))); // where; // Mask = 00..0 111..1 0.0; // | | +-- d-c 0s, and d-c is 0, 1 or 2.; // | +-------- 1s; // +-------------- at most c 0s; // Motivating example:; // DAG combiner optimizes (add x (shl (srl y 5) 2)); // to (add x (and (srl y 3) 1FFFFFFC)); // which results in a constant-extended and(##...,lsr). This transformation; // undoes this simplification for cases where the shl can be folded into; // an addressing mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:441,Usability,simpl,simplification,441,"// Transform: (load ch (add x (and (srl y c) Mask))); // to: (load ch (add x (shl (srl y d) d-c))); // where; // Mask = 00..0 111..1 0.0; // | | +-- d-c 0s, and d-c is 0, 1 or 2.; // | +-------- 1s; // +-------------- at most c 0s; // Motivating example:; // DAG combiner optimizes (add x (shl (srl y 5) 2)); // to (add x (and (srl y 3) 1FFFFFFC)); // which results in a constant-extended and(##...,lsr). This transformation; // undoes this simplification for cases where the shl can be folded into; // an addressing mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:26,Availability,Mask,Mask,26,// T0 must match: (and T1 Mask),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:42,Availability,mask,mask,42,// Check the second operand: the supposed mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:15,Availability,mask,mask,15,// Examine the mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:15,Usability,simpl,simplifiable,15,// Potentially simplifiable operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:75,Usability,simpl,simple,75,"// We're generating a SELECT way after legalization, so keep the types; // simple.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:200,Performance,load,loads,200,"// Transform: (store ch val (add x (add (shl y c) e))); // to: (store ch val (add x (shl (add y d) c))),; // where e = (shl d c) for some integer d.; // The purpose of this is to enable generation of loads/stores with; // shifted addressing mode, i.e. mem(x+y<<#c). For that, the shift; // value c must be 0, 1 or 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:45,Availability,Mask,Mask,45,"// Transform: (load ch (add x (and (srl y c) Mask))); // to: (load ch (add x (shl (srl y d) d-c))); // where; // Mask = 00..0 111..1 0.0; // | | +-- d-c 0s, and d-c is 0, 1 or 2.; // | +-------- 1s; // +-------------- at most c 0s; // Motivating example:; // DAG combiner optimizes (add x (shl (srl y 5) 2)); // to (add x (and (srl y 3) 1FFFFFFC)); // which results in a constant-extended and(##...,lsr). This transformation; // undoes this simplification for cases where the shl can be folded into; // an addressing mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:113,Availability,Mask,Mask,113,"// Transform: (load ch (add x (and (srl y c) Mask))); // to: (load ch (add x (shl (srl y d) d-c))); // where; // Mask = 00..0 111..1 0.0; // | | +-- d-c 0s, and d-c is 0, 1 or 2.; // | +-------- 1s; // +-------------- at most c 0s; // Motivating example:; // DAG combiner optimizes (add x (shl (srl y 5) 2)); // to (add x (and (srl y 3) 1FFFFFFC)); // which results in a constant-extended and(##...,lsr). This transformation; // undoes this simplification for cases where the shl can be folded into; // an addressing mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:380,Modifiability,extend,extended,380,"// Transform: (load ch (add x (and (srl y c) Mask))); // to: (load ch (add x (shl (srl y d) d-c))); // where; // Mask = 00..0 111..1 0.0; // | | +-- d-c 0s, and d-c is 0, 1 or 2.; // | +-------- 1s; // +-------------- at most c 0s; // Motivating example:; // DAG combiner optimizes (add x (shl (srl y 5) 2)); // to (add x (and (srl y 3) 1FFFFFFC)); // which results in a constant-extended and(##...,lsr). This transformation; // undoes this simplification for cases where the shl can be folded into; // an addressing mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:15,Performance,load,load,15,"// Transform: (load ch (add x (and (srl y c) Mask))); // to: (load ch (add x (shl (srl y d) d-c))); // where; // Mask = 00..0 111..1 0.0; // | | +-- d-c 0s, and d-c is 0, 1 or 2.; // | +-------- 1s; // +-------------- at most c 0s; // Motivating example:; // DAG combiner optimizes (add x (shl (srl y 5) 2)); // to (add x (and (srl y 3) 1FFFFFFC)); // which results in a constant-extended and(##...,lsr). This transformation; // undoes this simplification for cases where the shl can be folded into; // an addressing mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:62,Performance,load,load,62,"// Transform: (load ch (add x (and (srl y c) Mask))); // to: (load ch (add x (shl (srl y d) d-c))); // where; // Mask = 00..0 111..1 0.0; // | | +-- d-c 0s, and d-c is 0, 1 or 2.; // | +-------- 1s; // +-------------- at most c 0s; // Motivating example:; // DAG combiner optimizes (add x (shl (srl y 5) 2)); // to (add x (and (srl y 3) 1FFFFFFC)); // which results in a constant-extended and(##...,lsr). This transformation; // undoes this simplification for cases where the shl can be folded into; // an addressing mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:272,Performance,optimiz,optimizes,272,"// Transform: (load ch (add x (and (srl y c) Mask))); // to: (load ch (add x (shl (srl y d) d-c))); // where; // Mask = 00..0 111..1 0.0; // | | +-- d-c 0s, and d-c is 0, 1 or 2.; // | +-------- 1s; // +-------------- at most c 0s; // Motivating example:; // DAG combiner optimizes (add x (shl (srl y 5) 2)); // to (add x (and (srl y 3) 1FFFFFFC)); // which results in a constant-extended and(##...,lsr). This transformation; // undoes this simplification for cases where the shl can be folded into; // an addressing mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:429,Usability,undo,undoes,429,"// Transform: (load ch (add x (and (srl y c) Mask))); // to: (load ch (add x (shl (srl y d) d-c))); // where; // Mask = 00..0 111..1 0.0; // | | +-- d-c 0s, and d-c is 0, 1 or 2.; // | +-------- 1s; // +-------------- at most c 0s; // Motivating example:; // DAG combiner optimizes (add x (shl (srl y 5) 2)); // to (add x (and (srl y 3) 1FFFFFFC)); // which results in a constant-extended and(##...,lsr). This transformation; // undoes this simplification for cases where the shl can be folded into; // an addressing mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:441,Usability,simpl,simplification,441,"// Transform: (load ch (add x (and (srl y c) Mask))); // to: (load ch (add x (shl (srl y d) d-c))); // where; // Mask = 00..0 111..1 0.0; // | | +-- d-c 0s, and d-c is 0, 1 or 2.; // | +-------- 1s; // +-------------- at most c 0s; // Motivating example:; // DAG combiner optimizes (add x (shl (srl y 5) 2)); // to (add x (and (srl y 3) 1FFFFFFC)); // which results in a constant-extended and(##...,lsr). This transformation; // undoes this simplification for cases where the shl can be folded into; // an addressing mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:585,Modifiability,extend,extended,585,"// This (complex pattern) function is meant to detect a sign-extension; // i32->i64 on a per-operand basis. This would allow writing single; // patterns that would cover a number of combinations of different ways; // a sign-extensions could be written. For example:; // (mul (DetectUseSxtw x) (DetectUseSxtw y)) -> (M2_dpmpyss_s0 x y); // could match either one of these:; // (mul (sext x) (sext_inreg y)); // (mul (sext-load *p) (sext_inreg y)); // (mul (sext_inreg x) (sext y)); // etc.; //; // The returned value will have type i64 and its low word will; // contain the value being extended. The high bits are not specified.; // The returned type is i64 because the original type of N was i64,; // but the users of this function should only use the low-word of the; // result, e.g.; // (mul sxtw:x, sxtw:y) -> (M2_dpmpyss_s0 (LoReg sxtw:x), (LoReg sxtw:y))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:421,Performance,load,load,421,"// This (complex pattern) function is meant to detect a sign-extension; // i32->i64 on a per-operand basis. This would allow writing single; // patterns that would cover a number of combinations of different ways; // a sign-extensions could be written. For example:; // (mul (DetectUseSxtw x) (DetectUseSxtw y)) -> (M2_dpmpyss_s0 x y); // could match either one of these:; // (mul (sext x) (sext_inreg y)); // (mul (sext-load *p) (sext_inreg y)); // (mul (sext_inreg x) (sext y)); // etc.; //; // The returned value will have type i64 and its low word will; // contain the value being extended. The high bits are not specified.; // The returned type is i64 because the original type of N was i64,; // but the users of this function should only use the low-word of the; // result, e.g.; // (mul sxtw:x, sxtw:y) -> (M2_dpmpyss_s0 (LoReg sxtw:x), (LoReg sxtw:y))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:47,Safety,detect,detect,47,"// This (complex pattern) function is meant to detect a sign-extension; // i32->i64 on a per-operand basis. This would allow writing single; // patterns that would cover a number of combinations of different ways; // a sign-extensions could be written. For example:; // (mul (DetectUseSxtw x) (DetectUseSxtw y)) -> (M2_dpmpyss_s0 x y); // could match either one of these:; // (mul (sext x) (sext_inreg y)); // (mul (sext-load *p) (sext_inreg y)); // (mul (sext_inreg x) (sext y)); // etc.; //; // The returned value will have type i64 and its low word will; // contain the value being extended. The high bits are not specified.; // The returned type is i64 because the original type of N was i64,; // but the users of this function should only use the low-word of the; // result, e.g.; // (mul sxtw:x, sxtw:y) -> (M2_dpmpyss_s0 (LoReg sxtw:x), (LoReg sxtw:y))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:276,Safety,Detect,DetectUseSxtw,276,"// This (complex pattern) function is meant to detect a sign-extension; // i32->i64 on a per-operand basis. This would allow writing single; // patterns that would cover a number of combinations of different ways; // a sign-extensions could be written. For example:; // (mul (DetectUseSxtw x) (DetectUseSxtw y)) -> (M2_dpmpyss_s0 x y); // could match either one of these:; // (mul (sext x) (sext_inreg y)); // (mul (sext-load *p) (sext_inreg y)); // (mul (sext_inreg x) (sext y)); // etc.; //; // The returned value will have type i64 and its low word will; // contain the value being extended. The high bits are not specified.; // The returned type is i64 because the original type of N was i64,; // but the users of this function should only use the low-word of the; // result, e.g.; // (mul sxtw:x, sxtw:y) -> (M2_dpmpyss_s0 (LoReg sxtw:x), (LoReg sxtw:y))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:294,Safety,Detect,DetectUseSxtw,294,"// This (complex pattern) function is meant to detect a sign-extension; // i32->i64 on a per-operand basis. This would allow writing single; // patterns that would cover a number of combinations of different ways; // a sign-extensions could be written. For example:; // (mul (DetectUseSxtw x) (DetectUseSxtw y)) -> (M2_dpmpyss_s0 x y); // could match either one of these:; // (mul (sext x) (sext_inreg y)); // (mul (sext-load *p) (sext_inreg y)); // (mul (sext_inreg x) (sext y)); // etc.; //; // The returned value will have type i64 and its low word will; // contain the value being extended. The high bits are not specified.; // The returned type is i64 because the original type of N was i64,; // but the users of this function should only use the low-word of the; // result, e.g.; // (mul sxtw:x, sxtw:y) -> (M2_dpmpyss_s0 (LoReg sxtw:x), (LoReg sxtw:y))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:7,Modifiability,extend,extending,7,"// All extending loads extend to i32, so even if the value in; // memory is shorter than 32 bits, it will be i32 after the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:23,Modifiability,extend,extend,23,"// All extending loads extend to i32, so even if the value in; // memory is shorter than 32 bits, it will be i32 after the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:17,Performance,load,loads,17,"// All extending loads extend to i32, so even if the value in; // memory is shorter than 32 bits, it will be i32 after the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:123,Performance,load,load,123,"// All extending loads extend to i32, so even if the value in; // memory is shorter than 32 bits, it will be i32 after the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:27,Performance,queue,queue,27,/// A specialized priority queue for WeigthedLeaves. It automatically folds; /// constants and allows removal of non-top elements while maintaining the; /// priority order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:32,Performance,queue,queue,32,"/// Push L to the bottom of the queue regardless of its weight. If L is; /// constant, it will not be folded with other constants in the queue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:137,Performance,queue,queue,137,"/// Push L to the bottom of the queue regardless of its weight. If L is; /// constant, it will not be folded with other constants in the queue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:54,Performance,queue,queue,54,"/// Search for a SHL(x, [<=MaxAmount]) subtree in the queue, return the one of; /// lowest weight and remove it from the queue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:121,Performance,queue,queue,121,"/// Search for a SHL(x, [<=MaxAmount]) subtree in the queue, return the one of; /// lowest weight and remove it from the queue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:98,Performance,queue,queue,98,// Try to identify two factorizable MUL/SHL children greedily. Leave; // them out of the priority queue for now so we can deal with them; // after.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:77,Performance,queue,queue,77,"// We failed to factorize two MULs, so now the Muls are left outside the; // queue... add them back.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:139,Energy Efficiency,reduce,reduces,139,"// Combine GA + Constant -> GA+Offset, but only if GA is not used elsewhere; // and the root node itself is not used more than twice. This reduces the; // amount of additional constant extenders introduced by this optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:185,Modifiability,extend,extenders,185,"// Combine GA + Constant -> GA+Offset, but only if GA is not used elsewhere; // and the root node itself is not used more than twice. This reduces the; // amount of additional constant extenders introduced by this optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:214,Performance,optimiz,optimization,214,"// Combine GA + Constant -> GA+Offset, but only if GA is not used elsewhere; // and the root node itself is not used more than twice. This reduces the; // amount of additional constant extenders introduced by this optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:39,Performance,queue,queue,39,// Remove the offset constant from the queue,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.h:74,Performance,load,load,74,// Generate a machine instruction node corresponding to the circ/brev; // load intrinsic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.h:23,Performance,load,load,23,"// Given the circ/brev load intrinsic and the already generated machine; // instruction, generate the appropriate store (that is a part of the; // intrinsic's functionality).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.h:30,Security,access,access,30,// This is really only to get access to ReplaceNode (which is a protected; // member). Any other members used by HvxSelector can be moved around to; // make them accessible).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.h:162,Security,access,accessible,162,// This is really only to get access to ReplaceNode (which is a protected; // member). Any other members used by HvxSelector can be moved around to; // make them accessible).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:147,Integrability,rout,routing,147,"// --------------------------------------------------------------------; // Implementation of permutation networks.; // Implementation of the node routing through butterfly networks:; // - Forward delta.; // - Reverse delta.; // - Benes.; //; //; // Forward delta network consists of log(N) steps, where N is the number; // of inputs. In each step, an input can stay in place, or it can get; // routed to another position[1]. The step after that consists of two; // networks, each half in size in terms of the number of nodes. In those; // terms, in the given step, an input can go to either the upper or the; // lower network in the next step.; //; // [1] Hexagon's vdelta/vrdelta allow an element to be routed to both; // positions as long as there is no conflict.; // Here's a delta network for 8 inputs, only the switching routes are; // shown:; //; // Steps:; // |- 1 ---------------|- 2 -----|- 3 -|; //; // Inp[0] *** *** *** *** Out[0]; // \ / \ / \ /; // \ / \ / X; // \ / \ / / \; // Inp[1] *** \ / *** X *** *** Out[1]; // \ \ / / \ / \ /; // \ \ / / X X; // \ \ / / / \ / \; // Inp[2] *** \ \ / / *** X *** *** Out[2]; // \ \ X / / / \ \ /; // \ \ / \ / / / \ X; // \ X X / / \ / \; // Inp[3] *** \ / \ / \ / *** *** *** Out[3]; // \ X X X /; // \ / \ / \ / \ /; // X X X X; // / \ / \ / \ / \; // / X X X \; // Inp[4] *** / \ / \ / \ *** *** *** Out[4]; // / X X \ \ / \ /; // / / \ / \ \ \ / X; // / / X \ \ \ / / \; // Inp[5] *** / / \ \ *** X *** *** Out[5]; // / / \ \ \ / \ /; // / / \ \ X X; // / / \ \ / \ / \; // Inp[6] *** / \ *** X *** *** Out[6]; // / \ / \ \ /; // / \ / \ X; // / \ / \ / \; // Inp[7] *** *** *** *** Out[7]; //; //; // Reverse delta network is same as delta network, with the steps in; // the opposite order.; //; //; // Benes network is a forward delta network immediately followed by; // a reverse delta network.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:395,Integrability,rout,routed,395,"// --------------------------------------------------------------------; // Implementation of permutation networks.; // Implementation of the node routing through butterfly networks:; // - Forward delta.; // - Reverse delta.; // - Benes.; //; //; // Forward delta network consists of log(N) steps, where N is the number; // of inputs. In each step, an input can stay in place, or it can get; // routed to another position[1]. The step after that consists of two; // networks, each half in size in terms of the number of nodes. In those; // terms, in the given step, an input can go to either the upper or the; // lower network in the next step.; //; // [1] Hexagon's vdelta/vrdelta allow an element to be routed to both; // positions as long as there is no conflict.; // Here's a delta network for 8 inputs, only the switching routes are; // shown:; //; // Steps:; // |- 1 ---------------|- 2 -----|- 3 -|; //; // Inp[0] *** *** *** *** Out[0]; // \ / \ / \ /; // \ / \ / X; // \ / \ / / \; // Inp[1] *** \ / *** X *** *** Out[1]; // \ \ / / \ / \ /; // \ \ / / X X; // \ \ / / / \ / \; // Inp[2] *** \ \ / / *** X *** *** Out[2]; // \ \ X / / / \ \ /; // \ \ / \ / / / \ X; // \ X X / / \ / \; // Inp[3] *** \ / \ / \ / *** *** *** Out[3]; // \ X X X /; // \ / \ / \ / \ /; // X X X X; // / \ / \ / \ / \; // / X X X \; // Inp[4] *** / \ / \ / \ *** *** *** Out[4]; // / X X \ \ / \ /; // / / \ / \ \ \ / X; // / / X \ \ \ / / \; // Inp[5] *** / / \ \ *** X *** *** Out[5]; // / / \ \ \ / \ /; // / / \ \ X X; // / / \ \ / \ / \; // Inp[6] *** / \ *** X *** *** Out[6]; // / \ / \ \ /; // / \ / \ X; // / \ / \ / \; // Inp[7] *** *** *** *** Out[7]; //; //; // Reverse delta network is same as delta network, with the steps in; // the opposite order.; //; //; // Benes network is a forward delta network immediately followed by; // a reverse delta network.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:705,Integrability,rout,routed,705,"// --------------------------------------------------------------------; // Implementation of permutation networks.; // Implementation of the node routing through butterfly networks:; // - Forward delta.; // - Reverse delta.; // - Benes.; //; //; // Forward delta network consists of log(N) steps, where N is the number; // of inputs. In each step, an input can stay in place, or it can get; // routed to another position[1]. The step after that consists of two; // networks, each half in size in terms of the number of nodes. In those; // terms, in the given step, an input can go to either the upper or the; // lower network in the next step.; //; // [1] Hexagon's vdelta/vrdelta allow an element to be routed to both; // positions as long as there is no conflict.; // Here's a delta network for 8 inputs, only the switching routes are; // shown:; //; // Steps:; // |- 1 ---------------|- 2 -----|- 3 -|; //; // Inp[0] *** *** *** *** Out[0]; // \ / \ / \ /; // \ / \ / X; // \ / \ / / \; // Inp[1] *** \ / *** X *** *** Out[1]; // \ \ / / \ / \ /; // \ \ / / X X; // \ \ / / / \ / \; // Inp[2] *** \ \ / / *** X *** *** Out[2]; // \ \ X / / / \ \ /; // \ \ / \ / / / \ X; // \ X X / / \ / \; // Inp[3] *** \ / \ / \ / *** *** *** Out[3]; // \ X X X /; // \ / \ / \ / \ /; // X X X X; // / \ / \ / \ / \; // / X X X \; // Inp[4] *** / \ / \ / \ *** *** *** Out[4]; // / X X \ \ / \ /; // / / \ / \ \ \ / X; // / / X \ \ \ / / \; // Inp[5] *** / / \ \ *** X *** *** Out[5]; // / / \ \ \ / \ /; // / / \ \ X X; // / / \ \ / \ / \; // Inp[6] *** / \ *** X *** *** Out[6]; // / \ / \ \ /; // / \ / \ X; // / \ / \ / \; // Inp[7] *** *** *** *** Out[7]; //; //; // Reverse delta network is same as delta network, with the steps in; // the opposite order.; //; //; // Benes network is a forward delta network immediately followed by; // a reverse delta network.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:827,Integrability,rout,routes,827,"// --------------------------------------------------------------------; // Implementation of permutation networks.; // Implementation of the node routing through butterfly networks:; // - Forward delta.; // - Reverse delta.; // - Benes.; //; //; // Forward delta network consists of log(N) steps, where N is the number; // of inputs. In each step, an input can stay in place, or it can get; // routed to another position[1]. The step after that consists of two; // networks, each half in size in terms of the number of nodes. In those; // terms, in the given step, an input can go to either the upper or the; // lower network in the next step.; //; // [1] Hexagon's vdelta/vrdelta allow an element to be routed to both; // positions as long as there is no conflict.; // Here's a delta network for 8 inputs, only the switching routes are; // shown:; //; // Steps:; // |- 1 ---------------|- 2 -----|- 3 -|; //; // Inp[0] *** *** *** *** Out[0]; // \ / \ / \ /; // \ / \ / X; // \ / \ / / \; // Inp[1] *** \ / *** X *** *** Out[1]; // \ \ / / \ / \ /; // \ \ / / X X; // \ \ / / / \ / \; // Inp[2] *** \ \ / / *** X *** *** Out[2]; // \ \ X / / / \ \ /; // \ \ / \ / / / \ X; // \ X X / / \ / \; // Inp[3] *** \ / \ / \ / *** *** *** Out[3]; // \ X X X /; // \ / \ / \ / \ /; // X X X X; // / \ / \ / \ / \; // / X X X \; // Inp[4] *** / \ / \ / \ *** *** *** Out[4]; // / X X \ \ / \ /; // / / \ / \ \ \ / X; // / / X \ \ \ / / \; // Inp[5] *** / / \ \ *** X *** *** Out[5]; // / / \ \ \ / \ /; // / / \ \ X X; // / / \ \ / \ / \; // Inp[6] *** / \ *** X *** *** Out[6]; // / \ / \ \ /; // / \ / \ X; // / \ / \ / \; // Inp[7] *** *** *** *** Out[7]; //; //; // Reverse delta network is same as delta network, with the steps in; // the opposite order.; //; //; // Benes network is a forward delta network immediately followed by; // a reverse delta network.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:284,Testability,log,log,284,"// --------------------------------------------------------------------; // Implementation of permutation networks.; // Implementation of the node routing through butterfly networks:; // - Forward delta.; // - Reverse delta.; // - Benes.; //; //; // Forward delta network consists of log(N) steps, where N is the number; // of inputs. In each step, an input can stay in place, or it can get; // routed to another position[1]. The step after that consists of two; // networks, each half in size in terms of the number of nodes. In those; // terms, in the given step, an input can go to either the upper or the; // lower network in the next step.; //; // [1] Hexagon's vdelta/vrdelta allow an element to be routed to both; // positions as long as there is no conflict.; // Here's a delta network for 8 inputs, only the switching routes are; // shown:; //; // Steps:; // |- 1 ---------------|- 2 -----|- 3 -|; //; // Inp[0] *** *** *** *** Out[0]; // \ / \ / \ /; // \ / \ / X; // \ / \ / / \; // Inp[1] *** \ / *** X *** *** Out[1]; // \ \ / / \ / \ /; // \ \ / / X X; // \ \ / / / \ / \; // Inp[2] *** \ \ / / *** X *** *** Out[2]; // \ \ X / / / \ \ /; // \ \ / \ / / / \ X; // \ X X / / \ / \; // Inp[3] *** \ / \ / \ / *** *** *** Out[3]; // \ X X X /; // \ / \ / \ / \ /; // X X X X; // / \ / \ / \ / \; // / X X X \; // Inp[4] *** / \ / \ / \ *** *** *** Out[4]; // / X X \ \ / \ /; // / / \ / \ \ \ / X; // / / X \ \ \ / / \; // Inp[5] *** / / \ \ *** X *** *** Out[5]; // / / \ \ \ / \ /; // / / \ \ X X; // / / \ \ / \ / \; // Inp[6] *** / \ *** X *** *** Out[6]; // / \ / \ \ /; // / \ / \ X; // / \ / \ / \; // Inp[7] *** *** *** *** Out[7]; //; //; // Reverse delta network is same as delta network, with the steps in; // the opposite order.; //; //; // Benes network is a forward delta network immediately followed by; // a reverse delta network.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:101,Integrability,rout,routed,101,// Graph coloring utility used to partition nodes into two groups:; // they will correspond to nodes routed to the upper and lower networks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:104,Performance,queue,queue,104,"// Now, nodes that are still uncolored. Since the graph can be modified; // in this step, create a work queue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:183,Integrability,rout,routed,183,"// Cannot use coloring here, because coloring is used to determine; // the ""big"" switch, i.e. the one that changes halves, and in a forward; // network, a color can be simultaneously routed to both halves in the; // step we're working on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:50,Deployability,update,updated,50,// U is the element in the table that needs to be updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:43,Availability,Down,Down,43,"// Both assignments, i.e. Red->Up and Red->Down are valid, but they will; // result in different controls. Let's pick the one where the first; // control will be ""Pass"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:3,Availability,Down,Down,3,// Down,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:3,Availability,Mask,Mask,3,// Mask of the index value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:35,Availability,mask,mask,35,// Check if the second half of the mask is all-undef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:37,Performance,load,loads,37,"// Constant vectors are generated as loads from constant pools or as; // splats of a constant value. Since they are generated during the; // selection process, the main selection algorithm is not aware of them.; // Select them directly here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:56,Performance,cache,cache,56,"// The DAG can change (due to CSE) during selection, so cache all the; // unselected nodes first to avoid traversing a mutating DAG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:100,Safety,avoid,avoid,100,"// The DAG can change (due to CSE) during selection, so cache all the; // unselected nodes first to avoid traversing a mutating DAG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:103,Availability,mask,mask,103,"// NOTE:; // In the following part of the function, where the segments are rearranged,; // the shuffle mask SM can be of any length that is a multiple of a vector; // (i.e. a multiple of 2*SegLen), and non-zero.; // The output segment map is computed, and it may have any even number of; // entries, but the rearrangement of input segments will be done based only; // on the first two (non-undef) entries in the segment map.; // For example, if the output map is 3, 1, 1, 3 (it can have at most two; // distinct entries!), the segments 1 and 3 of Va/Vb will be packaged into; // a single vector V = 3:1. The output mask will then be updated to use; // seg(0,V), seg(1,V), seg(1,V), seg(0,V).; //; // Picking the segments based on the output map is an optimization. For; // correctness it is only necessary that Seg0 and Seg1 are the two input; // segments that are used in the output.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:615,Availability,mask,mask,615,"// NOTE:; // In the following part of the function, where the segments are rearranged,; // the shuffle mask SM can be of any length that is a multiple of a vector; // (i.e. a multiple of 2*SegLen), and non-zero.; // The output segment map is computed, and it may have any even number of; // entries, but the rearrangement of input segments will be done based only; // on the first two (non-undef) entries in the segment map.; // For example, if the output map is 3, 1, 1, 3 (it can have at most two; // distinct entries!), the segments 1 and 3 of Va/Vb will be packaged into; // a single vector V = 3:1. The output mask will then be updated to use; // seg(0,V), seg(1,V), seg(1,V), seg(0,V).; //; // Picking the segments based on the output map is an optimization. For; // correctness it is only necessary that Seg0 and Seg1 are the two input; // segments that are used in the output.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:633,Deployability,update,updated,633,"// NOTE:; // In the following part of the function, where the segments are rearranged,; // the shuffle mask SM can be of any length that is a multiple of a vector; // (i.e. a multiple of 2*SegLen), and non-zero.; // The output segment map is computed, and it may have any even number of; // entries, but the rearrangement of input segments will be done based only; // on the first two (non-undef) entries in the segment map.; // For example, if the output map is 3, 1, 1, 3 (it can have at most two; // distinct entries!), the segments 1 and 3 of Va/Vb will be packaged into; // a single vector V = 3:1. The output mask will then be updated to use; // seg(0,V), seg(1,V), seg(1,V), seg(0,V).; //; // Picking the segments based on the output map is an optimization. For; // correctness it is only necessary that Seg0 and Seg1 are the two input; // segments that are used in the output.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:751,Performance,optimiz,optimization,751,"// NOTE:; // In the following part of the function, where the segments are rearranged,; // the shuffle mask SM can be of any length that is a multiple of a vector; // (i.e. a multiple of 2*SegLen), and non-zero.; // The output segment map is computed, and it may have any even number of; // entries, but the rearrangement of input segments will be done based only; // on the first two (non-undef) entries in the segment map.; // For example, if the output map is 3, 1, 1, 3 (it can have at most two; // distinct entries!), the segments 1 and 3 of Va/Vb will be packaged into; // a single vector V = 3:1. The output mask will then be updated to use; // seg(0,V), seg(1,V), seg(1,V), seg(0,V).; //; // Picking the segments based on the output map is an optimization. For; // correctness it is only necessary that Seg0 and Seg1 are the two input; // segments that are used in the output.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:142,Availability,mask,mask,142,"// By here, packing by segment (half-vector) shuffling, and vector alignment; // failed. Try vmux.; // Note: since this is using the original mask, Va and Vb must not have been; // modified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:143,Availability,mask,mask,143,"// If elements picked from Va and Vb have all different (source) indexes; // (relative to the start of the argument), do a mux, and update the mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:132,Deployability,update,update,132,"// If elements picked from Va and Vb have all different (source) indexes; // (relative to the start of the argument), do a mux, and update the mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:58,Availability,mask,mask,58,// Really make sure we have at most 2 vectors used in the mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:29,Availability,mask,mask,29,"// TODO: Before we split the mask, try perfect shuffle on concatenated; // operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:41,Availability,mask,mask,41,"// Doing a perfect shuffle on a low-half mask (i.e. where the upper half; // is all-undef) may produce a perfect shuffle that generates legitimate; // upper half. This isn't wrong, but if the perfect shuffle was possible,; // then there is a good chance that a shorter (contracting) code may be; // used as well (e.g. V6_vshuffeb, etc).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:270,Integrability,contract,contracting,270,"// Doing a perfect shuffle on a low-half mask (i.e. where the upper half; // is all-undef) may produce a perfect shuffle that generates legitimate; // upper half. This isn't wrong, but if the perfect shuffle was possible,; // then there is a good chance that a shorter (contracting) code may be; // used as well (e.g. V6_vshuffeb, etc).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:20,Availability,mask,mask,20,// TODO commute the mask and try the opposite order of the halves.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:203,Availability,error,error,203,"// What's important here is to select the right set of nodes. The main; // selection algorithm loops over nodes in a topological order, i.e. users; // are visited before their operands.; //; // It is an error to have an unselected node with a selected operand, and; // there is an assertion in the main selector code to enforce that.; //; // Such a situation could occur if we selected a node, which is both a; // subnode of ISelN, and a subnode of an unrelated (and yet unselected); // node in the DAG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:281,Testability,assert,assertion,281,"// What's important here is to select the right set of nodes. The main; // selection algorithm loops over nodes in a topological order, i.e. users; // are visited before their operands.; //; // It is an error to have an unselected node with a selected operand, and; // there is an assertion in the main selector code to enforce that.; //; // Such a situation could occur if we selected a node, which is both a; // subnode of ISelN, and a subnode of an unrelated (and yet unselected); // node in the DAG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:174,Integrability,rout,routine,174,"// Need to manually select the nodes that are dominated by the ISEL. Other; // nodes are reachable from the rest of the DAG, and so will be selected; // by the DAG selection routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:685,Safety,avoid,avoid,685,"// The prior attempts to handle this shuffle may have left a bunch of; // dead nodes in the DAG (such as constants). These nodes will be added; // at the end of DAG's node list, which at that point had already been; // sorted topologically. In the main selection loop, the node list is; // traversed backwards from the root node, which means that any new; // nodes (from the end of the list) will not be visited.; // Scalarization will replace the shuffle node with the scalarized; // expression, and if that expression reused any if the leftoever (dead); // nodes, these nodes would not be selected (since the ""local"" selection; // only visits nodes that are not in AllNodes).; // To avoid this issue, remove all dead nodes from the DAG now.; // DAG.RemoveDeadNodes();",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:1159,Availability,mask,mask,1159,"// If there is a word P in Worklist that matches multiple possibilities,; // then if any other word Q matches any of the possibilities matched by P,; // then Q matches all the possibilities matched by P. In fact, P == Q.; // In other words, for each words P, Q, the sets of possibilities matched; // by P and Q are either equal or disjoint (no partial overlap).; //; // Illustration: For 4-bit values there are 4 complete sequences:; // a: 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1; // b: 0 0 1 1 0 0 1 1 0 0 1 1 0 0 1 1; // c: 0 0 0 0 1 1 1 1 0 0 0 0 1 1 1 1; // d: 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1; //; // Words containing unknown bits that match two of the complete; // sequences:; // ab: 0 u u 1 0 u u 1 0 u u 1 0 u u 1; // ac: 0 u 0 u u 1 u 1 0 u 0 u u 1 u 1; // ad: 0 u 0 u 0 u 0 u u 1 u 1 u 1 u 1; // bc: 0 0 u u u u 1 1 0 0 u u u u 1 1; // bd: 0 0 u u 0 0 u u u u 1 1 u u 1 1; // cd: 0 0 0 0 u u u u u u u u 1 1 1 1; //; // Proof of the claim above:; // Let P be a word that matches s0 and s1. For that to happen, all known; // bits in P must match s0 and s1 exactly.; // Assume there is Q that matches s1. Note that since P and Q came from; // the same shuffle mask, the positions of unknown bits in P and Q match; // exactly, which makes the indices of known bits be exactly the same; // between P and Q. Since P matches s0 and s1, the known bits of P much; // match both s0 and s1. Also, since Q matches s1, the known bits in Q; // are exactly the same as in s1, which means that they are exactly the; // same as in P. This implies that P == Q.; // There can be a situation where there are more entries with the same; // bits set than there are set bits (e.g. value 9 occuring more than 2; // times). In such cases it will be impossible to complete this to a; // perfect shuffle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:3,Usability,Clear,Clear,3,// Clear T in all remaining words matching P.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:143,Integrability,Wrap,WrapAt,143,"// Integer a%b operator assumes rounding towards zero by /, so it; // ""misbehaves"" when a crosses 0 (the remainder also changes sign).; // Add WrapAt in an attempt to keep I+Dist non-negative.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:3,Integrability,Contract,Contracting,3,"// Contracting shuffles, i.e. instructions that always discard some bytes; // from the operand vectors.; //; // Funnel shifts; // V6_vshuff{e,o}b; // V6_vshuf{e,o}h; // V6_vdealb4w; // V6_vpack{e,o}{b,h}",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:182,Availability,Mask,Mask,182,"// Expanding shuffles (using all elements and inserting into larger vector):; //; // V6_vunpacku{b,h} [*]; //; // [*] Only if the upper elements (filled with 0s) are ""don't care"" in Mask.; //; // Note: V6_vunpacko{b,h} are or-ing the high byte/half in the result, so; // they are not shuffles.; //; // The argument is a single vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:617,Performance,perform,perform,617,"// Check if this could be a perfect shuffle, or a combination of perfect; // shuffles.; //; // Consider this permutation (using hex digits to make the ASCII diagrams; // easier to read):; // { 0, 8, 1, 9, 2, A, 3, B, 4, C, 5, D, 6, E, 7, F }.; // This is a ""deal"" operation: divide the input into two halves, and; // create the output by picking elements by alternating between these two; // halves:; // 0 1 2 3 4 5 6 7 --> 0 8 1 9 2 A 3 B 4 C 5 D 6 E 7 F [*]; // 8 9 A B C D E F; //; // Aside from a few special explicit cases (V6_vdealb, etc.), HVX provides; // a somwehat different mechanism that could be used to perform shuffle/; // deal operations: a 2x2 transpose.; // Consider the halves of inputs again, they can be interpreted as a 2x8; // matrix. A 2x8 matrix can be looked at four 2x2 matrices concatenated; // together. Now, when considering 2 elements at a time, it will be a 2x4; // matrix (with elements 01, 23, 45, etc.), or two 2x2 matrices:; // 01 23 45 67; // 89 AB CD EF; // With groups of 4, this will become a single 2x2 matrix, and so on.; //; // The 2x2 transpose instruction works by transposing each of the 2x2; // matrices (or ""sub-matrices""), given a specific group size. For example,; // if the group size is 1 (i.e. each element is its own group), there; // will be four transposes of the four 2x2 matrices that form the 2x8.; // For example, with the inputs as above, the result will be:; // 0 8 2 A 4 C 6 E; // 1 9 3 B 5 D 7 F; // Now, this result can be tranposed again, but with the group size of 2:; // 08 19 4C 5D; // 2A 3B 6E 7F; // If we then transpose that result, but with the group size of 4, we get:; // 0819 2A3B; // 4C5D 6E7F; // If we concatenate these two rows, it will be; // 0 8 1 9 2 A 3 B 4 C 5 D 6 E 7 F; // which is the same as the ""deal"" [*] above.; //; // In general, a ""deal"" of individual elements is a series of 2x2 transposes,; // with changing group size. HVX has two instructions:; // Vdd = V6_vdealvdd Vu, Vv, Rt; // Vdd = V6_shufvdd Vu, V",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:2016,Performance,perform,perform,2016," // 89 AB CD EF; // With groups of 4, this will become a single 2x2 matrix, and so on.; //; // The 2x2 transpose instruction works by transposing each of the 2x2; // matrices (or ""sub-matrices""), given a specific group size. For example,; // if the group size is 1 (i.e. each element is its own group), there; // will be four transposes of the four 2x2 matrices that form the 2x8.; // For example, with the inputs as above, the result will be:; // 0 8 2 A 4 C 6 E; // 1 9 3 B 5 D 7 F; // Now, this result can be tranposed again, but with the group size of 2:; // 08 19 4C 5D; // 2A 3B 6E 7F; // If we then transpose that result, but with the group size of 4, we get:; // 0819 2A3B; // 4C5D 6E7F; // If we concatenate these two rows, it will be; // 0 8 1 9 2 A 3 B 4 C 5 D 6 E 7 F; // which is the same as the ""deal"" [*] above.; //; // In general, a ""deal"" of individual elements is a series of 2x2 transposes,; // with changing group size. HVX has two instructions:; // Vdd = V6_vdealvdd Vu, Vv, Rt; // Vdd = V6_shufvdd Vu, Vv, Rt; // that perform exactly that. The register Rt controls which transposes are; // going to happen: a bit at position n (counting from 0) indicates that a; // transpose with a group size of 2^n will take place. If multiple bits are; // set, multiple transposes will happen: vdealvdd will perform them starting; // with the largest group size, vshuffvdd will do them in the reverse order.; //; // The main observation is that each 2x2 transpose corresponds to swapping; // columns of bits in the binary representation of the values.; //; // The numbers {3,2,1,0} and the log2 of the number of contiguous 1 bits; // in a given column. The * denote the columns that will be swapped.; // The transpose with the group size 2^n corresponds to swapping columns; // 3 (the highest log) and log2(n):; //; // 3 2 1 0 0 2 1 3 0 2 3 1; // * * * * * *; // 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0; // 1 0 0 0 1 8 1 0 0 0 8 1 0 0 0 8 1 0 0 0; // 2 0 0 1 0 2 0 0 1 0 1 0 0 0 1 1 0 0 0 1;",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:2293,Performance,perform,perform,2293,"ransposes of the four 2x2 matrices that form the 2x8.; // For example, with the inputs as above, the result will be:; // 0 8 2 A 4 C 6 E; // 1 9 3 B 5 D 7 F; // Now, this result can be tranposed again, but with the group size of 2:; // 08 19 4C 5D; // 2A 3B 6E 7F; // If we then transpose that result, but with the group size of 4, we get:; // 0819 2A3B; // 4C5D 6E7F; // If we concatenate these two rows, it will be; // 0 8 1 9 2 A 3 B 4 C 5 D 6 E 7 F; // which is the same as the ""deal"" [*] above.; //; // In general, a ""deal"" of individual elements is a series of 2x2 transposes,; // with changing group size. HVX has two instructions:; // Vdd = V6_vdealvdd Vu, Vv, Rt; // Vdd = V6_shufvdd Vu, Vv, Rt; // that perform exactly that. The register Rt controls which transposes are; // going to happen: a bit at position n (counting from 0) indicates that a; // transpose with a group size of 2^n will take place. If multiple bits are; // set, multiple transposes will happen: vdealvdd will perform them starting; // with the largest group size, vshuffvdd will do them in the reverse order.; //; // The main observation is that each 2x2 transpose corresponds to swapping; // columns of bits in the binary representation of the values.; //; // The numbers {3,2,1,0} and the log2 of the number of contiguous 1 bits; // in a given column. The * denote the columns that will be swapped.; // The transpose with the group size 2^n corresponds to swapping columns; // 3 (the highest log) and log2(n):; //; // 3 2 1 0 0 2 1 3 0 2 3 1; // * * * * * *; // 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0; // 1 0 0 0 1 8 1 0 0 0 8 1 0 0 0 8 1 0 0 0; // 2 0 0 1 0 2 0 0 1 0 1 0 0 0 1 1 0 0 0 1; // 3 0 0 1 1 A 1 0 1 0 9 1 0 0 1 9 1 0 0 1; // 4 0 1 0 0 4 0 1 0 0 4 0 1 0 0 2 0 0 1 0; // 5 0 1 0 1 C 1 1 0 0 C 1 1 0 0 A 1 0 1 0; // 6 0 1 1 0 6 0 1 1 0 5 0 1 0 1 3 0 0 1 1; // 7 0 1 1 1 E 1 1 1 0 D 1 1 0 1 B 1 0 1 1; // 8 1 0 0 0 1 0 0 0 1 2 0 0 1 0 4 0 1 0 0; // 9 1 0 0 1 9 1 0 0 1 A 1 0 1 0 C 1 1 0 0; // A 1 0 1 0 3 0 0 ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:2778,Testability,log,log,2778,"of individual elements is a series of 2x2 transposes,; // with changing group size. HVX has two instructions:; // Vdd = V6_vdealvdd Vu, Vv, Rt; // Vdd = V6_shufvdd Vu, Vv, Rt; // that perform exactly that. The register Rt controls which transposes are; // going to happen: a bit at position n (counting from 0) indicates that a; // transpose with a group size of 2^n will take place. If multiple bits are; // set, multiple transposes will happen: vdealvdd will perform them starting; // with the largest group size, vshuffvdd will do them in the reverse order.; //; // The main observation is that each 2x2 transpose corresponds to swapping; // columns of bits in the binary representation of the values.; //; // The numbers {3,2,1,0} and the log2 of the number of contiguous 1 bits; // in a given column. The * denote the columns that will be swapped.; // The transpose with the group size 2^n corresponds to swapping columns; // 3 (the highest log) and log2(n):; //; // 3 2 1 0 0 2 1 3 0 2 3 1; // * * * * * *; // 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0; // 1 0 0 0 1 8 1 0 0 0 8 1 0 0 0 8 1 0 0 0; // 2 0 0 1 0 2 0 0 1 0 1 0 0 0 1 1 0 0 0 1; // 3 0 0 1 1 A 1 0 1 0 9 1 0 0 1 9 1 0 0 1; // 4 0 1 0 0 4 0 1 0 0 4 0 1 0 0 2 0 0 1 0; // 5 0 1 0 1 C 1 1 0 0 C 1 1 0 0 A 1 0 1 0; // 6 0 1 1 0 6 0 1 1 0 5 0 1 0 1 3 0 0 1 1; // 7 0 1 1 1 E 1 1 1 0 D 1 1 0 1 B 1 0 1 1; // 8 1 0 0 0 1 0 0 0 1 2 0 0 1 0 4 0 1 0 0; // 9 1 0 0 1 9 1 0 0 1 A 1 0 1 0 C 1 1 0 0; // A 1 0 1 0 3 0 0 1 1 3 0 0 1 1 5 0 1 0 1; // B 1 0 1 1 B 1 0 1 1 B 1 0 1 1 D 1 1 0 1; // C 1 1 0 0 5 0 1 0 1 6 0 1 1 0 6 0 1 1 0; // D 1 1 0 1 D 1 1 0 1 E 1 1 1 0 E 1 1 1 0; // E 1 1 1 0 7 0 1 1 1 7 0 1 1 1 7 0 1 1 1; // F 1 1 1 1 F 1 1 1 1 F 1 1 1 1 F 1 1 1 1; // There is one special case that is not a perfect shuffle, but can be; // turned into one easily: when the shuffle operates on a vector pair,; // but the two vectors in the pair are swapped. The code that identifies; // perfect shuffles will reject it, unless the order is reversed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:214,Usability,simpl,simple,214,"// Once we have Perm, represent it as cycles. Denote the maximum log2; // (equal to log2(VecLen)-1) as M. The cycle containing M can then be; // written as (M a1 a2 a3 ... an). That cycle can be broken up into; // simple swaps as (M a1)(M a2)(M a3)...(M an), with the composition; // order being from left to right. Any (contiguous) segment where the; // values ai, ai+1...aj are either all increasing or all decreasing,; // can be implemented via a single vshuffvdd/vdealvdd respectively.; //; // If there is a cycle (a1 a2 ... an) that does not involve M, it can; // be written as (M an)(a1 a2 ... an)(M a1). The first two cycles can; // then be folded to get (M a1 a2 ... an)(M a1), and the above procedure; // can be used to generate a sequence of vshuffvdd/vdealvdd.; //; // Example:; // Assume M = 4 and consider a permutation (0 1)(2 3). It can be written; // as (4 0 1)(4 0) composed with (4 2 3)(4 2), or simply; // (4 0 1)(4 0)(4 2 3)(4 2).; // It can then be expanded into swaps as; // (4 0)(4 1)(4 0)(4 2)(4 3)(4 2),; // and broken up into ""increasing"" segments as; // [(4 0)(4 1)] [(4 0)(4 2)(4 3)] [(4 2)].; // This is equivalent to; // (4 0 1)(4 0 2 3)(4 2),; // which can be implemented as 3 vshufvdd instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:914,Usability,simpl,simply,914,"// Once we have Perm, represent it as cycles. Denote the maximum log2; // (equal to log2(VecLen)-1) as M. The cycle containing M can then be; // written as (M a1 a2 a3 ... an). That cycle can be broken up into; // simple swaps as (M a1)(M a2)(M a3)...(M an), with the composition; // order being from left to right. Any (contiguous) segment where the; // values ai, ai+1...aj are either all increasing or all decreasing,; // can be implemented via a single vshuffvdd/vdealvdd respectively.; //; // If there is a cycle (a1 a2 ... an) that does not involve M, it can; // be written as (M an)(a1 a2 ... an)(M a1). The first two cycles can; // then be folded to get (M a1 a2 ... an)(M a1), and the above procedure; // can be used to generate a sequence of vshuffvdd/vdealvdd.; //; // Example:; // Assume M = 4 and consider a permutation (0 1)(2 3). It can be written; // as (4 0 1)(4 0) composed with (4 2 3)(4 2), or simply; // (4 0 1)(4 0)(4 2 3)(4 2).; // It can then be expanded into swaps as; // (4 0)(4 1)(4 0)(4 2)(4 3)(4 2),; // and broken up into ""increasing"" segments as; // [(4 0)(4 1)] [(4 0)(4 2)(4 3)] [(4 2)].; // This is equivalent to; // (4 0 1)(4 0 2 3)(4 2),; // which can be implemented as 3 vshufvdd instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:25,Testability,Log,LogLen-,25,"// If the cycle contains LogLen-1, move it to the front of the cycle.; // Otherwise, return the cycle unchanged.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:56,Testability,Log,Log,56,"// Ordering: shuff: 5 0 1 2 3 4, deal: 5 4 3 2 1 0 (for Log=6),; // for bytes zero is included, for halfwords is not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:256,Performance,perform,performs,256,"// From the cycles, construct the sequence of values that will; // then form the control values for vdealvdd/vshuffvdd, i.e.; // (M a1 a2)(M a3 a4 a5)... -> a1 a2 a3 a4 a5; // This essentially strips the M value from the cycles where; // it's present, and performs the insertion of M (then stripping); // for cycles without M (as described in an earlier comment).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:21,Modifiability,extend,extended,21,"// When the input is extended (i.e. single vector becomes a pair),; // this is done by using an ""undef"" vector as the second input.; // However, then we get; // input 1: GOODBITS; // input 2: ........; // but we need; // input 1: ....BITS; // input 2: ....GOOD; // Then at the end, this needs to be undone. To accomplish this,; // artificially add ""LogLen-1"" at both ends of the sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:349,Testability,Log,LogLen-,349,"// When the input is extended (i.e. single vector becomes a pair),; // this is done by using an ""undef"" vector as the second input.; // However, then we get; // input 1: GOODBITS; // input 2: ........; // but we need; // input 1: ....BITS; // input 2: ....GOOD; // Then at the end, this needs to be undone. To accomplish this,; // artificially add ""LogLen-1"" at both ends of the sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:299,Usability,undo,undone,299,"// When the input is extended (i.e. single vector becomes a pair),; // this is done by using an ""undef"" vector as the second input.; // However, then we get; // input 1: GOODBITS; // input 2: ........; // but we need; // input 1: ....BITS; // input 2: ....GOOD; // Then at the end, this needs to be undone. To accomplish this,; // artificially add ""LogLen-1"" at both ends of the sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:123,Availability,Mask,Mask,123,// Butterfly shuffles.; //; // V6_vdelta; // V6_vrdelta; // V6_vror; // The assumption here is that all elements picked by Mask are in the; // first operand to the vector_shuffle. This assumption is enforced; // by the caller.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:31,Availability,Mask,Mask,31,"// Vd = vector_shuffle Va, Vb, Mask; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:10,Availability,mask,mask,10,"// If the mask is all -1's, generate ""undef"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:130,Availability,mask,mask,130,"// Treat Shuff0 and Shuff1 as operands to another vector shuffle, and; // Idx as a (non-undef) element of the top level shuffle's mask, that; // is, index into concat(Shuff0, Shuff1).; // Assuming that Shuff0 and Shuff1 both operate on subvectors of the; // same source vector (as described by OpMap), return the index of; // that source vector corresponding to Idx.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:11,Availability,mask,mask,11,// Get the mask index that M points at in the corresponding operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:408,Integrability,interface,interfaces,408,"//===-- HexagonISelLowering.cpp - Hexagon DAG Lowering Implementation -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the interfaces that Hexagon uses to lower LLVM code; // into a selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:156,Energy Efficiency,allocate,allocate,156,"// Always return false here, as this function only makes sure that the first; // unallocated register has an even register number and does not actually; // allocate a register for the current argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:3,Deployability,Update,Update,3,// Update chain.; // Add the glue if we have it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:58,Performance,load,loads,58,"// Walk the register/memloc assignments, inserting copies/loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:428,Integrability,depend,depends,428,"// For tail calls lower the arguments to the 'real' stack slot.; //; // Force all the incoming stack arguments to be loaded from the stack; // before any new outgoing arguments are stored to the stack, because the; // outgoing stack slots may alias the incoming argument stack slots, and; // the alias isn't otherwise explicit. This is slightly more conservative; // than necessary, because it means that each store effectively depends; // on every argument instead of just those arguments it would clobber.; //; // Do not flag preceding copytoreg stuff together with the following stuff.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:117,Performance,load,loaded,117,"// For tail calls lower the arguments to the 'real' stack slot.; //; // Force all the incoming stack arguments to be loaded from the stack; // before any new outgoing arguments are stored to the stack, because the; // outgoing stack slots may alias the incoming argument stack slots, and; // the alias isn't otherwise explicit. This is slightly more conservative; // than necessary, because it means that each store effectively depends; // on every argument instead of just those arguments it would clobber.; //; // Do not flag preceding copytoreg stuff together with the following stuff.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:133,Performance,load,load,133,"/// Returns true by value, base pointer and offset pointer and addressing; /// mode by reference if this node can be combined with a load / store to; /// form a post-indexed load / store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:174,Performance,load,load,174,"/// Returns true by value, base pointer and offset pointer and addressing; /// mode by reference if this node can be combined with a load / store to; /// form a post-indexed load / store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:63,Modifiability,inherit,inherit,63,"// Need to transform ISD::PREFETCH into something that doesn't inherit; // all of the properties of ISD::PREFETCH, specifically SDNPMayLoad and; // SDNPMayStore.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:3,Testability,Assert,Assert,3,// Assert that the linux ABI is enabled for the current compilation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:49,Modifiability,extend,extend,49,"// Comparisons of short integers should use sign-extend, not zero-extend,; // since we can represent small negative values in the compare instructions.; // The LLVM default is to use zero-extend arbitrarily in these cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:66,Modifiability,extend,extend,66,"// Comparisons of short integers should use sign-extend, not zero-extend,; // since we can represent small negative values in the compare instructions.; // The LLVM default is to use zero-extend arbitrarily in these cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:188,Modifiability,extend,extend,188,"// Comparisons of short integers should use sign-extend, not zero-extend,; // since we can represent small negative values in the compare instructions.; // The LLVM default is to use zero-extend arbitrarily in these cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:10,Modifiability,extend,extend,10,// A sign-extend of a truncate of a sign-extend is free.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:41,Modifiability,extend,extend,41,// A sign-extend of a truncate of a sign-extend is free.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:26,Modifiability,extend,extended,26,// The type that was sign-extended to get the AssertSext must be; // narrower than the type of N (so that N has still the same value; // as the original).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:46,Testability,Assert,AssertSext,46,// The type that was sign-extended to get the AssertSext must be; // narrower than the type of N (so that N has still the same value; // as the original).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:16,Modifiability,extend,extended,16,// We have sign-extended loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:25,Performance,load,loads,25,// We have sign-extended loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:22,Performance,load,loads,22,// Specifies that for loads and stores VT can be promoted to PromotedLdStVT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:3,Performance,Load,Load,3,// Load the offset value for TLS symbol.This offset is relative to; // thread pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:31,Modifiability,variab,variable,31,// Address of the thread local variable is the add of thread; // pointer and the offset of the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:95,Modifiability,variab,variable,95,// Address of the thread local variable is the add of thread; // pointer and the offset of the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:31,Modifiability,variab,variable,31,// Address of the thread local variable is the add of thread; // pointer and the offset of the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:95,Modifiability,variab,variable,95,// Address of the thread local variable is the add of thread; // pointer and the offset of the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:103,Performance,load,loads,103,"//; // Handling of scalar operations.; //; // All operations default to ""legal"", except:; // - indexed loads and stores (pre-/post-incremented),; // - ANY_EXTEND_VECTOR_INREG, ATOMIC_CMP_SWAP_WITH_SUCCESS, CONCAT_VECTORS,; // ConstantFP, DEBUGTRAP, FCEIL, FCOPYSIGN, FEXP, FEXP2, FFLOOR, FGETSIGN,; // FLOG, FLOG2, FLOG10, FMAXNUM, FMINNUM, FNEARBYINT, FRINT, FROUND, TRAP,; // FTRUNC, PREFETCH, SIGN_EXTEND_VECTOR_INREG, ZERO_EXTEND_VECTOR_INREG,; // which default to ""expand"" for at least one type.; // Misc operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:20,Performance,optimiz,optimize,20,// Hexagon needs to optimize cases with negative constants.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:6,Modifiability,extend,extending,6,// No extending loads from i32.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:16,Performance,load,loads,16,// No extending loads from i32.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:24,Performance,load,load,24,// Turn FP extload into load/fpextend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:3,Testability,Log,Logical,3,// Logical/bit:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:14,Modifiability,extend,extending,14,// Expand all extending loads and truncating stores:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:24,Performance,load,loads,24,// Expand all extending loads and truncating stores:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:3,Modifiability,Extend,Extending,3,// Extending loads from (native) vectors of i8 into (native) vectors of i16; // are legal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:13,Performance,load,loads,13,// Extending loads from (native) vectors of i8 into (native) vectors of i16; // are legal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:205,Availability,error,error,205,"// Custom lower unaligned loads.; // Also, for both loads and stores, verify the alignment of the address; // in case it is a compile-time constant. This is a usability feature to; // provide a meaningful error message to users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:211,Integrability,message,message,211,"// Custom lower unaligned loads.; // Also, for both loads and stores, verify the alignment of the address; // in case it is a compile-time constant. This is a usability feature to; // provide a meaningful error message to users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:26,Performance,load,loads,26,"// Custom lower unaligned loads.; // Also, for both loads and stores, verify the alignment of the address; // in case it is a compile-time constant. This is a usability feature to; // provide a meaningful error message to users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:52,Performance,load,loads,52,"// Custom lower unaligned loads.; // Also, for both loads and stores, verify the alignment of the address; // in case it is a compile-time constant. This is a usability feature to; // provide a meaningful error message to users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:159,Usability,usab,usability,159,"// Custom lower unaligned loads.; // Also, for both loads and stores, verify the alignment of the address; // in case it is a compile-time constant. This is a usability feature to; // provide a meaningful error message to users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:16,Performance,load,load,16,// Custom-lower load/stores of boolean vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:23,Performance,load,loads,23,"// Handling of indexed loads/stores: default is ""expand"".; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:3,Integrability,Rout,Routines,3,// Routines to handle fp16 storage type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:15,Performance,Load,Load,15,// Bit-reverse Load Intrinsic: Check if the instruction is a bit reverse load; // intrinsic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:73,Performance,load,load,73,// Bit-reverse Load Intrinsic: Check if the instruction is a bit reverse load; // intrinsic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:15,Performance,Load,Load,15,"// Bit-reverse Load Intrinsic :Crawl up and figure out the object from previous; // instruction. So far we only handle bitcast, extract value and bit reverse; // load intrinsic instructions. Should we handle CGEP ?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:162,Performance,load,load,162,"// Bit-reverse Load Intrinsic :Crawl up and figure out the object from previous; // instruction. So far we only handle bitcast, extract value and bit reverse; // load intrinsic instructions. Should we handle CGEP ?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:15,Performance,Load,Load,15,"// Bit-reverse Load Intrinsic: For a PHI Node return either an incoming edge or; // a back edge. If the back edge comes from the intrinsic itself, the incoming; // edge is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:207,Integrability,depend,dependencies,207,"// Bit-reverse Load Intrinsic: Figure out the underlying object the base; // pointer points to, for the bit-reverse load intrinsic. Setting this to; // memoperand might help alias analysis to figure out the dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:15,Performance,Load,Load,15,"// Bit-reverse Load Intrinsic: Figure out the underlying object the base; // pointer points to, for the bit-reverse load intrinsic. Setting this to; // memoperand might help alias analysis to figure out the dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:116,Performance,load,load,116,"// Bit-reverse Load Intrinsic: Figure out the underlying object the base; // pointer points to, for the bit-reverse load intrinsic. Setting this to; // memoperand might help alias analysis to figure out the dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:81,Performance,load,loadXX,81,"// The intrinsic function call is of the form { ElTy, i8* }; // @llvm.hexagon.L2.loadXX.pbr(i8*, i32). The pointer and memory access type; // should be derived from ElTy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:126,Security,access,access,126,"// The intrinsic function call is of the form { ElTy, i8* }; // @llvm.hexagon.L2.loadXX.pbr(i8*, i32). The pointer and memory access type; // should be derived from ElTy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:13,Energy Efficiency,power,power-of-,13,"// Widen non-power-of-2 vectors. Such types cannot be split right now,; // and computeRegisterProperties will override ""split"" with ""widen"",; // which can cause other issues.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:74,Availability,error,error,74,"// If the inputs are not the same as the output, bail. This is not an; // error situation, but complicates the handling and the default expansion; // (into BUILD_VECTOR) should be adequate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:17,Availability,mask,mask,17,// Normalize the mask so that the first non-negative index comes from; // the first operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:23,Availability,mask,mask,23,// Express the shuffle mask in terms of bytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:130,Availability,Mask,MaskIdx,130,"// All non-undef (non-negative) indexes are well within [0..127], so they; // fit in a single byte. Build two 64-bit words:; // - MaskIdx where each byte is the corresponding index (for non-negative; // indexes), and 0xFF for negative indexes, and; // - MaskUnd that has 0xFF for each negative index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:254,Availability,Mask,MaskUnd,254,"// All non-undef (non-negative) indexes are well within [0..127], so they; // fit in a single byte. Build two 64-bit words:; // - MaskIdx where each byte is the corresponding index (for non-negative; // indexes), and 0xFF for negative indexes, and; // - MaskUnd that has 0xFF for each negative index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:21,Modifiability,extend,extend,21,"// For shifts of i8, extend the inputs to i16, then truncate back to i8.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:114,Availability,error,errors,114,"// Extracting the lowest bit is a no-op, but it changes the type,; // so it must be kept as an operation to avoid errors related to; // type mismatches.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:108,Safety,avoid,avoid,108,"// Extracting the lowest bit is a no-op, but it changes the type,; // so it must be kept as an operation to avoid errors related to; // type mismatches.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:51,Integrability,contract,contracted,51,// Scale is how many times the operands need to be contracted to match; // the representation in the target register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:50,Safety,safe,safe,50,"// FIXME: in principle up to 64-bit could be made safe, but it would be very; // fragile at the moment: any support for multiple value returns would be; // liable to disallow tail calls involving i64 -> iN truncation in many cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:35,Performance,load,loads,35,"// Call LowerUnalignedLoad for all loads, it recognizes loads that; // don't need extra aligning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:56,Performance,load,loads,56,"// Call LowerUnalignedLoad for all loads, it recognizes loads that; // don't need extra aligning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:10,Performance,load,load,10,"// If the load aligning is disabled or the load can be broken up into two; // smaller legal loads, do the default (target-independent) expansion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:43,Performance,load,load,43,"// If the load aligning is disabled or the load can be broken up into two; // smaller legal loads, do the default (target-independent) expansion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:92,Performance,load,loads,92,"// If the load aligning is disabled or the load can be broken up into two; // smaller legal loads, do the default (target-independent) expansion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:54,Performance,load,load,54,// Handle it in the default way if this is an indexed load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:32,Performance,load,loads,32,"// The code below generates two loads, both aligned as NeedAlign, and; // with the distance of NeedAlign between them. For that to cover the; // bits that need to be loaded (and without overlapping), the size of; // the loads should be equal to NeedAlign. This is true for all loadable; // types, but add an assertion in case something changes in the future.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:166,Performance,load,loaded,166,"// The code below generates two loads, both aligned as NeedAlign, and; // with the distance of NeedAlign between them. For that to cover the; // bits that need to be loaded (and without overlapping), the size of; // the loads should be equal to NeedAlign. This is true for all loadable; // types, but add an assertion in case something changes in the future.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:220,Performance,load,loads,220,"// The code below generates two loads, both aligned as NeedAlign, and; // with the distance of NeedAlign between them. For that to cover the; // bits that need to be loaded (and without overlapping), the size of; // the loads should be equal to NeedAlign. This is true for all loadable; // types, but add an assertion in case something changes in the future.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:277,Performance,load,loadable,277,"// The code below generates two loads, both aligned as NeedAlign, and; // with the distance of NeedAlign between them. For that to cover the; // bits that need to be loaded (and without overlapping), the size of; // the loads should be equal to NeedAlign. This is true for all loadable; // types, but add an assertion in case something changes in the future.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:308,Testability,assert,assertion,308,"// The code below generates two loads, both aligned as NeedAlign, and; // with the distance of NeedAlign between them. For that to cover the; // bits that need to be loaded (and without overlapping), the size of; // the loads should be equal to NeedAlign. This is true for all loadable; // types, but add an assertion in case something changes in the future.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:179,Performance,load,load,179,"/// isFPImmLegal - Returns true if the target can instruction select the; /// specified FP immediate natively. If false, the legalizer will; /// materialize the FP immediate as a load from a constant pool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:118,Performance,load,load,118,"/// isLegalAddressingMode - Return true if the addressing mode represented by; /// AM is legal for this target, for a load/store of the specified type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:12,Safety,detect,detects,12,"// When LSR detects uses of the same base address to access different; // types (e.g. unions), it will assume a conservative type for these; // uses:; // LSR Use: Kind=Address of void in addrspace(4294967295), ...; // The type Ty passed here would then be ""void"". Skip the alignment; // checks, but do not return false right away, since that confuses; // LSR into crashing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:53,Security,access,access,53,"// When LSR detects uses of the same base address to access different; // types (e.g. unions), it will assume a conservative type for these; // uses:; // LSR Use: Kind=Address of void in addrspace(4294967295), ...; // The type Ty passed here would then be ""void"". Skip the alignment; // checks, but do not return false right away, since that confuses; // LSR into crashing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:94,Performance,optimiz,optimization,94,/// IsEligibleForTailCallOptimization - Check whether the call is eligible; /// for tail call optimization. Targets which want to do tail call; /// optimization should implement this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:148,Performance,optimiz,optimization,148,/// IsEligibleForTailCallOptimization - Check whether the call is eligible; /// for tail call optimization. Targets which want to do tail call; /// optimization should implement this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:114,Performance,perform,perform,114,"// ***************************************************************************; // Look for obvious safe cases to perform tail call optimization that do not; // require ABI changes.; // ***************************************************************************; // If this is a tail call via a function pointer, then don't do it!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:132,Performance,optimiz,optimization,132,"// ***************************************************************************; // Look for obvious safe cases to perform tail call optimization that do not; // require ABI changes.; // ***************************************************************************; // If this is a tail call via a function pointer, then don't do it!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:100,Safety,safe,safe,100,"// ***************************************************************************; // Look for obvious safe cases to perform tail call optimization that do not; // require ABI changes.; // ***************************************************************************; // If this is a tail call via a function pointer, then don't do it!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:10,Performance,optimiz,optimize,10,// Do not optimize if the calling conventions do not match and the conventions; // used are not C or Fast.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:20,Performance,optimiz,optimize,20,// Do not tail call optimize vararg calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:24,Performance,optimiz,optimization,24,// Also avoid tail call optimization if either caller or callee uses struct; // return semantics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:8,Safety,avoid,avoid,8,// Also avoid tail call optimization if either caller or callee uses struct; // return semantics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:251,Availability,avail,available,251,"// In addition to the cases above, we also disable Tail Call Optimization if; // the calling convention code that at least one outgoing argument needs to; // go on the stack. We cannot check that here because at this point that; // information is not available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:61,Performance,Optimiz,Optimization,61,"// In addition to the cases above, we also disable Tail Call Optimization if; // the calling convention code that at least one outgoing argument needs to; // go on the stack. We cannot check that here because at this point that; // information is not available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:49,Performance,load,load,49,"/// Returns the target specific optimal type for load and store operations as; /// a result of memset, memcpy, and memmove lowering.; ///; /// If DstAlign is zero that means it's safe to destination alignment can; /// satisfy any constraint. Similarly if SrcAlign is zero it means there isn't; /// a need to check it against alignment requirement, probably because the; /// source does not need to be loaded. If 'IsMemset' is true, that means it's; /// expanding a memset. If 'ZeroMemset' is true, that means it's a memset of; /// zero. 'MemcpyStrSrc' indicates whether the memcpy source is constant so it; /// does not need to be loaded. It returns EVT::Other if the type should be; /// determined using generic target-independent logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:401,Performance,load,loaded,401,"/// Returns the target specific optimal type for load and store operations as; /// a result of memset, memcpy, and memmove lowering.; ///; /// If DstAlign is zero that means it's safe to destination alignment can; /// satisfy any constraint. Similarly if SrcAlign is zero it means there isn't; /// a need to check it against alignment requirement, probably because the; /// source does not need to be loaded. If 'IsMemset' is true, that means it's; /// expanding a memset. If 'ZeroMemset' is true, that means it's a memset of; /// zero. 'MemcpyStrSrc' indicates whether the memcpy source is constant so it; /// does not need to be loaded. It returns EVT::Other if the type should be; /// determined using generic target-independent logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:631,Performance,load,loaded,631,"/// Returns the target specific optimal type for load and store operations as; /// a result of memset, memcpy, and memmove lowering.; ///; /// If DstAlign is zero that means it's safe to destination alignment can; /// satisfy any constraint. Similarly if SrcAlign is zero it means there isn't; /// a need to check it against alignment requirement, probably because the; /// source does not need to be loaded. If 'IsMemset' is true, that means it's; /// expanding a memset. If 'ZeroMemset' is true, that means it's a memset of; /// zero. 'MemcpyStrSrc' indicates whether the memcpy source is constant so it; /// does not need to be loaded. It returns EVT::Other if the type should be; /// determined using generic target-independent logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:179,Safety,safe,safe,179,"/// Returns the target specific optimal type for load and store operations as; /// a result of memset, memcpy, and memmove lowering.; ///; /// If DstAlign is zero that means it's safe to destination alignment can; /// satisfy any constraint. Similarly if SrcAlign is zero it means there isn't; /// a need to check it against alignment requirement, probably because the; /// source does not need to be loaded. If 'IsMemset' is true, that means it's; /// expanding a memset. If 'ZeroMemset' is true, that means it's a memset of; /// zero. 'MemcpyStrSrc' indicates whether the memcpy source is constant so it; /// does not need to be loaded. It returns EVT::Other if the type should be; /// determined using generic target-independent logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:732,Testability,log,logic,732,"/// Returns the target specific optimal type for load and store operations as; /// a result of memset, memcpy, and memmove lowering.; ///; /// If DstAlign is zero that means it's safe to destination alignment can; /// satisfy any constraint. Similarly if SrcAlign is zero it means there isn't; /// a need to check it against alignment requirement, probably because the; /// source does not need to be loaded. If 'IsMemset' is true, that means it's; /// expanding a memset. If 'ZeroMemset' is true, that means it's a memset of; /// zero. 'MemcpyStrSrc' indicates whether the memcpy source is constant so it; /// does not need to be loaded. It returns EVT::Other if the type should be; /// determined using generic target-independent logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:54,Testability,test,tests,54,// TODO: This may be worth removing. Check regression tests for diffs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:4,Performance,Perform,Perform,4,"/// Perform a store-conditional operation to Addr. Return the status of the; /// store. This should be 0 if the store succeeded, non-zero otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:17,Performance,load,loads,17,// Do not expand loads and stores that don't exceed 64 bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:17,Performance,load,loads,17,// Do not expand loads and stores that don't exceed 64 bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h:53,Integrability,Interface,Interface,53,"//===-- HexagonISelLowering.h - Hexagon DAG Lowering Interface --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that Hexagon uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h:405,Integrability,interface,interfaces,405,"//===-- HexagonISelLowering.h - Hexagon DAG Lowering Interface --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that Hexagon uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h:3,Integrability,Wrap,Wrappers,3,// Wrappers for ISD::*_EXTEND and ISD::TRUNCATE to prevent DAG,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h:576,Integrability,wrap,wrapper,576,"// from auto-folding operations, e.g.; // (i32 ext (i16 ext i8)) would be folded to (i32 ext i8).; // To simplify the type legalization, we want to keep these; // single steps separate during type legalization.; // TL_[EXTEND|TRUNCATE] Inp, i128 _, i32 Opc; // * Inp is the original input to extend/truncate,; // * _ is a dummy operand with an illegal type (can be undef),; // * Opc is the original opcode.; // The legalization process (in Hexagon lowering code) will; // first deal with the ""real"" types (i.e. Inp and the result),; // and once all of them are processed, the wrapper node will; // be replaced with the original ISD node. The dummy illegal; // operand is there to make sure that the legalization hooks; // are called again after everything else is legal, giving; // us the opportunity to undo the wrapping.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h:813,Integrability,wrap,wrapping,813,"// from auto-folding operations, e.g.; // (i32 ext (i16 ext i8)) would be folded to (i32 ext i8).; // To simplify the type legalization, we want to keep these; // single steps separate during type legalization.; // TL_[EXTEND|TRUNCATE] Inp, i128 _, i32 Opc; // * Inp is the original input to extend/truncate,; // * _ is a dummy operand with an illegal type (can be undef),; // * Opc is the original opcode.; // The legalization process (in Hexagon lowering code) will; // first deal with the ""real"" types (i.e. Inp and the result),; // and once all of them are processed, the wrapper node will; // be replaced with the original ISD node. The dummy illegal; // operand is there to make sure that the legalization hooks; // are called again after everything else is legal, giving; // us the opportunity to undo the wrapping.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h:219,Modifiability,EXTEND,EXTEND,219,"// from auto-folding operations, e.g.; // (i32 ext (i16 ext i8)) would be folded to (i32 ext i8).; // To simplify the type legalization, we want to keep these; // single steps separate during type legalization.; // TL_[EXTEND|TRUNCATE] Inp, i128 _, i32 Opc; // * Inp is the original input to extend/truncate,; // * _ is a dummy operand with an illegal type (can be undef),; // * Opc is the original opcode.; // The legalization process (in Hexagon lowering code) will; // first deal with the ""real"" types (i.e. Inp and the result),; // and once all of them are processed, the wrapper node will; // be replaced with the original ISD node. The dummy illegal; // operand is there to make sure that the legalization hooks; // are called again after everything else is legal, giving; // us the opportunity to undo the wrapping.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h:292,Modifiability,extend,extend,292,"// from auto-folding operations, e.g.; // (i32 ext (i16 ext i8)) would be folded to (i32 ext i8).; // To simplify the type legalization, we want to keep these; // single steps separate during type legalization.; // TL_[EXTEND|TRUNCATE] Inp, i128 _, i32 Opc; // * Inp is the original input to extend/truncate,; // * _ is a dummy operand with an illegal type (can be undef),; // * Opc is the original opcode.; // The legalization process (in Hexagon lowering code) will; // first deal with the ""real"" types (i.e. Inp and the result),; // and once all of them are processed, the wrapper node will; // be replaced with the original ISD node. The dummy illegal; // operand is there to make sure that the legalization hooks; // are called again after everything else is legal, giving; // us the opportunity to undo the wrapping.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h:105,Usability,simpl,simplify,105,"// from auto-folding operations, e.g.; // (i32 ext (i16 ext i8)) would be folded to (i32 ext i8).; // To simplify the type legalization, we want to keep these; // single steps separate during type legalization.; // TL_[EXTEND|TRUNCATE] Inp, i128 _, i32 Opc; // * Inp is the original input to extend/truncate,; // * _ is a dummy operand with an illegal type (can be undef),; // * Opc is the original opcode.; // The legalization process (in Hexagon lowering code) will; // first deal with the ""real"" types (i.e. Inp and the result),; // and once all of them are processed, the wrapper node will; // be replaced with the original ISD node. The dummy illegal; // operand is there to make sure that the legalization hooks; // are called again after everything else is legal, giving; // us the opportunity to undo the wrapping.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h:804,Usability,undo,undo,804,"// from auto-folding operations, e.g.; // (i32 ext (i16 ext i8)) would be folded to (i32 ext i8).; // To simplify the type legalization, we want to keep these; // single steps separate during type legalization.; // TL_[EXTEND|TRUNCATE] Inp, i128 _, i32 Opc; // * Inp is the original input to extend/truncate,; // * _ is a dummy operand with an illegal type (can be undef),; // * Opc is the original opcode.; // The legalization process (in Hexagon lowering code) will; // first deal with the ""real"" types (i.e. Inp and the result),; // and once all of them are processed, the wrapper node will; // be replaced with the original ISD node. The dummy illegal; // operand is there to make sure that the legalization hooks; // are called again after everything else is legal, giving; // us the opportunity to undo the wrapping.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h:67,Performance,load,loaded,67,"// Align two vectors (in Op0, Op1) to one that would have; // been loaded from address in Op2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h:82,Performance,load,load,82,"// Align vector address: Op0 & -Op1, except when it is; // an address in a vector load, then it's a no-op.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h:94,Performance,optimiz,optimization,94,/// IsEligibleForTailCallOptimization - Check whether the call is eligible; /// for tail call optimization. Targets which want to do tail call; /// optimization should implement this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h:148,Performance,optimiz,optimization,148,/// IsEligibleForTailCallOptimization - Check whether the call is eligible; /// for tail call optimization. Targets which want to do tail call; /// optimization should implement this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h:118,Performance,load,load,118,"/// isLegalAddressingMode - Return true if the addressing mode represented; /// by AM is legal for this target, for a load/store of the specified type.; /// The type may be VoidTy, in which case only return true if the addressing; /// mode is legal for a load/store of any legal type.; /// TODO: Handle pre/postinc as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h:255,Performance,load,load,255,"/// isLegalAddressingMode - Return true if the addressing mode represented; /// by AM is legal for this target, for a load/store of the specified type.; /// The type may be VoidTy, in which case only return true if the addressing; /// mode is legal for a load/store of any legal type.; /// TODO: Handle pre/postinc as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:105,Performance,load,load,105,"// Custom-lower BUILD_VECTOR. The standard (target-independent); // handling of it would convert it to a load, which is not always; // the optimal choice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:105,Performance,load,load,105,"// Custom-lower BUILD_VECTOR. The standard (target-independent); // handling of it would convert it to a load, which is not always; // the optimal choice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:123,Performance,load,load,123,"// Custom-lower BUILD_VECTOR for vector pairs. The standard (target-; // independent) handling of it would convert it to a load, which is; // not always the optimal choice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:3,Availability,Mask,Masked,3,// Masked load/store takes a mask that may need splitting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:29,Availability,mask,mask,29,// Masked load/store takes a mask that may need splitting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:10,Performance,load,load,10,// Masked load/store takes a mask that may need splitting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:107,Performance,load,loaded,107,"// Bool vectors are excluded by default, but make it explicit to; // emphasize that bool vectors cannot be loaded or stored.; // Also, disallow double vector stores (to prevent unnecessary; // store widening in DAG combiner).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:159,Energy Efficiency,efficient,efficiently,159,"// A special case is a situation where the vector is built entirely from; // elements extracted from another vector. This could be done via a shuffle; // more efficiently, but typically, the size of the source vector will not; // match the size of the vector being built (which precludes the use of a; // shuffle directly).; // This only handles a single source vector, and the vector being built; // should be of a sub-vector type of the source vector type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:27,Availability,mask,mask,27,"// Construct a new shuffle mask that will produce a vector with the same; // number of elements as the input vector, and such that the vector we; // want will be the initial subvector of it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:24,Availability,mask,mask,24,"// Fill the rest of the mask with the unused elements of ExtVec in hopes; // that it will result in a permutation of ExtVec's elements. It's still; // fine if it doesn't (e.g. if undefs are present, or elements are; // repeated), but permutations can always be done efficiently via vdelta; // and vrdelta.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:266,Energy Efficiency,efficient,efficiently,266,"// Fill the rest of the mask with the unused elements of ExtVec in hopes; // that it will result in a permutation of ExtVec's elements. It's still; // fine if it doesn't (e.g. if undefs are present, or elements are; // repeated), but permutations can always be done efficiently via vdelta; // and vrdelta.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:66,Safety,avoid,avoid,66,// Find most common element to initialize vector with. This is to avoid; // unnecessary vinsert/valign for cases where the same value is present; // many times. Creates a histogram of the vector's elements to find the; // most common element n.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:157,Performance,perform,performed,157,"// Construct two halves in parallel, then or them together. Rn and Rm count; // number of rotations needed before the next element. One last rotation is; // performed post-loop to position the last element.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:3,Performance,Perform,Perform,3,// Perform last rotation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:73,Availability,down,down,73,"// Move the vector predicate SubV to a vector register, and scale it; // down to match the representation (bytes per type element) that VecV; // uses. The scaling down will pick every 2nd or 4th (every Scale-th; // in general) element and put them at the front of the resulting; // vector. This subvector will then be inserted into the Q2V of VecV.; // To avoid having an operation that generates an illegal type (short; // vector), generate a full size vector.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:163,Availability,down,down,163,"// Move the vector predicate SubV to a vector register, and scale it; // down to match the representation (bytes per type element) that VecV; // uses. The scaling down will pick every 2nd or 4th (every Scale-th; // in general) element and put them at the front of the resulting; // vector. This subvector will then be inserted into the Q2V of VecV.; // To avoid having an operation that generates an illegal type (short; // vector), generate a full size vector.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:356,Safety,avoid,avoid,356,"// Move the vector predicate SubV to a vector register, and scale it; // down to match the representation (bytes per type element) that VecV; // uses. The scaling down will pick every 2nd or 4th (every Scale-th; // in general) element and put them at the front of the resulting; // vector. This subvector will then be inserted into the Q2V of VecV.; // To avoid having an operation that generates an illegal type (short; // vector), generate a full size vector.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:508,Safety,avoid,avoid,508,"// Converting between a vector predicate and a scalar predicate. In the; // vector predicate, a group of BitBytes bits will correspond to a single; // i1 element of the source vector type. Those bits will all have the same; // value. The same will be true for ByteVec, where each byte corresponds; // to a bit in the vector predicate.; // The algorithm is to traverse the ByteVec, going over the i1 values from; // the source vector, and generate the corresponding representation in an; // 8-byte vector. To avoid repeated extracts from ByteVec, shuffle the; // elements so that the interesting 8 bytes will be in the low end of the; // vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:131,Deployability,update,update,131,"// The subvector being inserted must be entirely contained in one of; // the vectors V0 or V1. Set SingleV to the correct one, and update; // IdxV to be the index relative to the beginning of that vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:134,Availability,mask,mask,134,// ByteVec is the target vector VecV rotated in such a way that the; // subvector should be inserted at index 0. Generate a predicate mask; // and use vmux to do the insertion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:17,Modifiability,extend,extending,17,"// Sign- and any-extending of a vector predicate to a vector register is; // equivalent to Q2V. For zero-extensions, generate a vmux between 0 and; // a vector of 1s (where the 1s are of type matching the vector type).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:288,Modifiability,extend,extend,288,"// A vector of i16 will be broken up into a build_vector of i16's.; // This is a problem, since at the time of operation legalization,; // all operations are expected to be type-legalized, and i16 is not; // a legal type. If any of the extracted elements is not of a valid; // type, sign-extend it to a valid one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:13,Modifiability,extend,extends,13,"// Lower any-extends of boolean vectors to sign-extends, since they; // translate directly to Q2V. Zero-extending could also be done equally; // fast, but Q2V is used/recognized in more places.; // For all other vectors, use zero-extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:48,Modifiability,extend,extends,48,"// Lower any-extends of boolean vectors to sign-extends, since they; // translate directly to Q2V. Zero-extending could also be done equally; // fast, but Q2V is used/recognized in more places.; // For all other vectors, use zero-extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:104,Modifiability,extend,extending,104,"// Lower any-extends of boolean vectors to sign-extends, since they; // translate directly to Q2V. Zero-extending could also be done equally; // fast, but Q2V is used/recognized in more places.; // For all other vectors, use zero-extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:230,Modifiability,extend,extend,230,"// Lower any-extends of boolean vectors to sign-extends, since they; // translate directly to Q2V. Zero-extending could also be done equally; // fast, but Q2V is used/recognized in more places.; // For all other vectors, use zero-extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:18,Modifiability,extend,extends,18,// Sign- and zero-extends are legal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:43,Integrability,depend,depending,43,"// If the shift amount was 0, pick A or B, depending on the direction.; // The opposite shift will also be by 0, so the ""Or"" will be incorrect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:35,Availability,mask,masked,35,// MSTORE; // HVX only has aligned masked stores.; // TODO: Fold negations of the mask into the store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:82,Availability,mask,mask,82,// MSTORE; // HVX only has aligned masked stores.; // TODO: Fold negations of the mask into the store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:56,Modifiability,extend,extend,56,"// Compare the widths of elements of the two types, and extend the narrower; // type to match the with of the wider type. For vector types, apply this; // to the element type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:3,Modifiability,Rewrite,Rewrite,3,"// Rewrite conversion between integer and floating-point in such a way that; // the integer type is extended/narrowed to match the bitwidth of the; // floating-point type, combined with additional integer-integer extensions; // or narrowings to match the original input/result types.; // E.g. f32 -> i8 ==> f32 -> i32 -> i8; //; // The input/result types are not required to be legal, but if they are; // legal, this function should not introduce illegal types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:100,Modifiability,extend,extended,100,"// Rewrite conversion between integer and floating-point in such a way that; // the integer type is extended/narrowed to match the bitwidth of the; // floating-point type, combined with additional integer-integer extensions; // or narrowings to match the original input/result types.; // E.g. f32 -> i8 ==> f32 -> i32 -> i8; //; // The input/result types are not required to be legal, but if they are; // legal, this function should not introduce illegal types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:30,Modifiability,extend,extends,30,"// In general, sign- and zero-extends can't be split and still; // be legal. The only exception is extending bool vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:99,Modifiability,extend,extending,99,"// In general, sign- and zero-extends can't be split and still; // be legal. The only exception is extending bool vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:13,Performance,load,loads,13,// Unaligned loads will be handled by the default lowering.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:3,Modifiability,Rewrite,Rewrite,3,"// Rewrite the extension/truncation/saturation op into steps where each; // step changes the type widths by a factor of 2.; // E.g. i8 -> i16 remains unchanged, but i8 -> i32 ==> i8 -> i16 -> i32.; //; // Some of the vector types in Op may not be legal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:3,Usability,Simpl,Simplify,3,"// Simplify V:v2NiB --(bitcast)--> vNi2B --(truncate)--> vNiB; // to extract-subvector (shuffle V, pick even, pick odd)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:3,Performance,Perform,Perform,3,"// Perform a deep clone of the expression, set Root to the root; // of the clone, and build a map from the cloned values to the; // original ones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:8,Usability,simpl,simply,8,"// Now, simply replace OldV with NewV in Root.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:179,Availability,mask,masked,179,"// Match the following:; // select (X & (1 << i)) != 0 ? R ^ (Q << i) : R; // select (X & (1 << i)) == 0 ? R : R ^ (Q << i); // The condition may also check for equality with the masked value, i.e; // select (X & (1 << i)) == (1 << i) ? R ^ (Q << i) : R; // select (X & (1 << i)) != (1 << i) ? R : R ^ (Q << i);",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:43,Modifiability,variab,variable,43,// TODO: Could also check for an induction variable containing single; // bit shifted left by 1 in each iteration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:66,Integrability,depend,depending,66,// Matched: select +++ ? R : R ^ T; // select +++ ? R ^ T : R; // depending on TrueIfZero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:109,Modifiability,variab,variable,109,"// The xor input value T is isolated into its own match so that it could; // be checked against an induction variable containing a shifted bit; // (todo).; // For now, check against (Q << i).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:179,Availability,mask,masked,179,"// Match the following:; // select (X & 1) != 0 ? (R >> 1) ^ Q : (R >> 1); // select (X & 1) == 0 ? (R >> 1) : (R >> 1) ^ Q; // The condition may also check for equality with the masked value, i.e; // select (X & 1) == 1 ? (R >> 1) ^ Q : (R >> 1); // select (X & 1) != 1 ? (R >> 1) : (R >> 1) ^ Q",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:41,Testability,test,tested,41,"// The select's condition is true if the tested bit is 0.; // TrueV must be the shift, FalseV must be the xor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:41,Testability,test,tested,41,"// The select's condition is true if the tested bit is 1.; // TrueV must be the xor, FalseV must be the shift.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:99,Testability,test,test-bit,99,"// The basic pattern for R = P.Q is:; // for i = 0..31; // R = phi (0, R'); // if (P & (1 << i)) ; test-bit(P, i); // R' = R ^ (Q << i); //; // Similarly, the basic pattern for R = (P/Q).Q - P; // for i = 0..31; // R = phi(P, R'); // if (R & (1 << i)); // R' = R ^ (Q << i); // There exist idioms, where instead of Q being shifted left, P is shifted; // right. This produces a result that is shifted right by 32 bits (the; // non-shifted result is 64-bit).; //; // For R = P.Q, this would be:; // for i = 0..31; // R = phi (0, R'); // if ((P >> i) & 1); // R' = (R >> 1) ^ Q ; R is cycled through the loop, so it must; // else ; be shifted by 1, not i.; // R' = R >> 1; //; // And for the inverse:; // for i = 0..31; // R = phi (P, R'); // if (R & 1); // R' = (R >> 1) ^ Q; // else; // R' = R >> 1; // The left-shifting idioms share the same pattern:; // select (X & (1 << i)) ? R ^ (Q << i) : R; // Similarly for right-shifting idioms:; // select (X & 1) ? (R >> 1) ^ Q",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:133,Modifiability,variab,variable,133,"// X is not loop invariant. If X == R, this is the inverse pmpy.; // Otherwise, check for an xor with an invariant value. If the; // variable argument to the xor is R, then this is still a valid; // inverse pmpy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:3,Performance,Perform,Perform,3,// Perform the promotion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:9,Deployability,update,update,9,// Final update of the P's type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:38,Testability,log,logical,38,// Find all value cycles that contain logical right shifts by 1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:49,Integrability,depend,depending,49,"// First, the shift amount will be CIV or CIV+1, depending on; // whether the value is early or late. Instead of creating CIV+1,; // do a single shift of the value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:3,Deployability,Update,Update,3,"// Update the users outside of the loop to account for having left; // shifts. They would normally be shifted right in the loop, so shift; // them right after the loop exit.; // Take advantage of the loop-closed SSA form, which has all the post-; // loop values in phi nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:16,Availability,mask,mask,16,// Create a bit mask to clear the high bits beyond IterCount.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:24,Usability,clear,clear,24,// Create a bit mask to clear the high bits beyond IterCount.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:10,Usability,clear,clearing,10,"// Again, clearing bits beyond IterCount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:159,Modifiability,variab,variable,159,"// Restrictions:; // - The loop must consist of a single block.; // - The iteration count must be known at compile-time.; // - The loop must have an induction variable starting from 0, and; // incremented in each iteration of the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:3,Performance,Perform,Perform,3,"// Perform a preliminary scan of select instructions to see if any of them; // looks like a generator of the polynomial multiply steps. Assume that a; // loop can only contain a single transformable operation, so stop the; // traversal after the first reasonable candidate was found.; // XXX: Currently this approach can modify the loop before being 100% sure; // that the transformation can be carried out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:22,Usability,simpl,simplifications,22,// Run post-promotion simplifications.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:44,Performance,load,load,44,// The store must be feeding a non-volatile load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:113,Performance,load,load,113,"// See if the pointer expression is an AddRec like {base,+,1} on the current; // loop, which indicates a strided load. If we have something else, it's a; // random load we can't handle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:164,Performance,load,load,164,"// See if the pointer expression is an AddRec like {base,+,1} on the current; // loop, which indicates a strided load. If we have something else, it's a; // random load we can't handle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:17,Performance,load,load,17,// The store and load must share the same stride.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:68,Security,access,access,68,"/// mayLoopAccessLocation - Return true if the specified loop might access the; /// specified pointer location, which is a loop-strided access. The 'Access'; /// argument specifies what the verboten forms of access are (read or write).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:136,Security,access,access,136,"/// mayLoopAccessLocation - Return true if the specified loop might access the; /// specified pointer location, which is a loop-strided access. The 'Access'; /// argument specifies what the verboten forms of access are (read or write).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:149,Security,Access,Access,149,"/// mayLoopAccessLocation - Return true if the specified loop might access the; /// specified pointer location, which is a loop-strided access. The 'Access'; /// argument specifies what the verboten forms of access are (read or write).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:208,Security,access,access,208,"/// mayLoopAccessLocation - Return true if the specified loop might access the; /// specified pointer location, which is a loop-strided access. The 'Access'; /// argument specifies what the verboten forms of access are (read or write).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:66,Security,access,access,66,"// Get the location that may be stored across the loop. Since the access; // is strided positively through memory, we say that the modified location; // starts at the pointer and has infinite size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:67,Security,access,access,67,"// If the loop iterates a fixed number of times, we can refine the access; // size to be exactly the size of the memset, which is (BECount+1)*StoreSize",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:113,Performance,load,load,113,"// See if the pointer expression is an AddRec like {base,+,1} on the current; // loop, which indicates a strided load. If we have something else, it's a; // random load we can't handle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:164,Performance,load,load,164,"// See if the pointer expression is an AddRec like {base,+,1} on the current; // loop, which indicates a strided load. If we have something else, it's a; // random load we can't handle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:45,Performance,load,loaded,45,"// Okay, we have a strided store ""p[i]"" of a loaded value. We can turn; // this into a memcpy/memmove in the loop preheader now if we want. However,; // this would be unsafe to do if there is anything else in the loop that may; // read or write the memory region we're storing to. For memcpy, this; // includes the load that feeds the stores. Check for an alias by generating; // the base address and checking everything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:315,Performance,load,load,315,"// Okay, we have a strided store ""p[i]"" of a loaded value. We can turn; // this into a memcpy/memmove in the loop preheader now if we want. However,; // this would be unsafe to do if there is anything else in the loop that may; // read or write the memory region we're storing to. For memcpy, this; // includes the load that feeds the stores. Check for an alias by generating; // the base address and checking everything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:167,Safety,unsafe,unsafe,167,"// Okay, we have a strided store ""p[i]"" of a loaded value. We can turn; // this into a memcpy/memmove in the loop preheader now if we want. However,; // this would be unsafe to do if there is anything else in the loop that may; // read or write the memory region we're storing to. For memcpy, this; // includes the load that feeds the stores. Check for an alias by generating; // the base address and checking everything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:16,Performance,load,load,16,// Check if the load is the offending instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:22,Performance,load,load,22,// It worked with the load ignored.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:207,Integrability,depend,depend,207,"// In case of a memmove, the call to memmove will be executed instead; // of the loop, so we need to make sure that there is nothing else in; // the loop than the load, store and instructions that these two depend; // on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:163,Performance,load,load,163,"// In case of a memmove, the call to memmove will be executed instead; // of the loop, so we need to make sure that there is nothing else in; // the loop than the load, store and instructions that these two depend; // on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:39,Deployability,update,update,39,"// Create a new (empty) preheader, and update the PHI nodes in the; // header to use the new preheader.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:13,Safety,safe,safe,13,"// Check for safe conditions to execute memmove.; // If stride is positive, copying things from higher to lower addresses; // is equivalent to memmove. For negative stride, it's the other way; // around. Copying forward in memory with positive stride may not be; // same as memmove since we may be copying values that we just stored; // in some previous iteration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:59,Integrability,depend,dependencies,59,"// Check if the instructions in Insts, together with their dependencies; // cover the loop in the sense that the loop could be safely eliminated once; // the instructions in Insts are removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:127,Safety,safe,safely,127,"// Check if the instructions in Insts, together with their dependencies; // cover the loop in the sense that the loop could be safely eliminated once; // the instructions in Insts are removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:77,Integrability,depend,depend,77,"// Collect all instructions from the loop that the instructions in Insts; // depend on (plus their dependencies, etc.). These instructions will; // constitute the expression trees that feed those in Insts, but the trees; // will be limited only to instructions contained in the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:99,Integrability,depend,dependencies,99,"// Collect all instructions from the loop that the instructions in Insts; // depend on (plus their dependencies, etc.). These instructions will; // constitute the expression trees that feed those in Insts, but the trees; // will be limited only to instructions contained in the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:45,Performance,optimiz,optimized,45,"// Look for store instructions, which may be optimized to memset/memcpy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:3,Performance,Optimiz,Optimize,3,"// Optimize the store into a memcpy, if it feeds an similarly strided load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:70,Performance,load,load,70,"// Optimize the store into a memcpy, if it feeds an similarly strided load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonMachineScheduler.cpp:40,Energy Efficiency,Schedul,Scheduler,40,"//===- HexagonMachineScheduler.cpp - MI Scheduler for Hexagon -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // MachineScheduler schedules machine instructions after phi elimination. It; // preserves LiveIntervals so it can be invoked before register allocation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonMachineScheduler.cpp:400,Energy Efficiency,schedul,schedules,400,"//===- HexagonMachineScheduler.cpp - MI Scheduler for Hexagon -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // MachineScheduler schedules machine instructions after phi elimination. It; // preserves LiveIntervals so it can be invoked before register allocation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonMachineScheduler.cpp:30,Integrability,depend,dependence,30,/// Return true if there is a dependence between SUd and SUu.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonMachineScheduler.h:53,Energy Efficiency,schedul,scheduler,53,"//===- HexagonMachineScheduler.h - Custom Hexagon MI scheduler --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Custom Hexagon MI scheduler.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonMachineScheduler.h:401,Energy Efficiency,schedul,scheduler,401,"//===- HexagonMachineScheduler.h - Custom Hexagon MI scheduler --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Custom Hexagon MI scheduler.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonNewValueJump.cpp:248,Testability,log,logic,248,"// Bail out if feederReg is a paired register (double regs in; // our case). One would think that we can check to see if a given; // register cmpReg1 or cmpReg2 is a sub register of feederReg; // using -- if (QRI->isSubRegister(feederReg, cmpReg1) logic; // before the callsite of this function; // But we can not as it comes in the following fashion.; // %d0 = Hexagon_S2_lsr_r_p killed %d0, killed %r2; // %r0 = KILL %r0, implicit killed %d0; // %p0 = CMPEQri killed %r0, 0; // Hence, we need to check if it's a KILL instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonNewValueJump.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonNewValueJump.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonNewValueJump.cpp:472,Safety,hazard,hazards,472,"// Make sure there is no 'def' or 'use' of any of the uses of; // feeder insn between its definition, this MI and jump, jmpInst; // skipping compare, cmpInst.; // Here's the example.; // r21=memub(r22+r24<<#0); // p0 = cmp.eq(r21, #0); // r4=memub(r3+r21<<#0); // if (p0.new) jump:t .LBB29_45; // Without this check, it will be converted into; // r4=memub(r3+r21<<#0); // r21=memub(r22+r24<<#0); // p0 = cmp.eq(r21, #0); // if (p0.new) jump:t .LBB29_45; // and result WAR hazards if converted to New Value Jump.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonNewValueJump.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonNewValueJump.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonNewValueJump.cpp:44,Performance,perform,performed,44,// These are the common checks that need to performed; // to determine if; // 1. compare instruction can be moved before jump.; // 2. feeder to the compare instruction can be moved before jump.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonNewValueJump.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonNewValueJump.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonNewValueJump.cpp:26,Safety,avoid,avoid,26,// return *some value* to avoid compiler warning,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonNewValueJump.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonNewValueJump.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonNewValueJump.cpp:70,Modifiability,variab,variable,70,// If we move NewValueJump before register allocation we'll need live variable; // analysis here too.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonNewValueJump.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonNewValueJump.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonNewValueJump.cpp:281,Modifiability,variab,variable,281,"// If ifconverter had not messed up with the kill flags of the; // operands, the following check on the kill flag would suffice.; // if(!jmpInstr->getOperand(0).isKill()) break;; // This predicate register is live out of BB; // this would only work if we can actually use Live; // variable analysis on phy regs - but LLVM does not; // provide LV analysis on phys regs.; //if(LVs.isLiveOut(predReg, *MBB)) break;; // Get all the successors of this block - which will always; // be 2. Check if the predicate register is live-in in those; // successor. If yes, we can not delete the predicate -; // I am doing this only because LLVM does not provide LiveOut; // at the BB level.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonNewValueJump.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonNewValueJump.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:422,Performance,optimiz,optimize,422,"//===- HexagonOptAddrMode.cpp ---------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This implements a Hexagon-specific pass to optimize addressing mode for; // load/store instructions.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:455,Performance,load,load,455,"//===- HexagonOptAddrMode.cpp ---------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This implements a Hexagon-specific pass to optimize addressing mode for; // load/store instructions.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:97,Performance,load,load,97,"// Check if addasl instruction can be removed. This is possible only; // if it's feeding to only load/store instructions with base + register; // offset as these instruction can be tranformed to use 'absolute plus; // shifted register offset'.; // ex:; // Rs = ##foo; // Rx = addasl(Rs, Rt, #2); // Rd = memw(Rx + #28); // Above three instructions can be replaced with Rd = memw(Rt<<#2 + ##foo+28)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:34,Performance,load,load,34,// The reaching def of LRExtRR at load/store node should be same as the; // one reaching at the SN.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:107,Modifiability,extend,extend,107,"// If the register is undefined (for example if it's a reserved register),; // it may still be possible to extend the range, but it's safer to be; // conservative and just punt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:134,Safety,safe,safer,134,"// If the register is undefined (for example if it's a reserved register),; // it may still be possible to extend the range, but it's safer to be; // conservative and just punt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:51,Modifiability,extend,extend,51,// only HVX vgather instructions handled; // TODO: extend the pass to other vector load/store operations,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:83,Performance,load,load,83,// only HVX vgather instructions handled; // TODO: extend the pass to other vector load/store operations,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:18,Modifiability,extend,extending,18,"// Since we'll be extending the live range of Rt in the following example,; // make sure that is safe. another definition of Rt doesn't exist between 'add'; // and load/store instruction.; //; // Ex: Rx= add(Rt,#10); // memw(Rx+#0) = Rs; // will be replaced with => memw(Rt+#10) = Rs",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:164,Performance,load,load,164,"// Since we'll be extending the live range of Rt in the following example,; // make sure that is safe. another definition of Rt doesn't exist between 'add'; // and load/store instruction.; //; // Ex: Rx= add(Rt,#10); // memw(Rx+#0) = Rs; // will be replaced with => memw(Rt+#10) = Rs",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:97,Safety,safe,safe,97,"// Since we'll be extending the live range of Rt in the following example,; // make sure that is safe. another definition of Rt doesn't exist between 'add'; // and load/store instruction.; //; // Ex: Rx= add(Rt,#10); // memw(Rx+#0) = Rs; // will be replaced with => memw(Rt+#10) = Rs",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:3,Deployability,Update,Update,3,// Update all the uses of 'add' with the appropriate base and offset; // values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:155,Deployability,update,update,155,// Set the reachingDef for UseNode under consideration; // after updating the Add use. This local change is; // to avoid rebuilding of the RDF graph after update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:115,Safety,avoid,avoid,115,// Set the reachingDef for UseNode under consideration; // after updating the Add use. This local change is; // to avoid rebuilding of the RDF graph after update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:3,Energy Efficiency,Reduce,Reduce,3,// Reduce size by 1 as addasl itself can be removed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:19,Performance,load,load,19,"// Currently, only load/store and addasl are handled.; // Some other instructions to consider -; // A2_add -> A2_addi; // M4_mpyrr_addr -> M4_mpyrr_addi",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:3,Energy Efficiency,Reduce,Reduce,3,// Reduce total size by 2 if original tfr can be deleted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:165,Deployability,update,updated,165,"// Analyze all uses of 'add'. If the output of 'add' is used as an address; // in the base+immediate addressing mode load/store instructions, see if; // they can be updated to use the immediate value as an offet. Thus,; // providing us the opportunity to eliminate 'add'.; // Ex: Rx= add(Rt,#12); // memw(Rx+#0) = Rs; // This can be replaced with memw(Rt+#12) = Rs; //; // This transformation is only performed if all uses can be updated and; // the offset isn't required to be constant extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:430,Deployability,update,updated,430,"// Analyze all uses of 'add'. If the output of 'add' is used as an address; // in the base+immediate addressing mode load/store instructions, see if; // they can be updated to use the immediate value as an offet. Thus,; // providing us the opportunity to eliminate 'add'.; // Ex: Rx= add(Rt,#12); // memw(Rx+#0) = Rs; // This can be replaced with memw(Rt+#12) = Rs; //; // This transformation is only performed if all uses can be updated and; // the offset isn't required to be constant extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:487,Modifiability,extend,extended,487,"// Analyze all uses of 'add'. If the output of 'add' is used as an address; // in the base+immediate addressing mode load/store instructions, see if; // they can be updated to use the immediate value as an offet. Thus,; // providing us the opportunity to eliminate 'add'.; // Ex: Rx= add(Rt,#12); // memw(Rx+#0) = Rs; // This can be replaced with memw(Rt+#12) = Rs; //; // This transformation is only performed if all uses can be updated and; // the offset isn't required to be constant extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:117,Performance,load,load,117,"// Analyze all uses of 'add'. If the output of 'add' is used as an address; // in the base+immediate addressing mode load/store instructions, see if; // they can be updated to use the immediate value as an offet. Thus,; // providing us the opportunity to eliminate 'add'.; // Ex: Rx= add(Rt,#12); // memw(Rx+#0) = Rs; // This can be replaced with memw(Rt+#12) = Rs; //; // This transformation is only performed if all uses can be updated and; // the offset isn't required to be constant extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:401,Performance,perform,performed,401,"// Analyze all uses of 'add'. If the output of 'add' is used as an address; // in the base+immediate addressing mode load/store instructions, see if; // they can be updated to use the immediate value as an offet. Thus,; // providing us the opportunity to eliminate 'add'.; // Ex: Rx= add(Rt,#12); // memw(Rx+#0) = Rs; // This can be replaced with memw(Rt+#12) = Rs; //; // This transformation is only performed if all uses can be updated and; // the offset isn't required to be constant extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:52,Performance,Perform,Perform,52,// Analyze all uses and calculate increase in size. Perform the optimization; // only if there is no increase in size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:64,Performance,optimiz,optimization,64,// Analyze all uses and calculate increase in size. Perform the optimization; // only if there is no increase in size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp:66,Modifiability,extend,extends,66,"//===- HexagonOptimizeSZextends.cpp - Remove unnecessary argument extends -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Pass that removes sign extends for function parameters. These parameters; // are already sign extended by the caller per Hexagon's ABI; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp:406,Modifiability,extend,extends,406,"//===- HexagonOptimizeSZextends.cpp - Remove unnecessary argument extends -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Pass that removes sign extends for function parameters. These parameters; // are already sign extended by the caller per Hexagon's ABI; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp:477,Modifiability,extend,extended,477,"//===- HexagonOptimizeSZextends.cpp - Remove unnecessary argument extends -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Pass that removes sign extends for function parameters. These parameters; // are already sign extended by the caller per Hexagon's ABI; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp:24,Modifiability,extend,extends,24,// Try to optimize sign extends in formal parameters. It's relying on; // callee already sign extending the values. I'm not sure if our ABI; // requires callee to sign extend though.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp:94,Modifiability,extend,extending,94,// Try to optimize sign extends in formal parameters. It's relying on; // callee already sign extending the values. I'm not sure if our ABI; // requires callee to sign extend though.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp:168,Modifiability,extend,extend,168,// Try to optimize sign extends in formal parameters. It's relying on; // callee already sign extending the values. I'm not sure if our ABI; // requires callee to sign extend though.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp:10,Performance,optimiz,optimize,10,// Try to optimize sign extends in formal parameters. It's relying on; // callee already sign extending the values. I'm not sure if our ABI; // requires callee to sign extend though.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp:17,Availability,redundant,redundant,17,"// Try to remove redundant sext operations on Hexagon. The hardware; // already sign extends many 16 bit intrinsic operations to 32 bits.; // For example:; // %34 = tail call i32 @llvm.hexagon.A2.addh.l16.sat.ll(i32 %x, i32 %y); // %sext233 = shl i32 %34, 16; // %conv52 = ashr exact i32 %sext233, 16",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp:85,Modifiability,extend,extends,85,"// Try to remove redundant sext operations on Hexagon. The hardware; // already sign extends many 16 bit intrinsic operations to 32 bits.; // For example:; // %34 = tail call i32 @llvm.hexagon.A2.addh.l16.sat.ll(i32 %x, i32 %y); // %sext233 = shl i32 %34, 16; // %conv52 = ashr exact i32 %sext233, 16",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp:17,Safety,redund,redundant,17,"// Try to remove redundant sext operations on Hexagon. The hardware; // already sign extends many 16 bit intrinsic operations to 32 bits.; // For example:; // %34 = tail call i32 @llvm.hexagon.A2.addh.l16.sat.ll(i32 %x, i32 %y); // %sext233 = shl i32 %34, 16; // %conv52 = ashr exact i32 %sext233, 16",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp:40,Testability,log,logical,40,// The first operand of Ashr comes from logical shift left.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp:367,Availability,redundant,redundant,367,"//===-- HexagonPeephole.cpp - Hexagon Peephole Optimiztions ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; // This peephole pass optimizes in the following cases.; // 1. Optimizes redundant sign extends for the following case; // Transform the following pattern; // %170 = SXTW %166; // ...; // %176 = COPY %170:isub_lo; //; // Into; // %176 = COPY %166; //; // 2. Optimizes redundant negation of predicates.; // %15 = CMPGTrr %6, %2; // ...; // %16 = NOT_p killed %15; // ...; // JMP_c killed %16, <%bb.1>, implicit dead %pc; //; // Into; // %15 = CMPGTrr %6, %2;; // ...; // JMP_cNot killed %15, <%bb.1>, implicit dead %pc;; //; // Note: The peephole pass makes the instrucstions like; // %170 = SXTW %166 or %16 = NOT_p killed %15; // redundant and relies on some form of dead removal instructions, like; // DCE or DIE to actually eliminate them.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp:562,Availability,redundant,redundant,562,"//===-- HexagonPeephole.cpp - Hexagon Peephole Optimiztions ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; // This peephole pass optimizes in the following cases.; // 1. Optimizes redundant sign extends for the following case; // Transform the following pattern; // %170 = SXTW %166; // ...; // %176 = COPY %170:isub_lo; //; // Into; // %176 = COPY %166; //; // 2. Optimizes redundant negation of predicates.; // %15 = CMPGTrr %6, %2; // ...; // %16 = NOT_p killed %15; // ...; // JMP_c killed %16, <%bb.1>, implicit dead %pc; //; // Into; // %15 = CMPGTrr %6, %2;; // ...; // JMP_cNot killed %15, <%bb.1>, implicit dead %pc;; //; // Note: The peephole pass makes the instrucstions like; // %170 = SXTW %166 or %16 = NOT_p killed %15; // redundant and relies on some form of dead removal instructions, like; // DCE or DIE to actually eliminate them.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp:925,Availability,redundant,redundant,925,"//===-- HexagonPeephole.cpp - Hexagon Peephole Optimiztions ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; // This peephole pass optimizes in the following cases.; // 1. Optimizes redundant sign extends for the following case; // Transform the following pattern; // %170 = SXTW %166; // ...; // %176 = COPY %170:isub_lo; //; // Into; // %176 = COPY %166; //; // 2. Optimizes redundant negation of predicates.; // %15 = CMPGTrr %6, %2; // ...; // %16 = NOT_p killed %15; // ...; // JMP_c killed %16, <%bb.1>, implicit dead %pc; //; // Into; // %15 = CMPGTrr %6, %2;; // ...; // JMP_cNot killed %15, <%bb.1>, implicit dead %pc;; //; // Note: The peephole pass makes the instrucstions like; // %170 = SXTW %166 or %16 = NOT_p killed %15; // redundant and relies on some form of dead removal instructions, like; // DCE or DIE to actually eliminate them.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp:382,Modifiability,extend,extends,382,"//===-- HexagonPeephole.cpp - Hexagon Peephole Optimiztions ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; // This peephole pass optimizes in the following cases.; // 1. Optimizes redundant sign extends for the following case; // Transform the following pattern; // %170 = SXTW %166; // ...; // %176 = COPY %170:isub_lo; //; // Into; // %176 = COPY %166; //; // 2. Optimizes redundant negation of predicates.; // %15 = CMPGTrr %6, %2; // ...; // %16 = NOT_p killed %15; // ...; // JMP_c killed %16, <%bb.1>, implicit dead %pc; //; // Into; // %15 = CMPGTrr %6, %2;; // ...; // JMP_cNot killed %15, <%bb.1>, implicit dead %pc;; //; // Note: The peephole pass makes the instrucstions like; // %170 = SXTW %166 or %16 = NOT_p killed %15; // redundant and relies on some form of dead removal instructions, like; // DCE or DIE to actually eliminate them.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp:47,Performance,Optimiz,Optimiztions,47,"//===-- HexagonPeephole.cpp - Hexagon Peephole Optimiztions ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; // This peephole pass optimizes in the following cases.; // 1. Optimizes redundant sign extends for the following case; // Transform the following pattern; // %170 = SXTW %166; // ...; // %176 = COPY %170:isub_lo; //; // Into; // %176 = COPY %166; //; // 2. Optimizes redundant negation of predicates.; // %15 = CMPGTrr %6, %2; // ...; // %16 = NOT_p killed %15; // ...; // JMP_c killed %16, <%bb.1>, implicit dead %pc; //; // Into; // %15 = CMPGTrr %6, %2;; // ...; // JMP_cNot killed %15, <%bb.1>, implicit dead %pc;; //; // Note: The peephole pass makes the instrucstions like; // %170 = SXTW %166 or %16 = NOT_p killed %15; // redundant and relies on some form of dead removal instructions, like; // DCE or DIE to actually eliminate them.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp:316,Performance,optimiz,optimizes,316,"//===-- HexagonPeephole.cpp - Hexagon Peephole Optimiztions ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; // This peephole pass optimizes in the following cases.; // 1. Optimizes redundant sign extends for the following case; // Transform the following pattern; // %170 = SXTW %166; // ...; // %176 = COPY %170:isub_lo; //; // Into; // %176 = COPY %166; //; // 2. Optimizes redundant negation of predicates.; // %15 = CMPGTrr %6, %2; // ...; // %16 = NOT_p killed %15; // ...; // JMP_c killed %16, <%bb.1>, implicit dead %pc; //; // Into; // %15 = CMPGTrr %6, %2;; // ...; // JMP_cNot killed %15, <%bb.1>, implicit dead %pc;; //; // Note: The peephole pass makes the instrucstions like; // %170 = SXTW %166 or %16 = NOT_p killed %15; // redundant and relies on some form of dead removal instructions, like; // DCE or DIE to actually eliminate them.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp:357,Performance,Optimiz,Optimizes,357,"//===-- HexagonPeephole.cpp - Hexagon Peephole Optimiztions ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; // This peephole pass optimizes in the following cases.; // 1. Optimizes redundant sign extends for the following case; // Transform the following pattern; // %170 = SXTW %166; // ...; // %176 = COPY %170:isub_lo; //; // Into; // %176 = COPY %166; //; // 2. Optimizes redundant negation of predicates.; // %15 = CMPGTrr %6, %2; // ...; // %16 = NOT_p killed %15; // ...; // JMP_c killed %16, <%bb.1>, implicit dead %pc; //; // Into; // %15 = CMPGTrr %6, %2;; // ...; // JMP_cNot killed %15, <%bb.1>, implicit dead %pc;; //; // Note: The peephole pass makes the instrucstions like; // %170 = SXTW %166 or %16 = NOT_p killed %15; // redundant and relies on some form of dead removal instructions, like; // DCE or DIE to actually eliminate them.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp:552,Performance,Optimiz,Optimizes,552,"//===-- HexagonPeephole.cpp - Hexagon Peephole Optimiztions ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; // This peephole pass optimizes in the following cases.; // 1. Optimizes redundant sign extends for the following case; // Transform the following pattern; // %170 = SXTW %166; // ...; // %176 = COPY %170:isub_lo; //; // Into; // %176 = COPY %166; //; // 2. Optimizes redundant negation of predicates.; // %15 = CMPGTrr %6, %2; // ...; // %16 = NOT_p killed %15; // ...; // JMP_c killed %16, <%bb.1>, implicit dead %pc; //; // Into; // %15 = CMPGTrr %6, %2;; // ...; // JMP_cNot killed %15, <%bb.1>, implicit dead %pc;; //; // Note: The peephole pass makes the instrucstions like; // %170 = SXTW %166 or %16 = NOT_p killed %15; // redundant and relies on some form of dead removal instructions, like; // DCE or DIE to actually eliminate them.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp:367,Safety,redund,redundant,367,"//===-- HexagonPeephole.cpp - Hexagon Peephole Optimiztions ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; // This peephole pass optimizes in the following cases.; // 1. Optimizes redundant sign extends for the following case; // Transform the following pattern; // %170 = SXTW %166; // ...; // %176 = COPY %170:isub_lo; //; // Into; // %176 = COPY %166; //; // 2. Optimizes redundant negation of predicates.; // %15 = CMPGTrr %6, %2; // ...; // %16 = NOT_p killed %15; // ...; // JMP_c killed %16, <%bb.1>, implicit dead %pc; //; // Into; // %15 = CMPGTrr %6, %2;; // ...; // JMP_cNot killed %15, <%bb.1>, implicit dead %pc;; //; // Note: The peephole pass makes the instrucstions like; // %170 = SXTW %166 or %16 = NOT_p killed %15; // redundant and relies on some form of dead removal instructions, like; // DCE or DIE to actually eliminate them.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp:562,Safety,redund,redundant,562,"//===-- HexagonPeephole.cpp - Hexagon Peephole Optimiztions ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; // This peephole pass optimizes in the following cases.; // 1. Optimizes redundant sign extends for the following case; // Transform the following pattern; // %170 = SXTW %166; // ...; // %176 = COPY %170:isub_lo; //; // Into; // %176 = COPY %166; //; // 2. Optimizes redundant negation of predicates.; // %15 = CMPGTrr %6, %2; // ...; // %16 = NOT_p killed %15; // ...; // JMP_c killed %16, <%bb.1>, implicit dead %pc; //; // Into; // %15 = CMPGTrr %6, %2;; // ...; // JMP_cNot killed %15, <%bb.1>, implicit dead %pc;; //; // Note: The peephole pass makes the instrucstions like; // %170 = SXTW %166 or %16 = NOT_p killed %15; // redundant and relies on some form of dead removal instructions, like; // DCE or DIE to actually eliminate them.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp:925,Safety,redund,redundant,925,"//===-- HexagonPeephole.cpp - Hexagon Peephole Optimiztions ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; // This peephole pass optimizes in the following cases.; // 1. Optimizes redundant sign extends for the following case; // Transform the following pattern; // %170 = SXTW %166; // ...; // %176 = COPY %170:isub_lo; //; // Into; // %176 = COPY %166; //; // 2. Optimizes redundant negation of predicates.; // %15 = CMPGTrr %6, %2; // ...; // %16 = NOT_p killed %15; // ...; // JMP_c killed %16, <%bb.1>, implicit dead %pc; //; // Into; // %15 = CMPGTrr %6, %2;; // ...; // JMP_cNot killed %15, <%bb.1>, implicit dead %pc;; //; // Note: The peephole pass makes the instrucstions like; // %170 = SXTW %166 or %16 = NOT_p killed %15; // redundant and relies on some form of dead removal instructions, like; // DCE or DIE to actually eliminate them.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp:17,Modifiability,extend,extends,17,// Look for sign extends:; // %170 = SXTW %166,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp:245,Performance,load,loads,245,"// The actual base register (BP) is typically shared between many; // instructions where frame indices are being replaced. In scalar; // instructions the offset range is large, and the need for an extra; // add instruction is infrequent. Vector loads/stores, however, have; // a much smaller offset range: [-8, 7), or #s4. In those cases it; // makes sense to ""standardize"" the immediate in the ""addi"" instruction; // so that multiple loads/stores could be based on it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp:435,Performance,load,loads,435,"// The actual base register (BP) is typically shared between many; // instructions where frame indices are being replaced. In scalar; // instructions the offset range is large, and the need for an extra; // add instruction is infrequent. Vector loads/stores, however, have; // a much smaller offset range: [-8, 7), or #s4. In those cases it; // makes sense to ""standardize"" the immediate in the ""addi"" instruction; // so that multiple loads/stores could be based on it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp:3,Modifiability,Rewrite,Rewrite,3,"// Rewrite the offset as ""base + [-8, 7)"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp:103,Safety,avoid,avoid,103,"// Search backwards in the block for ""Reg = A2_addi BP, RealOffset"".; // This will give us a chance to avoid creating a new register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp:3,Modifiability,Extend,Extending,3,"// Extending a range of a virtual register can be dangerous,; // since the scavenger will need to find a physical register; // for it. Avoid extending the range past a function call,; // and avoid overlapping it with another virtual register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp:141,Modifiability,extend,extending,141,"// Extending a range of a virtual register can be dangerous,; // since the scavenger will need to find a physical register; // for it. Avoid extending the range past a function call,; // and avoid overlapping it with another virtual register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp:135,Safety,Avoid,Avoid,135,"// Extending a range of a virtual register can be dangerous,; // since the scavenger will need to find a physical register; // for it. Avoid extending the range past a function call,; // and avoid overlapping it with another virtual register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp:191,Safety,avoid,avoid,191,"// Extending a range of a virtual register can be dangerous,; // since the scavenger will need to find a physical register; // for it. Avoid extending the range past a function call,; // and avoid overlapping it with another virtual register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp:19,Modifiability,extend,extend,19,"// Coalescing will extend the live interval of the destination register.; // If the destination register is a vector pair, avoid introducing function; // calls into the interval, since it could result in a spilling of a pair; // instead of a single vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp:123,Safety,avoid,avoid,123,"// Coalescing will extend the live interval of the destination register.; // If the destination register is a vector pair, avoid introducing function; // calls into the interval, since it could result in a spilling of a pair; // instead of a single vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitConst32AndConst64.cpp:525,Availability,down,down,525,"//=== HexagonSplitConst32AndConst64.cpp - split CONST32/Const64 into HI/LO ===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // When the compiler is invoked with no small data, for instance, with the -G0; // command line option, then all CONST* opcodes should be broken down into; // appropriate LO and HI instructions. This splitting is done by this pass.; // The only reason this is not done in the DAG lowering itself is that there; // is no simple way of getting the register allocator to allot the same hard; // register to the result of LO and HI instructions. This pass is always; // scheduled after register allocation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitConst32AndConst64.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitConst32AndConst64.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitConst32AndConst64.cpp:846,Energy Efficiency,schedul,scheduled,846,"//=== HexagonSplitConst32AndConst64.cpp - split CONST32/Const64 into HI/LO ===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // When the compiler is invoked with no small data, for instance, with the -G0; // command line option, then all CONST* opcodes should be broken down into; // appropriate LO and HI instructions. This splitting is done by this pass.; // The only reason this is not done in the DAG lowering itself is that there; // is no simple way of getting the register allocator to allot the same hard; // register to the result of LO and HI instructions. This pass is always; // scheduled after register allocation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitConst32AndConst64.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitConst32AndConst64.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitConst32AndConst64.cpp:700,Usability,simpl,simple,700,"//=== HexagonSplitConst32AndConst64.cpp - split CONST32/Const64 into HI/LO ===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // When the compiler is invoked with no small data, for instance, with the -G0; // command line option, then all CONST* opcodes should be broken down into; // appropriate LO and HI instructions. This splitting is done by this pass.; // The only reason this is not done in the DAG lowering itself is that there; // is no simple way of getting the register allocator to allot the same hard; // register to the result of LO and HI instructions. This pass is always; // scheduled after register allocation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitConst32AndConst64.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitConst32AndConst64.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp:145,Safety,safe,safe,145,"// In some cases a register may exist, but never be defined or used.; // It should never appear anywhere, but mark it as ""fixed"", just to be; // safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp:3,Energy Efficiency,Reduce,Reduce,3,// Reduce the profitability of splitting induction registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp:227,Energy Efficiency,schedul,scheduler,227,"// If a register from this partition is used in a fixed instruction,; // and there is also a register in this partition that is used in; // a loop phi node, then decrease the splitting profit as this can; // confuse the modulo scheduler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp:8,Usability,simpl,simple,8,// Only simple jump-conditional (with or without negation).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp:75,Integrability,depend,depends,75,// Get the registers on which the loop controlling compare instruction; // depends.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp:383,Modifiability,extend,extender,383,"// The operand to A2_tfrsi can only have 32 significant bits. Immediate; // values in MachineOperand are stored as 64-bit integers, and so the; // value -1 may be represented either as 64-bit -1, or 4294967295. Both; // will have the 32 higher bits truncated in the end, but -1 will remain; // as -1, while the latter may appear to be a large unsigned value; // requiring a constant extender. The casting to int32_t will select the; // former representation. (The same reasoning applies to all 32-bit; // values.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp:839,Energy Efficiency,reduce,reduce,839,"//===- HexagonStoreWidening.cpp -------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Replace sequences of ""narrow"" stores to adjacent memory locations with; // a fewer ""wide"" stores that have the same effect.; // For example, replace:; // S4_storeirb_io %100, 0, 0 ; store-immediate-byte; // S4_storeirb_io %100, 1, 0 ; store-immediate-byte; // with; // S4_storeirh_io %100, 0, 0 ; store-immediate-halfword; // The above is the general idea. The actual cases handled by the code; // may be a bit more complex.; // The purpose of this pass is to reduce the number of outstanding stores,; // or as one could say, ""reduce store queue pressure"". Also, wide stores; // mean fewer stores, and since there are only two memory instructions allowed; // per packet, it also means fewer packets, and ultimately fewer cycles.; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp:906,Energy Efficiency,reduce,reduce,906,"//===- HexagonStoreWidening.cpp -------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Replace sequences of ""narrow"" stores to adjacent memory locations with; // a fewer ""wide"" stores that have the same effect.; // For example, replace:; // S4_storeirb_io %100, 0, 0 ; store-immediate-byte; // S4_storeirb_io %100, 1, 0 ; store-immediate-byte; // with; // S4_storeirh_io %100, 0, 0 ; store-immediate-halfword; // The above is the general idea. The actual cases handled by the code; // may be a bit more complex.; // The purpose of this pass is to reduce the number of outstanding stores,; // or as one could say, ""reduce store queue pressure"". Also, wide stores; // mean fewer stores, and since there are only two memory instructions allowed; // per packet, it also means fewer packets, and ultimately fewer cycles.; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp:919,Performance,queue,queue,919,"//===- HexagonStoreWidening.cpp -------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Replace sequences of ""narrow"" stores to adjacent memory locations with; // a fewer ""wide"" stores that have the same effect.; // For example, replace:; // S4_storeirb_io %100, 0, 0 ; store-immediate-byte; // S4_storeirb_io %100, 1, 0 ; store-immediate-byte; // with; // S4_storeirh_io %100, 0, 0 ; store-immediate-halfword; // The above is the general idea. The actual cases handled by the code; // may be a bit more complex.; // The purpose of this pass is to reduce the number of outstanding stores,; // or as one could say, ""reduce store queue pressure"". Also, wide stores; // mean fewer stores, and since there are only two memory instructions allowed; // per packet, it also means fewer packets, and ultimately fewer cycles.; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp:39,Security,access,accesses,39,// Check if the machine instruction MI accesses any storage aliased with; // any store in the group Stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp:85,Security,access,access,85,"// Check if store instructions S1 and S2 are adjacent. More precisely,; // S2 has to access memory immediately following that accessed by S1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp:126,Security,access,accessed,126,"// Check if store instructions S1 and S2 are adjacent. More precisely,; // S2 has to access memory immediately following that accessed by S1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp:53,Energy Efficiency,power,power,53,// The initial value of SizeAccum should always be a power of 2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp:219,Testability,Test,Test,219,"// The offset of a store will put restrictions on how wide the store can be.; // Offsets in stores of size 2^n bytes need to have the n lowest bits be 0.; // If the first store already exhausts the offset limits, quit. Test this; // by checking if the next wider size would exceed the limit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp:121,Energy Efficiency,power,power,121,// Pow2Num will be the largest number of elements in OG such that the sum; // of sizes of stores 0...Pow2Num-1 will be a power of 2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp:233,Energy Efficiency,power,power,233,"// Be greedy: keep accumulating stores as long as they are to adjacent; // memory locations, and as long as the total number of bytes stored; // does not exceed the limit (MaxSize).; // Keep track of when the total size covered is a power of 2, since; // this is a size a single store can cover.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp:186,Availability,recover,recover,186,"// InsertAt points at the first instruction that will be removed. We need; // to move it out of the way, so it remains valid after removing all the; // old stores, and so we are able to recover it back to the proper insertion; // position.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp:186,Safety,recover,recover,186,"// InsertAt points at the first instruction that will be removed. We need; // to move it out of the way, so it remains valid after removing all the; // old stores, and so we are able to recover it back to the proper insertion; // position.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp:342,Performance,perform,performed,342,"// Process a single basic block: create the store groups, and replace them; // with the widened stores, if possible. Processing of each basic block; // is independent from processing of any other basic block. This transfor-; // mation could be stopped after having processed any basic block without; // any ill effects (other than not having performed widening in the unpro-; // cessed blocks). Also, the basic blocks can be processed in any order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:139,Modifiability,variab,variables,139,"// Turn on QFloat if the HVX version is v68+.; // The function ParseSubtargetFeatures will set feature bits and initialize; // subtarget's variables all in one, so there isn't a good way to preprocess; // the feature string, other than by tinkering with it directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:50,Energy Efficiency,schedul,scheduling,50,"// Tiny core has a single thread, so back-to-back scheduling is enabled by; // default.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:3,Safety,Avoid,Avoid,3,// Avoid types like <2 x i32*>.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:105,Usability,simpl,simple,105,"// The given type may be something like <17 x i32>, which is not MVT,; // but can be represented as (non-simple) EVT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:24,Energy Efficiency,power,power-of-,24,"// Round up EVT to have power-of-2 elements, and keep checking if it; // qualifies for HVX, dividing it in half after each step.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:3,Deployability,Update,Update,3,// Update the latency of chain edges between v60 vector load or store; // instructions to be 1. These instruction cannot be scheduled in the; // same packet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:124,Energy Efficiency,schedul,scheduled,124,// Update the latency of chain edges between v60 vector load or store; // instructions to be 1. These instruction cannot be scheduled in the; // same packet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:14,Performance,latency,latency,14,// Update the latency of chain edges between v60 vector load or store; // instructions to be 1. These instruction cannot be scheduled in the; // same packet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:56,Performance,load,load,56,// Update the latency of chain edges between v60 vector load or store; // instructions to be 1. These instruction cannot be scheduled in the; // same packet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:14,Integrability,depend,dependence,14,// Change the dependence in the opposite direction too.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:76,Energy Efficiency,schedul,scheduling,76,"// Check if a call and subsequent A2_tfrpi instructions should maintain; // scheduling affinity. We are looking for the TFRI to be consumed in; // the next instruction. This should help reduce the instances of; // double register pairs being allocated and scheduled before a call; // when not used until after the call. This situation is exacerbated; // by the fact that we allocate the pair from the callee saves list,; // leading to excess spills and restores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:186,Energy Efficiency,reduce,reduce,186,"// Check if a call and subsequent A2_tfrpi instructions should maintain; // scheduling affinity. We are looking for the TFRI to be consumed in; // the next instruction. This should help reduce the instances of; // double register pairs being allocated and scheduled before a call; // when not used until after the call. This situation is exacerbated; // by the fact that we allocate the pair from the callee saves list,; // leading to excess spills and restores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:242,Energy Efficiency,allocate,allocated,242,"// Check if a call and subsequent A2_tfrpi instructions should maintain; // scheduling affinity. We are looking for the TFRI to be consumed in; // the next instruction. This should help reduce the instances of; // double register pairs being allocated and scheduled before a call; // when not used until after the call. This situation is exacerbated; // by the fact that we allocate the pair from the callee saves list,; // leading to excess spills and restores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:256,Energy Efficiency,schedul,scheduled,256,"// Check if a call and subsequent A2_tfrpi instructions should maintain; // scheduling affinity. We are looking for the TFRI to be consumed in; // the next instruction. This should help reduce the instances of; // double register pairs being allocated and scheduled before a call; // when not used until after the call. This situation is exacerbated; // by the fact that we allocate the pair from the callee saves list,; // leading to excess spills and restores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:374,Energy Efficiency,allocate,allocate,374,"// Check if a call and subsequent A2_tfrpi instructions should maintain; // scheduling affinity. We are looking for the TFRI to be consumed in; // the next instruction. This should help reduce the instances of; // double register pairs being allocated and scheduled before a call; // when not used until after the call. This situation is exacerbated; // by the fact that we allocate the pair from the callee saves list,; // leading to excess spills and restores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:59,Energy Efficiency,schedul,scheduled,59,// Currently we only catch the situation when compare gets scheduled; // before preceding call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:11,Availability,redundant,redundant,11,"// Prevent redundant register copies due to reads and writes of physical; // registers. The original motivation for this was the code generated; // between two calls, which are caused both the return value and the; // argument for the next call being in %r0.; // Example:; // 1: <call1>; // 2: %vreg = COPY %r0; // 3: <use of %vreg>; // 4: %r0 = ...; // 5: <call2>; // The scheduler would often swap 3 and 4, so an additional register is; // needed. This code inserts a Barrier dependence between 3 & 4 to prevent; // this.; // The code below checks for all the physical registers, not just R0/D0/V0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:373,Energy Efficiency,schedul,scheduler,373,"// Prevent redundant register copies due to reads and writes of physical; // registers. The original motivation for this was the code generated; // between two calls, which are caused both the return value and the; // argument for the next call being in %r0.; // Example:; // 1: <call1>; // 2: %vreg = COPY %r0; // 3: <use of %vreg>; // 4: %r0 = ...; // 5: <call2>; // The scheduler would often swap 3 and 4, so an additional register is; // needed. This code inserts a Barrier dependence between 3 & 4 to prevent; // this.; // The code below checks for all the physical registers, not just R0/D0/V0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:478,Integrability,depend,dependence,478,"// Prevent redundant register copies due to reads and writes of physical; // registers. The original motivation for this was the code generated; // between two calls, which are caused both the return value and the; // argument for the next call being in %r0.; // Example:; // 1: <call1>; // 2: %vreg = COPY %r0; // 3: <use of %vreg>; // 4: %r0 = ...; // 5: <call2>; // The scheduler would often swap 3 and 4, so an additional register is; // needed. This code inserts a Barrier dependence between 3 & 4 to prevent; // this.; // The code below checks for all the physical registers, not just R0/D0/V0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:11,Safety,redund,redundant,11,"// Prevent redundant register copies due to reads and writes of physical; // registers. The original motivation for this was the code generated; // between two calls, which are caused both the return value and the; // argument for the next call being in %r0.; // Example:; // 1: <call1>; // 2: %vreg = COPY %r0; // 3: <use of %vreg>; // 4: %r0 = ...; // 5: <call2>; // The scheduler would often swap 3 and 4, so an additional register is; // needed. This code inserts a Barrier dependence between 3 & 4 to prevent; // this.; // The code below checks for all the physical registers, not just R0/D0/V0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:131,Integrability,depend,dependency,131,"// Create artificial edges between loads that could likely cause a bank; // conflict. Since such loads would normally not have any dependency; // between them, we cannot rely on existing edges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:35,Performance,load,loads,35,"// Create artificial edges between loads that could likely cause a bank; // conflict. Since such loads would normally not have any dependency; // between them, we cannot rely on existing edges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:97,Performance,load,loads,97,"// Create artificial edges between loads that could likely cause a bank; // conflict. Since such loads would normally not have any dependency; // between them, we cannot rely on existing edges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:44,Performance,cache,cache,44,"// Is the access size is longer than the L1 cache line, skip the check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:10,Security,access,access,10,"// Is the access size is longer than the L1 cache line, skip the check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:45,Safety,avoid,avoid,45,// Scan only up to 32 instructions ahead (to avoid n^2 complexity).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:71,Performance,latency,latency,71,"// Bits 3 and 4 are the same, add an artificial edge and set extra; // latency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:72,Energy Efficiency,schedul,scheduling,72,"/// Enable use of alias analysis during code generation (during MI; /// scheduling, DAGCombine, etc.).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:60,Energy Efficiency,schedul,schedule,60,/// Perform target specific adjustments to the latency of a schedule; /// dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:74,Integrability,depend,dependency,74,/// Perform target specific adjustments to the latency of a schedule; /// dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:4,Performance,Perform,Perform,4,/// Perform target specific adjustments to the latency of a schedule; /// dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:47,Performance,latency,latency,47,/// Perform target specific adjustments to the latency of a schedule; /// dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:45,Performance,latency,latency,45,// Instructions with .new operands have zero latency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:11,Performance,latency,latency,11,// Set the latency for a copy to zero since we hope that is will get; // removed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:93,Performance,latency,latency,93,"// If it's a REG_SEQUENCE/COPY, use its destination instruction to determine; // the correct latency.; // If there are multiple uses of the def of COPY/REG_SEQUENCE, set the latency; // only if the latencies on all the uses are equal, otherwise set it to; // default.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:174,Performance,latency,latency,174,"// If it's a REG_SEQUENCE/COPY, use its destination instruction to determine; // the correct latency.; // If there are multiple uses of the def of COPY/REG_SEQUENCE, set the latency; // only if the latencies on all the uses are equal, otherwise set it to; // default.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:29,Performance,Latency,Latency,29,"// For multiple uses, if the Latency is different across uses, reset; // DLatency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:10,Energy Efficiency,schedul,schedule,10,// Try to schedule uses near definitions to generate .cur.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:7,Energy Efficiency,schedul,scheduling,7,// BSB scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:62,Performance,latency,latency,62,"// For some instructions (ex: COPY), we might end up with < 0 latency; // as they don't have any Itinerary class associated with them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:3,Deployability,Update,Update,3,// Update the latency of opposite edge too.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:14,Performance,latency,latency,14,// Update the latency of opposite edge too.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:15,Performance,latency,latency,15,/// Change the latency between the two SUnits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:3,Deployability,Update,Update,3,// Update the latency of opposite edge too.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:14,Performance,latency,latency,14,// Update the latency of opposite edge too.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:28,Performance,latency,latency,28,"/// If the SUnit has a zero latency edge, return the other SUnit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:57,Energy Efficiency,schedul,schedule,57,"// Return true if these are the best two instructions to schedule; // together with a zero latency. Only one dependence should have a zero; // latency. If there are multiple choices, choose the best, and change; // the others, if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:109,Integrability,depend,dependence,109,"// Return true if these are the best two instructions to schedule; // together with a zero latency. Only one dependence should have a zero; // latency. If there are multiple choices, choose the best, and change; // the others, if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:91,Performance,latency,latency,91,"// Return true if these are the best two instructions to schedule; // together with a zero latency. Only one dependence should have a zero; // latency. If there are multiple choices, choose the best, and change; // the others, if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:143,Performance,latency,latency,143,"// Return true if these are the best two instructions to schedule; // together with a zero latency. Only one dependence should have a zero; // latency. If there are multiple choices, choose the best, and change; // the others, if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:40,Integrability,depend,dependent,40,"// The architecture doesn't allow three dependent instructions in the same; // packet. So, if the destination has a zero latency successor, then it's; // not a candidate for a zero latency predecessor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:121,Performance,latency,latency,121,"// The architecture doesn't allow three dependent instructions in the same; // packet. So, if the destination has a zero latency successor, then it's; // not a candidate for a zero latency predecessor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:181,Performance,latency,latency,181,"// The architecture doesn't allow three dependent instructions in the same; // packet. So, if the destination has a zero latency successor, then it's; // not a candidate for a zero latency predecessor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:39,Integrability,depend,dependence,39,"// The caller frequently adds the same dependence twice. If so, then; // return true for this case too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:79,Integrability,depend,dependence,79,"// Reassign the latency for the previous bests, which requires setting; // the dependence edge in both directions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:16,Performance,latency,latency,16,"// Reassign the latency for the previous bests, which requires setting; // the dependence edge in both directions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:75,Integrability,depend,dependence,75,// Attempt to find another opprotunity for zero latency in a different; // dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:48,Performance,latency,latency,48,// Attempt to find another opprotunity for zero latency in a different; // dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:81,Integrability,depend,dependence,81,// Check if the previous best destination instruction has a new zero; // latency dependence opportunity.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:73,Performance,latency,latency,73,// Check if the previous best destination instruction has a new zero; // latency dependence opportunity.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:72,Integrability,depend,dependence,72,// Check if previous best source instruction has a new zero latency; // dependence opportunity.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:60,Performance,latency,latency,60,// Check if previous best source instruction has a new zero latency; // dependence opportunity.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h:49,Energy Efficiency,schedul,scheduling,49,/// True if the target should use Back-Skip-Back scheduling. This is the; /// default for V60.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h:41,Energy Efficiency,schedul,scheduler,41,// Always use the TargetLowering default scheduler.; // FIXME: This will use the vliw scheduler which is probably just hurting; // compiler time and will be removed eventually anyway.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h:86,Energy Efficiency,schedul,scheduler,86,// Always use the TargetLowering default scheduler.; // FIXME: This will use the vliw scheduler which is probably just hurting; // compiler time and will be removed eventually anyway.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h:111,Energy Efficiency,schedul,scheduling,111,// For use with PostRAScheduling: get the anti-dependence breaking that should; // be performed before post-RA scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h:47,Integrability,depend,dependence,47,// For use with PostRAScheduling: get the anti-dependence breaking that should; // be performed before post-RA scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h:86,Performance,perform,performed,86,// For use with PostRAScheduling: get the anti-dependence breaking that should; // be performed before post-RA scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h:39,Energy Efficiency,schedul,scheduler,39,/// True if the subtarget should run a scheduler after register; /// allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h:72,Energy Efficiency,schedul,scheduling,72,"/// Enable use of alias analysis during code generation (during MI; /// scheduling, DAGCombine, etc.).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h:60,Energy Efficiency,schedul,schedule,60,/// Perform target specific adjustments to the latency of a schedule; /// dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h:74,Integrability,depend,dependency,74,/// Perform target specific adjustments to the latency of a schedule; /// dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h:4,Performance,Perform,Perform,4,/// Perform target specific adjustments to the latency of a schedule; /// dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h:47,Performance,latency,latency,47,/// Perform target specific adjustments to the latency of a schedule; /// dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h:50,Performance,latency,latency,50,// Helper function responsible for increasing the latency only.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp:82,Safety,unsafe,unsafe-fp-math,82,"// Append the preexisting target features last, so that +mattr overrides; // the ""unsafe-fp-math"" function attribute.; // Creating a separate target feature is not strictly necessary, it only; // exists to make ""unsafe-fp-math"" force creating a new subtarget.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp:212,Safety,unsafe,unsafe-fp-math,212,"// Append the preexisting target features last, so that +mattr overrides; // the ""unsafe-fp-math"" function attribute.; // Creating a separate target feature is not strictly necessary, it only; // exists to make ""unsafe-fp-math"" force creating a new subtarget.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp:86,Integrability,depend,depend,86,// This needs to be done before we create a new subtarget since any; // creation will depend on the TM and the code generation flags on the; // function that reside in TargetOptions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp:32,Deployability,Configurat,Configuration,32,/// Hexagon Code Generator Pass Configuration Options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp:32,Modifiability,Config,Configuration,32,/// Hexagon Code Generator Pass Configuration Options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp:10,Testability,log,logical,10,// Create logical operations on predicate registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp:19,Security,expose,expose,19,// Rotate loops to expose bit-simplification opportunities.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp:30,Usability,simpl,simplification,30,// Rotate loops to expose bit-simplification opportunities.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp:7,Usability,simpl,simplification,7,// Bit simplification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp:95,Deployability,release,release,95,"// TraceGVPlacement controls messages for all builds. For builds with assertions; // (debug or release), messages are also controlled by the usual debug flags; // (e.g. -debug and -debug-only=globallayout)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp:29,Integrability,message,messages,29,"// TraceGVPlacement controls messages for all builds. For builds with assertions; // (debug or release), messages are also controlled by the usual debug flags; // (e.g. -debug and -debug-only=globallayout)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp:105,Integrability,message,messages,105,"// TraceGVPlacement controls messages for all builds. For builds with assertions; // (debug or release), messages are also controlled by the usual debug flags; // (e.g. -debug and -debug-only=globallayout)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp:70,Testability,assert,assertions,70,"// TraceGVPlacement controls messages for all builds. For builds with assertions; // (debug or release), messages are also controlled by the usual debug flags; // (e.g. -debug and -debug-only=globallayout)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp:126,Modifiability,variab,variables,126,"// Returns true if the section name is such that the symbol will be put; // in a small data section.; // For instance, global variables with section attributes such as "".sdata""; // "".sdata.*"", "".sbss"", and "".sbss.*"" will go into small data.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp:15,Modifiability,variab,variables,15,"// Only global variables, not functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp:215,Safety,safe,safe,215,"// If the type is a struct with no body provided, treat is conservatively.; // There cannot be actual definitions of object of such a type in this CU; // (only references), so assuming that they are not in sdata is safe. If; // these objects end up in the sdata, the references will still be valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp:22,Availability,down,down,22,"/// Descends any type down to ""elementary"" components,; /// discovering the smallest addressable one.; /// If zero is returned, declaration will not be modified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp:31,Security,access,access,31,// Assign the smallest element access size to the highest; // value which assembler can handle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp:50,Security,access,accessible,50,"// If -mno-sort-sda is not set, find out smallest accessible entity in; // declaration and add it to the section name string.; // Note. It does not track the actual usage of the value, only its de-; // claration. Also, compiler adds explicit pad fields to some struct; // declarations - they are currently counted towards smallest addres-; // sable entity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp:3,Security,validat,validate,3,// validate each instance of user to be a live function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp:15,Performance,load,loads,15,// Cost of HVX loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp:47,Performance,load,loads,47,// Cost of constructing HVX vector from scalar loads,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp:3,Performance,Load,Loads,3,// Loads of less than 32 bits will need extra inserts to compose a vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp:19,Performance,throughput,throughput,19,// TODO: Allow non-throughput costs that aren't binary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp:42,Availability,mask,masked-mem-intrin,42,"// This function is called from scalarize-masked-mem-intrin, which runs; // in pre-isel. Use ST directly instead of calling isHVXVectorType.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp:42,Availability,mask,masked-mem-intrin,42,"// This function is called from scalarize-masked-mem-intrin, which runs; // in pre-isel. Use ST directly instead of calling isHVXVectorType.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp:94,Performance,load,load,94,// Only extensions from an integer type shorter than 32-bit to i32; // can be folded into the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp:59,Performance,load,load,59,"// Technically, this code could allow multiple uses of the load, and; // check if all the uses are the same extension operation, but this; // should be sufficient for most cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.h:6,Performance,cache,cache,6,// L1 cache prefetch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:487,Performance,optimiz,optimizations,487,"//===-- HexagonVectorCombine.cpp ------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // HexagonVectorCombine is a utility class implementing a variety of functions; // that assist in vector-based optimizations.; //; // AlignVectors: replace unaligned vector loads and stores with aligned ones.; // HvxIdioms: recognize various opportunities to generate HVX intrinsic code.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:549,Performance,load,loads,549,"//===-- HexagonVectorCombine.cpp ------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // HexagonVectorCombine is a utility class implementing a variety of functions; // that assist in vector-based optimizations.; //; // AlignVectors: replace unaligned vector loads and stores with aligned ones.; // HvxIdioms: recognize various opportunities to generate HVX intrinsic code.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:34,Testability,assert,assertions,34,// This function is only used for assertions at the moment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:47,Performance,load,loads,47,"// This code tries to replace unaligned vector loads/stores with aligned; // ones.; // Consider unaligned load:; // %v = original_load %some_addr, align <bad>; // %user = %v; // It will generate; // = load ..., align <good>; // = load ..., align <good>; // = valign; // etc.; // %synthesize = combine/shuffle the loaded data so that it looks; // exactly like what ""original_load"" has loaded.; // %user = %synthesize; // Similarly for stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:106,Performance,load,load,106,"// This code tries to replace unaligned vector loads/stores with aligned; // ones.; // Consider unaligned load:; // %v = original_load %some_addr, align <bad>; // %user = %v; // It will generate; // = load ..., align <good>; // = load ..., align <good>; // = valign; // etc.; // %synthesize = combine/shuffle the loaded data so that it looks; // exactly like what ""original_load"" has loaded.; // %user = %synthesize; // Similarly for stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:201,Performance,load,load,201,"// This code tries to replace unaligned vector loads/stores with aligned; // ones.; // Consider unaligned load:; // %v = original_load %some_addr, align <bad>; // %user = %v; // It will generate; // = load ..., align <good>; // = load ..., align <good>; // = valign; // etc.; // %synthesize = combine/shuffle the loaded data so that it looks; // exactly like what ""original_load"" has loaded.; // %user = %synthesize; // Similarly for stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:230,Performance,load,load,230,"// This code tries to replace unaligned vector loads/stores with aligned; // ones.; // Consider unaligned load:; // %v = original_load %some_addr, align <bad>; // %user = %v; // It will generate; // = load ..., align <good>; // = load ..., align <good>; // = valign; // etc.; // %synthesize = combine/shuffle the loaded data so that it looks; // exactly like what ""original_load"" has loaded.; // %user = %synthesize; // Similarly for stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:313,Performance,load,loaded,313,"// This code tries to replace unaligned vector loads/stores with aligned; // ones.; // Consider unaligned load:; // %v = original_load %some_addr, align <bad>; // %user = %v; // It will generate; // = load ..., align <good>; // = load ..., align <good>; // = valign; // etc.; // %synthesize = combine/shuffle the loaded data so that it looks; // exactly like what ""original_load"" has loaded.; // %user = %synthesize; // Similarly for stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:384,Performance,load,loaded,384,"// This code tries to replace unaligned vector loads/stores with aligned; // ones.; // Consider unaligned load:; // %v = original_load %some_addr, align <bad>; // %user = %v; // It will generate; // = load ..., align <good>; // = load ..., align <good>; // = valign; // etc.; // %synthesize = combine/shuffle the loaded data so that it looks; // exactly like what ""original_load"" has loaded.; // %user = %synthesize; // Similarly for stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:11,Integrability,depend,dependencies,11,// List of dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:13,Performance,load,load,13,// Is this a load group?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:109,Performance,load,loaded,109,"// A representation of ""interesting"" bytes within a given span of memory.; // These bytes are those that are loaded or stored, and they don't have; // to cover the entire span of memory.; //; // The representation works by picking a contiguous sequence of bytes; // from somewhere within a llvm::Value, and placing it at a given offset; // within the span.; //; // The sequence of bytes from llvm:Value is represented by Segment.; // Block is Segment, plus where it goes in the span.; //; // An important feature of ByteSpan is being able to make a ""section"",; // i.e. creating another ByteSpan corresponding to a range of offsets; // relative to the source span.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:34,Testability,assert,assertions,34,// This function is only used for assertions at the moment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:71,Availability,error,error,71,"// VS2017 and some versions of VS2019 have trouble compiling this:; // error C2976: 'std::map': too few template arguments; // VS 2019 16.x is known to work, except for 16.4/16.5 (MSC_VER 1924/1925)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:71,Performance,load,loads,71,"// namespace; // --- Begin AlignVectors; // For brevity, only consider loads. We identify a group of loads where we; // know the relative differences between their addresses, so we know how they; // are laid out in memory (relative to one another). These loads can overlap,; // can be shorter or longer than the desired vector length.; // Ultimately we want to generate a sequence of aligned loads that will load; // every byte that the original loads loaded, and have the program use these; // loaded values instead of the original loads.; // We consider the contiguous memory area spanned by all these loads.; //; // Let's say that a single aligned vector load can load 16 bytes at a time.; // If the program wanted to use a byte at offset 13 from the beginning of the; // original span, it will be a byte at offset 13+x in the aligned data for; // some x>=0. This may happen to be in the first aligned load, or in the load; // following it. Since we generally don't know what the that alignment value; // is at compile time, we proactively do valigns on the aligned loads, so that; // byte that was at offset 13 is still at offset 13 after the valigns.; //; // This will be the starting point for making the rest of the program use the; // data loaded by the new loads.; // For each original load, and its users:; // %v = load ...; // ... = %v; // ... = %v; // we create; // %new_v = extract/combine/shuffle data from loaded/valigned vectors so; // it contains the same value as %v did before; // then replace all users of %v with %new_v.; // ... = %new_v; // ... = %new_v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:101,Performance,load,loads,101,"// namespace; // --- Begin AlignVectors; // For brevity, only consider loads. We identify a group of loads where we; // know the relative differences between their addresses, so we know how they; // are laid out in memory (relative to one another). These loads can overlap,; // can be shorter or longer than the desired vector length.; // Ultimately we want to generate a sequence of aligned loads that will load; // every byte that the original loads loaded, and have the program use these; // loaded values instead of the original loads.; // We consider the contiguous memory area spanned by all these loads.; //; // Let's say that a single aligned vector load can load 16 bytes at a time.; // If the program wanted to use a byte at offset 13 from the beginning of the; // original span, it will be a byte at offset 13+x in the aligned data for; // some x>=0. This may happen to be in the first aligned load, or in the load; // following it. Since we generally don't know what the that alignment value; // is at compile time, we proactively do valigns on the aligned loads, so that; // byte that was at offset 13 is still at offset 13 after the valigns.; //; // This will be the starting point for making the rest of the program use the; // data loaded by the new loads.; // For each original load, and its users:; // %v = load ...; // ... = %v; // ... = %v; // we create; // %new_v = extract/combine/shuffle data from loaded/valigned vectors so; // it contains the same value as %v did before; // then replace all users of %v with %new_v.; // ... = %new_v; // ... = %new_v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:255,Performance,load,loads,255,"// namespace; // --- Begin AlignVectors; // For brevity, only consider loads. We identify a group of loads where we; // know the relative differences between their addresses, so we know how they; // are laid out in memory (relative to one another). These loads can overlap,; // can be shorter or longer than the desired vector length.; // Ultimately we want to generate a sequence of aligned loads that will load; // every byte that the original loads loaded, and have the program use these; // loaded values instead of the original loads.; // We consider the contiguous memory area spanned by all these loads.; //; // Let's say that a single aligned vector load can load 16 bytes at a time.; // If the program wanted to use a byte at offset 13 from the beginning of the; // original span, it will be a byte at offset 13+x in the aligned data for; // some x>=0. This may happen to be in the first aligned load, or in the load; // following it. Since we generally don't know what the that alignment value; // is at compile time, we proactively do valigns on the aligned loads, so that; // byte that was at offset 13 is still at offset 13 after the valigns.; //; // This will be the starting point for making the rest of the program use the; // data loaded by the new loads.; // For each original load, and its users:; // %v = load ...; // ... = %v; // ... = %v; // we create; // %new_v = extract/combine/shuffle data from loaded/valigned vectors so; // it contains the same value as %v did before; // then replace all users of %v with %new_v.; // ... = %new_v; // ... = %new_v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:392,Performance,load,loads,392,"// namespace; // --- Begin AlignVectors; // For brevity, only consider loads. We identify a group of loads where we; // know the relative differences between their addresses, so we know how they; // are laid out in memory (relative to one another). These loads can overlap,; // can be shorter or longer than the desired vector length.; // Ultimately we want to generate a sequence of aligned loads that will load; // every byte that the original loads loaded, and have the program use these; // loaded values instead of the original loads.; // We consider the contiguous memory area spanned by all these loads.; //; // Let's say that a single aligned vector load can load 16 bytes at a time.; // If the program wanted to use a byte at offset 13 from the beginning of the; // original span, it will be a byte at offset 13+x in the aligned data for; // some x>=0. This may happen to be in the first aligned load, or in the load; // following it. Since we generally don't know what the that alignment value; // is at compile time, we proactively do valigns on the aligned loads, so that; // byte that was at offset 13 is still at offset 13 after the valigns.; //; // This will be the starting point for making the rest of the program use the; // data loaded by the new loads.; // For each original load, and its users:; // %v = load ...; // ... = %v; // ... = %v; // we create; // %new_v = extract/combine/shuffle data from loaded/valigned vectors so; // it contains the same value as %v did before; // then replace all users of %v with %new_v.; // ... = %new_v; // ... = %new_v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:408,Performance,load,load,408,"// namespace; // --- Begin AlignVectors; // For brevity, only consider loads. We identify a group of loads where we; // know the relative differences between their addresses, so we know how they; // are laid out in memory (relative to one another). These loads can overlap,; // can be shorter or longer than the desired vector length.; // Ultimately we want to generate a sequence of aligned loads that will load; // every byte that the original loads loaded, and have the program use these; // loaded values instead of the original loads.; // We consider the contiguous memory area spanned by all these loads.; //; // Let's say that a single aligned vector load can load 16 bytes at a time.; // If the program wanted to use a byte at offset 13 from the beginning of the; // original span, it will be a byte at offset 13+x in the aligned data for; // some x>=0. This may happen to be in the first aligned load, or in the load; // following it. Since we generally don't know what the that alignment value; // is at compile time, we proactively do valigns on the aligned loads, so that; // byte that was at offset 13 is still at offset 13 after the valigns.; //; // This will be the starting point for making the rest of the program use the; // data loaded by the new loads.; // For each original load, and its users:; // %v = load ...; // ... = %v; // ... = %v; // we create; // %new_v = extract/combine/shuffle data from loaded/valigned vectors so; // it contains the same value as %v did before; // then replace all users of %v with %new_v.; // ... = %new_v; // ... = %new_v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:446,Performance,load,loads,446,"// namespace; // --- Begin AlignVectors; // For brevity, only consider loads. We identify a group of loads where we; // know the relative differences between their addresses, so we know how they; // are laid out in memory (relative to one another). These loads can overlap,; // can be shorter or longer than the desired vector length.; // Ultimately we want to generate a sequence of aligned loads that will load; // every byte that the original loads loaded, and have the program use these; // loaded values instead of the original loads.; // We consider the contiguous memory area spanned by all these loads.; //; // Let's say that a single aligned vector load can load 16 bytes at a time.; // If the program wanted to use a byte at offset 13 from the beginning of the; // original span, it will be a byte at offset 13+x in the aligned data for; // some x>=0. This may happen to be in the first aligned load, or in the load; // following it. Since we generally don't know what the that alignment value; // is at compile time, we proactively do valigns on the aligned loads, so that; // byte that was at offset 13 is still at offset 13 after the valigns.; //; // This will be the starting point for making the rest of the program use the; // data loaded by the new loads.; // For each original load, and its users:; // %v = load ...; // ... = %v; // ... = %v; // we create; // %new_v = extract/combine/shuffle data from loaded/valigned vectors so; // it contains the same value as %v did before; // then replace all users of %v with %new_v.; // ... = %new_v; // ... = %new_v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:452,Performance,load,loaded,452,"// namespace; // --- Begin AlignVectors; // For brevity, only consider loads. We identify a group of loads where we; // know the relative differences between their addresses, so we know how they; // are laid out in memory (relative to one another). These loads can overlap,; // can be shorter or longer than the desired vector length.; // Ultimately we want to generate a sequence of aligned loads that will load; // every byte that the original loads loaded, and have the program use these; // loaded values instead of the original loads.; // We consider the contiguous memory area spanned by all these loads.; //; // Let's say that a single aligned vector load can load 16 bytes at a time.; // If the program wanted to use a byte at offset 13 from the beginning of the; // original span, it will be a byte at offset 13+x in the aligned data for; // some x>=0. This may happen to be in the first aligned load, or in the load; // following it. Since we generally don't know what the that alignment value; // is at compile time, we proactively do valigns on the aligned loads, so that; // byte that was at offset 13 is still at offset 13 after the valigns.; //; // This will be the starting point for making the rest of the program use the; // data loaded by the new loads.; // For each original load, and its users:; // %v = load ...; // ... = %v; // ... = %v; // we create; // %new_v = extract/combine/shuffle data from loaded/valigned vectors so; // it contains the same value as %v did before; // then replace all users of %v with %new_v.; // ... = %new_v; // ... = %new_v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:495,Performance,load,loaded,495,"// namespace; // --- Begin AlignVectors; // For brevity, only consider loads. We identify a group of loads where we; // know the relative differences between their addresses, so we know how they; // are laid out in memory (relative to one another). These loads can overlap,; // can be shorter or longer than the desired vector length.; // Ultimately we want to generate a sequence of aligned loads that will load; // every byte that the original loads loaded, and have the program use these; // loaded values instead of the original loads.; // We consider the contiguous memory area spanned by all these loads.; //; // Let's say that a single aligned vector load can load 16 bytes at a time.; // If the program wanted to use a byte at offset 13 from the beginning of the; // original span, it will be a byte at offset 13+x in the aligned data for; // some x>=0. This may happen to be in the first aligned load, or in the load; // following it. Since we generally don't know what the that alignment value; // is at compile time, we proactively do valigns on the aligned loads, so that; // byte that was at offset 13 is still at offset 13 after the valigns.; //; // This will be the starting point for making the rest of the program use the; // data loaded by the new loads.; // For each original load, and its users:; // %v = load ...; // ... = %v; // ... = %v; // we create; // %new_v = extract/combine/shuffle data from loaded/valigned vectors so; // it contains the same value as %v did before; // then replace all users of %v with %new_v.; // ... = %new_v; // ... = %new_v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:533,Performance,load,loads,533,"// namespace; // --- Begin AlignVectors; // For brevity, only consider loads. We identify a group of loads where we; // know the relative differences between their addresses, so we know how they; // are laid out in memory (relative to one another). These loads can overlap,; // can be shorter or longer than the desired vector length.; // Ultimately we want to generate a sequence of aligned loads that will load; // every byte that the original loads loaded, and have the program use these; // loaded values instead of the original loads.; // We consider the contiguous memory area spanned by all these loads.; //; // Let's say that a single aligned vector load can load 16 bytes at a time.; // If the program wanted to use a byte at offset 13 from the beginning of the; // original span, it will be a byte at offset 13+x in the aligned data for; // some x>=0. This may happen to be in the first aligned load, or in the load; // following it. Since we generally don't know what the that alignment value; // is at compile time, we proactively do valigns on the aligned loads, so that; // byte that was at offset 13 is still at offset 13 after the valigns.; //; // This will be the starting point for making the rest of the program use the; // data loaded by the new loads.; // For each original load, and its users:; // %v = load ...; // ... = %v; // ... = %v; // we create; // %new_v = extract/combine/shuffle data from loaded/valigned vectors so; // it contains the same value as %v did before; // then replace all users of %v with %new_v.; // ... = %new_v; // ... = %new_v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:604,Performance,load,loads,604,"// namespace; // --- Begin AlignVectors; // For brevity, only consider loads. We identify a group of loads where we; // know the relative differences between their addresses, so we know how they; // are laid out in memory (relative to one another). These loads can overlap,; // can be shorter or longer than the desired vector length.; // Ultimately we want to generate a sequence of aligned loads that will load; // every byte that the original loads loaded, and have the program use these; // loaded values instead of the original loads.; // We consider the contiguous memory area spanned by all these loads.; //; // Let's say that a single aligned vector load can load 16 bytes at a time.; // If the program wanted to use a byte at offset 13 from the beginning of the; // original span, it will be a byte at offset 13+x in the aligned data for; // some x>=0. This may happen to be in the first aligned load, or in the load; // following it. Since we generally don't know what the that alignment value; // is at compile time, we proactively do valigns on the aligned loads, so that; // byte that was at offset 13 is still at offset 13 after the valigns.; //; // This will be the starting point for making the rest of the program use the; // data loaded by the new loads.; // For each original load, and its users:; // %v = load ...; // ... = %v; // ... = %v; // we create; // %new_v = extract/combine/shuffle data from loaded/valigned vectors so; // it contains the same value as %v did before; // then replace all users of %v with %new_v.; // ... = %new_v; // ... = %new_v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:658,Performance,load,load,658,"// namespace; // --- Begin AlignVectors; // For brevity, only consider loads. We identify a group of loads where we; // know the relative differences between their addresses, so we know how they; // are laid out in memory (relative to one another). These loads can overlap,; // can be shorter or longer than the desired vector length.; // Ultimately we want to generate a sequence of aligned loads that will load; // every byte that the original loads loaded, and have the program use these; // loaded values instead of the original loads.; // We consider the contiguous memory area spanned by all these loads.; //; // Let's say that a single aligned vector load can load 16 bytes at a time.; // If the program wanted to use a byte at offset 13 from the beginning of the; // original span, it will be a byte at offset 13+x in the aligned data for; // some x>=0. This may happen to be in the first aligned load, or in the load; // following it. Since we generally don't know what the that alignment value; // is at compile time, we proactively do valigns on the aligned loads, so that; // byte that was at offset 13 is still at offset 13 after the valigns.; //; // This will be the starting point for making the rest of the program use the; // data loaded by the new loads.; // For each original load, and its users:; // %v = load ...; // ... = %v; // ... = %v; // we create; // %new_v = extract/combine/shuffle data from loaded/valigned vectors so; // it contains the same value as %v did before; // then replace all users of %v with %new_v.; // ... = %new_v; // ... = %new_v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:667,Performance,load,load,667,"// namespace; // --- Begin AlignVectors; // For brevity, only consider loads. We identify a group of loads where we; // know the relative differences between their addresses, so we know how they; // are laid out in memory (relative to one another). These loads can overlap,; // can be shorter or longer than the desired vector length.; // Ultimately we want to generate a sequence of aligned loads that will load; // every byte that the original loads loaded, and have the program use these; // loaded values instead of the original loads.; // We consider the contiguous memory area spanned by all these loads.; //; // Let's say that a single aligned vector load can load 16 bytes at a time.; // If the program wanted to use a byte at offset 13 from the beginning of the; // original span, it will be a byte at offset 13+x in the aligned data for; // some x>=0. This may happen to be in the first aligned load, or in the load; // following it. Since we generally don't know what the that alignment value; // is at compile time, we proactively do valigns on the aligned loads, so that; // byte that was at offset 13 is still at offset 13 after the valigns.; //; // This will be the starting point for making the rest of the program use the; // data loaded by the new loads.; // For each original load, and its users:; // %v = load ...; // ... = %v; // ... = %v; // we create; // %new_v = extract/combine/shuffle data from loaded/valigned vectors so; // it contains the same value as %v did before; // then replace all users of %v with %new_v.; // ... = %new_v; // ... = %new_v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:905,Performance,load,load,905,"// namespace; // --- Begin AlignVectors; // For brevity, only consider loads. We identify a group of loads where we; // know the relative differences between their addresses, so we know how they; // are laid out in memory (relative to one another). These loads can overlap,; // can be shorter or longer than the desired vector length.; // Ultimately we want to generate a sequence of aligned loads that will load; // every byte that the original loads loaded, and have the program use these; // loaded values instead of the original loads.; // We consider the contiguous memory area spanned by all these loads.; //; // Let's say that a single aligned vector load can load 16 bytes at a time.; // If the program wanted to use a byte at offset 13 from the beginning of the; // original span, it will be a byte at offset 13+x in the aligned data for; // some x>=0. This may happen to be in the first aligned load, or in the load; // following it. Since we generally don't know what the that alignment value; // is at compile time, we proactively do valigns on the aligned loads, so that; // byte that was at offset 13 is still at offset 13 after the valigns.; //; // This will be the starting point for making the rest of the program use the; // data loaded by the new loads.; // For each original load, and its users:; // %v = load ...; // ... = %v; // ... = %v; // we create; // %new_v = extract/combine/shuffle data from loaded/valigned vectors so; // it contains the same value as %v did before; // then replace all users of %v with %new_v.; // ... = %new_v; // ... = %new_v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:921,Performance,load,load,921,"// namespace; // --- Begin AlignVectors; // For brevity, only consider loads. We identify a group of loads where we; // know the relative differences between their addresses, so we know how they; // are laid out in memory (relative to one another). These loads can overlap,; // can be shorter or longer than the desired vector length.; // Ultimately we want to generate a sequence of aligned loads that will load; // every byte that the original loads loaded, and have the program use these; // loaded values instead of the original loads.; // We consider the contiguous memory area spanned by all these loads.; //; // Let's say that a single aligned vector load can load 16 bytes at a time.; // If the program wanted to use a byte at offset 13 from the beginning of the; // original span, it will be a byte at offset 13+x in the aligned data for; // some x>=0. This may happen to be in the first aligned load, or in the load; // following it. Since we generally don't know what the that alignment value; // is at compile time, we proactively do valigns on the aligned loads, so that; // byte that was at offset 13 is still at offset 13 after the valigns.; //; // This will be the starting point for making the rest of the program use the; // data loaded by the new loads.; // For each original load, and its users:; // %v = load ...; // ... = %v; // ... = %v; // we create; // %new_v = extract/combine/shuffle data from loaded/valigned vectors so; // it contains the same value as %v did before; // then replace all users of %v with %new_v.; // ... = %new_v; // ... = %new_v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:1069,Performance,load,loads,1069,"// namespace; // --- Begin AlignVectors; // For brevity, only consider loads. We identify a group of loads where we; // know the relative differences between their addresses, so we know how they; // are laid out in memory (relative to one another). These loads can overlap,; // can be shorter or longer than the desired vector length.; // Ultimately we want to generate a sequence of aligned loads that will load; // every byte that the original loads loaded, and have the program use these; // loaded values instead of the original loads.; // We consider the contiguous memory area spanned by all these loads.; //; // Let's say that a single aligned vector load can load 16 bytes at a time.; // If the program wanted to use a byte at offset 13 from the beginning of the; // original span, it will be a byte at offset 13+x in the aligned data for; // some x>=0. This may happen to be in the first aligned load, or in the load; // following it. Since we generally don't know what the that alignment value; // is at compile time, we proactively do valigns on the aligned loads, so that; // byte that was at offset 13 is still at offset 13 after the valigns.; //; // This will be the starting point for making the rest of the program use the; // data loaded by the new loads.; // For each original load, and its users:; // %v = load ...; // ... = %v; // ... = %v; // we create; // %new_v = extract/combine/shuffle data from loaded/valigned vectors so; // it contains the same value as %v did before; // then replace all users of %v with %new_v.; // ... = %new_v; // ... = %new_v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:1248,Performance,load,loaded,1248,"// namespace; // --- Begin AlignVectors; // For brevity, only consider loads. We identify a group of loads where we; // know the relative differences between their addresses, so we know how they; // are laid out in memory (relative to one another). These loads can overlap,; // can be shorter or longer than the desired vector length.; // Ultimately we want to generate a sequence of aligned loads that will load; // every byte that the original loads loaded, and have the program use these; // loaded values instead of the original loads.; // We consider the contiguous memory area spanned by all these loads.; //; // Let's say that a single aligned vector load can load 16 bytes at a time.; // If the program wanted to use a byte at offset 13 from the beginning of the; // original span, it will be a byte at offset 13+x in the aligned data for; // some x>=0. This may happen to be in the first aligned load, or in the load; // following it. Since we generally don't know what the that alignment value; // is at compile time, we proactively do valigns on the aligned loads, so that; // byte that was at offset 13 is still at offset 13 after the valigns.; //; // This will be the starting point for making the rest of the program use the; // data loaded by the new loads.; // For each original load, and its users:; // %v = load ...; // ... = %v; // ... = %v; // we create; // %new_v = extract/combine/shuffle data from loaded/valigned vectors so; // it contains the same value as %v did before; // then replace all users of %v with %new_v.; // ... = %new_v; // ... = %new_v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:1266,Performance,load,loads,1266,"// namespace; // --- Begin AlignVectors; // For brevity, only consider loads. We identify a group of loads where we; // know the relative differences between their addresses, so we know how they; // are laid out in memory (relative to one another). These loads can overlap,; // can be shorter or longer than the desired vector length.; // Ultimately we want to generate a sequence of aligned loads that will load; // every byte that the original loads loaded, and have the program use these; // loaded values instead of the original loads.; // We consider the contiguous memory area spanned by all these loads.; //; // Let's say that a single aligned vector load can load 16 bytes at a time.; // If the program wanted to use a byte at offset 13 from the beginning of the; // original span, it will be a byte at offset 13+x in the aligned data for; // some x>=0. This may happen to be in the first aligned load, or in the load; // following it. Since we generally don't know what the that alignment value; // is at compile time, we proactively do valigns on the aligned loads, so that; // byte that was at offset 13 is still at offset 13 after the valigns.; //; // This will be the starting point for making the rest of the program use the; // data loaded by the new loads.; // For each original load, and its users:; // %v = load ...; // ... = %v; // ... = %v; // we create; // %new_v = extract/combine/shuffle data from loaded/valigned vectors so; // it contains the same value as %v did before; // then replace all users of %v with %new_v.; // ... = %new_v; // ... = %new_v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:1295,Performance,load,load,1295,"// namespace; // --- Begin AlignVectors; // For brevity, only consider loads. We identify a group of loads where we; // know the relative differences between their addresses, so we know how they; // are laid out in memory (relative to one another). These loads can overlap,; // can be shorter or longer than the desired vector length.; // Ultimately we want to generate a sequence of aligned loads that will load; // every byte that the original loads loaded, and have the program use these; // loaded values instead of the original loads.; // We consider the contiguous memory area spanned by all these loads.; //; // Let's say that a single aligned vector load can load 16 bytes at a time.; // If the program wanted to use a byte at offset 13 from the beginning of the; // original span, it will be a byte at offset 13+x in the aligned data for; // some x>=0. This may happen to be in the first aligned load, or in the load; // following it. Since we generally don't know what the that alignment value; // is at compile time, we proactively do valigns on the aligned loads, so that; // byte that was at offset 13 is still at offset 13 after the valigns.; //; // This will be the starting point for making the rest of the program use the; // data loaded by the new loads.; // For each original load, and its users:; // %v = load ...; // ... = %v; // ... = %v; // we create; // %new_v = extract/combine/shuffle data from loaded/valigned vectors so; // it contains the same value as %v did before; // then replace all users of %v with %new_v.; // ... = %new_v; // ... = %new_v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:1325,Performance,load,load,1325,"// namespace; // --- Begin AlignVectors; // For brevity, only consider loads. We identify a group of loads where we; // know the relative differences between their addresses, so we know how they; // are laid out in memory (relative to one another). These loads can overlap,; // can be shorter or longer than the desired vector length.; // Ultimately we want to generate a sequence of aligned loads that will load; // every byte that the original loads loaded, and have the program use these; // loaded values instead of the original loads.; // We consider the contiguous memory area spanned by all these loads.; //; // Let's say that a single aligned vector load can load 16 bytes at a time.; // If the program wanted to use a byte at offset 13 from the beginning of the; // original span, it will be a byte at offset 13+x in the aligned data for; // some x>=0. This may happen to be in the first aligned load, or in the load; // following it. Since we generally don't know what the that alignment value; // is at compile time, we proactively do valigns on the aligned loads, so that; // byte that was at offset 13 is still at offset 13 after the valigns.; //; // This will be the starting point for making the rest of the program use the; // data loaded by the new loads.; // For each original load, and its users:; // %v = load ...; // ... = %v; // ... = %v; // we create; // %new_v = extract/combine/shuffle data from loaded/valigned vectors so; // it contains the same value as %v did before; // then replace all users of %v with %new_v.; // ... = %new_v; // ... = %new_v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:1421,Performance,load,loaded,1421,"// namespace; // --- Begin AlignVectors; // For brevity, only consider loads. We identify a group of loads where we; // know the relative differences between their addresses, so we know how they; // are laid out in memory (relative to one another). These loads can overlap,; // can be shorter or longer than the desired vector length.; // Ultimately we want to generate a sequence of aligned loads that will load; // every byte that the original loads loaded, and have the program use these; // loaded values instead of the original loads.; // We consider the contiguous memory area spanned by all these loads.; //; // Let's say that a single aligned vector load can load 16 bytes at a time.; // If the program wanted to use a byte at offset 13 from the beginning of the; // original span, it will be a byte at offset 13+x in the aligned data for; // some x>=0. This may happen to be in the first aligned load, or in the load; // following it. Since we generally don't know what the that alignment value; // is at compile time, we proactively do valigns on the aligned loads, so that; // byte that was at offset 13 is still at offset 13 after the valigns.; //; // This will be the starting point for making the rest of the program use the; // data loaded by the new loads.; // For each original load, and its users:; // %v = load ...; // ... = %v; // ... = %v; // we create; // %new_v = extract/combine/shuffle data from loaded/valigned vectors so; // it contains the same value as %v did before; // then replace all users of %v with %new_v.; // ... = %new_v; // ... = %new_v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:51,Performance,load,load,51,// Predicate is nullptr if not creating predicated load,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:27,Availability,Mask,Mask,27,// Here both Predicate and Mask are true or unknown.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:3,Availability,Mask,Mask,3,// Mask is unknown,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:22,Availability,Mask,Mask,22,// Both Predicate and Mask are unknown.; // Emulate masked store with predicated-load + mux + predicated-store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:52,Availability,mask,masked,52,// Both Predicate and Mask are unknown.; // Emulate masked store with predicated-load + mux + predicated-store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:81,Performance,load,load,81,// Both Predicate and Mask are unknown.; // Emulate masked store with predicated-load + mux + predicated-store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:8,Performance,load,load,8,"// Form load groups.; // To avoid complications with moving code across basic blocks, only form; // groups that are contained within a single basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:28,Safety,avoid,avoid,28,"// Form load groups.; // To avoid complications with moving code across basic blocks, only form; // groups that are contained within a single basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:30,Performance,load,load,30,// Leading instruction in the load group.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:34,Performance,load,load,34,// Check if it's safe to move the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:17,Safety,safe,safe,17,// Check if it's safe to move the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:33,Integrability,depend,dependencies,33,// And if it's safe to clone the dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:15,Safety,safe,safe,15,// And if it's safe to clone the dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:67,Performance,load,loads,67,// Erase HVX groups on targets < HvxV62 (due to lack of predicated loads).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:29,Safety,avoid,avoid,29,"// Form store groups.; // To avoid complications with moving code across basic blocks, only form; // groups that are contained within a single basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:54,Availability,down,downward,54,"// For stores with return values we'd have to collect downward depenencies.; // There are no such stores that we handle at the moment, so omit that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:49,Safety,safe,safe,49,// For stores we need to be careful whether it's safe to move them.; // Stores that are otherwise safe to move together may not appear safe; // to move over one another (i.e. isSafeToMoveBefore may return false).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:98,Safety,safe,safe,98,// For stores we need to be careful whether it's safe to move them.; // Stores that are otherwise safe to move together may not appear safe; // to move over one another (i.e. isSafeToMoveBefore may return false).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:135,Safety,safe,safe,135,// For stores we need to be careful whether it's safe to move them.; // Stores that are otherwise safe to move together may not appear safe; // to move over one another (i.e. isSafeToMoveBefore may return false).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:67,Performance,load,loads,67,// Erase HVX groups on targets < HvxV62 (due to lack of predicated loads).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:150,Energy Efficiency,efficient,efficient,150,// Erase groups where every store is a full HVX vector. The reason is that; // aligning predicated stores generates complex code that may be less; // efficient than a sequence of unaligned vector stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:27,Integrability,depend,dependencies,27,"// Move all the loads (and dependencies) to where the first load is.; // Clone all deps to before Where, keeping order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:16,Performance,load,loads,16,"// Move all the loads (and dependencies) to where the first load is.; // Clone all deps to before Where, keeping order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:60,Performance,load,load,60,"// Move all the loads (and dependencies) to where the first load is.; // Clone all deps to before Where, keeping order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:11,Performance,load,load,11,"// Created load does not have to be ""Instruction"" (e.g. ""undef"").",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:38,Performance,load,loads,38,"// We could create all of the aligned loads, and generate the valigns; // at the location of the first load, but for large load groups, this; // could create highly suboptimal code (there have been groups of 140+; // loads in real code).; // Instead, place the loads/valigns as close to the users as possible.; // In any case we need to have a mapping from the blocks of VSpan (the; // span covered by the pre-existing loads) to ASpan (the span covered; // by the aligned loads). There is a small problem, though: ASpan needs; // to have pointers to the loads/valigns, but we don't have these loads; // because we don't know where to put them yet. We find out by creating; // a section of ASpan that corresponds to values (blocks) from VSpan,; // and checking where the new load should be placed. We need to attach; // this location information to each block in ASpan somehow, so we put; // distincts values for Seg.Val in each ASpan.Blocks[i], and use a map; // to store the location for each Seg.Val.; // The distinct values happen to be Blocks[i].Seg.Val = &Blocks[i],; // which helps with printing ByteSpans without crashing when printing; // Segments with these temporary identifiers in place of Val.; // Populate the blocks first, to avoid reallocations of the vector; // interfering with generating the placeholder addresses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:103,Performance,load,load,103,"// We could create all of the aligned loads, and generate the valigns; // at the location of the first load, but for large load groups, this; // could create highly suboptimal code (there have been groups of 140+; // loads in real code).; // Instead, place the loads/valigns as close to the users as possible.; // In any case we need to have a mapping from the blocks of VSpan (the; // span covered by the pre-existing loads) to ASpan (the span covered; // by the aligned loads). There is a small problem, though: ASpan needs; // to have pointers to the loads/valigns, but we don't have these loads; // because we don't know where to put them yet. We find out by creating; // a section of ASpan that corresponds to values (blocks) from VSpan,; // and checking where the new load should be placed. We need to attach; // this location information to each block in ASpan somehow, so we put; // distincts values for Seg.Val in each ASpan.Blocks[i], and use a map; // to store the location for each Seg.Val.; // The distinct values happen to be Blocks[i].Seg.Val = &Blocks[i],; // which helps with printing ByteSpans without crashing when printing; // Segments with these temporary identifiers in place of Val.; // Populate the blocks first, to avoid reallocations of the vector; // interfering with generating the placeholder addresses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:123,Performance,load,load,123,"// We could create all of the aligned loads, and generate the valigns; // at the location of the first load, but for large load groups, this; // could create highly suboptimal code (there have been groups of 140+; // loads in real code).; // Instead, place the loads/valigns as close to the users as possible.; // In any case we need to have a mapping from the blocks of VSpan (the; // span covered by the pre-existing loads) to ASpan (the span covered; // by the aligned loads). There is a small problem, though: ASpan needs; // to have pointers to the loads/valigns, but we don't have these loads; // because we don't know where to put them yet. We find out by creating; // a section of ASpan that corresponds to values (blocks) from VSpan,; // and checking where the new load should be placed. We need to attach; // this location information to each block in ASpan somehow, so we put; // distincts values for Seg.Val in each ASpan.Blocks[i], and use a map; // to store the location for each Seg.Val.; // The distinct values happen to be Blocks[i].Seg.Val = &Blocks[i],; // which helps with printing ByteSpans without crashing when printing; // Segments with these temporary identifiers in place of Val.; // Populate the blocks first, to avoid reallocations of the vector; // interfering with generating the placeholder addresses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:217,Performance,load,loads,217,"// We could create all of the aligned loads, and generate the valigns; // at the location of the first load, but for large load groups, this; // could create highly suboptimal code (there have been groups of 140+; // loads in real code).; // Instead, place the loads/valigns as close to the users as possible.; // In any case we need to have a mapping from the blocks of VSpan (the; // span covered by the pre-existing loads) to ASpan (the span covered; // by the aligned loads). There is a small problem, though: ASpan needs; // to have pointers to the loads/valigns, but we don't have these loads; // because we don't know where to put them yet. We find out by creating; // a section of ASpan that corresponds to values (blocks) from VSpan,; // and checking where the new load should be placed. We need to attach; // this location information to each block in ASpan somehow, so we put; // distincts values for Seg.Val in each ASpan.Blocks[i], and use a map; // to store the location for each Seg.Val.; // The distinct values happen to be Blocks[i].Seg.Val = &Blocks[i],; // which helps with printing ByteSpans without crashing when printing; // Segments with these temporary identifiers in place of Val.; // Populate the blocks first, to avoid reallocations of the vector; // interfering with generating the placeholder addresses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:261,Performance,load,loads,261,"// We could create all of the aligned loads, and generate the valigns; // at the location of the first load, but for large load groups, this; // could create highly suboptimal code (there have been groups of 140+; // loads in real code).; // Instead, place the loads/valigns as close to the users as possible.; // In any case we need to have a mapping from the blocks of VSpan (the; // span covered by the pre-existing loads) to ASpan (the span covered; // by the aligned loads). There is a small problem, though: ASpan needs; // to have pointers to the loads/valigns, but we don't have these loads; // because we don't know where to put them yet. We find out by creating; // a section of ASpan that corresponds to values (blocks) from VSpan,; // and checking where the new load should be placed. We need to attach; // this location information to each block in ASpan somehow, so we put; // distincts values for Seg.Val in each ASpan.Blocks[i], and use a map; // to store the location for each Seg.Val.; // The distinct values happen to be Blocks[i].Seg.Val = &Blocks[i],; // which helps with printing ByteSpans without crashing when printing; // Segments with these temporary identifiers in place of Val.; // Populate the blocks first, to avoid reallocations of the vector; // interfering with generating the placeholder addresses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:419,Performance,load,loads,419,"// We could create all of the aligned loads, and generate the valigns; // at the location of the first load, but for large load groups, this; // could create highly suboptimal code (there have been groups of 140+; // loads in real code).; // Instead, place the loads/valigns as close to the users as possible.; // In any case we need to have a mapping from the blocks of VSpan (the; // span covered by the pre-existing loads) to ASpan (the span covered; // by the aligned loads). There is a small problem, though: ASpan needs; // to have pointers to the loads/valigns, but we don't have these loads; // because we don't know where to put them yet. We find out by creating; // a section of ASpan that corresponds to values (blocks) from VSpan,; // and checking where the new load should be placed. We need to attach; // this location information to each block in ASpan somehow, so we put; // distincts values for Seg.Val in each ASpan.Blocks[i], and use a map; // to store the location for each Seg.Val.; // The distinct values happen to be Blocks[i].Seg.Val = &Blocks[i],; // which helps with printing ByteSpans without crashing when printing; // Segments with these temporary identifiers in place of Val.; // Populate the blocks first, to avoid reallocations of the vector; // interfering with generating the placeholder addresses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:472,Performance,load,loads,472,"// We could create all of the aligned loads, and generate the valigns; // at the location of the first load, but for large load groups, this; // could create highly suboptimal code (there have been groups of 140+; // loads in real code).; // Instead, place the loads/valigns as close to the users as possible.; // In any case we need to have a mapping from the blocks of VSpan (the; // span covered by the pre-existing loads) to ASpan (the span covered; // by the aligned loads). There is a small problem, though: ASpan needs; // to have pointers to the loads/valigns, but we don't have these loads; // because we don't know where to put them yet. We find out by creating; // a section of ASpan that corresponds to values (blocks) from VSpan,; // and checking where the new load should be placed. We need to attach; // this location information to each block in ASpan somehow, so we put; // distincts values for Seg.Val in each ASpan.Blocks[i], and use a map; // to store the location for each Seg.Val.; // The distinct values happen to be Blocks[i].Seg.Val = &Blocks[i],; // which helps with printing ByteSpans without crashing when printing; // Segments with these temporary identifiers in place of Val.; // Populate the blocks first, to avoid reallocations of the vector; // interfering with generating the placeholder addresses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:554,Performance,load,loads,554,"// We could create all of the aligned loads, and generate the valigns; // at the location of the first load, but for large load groups, this; // could create highly suboptimal code (there have been groups of 140+; // loads in real code).; // Instead, place the loads/valigns as close to the users as possible.; // In any case we need to have a mapping from the blocks of VSpan (the; // span covered by the pre-existing loads) to ASpan (the span covered; // by the aligned loads). There is a small problem, though: ASpan needs; // to have pointers to the loads/valigns, but we don't have these loads; // because we don't know where to put them yet. We find out by creating; // a section of ASpan that corresponds to values (blocks) from VSpan,; // and checking where the new load should be placed. We need to attach; // this location information to each block in ASpan somehow, so we put; // distincts values for Seg.Val in each ASpan.Blocks[i], and use a map; // to store the location for each Seg.Val.; // The distinct values happen to be Blocks[i].Seg.Val = &Blocks[i],; // which helps with printing ByteSpans without crashing when printing; // Segments with these temporary identifiers in place of Val.; // Populate the blocks first, to avoid reallocations of the vector; // interfering with generating the placeholder addresses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:593,Performance,load,loads,593,"// We could create all of the aligned loads, and generate the valigns; // at the location of the first load, but for large load groups, this; // could create highly suboptimal code (there have been groups of 140+; // loads in real code).; // Instead, place the loads/valigns as close to the users as possible.; // In any case we need to have a mapping from the blocks of VSpan (the; // span covered by the pre-existing loads) to ASpan (the span covered; // by the aligned loads). There is a small problem, though: ASpan needs; // to have pointers to the loads/valigns, but we don't have these loads; // because we don't know where to put them yet. We find out by creating; // a section of ASpan that corresponds to values (blocks) from VSpan,; // and checking where the new load should be placed. We need to attach; // this location information to each block in ASpan somehow, so we put; // distincts values for Seg.Val in each ASpan.Blocks[i], and use a map; // to store the location for each Seg.Val.; // The distinct values happen to be Blocks[i].Seg.Val = &Blocks[i],; // which helps with printing ByteSpans without crashing when printing; // Segments with these temporary identifiers in place of Val.; // Populate the blocks first, to avoid reallocations of the vector; // interfering with generating the placeholder addresses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:774,Performance,load,load,774,"// We could create all of the aligned loads, and generate the valigns; // at the location of the first load, but for large load groups, this; // could create highly suboptimal code (there have been groups of 140+; // loads in real code).; // Instead, place the loads/valigns as close to the users as possible.; // In any case we need to have a mapping from the blocks of VSpan (the; // span covered by the pre-existing loads) to ASpan (the span covered; // by the aligned loads). There is a small problem, though: ASpan needs; // to have pointers to the loads/valigns, but we don't have these loads; // because we don't know where to put them yet. We find out by creating; // a section of ASpan that corresponds to values (blocks) from VSpan,; // and checking where the new load should be placed. We need to attach; // this location information to each block in ASpan somehow, so we put; // distincts values for Seg.Val in each ASpan.Blocks[i], and use a map; // to store the location for each Seg.Val.; // The distinct values happen to be Blocks[i].Seg.Val = &Blocks[i],; // which helps with printing ByteSpans without crashing when printing; // Segments with these temporary identifiers in place of Val.; // Populate the blocks first, to avoid reallocations of the vector; // interfering with generating the placeholder addresses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:1240,Safety,avoid,avoid,1240,"// We could create all of the aligned loads, and generate the valigns; // at the location of the first load, but for large load groups, this; // could create highly suboptimal code (there have been groups of 140+; // loads in real code).; // Instead, place the loads/valigns as close to the users as possible.; // In any case we need to have a mapping from the blocks of VSpan (the; // span covered by the pre-existing loads) to ASpan (the span covered; // by the aligned loads). There is a small problem, though: ASpan needs; // to have pointers to the loads/valigns, but we don't have these loads; // because we don't know where to put them yet. We find out by creating; // a section of ASpan that corresponds to values (blocks) from VSpan,; // and checking where the new load should be placed. We need to attach; // this location information to each block in ASpan somehow, so we put; // distincts values for Seg.Val in each ASpan.Blocks[i], and use a map; // to store the location for each Seg.Val.; // The distinct values happen to be Blocks[i].Seg.Val = &Blocks[i],; // which helps with printing ByteSpans without crashing when printing; // Segments with these temporary identifiers in place of Val.; // Populate the blocks first, to avoid reallocations of the vector; // interfering with generating the placeholder addresses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:93,Performance,load,loads,93,"// Multiple values from VSpan can map to the same value in ASpan. Since we; // try to create loads lazily, we need to find the earliest use for each; // value from ASpan.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:173,Performance,load,loads,173,"// Make sure we only consider users in this block, but we need; // to remember if there were users outside the block too. This is; // because if no users are found, aligned loads will not be created.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:103,Performance,load,load,103,"// If vector shifting is potentially needed, accumulate metadata; // from source sections of twice the load width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:26,Integrability,depend,dependencies,26,// Move In and its upward dependencies to before To.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:22,Performance,load,loads,22,// Generate necessary loads at appropriate locations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:56,Performance,load,load,56,"// In ASpan, each block will be either a single aligned load, or a; // valign of a pair of loads. In the latter case, an aligned load j; // will belong to the current valign, and the one in the previous; // block (for j > 0).; // Place the load at a location which will dominate the valign, assuming; // the valign will be placed right before the earliest user.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:91,Performance,load,loads,91,"// In ASpan, each block will be either a single aligned load, or a; // valign of a pair of loads. In the latter case, an aligned load j; // will belong to the current valign, and the one in the previous; // block (for j > 0).; // Place the load at a location which will dominate the valign, assuming; // the valign will be placed right before the earliest user.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:129,Performance,load,load,129,"// In ASpan, each block will be either a single aligned load, or a; // valign of a pair of loads. In the latter case, an aligned load j; // will belong to the current valign, and the one in the previous; // block (for j > 0).; // Place the load at a location which will dominate the valign, assuming; // the valign will be placed right before the earliest user.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:240,Performance,load,load,240,"// In ASpan, each block will be either a single aligned load, or a; // valign of a pair of loads. In the latter case, an aligned load j; // will belong to the current valign, and the one in the previous; // block (for j > 0).; // Place the load at a location which will dominate the valign, assuming; // the valign will be placed right before the earliest user.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:32,Performance,load,load,32,"// We know it's safe to put the load at BasePos, but we'd prefer to put; // it at ""Where"". To see if the load is safe to be placed at Where, put; // it there first and then check if it's safe to move it to BasePos.; // If not, then the load needs to be placed at BasePos.; // We can't do this check proactively because we need the load to exist; // in order to check legality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:105,Performance,load,load,105,"// We know it's safe to put the load at BasePos, but we'd prefer to put; // it at ""Where"". To see if the load is safe to be placed at Where, put; // it there first and then check if it's safe to move it to BasePos.; // If not, then the load needs to be placed at BasePos.; // We can't do this check proactively because we need the load to exist; // in order to check legality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:236,Performance,load,load,236,"// We know it's safe to put the load at BasePos, but we'd prefer to put; // it at ""Where"". To see if the load is safe to be placed at Where, put; // it there first and then check if it's safe to move it to BasePos.; // If not, then the load needs to be placed at BasePos.; // We can't do this check proactively because we need the load to exist; // in order to check legality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:331,Performance,load,load,331,"// We know it's safe to put the load at BasePos, but we'd prefer to put; // it at ""Where"". To see if the load is safe to be placed at Where, put; // it there first and then check if it's safe to move it to BasePos.; // If not, then the load needs to be placed at BasePos.; // We can't do this check proactively because we need the load to exist; // in order to check legality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:16,Safety,safe,safe,16,"// We know it's safe to put the load at BasePos, but we'd prefer to put; // it at ""Where"". To see if the load is safe to be placed at Where, put; // it there first and then check if it's safe to move it to BasePos.; // If not, then the load needs to be placed at BasePos.; // We can't do this check proactively because we need the load to exist; // in order to check legality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:113,Safety,safe,safe,113,"// We know it's safe to put the load at BasePos, but we'd prefer to put; // it at ""Where"". To see if the load is safe to be placed at Where, put; // it there first and then check if it's safe to move it to BasePos.; // If not, then the load needs to be placed at BasePos.; // We can't do this check proactively because we need the load to exist; // in order to check legality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:187,Safety,safe,safe,187,"// We know it's safe to put the load at BasePos, but we'd prefer to put; // it at ""Where"". To see if the load is safe to be placed at Where, put; // it there first and then check if it's safe to move it to BasePos.; // If not, then the load needs to be placed at BasePos.; // We can't do this check proactively because we need the load to exist; // in order to check legality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:56,Integrability,depend,depends,56,"// We're generating a reduction, where each instruction depends on; // the previous one, so we need to order them according to the position; // of their inputs in the code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:101,Availability,avail,available,101,// The processing of the data loaded by the aligned loads; // needs to be inserted after the data is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:30,Performance,load,loaded,30,// The processing of the data loaded by the aligned loads; // needs to be inserted after the data is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:52,Performance,load,loads,52,// The processing of the data loaded by the aligned loads; // needs to be inserted after the data is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:139,Availability,mask,masks,139,"// Instead of casting everything to bytes for the vselect, cast to the; // original value type. This will avoid complications with casting masks.; // For example, in cases when the original mask applied to i32, it could; // be converted to a mask applicable to i8 via pred_typecast intrinsic,; // but if the mask is not exactly of HVX length, extra handling would be; // needed to make it work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:190,Availability,mask,mask,190,"// Instead of casting everything to bytes for the vselect, cast to the; // original value type. This will avoid complications with casting masks.; // For example, in cases when the original mask applied to i32, it could; // be converted to a mask applicable to i8 via pred_typecast intrinsic,; // but if the mask is not exactly of HVX length, extra handling would be; // needed to make it work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:242,Availability,mask,mask,242,"// Instead of casting everything to bytes for the vselect, cast to the; // original value type. This will avoid complications with casting masks.; // For example, in cases when the original mask applied to i32, it could; // be converted to a mask applicable to i8 via pred_typecast intrinsic,; // but if the mask is not exactly of HVX length, extra handling would be; // needed to make it work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:308,Availability,mask,mask,308,"// Instead of casting everything to bytes for the vselect, cast to the; // original value type. This will avoid complications with casting masks.; // For example, in cases when the original mask applied to i32, it could; // be converted to a mask applicable to i8 via pred_typecast intrinsic,; // but if the mask is not exactly of HVX length, extra handling would be; // needed to make it work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:106,Safety,avoid,avoid,106,"// Instead of casting everything to bytes for the vselect, cast to the; // original value type. This will avoid complications with casting masks.; // For example, in cases when the original mask applied to i32, it could; // be converted to a mask applicable to i8 via pred_typecast intrinsic,; // but if the mask is not exactly of HVX length, extra handling would be; // needed to make it work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:2,Performance,Scalab,Scalable,2,/*Scalable=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:27,Availability,mask,masked,27,"// TODO: Needs support for masked loads/stores of ""scalar"" vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:34,Performance,load,loads,34,"// TODO: Needs support for masked loads/stores of ""scalar"" vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:547,Availability,down,down-aligned,547,"// Conceptually, there is a vector of N bytes covering the addresses; // starting from the minimum offset (i.e. Base.Addr+Start). This vector; // represents a contiguous memory region that spans all accessed memory; // locations.; // The correspondence between loaded or stored values will be expressed; // in terms of this vector. For example, the 0th element of the vector; // from the Base address info will start at byte Start from the beginning; // of this conceptual vector.; //; // This vector will be loaded/stored starting at the nearest down-aligned; // address and the amount od the down-alignment will be AlignVal:; // valign(load_vector(align_down(Base+Start)), AlignVal)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:594,Availability,down,down-alignment,594,"// Conceptually, there is a vector of N bytes covering the addresses; // starting from the minimum offset (i.e. Base.Addr+Start). This vector; // represents a contiguous memory region that spans all accessed memory; // locations.; // The correspondence between loaded or stored values will be expressed; // in terms of this vector. For example, the 0th element of the vector; // from the Base address info will start at byte Start from the beginning; // of this conceptual vector.; //; // This vector will be loaded/stored starting at the nearest down-aligned; // address and the amount od the down-alignment will be AlignVal:; // valign(load_vector(align_down(Base+Start)), AlignVal)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:261,Performance,load,loaded,261,"// Conceptually, there is a vector of N bytes covering the addresses; // starting from the minimum offset (i.e. Base.Addr+Start). This vector; // represents a contiguous memory region that spans all accessed memory; // locations.; // The correspondence between loaded or stored values will be expressed; // in terms of this vector. For example, the 0th element of the vector; // from the Base address info will start at byte Start from the beginning; // of this conceptual vector.; //; // This vector will be loaded/stored starting at the nearest down-aligned; // address and the amount od the down-alignment will be AlignVal:; // valign(load_vector(align_down(Base+Start)), AlignVal)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:509,Performance,load,loaded,509,"// Conceptually, there is a vector of N bytes covering the addresses; // starting from the minimum offset (i.e. Base.Addr+Start). This vector; // represents a contiguous memory region that spans all accessed memory; // locations.; // The correspondence between loaded or stored values will be expressed; // in terms of this vector. For example, the 0th element of the vector; // from the Base address info will start at byte Start from the beginning; // of this conceptual vector.; //; // This vector will be loaded/stored starting at the nearest down-aligned; // address and the amount od the down-alignment will be AlignVal:; // valign(load_vector(align_down(Base+Start)), AlignVal)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:199,Security,access,accessed,199,"// Conceptually, there is a vector of N bytes covering the addresses; // starting from the minimum offset (i.e. Base.Addr+Start). This vector; // represents a contiguous memory region that spans all accessed memory; // locations.; // The correspondence between loaded or stored values will be expressed; // in terms of this vector. For example, the 0th element of the vector; // from the Base address info will start at byte Start from the beginning; // of this conceptual vector.; //; // This vector will be loaded/stored starting at the nearest down-aligned; // address and the amount od the down-alignment will be AlignVal:; // valign(load_vector(align_down(Base+Start)), AlignVal)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:54,Performance,load,load,54,"// Set the builder's insertion point right before the load group, or; // immediately after the store group. (Instructions in a store group are; // listed in reverse order.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:294,Usability,simpl,simple,294,// Shift the offset of the maximally aligned instruction (OffAtMax); // back by just enough multiples of the required alignment to cover the; // distance from Start to OffAtMax.; // Calculate the address adjustment amount based on the address with the; // maximum alignment. This is to allow a simple gep instruction instead; // of potential bitcasts to i8*.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:167,Availability,mask,mask,167,"// WithMinOffset is the lowest address in the group,; // WithMinOffset.Addr = Base+Start.; // Align instructions for both HVX (V6_valign) and scalar (S2_valignrb); // mask off unnecessary bits, so it's ok to just the original pointer as; // the alignment amount.; // Do an explicit down-alignment of the address to avoid creating an; // aligned instruction with an address that is not really aligned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:282,Availability,down,down-alignment,282,"// WithMinOffset is the lowest address in the group,; // WithMinOffset.Addr = Base+Start.; // Align instructions for both HVX (V6_valign) and scalar (S2_valignrb); // mask off unnecessary bits, so it's ok to just the original pointer as; // the alignment amount.; // Do an explicit down-alignment of the address to avoid creating an; // aligned instruction with an address that is not really aligned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:315,Safety,avoid,avoid,315,"// WithMinOffset is the lowest address in the group,; // WithMinOffset.Addr = Base+Start.; // Align instructions for both HVX (V6_valign) and scalar (S2_valignrb); // mask off unnecessary bits, so it's ok to just the original pointer as; // the alignment amount.; // Do an explicit down-alignment of the address to avoid creating an; // aligned instruction with an address that is not really aligned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:15,Performance,load,loads,15,"// The aligned loads/stores will use blocks that are either scalars,; // or HVX vectors. Let ""sector"" be the unified term for such a block.; // blend(scalar, vector) -> sector...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:102,Modifiability,extend,extended,102,"// The significant bits are calculated including the sign bit. This may; // add an extra bit for zero-extended values, e.g. (zext i32 to i64) may; // result in 33 significant bits. To avoid extra words, skip the extra; // sign bit, but keep information that the value is to be treated as; // unsigned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:184,Safety,avoid,avoid,184,"// The significant bits are calculated including the sign bit. This may; // add an extra bit for zero-extended values, e.g. (zext i32 to i64) may; // result in 33 significant bits. To avoid extra words, skip the extra; // sign bit, but keep information that the value is to be treated as; // unsigned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:26,Testability,test,test,26,// Number of bits used in test for unsignedness.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:33,Energy Efficiency,power,power-of-,33,"// If the top bit of the nearest power-of-2 is zero, this value is; // positive. It could be treated as either signed or unsigned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:33,Energy Efficiency,power,power,33,"// If the element width is not a power of 2, round it up; // to the next one. Do this for widths not exceeding 32.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:2,Performance,Scalab,Scalable,2,/*Scalable=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:2,Performance,Scalab,Scalable,2,/*Scalable=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:2,Performance,Scalab,Scalable,2,/*Scalable=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:99,Performance,perform,perform,99,"// Since there may have been some undefs appended to make shuffle operands; // have the same type, perform the last shuffle to only pick the original; // elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:3,Modifiability,Extend,Extend,3,// Extend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:3,Availability,Mask,Mask,3,"// Mask is a vector <N x i1>, where each element corresponds to an; // element of FromTy. Remap it so that each element will correspond; // to an element of ToTy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:3,Availability,Mask,Mask,3,// Mask <N x i1> -> sext to <N x FromTy> -> bitcast to <M x ToTy> ->; // -> trunc to <M x i1>.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:2,Performance,Scalab,Scalable,2,/*Scalable=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:2,Performance,Scalab,Scalable,2,/*Scalable=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:2,Performance,Scalab,Scalable,2,/*Scalable=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:39,Energy Efficiency,power,power-of-,39,"// If the list of values does not have power-of-2 elements, append copies; // of the sign bit to it, to make the size be 2^n.; // The reason for this is that the values will be joined in pairs, because; // otherwise the shuffles will result in convoluted code. With pairwise; // joins, the shuffles will hopefully be folded into a perfect shuffle.; // The output will need to be sign-extended to a type with element width; // being a power-of-2 anyways.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:434,Energy Efficiency,power,power-of-,434,"// If the list of values does not have power-of-2 elements, append copies; // of the sign bit to it, to make the size be 2^n.; // The reason for this is that the values will be joined in pairs, because; // otherwise the shuffles will result in convoluted code. With pairwise; // joins, the shuffles will hopefully be folded into a perfect shuffle.; // The output will need to be sign-extended to a type with element width; // being a power-of-2 anyways.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:384,Modifiability,extend,extended,384,"// If the list of values does not have power-of-2 elements, append copies; // of the sign bit to it, to make the size be 2^n.; // The reason for this is that the values will be joined in pairs, because; // otherwise the shuffles will result in convoluted code. With pairwise; // joins, the shuffles will hopefully be folded into a perfect shuffle.; // The output will need to be sign-extended to a type with element width; // being a power-of-2 anyways.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:59,Integrability,wrap,wrap-around,59,"// Having too many inputs is ok: drop the high bits (usual wrap-around).; // If there are too few, fill them with the sign bit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:17,Usability,simpl,simplify,17,"// First, try to simplify the subtraction directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.cpp:429,Availability,redundant,redundant,429,"//===- HexagonVectorLoopCarriedReuse.cpp ----------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass removes the computation of provably redundant expressions that have; // been computed earlier in a previous iteration. It relies on the use of PHIs; // to identify loop carried dependences. This is scalar replacement for vector; // types.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.cpp:570,Integrability,depend,dependences,570,"//===- HexagonVectorLoopCarriedReuse.cpp ----------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass removes the computation of provably redundant expressions that have; // been computed earlier in a previous iteration. It relies on the use of PHIs; // to identify loop carried dependences. This is scalar replacement for vector; // types.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.cpp:429,Safety,redund,redundant,429,"//===- HexagonVectorLoopCarriedReuse.cpp ----------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass removes the computation of provably redundant expressions that have; // been computed earlier in a previous iteration. It relies on the use of PHIs; // to identify loop carried dependences. This is scalar replacement for vector; // types.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.cpp:73,Performance,perform,performs,73,"// For each interesting use I of PN, find an Instruction BEUser that; // performs the same operation as I on BEInst and whose other operands,; // if any, can also be rematerialized in OtherBB. We stop when we find the; // first such Instruction BEUser. This is because once BEUser is; // rematerialized in OtherBB, we may find more such ""fixup"" opportunities; // in this block. So, we'll start over again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.cpp:116,Safety,safe,safe,116,"// We are in LCSSA form. So, a value defined inside the Loop is used only; // inside the loop. So, the following is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h:429,Availability,redundant,redundant,429,"//===- HexagonVectorLoopCarriedReuse.h ------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass removes the computation of provably redundant expressions that have; // been computed earlier in a previous iteration. It relies on the use of PHIs; // to identify loop carried dependences. This is scalar replacement for vector; // types.; //; //-----------------------------------------------------------------------------; // Motivation: Consider the case where we have the following loop structure.; //; // Loop:; // t0 = a[i];; // t1 = f(t0);; // t2 = g(t1);; // ...; // t3 = a[i+1];; // t4 = f(t3);; // t5 = g(t4);; // t6 = op(t2, t5); // cond_branch <Loop>; //; // This can be converted to; // t00 = a[0];; // t10 = f(t00);; // t20 = g(t10);; // Loop:; // t2 = t20;; // t3 = a[i+1];; // t4 = f(t3);; // t5 = g(t4);; // t6 = op(t2, t5); // t20 = t5; // cond_branch <Loop>; //; // SROA does a good job of reusing a[i+1] as a[i] in the next iteration.; // Such a loop comes to this pass in the following form.; //; // LoopPreheader:; // X0 = a[0];; // Loop:; // X2 = PHI<(X0, LoopPreheader), (X1, Loop)>; // t1 = f(X2) <-- I1; // t2 = g(t1); // ...; // X1 = a[i+1]; // t4 = f(X1) <-- I2; // t5 = g(t4); // t6 = op(t2, t5); // cond_branch <Loop>; //; // In this pass, we look for PHIs such as X2 whose incoming values come only; // from the Loop Preheader and over the backedge and additionaly, both these; // values are the results of the same operation in terms of opcode. We call such; // a PHI node a dependence chain or DepChain. In this case, the dependence of X2; // over X1 is carried over only one iteration and so the DepChain is only one; // PHI node long.; //; // Then, we traverse the uses of ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h:570,Integrability,depend,dependences,570,"//===- HexagonVectorLoopCarriedReuse.h ------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass removes the computation of provably redundant expressions that have; // been computed earlier in a previous iteration. It relies on the use of PHIs; // to identify loop carried dependences. This is scalar replacement for vector; // types.; //; //-----------------------------------------------------------------------------; // Motivation: Consider the case where we have the following loop structure.; //; // Loop:; // t0 = a[i];; // t1 = f(t0);; // t2 = g(t1);; // ...; // t3 = a[i+1];; // t4 = f(t3);; // t5 = g(t4);; // t6 = op(t2, t5); // cond_branch <Loop>; //; // This can be converted to; // t00 = a[0];; // t10 = f(t00);; // t20 = g(t10);; // Loop:; // t2 = t20;; // t3 = a[i+1];; // t4 = f(t3);; // t5 = g(t4);; // t6 = op(t2, t5); // t20 = t5; // cond_branch <Loop>; //; // SROA does a good job of reusing a[i+1] as a[i] in the next iteration.; // Such a loop comes to this pass in the following form.; //; // LoopPreheader:; // X0 = a[0];; // Loop:; // X2 = PHI<(X0, LoopPreheader), (X1, Loop)>; // t1 = f(X2) <-- I1; // t2 = g(t1); // ...; // X1 = a[i+1]; // t4 = f(X1) <-- I2; // t5 = g(t4); // t6 = op(t2, t5); // cond_branch <Loop>; //; // In this pass, we look for PHIs such as X2 whose incoming values come only; // from the Loop Preheader and over the backedge and additionaly, both these; // values are the results of the same operation in terms of opcode. We call such; // a PHI node a dependence chain or DepChain. In this case, the dependence of X2; // over X1 is carried over only one iteration and so the DepChain is only one; // PHI node long.; //; // Then, we traverse the uses of ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h:1800,Integrability,depend,dependence,1800," // Loop:; // t0 = a[i];; // t1 = f(t0);; // t2 = g(t1);; // ...; // t3 = a[i+1];; // t4 = f(t3);; // t5 = g(t4);; // t6 = op(t2, t5); // cond_branch <Loop>; //; // This can be converted to; // t00 = a[0];; // t10 = f(t00);; // t20 = g(t10);; // Loop:; // t2 = t20;; // t3 = a[i+1];; // t4 = f(t3);; // t5 = g(t4);; // t6 = op(t2, t5); // t20 = t5; // cond_branch <Loop>; //; // SROA does a good job of reusing a[i+1] as a[i] in the next iteration.; // Such a loop comes to this pass in the following form.; //; // LoopPreheader:; // X0 = a[0];; // Loop:; // X2 = PHI<(X0, LoopPreheader), (X1, Loop)>; // t1 = f(X2) <-- I1; // t2 = g(t1); // ...; // X1 = a[i+1]; // t4 = f(X1) <-- I2; // t5 = g(t4); // t6 = op(t2, t5); // cond_branch <Loop>; //; // In this pass, we look for PHIs such as X2 whose incoming values come only; // from the Loop Preheader and over the backedge and additionaly, both these; // values are the results of the same operation in terms of opcode. We call such; // a PHI node a dependence chain or DepChain. In this case, the dependence of X2; // over X1 is carried over only one iteration and so the DepChain is only one; // PHI node long.; //; // Then, we traverse the uses of the PHI (X2) and the uses of the value of the; // PHI coming over the backedge (X1). We stop at the first pair of such users; // I1 (of X2) and I2 (of X1) that meet the following conditions.; // 1. I1 and I2 are the same operation, but with different operands.; // 2. X2 and X1 are used at the same operand number in the two instructions.; // 3. All other operands Op1 of I1 and Op2 of I2 are also such that there is a; // a DepChain from Op1 to Op2 of the same length as that between X2 and X1.; //; // We then make the following transformation; // LoopPreheader:; // X0 = a[0];; // Y0 = f(X0);; // Loop:; // X2 = PHI<(X0, LoopPreheader), (X1, Loop)>; // Y2 = PHI<(Y0, LoopPreheader), (t4, Loop)>; // t1 = f(X2) <-- Will be removed by DCE.; // t2 = g(Y2); // ...; // X1 = a[i+1]; // t4 = f(X1); //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h:1848,Integrability,depend,dependence,1848,";; // t5 = g(t4);; // t6 = op(t2, t5); // cond_branch <Loop>; //; // This can be converted to; // t00 = a[0];; // t10 = f(t00);; // t20 = g(t10);; // Loop:; // t2 = t20;; // t3 = a[i+1];; // t4 = f(t3);; // t5 = g(t4);; // t6 = op(t2, t5); // t20 = t5; // cond_branch <Loop>; //; // SROA does a good job of reusing a[i+1] as a[i] in the next iteration.; // Such a loop comes to this pass in the following form.; //; // LoopPreheader:; // X0 = a[0];; // Loop:; // X2 = PHI<(X0, LoopPreheader), (X1, Loop)>; // t1 = f(X2) <-- I1; // t2 = g(t1); // ...; // X1 = a[i+1]; // t4 = f(X1) <-- I2; // t5 = g(t4); // t6 = op(t2, t5); // cond_branch <Loop>; //; // In this pass, we look for PHIs such as X2 whose incoming values come only; // from the Loop Preheader and over the backedge and additionaly, both these; // values are the results of the same operation in terms of opcode. We call such; // a PHI node a dependence chain or DepChain. In this case, the dependence of X2; // over X1 is carried over only one iteration and so the DepChain is only one; // PHI node long.; //; // Then, we traverse the uses of the PHI (X2) and the uses of the value of the; // PHI coming over the backedge (X1). We stop at the first pair of such users; // I1 (of X2) and I2 (of X1) that meet the following conditions.; // 1. I1 and I2 are the same operation, but with different operands.; // 2. X2 and X1 are used at the same operand number in the two instructions.; // 3. All other operands Op1 of I1 and Op2 of I2 are also such that there is a; // a DepChain from Op1 to Op2 of the same length as that between X2 and X1.; //; // We then make the following transformation; // LoopPreheader:; // X0 = a[0];; // Y0 = f(X0);; // Loop:; // X2 = PHI<(X0, LoopPreheader), (X1, Loop)>; // Y2 = PHI<(Y0, LoopPreheader), (t4, Loop)>; // t1 = f(X2) <-- Will be removed by DCE.; // t2 = g(Y2); // ...; // X1 = a[i+1]; // t4 = f(X1); // t5 = g(t4); // t6 = op(t2, t5); // cond_branch <Loop>; //; // We proceed until we cannot find an",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h:2969,Integrability,depend,dependences,2969,"de long.; //; // Then, we traverse the uses of the PHI (X2) and the uses of the value of the; // PHI coming over the backedge (X1). We stop at the first pair of such users; // I1 (of X2) and I2 (of X1) that meet the following conditions.; // 1. I1 and I2 are the same operation, but with different operands.; // 2. X2 and X1 are used at the same operand number in the two instructions.; // 3. All other operands Op1 of I1 and Op2 of I2 are also such that there is a; // a DepChain from Op1 to Op2 of the same length as that between X2 and X1.; //; // We then make the following transformation; // LoopPreheader:; // X0 = a[0];; // Y0 = f(X0);; // Loop:; // X2 = PHI<(X0, LoopPreheader), (X1, Loop)>; // Y2 = PHI<(Y0, LoopPreheader), (t4, Loop)>; // t1 = f(X2) <-- Will be removed by DCE.; // t2 = g(Y2); // ...; // X1 = a[i+1]; // t4 = f(X1); // t5 = g(t4); // t6 = op(t2, t5); // cond_branch <Loop>; //; // We proceed until we cannot find any more such instructions I1 and I2.; //; // --- DepChains & Loop carried dependences ---; // Consider a single basic block loop such as; //; // LoopPreheader:; // X0 = ...; // Y0 = ...; // Loop:; // X2 = PHI<(X0, LoopPreheader), (X1, Loop)>; // Y2 = PHI<(Y0, LoopPreheader), (X2, Loop)>; // ...; // X1 = ...; // ...; // cond_branch <Loop>; //; // Then there is a dependence between X2 and X1 that goes back one iteration,; // i.e. X1 is used as X2 in the very next iteration. We represent this as a; // DepChain from X2 to X1 (X2->X1).; // Similarly, there is a dependence between Y2 and X1 that goes back two; // iterations. X1 is used as Y2 two iterations after it is computed. This is; // represented by a DepChain as (Y2->X2->X1).; //; // A DepChain has the following properties.; // 1. Num of edges in DepChain = Number of Instructions in DepChain = Number of; // iterations of carried dependence + 1.; // 2. All instructions in the DepChain except the last are PHIs.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h:3259,Integrability,depend,dependence,3259,"de long.; //; // Then, we traverse the uses of the PHI (X2) and the uses of the value of the; // PHI coming over the backedge (X1). We stop at the first pair of such users; // I1 (of X2) and I2 (of X1) that meet the following conditions.; // 1. I1 and I2 are the same operation, but with different operands.; // 2. X2 and X1 are used at the same operand number in the two instructions.; // 3. All other operands Op1 of I1 and Op2 of I2 are also such that there is a; // a DepChain from Op1 to Op2 of the same length as that between X2 and X1.; //; // We then make the following transformation; // LoopPreheader:; // X0 = a[0];; // Y0 = f(X0);; // Loop:; // X2 = PHI<(X0, LoopPreheader), (X1, Loop)>; // Y2 = PHI<(Y0, LoopPreheader), (t4, Loop)>; // t1 = f(X2) <-- Will be removed by DCE.; // t2 = g(Y2); // ...; // X1 = a[i+1]; // t4 = f(X1); // t5 = g(t4); // t6 = op(t2, t5); // cond_branch <Loop>; //; // We proceed until we cannot find any more such instructions I1 and I2.; //; // --- DepChains & Loop carried dependences ---; // Consider a single basic block loop such as; //; // LoopPreheader:; // X0 = ...; // Y0 = ...; // Loop:; // X2 = PHI<(X0, LoopPreheader), (X1, Loop)>; // Y2 = PHI<(Y0, LoopPreheader), (X2, Loop)>; // ...; // X1 = ...; // ...; // cond_branch <Loop>; //; // Then there is a dependence between X2 and X1 that goes back one iteration,; // i.e. X1 is used as X2 in the very next iteration. We represent this as a; // DepChain from X2 to X1 (X2->X1).; // Similarly, there is a dependence between Y2 and X1 that goes back two; // iterations. X1 is used as Y2 two iterations after it is computed. This is; // represented by a DepChain as (Y2->X2->X1).; //; // A DepChain has the following properties.; // 1. Num of edges in DepChain = Number of Instructions in DepChain = Number of; // iterations of carried dependence + 1.; // 2. All instructions in the DepChain except the last are PHIs.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h:3458,Integrability,depend,dependence,3458,"de long.; //; // Then, we traverse the uses of the PHI (X2) and the uses of the value of the; // PHI coming over the backedge (X1). We stop at the first pair of such users; // I1 (of X2) and I2 (of X1) that meet the following conditions.; // 1. I1 and I2 are the same operation, but with different operands.; // 2. X2 and X1 are used at the same operand number in the two instructions.; // 3. All other operands Op1 of I1 and Op2 of I2 are also such that there is a; // a DepChain from Op1 to Op2 of the same length as that between X2 and X1.; //; // We then make the following transformation; // LoopPreheader:; // X0 = a[0];; // Y0 = f(X0);; // Loop:; // X2 = PHI<(X0, LoopPreheader), (X1, Loop)>; // Y2 = PHI<(Y0, LoopPreheader), (t4, Loop)>; // t1 = f(X2) <-- Will be removed by DCE.; // t2 = g(Y2); // ...; // X1 = a[i+1]; // t4 = f(X1); // t5 = g(t4); // t6 = op(t2, t5); // cond_branch <Loop>; //; // We proceed until we cannot find any more such instructions I1 and I2.; //; // --- DepChains & Loop carried dependences ---; // Consider a single basic block loop such as; //; // LoopPreheader:; // X0 = ...; // Y0 = ...; // Loop:; // X2 = PHI<(X0, LoopPreheader), (X1, Loop)>; // Y2 = PHI<(Y0, LoopPreheader), (X2, Loop)>; // ...; // X1 = ...; // ...; // cond_branch <Loop>; //; // Then there is a dependence between X2 and X1 that goes back one iteration,; // i.e. X1 is used as X2 in the very next iteration. We represent this as a; // DepChain from X2 to X1 (X2->X1).; // Similarly, there is a dependence between Y2 and X1 that goes back two; // iterations. X1 is used as Y2 two iterations after it is computed. This is; // represented by a DepChain as (Y2->X2->X1).; //; // A DepChain has the following properties.; // 1. Num of edges in DepChain = Number of Instructions in DepChain = Number of; // iterations of carried dependence + 1.; // 2. All instructions in the DepChain except the last are PHIs.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h:3787,Integrability,depend,dependence,3787,"de long.; //; // Then, we traverse the uses of the PHI (X2) and the uses of the value of the; // PHI coming over the backedge (X1). We stop at the first pair of such users; // I1 (of X2) and I2 (of X1) that meet the following conditions.; // 1. I1 and I2 are the same operation, but with different operands.; // 2. X2 and X1 are used at the same operand number in the two instructions.; // 3. All other operands Op1 of I1 and Op2 of I2 are also such that there is a; // a DepChain from Op1 to Op2 of the same length as that between X2 and X1.; //; // We then make the following transformation; // LoopPreheader:; // X0 = a[0];; // Y0 = f(X0);; // Loop:; // X2 = PHI<(X0, LoopPreheader), (X1, Loop)>; // Y2 = PHI<(Y0, LoopPreheader), (t4, Loop)>; // t1 = f(X2) <-- Will be removed by DCE.; // t2 = g(Y2); // ...; // X1 = a[i+1]; // t4 = f(X1); // t5 = g(t4); // t6 = op(t2, t5); // cond_branch <Loop>; //; // We proceed until we cannot find any more such instructions I1 and I2.; //; // --- DepChains & Loop carried dependences ---; // Consider a single basic block loop such as; //; // LoopPreheader:; // X0 = ...; // Y0 = ...; // Loop:; // X2 = PHI<(X0, LoopPreheader), (X1, Loop)>; // Y2 = PHI<(Y0, LoopPreheader), (X2, Loop)>; // ...; // X1 = ...; // ...; // cond_branch <Loop>; //; // Then there is a dependence between X2 and X1 that goes back one iteration,; // i.e. X1 is used as X2 in the very next iteration. We represent this as a; // DepChain from X2 to X1 (X2->X1).; // Similarly, there is a dependence between Y2 and X1 that goes back two; // iterations. X1 is used as Y2 two iterations after it is computed. This is; // represented by a DepChain as (Y2->X2->X1).; //; // A DepChain has the following properties.; // 1. Num of edges in DepChain = Number of Instructions in DepChain = Number of; // iterations of carried dependence + 1.; // 2. All instructions in the DepChain except the last are PHIs.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h:429,Safety,redund,redundant,429,"//===- HexagonVectorLoopCarriedReuse.h ------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass removes the computation of provably redundant expressions that have; // been computed earlier in a previous iteration. It relies on the use of PHIs; // to identify loop carried dependences. This is scalar replacement for vector; // types.; //; //-----------------------------------------------------------------------------; // Motivation: Consider the case where we have the following loop structure.; //; // Loop:; // t0 = a[i];; // t1 = f(t0);; // t2 = g(t1);; // ...; // t3 = a[i+1];; // t4 = f(t3);; // t5 = g(t4);; // t6 = op(t2, t5); // cond_branch <Loop>; //; // This can be converted to; // t00 = a[0];; // t10 = f(t00);; // t20 = g(t10);; // Loop:; // t2 = t20;; // t3 = a[i+1];; // t4 = f(t3);; // t5 = g(t4);; // t6 = op(t2, t5); // t20 = t5; // cond_branch <Loop>; //; // SROA does a good job of reusing a[i+1] as a[i] in the next iteration.; // Such a loop comes to this pass in the following form.; //; // LoopPreheader:; // X0 = a[0];; // Loop:; // X2 = PHI<(X0, LoopPreheader), (X1, Loop)>; // t1 = f(X2) <-- I1; // t2 = g(t1); // ...; // X1 = a[i+1]; // t4 = f(X1) <-- I2; // t5 = g(t4); // t6 = op(t2, t5); // cond_branch <Loop>; //; // In this pass, we look for PHIs such as X2 whose incoming values come only; // from the Loop Preheader and over the backedge and additionaly, both these; // values are the results of the same operation in terms of opcode. We call such; // a PHI node a dependence chain or DepChain. In this case, the dependence of X2; // over X1 is carried over only one iteration and so the DepChain is only one; // PHI node long.; //; // Then, we traverse the uses of ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorPrint.cpp:7,Performance,load,load,7,// Vec load or compute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorPrint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorPrint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp:520,Performance,load,loads,520,"//===- HexagonVExtract.cpp ------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This pass will replace multiple occurrences of V6_extractw from the same; // vector register with a combination of a vector store and scalar loads.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp:3,Usability,Simpl,Simplified,3,// Simplified check for a compile-time constant value of ExtIdxR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp:227,Availability,avail,available,227,"// Make sure this is not a spill slot: spill slots cannot be aligned; // if there are variable-sized objects on the stack. They must be; // accessible via FP (which is not aligned), because SP is unknown,; // and AP may not be available at the location of the load/store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp:86,Modifiability,variab,variable-sized,86,"// Make sure this is not a spill slot: spill slots cannot be aligned; // if there are variable-sized objects on the stack. They must be; // accessible via FP (which is not aligned), because SP is unknown,; // and AP may not be available at the location of the load/store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp:260,Performance,load,load,260,"// Make sure this is not a spill slot: spill slots cannot be aligned; // if there are variable-sized objects on the stack. They must be; // accessible via FP (which is not aligned), because SP is unknown,; // and AP may not be available at the location of the load/store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp:140,Security,access,accessible,140,"// Make sure this is not a spill slot: spill slots cannot be aligned; // if there are variable-sized objects on the stack. They must be; // accessible via FP (which is not aligned), because SP is unknown,; // and AP may not be available at the location of the load/store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp:3,Deployability,Update,Update,3,// Update the required stack alignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:583,Availability,avail,available,583,"//===- HexagonPacketizer.cpp - VLIW packetizer ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements a simple VLIW packetizer using DFA. The packetizer works on; // machine basic blocks. For each instruction I in BB, the packetizer consults; // the DFA to see if machine resources are available to execute I. If so, the; // packetizer checks if I depends on any instruction J in the current packet.; // If no dependency is found, I is added to current packet and machine resource; // is marked as taken. If any dependency is found, a target API call is made to; // prune the dependence.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:645,Integrability,depend,depends,645,"//===- HexagonPacketizer.cpp - VLIW packetizer ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements a simple VLIW packetizer using DFA. The packetizer works on; // machine basic blocks. For each instruction I in BB, the packetizer consults; // the DFA to see if machine resources are available to execute I. If so, the; // packetizer checks if I depends on any instruction J in the current packet.; // If no dependency is found, I is added to current packet and machine resource; // is marked as taken. If any dependency is found, a target API call is made to; // prune the dependence.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:707,Integrability,depend,dependency,707,"//===- HexagonPacketizer.cpp - VLIW packetizer ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements a simple VLIW packetizer using DFA. The packetizer works on; // machine basic blocks. For each instruction I in BB, the packetizer consults; // the DFA to see if machine resources are available to execute I. If so, the; // packetizer checks if I depends on any instruction J in the current packet.; // If no dependency is found, I is added to current packet and machine resource; // is marked as taken. If any dependency is found, a target API call is made to; // prune the dependence.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:809,Integrability,depend,dependency,809,"//===- HexagonPacketizer.cpp - VLIW packetizer ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements a simple VLIW packetizer using DFA. The packetizer works on; // machine basic blocks. For each instruction I in BB, the packetizer consults; // the DFA to see if machine resources are available to execute I. If so, the; // packetizer checks if I depends on any instruction J in the current packet.; // If no dependency is found, I is added to current packet and machine resource; // is marked as taken. If any dependency is found, a target API call is made to; // prune the dependence.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:873,Integrability,depend,dependence,873,"//===- HexagonPacketizer.cpp - VLIW packetizer ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements a simple VLIW packetizer using DFA. The packetizer works on; // machine basic blocks. For each instruction I in BB, the packetizer consults; // the DFA to see if machine resources are available to execute I. If so, the; // packetizer checks if I depends on any instruction J in the current packet.; // If no dependency is found, I is added to current packet and machine resource; // is marked as taken. If any dependency is found, a target API call is made to; // prune the dependence.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:401,Usability,simpl,simple,401,"//===- HexagonPacketizer.cpp - VLIW packetizer ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements a simple VLIW packetizer using DFA. The packetizer works on; // machine basic blocks. For each instruction I in BB, the packetizer consults; // the DFA to see if machine resources are available to execute I. If so, the; // packetizer checks if I depends on any instruction J in the current packet.; // If no dependency is found, I is added to current packet and machine resource; // is marked as taken. If any dependency is found, a target API call is made to; // prune the dependence.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:99,Usability,simpl,simply,99,"// If it's not bundled with the successor (i.e. it is the last one; // in the bundle), then we can simply unbundle it from the predecessor,; // which will take care of updating the predecessor's flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:38,Testability,assert,asserting,38,// Get the size of the bundle without asserting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:40,Availability,failure,failures,40,// FIXME: This pass causes verification failures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:101,Integrability,depend,dependence,101,"// Loop over all basic blocks and remove KILL pseudo-instructions; // These instructions confuse the dependence analysis. Consider:; // D0 = ... (Insn 0); // R0 = KILL R0, D0 (Insn 1); // R0 = ... (Insn 2); // Here, Insn 1 will result in the dependence graph not emitting an output; // dependence between Insn 0 and Insn 2. This can lead to incorrect; // packetization",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:242,Integrability,depend,dependence,242,"// Loop over all basic blocks and remove KILL pseudo-instructions; // These instructions confuse the dependence analysis. Consider:; // D0 = ... (Insn 0); // R0 = KILL R0, D0 (Insn 1); // R0 = ... (Insn 2); // Here, Insn 1 will result in the dependence graph not emitting an output; // dependence between Insn 0 and Insn 2. This can lead to incorrect; // packetization",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:286,Integrability,depend,dependence,286,"// Loop over all basic blocks and remove KILL pseudo-instructions; // These instructions confuse the dependence analysis. Consider:; // D0 = ... (Insn 0); // R0 = KILL R0, D0 (Insn 1); // R0 = ... (Insn 2); // Here, Insn 1 will result in the dependence graph not emitting an output; // dependence between Insn 0 and Insn 2. This can lead to incorrect; // packetization",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:69,Energy Efficiency,schedul,scheduling,69,// Find the first non-boundary starting from the end of the last; // scheduling region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:11,Energy Efficiency,schedul,scheduling,11,// Add the scheduling boundary if it's not block end.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:36,Modifiability,extend,extender,36,// Reserve resources for a constant extender. Trigger an assertion if the; // reservation fails.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:57,Testability,assert,assertion,57,// Reserve resources for a constant extender. Trigger an assertion if the; // reservation fails.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:3,Energy Efficiency,Allocate,Allocate,3,"// Allocate resources (i.e. 4 bytes) for constant extender. If succeeded,; // return true, otherwise, return false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:50,Modifiability,extend,extender,50,"// Allocate resources (i.e. 4 bytes) for constant extender. If succeeded,; // return true, otherwise, return false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:16,Integrability,depend,dependence,16,// Check for LR dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:117,Performance,load,load,117,// Check for existing uses of a vector register within the packet which; // would be affected by converting a vector load into .cur formt.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:26,Deployability,update,update,26,/// Return true if we can update the offset in MI so that MI and MJ; /// can be packetized together.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:22,Integrability,depend,dependences,22,"// Make sure that the dependences do not restrict adding MI to the packet.; // That is, ignore anti dependences, and make sure the only data dependence; // involves the specific register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:100,Integrability,depend,dependences,100,"// Make sure that the dependences do not restrict adding MI to the packet.; // That is, ignore anti dependences, and make sure the only data dependence; // involves the specific register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:141,Integrability,depend,dependence,141,"// Make sure that the dependences do not restrict adding MI to the packet.; // That is, ignore anti dependences, and make sure the only data dependence; // involves the specific register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:4,Usability,Undo,Undo,4,/// Undo the changed offset. This is needed if the instruction cannot be; /// added to the current packet due to a different instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:59,Performance,load,load,59,// The 2nd operand is always the post increment operand in load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:22,Integrability,depend,dependency,22,// Make sure there is dependency and can be new value'd.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:428,Performance,perform,perform,428,"// Make sure that other than the new-value register no other store instruction; // register has been modified in the same packet. Predicate registers can be; // modified by they should not be modified between the producer and the store; // instruction as it will make them both conditional on different values.; // We already know this to be true for all the instructions before and; // including PacketMI. Howerver, we need to perform the check for the; // remaining instructions in the packet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:39,Integrability,depend,dependence,39,// We don't want to check PacketMI for dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:6,Integrability,depend,dependency,6,"// If dependency is trough an implicitly defined register, we should not; // newify the use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:71,Energy Efficiency,allocate,allocated,71,"// Create a dot new machine instruction to see if resources can be; // allocated. If not, bail out now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:61,Integrability,depend,dependency,61,"// Go through the packet instructions and search for an anti dependency between; // them and DepReg from MI. Consider this case:; // Trying to add; // a) %r1 = TFRI_cdNotPt %p3, 2; // to this packet:; // {; // b) %p0 = C2_or killed %p3, killed %p0; // c) %p3 = C2_tfrrp %r23; // d) %r1 = C2_cmovenewit %p3, 4; // }; // The P3 from a) and d) will be complements after; // a)'s P3 is converted to .new form; // Anti-dep between c) and b) is irrelevant for this case",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:20,Integrability,depend,dependencies,20,// We only care for dependencies to predicated instructions,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:3,Energy Efficiency,Schedul,Scheduling,3,// Scheduling Unit for current insn in the packet,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:11,Integrability,depend,dependencies,11,// Look at dependencies between current members of the packet and; // predicate defining instruction MI. Make sure that dependency is; // on the exact register we care about.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:120,Integrability,depend,dependency,120,// Look at dependencies between current members of the packet and; // predicate defining instruction MI. Make sure that dependency is; // on the exact register we care about.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:52,Safety,detect,detects,52,"// Given two predicated instructions, this function detects whether; // the predicates are complements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:3,Energy Efficiency,Schedul,Scheduling,3,// Scheduling unit for candidate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:387,Integrability,depend,dependencies,387,"// One corner case deals with the following scenario:; // Trying to add; // a) %r24 = A2_tfrt %p0, %r25; // to this packet:; // {; // b) %r25 = A2_tfrf %p0, %r24; // c) %p0 = C2_cmpeqi %r26, 1; // }; //; // On general check a) and b) are complements, but presence of c) will; // convert a) to .new form, and then it is not a complement.; // We attempt to detect it by analyzing existing dependencies in the packet.; // Analyze relationships between all existing members of the packet.; // Look for Anti dependecy on the same predicate reg as used in the; // candidate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:503,Integrability,depend,dependecy,503,"// One corner case deals with the following scenario:; // Trying to add; // a) %r24 = A2_tfrt %p0, %r25; // to this packet:; // {; // b) %r25 = A2_tfrf %p0, %r24; // c) %p0 = C2_cmpeqi %r26, 1; // }; //; // On general check a) and b) are complements, but presence of c) will; // convert a) to .new form, and then it is not a complement.; // We attempt to detect it by analyzing existing dependencies in the packet.; // Analyze relationships between all existing members of the packet.; // Look for Anti dependecy on the same predicate reg as used in the; // candidate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:355,Safety,detect,detect,355,"// One corner case deals with the following scenario:; // Trying to add; // a) %r24 = A2_tfrt %p0, %r25; // to this packet:; // {; // b) %r25 = A2_tfrf %p0, %r24; // c) %p0 = C2_cmpeqi %r26, 1; // }; //; // On general check a) and b) are complements, but presence of c) will; // convert a) to .new form, and then it is not a complement.; // We attempt to detect it by analyzing existing dependencies in the packet.; // Analyze relationships between all existing members of the packet.; // Look for Anti dependecy on the same predicate reg as used in the; // candidate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:3,Energy Efficiency,Schedul,Scheduling,3,// Scheduling Unit for current insn in the packet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:49,Integrability,depend,dependency,49,"// The corner case exist when there is true data dependency between; // candidate and one of current packet members, this dep is on; // predicate reg, and there already exist anti dep on the same pred in; // the packet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:190,Integrability,depend,dependency,190,// Here I know that I is predicate setting instruction with true; // data dep to candidate on the register we care about - c) in the; // above example. Now I need to see if there is an anti dependency; // from c) to any other instruction in the same packet on the pred; // reg of interest.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:243,Energy Efficiency,reduce,reduce,243,"// Consider inline asm to not be a solo instruction by default.; // Inline asm will be put in a packet temporarily, but then it will be; // removed, and placed outside of the packet (before or after, depending; // on dependencies). This is to reduce the impact of inline asm as a; // ""packet splitting"" instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:200,Integrability,depend,depending,200,"// Consider inline asm to not be a solo instruction by default.; // Inline asm will be put in a packet temporarily, but then it will be; // removed, and placed outside of the packet (before or after, depending; // on dependencies). This is to reduce the impact of inline asm as a; // ""packet splitting"" instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:217,Integrability,depend,dependencies,217,"// Consider inline asm to not be a solo instruction by default.; // Inline asm will be put in a packet temporarily, but then it will be; // removed, and placed outside of the packet (before or after, depending; // on dependencies). This is to reduce the impact of inline asm as a; // ""packet splitting"" instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:90,Testability,test,tests,90,"// Quick check if instructions MI and MJ cannot coexist in the same packet.; // Limit the tests to be ""one-way"", e.g. ""if MI->isBranch and MJ->isInlineAsm"",; // but not the symmetric case: ""if MJ->isBranch and MI->isInlineAsm"".; // For full test call this function twice:; // cannotCoexistAsymm(MI, MJ) || cannotCoexistAsymm(MJ, MI); // Doing the test only one way saves the amount of code in this function,; // since every test would need to be repeated with the MI and MJ reversed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:241,Testability,test,test,241,"// Quick check if instructions MI and MJ cannot coexist in the same packet.; // Limit the tests to be ""one-way"", e.g. ""if MI->isBranch and MJ->isInlineAsm"",; // but not the symmetric case: ""if MJ->isBranch and MI->isInlineAsm"".; // For full test call this function twice:; // cannotCoexistAsymm(MI, MJ) || cannotCoexistAsymm(MJ, MI); // Doing the test only one way saves the amount of code in this function,; // since every test would need to be repeated with the MI and MJ reversed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:347,Testability,test,test,347,"// Quick check if instructions MI and MJ cannot coexist in the same packet.; // Limit the tests to be ""one-way"", e.g. ""if MI->isBranch and MJ->isInlineAsm"",; // but not the symmetric case: ""if MJ->isBranch and MI->isInlineAsm"".; // For full test call this function twice:; // cannotCoexistAsymm(MI, MJ) || cannotCoexistAsymm(MJ, MI); // Doing the test only one way saves the amount of code in this function,; // since every test would need to be repeated with the MI and MJ reversed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:424,Testability,test,test,424,"// Quick check if instructions MI and MJ cannot coexist in the same packet.; // Limit the tests to be ""one-way"", e.g. ""if MI->isBranch and MJ->isInlineAsm"",; // but not the symmetric case: ""if MJ->isBranch and MI->isInlineAsm"".; // For full test call this function twice:; // cannotCoexistAsymm(MI, MJ) || cannotCoexistAsymm(MJ, MI); // Doing the test only one way saves the amount of code in this function,; // since every test would need to be repeated with the MI and MJ reversed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:217,Safety,avoid,avoid,217,"// An inline asm cannot be together with a branch, because we may not be; // able to remove the asm out after packetizing (i.e. if the asm must be; // moved past the bundle). Similarly, two asms cannot be together to avoid; // complications when determining their relative order outside of a bundle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:158,Integrability,depend,depends,158,"// Decide on where to insert the instruction that we are pulling out.; // Debug instructions always go before the bundle, but the placement of; // INLINE_ASM depends on potential dependencies. By default, try to; // put it before the bundle, but if the asm writes to a register that; // other instructions in the bundle read, then we need to place it; // after the bundle (to preserve the bundle semantics).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:179,Integrability,depend,dependencies,179,"// Decide on where to insert the instruction that we are pulling out.; // Debug instructions always go before the bundle, but the placement of; // INLINE_ASM depends on potential dependencies. By default, try to; // put it before the bundle, but if the asm writes to a register that; // other instructions in the bundle read, then we need to place it; // after the bundle (to preserve the bundle semantics).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:7,Integrability,depend,dependence,7,"// The dependence graph may not include edges between dead definitions,; // so without extra checks, we could end up packetizing two instruction; // defining the same (dead) register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:74,Energy Efficiency,schedul,scheduling,74,"// Adding I to a packet that has J.; // Regmasks are not reflected in the scheduling dependency graph, so; // we need to check them manually. This code assumes that regmasks only; // occur on calls, and the problematic case is when we add an instruction; // defining a register R to a packet that has a call that clobbers R via; // a regmask. Those cannot be packetized together, because the call will; // be executed last. That's also a reson why it is ok to add a call; // clobbering R to a packet that defines R.; // Look for regmasks in J.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:85,Integrability,depend,dependency,85,"// Adding I to a packet that has J.; // Regmasks are not reflected in the scheduling dependency graph, so; // we need to check them manually. This code assumes that regmasks only; // occur on calls, and the problematic case is when we add an instruction; // defining a register R to a packet that has a call that clobbers R via; // a regmask. Those cannot be packetized together, because the call will; // be executed last. That's also a reson why it is ok to add a call; // clobbering R to a packet that defines R.; // Look for regmasks in J.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:3,Usability,Clear,Clear,3,// Clear IgnoreDepMIs when Packet starts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:41,Energy Efficiency,schedul,scheduling,41,"// Regmasks are not accounted for in the scheduling graph, so we need; // to explicitly check for dependencies caused by them. They should only; // appear on calls, so it's not too pessimistic to reject all regmask; // dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:98,Integrability,depend,dependencies,98,"// Regmasks are not accounted for in the scheduling graph, so we need; // to explicitly check for dependencies caused by them. They should only; // appear on calls, so it's not too pessimistic to reject all regmask; // dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:219,Integrability,depend,dependencies,219,"// Regmasks are not accounted for in the scheduling graph, so we need; // to explicitly check for dependencies caused by them. They should only; // appear on calls, so it's not too pessimistic to reject all regmask; // dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:3,Security,Validat,Validate,3,"// Validate:; // 1. Packet does not have a store in it.; // 2. If the first operand of the nvj is newified, and the second; // operand is also a reg, it (second reg) is not defined in; // the same packet.; // 3. If the second operand of the nvj is newified, (which means; // first operand is also a reg), first reg is not defined in; // the same packet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:12,Integrability,depend,dependency,12,// There no dependency between a prolog instruction and its successor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:41,Integrability,depend,dependences,41,"// For direct calls:; // Ignore register dependences for call instructions for packetization; // purposes except for those due to r31 and predicate registers.; //; // For indirect calls:; // Same as direct calls + check for true dependences to the register; // used in the indirect call.; //; // We completely ignore Order dependences for call instructions.; //; // For returns:; // Ignore register dependences for return instructions like jumpr,; // dealloc return unless we have dependencies on the explicit uses; // of the registers used by jumpr (like r31) or dealloc return; // (like r29 or r30).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:229,Integrability,depend,dependences,229,"// For direct calls:; // Ignore register dependences for call instructions for packetization; // purposes except for those due to r31 and predicate registers.; //; // For indirect calls:; // Same as direct calls + check for true dependences to the register; // used in the indirect call.; //; // We completely ignore Order dependences for call instructions.; //; // For returns:; // Ignore register dependences for return instructions like jumpr,; // dealloc return unless we have dependencies on the explicit uses; // of the registers used by jumpr (like r31) or dealloc return; // (like r29 or r30).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:323,Integrability,depend,dependences,323,"// For direct calls:; // Ignore register dependences for call instructions for packetization; // purposes except for those due to r31 and predicate registers.; //; // For indirect calls:; // Same as direct calls + check for true dependences to the register; // used in the indirect call.; //; // We completely ignore Order dependences for call instructions.; //; // For returns:; // Ignore register dependences for return instructions like jumpr,; // dealloc return unless we have dependencies on the explicit uses; // of the registers used by jumpr (like r31) or dealloc return; // (like r29 or r30).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:399,Integrability,depend,dependences,399,"// For direct calls:; // Ignore register dependences for call instructions for packetization; // purposes except for those due to r31 and predicate registers.; //; // For indirect calls:; // Same as direct calls + check for true dependences to the register; // used in the indirect call.; //; // We completely ignore Order dependences for call instructions.; //; // For returns:; // Ignore register dependences for return instructions like jumpr,; // dealloc return unless we have dependencies on the explicit uses; // of the registers used by jumpr (like r31) or dealloc return; // (like r29 or r30).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:481,Integrability,depend,dependencies,481,"// For direct calls:; // Ignore register dependences for call instructions for packetization; // purposes except for those due to r31 and predicate registers.; //; // For indirect calls:; // Same as direct calls + check for true dependences to the register; // used in the indirect call.; //; // We completely ignore Order dependences for call instructions.; //; // For returns:; // Ignore register dependences for return instructions like jumpr,; // dealloc return unless we have dependencies on the explicit uses; // of the registers used by jumpr (like r31) or dealloc return; // (like r29 or r30).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:32,Performance,load,load,32,// Data dpendence ok if we have load.cur.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:91,Integrability,depend,dependence,91,"// For predicated instructions, if the predicates are complements then; // there can be no dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:71,Energy Efficiency,reduce,reduce,71,"// Not always safe to do this translation.; // DAG Builder attempts to reduce dependence edges using transitive; // nature of dependencies. Here is an example:; //; // r0 = tfr_pt ... (1); // r0 = tfr_pf ... (2); // r0 = tfr_pt ... (3); //; // There will be an output dependence between (1)->(2) and (2)->(3).; // However, there is no dependence edge between (1)->(3). This results; // in all 3 instructions going in the same packet. We ignore dependce; // only once to avoid this situation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:78,Integrability,depend,dependence,78,"// Not always safe to do this translation.; // DAG Builder attempts to reduce dependence edges using transitive; // nature of dependencies. Here is an example:; //; // r0 = tfr_pt ... (1); // r0 = tfr_pf ... (2); // r0 = tfr_pt ... (3); //; // There will be an output dependence between (1)->(2) and (2)->(3).; // However, there is no dependence edge between (1)->(3). This results; // in all 3 instructions going in the same packet. We ignore dependce; // only once to avoid this situation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:126,Integrability,depend,dependencies,126,"// Not always safe to do this translation.; // DAG Builder attempts to reduce dependence edges using transitive; // nature of dependencies. Here is an example:; //; // r0 = tfr_pt ... (1); // r0 = tfr_pf ... (2); // r0 = tfr_pt ... (3); //; // There will be an output dependence between (1)->(2) and (2)->(3).; // However, there is no dependence edge between (1)->(3). This results; // in all 3 instructions going in the same packet. We ignore dependce; // only once to avoid this situation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:268,Integrability,depend,dependence,268,"// Not always safe to do this translation.; // DAG Builder attempts to reduce dependence edges using transitive; // nature of dependencies. Here is an example:; //; // r0 = tfr_pt ... (1); // r0 = tfr_pf ... (2); // r0 = tfr_pt ... (3); //; // There will be an output dependence between (1)->(2) and (2)->(3).; // However, there is no dependence edge between (1)->(3). This results; // in all 3 instructions going in the same packet. We ignore dependce; // only once to avoid this situation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:335,Integrability,depend,dependence,335,"// Not always safe to do this translation.; // DAG Builder attempts to reduce dependence edges using transitive; // nature of dependencies. Here is an example:; //; // r0 = tfr_pt ... (1); // r0 = tfr_pf ... (2); // r0 = tfr_pt ... (3); //; // There will be an output dependence between (1)->(2) and (2)->(3).; // However, there is no dependence edge between (1)->(3). This results; // in all 3 instructions going in the same packet. We ignore dependce; // only once to avoid this situation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:444,Integrability,depend,dependce,444,"// Not always safe to do this translation.; // DAG Builder attempts to reduce dependence edges using transitive; // nature of dependencies. Here is an example:; //; // r0 = tfr_pt ... (1); // r0 = tfr_pf ... (2); // r0 = tfr_pt ... (3); //; // There will be an output dependence between (1)->(2) and (2)->(3).; // However, there is no dependence edge between (1)->(3). This results; // in all 3 instructions going in the same packet. We ignore dependce; // only once to avoid this situation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:14,Safety,safe,safe,14,"// Not always safe to do this translation.; // DAG Builder attempts to reduce dependence edges using transitive; // nature of dependencies. Here is an example:; //; // r0 = tfr_pt ... (1); // r0 = tfr_pf ... (2); // r0 = tfr_pt ... (3); //; // There will be an output dependence between (1)->(2) and (2)->(3).; // However, there is no dependence edge between (1)->(3). This results; // in all 3 instructions going in the same packet. We ignore dependce; // only once to avoid this situation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:470,Safety,avoid,avoid,470,"// Not always safe to do this translation.; // DAG Builder attempts to reduce dependence edges using transitive; // nature of dependencies. Here is an example:; //; // r0 = tfr_pt ... (1); // r0 = tfr_pf ... (2); // r0 = tfr_pt ... (3); //; // There will be an output dependence between (1)->(2) and (2)->(3).; // However, there is no dependence edge between (1)->(3). This results; // in all 3 instructions going in the same packet. We ignore dependce; // only once to avoid this situation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:16,Integrability,depend,dependences,16,// Ignore Order dependences between unconditional direct branches; // and non-control-flow instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:14,Integrability,depend,dependences,14,// Ignore all dependences for jumps except for true and output; // dependences.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:67,Integrability,depend,dependences,67,// Ignore all dependences for jumps except for true and output; // dependences.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:13,Integrability,depend,dependences,13,"// For Order dependences:; // 1. Volatile loads/stores can be packetized together, unless other; // rules prevent is.; // 2. Store followed by a load is not allowed.; // 3. Store followed by a store is valid.; // 4. Load followed by any memory operation is allowed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:42,Performance,load,loads,42,"// For Order dependences:; // 1. Volatile loads/stores can be packetized together, unless other; // rules prevent is.; // 2. Store followed by a load is not allowed.; // 3. Store followed by a store is valid.; // 4. Load followed by any memory operation is allowed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:145,Performance,load,load,145,"// For Order dependences:; // 1. Volatile loads/stores can be packetized together, unless other; // rules prevent is.; // 2. Store followed by a load is not allowed.; // 3. Store followed by a store is valid.; // 4. Load followed by any memory operation is allowed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:216,Performance,Load,Load,216,"// For Order dependences:; // 1. Volatile loads/stores can be packetized together, unless other; // rules prevent is.; // 2. Store followed by a load is not allowed.; // 3. Store followed by a store is valid.; // 4. Load followed by any memory operation is allowed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:48,Integrability,depend,dependence,48,// Don't reorder the loads if there is an order dependence. This would; // occur if the first instruction must go in slot0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:21,Performance,load,loads,21,// Don't reorder the loads if there is an order dependence. This would; // occur if the first instruction must go in slot0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:44,Integrability,depend,dependency,44,"// If J is neither load nor store, assume a dependency.; // If J is a load, but I is neither, also assume a dependency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:108,Integrability,depend,dependency,108,"// If J is neither load nor store, assume a dependency.; // If J is a load, but I is neither, also assume a dependency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:19,Performance,load,load,19,"// If J is neither load nor store, assume a dependency.; // If J is a load, but I is neither, also assume a dependency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:70,Performance,load,load,70,"// If J is neither load nor store, assume a dependency.; // If J is a load, but I is neither, also assume a dependency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:64,Performance,load,load,64,// Store followed by store: not OK on V2.; // Store followed by load: not OK on all.; // Load followed by store: OK on all.; // Load followed by load: OK on all.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:89,Performance,Load,Load,89,// Store followed by store: not OK on V2.; // Store followed by load: not OK on all.; // Load followed by store: OK on all.; // Load followed by load: OK on all.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:128,Performance,Load,Load,128,// Store followed by store: not OK on V2.; // Store followed by load: not OK on all.; // Load followed by store: OK on all.; // Load followed by load: OK on all.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:145,Performance,load,load,145,// Store followed by store: not OK on V2.; // Store followed by load: not OK on all.; // Load followed by store: OK on all.; // Load followed by load: OK on all.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:241,Deployability,update,updated,241,"// Special case for ALLOCFRAME: even though there is dependency; // between ALLOCFRAME and subsequent store, allow it to be packetized; // in a same packet. This implies that the store is using the caller's; // SP. Hence, offset needs to be updated accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:53,Integrability,depend,dependency,53,"// Special case for ALLOCFRAME: even though there is dependency; // between ALLOCFRAME and subsequent store, allow it to be packetized; // in a same packet. This implies that the store is using the caller's; // SP. Hence, offset needs to be updated accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:26,Integrability,depend,dependencies,26,"// There are certain anti-dependencies that cannot be ignored.; // Specifically:; // J2_call ... implicit-def %r0 ; SUJ; // R0 = ... ; SUI; // Those cannot be packetized together, since the call will observe; // the effect of the assignment to R0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:29,Integrability,depend,dependency,29,// If I has a regmask assume dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:28,Integrability,depend,dependences,28,"// Skip over remaining anti-dependences. Two instructions that are; // anti-dependent can share a packet, since in most such cases all; // operands are read before any modifications take place.; // The exceptions are branch and call instructions, since they are; // executed after all other instructions have completed (at least; // conceptually).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:76,Integrability,depend,dependent,76,"// Skip over remaining anti-dependences. Two instructions that are; // anti-dependent can share a packet, since in most such cases all; // operands are read before any modifications take place.; // The exceptions are branch and call instructions, since they are; // executed after all other instructions have completed (at least; // conceptually).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:112,Modifiability,extend,extender,112,"// We need to put both instructions in the same packet: MI and NvjMI.; // Either of them can require a constant extender. Try to add both to; // the current packet, and if that fails, end the packet and start a; // new one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:15,Energy Efficiency,schedul,scheduling,15,// V60 forward scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:121,Safety,avoid,avoid,121,"// Check whether the previous packet is in a different loop. If this is the; // case, there is little point in trying to avoid a stall because that would; // favor the rare case (loop entry) over the common case (loop iteration).; //; // TODO: We should really be able to check all the incoming edges if this is; // the first packet in a basic block, so we can avoid stalls from the loop; // backedge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:361,Safety,avoid,avoid,361,"// Check whether the previous packet is in a different loop. If this is the; // case, there is little point in trying to avoid a stall because that would; // favor the rare case (loop entry) over the common case (loop iteration).; //; // TODO: We should really be able to check all the incoming edges if this is; // the first packet in a basic block, so we can avoid stalls from the loop; // backedge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:740,Deployability,pipeline,pipeliner,740,"// If the latency is 0 and there is a data dependence between this; // instruction and any instruction in the current packet, we disregard any; // potential stalls due to the instructions in the previous packet. Most of; // the instruction pairs that can go together in the same packet have 0; // latency between them. The exceptions are; // 1. NewValueJumps as they're generated much later and the latencies can't; // be changed at that point.; // 2. .cur instructions, if its consumer has a 0 latency successor (such as; // .new). In this case, the latency between .cur and the consumer stays; // non-zero even though we can have both .cur and .new in the same packet.; // Changing the latency to 0 is not an option as it causes software pipeliner; // to not pipeline in some cases.; // For Example:; // {; // I1: v6.cur = vmem(r0++#1); // I2: v7 = valign(v6,v4,r2); // I3: vmem(r5++#1) = v7.new; // }; // Here I2 and I3 has 0 cycle latency, but I1 and I2 has 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:761,Deployability,pipeline,pipeline,761,"// If the latency is 0 and there is a data dependence between this; // instruction and any instruction in the current packet, we disregard any; // potential stalls due to the instructions in the previous packet. Most of; // the instruction pairs that can go together in the same packet have 0; // latency between them. The exceptions are; // 1. NewValueJumps as they're generated much later and the latencies can't; // be changed at that point.; // 2. .cur instructions, if its consumer has a 0 latency successor (such as; // .new). In this case, the latency between .cur and the consumer stays; // non-zero even though we can have both .cur and .new in the same packet.; // Changing the latency to 0 is not an option as it causes software pipeliner; // to not pipeline in some cases.; // For Example:; // {; // I1: v6.cur = vmem(r0++#1); // I2: v7 = valign(v6,v4,r2); // I3: vmem(r5++#1) = v7.new; // }; // Here I2 and I3 has 0 cycle latency, but I1 and I2 has 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:43,Integrability,depend,dependence,43,"// If the latency is 0 and there is a data dependence between this; // instruction and any instruction in the current packet, we disregard any; // potential stalls due to the instructions in the previous packet. Most of; // the instruction pairs that can go together in the same packet have 0; // latency between them. The exceptions are; // 1. NewValueJumps as they're generated much later and the latencies can't; // be changed at that point.; // 2. .cur instructions, if its consumer has a 0 latency successor (such as; // .new). In this case, the latency between .cur and the consumer stays; // non-zero even though we can have both .cur and .new in the same packet.; // Changing the latency to 0 is not an option as it causes software pipeliner; // to not pipeline in some cases.; // For Example:; // {; // I1: v6.cur = vmem(r0++#1); // I2: v7 = valign(v6,v4,r2); // I3: vmem(r5++#1) = v7.new; // }; // Here I2 and I3 has 0 cycle latency, but I1 and I2 has 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:10,Performance,latency,latency,10,"// If the latency is 0 and there is a data dependence between this; // instruction and any instruction in the current packet, we disregard any; // potential stalls due to the instructions in the previous packet. Most of; // the instruction pairs that can go together in the same packet have 0; // latency between them. The exceptions are; // 1. NewValueJumps as they're generated much later and the latencies can't; // be changed at that point.; // 2. .cur instructions, if its consumer has a 0 latency successor (such as; // .new). In this case, the latency between .cur and the consumer stays; // non-zero even though we can have both .cur and .new in the same packet.; // Changing the latency to 0 is not an option as it causes software pipeliner; // to not pipeline in some cases.; // For Example:; // {; // I1: v6.cur = vmem(r0++#1); // I2: v7 = valign(v6,v4,r2); // I3: vmem(r5++#1) = v7.new; // }; // Here I2 and I3 has 0 cycle latency, but I1 and I2 has 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:297,Performance,latency,latency,297,"// If the latency is 0 and there is a data dependence between this; // instruction and any instruction in the current packet, we disregard any; // potential stalls due to the instructions in the previous packet. Most of; // the instruction pairs that can go together in the same packet have 0; // latency between them. The exceptions are; // 1. NewValueJumps as they're generated much later and the latencies can't; // be changed at that point.; // 2. .cur instructions, if its consumer has a 0 latency successor (such as; // .new). In this case, the latency between .cur and the consumer stays; // non-zero even though we can have both .cur and .new in the same packet.; // Changing the latency to 0 is not an option as it causes software pipeliner; // to not pipeline in some cases.; // For Example:; // {; // I1: v6.cur = vmem(r0++#1); // I2: v7 = valign(v6,v4,r2); // I3: vmem(r5++#1) = v7.new; // }; // Here I2 and I3 has 0 cycle latency, but I1 and I2 has 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:495,Performance,latency,latency,495,"// If the latency is 0 and there is a data dependence between this; // instruction and any instruction in the current packet, we disregard any; // potential stalls due to the instructions in the previous packet. Most of; // the instruction pairs that can go together in the same packet have 0; // latency between them. The exceptions are; // 1. NewValueJumps as they're generated much later and the latencies can't; // be changed at that point.; // 2. .cur instructions, if its consumer has a 0 latency successor (such as; // .new). In this case, the latency between .cur and the consumer stays; // non-zero even though we can have both .cur and .new in the same packet.; // Changing the latency to 0 is not an option as it causes software pipeliner; // to not pipeline in some cases.; // For Example:; // {; // I1: v6.cur = vmem(r0++#1); // I2: v7 = valign(v6,v4,r2); // I3: vmem(r5++#1) = v7.new; // }; // Here I2 and I3 has 0 cycle latency, but I1 and I2 has 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:551,Performance,latency,latency,551,"// If the latency is 0 and there is a data dependence between this; // instruction and any instruction in the current packet, we disregard any; // potential stalls due to the instructions in the previous packet. Most of; // the instruction pairs that can go together in the same packet have 0; // latency between them. The exceptions are; // 1. NewValueJumps as they're generated much later and the latencies can't; // be changed at that point.; // 2. .cur instructions, if its consumer has a 0 latency successor (such as; // .new). In this case, the latency between .cur and the consumer stays; // non-zero even though we can have both .cur and .new in the same packet.; // Changing the latency to 0 is not an option as it causes software pipeliner; // to not pipeline in some cases.; // For Example:; // {; // I1: v6.cur = vmem(r0++#1); // I2: v7 = valign(v6,v4,r2); // I3: vmem(r5++#1) = v7.new; // }; // Here I2 and I3 has 0 cycle latency, but I1 and I2 has 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:688,Performance,latency,latency,688,"// If the latency is 0 and there is a data dependence between this; // instruction and any instruction in the current packet, we disregard any; // potential stalls due to the instructions in the previous packet. Most of; // the instruction pairs that can go together in the same packet have 0; // latency between them. The exceptions are; // 1. NewValueJumps as they're generated much later and the latencies can't; // be changed at that point.; // 2. .cur instructions, if its consumer has a 0 latency successor (such as; // .new). In this case, the latency between .cur and the consumer stays; // non-zero even though we can have both .cur and .new in the same packet.; // Changing the latency to 0 is not an option as it causes software pipeliner; // to not pipeline in some cases.; // For Example:; // {; // I1: v6.cur = vmem(r0++#1); // I2: v7 = valign(v6,v4,r2); // I3: vmem(r5++#1) = v7.new; // }; // Here I2 and I3 has 0 cycle latency, but I1 and I2 has 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:935,Performance,latency,latency,935,"// If the latency is 0 and there is a data dependence between this; // instruction and any instruction in the current packet, we disregard any; // potential stalls due to the instructions in the previous packet. Most of; // the instruction pairs that can go together in the same packet have 0; // latency between them. The exceptions are; // 1. NewValueJumps as they're generated much later and the latencies can't; // be changed at that point.; // 2. .cur instructions, if its consumer has a 0 latency successor (such as; // .new). In this case, the latency between .cur and the consumer stays; // non-zero even though we can have both .cur and .new in the same packet.; // Changing the latency to 0 is not an option as it causes software pipeliner; // to not pipeline in some cases.; // For Example:; // {; // I1: v6.cur = vmem(r0++#1); // I2: v7 = valign(v6,v4,r2); // I3: vmem(r5++#1) = v7.new; // }; // Here I2 and I3 has 0 cycle latency, but I1 and I2 has 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:16,Performance,latency,latency,16,// Check if the latency is greater than one between this instruction and any; // instruction in the previous packet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h:49,Integrability,depend,dependences,49,"// This holds the offset value, when pruning the dependences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h:23,Integrability,depend,dependence,23,// Check if there is a dependence between some instruction already in this; // packet and this instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h:52,Availability,avail,available,52,// Only check for dependence if there are resources available to; // schedule this instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h:69,Energy Efficiency,schedul,schedule,69,// Only check for dependence if there are resources available to; // schedule this instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h:18,Integrability,depend,dependence,18,// Only check for dependence if there are resources available to; // schedule this instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h:26,Integrability,depend,dependence,26,// Track MIs with ignored dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h:86,Integrability,depend,dependence,86,// Set to the number of cycles of stall a given instruction will incur; // because of dependence on instruction in previous packet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h:53,Integrability,depend,dependece,53,// isLegalToPruneDependencies - Is it legal to prune dependece between SUI; // and SUJ.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFCopy.cpp:3,Deployability,Update,Update,3,// Update the EM map in the copy's entry.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFCopy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFCopy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.cpp:92,Performance,queue,queue,92,"// This drastically improves execution time in ""collect"" over using; // SetVector as a work queue, and popping the first element from it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.cpp:113,Safety,safe,safe,113,"// Check if the given instruction has observable side-effects, i.e. if; // it should be considered ""live"". It is safe for this function to be; // overly conservative (i.e. return ""true"" for all instructions), but it; // is not safe to return ""false"" for an instruction that should not be; // considered removable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.cpp:227,Safety,safe,safe,227,"// Check if the given instruction has observable side-effects, i.e. if; // it should be considered ""live"". It is safe for this function to be; // overly conservative (i.e. return ""true"" for all instructions), but it; // is not safe to return ""false"" for an instruction that should not be; // considered removable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.h:898,Deployability,update,update,898,"//===--- RDFDeadCode.h ----------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // RDF-based generic dead code elimination.; //; // The main interface of this class are functions ""collect"" and ""erase"".; // This allows custom processing of the function being optimized by a; // particular consumer. The simplest way to use this class would be to; // instantiate an object, and then simply call ""collect"" and ""erase"",; // passing the result of ""getDeadInstrs()"" to it.; // A more complex scenario would be to call ""collect"" first, then visit; // all post-increment instructions to see if the address update is dead; // or not, and if it is, convert the instruction to a non-updating form.; // After that ""erase"" can be called with the set of nodes including both,; // dead defs from the updating instructions and the nodes corresponding; // to the dead instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.h:441,Integrability,interface,interface,441,"//===--- RDFDeadCode.h ----------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // RDF-based generic dead code elimination.; //; // The main interface of this class are functions ""collect"" and ""erase"".; // This allows custom processing of the function being optimized by a; // particular consumer. The simplest way to use this class would be to; // instantiate an object, and then simply call ""collect"" and ""erase"",; // passing the result of ""getDeadInstrs()"" to it.; // A more complex scenario would be to call ""collect"" first, then visit; // all post-increment instructions to see if the address update is dead; // or not, and if it is, convert the instruction to a non-updating form.; // After that ""erase"" can be called with the set of nodes including both,; // dead defs from the updating instructions and the nodes corresponding; // to the dead instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.h:558,Performance,optimiz,optimized,558,"//===--- RDFDeadCode.h ----------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // RDF-based generic dead code elimination.; //; // The main interface of this class are functions ""collect"" and ""erase"".; // This allows custom processing of the function being optimized by a; // particular consumer. The simplest way to use this class would be to; // instantiate an object, and then simply call ""collect"" and ""erase"",; // passing the result of ""getDeadInstrs()"" to it.; // A more complex scenario would be to call ""collect"" first, then visit; // all post-increment instructions to see if the address update is dead; // or not, and if it is, convert the instruction to a non-updating form.; // After that ""erase"" can be called with the set of nodes including both,; // dead defs from the updating instructions and the nodes corresponding; // to the dead instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.h:602,Usability,simpl,simplest,602,"//===--- RDFDeadCode.h ----------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // RDF-based generic dead code elimination.; //; // The main interface of this class are functions ""collect"" and ""erase"".; // This allows custom processing of the function being optimized by a; // particular consumer. The simplest way to use this class would be to; // instantiate an object, and then simply call ""collect"" and ""erase"",; // passing the result of ""getDeadInstrs()"" to it.; // A more complex scenario would be to call ""collect"" first, then visit; // all post-increment instructions to see if the address update is dead; // or not, and if it is, convert the instruction to a non-updating form.; // After that ""erase"" can be called with the set of nodes including both,; // dead defs from the updating instructions and the nodes corresponding; // to the dead instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.h:681,Usability,simpl,simply,681,"//===--- RDFDeadCode.h ----------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // RDF-based generic dead code elimination.; //; // The main interface of this class are functions ""collect"" and ""erase"".; // This allows custom processing of the function being optimized by a; // particular consumer. The simplest way to use this class would be to; // instantiate an object, and then simply call ""collect"" and ""erase"",; // passing the result of ""getDeadInstrs()"" to it.; // A more complex scenario would be to call ""collect"" first, then visit; // all post-increment instructions to see if the address update is dead; // or not, and if it is, convert the instruction to a non-updating form.; // After that ""erase"" can be called with the set of nodes including both,; // dead defs from the updating instructions and the nodes corresponding; // to the dead instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp:29,Safety,detect,detect,29,// FIXME: need better way to detect AsmStreamer (upstream removed getKind()),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp:24,Availability,error,errors,24,// Check the bundle for errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp:3,Availability,Error,Error,3,// Error,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp:6,Availability,error,error,6,// No error,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp:3,Performance,Perform,Perform,3,// Perform matching with tablegen asmmatcher generated function,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp:162,Availability,error,error,162,"// Create instruction operand for bundle instruction; // Break this into a separate function Code here is less readable; // Think about how to get an instruction error to report correctly.; // SMLoc will return the ""{""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp:60,Modifiability,extend,extended,60,"// This is largely a copy of AsmParser's ParseDirectiveComm extended to; // accept a 3rd argument, AccessAlignment which indicates the smallest; // memory access made to the symbol, expressed in bytes. If no; // AccessAlignment is specified it defaults to the Alignment Value.; // Hexagon's .lcomm:; // .lcomm Symbol, Length, Alignment, AccessAlignment",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp:99,Security,Access,AccessAlignment,99,"// This is largely a copy of AsmParser's ParseDirectiveComm extended to; // accept a 3rd argument, AccessAlignment which indicates the smallest; // memory access made to the symbol, expressed in bytes. If no; // AccessAlignment is specified it defaults to the Alignment Value.; // Hexagon's .lcomm:; // .lcomm Symbol, Length, Alignment, AccessAlignment",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp:155,Security,access,access,155,"// This is largely a copy of AsmParser's ParseDirectiveComm extended to; // accept a 3rd argument, AccessAlignment which indicates the smallest; // memory access made to the symbol, expressed in bytes. If no; // AccessAlignment is specified it defaults to the Alignment Value.; // Hexagon's .lcomm:; // .lcomm Symbol, Length, Alignment, AccessAlignment",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp:212,Security,Access,AccessAlignment,212,"// This is largely a copy of AsmParser's ParseDirectiveComm extended to; // accept a 3rd argument, AccessAlignment which indicates the smallest; // memory access made to the symbol, expressed in bytes. If no; // AccessAlignment is specified it defaults to the Alignment Value.; // Hexagon's .lcomm:; // .lcomm Symbol, Length, Alignment, AccessAlignment",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp:337,Security,Access,AccessAlignment,337,"// This is largely a copy of AsmParser's ParseDirectiveComm extended to; // accept a 3rd argument, AccessAlignment which indicates the smallest; // memory access made to the symbol, expressed in bytes. If no; // AccessAlignment is specified it defaults to the Alignment Value.; // Hexagon's .lcomm:; // .lcomm Symbol, Length, Alignment, AccessAlignment",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp:29,Safety,detect,detect,29,// FIXME: need better way to detect if AsmStreamer (upstream removed; // getKind()),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp:16,Security,access,access,16,"// The optional access argument specifies the size of the smallest memory; // access to be made to the symbol, expressed in bytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp:78,Security,access,access,78,"// The optional access argument specifies the size of the smallest memory; // access to be made to the symbol, expressed in bytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp:45,Energy Efficiency,power,power,45,"// NOTE: The alignment in the directive is a power of 2 value, the assembler; // may internally end up wanting an alignment in bytes.; // FIXME: Diagnose overflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp:3,Security,validat,validate,3,// validate register against architecture,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp:14,Modifiability,extend,extend,14,// Don't lazy extend these expression variants,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp:47,Availability,failure,failure,47,// FIXME: Calls to OutOfRange shoudl propagate failure up to parseStatement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp:29,Safety,detect,detect,29,// FIXME: need better way to detect AsmStreamer (upstream removed getKind()),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/Disassembler/HexagonDisassembler.cpp:106,Availability,down,down,106,// Forward declare these because the auto-generated code will reference them.; // Definitions are further down.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/Disassembler/HexagonDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/Disassembler/HexagonDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/Disassembler/HexagonDisassembler.cpp:12,Modifiability,extend,extenders,12,// constant extenders in duplex must always be in slot 1,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/Disassembler/HexagonDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/Disassembler/HexagonDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/Disassembler/HexagonDisassembler.cpp:16,Modifiability,extend,extendable,16,"// r13_2 is not extendable, so if there are no extent bits, it's r13_2",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/Disassembler/HexagonDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/Disassembler/HexagonDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp:3,Deployability,Update,Update,3,// Update the fragment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp:3,Availability,Error,Error,3,// Error: value 1124 out of range: -1024-1023 when resolving; // symbol in file xprtsock.S,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp:70,Modifiability,extend,extended,70,"// Since the existing branches that use this relocation cannot be; // extended, they should only be fixed up if the target is within range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp:57,Availability,mask,mask,57,"// For each byte of the fragment that the fixup touches, mask in the; // bits from the fixup value. The Value has been ""split up"" into the; // appropriate bitfields above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp:3,Usability,Clear,Clear,3,// Clear reloc bits,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp:129,Testability,test,test,129,/// MayNeedRelaxation - Check whether the given instruction may need; /// relaxation.; ///; /// \param Inst - The instruction to test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp:4,Usability,Simpl,Simple,4,/// Simple predicate for targets where !Resolved implies requiring relaxation,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp:16,Modifiability,extend,extender,16,"// if immediate extender needed, add it in",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp:62,Modifiability,extend,extended,62,// now copy over the original instruction(the one we may have extended),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp:10,Availability,Error,Error,10,//assert(!Error);,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp:2,Testability,assert,assert,2,//assert(!Error);,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h:3,Performance,Load,Loads,3,// Loads that can become current-value loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h:39,Performance,load,loads,39,// Loads that can become current-value loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h:17,Performance,load,load,17,// Current-value load instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h:3,Modifiability,Extend,Extendable,3,// Extendable insns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h:17,Modifiability,extend,extended,17,// Insns must be extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h:24,Modifiability,extend,extended,24,// Which operand may be extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h:34,Modifiability,extend,extending,34,// Number of bits of range before extending operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h:13,Energy Efficiency,power,power-of-two,13,// Alignment power-of-two before extending operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h:33,Modifiability,extend,extending,33,// Alignment power-of-two before extending operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h:23,Performance,load,load,23,// Addressing mode for load/store instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h:19,Performance,load,load,19,// Access size for load/store instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h:3,Security,Access,Access,3,// Access size for load/store instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h:10,Safety,predict,predicted,10,// Branch predicted taken.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h:100,Availability,mask,mask,100,// *** The code above must match HexagonInstrFormat*.td *** //; // Hexagon specific MO operand flag mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h:91,Deployability,update,update,91,"// Hexagon-specific MachineOperand target flags.; //; // When changing these, make sure to update; // getSerializableDirectMachineOperandTargetFlags and; // getSerializableBitmaskMachineOperandTargetFlags if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h:97,Availability,mask,mask,97,"// HMOTF_ConstExtended; // Addendum to above, indicates a const extended op; // Can be used as a mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h:64,Modifiability,extend,extended,64,"// HMOTF_ConstExtended; // Addendum to above, indicates a const extended op; // Can be used as a mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp:3,Safety,Avoid,Avoid,3,// Avoid scoring the defined register multiple times.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp:127,Testability,log,logical,127,"// P3:0 is a special case, since multiple predicate register definitions; // in a packet is allowed as the equivalent of their logical ""and"".; // Only an explicit definition of P3:0 is noted as such; if a; // side-effect, then note as a soft definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp:13,Performance,load,loads,13,"// Temporary loads should be used in the same packet, but don't commit; // results, so it should be disregarded if another insn changes the same; // register.; // TODO: relies on the impossibility of a current and a temporary loads; // in the same packet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp:226,Performance,load,loads,226,"// Temporary loads should be used in the same packet, but don't commit; // results, so it should be disregarded if another insn changes the same; // register.; // TODO: relies on the impossibility of a current and a temporary loads; // in the same packet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp:3,Availability,Error,Error,3,"// Error out if the new predicate register is not defined,; // or defined ""late""; // (e.g., ""{ if (p3.new)... ; p3 = sp1loop0(#r7:2, Rs) }"").",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp:3,Availability,Error,Error,3,"// Error out if predicate register defined ""late"" multiple times or; // defined late and regularly defined; // (e.g., ""{ p3 = sp1loop0(...); p3 = cmp.eq(...) }"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp:50,Energy Efficiency,consumption,consumption,50,// Checks that statically prove correct new value consumption,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp:99,Performance,load,load,99,"// The ProducerOpIsMemIndex logic checks for the index of the producer; // register operand. Z-reg load instructions have an implicit operand; // that's not encoded, so the producer won't appear as the 1-th def, it; // will be at the 0-th.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp:28,Testability,log,logic,28,"// The ProducerOpIsMemIndex logic checks for the index of the producer; // register operand. Z-reg load instructions have an implicit operand; // that's not encoded, so the producer won't appear as the 1-th def, it; // will be at the 0-th.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp:3,Availability,Error,Error,3,// Error out for definitions of loop registers at the end of a loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp:3,Availability,Error,Error,3,"// Error out for explicit changes to registers also weakly defined; // (e.g., ""{ usr = r0; r0 = sfadd(...) }"").",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp:3,Availability,Error,Error,3,"// Error out on an unconditional change when there are any other; // changes, conditional or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp:3,Availability,Error,Error,3,"// Error out on conditional changes based on the same predicate; // (e.g., ""{ if (!p0) r0 =...; if (!p0) r0 =... }"").",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp:3,Availability,Error,Error,3,"// Error out on conditional changes based on the same predicate; // multiple times; // (e.g., ""if (p0) r0 =...; if (!p0) r0 =... }; if (!p0) r0 =..."").",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.h:10,Performance,perform,performed,10,// Checks performed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.cpp:45,Integrability,depend,depending,45,"//; // [2] The actual fixup is LO16 or HI16, depending on the instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.cpp:51,Modifiability,extend,extenders,51,"// Check for unimplemented instructions. Immediate extenders; // are encoded as zero, so they need to be accounted for.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.cpp:52,Availability,mask,masked,52,// 29 is the bit position.; // 0b1110 =0xE bits are masked off and down shifted by 1 bit.; // Last bit is moved to bit position 13,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.cpp:67,Availability,down,down,67,// 29 is the bit position.; // 0b1110 =0xE bits are masked off and down shifted by 1 bit.; // Last bit is moved to bit position 13,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.cpp:23,Modifiability,extend,extended,23,/// Some insns are not extended and thus have no bits. These cases require; /// a more brute force method for determining the correct relocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.cpp:34,Modifiability,extend,extended,34,"// Only sub-instruction #1 can be extended in a duplex. If MI is a; // sub-instruction #0, it is not extended even if Extended is true; // (it can be true for the duplex as a whole).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.cpp:101,Modifiability,extend,extended,101,"// Only sub-instruction #1 can be extended in a duplex. If MI is a; // sub-instruction #0, it is not extended even if Extended is true; // (it can be true for the duplex as a whole).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.cpp:118,Modifiability,Extend,Extended,118,"// Only sub-instruction #1 can be extended in a duplex. If MI is a; // sub-instruction #0, it is not extended even if Extended is true; // (it can be true for the duplex as a whole).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.h:10,Integrability,rout,routine,10,// helper routine for getMachineOpValue(),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCompound.cpp:80,Testability,test,test,80,// Transfer and jump:; // Rd=#U6 ; jump #r9:2; // Rd=Rs ; jump #r9:2; // Do not test for jump range here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCompound.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCompound.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCompound.cpp:81,Deployability,update,update,81,/// tryCompound - Given a bundle check for compound insns when one; /// is found update the contents fo the bundle with the compound insn.; /// If a compound instruction is found then the bundle will have one; /// additional slot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCompound.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCompound.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCompound.cpp:49,Deployability,update,update,49,"// Look for compounds until none are found, only update the bundle when; // a compound is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCompound.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCompound.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCompound.cpp:11,Deployability,update,update,11,// Need to update the bundle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCompound.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCompound.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp:428,Energy Efficiency,reduce,reduce,428,"//===- HexagonMCDuplexInfo.cpp - Instruction bundle checking --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements duplexing of instructions to reduce code size; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp:3,Testability,test,testing,3,"// testing for case of: Rx = add(Rx,#s7)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp:20,Modifiability,extend,extended,20,// Slot 1 cannot be extended in duplexes PRM 10.5,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp:36,Modifiability,extend,extended,36,// Only A2_addi and A2_tfrsi can be extended in duplex form PRM 10.5,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp:31,Modifiability,extend,extenders,31,// Prevent 2 instructions with extenders from duplexing; // Note that MIb (slot1) can be extended and MIa (slot0); // can never be extended,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp:89,Modifiability,extend,extended,89,// Prevent 2 instructions with extenders from duplexing; // Note that MIb (slot1) can be extended and MIa (slot0); // can never be extended,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp:131,Modifiability,extend,extended,131,// Prevent 2 instructions with extenders from duplexing; // Note that MIb (slot1) can be extended and MIa (slot0); // can never be extended,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp:28,Modifiability,extend,extender,28,"// If duplexing produces an extender, but the original did not; // have an extender, do not duplex.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp:75,Modifiability,extend,extender,75,"// If duplexing produces an extender, but the original did not; // have an extender, do not duplex.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCELFStreamer.cpp:397,Testability,stub,stub,397,"//=== HexagonMCELFStreamer.cpp - Hexagon subclass of MCELFStreamer -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file is a stub that parses a MCInst bundle and passes the; // instructions on to the real streamer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCELFStreamer.cpp:50,Modifiability,extend,extended,50,// EmitCommonSymbol and EmitLocalCommonSymbol are extended versions of the; // functions found in MCELFStreamer.cpp taking AccessSize as an additional; // parameter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCELFStreamer.cpp:123,Security,Access,AccessSize,123,// EmitCommonSymbol and EmitLocalCommonSymbol are extended versions of the; // functions found in MCELFStreamer.cpp taking AccessSize as an additional; // parameter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCELFStreamer.cpp:3,Deployability,Update,Update,3,// Update the maximum alignment of the section if necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp:394,Modifiability,extend,extends,394,"//===- HexagonMCInstrInfo.cpp - Hexagon sub-class of MCInst ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This class extends MCInstrInfo to allow Hexagon specific MCInstr queries; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp:14,Modifiability,extend,extender,14,// Create the extender.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp:24,Availability,error,errors,24,// Check the bundle for errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp:39,Energy Efficiency,reduce,reduce,39,// If compounding and duplexing didn't reduce the size below; // 4 or less we have a packet that is too big.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp:24,Availability,error,errors,24,// Check the bundle for errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp:35,Modifiability,extend,extendable,35,/// Return the maximum value of an extendable operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp:35,Modifiability,extend,extendable,35,/// Return the minimum value of an extendable operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp:34,Modifiability,extend,extendable,34,/// Return whether the operand is extendable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp:96,Security,access,accessing,96,"// If we're a single vector consumer of a double producer, set subreg bit; // based on if we're accessing the lower or upper register component",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h:25,Performance,load,load,25,// do not reorder memory load/stores by default load/stores are re-ordered; // and by default loads can be re-ordered,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h:48,Performance,load,load,48,// do not reorder memory load/stores by default load/stores are re-ordered; // and by default loads can be re-ordered,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h:94,Performance,load,loads,94,// do not reorder memory load/stores by default load/stores are re-ordered; // and by default loads can be re-ordered,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h:14,Modifiability,extend,extender,14,// Return the extender for instruction at Index or nullptr if none,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h:17,Security,access,access,17,// Return memory access size in bytes,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h:17,Security,access,access,17,// Return memory access size,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h:27,Modifiability,extend,extendable,27,// Return the index of the extendable operand,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h
