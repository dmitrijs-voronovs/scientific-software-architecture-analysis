id,quality_attribute,keyword,matched_word,match_idx,sentence,source,author,repo,version,wiki,url
https://github.com/qutip/qutip/pull/899:25,Deployability,release,release,25,Bumping micro after pypi release.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/899
https://github.com/qutip/qutip/issues/900:112,Deployability,release,releases,112,"It would be really nice if qutip coud support the numba jit compiler (https://numba.pydata.org/) in some future releases. This would also enable, to perform calculations using the GPU very easily.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/900
https://github.com/qutip/qutip/issues/900:149,Performance,perform,perform,149,"It would be really nice if qutip coud support the numba jit compiler (https://numba.pydata.org/) in some future releases. This would also enable, to perform calculations using the GPU very easily.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/900
https://github.com/qutip/qutip/issues/905:85,Deployability,update,update,85,"The version requirements need increasing. This was posted on the help group.; Please update the requirements, for the new features (PIQS and photon scattering) to work Numpy = 1.12.0+ is required as numpy.flip() and numpy.geomspace are used.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/905
https://github.com/qutip/qutip/issues/907:423,Availability,error,error,423,"Every other file works fine. . For example, double click qobj.py and this opens. ![example](https://user-images.githubusercontent.com/32380833/43563341-b0c54b2a-965c-11e8-917c-4f2c18d8b457.png). Double click random_objects.py and it freezes and does nothing. I can open it in other editors like vim but I think it *should* work with the python default editor. . When I try to open up with IDLE from command line I get this error. ![error](https://user-images.githubusercontent.com/32380833/43563415-f443f842-965c-11e8-94f2-c28503bc6637.png). Which leads me to think there's a character somewhere in the file that causes the crash. But I don't know where.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/907
https://github.com/qutip/qutip/issues/907:432,Availability,error,error,432,"Every other file works fine. . For example, double click qobj.py and this opens. ![example](https://user-images.githubusercontent.com/32380833/43563341-b0c54b2a-965c-11e8-917c-4f2c18d8b457.png). Double click random_objects.py and it freezes and does nothing. I can open it in other editors like vim but I think it *should* work with the python default editor. . When I try to open up with IDLE from command line I get this error. ![error](https://user-images.githubusercontent.com/32380833/43563415-f443f842-965c-11e8-94f2-c28503bc6637.png). Which leads me to think there's a character somewhere in the file that causes the crash. But I don't know where.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/907
https://github.com/qutip/qutip/issues/908:116,Deployability,install,installe,116,"I am starting to use qutip and would like to draw 3D bloch spheres but cannot import Bloch3d() because of mayavi. I installe dmayavi from anaconda but now there;s some issue with ""vtk""; My qutip version is - 4.2.0",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/908
https://github.com/qutip/qutip/issues/911:112,Availability,error,error,112,I try to `pip install qutip==4.0.2` (all the latest versions cannot be installed and have even more complicated error). The error seems to be easier to diagnosed. But I still cannot find out which part goes wrong and why the error happened. The error is:; ```; Collecting qutip==4.0.2; Using cached https://files.pythonhosted.org/packages/c1/de/2efee1b7f6cadd45426ef7b0759cdc3e522672a509d1c75bb317cc4be6cb/qutip-4.0.2.tar.gz; Complete output from command python setup.py egg_info:; ; Error compiling Cython file:; ------------------------------------------------------------; ...; ; DTYPE = np.float64; ^; ------------------------------------------------------------; ; qutip/cy/parameters.pxi:2:10: cimported module has no attribute 'float64'; ; Error compiling Cython file:; ------------------------------------------------------------; ...; ; DTYPE = np.float64; ctypedef np.float64_t DTYPE_t; ; ITYPE = np.int32; ^; ------------------------------------------------------------; ; qutip/cy/parameters.pxi:5:10: cimported module has no attribute 'int32'; ; Error compiling Cython file:; ------------------------------------------------------------; ...; ctypedef np.float64_t DTYPE_t; ; ITYPE = np.int32; ctypedef np.int32_t ITYPE_t; ; CTYPE = np.complex128; ^; ------------------------------------------------------------; ; qutip/cy/parameters.pxi:8:10: cimported module has no attribute 'complex128'; ; Error compiling Cython file:; ------------------------------------------------------------; ...; ctypedef np.int32_t ITYPE_t; ; CTYPE = np.complex128; ctypedef np.complex128_t CTYPE_t; ; CTYPE = np.int64; ^; ------------------------------------------------------------; ; qutip/cy/parameters.pxi:11:10: cimported module has no attribute 'int64'; ```; Thank you very much.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/911
https://github.com/qutip/qutip/issues/911:124,Availability,error,error,124,I try to `pip install qutip==4.0.2` (all the latest versions cannot be installed and have even more complicated error). The error seems to be easier to diagnosed. But I still cannot find out which part goes wrong and why the error happened. The error is:; ```; Collecting qutip==4.0.2; Using cached https://files.pythonhosted.org/packages/c1/de/2efee1b7f6cadd45426ef7b0759cdc3e522672a509d1c75bb317cc4be6cb/qutip-4.0.2.tar.gz; Complete output from command python setup.py egg_info:; ; Error compiling Cython file:; ------------------------------------------------------------; ...; ; DTYPE = np.float64; ^; ------------------------------------------------------------; ; qutip/cy/parameters.pxi:2:10: cimported module has no attribute 'float64'; ; Error compiling Cython file:; ------------------------------------------------------------; ...; ; DTYPE = np.float64; ctypedef np.float64_t DTYPE_t; ; ITYPE = np.int32; ^; ------------------------------------------------------------; ; qutip/cy/parameters.pxi:5:10: cimported module has no attribute 'int32'; ; Error compiling Cython file:; ------------------------------------------------------------; ...; ctypedef np.float64_t DTYPE_t; ; ITYPE = np.int32; ctypedef np.int32_t ITYPE_t; ; CTYPE = np.complex128; ^; ------------------------------------------------------------; ; qutip/cy/parameters.pxi:8:10: cimported module has no attribute 'complex128'; ; Error compiling Cython file:; ------------------------------------------------------------; ...; ctypedef np.int32_t ITYPE_t; ; CTYPE = np.complex128; ctypedef np.complex128_t CTYPE_t; ; CTYPE = np.int64; ^; ------------------------------------------------------------; ; qutip/cy/parameters.pxi:11:10: cimported module has no attribute 'int64'; ```; Thank you very much.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/911
https://github.com/qutip/qutip/issues/911:225,Availability,error,error,225,I try to `pip install qutip==4.0.2` (all the latest versions cannot be installed and have even more complicated error). The error seems to be easier to diagnosed. But I still cannot find out which part goes wrong and why the error happened. The error is:; ```; Collecting qutip==4.0.2; Using cached https://files.pythonhosted.org/packages/c1/de/2efee1b7f6cadd45426ef7b0759cdc3e522672a509d1c75bb317cc4be6cb/qutip-4.0.2.tar.gz; Complete output from command python setup.py egg_info:; ; Error compiling Cython file:; ------------------------------------------------------------; ...; ; DTYPE = np.float64; ^; ------------------------------------------------------------; ; qutip/cy/parameters.pxi:2:10: cimported module has no attribute 'float64'; ; Error compiling Cython file:; ------------------------------------------------------------; ...; ; DTYPE = np.float64; ctypedef np.float64_t DTYPE_t; ; ITYPE = np.int32; ^; ------------------------------------------------------------; ; qutip/cy/parameters.pxi:5:10: cimported module has no attribute 'int32'; ; Error compiling Cython file:; ------------------------------------------------------------; ...; ctypedef np.float64_t DTYPE_t; ; ITYPE = np.int32; ctypedef np.int32_t ITYPE_t; ; CTYPE = np.complex128; ^; ------------------------------------------------------------; ; qutip/cy/parameters.pxi:8:10: cimported module has no attribute 'complex128'; ; Error compiling Cython file:; ------------------------------------------------------------; ...; ctypedef np.int32_t ITYPE_t; ; CTYPE = np.complex128; ctypedef np.complex128_t CTYPE_t; ; CTYPE = np.int64; ^; ------------------------------------------------------------; ; qutip/cy/parameters.pxi:11:10: cimported module has no attribute 'int64'; ```; Thank you very much.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/911
https://github.com/qutip/qutip/issues/911:245,Availability,error,error,245,I try to `pip install qutip==4.0.2` (all the latest versions cannot be installed and have even more complicated error). The error seems to be easier to diagnosed. But I still cannot find out which part goes wrong and why the error happened. The error is:; ```; Collecting qutip==4.0.2; Using cached https://files.pythonhosted.org/packages/c1/de/2efee1b7f6cadd45426ef7b0759cdc3e522672a509d1c75bb317cc4be6cb/qutip-4.0.2.tar.gz; Complete output from command python setup.py egg_info:; ; Error compiling Cython file:; ------------------------------------------------------------; ...; ; DTYPE = np.float64; ^; ------------------------------------------------------------; ; qutip/cy/parameters.pxi:2:10: cimported module has no attribute 'float64'; ; Error compiling Cython file:; ------------------------------------------------------------; ...; ; DTYPE = np.float64; ctypedef np.float64_t DTYPE_t; ; ITYPE = np.int32; ^; ------------------------------------------------------------; ; qutip/cy/parameters.pxi:5:10: cimported module has no attribute 'int32'; ; Error compiling Cython file:; ------------------------------------------------------------; ...; ctypedef np.float64_t DTYPE_t; ; ITYPE = np.int32; ctypedef np.int32_t ITYPE_t; ; CTYPE = np.complex128; ^; ------------------------------------------------------------; ; qutip/cy/parameters.pxi:8:10: cimported module has no attribute 'complex128'; ; Error compiling Cython file:; ------------------------------------------------------------; ...; ctypedef np.int32_t ITYPE_t; ; CTYPE = np.complex128; ctypedef np.complex128_t CTYPE_t; ; CTYPE = np.int64; ^; ------------------------------------------------------------; ; qutip/cy/parameters.pxi:11:10: cimported module has no attribute 'int64'; ```; Thank you very much.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/911
https://github.com/qutip/qutip/issues/911:484,Availability,Error,Error,484,I try to `pip install qutip==4.0.2` (all the latest versions cannot be installed and have even more complicated error). The error seems to be easier to diagnosed. But I still cannot find out which part goes wrong and why the error happened. The error is:; ```; Collecting qutip==4.0.2; Using cached https://files.pythonhosted.org/packages/c1/de/2efee1b7f6cadd45426ef7b0759cdc3e522672a509d1c75bb317cc4be6cb/qutip-4.0.2.tar.gz; Complete output from command python setup.py egg_info:; ; Error compiling Cython file:; ------------------------------------------------------------; ...; ; DTYPE = np.float64; ^; ------------------------------------------------------------; ; qutip/cy/parameters.pxi:2:10: cimported module has no attribute 'float64'; ; Error compiling Cython file:; ------------------------------------------------------------; ...; ; DTYPE = np.float64; ctypedef np.float64_t DTYPE_t; ; ITYPE = np.int32; ^; ------------------------------------------------------------; ; qutip/cy/parameters.pxi:5:10: cimported module has no attribute 'int32'; ; Error compiling Cython file:; ------------------------------------------------------------; ...; ctypedef np.float64_t DTYPE_t; ; ITYPE = np.int32; ctypedef np.int32_t ITYPE_t; ; CTYPE = np.complex128; ^; ------------------------------------------------------------; ; qutip/cy/parameters.pxi:8:10: cimported module has no attribute 'complex128'; ; Error compiling Cython file:; ------------------------------------------------------------; ...; ctypedef np.int32_t ITYPE_t; ; CTYPE = np.complex128; ctypedef np.complex128_t CTYPE_t; ; CTYPE = np.int64; ^; ------------------------------------------------------------; ; qutip/cy/parameters.pxi:11:10: cimported module has no attribute 'int64'; ```; Thank you very much.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/911
https://github.com/qutip/qutip/issues/911:747,Availability,Error,Error,747,I try to `pip install qutip==4.0.2` (all the latest versions cannot be installed and have even more complicated error). The error seems to be easier to diagnosed. But I still cannot find out which part goes wrong and why the error happened. The error is:; ```; Collecting qutip==4.0.2; Using cached https://files.pythonhosted.org/packages/c1/de/2efee1b7f6cadd45426ef7b0759cdc3e522672a509d1c75bb317cc4be6cb/qutip-4.0.2.tar.gz; Complete output from command python setup.py egg_info:; ; Error compiling Cython file:; ------------------------------------------------------------; ...; ; DTYPE = np.float64; ^; ------------------------------------------------------------; ; qutip/cy/parameters.pxi:2:10: cimported module has no attribute 'float64'; ; Error compiling Cython file:; ------------------------------------------------------------; ...; ; DTYPE = np.float64; ctypedef np.float64_t DTYPE_t; ; ITYPE = np.int32; ^; ------------------------------------------------------------; ; qutip/cy/parameters.pxi:5:10: cimported module has no attribute 'int32'; ; Error compiling Cython file:; ------------------------------------------------------------; ...; ctypedef np.float64_t DTYPE_t; ; ITYPE = np.int32; ctypedef np.int32_t ITYPE_t; ; CTYPE = np.complex128; ^; ------------------------------------------------------------; ; qutip/cy/parameters.pxi:8:10: cimported module has no attribute 'complex128'; ; Error compiling Cython file:; ------------------------------------------------------------; ...; ctypedef np.int32_t ITYPE_t; ; CTYPE = np.complex128; ctypedef np.complex128_t CTYPE_t; ; CTYPE = np.int64; ^; ------------------------------------------------------------; ; qutip/cy/parameters.pxi:11:10: cimported module has no attribute 'int64'; ```; Thank you very much.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/911
https://github.com/qutip/qutip/issues/911:1059,Availability,Error,Error,1059,I try to `pip install qutip==4.0.2` (all the latest versions cannot be installed and have even more complicated error). The error seems to be easier to diagnosed. But I still cannot find out which part goes wrong and why the error happened. The error is:; ```; Collecting qutip==4.0.2; Using cached https://files.pythonhosted.org/packages/c1/de/2efee1b7f6cadd45426ef7b0759cdc3e522672a509d1c75bb317cc4be6cb/qutip-4.0.2.tar.gz; Complete output from command python setup.py egg_info:; ; Error compiling Cython file:; ------------------------------------------------------------; ...; ; DTYPE = np.float64; ^; ------------------------------------------------------------; ; qutip/cy/parameters.pxi:2:10: cimported module has no attribute 'float64'; ; Error compiling Cython file:; ------------------------------------------------------------; ...; ; DTYPE = np.float64; ctypedef np.float64_t DTYPE_t; ; ITYPE = np.int32; ^; ------------------------------------------------------------; ; qutip/cy/parameters.pxi:5:10: cimported module has no attribute 'int32'; ; Error compiling Cython file:; ------------------------------------------------------------; ...; ctypedef np.float64_t DTYPE_t; ; ITYPE = np.int32; ctypedef np.int32_t ITYPE_t; ; CTYPE = np.complex128; ^; ------------------------------------------------------------; ; qutip/cy/parameters.pxi:8:10: cimported module has no attribute 'complex128'; ; Error compiling Cython file:; ------------------------------------------------------------; ...; ctypedef np.int32_t ITYPE_t; ; CTYPE = np.complex128; ctypedef np.complex128_t CTYPE_t; ; CTYPE = np.int64; ^; ------------------------------------------------------------; ; qutip/cy/parameters.pxi:11:10: cimported module has no attribute 'int64'; ```; Thank you very much.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/911
https://github.com/qutip/qutip/issues/911:1408,Availability,Error,Error,1408,I try to `pip install qutip==4.0.2` (all the latest versions cannot be installed and have even more complicated error). The error seems to be easier to diagnosed. But I still cannot find out which part goes wrong and why the error happened. The error is:; ```; Collecting qutip==4.0.2; Using cached https://files.pythonhosted.org/packages/c1/de/2efee1b7f6cadd45426ef7b0759cdc3e522672a509d1c75bb317cc4be6cb/qutip-4.0.2.tar.gz; Complete output from command python setup.py egg_info:; ; Error compiling Cython file:; ------------------------------------------------------------; ...; ; DTYPE = np.float64; ^; ------------------------------------------------------------; ; qutip/cy/parameters.pxi:2:10: cimported module has no attribute 'float64'; ; Error compiling Cython file:; ------------------------------------------------------------; ...; ; DTYPE = np.float64; ctypedef np.float64_t DTYPE_t; ; ITYPE = np.int32; ^; ------------------------------------------------------------; ; qutip/cy/parameters.pxi:5:10: cimported module has no attribute 'int32'; ; Error compiling Cython file:; ------------------------------------------------------------; ...; ctypedef np.float64_t DTYPE_t; ; ITYPE = np.int32; ctypedef np.int32_t ITYPE_t; ; CTYPE = np.complex128; ^; ------------------------------------------------------------; ; qutip/cy/parameters.pxi:8:10: cimported module has no attribute 'complex128'; ; Error compiling Cython file:; ------------------------------------------------------------; ...; ctypedef np.int32_t ITYPE_t; ; CTYPE = np.complex128; ctypedef np.complex128_t CTYPE_t; ; CTYPE = np.int64; ^; ------------------------------------------------------------; ; qutip/cy/parameters.pxi:11:10: cimported module has no attribute 'int64'; ```; Thank you very much.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/911
https://github.com/qutip/qutip/issues/911:14,Deployability,install,install,14,I try to `pip install qutip==4.0.2` (all the latest versions cannot be installed and have even more complicated error). The error seems to be easier to diagnosed. But I still cannot find out which part goes wrong and why the error happened. The error is:; ```; Collecting qutip==4.0.2; Using cached https://files.pythonhosted.org/packages/c1/de/2efee1b7f6cadd45426ef7b0759cdc3e522672a509d1c75bb317cc4be6cb/qutip-4.0.2.tar.gz; Complete output from command python setup.py egg_info:; ; Error compiling Cython file:; ------------------------------------------------------------; ...; ; DTYPE = np.float64; ^; ------------------------------------------------------------; ; qutip/cy/parameters.pxi:2:10: cimported module has no attribute 'float64'; ; Error compiling Cython file:; ------------------------------------------------------------; ...; ; DTYPE = np.float64; ctypedef np.float64_t DTYPE_t; ; ITYPE = np.int32; ^; ------------------------------------------------------------; ; qutip/cy/parameters.pxi:5:10: cimported module has no attribute 'int32'; ; Error compiling Cython file:; ------------------------------------------------------------; ...; ctypedef np.float64_t DTYPE_t; ; ITYPE = np.int32; ctypedef np.int32_t ITYPE_t; ; CTYPE = np.complex128; ^; ------------------------------------------------------------; ; qutip/cy/parameters.pxi:8:10: cimported module has no attribute 'complex128'; ; Error compiling Cython file:; ------------------------------------------------------------; ...; ctypedef np.int32_t ITYPE_t; ; CTYPE = np.complex128; ctypedef np.complex128_t CTYPE_t; ; CTYPE = np.int64; ^; ------------------------------------------------------------; ; qutip/cy/parameters.pxi:11:10: cimported module has no attribute 'int64'; ```; Thank you very much.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/911
https://github.com/qutip/qutip/issues/911:71,Deployability,install,installed,71,I try to `pip install qutip==4.0.2` (all the latest versions cannot be installed and have even more complicated error). The error seems to be easier to diagnosed. But I still cannot find out which part goes wrong and why the error happened. The error is:; ```; Collecting qutip==4.0.2; Using cached https://files.pythonhosted.org/packages/c1/de/2efee1b7f6cadd45426ef7b0759cdc3e522672a509d1c75bb317cc4be6cb/qutip-4.0.2.tar.gz; Complete output from command python setup.py egg_info:; ; Error compiling Cython file:; ------------------------------------------------------------; ...; ; DTYPE = np.float64; ^; ------------------------------------------------------------; ; qutip/cy/parameters.pxi:2:10: cimported module has no attribute 'float64'; ; Error compiling Cython file:; ------------------------------------------------------------; ...; ; DTYPE = np.float64; ctypedef np.float64_t DTYPE_t; ; ITYPE = np.int32; ^; ------------------------------------------------------------; ; qutip/cy/parameters.pxi:5:10: cimported module has no attribute 'int32'; ; Error compiling Cython file:; ------------------------------------------------------------; ...; ctypedef np.float64_t DTYPE_t; ; ITYPE = np.int32; ctypedef np.int32_t ITYPE_t; ; CTYPE = np.complex128; ^; ------------------------------------------------------------; ; qutip/cy/parameters.pxi:8:10: cimported module has no attribute 'complex128'; ; Error compiling Cython file:; ------------------------------------------------------------; ...; ctypedef np.int32_t ITYPE_t; ; CTYPE = np.complex128; ctypedef np.complex128_t CTYPE_t; ; CTYPE = np.int64; ^; ------------------------------------------------------------; ; qutip/cy/parameters.pxi:11:10: cimported module has no attribute 'int64'; ```; Thank you very much.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/911
https://github.com/qutip/qutip/issues/911:292,Performance,cache,cached,292,I try to `pip install qutip==4.0.2` (all the latest versions cannot be installed and have even more complicated error). The error seems to be easier to diagnosed. But I still cannot find out which part goes wrong and why the error happened. The error is:; ```; Collecting qutip==4.0.2; Using cached https://files.pythonhosted.org/packages/c1/de/2efee1b7f6cadd45426ef7b0759cdc3e522672a509d1c75bb317cc4be6cb/qutip-4.0.2.tar.gz; Complete output from command python setup.py egg_info:; ; Error compiling Cython file:; ------------------------------------------------------------; ...; ; DTYPE = np.float64; ^; ------------------------------------------------------------; ; qutip/cy/parameters.pxi:2:10: cimported module has no attribute 'float64'; ; Error compiling Cython file:; ------------------------------------------------------------; ...; ; DTYPE = np.float64; ctypedef np.float64_t DTYPE_t; ; ITYPE = np.int32; ^; ------------------------------------------------------------; ; qutip/cy/parameters.pxi:5:10: cimported module has no attribute 'int32'; ; Error compiling Cython file:; ------------------------------------------------------------; ...; ctypedef np.float64_t DTYPE_t; ; ITYPE = np.int32; ctypedef np.int32_t ITYPE_t; ; CTYPE = np.complex128; ^; ------------------------------------------------------------; ; qutip/cy/parameters.pxi:8:10: cimported module has no attribute 'complex128'; ; Error compiling Cython file:; ------------------------------------------------------------; ...; ctypedef np.int32_t ITYPE_t; ; CTYPE = np.complex128; ctypedef np.complex128_t CTYPE_t; ; CTYPE = np.int64; ^; ------------------------------------------------------------; ; qutip/cy/parameters.pxi:11:10: cimported module has no attribute 'int64'; ```; Thank you very much.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/911
https://github.com/qutip/qutip/issues/913:460,Security,access,access,460,"I'm quite new to the package, so please forgive me if this is obvious. Haven't been able to find anything in docs or previous issues. I'm looking to get images of quantum circuits saved. My quirks of setup means that I'm not using notebooks. Therefore the normal `qc.png` command isn't compatible. . In `qutip/qip/circuit.py`, the properties `png()` and `svg()` directly display in a notebook the compiled LaTeX figure of the cicuit. I would rather be able to access the compiled image directly. I've been looking around the codebase to see if there is native functionality for this. We can get Bloch spheres using the kind of workflow I'm imagining:. ```; from qutip import * . b = Bloch(). b.show(). bb = b.fig; bb.savefig('Bloch.png'); bb.savefig('Bloch.pdf'); ```. Does anyone have any suggestions? . I think that `_latex_compile()` returns a bytes object, which can be interpreted as an image, but I haven't had a chance to play around with it yet.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/913
https://github.com/qutip/qutip/pull/915:233,Availability,down,down,233,I noticed that stochastic._rhs_psi_platen wasn't working so I fixed it. Now ssesolve can be used with the platen solver for multiple stochastic collapse operators with both homodyne and heterodyne methods. . Basically I have written down equation 1.3 from chapter 15.1 of Numerical solution of stochastic differential equations by Kloeden and Platen.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/915
https://github.com/qutip/qutip/issues/916:794,Deployability,update,update,794,"I get the following warnings when importing qutip:. ```; /usr/local/Cellar/python/3.7.0/Frameworks/Python.framework/Versions/3.7/lib/python3.7/subprocess.py:839: ResourceWarning: subprocess 606 is still running; ResourceWarning, source=self); /usr/local/lib/python3.7/site-packages/qutip/hardware_info.py:44: ResourceWarning: unclosed file <_io.TextIOWrapper name=3 encoding='UTF-8'>; for l in [l.split(':') for l in os.popen('sysctl hw').readlines()[1:]]:; /usr/local/Cellar/python/3.7.0/Frameworks/Python.framework/Versions/3.7/lib/python3.7/subprocess.py:839: ResourceWarning: subprocess 607 is still running; ResourceWarning, source=self); /usr/local/lib/python3.7/site-packages/qutip/hardware_info.py:48: ResourceWarning: unclosed file <_io.TextIOWrapper name=3 encoding='UTF-8'>; results.update({'cpu_freq': int(float(os.popen('sysctl -n machdep.cpu.brand_string'); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/916
https://github.com/qutip/qutip/issues/918:94,Availability,error,error,94,How to find eigenvalues of Hamiltonian from eigenenergies( ) command.For Hamiltonian it gives error 'list' object has no attribute 'eigenenergies''; I am using Hamiltonian ; H = wc * a.dag() * a + wm * bv.dag() * bv+ wv * bm.dag() * bm + g * (a.dag() * bv + bv.dag()* a)-g * (a.dag() * bm + bm .dag()*a) ; command is like H.eigenenergies( ),MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/918
https://github.com/qutip/qutip/issues/919:154,Deployability,install,installation,154,"It seems the new macOS can not compile QuTiP, it can not find `<complex>`. The headers do present in `/usr/include` (however it required a header package installation on the new macOS)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/919
https://github.com/qutip/qutip/issues/920:248,Availability,error,errors,248,"Hard-coding compiler flag `-march=native` in setup.py completely destroys possibility to set up Qutip on heterogeneous cluster. In general, it brings a lot of problems for people that don't have a good experience in debugging ""illegal instruction"" errors, that often happen, if you compile the module on different machine than you use. If you are sure you need optimized build for localhost, you might use; ```; export CFLAGS=""-O3 -march=native""; export CXXFLAGS=""$CFLAGS""; pip install qutip; ```; instead or provide separate option for setup.py script.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/920
https://github.com/qutip/qutip/issues/920:478,Deployability,install,install,478,"Hard-coding compiler flag `-march=native` in setup.py completely destroys possibility to set up Qutip on heterogeneous cluster. In general, it brings a lot of problems for people that don't have a good experience in debugging ""illegal instruction"" errors, that often happen, if you compile the module on different machine than you use. If you are sure you need optimized build for localhost, you might use; ```; export CFLAGS=""-O3 -march=native""; export CXXFLAGS=""$CFLAGS""; pip install qutip; ```; instead or provide separate option for setup.py script.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/920
https://github.com/qutip/qutip/issues/920:361,Performance,optimiz,optimized,361,"Hard-coding compiler flag `-march=native` in setup.py completely destroys possibility to set up Qutip on heterogeneous cluster. In general, it brings a lot of problems for people that don't have a good experience in debugging ""illegal instruction"" errors, that often happen, if you compile the module on different machine than you use. If you are sure you need optimized build for localhost, you might use; ```; export CFLAGS=""-O3 -march=native""; export CXXFLAGS=""$CFLAGS""; pip install qutip; ```; instead or provide separate option for setup.py script.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/920
https://github.com/qutip/qutip/pull/922:11,Deployability,install,installations,11,This fixes installations on OSX 10.14. fixes #919,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/922
https://github.com/qutip/qutip/pull/923:116,Testability,test,test,116,- Remove Python 2.7 (probably good to drop support at this stage); - Bumped Python version numbers up.; - Added OSX test.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/923
https://github.com/qutip/qutip/pull/924:5,Deployability,update,updates,5,This updates the Travis build process. It is for Py3 only.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/924
https://github.com/qutip/qutip/issues/926:187,Deployability,update,update,187,"Simulating the stochastic master equation, I got confused since `dW_factors` are used to; compute the measured value, e.g. `_smesolve_single_trajectory` in stochastic.py,; but not in the update of density matrix, e.g. `_rhs_rho_euler_maruyama` in stochastic.py. If it is not a bug, how shall I set the value?; Shall I understand as a fixed quantity as in this [tutorial](http://nbviewer.jupyter.org/github/qutip/qutip-notebooks/blob/master/examples/smesolve-heterodyne.ipynb), ; or is it a free parameter?. Thanks in advance!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/926
https://github.com/qutip/qutip/pull/927:255,Safety,detect,detected,255,"With cython0.29 that came out this weeks there where warning at ""cythonization"" about language_level. Complied with it by adding `#cython: language_level=3` at the start of every .pyx and .pxd. Also rename the cy/*testing* files to cy/*checks* since nose detected them as tests to run which caused automated tests to fail.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/927
https://github.com/qutip/qutip/pull/927:214,Testability,test,testing,214,"With cython0.29 that came out this weeks there where warning at ""cythonization"" about language_level. Complied with it by adding `#cython: language_level=3` at the start of every .pyx and .pxd. Also rename the cy/*testing* files to cy/*checks* since nose detected them as tests to run which caused automated tests to fail.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/927
https://github.com/qutip/qutip/pull/927:272,Testability,test,tests,272,"With cython0.29 that came out this weeks there where warning at ""cythonization"" about language_level. Complied with it by adding `#cython: language_level=3` at the start of every .pyx and .pxd. Also rename the cy/*testing* files to cy/*checks* since nose detected them as tests to run which caused automated tests to fail.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/927
https://github.com/qutip/qutip/pull/927:308,Testability,test,tests,308,"With cython0.29 that came out this weeks there where warning at ""cythonization"" about language_level. Complied with it by adding `#cython: language_level=3` at the start of every .pyx and .pxd. Also rename the cy/*testing* files to cy/*checks* since nose detected them as tests to run which caused automated tests to fail.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/927
https://github.com/qutip/qutip/pull/930:83,Integrability,depend,dependent,83,"Dear ladies and gentlemen,; Is it possible to calculate expactation values of time-dependent operators (using, for example, mesolve)?; I do not know how to evaluate <psi | O(t) | psi>, where O(t) is time-dependent and psi is the solution of the Schroedinger equation.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/930
https://github.com/qutip/qutip/pull/930:204,Integrability,depend,dependent,204,"Dear ladies and gentlemen,; Is it possible to calculate expactation values of time-dependent operators (using, for example, mesolve)?; I do not know how to evaluate <psi | O(t) | psi>, where O(t) is time-dependent and psi is the solution of the Schroedinger equation.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/930
https://github.com/qutip/qutip/issues/931:83,Integrability,depend,dependent,83,"Dear ladies and gentlemen,; Is it possible to calculate expactation values of time-dependent operators (using, for example, mesolve)?; I do not know how to evaluate <psi | O(t) | psi>, where O(t) is time-dependent and psi is the solution of the Schroedinger equation.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/931
https://github.com/qutip/qutip/issues/931:204,Integrability,depend,dependent,204,"Dear ladies and gentlemen,; Is it possible to calculate expactation values of time-dependent operators (using, for example, mesolve)?; I do not know how to evaluate <psi | O(t) | psi>, where O(t) is time-dependent and psi is the solution of the Schroedinger equation.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/931
https://github.com/qutip/qutip/issues/932:2960,Deployability,release,release,2960,"/bin/clang' failed with exit status 1` on Python 3.5. It works fine if I don't to the conversion from the function to the array. The Cython program that is being generated and that fails to compile is this:; ~~~; # This file is generated automatically by QuTiP.; # (C) 2011 and later, QuSTaR. import numpy as np; cimport numpy as np; cimport cython; np.import_array(); cdef extern from ""numpy/arrayobject.h"" nogil:; void PyDataMem_NEW_ZEROED(size_t size, size_t elsize); void PyArray_ENABLEFLAGS(np.ndarray arr, int flags). from qutip.cy.spmatfuncs cimport spmvpy; from qutip.cy.interpolate cimport interp, zinterp; from qutip.cy.math cimport erf; cdef double pi = 3.14159265358979323. include '/Users/goerz/Documents/Programming/github/krotov/.venv/py36/lib/python3.6/site-packages/qutip/cy/complex_math.pxi'. @cython.cdivision(True); @cython.boundscheck(False); @cython.wraparound(False); def cy_td_ode_rhs(; double t,; complex[::1] vec,; complex[::1] data0,int[::1] idx0,int[::1] ptr0,; complex[::1] data1,int[::1] idx1,int[::1] ptr1,; np.ndarray[np.float64_t, ndim=1] _td_array_0):; ; cdef size_t row; cdef unsigned int num_rows = vec.shape[0]; cdef double complex * out = <complex *>PyDataMem_NEW_ZEROED(num_rows,sizeof(complex)); ; spmvpy(&data0[0], &idx0[0], &ptr0[0], &vec[0], 1.0, out, num_rows); spmvpy(&data1[0], &idx1[0], &ptr1[0], &vec[0], (0 if (t > 10.000000) else _td_array_0[int(round(999 * (t/10.000000)))]), out, num_rows); cdef np.npy_intp dims = num_rows; cdef np.ndarray[complex, ndim=1, mode='c'] arr_out = np.PyArray_SimpleNewFromData(1, &dims, np.NPY_COMPLEX128, out); PyArray_ENABLEFLAGS(arr_out, np.NPY_OWNDATA); return arr_out ; ~~~. Program versions are; ~~~; CPython 3.6.7; IPython 7.1.1. qutip 4.3.1; numpy 1.15.4; scipy 1.1.0; cython 0.29. compiler : GCC 4.2.1 Compatible Clang 4.0.1 (tags/RELEASE_401/final); system : Darwin; release : 18.0.0; machine : x86_64; processor : i386; CPU cores : 4; interpreter: 64bit; ~~~; I also tried this with Python 3.5 and qutip 4.2",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/932
https://github.com/qutip/qutip/issues/932:534,Energy Efficiency,energy,energy,534,"Code to reproduce:. ~~~; import qutip; import numpy as np; import scipy. def transmon_ham_and_states(Ec=0.386, EjEc=45, nstates=8, ng=0.0, T=10.0):; """"""Transmon Hamiltonian""""""; Ej = EjEc * Ec; n = np.arange(-nstates, nstates+1); up = np.diag(np.ones(2*nstates),k=-1); do = up.T; H0 = qutip.Qobj(np.diag(4*Ec*(n - ng)**2) - Ej*(up+do)/2.0); H1 = qutip.Qobj(-2*np.diag(n)). eigenvals, eigenvecs = scipy.linalg.eig(H0.full()); ndx = np.argsort(eigenvals.real); E = eigenvals[ndx].real; V = eigenvecs[:,ndx]; w01 = E[1]-E[0] # Transition energy between states. psi0 = qutip.Qobj(V[:, 0]); psi1 = qutip.Qobj(V[:, 1]) . profile = lambda t: np.exp(-40.0*(t/T - 0.5)**2); eps0 = lambda t, args: 0.5 * profile(t) * np.cos(8*np.pi*w01*t); return ([H0, [H1, eps0]], psi0, psi1). H, psi0, psi1 = transmon_ham_and_states(). tlist = np.linspace(0, 10, 1000). # convert function to array; H[1][1] = np.array([H[1][1](t, None) for t in tlist]). result = qutip.mesolve(H, psi0, tlist=tlist); ~~~. This crashes with a `CompileError: command 'gcc' failed with exit status 1` on Python 3.6 or `CompileError: command '/usr/bin/clang' failed with exit status 1` on Python 3.5. It works fine if I don't to the conversion from the function to the array. The Cython program that is being generated and that fails to compile is this:; ~~~; # This file is generated automatically by QuTiP.; # (C) 2011 and later, QuSTaR. import numpy as np; cimport numpy as np; cimport cython; np.import_array(); cdef extern from ""numpy/arrayobject.h"" nogil:; void PyDataMem_NEW_ZEROED(size_t size, size_t elsize); void PyArray_ENABLEFLAGS(np.ndarray arr, int flags). from qutip.cy.spmatfuncs cimport spmvpy; from qutip.cy.interpolate cimport interp, zinterp; from qutip.cy.math cimport erf; cdef double pi = 3.14159265358979323. include '/Users/goerz/Documents/Programming/github/krotov/.venv/py36/lib/python3.6/site-packages/qutip/cy/complex_math.pxi'. @cython.cdivision(True); @cython.boundscheck(False); @cython.wraparound(False); def cy_td",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/932
https://github.com/qutip/qutip/issues/932:1973,Integrability,wrap,wraparound,1973," Python 3.6 or `CompileError: command '/usr/bin/clang' failed with exit status 1` on Python 3.5. It works fine if I don't to the conversion from the function to the array. The Cython program that is being generated and that fails to compile is this:; ~~~; # This file is generated automatically by QuTiP.; # (C) 2011 and later, QuSTaR. import numpy as np; cimport numpy as np; cimport cython; np.import_array(); cdef extern from ""numpy/arrayobject.h"" nogil:; void PyDataMem_NEW_ZEROED(size_t size, size_t elsize); void PyArray_ENABLEFLAGS(np.ndarray arr, int flags). from qutip.cy.spmatfuncs cimport spmvpy; from qutip.cy.interpolate cimport interp, zinterp; from qutip.cy.math cimport erf; cdef double pi = 3.14159265358979323. include '/Users/goerz/Documents/Programming/github/krotov/.venv/py36/lib/python3.6/site-packages/qutip/cy/complex_math.pxi'. @cython.cdivision(True); @cython.boundscheck(False); @cython.wraparound(False); def cy_td_ode_rhs(; double t,; complex[::1] vec,; complex[::1] data0,int[::1] idx0,int[::1] ptr0,; complex[::1] data1,int[::1] idx1,int[::1] ptr1,; np.ndarray[np.float64_t, ndim=1] _td_array_0):; ; cdef size_t row; cdef unsigned int num_rows = vec.shape[0]; cdef double complex * out = <complex *>PyDataMem_NEW_ZEROED(num_rows,sizeof(complex)); ; spmvpy(&data0[0], &idx0[0], &ptr0[0], &vec[0], 1.0, out, num_rows); spmvpy(&data1[0], &idx1[0], &ptr1[0], &vec[0], (0 if (t > 10.000000) else _td_array_0[int(round(999 * (t/10.000000)))]), out, num_rows); cdef np.npy_intp dims = num_rows; cdef np.ndarray[complex, ndim=1, mode='c'] arr_out = np.PyArray_SimpleNewFromData(1, &dims, np.NPY_COMPLEX128, out); PyArray_ENABLEFLAGS(arr_out, np.NPY_OWNDATA); return arr_out ; ~~~. Program versions are; ~~~; CPython 3.6.7; IPython 7.1.1. qutip 4.3.1; numpy 1.15.4; scipy 1.1.0; cython 0.29. compiler : GCC 4.2.1 Compatible Clang 4.0.1 (tags/RELEASE_401/final); system : Darwin; release : 18.0.0; machine : x86_64; processor : i386; CPU cores : 4; interpreter: 64bit; ~~~; I al",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/932
https://github.com/qutip/qutip/issues/933:152,Deployability,install,installation,152,"It seems that over the last year, nearly all packages in the scientific Python ecosystem have started to provide wheels. This is great news, as it make installation on platforms that don't have the necessary compilers installed very easy, and it's also extremely fast. So far, `conda` has been the only realistic option to install qutip outside of Linux development workstation, and it's not without caveats (https://github.com/qutip/qutip/issues/674). Conda has also been getting extremely slow; (https://github.com/conda/conda/issues/7239), which causes problem with continuous integration services or readthedocs (together with the fact that setting up conda on these services isn't entirely trivial, and, for readthedocs, buggy: https://github.com/rtfd/readthedocs.org/issues/3925, https://github.com/rtfd/readthedocs.org/issues/3829). If qutip were to provide wheels, this might alleviate all of these problems. Depending on how complicated the process is compared compared to a conda package, it might then even be ok to drop conda support.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/933
https://github.com/qutip/qutip/issues/933:218,Deployability,install,installed,218,"It seems that over the last year, nearly all packages in the scientific Python ecosystem have started to provide wheels. This is great news, as it make installation on platforms that don't have the necessary compilers installed very easy, and it's also extremely fast. So far, `conda` has been the only realistic option to install qutip outside of Linux development workstation, and it's not without caveats (https://github.com/qutip/qutip/issues/674). Conda has also been getting extremely slow; (https://github.com/conda/conda/issues/7239), which causes problem with continuous integration services or readthedocs (together with the fact that setting up conda on these services isn't entirely trivial, and, for readthedocs, buggy: https://github.com/rtfd/readthedocs.org/issues/3925, https://github.com/rtfd/readthedocs.org/issues/3829). If qutip were to provide wheels, this might alleviate all of these problems. Depending on how complicated the process is compared compared to a conda package, it might then even be ok to drop conda support.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/933
https://github.com/qutip/qutip/issues/933:323,Deployability,install,install,323,"It seems that over the last year, nearly all packages in the scientific Python ecosystem have started to provide wheels. This is great news, as it make installation on platforms that don't have the necessary compilers installed very easy, and it's also extremely fast. So far, `conda` has been the only realistic option to install qutip outside of Linux development workstation, and it's not without caveats (https://github.com/qutip/qutip/issues/674). Conda has also been getting extremely slow; (https://github.com/conda/conda/issues/7239), which causes problem with continuous integration services or readthedocs (together with the fact that setting up conda on these services isn't entirely trivial, and, for readthedocs, buggy: https://github.com/rtfd/readthedocs.org/issues/3925, https://github.com/rtfd/readthedocs.org/issues/3829). If qutip were to provide wheels, this might alleviate all of these problems. Depending on how complicated the process is compared compared to a conda package, it might then even be ok to drop conda support.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/933
https://github.com/qutip/qutip/issues/933:569,Deployability,continuous,continuous,569,"It seems that over the last year, nearly all packages in the scientific Python ecosystem have started to provide wheels. This is great news, as it make installation on platforms that don't have the necessary compilers installed very easy, and it's also extremely fast. So far, `conda` has been the only realistic option to install qutip outside of Linux development workstation, and it's not without caveats (https://github.com/qutip/qutip/issues/674). Conda has also been getting extremely slow; (https://github.com/conda/conda/issues/7239), which causes problem with continuous integration services or readthedocs (together with the fact that setting up conda on these services isn't entirely trivial, and, for readthedocs, buggy: https://github.com/rtfd/readthedocs.org/issues/3925, https://github.com/rtfd/readthedocs.org/issues/3829). If qutip were to provide wheels, this might alleviate all of these problems. Depending on how complicated the process is compared compared to a conda package, it might then even be ok to drop conda support.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/933
https://github.com/qutip/qutip/issues/933:580,Deployability,integrat,integration,580,"It seems that over the last year, nearly all packages in the scientific Python ecosystem have started to provide wheels. This is great news, as it make installation on platforms that don't have the necessary compilers installed very easy, and it's also extremely fast. So far, `conda` has been the only realistic option to install qutip outside of Linux development workstation, and it's not without caveats (https://github.com/qutip/qutip/issues/674). Conda has also been getting extremely slow; (https://github.com/conda/conda/issues/7239), which causes problem with continuous integration services or readthedocs (together with the fact that setting up conda on these services isn't entirely trivial, and, for readthedocs, buggy: https://github.com/rtfd/readthedocs.org/issues/3925, https://github.com/rtfd/readthedocs.org/issues/3829). If qutip were to provide wheels, this might alleviate all of these problems. Depending on how complicated the process is compared compared to a conda package, it might then even be ok to drop conda support.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/933
https://github.com/qutip/qutip/issues/933:580,Integrability,integrat,integration,580,"It seems that over the last year, nearly all packages in the scientific Python ecosystem have started to provide wheels. This is great news, as it make installation on platforms that don't have the necessary compilers installed very easy, and it's also extremely fast. So far, `conda` has been the only realistic option to install qutip outside of Linux development workstation, and it's not without caveats (https://github.com/qutip/qutip/issues/674). Conda has also been getting extremely slow; (https://github.com/conda/conda/issues/7239), which causes problem with continuous integration services or readthedocs (together with the fact that setting up conda on these services isn't entirely trivial, and, for readthedocs, buggy: https://github.com/rtfd/readthedocs.org/issues/3925, https://github.com/rtfd/readthedocs.org/issues/3829). If qutip were to provide wheels, this might alleviate all of these problems. Depending on how complicated the process is compared compared to a conda package, it might then even be ok to drop conda support.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/933
https://github.com/qutip/qutip/issues/933:917,Integrability,Depend,Depending,917,"It seems that over the last year, nearly all packages in the scientific Python ecosystem have started to provide wheels. This is great news, as it make installation on platforms that don't have the necessary compilers installed very easy, and it's also extremely fast. So far, `conda` has been the only realistic option to install qutip outside of Linux development workstation, and it's not without caveats (https://github.com/qutip/qutip/issues/674). Conda has also been getting extremely slow; (https://github.com/conda/conda/issues/7239), which causes problem with continuous integration services or readthedocs (together with the fact that setting up conda on these services isn't entirely trivial, and, for readthedocs, buggy: https://github.com/rtfd/readthedocs.org/issues/3925, https://github.com/rtfd/readthedocs.org/issues/3829). If qutip were to provide wheels, this might alleviate all of these problems. Depending on how complicated the process is compared compared to a conda package, it might then even be ok to drop conda support.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/933
https://github.com/qutip/qutip/pull/934:52,Integrability,depend,depend,52,"A lot of the cost of the Husimi Q function does not depend on the state. If it is called many times (e.g. for a density matrix or when doing multiple states), this can be used for a speedup. I wrote a function to precompute everything that does not depend on the state and store it as a 3d array. The Q function itself is then a dot product between the last axis of the precomputed array and a pure state. Performance: Everything tested by computing Q of a coherent state with N dimensions, evaluated at 401 points in x and y, respectively.; Speedup is 3x for N=10, 4x for N=20, 7x for N=50. ; For density matrices, precomputing is already paid for by the first call. . Possible further changes:; Because precomputing is always worth it if the state is a density matrix, one could do that automatically. Because the memory cost can be large (len(xvec) * len(yvec) * N * 128 bit) , I still leave the decision to the user. The third if statement in _qfunc_pure can be avoided at a small performance cost in either the polyval or np.dot variant. This seemed the best compromise between performance and nice code.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/934
https://github.com/qutip/qutip/pull/934:249,Integrability,depend,depend,249,"A lot of the cost of the Husimi Q function does not depend on the state. If it is called many times (e.g. for a density matrix or when doing multiple states), this can be used for a speedup. I wrote a function to precompute everything that does not depend on the state and store it as a 3d array. The Q function itself is then a dot product between the last axis of the precomputed array and a pure state. Performance: Everything tested by computing Q of a coherent state with N dimensions, evaluated at 401 points in x and y, respectively.; Speedup is 3x for N=10, 4x for N=20, 7x for N=50. ; For density matrices, precomputing is already paid for by the first call. . Possible further changes:; Because precomputing is always worth it if the state is a density matrix, one could do that automatically. Because the memory cost can be large (len(xvec) * len(yvec) * N * 128 bit) , I still leave the decision to the user. The third if statement in _qfunc_pure can be avoided at a small performance cost in either the polyval or np.dot variant. This seemed the best compromise between performance and nice code.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/934
https://github.com/qutip/qutip/pull/934:406,Performance,Perform,Performance,406,"A lot of the cost of the Husimi Q function does not depend on the state. If it is called many times (e.g. for a density matrix or when doing multiple states), this can be used for a speedup. I wrote a function to precompute everything that does not depend on the state and store it as a 3d array. The Q function itself is then a dot product between the last axis of the precomputed array and a pure state. Performance: Everything tested by computing Q of a coherent state with N dimensions, evaluated at 401 points in x and y, respectively.; Speedup is 3x for N=10, 4x for N=20, 7x for N=50. ; For density matrices, precomputing is already paid for by the first call. . Possible further changes:; Because precomputing is always worth it if the state is a density matrix, one could do that automatically. Because the memory cost can be large (len(xvec) * len(yvec) * N * 128 bit) , I still leave the decision to the user. The third if statement in _qfunc_pure can be avoided at a small performance cost in either the polyval or np.dot variant. This seemed the best compromise between performance and nice code.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/934
https://github.com/qutip/qutip/pull/934:985,Performance,perform,performance,985,"A lot of the cost of the Husimi Q function does not depend on the state. If it is called many times (e.g. for a density matrix or when doing multiple states), this can be used for a speedup. I wrote a function to precompute everything that does not depend on the state and store it as a 3d array. The Q function itself is then a dot product between the last axis of the precomputed array and a pure state. Performance: Everything tested by computing Q of a coherent state with N dimensions, evaluated at 401 points in x and y, respectively.; Speedup is 3x for N=10, 4x for N=20, 7x for N=50. ; For density matrices, precomputing is already paid for by the first call. . Possible further changes:; Because precomputing is always worth it if the state is a density matrix, one could do that automatically. Because the memory cost can be large (len(xvec) * len(yvec) * N * 128 bit) , I still leave the decision to the user. The third if statement in _qfunc_pure can be avoided at a small performance cost in either the polyval or np.dot variant. This seemed the best compromise between performance and nice code.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/934
https://github.com/qutip/qutip/pull/934:1083,Performance,perform,performance,1083,"A lot of the cost of the Husimi Q function does not depend on the state. If it is called many times (e.g. for a density matrix or when doing multiple states), this can be used for a speedup. I wrote a function to precompute everything that does not depend on the state and store it as a 3d array. The Q function itself is then a dot product between the last axis of the precomputed array and a pure state. Performance: Everything tested by computing Q of a coherent state with N dimensions, evaluated at 401 points in x and y, respectively.; Speedup is 3x for N=10, 4x for N=20, 7x for N=50. ; For density matrices, precomputing is already paid for by the first call. . Possible further changes:; Because precomputing is always worth it if the state is a density matrix, one could do that automatically. Because the memory cost can be large (len(xvec) * len(yvec) * N * 128 bit) , I still leave the decision to the user. The third if statement in _qfunc_pure can be avoided at a small performance cost in either the polyval or np.dot variant. This seemed the best compromise between performance and nice code.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/934
https://github.com/qutip/qutip/pull/934:966,Safety,avoid,avoided,966,"A lot of the cost of the Husimi Q function does not depend on the state. If it is called many times (e.g. for a density matrix or when doing multiple states), this can be used for a speedup. I wrote a function to precompute everything that does not depend on the state and store it as a 3d array. The Q function itself is then a dot product between the last axis of the precomputed array and a pure state. Performance: Everything tested by computing Q of a coherent state with N dimensions, evaluated at 401 points in x and y, respectively.; Speedup is 3x for N=10, 4x for N=20, 7x for N=50. ; For density matrices, precomputing is already paid for by the first call. . Possible further changes:; Because precomputing is always worth it if the state is a density matrix, one could do that automatically. Because the memory cost can be large (len(xvec) * len(yvec) * N * 128 bit) , I still leave the decision to the user. The third if statement in _qfunc_pure can be avoided at a small performance cost in either the polyval or np.dot variant. This seemed the best compromise between performance and nice code.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/934
https://github.com/qutip/qutip/pull/934:430,Testability,test,tested,430,"A lot of the cost of the Husimi Q function does not depend on the state. If it is called many times (e.g. for a density matrix or when doing multiple states), this can be used for a speedup. I wrote a function to precompute everything that does not depend on the state and store it as a 3d array. The Q function itself is then a dot product between the last axis of the precomputed array and a pure state. Performance: Everything tested by computing Q of a coherent state with N dimensions, evaluated at 401 points in x and y, respectively.; Speedup is 3x for N=10, 4x for N=20, 7x for N=50. ; For density matrices, precomputing is already paid for by the first call. . Possible further changes:; Because precomputing is always worth it if the state is a density matrix, one could do that automatically. Because the memory cost can be large (len(xvec) * len(yvec) * N * 128 bit) , I still leave the decision to the user. The third if statement in _qfunc_pure can be avoided at a small performance cost in either the polyval or np.dot variant. This seemed the best compromise between performance and nice code.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/934
https://github.com/qutip/qutip/issues/937:62,Availability,down,down,62,"This is just FYI because I needed some time to track this one down, but I do not think it can be fixed in qutip (or scipy). A Bug in Intel MKL causes scipy.linalg.eig to break and return zeros if the matrix is too large. This in turn breaks wigner.qfunc if the state in question is a density matrix. Possibly related are issues ; https://github.com/scipy/scipy/issues/8713 and https://github.com/scipy/scipy/issues/8205. However the fix mentioned there does not solve the problem for me, so it might be unrelated. If you run into this error, the only workaround I know of is to link scipy and numpy to a different blas library, e.g. openblas. Note that anaconda on windows always uses MKL on intel machines, so you need to install either manually or with pip.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/937
https://github.com/qutip/qutip/issues/937:535,Availability,error,error,535,"This is just FYI because I needed some time to track this one down, but I do not think it can be fixed in qutip (or scipy). A Bug in Intel MKL causes scipy.linalg.eig to break and return zeros if the matrix is too large. This in turn breaks wigner.qfunc if the state in question is a density matrix. Possibly related are issues ; https://github.com/scipy/scipy/issues/8713 and https://github.com/scipy/scipy/issues/8205. However the fix mentioned there does not solve the problem for me, so it might be unrelated. If you run into this error, the only workaround I know of is to link scipy and numpy to a different blas library, e.g. openblas. Note that anaconda on windows always uses MKL on intel machines, so you need to install either manually or with pip.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/937
https://github.com/qutip/qutip/issues/937:723,Deployability,install,install,723,"This is just FYI because I needed some time to track this one down, but I do not think it can be fixed in qutip (or scipy). A Bug in Intel MKL causes scipy.linalg.eig to break and return zeros if the matrix is too large. This in turn breaks wigner.qfunc if the state in question is a density matrix. Possibly related are issues ; https://github.com/scipy/scipy/issues/8713 and https://github.com/scipy/scipy/issues/8205. However the fix mentioned there does not solve the problem for me, so it might be unrelated. If you run into this error, the only workaround I know of is to link scipy and numpy to a different blas library, e.g. openblas. Note that anaconda on windows always uses MKL on intel machines, so you need to install either manually or with pip.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/937
https://github.com/qutip/qutip/issues/938:816,Integrability,rout,routines,816,"Currently, trying to convert a Qobj to a numpy array with `np.array(qobj)` does not work the way I would expect:. ~~~; >>> import numpy as np; >>> import qutip; >>> a = np.random.random((10, 10)); >>> A = qutip.Qobj(a); >>> b = np.array(A); >>> b.shape; (); ~~~. What it does is it handles `A` like it would a scalar.; ~~~; >>> np.array(1).shape; (); ~~~. I generally think of a `Qobj` as ""array-like"", and thus I would expect `np.array(A)` to be equivalent to `np.array(A.full())` (or just `A.full()` directly). ~~~; >>> b = np.array(A.full()); >>> b.shape; (10, 10); ~~~. The reason why I'd want `np.array(A)` to work is that it makes it much easier to write code that works for any array-like types (see https://stackoverflow.com/questions/40378427/numpy-formal-definition-of-array-like-objects). I'm thinking of routines like this:; https://github.com/qucontrol/weylchamber/blob/9a7607363901034da5aca3abb1c4fae7b15db940/src/weylchamber/cartan_decomposition.py#L11 that are intended to accept quantum gates in a wide range of formats. For now, I have to catch `Qobj` explicitly:; https://github.com/qucontrol/weylchamber/blob/9a7607363901034da5aca3abb1c4fae7b15db940/src/weylchamber/cartan_decomposition.py#L41. If I'm not mistaken, the only thing required is to define an `__array__` method on `Qobj` that returns `self.full()`. I thought that the idea would probably have come up when `full()` was implemented, so I'm wondering if there was a conscious design decision not to implement an array interface, and what the reasoning was (if any).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/938
https://github.com/qutip/qutip/issues/938:1500,Integrability,interface,interface,1500,"Currently, trying to convert a Qobj to a numpy array with `np.array(qobj)` does not work the way I would expect:. ~~~; >>> import numpy as np; >>> import qutip; >>> a = np.random.random((10, 10)); >>> A = qutip.Qobj(a); >>> b = np.array(A); >>> b.shape; (); ~~~. What it does is it handles `A` like it would a scalar.; ~~~; >>> np.array(1).shape; (); ~~~. I generally think of a `Qobj` as ""array-like"", and thus I would expect `np.array(A)` to be equivalent to `np.array(A.full())` (or just `A.full()` directly). ~~~; >>> b = np.array(A.full()); >>> b.shape; (10, 10); ~~~. The reason why I'd want `np.array(A)` to work is that it makes it much easier to write code that works for any array-like types (see https://stackoverflow.com/questions/40378427/numpy-formal-definition-of-array-like-objects). I'm thinking of routines like this:; https://github.com/qucontrol/weylchamber/blob/9a7607363901034da5aca3abb1c4fae7b15db940/src/weylchamber/cartan_decomposition.py#L11 that are intended to accept quantum gates in a wide range of formats. For now, I have to catch `Qobj` explicitly:; https://github.com/qucontrol/weylchamber/blob/9a7607363901034da5aca3abb1c4fae7b15db940/src/weylchamber/cartan_decomposition.py#L41. If I'm not mistaken, the only thing required is to define an `__array__` method on `Qobj` that returns `self.full()`. I thought that the idea would probably have come up when `full()` was implemented, so I'm wondering if there was a conscious design decision not to implement an array interface, and what the reasoning was (if any).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/938
https://github.com/qutip/qutip/issues/939:1599,Integrability,rout,routine,1599,"Consider the following example:; ~~~; >>> import qutip; >>> from qutip.operators import *; >>> import numpy as np; >>> ket = (qutip.tensor(qutip.ket('0'), qutip.ket('0')) - 1j * qutip.tensor(qutip.ket('1'), qutip.ket('1')))/np.sqrt(2); >>> rho = qutip.ket2dm(ket); >>> H = qutip.tensor(sigmaz(), identity(2)) + qutip.tensor(identity(2), sigmaz()); >>> c_ops = [qutip.tensor(sigmam(), identity(2)), qutip.tensor(identity(2), sigmam())]; >>> L = qutip.superoperator.liouvillian(H, c_ops=c_ops); ~~~. Now, it seems very sensible to want to apply the superoperator to the density matrix via a simple product. However, this fails:; ~~~; >>> L * rho; Traceback (most recent call last):; File ""<ipython-input-50-c0fe3dea3c39>"", line 1, in <module>; L * rho; File ""/Users/goerz/anaconda3/lib/python3.5/site-packages/qutip/qobj.py"", line 515, in __mul__; raise TypeError(""Incompatible Qobj shapes""); TypeError: Incompatible Qobj shapes; ~~~. The only way to do it seems to be:. ~~~; >>> qutip.vector_to_operator(L * qutip.operator_to_vector(rho)); Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[-1.0+0.j 0.0+0.j 0.0+0.j 2.0-0.5j]; [ 0.0+0.j 0.5+0.j 0.0+0.j 0.0+0.j ]; [ 0.0+0.j 0.0+0.j 0.5+0.j 0.0+0.j ]; [ 2.0+0.5j 0.0+0.j 0.0+0.j 0.0+0.j ]]; ~~~. I would argue that the product `L * rho` should do this kind of conversion internally instead of throwing an exception. It seems to me the intention of `L * rho` is completely unambiguous, but maybe I'm missing something?. Having the product work out of the box means that I can write a simple propagation routine as `(A * dt).expm() * state` and it would work independent of whether (A, state) are a (Hamiltonian, vector) or a (Liouvillian, density matrix). Currently, I have to catch the different cases and handle them separately.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/939
https://github.com/qutip/qutip/issues/939:589,Usability,simpl,simple,589,"Consider the following example:; ~~~; >>> import qutip; >>> from qutip.operators import *; >>> import numpy as np; >>> ket = (qutip.tensor(qutip.ket('0'), qutip.ket('0')) - 1j * qutip.tensor(qutip.ket('1'), qutip.ket('1')))/np.sqrt(2); >>> rho = qutip.ket2dm(ket); >>> H = qutip.tensor(sigmaz(), identity(2)) + qutip.tensor(identity(2), sigmaz()); >>> c_ops = [qutip.tensor(sigmam(), identity(2)), qutip.tensor(identity(2), sigmam())]; >>> L = qutip.superoperator.liouvillian(H, c_ops=c_ops); ~~~. Now, it seems very sensible to want to apply the superoperator to the density matrix via a simple product. However, this fails:; ~~~; >>> L * rho; Traceback (most recent call last):; File ""<ipython-input-50-c0fe3dea3c39>"", line 1, in <module>; L * rho; File ""/Users/goerz/anaconda3/lib/python3.5/site-packages/qutip/qobj.py"", line 515, in __mul__; raise TypeError(""Incompatible Qobj shapes""); TypeError: Incompatible Qobj shapes; ~~~. The only way to do it seems to be:. ~~~; >>> qutip.vector_to_operator(L * qutip.operator_to_vector(rho)); Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[-1.0+0.j 0.0+0.j 0.0+0.j 2.0-0.5j]; [ 0.0+0.j 0.5+0.j 0.0+0.j 0.0+0.j ]; [ 0.0+0.j 0.0+0.j 0.5+0.j 0.0+0.j ]; [ 2.0+0.5j 0.0+0.j 0.0+0.j 0.0+0.j ]]; ~~~. I would argue that the product `L * rho` should do this kind of conversion internally instead of throwing an exception. It seems to me the intention of `L * rho` is completely unambiguous, but maybe I'm missing something?. Having the product work out of the box means that I can write a simple propagation routine as `(A * dt).expm() * state` and it would work independent of whether (A, state) are a (Hamiltonian, vector) or a (Liouvillian, density matrix). Currently, I have to catch the different cases and handle them separately.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/939
https://github.com/qutip/qutip/issues/939:1580,Usability,simpl,simple,1580,"Consider the following example:; ~~~; >>> import qutip; >>> from qutip.operators import *; >>> import numpy as np; >>> ket = (qutip.tensor(qutip.ket('0'), qutip.ket('0')) - 1j * qutip.tensor(qutip.ket('1'), qutip.ket('1')))/np.sqrt(2); >>> rho = qutip.ket2dm(ket); >>> H = qutip.tensor(sigmaz(), identity(2)) + qutip.tensor(identity(2), sigmaz()); >>> c_ops = [qutip.tensor(sigmam(), identity(2)), qutip.tensor(identity(2), sigmam())]; >>> L = qutip.superoperator.liouvillian(H, c_ops=c_ops); ~~~. Now, it seems very sensible to want to apply the superoperator to the density matrix via a simple product. However, this fails:; ~~~; >>> L * rho; Traceback (most recent call last):; File ""<ipython-input-50-c0fe3dea3c39>"", line 1, in <module>; L * rho; File ""/Users/goerz/anaconda3/lib/python3.5/site-packages/qutip/qobj.py"", line 515, in __mul__; raise TypeError(""Incompatible Qobj shapes""); TypeError: Incompatible Qobj shapes; ~~~. The only way to do it seems to be:. ~~~; >>> qutip.vector_to_operator(L * qutip.operator_to_vector(rho)); Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[-1.0+0.j 0.0+0.j 0.0+0.j 2.0-0.5j]; [ 0.0+0.j 0.5+0.j 0.0+0.j 0.0+0.j ]; [ 0.0+0.j 0.0+0.j 0.5+0.j 0.0+0.j ]; [ 2.0+0.5j 0.0+0.j 0.0+0.j 0.0+0.j ]]; ~~~. I would argue that the product `L * rho` should do this kind of conversion internally instead of throwing an exception. It seems to me the intention of `L * rho` is completely unambiguous, but maybe I'm missing something?. Having the product work out of the box means that I can write a simple propagation routine as `(A * dt).expm() * state` and it would work independent of whether (A, state) are a (Hamiltonian, vector) or a (Liouvillian, density matrix). Currently, I have to catch the different cases and handle them separately.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/939
https://github.com/qutip/qutip/pull/942:139,Testability,test,test,139,"In some rare case, the matrix obtain from random_objects.rand_stochastic would have an empty row or column. This would cause the automated test to fail (about 0.8% of the time.). Small fix that ensure the matrix always has a least 1 element on each rows and columns.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/942
https://github.com/qutip/qutip/issues/944:100,Availability,down,down,100,"I was trying to figure out why tests on #943 and #942 were failing for MacOS and could pin-point it down to the `qutip.superop_reps.to_kraus` function. The test `tests.test_superop_reps.test_ChoiKrausChoi` leads to the same malloc error with the message,; ```; python(2234,0x7fff95aef380) malloc: *** error for object 0x7fde6f2f0ff0: incorrect checksum for freed object - object was probably modified after being freed.; ```; Investigating more.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/944
https://github.com/qutip/qutip/issues/944:231,Availability,error,error,231,"I was trying to figure out why tests on #943 and #942 were failing for MacOS and could pin-point it down to the `qutip.superop_reps.to_kraus` function. The test `tests.test_superop_reps.test_ChoiKrausChoi` leads to the same malloc error with the message,; ```; python(2234,0x7fff95aef380) malloc: *** error for object 0x7fde6f2f0ff0: incorrect checksum for freed object - object was probably modified after being freed.; ```; Investigating more.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/944
https://github.com/qutip/qutip/issues/944:301,Availability,error,error,301,"I was trying to figure out why tests on #943 and #942 were failing for MacOS and could pin-point it down to the `qutip.superop_reps.to_kraus` function. The test `tests.test_superop_reps.test_ChoiKrausChoi` leads to the same malloc error with the message,; ```; python(2234,0x7fff95aef380) malloc: *** error for object 0x7fde6f2f0ff0: incorrect checksum for freed object - object was probably modified after being freed.; ```; Investigating more.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/944
https://github.com/qutip/qutip/issues/944:246,Integrability,message,message,246,"I was trying to figure out why tests on #943 and #942 were failing for MacOS and could pin-point it down to the `qutip.superop_reps.to_kraus` function. The test `tests.test_superop_reps.test_ChoiKrausChoi` leads to the same malloc error with the message,; ```; python(2234,0x7fff95aef380) malloc: *** error for object 0x7fde6f2f0ff0: incorrect checksum for freed object - object was probably modified after being freed.; ```; Investigating more.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/944
https://github.com/qutip/qutip/issues/944:344,Security,checksum,checksum,344,"I was trying to figure out why tests on #943 and #942 were failing for MacOS and could pin-point it down to the `qutip.superop_reps.to_kraus` function. The test `tests.test_superop_reps.test_ChoiKrausChoi` leads to the same malloc error with the message,; ```; python(2234,0x7fff95aef380) malloc: *** error for object 0x7fde6f2f0ff0: incorrect checksum for freed object - object was probably modified after being freed.; ```; Investigating more.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/944
https://github.com/qutip/qutip/issues/944:31,Testability,test,tests,31,"I was trying to figure out why tests on #943 and #942 were failing for MacOS and could pin-point it down to the `qutip.superop_reps.to_kraus` function. The test `tests.test_superop_reps.test_ChoiKrausChoi` leads to the same malloc error with the message,; ```; python(2234,0x7fff95aef380) malloc: *** error for object 0x7fde6f2f0ff0: incorrect checksum for freed object - object was probably modified after being freed.; ```; Investigating more.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/944
https://github.com/qutip/qutip/issues/944:156,Testability,test,test,156,"I was trying to figure out why tests on #943 and #942 were failing for MacOS and could pin-point it down to the `qutip.superop_reps.to_kraus` function. The test `tests.test_superop_reps.test_ChoiKrausChoi` leads to the same malloc error with the message,; ```; python(2234,0x7fff95aef380) malloc: *** error for object 0x7fde6f2f0ff0: incorrect checksum for freed object - object was probably modified after being freed.; ```; Investigating more.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/944
https://github.com/qutip/qutip/issues/944:162,Testability,test,tests,162,"I was trying to figure out why tests on #943 and #942 were failing for MacOS and could pin-point it down to the `qutip.superop_reps.to_kraus` function. The test `tests.test_superop_reps.test_ChoiKrausChoi` leads to the same malloc error with the message,; ```; python(2234,0x7fff95aef380) malloc: *** error for object 0x7fde6f2f0ff0: incorrect checksum for freed object - object was probably modified after being freed.; ```; Investigating more.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/944
https://github.com/qutip/qutip/pull/945:631,Performance,perform,performance,631,"numpy give deprecation warning in some test related to mcsolve:; ```Monte-carlo: Constant H (str format) with no collapse ops (expect) ... /home/ericgig/.local/lib/python3.6/site-packages/qutip-4.4.0.dev0+7af31179-py3.6-linux-x86_64.egg/qutip/mcsolve.py:1152: DeprecationWarning: Calling np.sum(generator) is deprecated, and in the future will give a different result. Use np.sum(np.fromiter(generator)) or the python sum builtin instead.```. I replaced the 2 np.sum causing problem by the python builtin sum. Since we are not doing the sum on a numpy array and it's in the solver setup phase, there is only a negligible effect on performance.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/945
https://github.com/qutip/qutip/pull/945:39,Testability,test,test,39,"numpy give deprecation warning in some test related to mcsolve:; ```Monte-carlo: Constant H (str format) with no collapse ops (expect) ... /home/ericgig/.local/lib/python3.6/site-packages/qutip-4.4.0.dev0+7af31179-py3.6-linux-x86_64.egg/qutip/mcsolve.py:1152: DeprecationWarning: Calling np.sum(generator) is deprecated, and in the future will give a different result. Use np.sum(np.fromiter(generator)) or the python sum builtin instead.```. I replaced the 2 np.sum causing problem by the python builtin sum. Since we are not doing the sum on a numpy array and it's in the solver setup phase, there is only a negligible effect on performance.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/945
https://github.com/qutip/qutip/issues/946:99,Integrability,depend,dependent,99,"Hi,. Sometimes I want to simulate the exact behavior of my quantum circuit, i.e. work out the time-dependent Hamiltonian for a specific gate sequence and Hamiltonian of each gate. Then solve the Lindblad master equation with some collapse operator. Is there an easy way to generate the time-dependent Hamiltonian?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/946
https://github.com/qutip/qutip/issues/946:291,Integrability,depend,dependent,291,"Hi,. Sometimes I want to simulate the exact behavior of my quantum circuit, i.e. work out the time-dependent Hamiltonian for a specific gate sequence and Hamiltonian of each gate. Then solve the Lindblad master equation with some collapse operator. Is there an easy way to generate the time-dependent Hamiltonian?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/946
https://github.com/qutip/qutip/issues/947:62,Integrability,depend,dependence,62,"When using the `rhs_with_state=True` with list func type time dependence the state is passed to the user defined func as a numpy vector. I think users would expect this to be a `Qobj`, as in:; https://groups.google.com/forum/#!topic/qutip/BqUZQEQN1c4. The question is whether this should be considered a bug, and hence whether we can fix this without worrying too much about how this will affect other users. My guess it that it is not a well used feature anyway @nonhermitian what do you think? There is no documentation on it's usage for instance, and I don't think there are any tests for it. This is perhaps related #824, insomuchas any fix we do here should be replicated in sesolve as well. The fix seems quite easy, as I think we can assume that the `rho` can be converted as; ```; def drho_list_td_with_state(t, rho, L_list, args):; d = np.sqrt(len(rho_vec)); rho_qobj = QObj(dense2D_to_fastcsr_fmode(vec2mat(rho), d, d)); ```; @Ericgig how do you accommodate rhs_with_state in `QobjEvo`?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/947
https://github.com/qutip/qutip/issues/947:582,Testability,test,tests,582,"When using the `rhs_with_state=True` with list func type time dependence the state is passed to the user defined func as a numpy vector. I think users would expect this to be a `Qobj`, as in:; https://groups.google.com/forum/#!topic/qutip/BqUZQEQN1c4. The question is whether this should be considered a bug, and hence whether we can fix this without worrying too much about how this will affect other users. My guess it that it is not a well used feature anyway @nonhermitian what do you think? There is no documentation on it's usage for instance, and I don't think there are any tests for it. This is perhaps related #824, insomuchas any fix we do here should be replicated in sesolve as well. The fix seems quite easy, as I think we can assume that the `rho` can be converted as; ```; def drho_list_td_with_state(t, rho, L_list, args):; d = np.sqrt(len(rho_vec)); rho_qobj = QObj(dense2D_to_fastcsr_fmode(vec2mat(rho), d, d)); ```; @Ericgig how do you accommodate rhs_with_state in `QobjEvo`?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/947
https://github.com/qutip/qutip/issues/948:41,Usability,undo,undocumented,41,"While we are at it, I have found another undocumented, untested ""feature"" is the solvers.; In `sesolve`, when H is a function and a Qobj is in args, it is replaced by it's data""; sesolve.py, 696:; ``` ; for key in args:; if isinstance(args[key], Qobj):; new_args[key] = args[key].data; ```; `mesolve` does a similar thing: (mesolve.py:889) ; ```; for key in args:; if isinstance(args[key], Qobj):; if isoper(args[key]):; new_args[key] = (; -1j * (spre(args[key]) - spost(args[key]))); ```; While this is probably not common, I don't see it being useful (at least without proper documentation).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/948
https://github.com/qutip/qutip/pull/949:90,Deployability,install,install,90,"Due to the fact that this flag is hard-coded to the `setup.py`, I am completely unable to install QuTiP to the cluster environment. The only way to overcome it is clone the repo and remove it by hands. Closes #920",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/949
https://github.com/qutip/qutip/issues/951:244,Deployability,install,installing,244,"In response to #920, and following the discussion in #949, we need some way to make the compile flags optional during setup. The `-march=native` is the probable cause of issues with the conda-forge build #647, and also causes problems for some installing in a cluster environment. However, for most people installing on a local machine, `-march=native` is likely to have significant performance advantages. The suggestion is then to have some cmd line option to choose compile flags where the default is 'optimal', which would include `-march=native`. @Ericgig we can discuss this next week",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/951
https://github.com/qutip/qutip/issues/951:306,Deployability,install,installing,306,"In response to #920, and following the discussion in #949, we need some way to make the compile flags optional during setup. The `-march=native` is the probable cause of issues with the conda-forge build #647, and also causes problems for some installing in a cluster environment. However, for most people installing on a local machine, `-march=native` is likely to have significant performance advantages. The suggestion is then to have some cmd line option to choose compile flags where the default is 'optimal', which would include `-march=native`. @Ericgig we can discuss this next week",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/951
https://github.com/qutip/qutip/issues/951:383,Performance,perform,performance,383,"In response to #920, and following the discussion in #949, we need some way to make the compile flags optional during setup. The `-march=native` is the probable cause of issues with the conda-forge build #647, and also causes problems for some installing in a cluster environment. However, for most people installing on a local machine, `-march=native` is likely to have significant performance advantages. The suggestion is then to have some cmd line option to choose compile flags where the default is 'optimal', which would include `-march=native`. @Ericgig we can discuss this next week",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/951
https://github.com/qutip/qutip/issues/954:460,Availability,down,downloads,460,"At present the only known working option that works with the runtime compile features (e.g. string type time-dependence) requires Visual Studio 2015 with C++ options. The community edition is fine, which has no monetary cost, but it does come with a considerable install time and disk space (11GB) cost. . According to the [Python wiki on Windows compilers](https://wiki.python.org/moin/WindowsCompilers) These [build tools](https://visualstudio.microsoft.com/downloads/#build-tools-for-visual-studio-2017) are supposed to work, but so far I did not succeed. Not tried in a while, as I don't have very easy access to a Windows machine I can play with. So if someone else wants to give a try, then that would be just great. This issue would ideally be closed after a merging of a PR updating the installation instructions in https://github.com/qutip/qutip-doc",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/954
https://github.com/qutip/qutip/issues/954:263,Deployability,install,install,263,"At present the only known working option that works with the runtime compile features (e.g. string type time-dependence) requires Visual Studio 2015 with C++ options. The community edition is fine, which has no monetary cost, but it does come with a considerable install time and disk space (11GB) cost. . According to the [Python wiki on Windows compilers](https://wiki.python.org/moin/WindowsCompilers) These [build tools](https://visualstudio.microsoft.com/downloads/#build-tools-for-visual-studio-2017) are supposed to work, but so far I did not succeed. Not tried in a while, as I don't have very easy access to a Windows machine I can play with. So if someone else wants to give a try, then that would be just great. This issue would ideally be closed after a merging of a PR updating the installation instructions in https://github.com/qutip/qutip-doc",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/954
https://github.com/qutip/qutip/issues/954:795,Deployability,install,installation,795,"At present the only known working option that works with the runtime compile features (e.g. string type time-dependence) requires Visual Studio 2015 with C++ options. The community edition is fine, which has no monetary cost, but it does come with a considerable install time and disk space (11GB) cost. . According to the [Python wiki on Windows compilers](https://wiki.python.org/moin/WindowsCompilers) These [build tools](https://visualstudio.microsoft.com/downloads/#build-tools-for-visual-studio-2017) are supposed to work, but so far I did not succeed. Not tried in a while, as I don't have very easy access to a Windows machine I can play with. So if someone else wants to give a try, then that would be just great. This issue would ideally be closed after a merging of a PR updating the installation instructions in https://github.com/qutip/qutip-doc",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/954
https://github.com/qutip/qutip/issues/954:109,Integrability,depend,dependence,109,"At present the only known working option that works with the runtime compile features (e.g. string type time-dependence) requires Visual Studio 2015 with C++ options. The community edition is fine, which has no monetary cost, but it does come with a considerable install time and disk space (11GB) cost. . According to the [Python wiki on Windows compilers](https://wiki.python.org/moin/WindowsCompilers) These [build tools](https://visualstudio.microsoft.com/downloads/#build-tools-for-visual-studio-2017) are supposed to work, but so far I did not succeed. Not tried in a while, as I don't have very easy access to a Windows machine I can play with. So if someone else wants to give a try, then that would be just great. This issue would ideally be closed after a merging of a PR updating the installation instructions in https://github.com/qutip/qutip-doc",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/954
https://github.com/qutip/qutip/issues/954:607,Security,access,access,607,"At present the only known working option that works with the runtime compile features (e.g. string type time-dependence) requires Visual Studio 2015 with C++ options. The community edition is fine, which has no monetary cost, but it does come with a considerable install time and disk space (11GB) cost. . According to the [Python wiki on Windows compilers](https://wiki.python.org/moin/WindowsCompilers) These [build tools](https://visualstudio.microsoft.com/downloads/#build-tools-for-visual-studio-2017) are supposed to work, but so far I did not succeed. Not tried in a while, as I don't have very easy access to a Windows machine I can play with. So if someone else wants to give a try, then that would be just great. This issue would ideally be closed after a merging of a PR updating the installation instructions in https://github.com/qutip/qutip-doc",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/954
https://github.com/qutip/qutip/issues/955:84,Modifiability,variab,variables,84,See #954 ; > This builds fine except for the cqobjevo_omp module that uses unsigned variables for the openmp for loop which is not allowed on windows,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/955
https://github.com/qutip/qutip/issues/1525:237,Deployability,Update,Update,237,"@quantshah spotted that the function visualisation tree was out-of-date in qutip/qutip-doc#63. Thanks for that.; @nathanshammah and I spent some time updating it yesterday, but was quite a rigmarole, and the solution is sub-optimal:; 1. Update modules and functions in `QuTiP_tree_plot/qutip-structure.py`; 2. Run `QuTiP_tree_plot/qutip-structure.py`, which updates `QuTiP_tree_plot/d3_data/qutip.json`; 3.a. Open `QuTiP_tree_plot/qutip_org.html` (this only seemed to work with Firefox browser); 3.b. Print to PDF, save as `guide/doc/qutip_tree.pdf`; 4. Somehow crop `qutip_tree.pdf` and export as `guide/figures/qutip_tree.png`. In general we would like to automate this process, so that when the docs are built, the tree is rebuilt automatically. Task 1: make `qutip_org.html` open in all browsers. Task 2: Auto-generate the `qutip.json` when the API docs are built.; The API function docs are built from `apidoc/functions.rst`. It would be much better if we only needed to add new functions in this doc, and it output the `qutip.json` when it gets built. Task 3: embed `qutip_org.html` in the HTML docs and somehow in the PDF docs; Now it would be much better if when the `guide-overview.rst` were build that the HTML in `qutip_org.html` were embedded in the resulting `guide-overview.html` rather than the PNG as is now. More tricky is how this can be embedded in the PDF docs. Task 4: link to the API docs (this is probably quite tricky); If Task 2 is possible, then I guess it should be possible to add links to the API docs. Task 5: Have something similar to the function tree for classes. All in all this is far to hard to be worth doing just for the QuTiP docs, but I assume that lots of other projects would like to have this function tree in their docs, so you might think someone would add this feature to Sphinx. Maybe someone already has. I would suggest that a good first step would be to investigate this, and if not ask a question on their Github; https://github.com/sphinx-doc/sphinx",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1525
https://github.com/qutip/qutip/issues/1525:358,Deployability,update,updates,358,"@quantshah spotted that the function visualisation tree was out-of-date in qutip/qutip-doc#63. Thanks for that.; @nathanshammah and I spent some time updating it yesterday, but was quite a rigmarole, and the solution is sub-optimal:; 1. Update modules and functions in `QuTiP_tree_plot/qutip-structure.py`; 2. Run `QuTiP_tree_plot/qutip-structure.py`, which updates `QuTiP_tree_plot/d3_data/qutip.json`; 3.a. Open `QuTiP_tree_plot/qutip_org.html` (this only seemed to work with Firefox browser); 3.b. Print to PDF, save as `guide/doc/qutip_tree.pdf`; 4. Somehow crop `qutip_tree.pdf` and export as `guide/figures/qutip_tree.png`. In general we would like to automate this process, so that when the docs are built, the tree is rebuilt automatically. Task 1: make `qutip_org.html` open in all browsers. Task 2: Auto-generate the `qutip.json` when the API docs are built.; The API function docs are built from `apidoc/functions.rst`. It would be much better if we only needed to add new functions in this doc, and it output the `qutip.json` when it gets built. Task 3: embed `qutip_org.html` in the HTML docs and somehow in the PDF docs; Now it would be much better if when the `guide-overview.rst` were build that the HTML in `qutip_org.html` were embedded in the resulting `guide-overview.html` rather than the PNG as is now. More tricky is how this can be embedded in the PDF docs. Task 4: link to the API docs (this is probably quite tricky); If Task 2 is possible, then I guess it should be possible to add links to the API docs. Task 5: Have something similar to the function tree for classes. All in all this is far to hard to be worth doing just for the QuTiP docs, but I assume that lots of other projects would like to have this function tree in their docs, so you might think someone would add this feature to Sphinx. Maybe someone already has. I would suggest that a good first step would be to investigate this, and if not ask a question on their Github; https://github.com/sphinx-doc/sphinx",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1525
https://github.com/qutip/qutip/issues/1525:524,Usability,guid,guide,524,"@quantshah spotted that the function visualisation tree was out-of-date in qutip/qutip-doc#63. Thanks for that.; @nathanshammah and I spent some time updating it yesterday, but was quite a rigmarole, and the solution is sub-optimal:; 1. Update modules and functions in `QuTiP_tree_plot/qutip-structure.py`; 2. Run `QuTiP_tree_plot/qutip-structure.py`, which updates `QuTiP_tree_plot/d3_data/qutip.json`; 3.a. Open `QuTiP_tree_plot/qutip_org.html` (this only seemed to work with Firefox browser); 3.b. Print to PDF, save as `guide/doc/qutip_tree.pdf`; 4. Somehow crop `qutip_tree.pdf` and export as `guide/figures/qutip_tree.png`. In general we would like to automate this process, so that when the docs are built, the tree is rebuilt automatically. Task 1: make `qutip_org.html` open in all browsers. Task 2: Auto-generate the `qutip.json` when the API docs are built.; The API function docs are built from `apidoc/functions.rst`. It would be much better if we only needed to add new functions in this doc, and it output the `qutip.json` when it gets built. Task 3: embed `qutip_org.html` in the HTML docs and somehow in the PDF docs; Now it would be much better if when the `guide-overview.rst` were build that the HTML in `qutip_org.html` were embedded in the resulting `guide-overview.html` rather than the PNG as is now. More tricky is how this can be embedded in the PDF docs. Task 4: link to the API docs (this is probably quite tricky); If Task 2 is possible, then I guess it should be possible to add links to the API docs. Task 5: Have something similar to the function tree for classes. All in all this is far to hard to be worth doing just for the QuTiP docs, but I assume that lots of other projects would like to have this function tree in their docs, so you might think someone would add this feature to Sphinx. Maybe someone already has. I would suggest that a good first step would be to investigate this, and if not ask a question on their Github; https://github.com/sphinx-doc/sphinx",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1525
https://github.com/qutip/qutip/issues/1525:599,Usability,guid,guide,599,"@quantshah spotted that the function visualisation tree was out-of-date in qutip/qutip-doc#63. Thanks for that.; @nathanshammah and I spent some time updating it yesterday, but was quite a rigmarole, and the solution is sub-optimal:; 1. Update modules and functions in `QuTiP_tree_plot/qutip-structure.py`; 2. Run `QuTiP_tree_plot/qutip-structure.py`, which updates `QuTiP_tree_plot/d3_data/qutip.json`; 3.a. Open `QuTiP_tree_plot/qutip_org.html` (this only seemed to work with Firefox browser); 3.b. Print to PDF, save as `guide/doc/qutip_tree.pdf`; 4. Somehow crop `qutip_tree.pdf` and export as `guide/figures/qutip_tree.png`. In general we would like to automate this process, so that when the docs are built, the tree is rebuilt automatically. Task 1: make `qutip_org.html` open in all browsers. Task 2: Auto-generate the `qutip.json` when the API docs are built.; The API function docs are built from `apidoc/functions.rst`. It would be much better if we only needed to add new functions in this doc, and it output the `qutip.json` when it gets built. Task 3: embed `qutip_org.html` in the HTML docs and somehow in the PDF docs; Now it would be much better if when the `guide-overview.rst` were build that the HTML in `qutip_org.html` were embedded in the resulting `guide-overview.html` rather than the PNG as is now. More tricky is how this can be embedded in the PDF docs. Task 4: link to the API docs (this is probably quite tricky); If Task 2 is possible, then I guess it should be possible to add links to the API docs. Task 5: Have something similar to the function tree for classes. All in all this is far to hard to be worth doing just for the QuTiP docs, but I assume that lots of other projects would like to have this function tree in their docs, so you might think someone would add this feature to Sphinx. Maybe someone already has. I would suggest that a good first step would be to investigate this, and if not ask a question on their Github; https://github.com/sphinx-doc/sphinx",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1525
https://github.com/qutip/qutip/issues/1525:1176,Usability,guid,guide-overview,1176,"nt some time updating it yesterday, but was quite a rigmarole, and the solution is sub-optimal:; 1. Update modules and functions in `QuTiP_tree_plot/qutip-structure.py`; 2. Run `QuTiP_tree_plot/qutip-structure.py`, which updates `QuTiP_tree_plot/d3_data/qutip.json`; 3.a. Open `QuTiP_tree_plot/qutip_org.html` (this only seemed to work with Firefox browser); 3.b. Print to PDF, save as `guide/doc/qutip_tree.pdf`; 4. Somehow crop `qutip_tree.pdf` and export as `guide/figures/qutip_tree.png`. In general we would like to automate this process, so that when the docs are built, the tree is rebuilt automatically. Task 1: make `qutip_org.html` open in all browsers. Task 2: Auto-generate the `qutip.json` when the API docs are built.; The API function docs are built from `apidoc/functions.rst`. It would be much better if we only needed to add new functions in this doc, and it output the `qutip.json` when it gets built. Task 3: embed `qutip_org.html` in the HTML docs and somehow in the PDF docs; Now it would be much better if when the `guide-overview.rst` were build that the HTML in `qutip_org.html` were embedded in the resulting `guide-overview.html` rather than the PNG as is now. More tricky is how this can be embedded in the PDF docs. Task 4: link to the API docs (this is probably quite tricky); If Task 2 is possible, then I guess it should be possible to add links to the API docs. Task 5: Have something similar to the function tree for classes. All in all this is far to hard to be worth doing just for the QuTiP docs, but I assume that lots of other projects would like to have this function tree in their docs, so you might think someone would add this feature to Sphinx. Maybe someone already has. I would suggest that a good first step would be to investigate this, and if not ask a question on their Github; https://github.com/sphinx-doc/sphinx/issues. If no-one has picked this up after a few months, then we will just add the instructions (steps 1 to 4) above to the readme and ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1525
https://github.com/qutip/qutip/issues/1525:1273,Usability,guid,guide-overview,1273,"e updating it yesterday, but was quite a rigmarole, and the solution is sub-optimal:; 1. Update modules and functions in `QuTiP_tree_plot/qutip-structure.py`; 2. Run `QuTiP_tree_plot/qutip-structure.py`, which updates `QuTiP_tree_plot/d3_data/qutip.json`; 3.a. Open `QuTiP_tree_plot/qutip_org.html` (this only seemed to work with Firefox browser); 3.b. Print to PDF, save as `guide/doc/qutip_tree.pdf`; 4. Somehow crop `qutip_tree.pdf` and export as `guide/figures/qutip_tree.png`. In general we would like to automate this process, so that when the docs are built, the tree is rebuilt automatically. Task 1: make `qutip_org.html` open in all browsers. Task 2: Auto-generate the `qutip.json` when the API docs are built.; The API function docs are built from `apidoc/functions.rst`. It would be much better if we only needed to add new functions in this doc, and it output the `qutip.json` when it gets built. Task 3: embed `qutip_org.html` in the HTML docs and somehow in the PDF docs; Now it would be much better if when the `guide-overview.rst` were build that the HTML in `qutip_org.html` were embedded in the resulting `guide-overview.html` rather than the PNG as is now. More tricky is how this can be embedded in the PDF docs. Task 4: link to the API docs (this is probably quite tricky); If Task 2 is possible, then I guess it should be possible to add links to the API docs. Task 5: Have something similar to the function tree for classes. All in all this is far to hard to be worth doing just for the QuTiP docs, but I assume that lots of other projects would like to have this function tree in their docs, so you might think someone would add this feature to Sphinx. Maybe someone already has. I would suggest that a good first step would be to investigate this, and if not ask a question on their Github; https://github.com/sphinx-doc/sphinx/issues. If no-one has picked this up after a few months, then we will just add the instructions (steps 1 to 4) above to the readme and close this.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1525
https://github.com/qutip/qutip/issues/958:972,Availability,robust,robust,972,This is post for discussion over whether it might be beneficial to switch from `nose` to another unit testing software. . - QuTiP is using nose for unit testing. A [disclaimer](https://nose.readthedocs.io/en/latest/) on that project homepage warns that nose might not be maintained in the future. . - [`nose2`](https://nose2.readthedocs.io/en/latest/differences.html) is the successor to `nose`. It is actively maintained. There are some [differences](https://nose2.readthedocs.io/en/latest/differences.html). . - [pytest](https://pytest.readthedocs.io/en/latest/) is another open-source solution. By comparing [nose2](https://github.com/nose-devs/nose2/graphs/contributors?from=2010-08-01&to=2019-02-27&type=a) and [pytest](https://github.com/pytest-dev/pytest/graphs/contributors?from=2009-04-05&to=2019-02-27&type=a) activity it seems that the latter has grown and is actively updated. . I wonder whether it would make sense to migrate to a more popular (possibly more robust?) software and how much work this would mean. Other implications are not clear to me at this moment.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/958
https://github.com/qutip/qutip/issues/958:880,Deployability,update,updated,880,This is post for discussion over whether it might be beneficial to switch from `nose` to another unit testing software. . - QuTiP is using nose for unit testing. A [disclaimer](https://nose.readthedocs.io/en/latest/) on that project homepage warns that nose might not be maintained in the future. . - [`nose2`](https://nose2.readthedocs.io/en/latest/differences.html) is the successor to `nose`. It is actively maintained. There are some [differences](https://nose2.readthedocs.io/en/latest/differences.html). . - [pytest](https://pytest.readthedocs.io/en/latest/) is another open-source solution. By comparing [nose2](https://github.com/nose-devs/nose2/graphs/contributors?from=2010-08-01&to=2019-02-27&type=a) and [pytest](https://github.com/pytest-dev/pytest/graphs/contributors?from=2009-04-05&to=2019-02-27&type=a) activity it seems that the latter has grown and is actively updated. . I wonder whether it would make sense to migrate to a more popular (possibly more robust?) software and how much work this would mean. Other implications are not clear to me at this moment.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/958
https://github.com/qutip/qutip/issues/958:102,Testability,test,testing,102,This is post for discussion over whether it might be beneficial to switch from `nose` to another unit testing software. . - QuTiP is using nose for unit testing. A [disclaimer](https://nose.readthedocs.io/en/latest/) on that project homepage warns that nose might not be maintained in the future. . - [`nose2`](https://nose2.readthedocs.io/en/latest/differences.html) is the successor to `nose`. It is actively maintained. There are some [differences](https://nose2.readthedocs.io/en/latest/differences.html). . - [pytest](https://pytest.readthedocs.io/en/latest/) is another open-source solution. By comparing [nose2](https://github.com/nose-devs/nose2/graphs/contributors?from=2010-08-01&to=2019-02-27&type=a) and [pytest](https://github.com/pytest-dev/pytest/graphs/contributors?from=2009-04-05&to=2019-02-27&type=a) activity it seems that the latter has grown and is actively updated. . I wonder whether it would make sense to migrate to a more popular (possibly more robust?) software and how much work this would mean. Other implications are not clear to me at this moment.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/958
https://github.com/qutip/qutip/issues/958:153,Testability,test,testing,153,This is post for discussion over whether it might be beneficial to switch from `nose` to another unit testing software. . - QuTiP is using nose for unit testing. A [disclaimer](https://nose.readthedocs.io/en/latest/) on that project homepage warns that nose might not be maintained in the future. . - [`nose2`](https://nose2.readthedocs.io/en/latest/differences.html) is the successor to `nose`. It is actively maintained. There are some [differences](https://nose2.readthedocs.io/en/latest/differences.html). . - [pytest](https://pytest.readthedocs.io/en/latest/) is another open-source solution. By comparing [nose2](https://github.com/nose-devs/nose2/graphs/contributors?from=2010-08-01&to=2019-02-27&type=a) and [pytest](https://github.com/pytest-dev/pytest/graphs/contributors?from=2009-04-05&to=2019-02-27&type=a) activity it seems that the latter has grown and is actively updated. . I wonder whether it would make sense to migrate to a more popular (possibly more robust?) software and how much work this would mean. Other implications are not clear to me at this moment.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/958
https://github.com/qutip/qutip/issues/958:1052,Usability,clear,clear,1052,This is post for discussion over whether it might be beneficial to switch from `nose` to another unit testing software. . - QuTiP is using nose for unit testing. A [disclaimer](https://nose.readthedocs.io/en/latest/) on that project homepage warns that nose might not be maintained in the future. . - [`nose2`](https://nose2.readthedocs.io/en/latest/differences.html) is the successor to `nose`. It is actively maintained. There are some [differences](https://nose2.readthedocs.io/en/latest/differences.html). . - [pytest](https://pytest.readthedocs.io/en/latest/) is another open-source solution. By comparing [nose2](https://github.com/nose-devs/nose2/graphs/contributors?from=2010-08-01&to=2019-02-27&type=a) and [pytest](https://github.com/pytest-dev/pytest/graphs/contributors?from=2009-04-05&to=2019-02-27&type=a) activity it seems that the latter has grown and is actively updated. . I wonder whether it would make sense to migrate to a more popular (possibly more robust?) software and how much work this would mean. Other implications are not clear to me at this moment.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/958
https://github.com/qutip/qutip/issues/959:87,Deployability,continuous,continuous,87,"This is post for discussion over whether it might be beneficial to consider additional continuous integration (CI) tools for QuTiP, beyond Travis CI. . Some open-source projects use multiple CI tools, possibly to do different tasks and test different configurations. For example by adding QuTiP to the list of projects using Sphinx for the documentation I noticed they use concurrently Travis CI, CircleCI and [Appveyor](https://github.com/marketplace/appveyor). . [Stackshare](https://stackshare.io/stackups/circleci-vs-jenkins-vs-travis-ci) allows to compare multiple developers tools.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/959
https://github.com/qutip/qutip/issues/959:98,Deployability,integrat,integration,98,"This is post for discussion over whether it might be beneficial to consider additional continuous integration (CI) tools for QuTiP, beyond Travis CI. . Some open-source projects use multiple CI tools, possibly to do different tasks and test different configurations. For example by adding QuTiP to the list of projects using Sphinx for the documentation I noticed they use concurrently Travis CI, CircleCI and [Appveyor](https://github.com/marketplace/appveyor). . [Stackshare](https://stackshare.io/stackups/circleci-vs-jenkins-vs-travis-ci) allows to compare multiple developers tools.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/959
https://github.com/qutip/qutip/issues/959:251,Deployability,configurat,configurations,251,"This is post for discussion over whether it might be beneficial to consider additional continuous integration (CI) tools for QuTiP, beyond Travis CI. . Some open-source projects use multiple CI tools, possibly to do different tasks and test different configurations. For example by adding QuTiP to the list of projects using Sphinx for the documentation I noticed they use concurrently Travis CI, CircleCI and [Appveyor](https://github.com/marketplace/appveyor). . [Stackshare](https://stackshare.io/stackups/circleci-vs-jenkins-vs-travis-ci) allows to compare multiple developers tools.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/959
https://github.com/qutip/qutip/issues/959:98,Integrability,integrat,integration,98,"This is post for discussion over whether it might be beneficial to consider additional continuous integration (CI) tools for QuTiP, beyond Travis CI. . Some open-source projects use multiple CI tools, possibly to do different tasks and test different configurations. For example by adding QuTiP to the list of projects using Sphinx for the documentation I noticed they use concurrently Travis CI, CircleCI and [Appveyor](https://github.com/marketplace/appveyor). . [Stackshare](https://stackshare.io/stackups/circleci-vs-jenkins-vs-travis-ci) allows to compare multiple developers tools.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/959
https://github.com/qutip/qutip/issues/959:251,Modifiability,config,configurations,251,"This is post for discussion over whether it might be beneficial to consider additional continuous integration (CI) tools for QuTiP, beyond Travis CI. . Some open-source projects use multiple CI tools, possibly to do different tasks and test different configurations. For example by adding QuTiP to the list of projects using Sphinx for the documentation I noticed they use concurrently Travis CI, CircleCI and [Appveyor](https://github.com/marketplace/appveyor). . [Stackshare](https://stackshare.io/stackups/circleci-vs-jenkins-vs-travis-ci) allows to compare multiple developers tools.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/959
https://github.com/qutip/qutip/issues/959:373,Performance,concurren,concurrently,373,"This is post for discussion over whether it might be beneficial to consider additional continuous integration (CI) tools for QuTiP, beyond Travis CI. . Some open-source projects use multiple CI tools, possibly to do different tasks and test different configurations. For example by adding QuTiP to the list of projects using Sphinx for the documentation I noticed they use concurrently Travis CI, CircleCI and [Appveyor](https://github.com/marketplace/appveyor). . [Stackshare](https://stackshare.io/stackups/circleci-vs-jenkins-vs-travis-ci) allows to compare multiple developers tools.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/959
https://github.com/qutip/qutip/issues/959:236,Testability,test,test,236,"This is post for discussion over whether it might be beneficial to consider additional continuous integration (CI) tools for QuTiP, beyond Travis CI. . Some open-source projects use multiple CI tools, possibly to do different tasks and test different configurations. For example by adding QuTiP to the list of projects using Sphinx for the documentation I noticed they use concurrently Travis CI, CircleCI and [Appveyor](https://github.com/marketplace/appveyor). . [Stackshare](https://stackshare.io/stackups/circleci-vs-jenkins-vs-travis-ci) allows to compare multiple developers tools.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/959
https://github.com/qutip/qutip/pull/961:48,Integrability,depend,dependency,48,issue - #892 ; Inserted the syntax for optional dependency in setup.py and requirements.txt,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/961
https://github.com/qutip/qutip/pull/962:497,Modifiability,coupling,coupling,497,"I would like to add the Underdamped Lorentzian spectral density to the HEOM and realised that there should be some discussion on the design. For this specific PR, I am in two minds: . A. I follow the previous code and make a `HSolverUnderDampedBrownian` class. This will be quite different from the HSolverDL class as now, we will take the coefficients ck and vk separately for the non-Matsubara part and then the Mastsubara part and combine them to get the RHS instead of computing them from the coupling strength as before. B. Rewrite a new `Heom` class with the `configure` method taking the ck and vk values and not caring about the spectral density. We add some additional functions to compute the cks and vks based on Drude-Lorrentz, Underdamped Lorrentzian or Ohmic spectral density. We can even do a numerical fitting for the coefficients using the `bath_correlation` function that I added now for any arbitrary spectral density and then feed it to the `configure` method of the new `Heom` class to build the RHS. This is a more generic version of the HEOM which separates the method from specific spectral densities and is close to implementing the following version that is simplified from @nwlambert 's paper :. ![screenshot 2019-03-05 14 41 25](https://user-images.githubusercontent.com/6968324/53809476-16468080-3f55-11e9-90bd-50159a075663.png). I am leaning more towards B and re-structuring the HEOM functions to seperate the SD and the implementation itself. This has some advantages in the future too perhaps if we want to work specificially on the HEOM part without caring about the form of the spectral density. The second point is:. Most of QuTiP's solvers are function based eg., `mesolve`. In `qutip.piqs` however, we tried to do things with the class called `Dicke`. We defined a `pisolve` method similar in spirit to `mesolve` which takes in an initial state, tlist and computes the evolution. For many sophisticated approaches like `piqs` or `heom`, there needs to be some amo",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/962
https://github.com/qutip/qutip/pull/962:529,Modifiability,Rewrite,Rewrite,529,"I would like to add the Underdamped Lorentzian spectral density to the HEOM and realised that there should be some discussion on the design. For this specific PR, I am in two minds: . A. I follow the previous code and make a `HSolverUnderDampedBrownian` class. This will be quite different from the HSolverDL class as now, we will take the coefficients ck and vk separately for the non-Matsubara part and then the Mastsubara part and combine them to get the RHS instead of computing them from the coupling strength as before. B. Rewrite a new `Heom` class with the `configure` method taking the ck and vk values and not caring about the spectral density. We add some additional functions to compute the cks and vks based on Drude-Lorrentz, Underdamped Lorrentzian or Ohmic spectral density. We can even do a numerical fitting for the coefficients using the `bath_correlation` function that I added now for any arbitrary spectral density and then feed it to the `configure` method of the new `Heom` class to build the RHS. This is a more generic version of the HEOM which separates the method from specific spectral densities and is close to implementing the following version that is simplified from @nwlambert 's paper :. ![screenshot 2019-03-05 14 41 25](https://user-images.githubusercontent.com/6968324/53809476-16468080-3f55-11e9-90bd-50159a075663.png). I am leaning more towards B and re-structuring the HEOM functions to seperate the SD and the implementation itself. This has some advantages in the future too perhaps if we want to work specificially on the HEOM part without caring about the form of the spectral density. The second point is:. Most of QuTiP's solvers are function based eg., `mesolve`. In `qutip.piqs` however, we tried to do things with the class called `Dicke`. We defined a `pisolve` method similar in spirit to `mesolve` which takes in an initial state, tlist and computes the evolution. For many sophisticated approaches like `piqs` or `heom`, there needs to be some amo",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/962
https://github.com/qutip/qutip/pull/962:566,Modifiability,config,configure,566,"I would like to add the Underdamped Lorentzian spectral density to the HEOM and realised that there should be some discussion on the design. For this specific PR, I am in two minds: . A. I follow the previous code and make a `HSolverUnderDampedBrownian` class. This will be quite different from the HSolverDL class as now, we will take the coefficients ck and vk separately for the non-Matsubara part and then the Mastsubara part and combine them to get the RHS instead of computing them from the coupling strength as before. B. Rewrite a new `Heom` class with the `configure` method taking the ck and vk values and not caring about the spectral density. We add some additional functions to compute the cks and vks based on Drude-Lorrentz, Underdamped Lorrentzian or Ohmic spectral density. We can even do a numerical fitting for the coefficients using the `bath_correlation` function that I added now for any arbitrary spectral density and then feed it to the `configure` method of the new `Heom` class to build the RHS. This is a more generic version of the HEOM which separates the method from specific spectral densities and is close to implementing the following version that is simplified from @nwlambert 's paper :. ![screenshot 2019-03-05 14 41 25](https://user-images.githubusercontent.com/6968324/53809476-16468080-3f55-11e9-90bd-50159a075663.png). I am leaning more towards B and re-structuring the HEOM functions to seperate the SD and the implementation itself. This has some advantages in the future too perhaps if we want to work specificially on the HEOM part without caring about the form of the spectral density. The second point is:. Most of QuTiP's solvers are function based eg., `mesolve`. In `qutip.piqs` however, we tried to do things with the class called `Dicke`. We defined a `pisolve` method similar in spirit to `mesolve` which takes in an initial state, tlist and computes the evolution. For many sophisticated approaches like `piqs` or `heom`, there needs to be some amo",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/962
https://github.com/qutip/qutip/pull/962:962,Modifiability,config,configure,962,"I would like to add the Underdamped Lorentzian spectral density to the HEOM and realised that there should be some discussion on the design. For this specific PR, I am in two minds: . A. I follow the previous code and make a `HSolverUnderDampedBrownian` class. This will be quite different from the HSolverDL class as now, we will take the coefficients ck and vk separately for the non-Matsubara part and then the Mastsubara part and combine them to get the RHS instead of computing them from the coupling strength as before. B. Rewrite a new `Heom` class with the `configure` method taking the ck and vk values and not caring about the spectral density. We add some additional functions to compute the cks and vks based on Drude-Lorrentz, Underdamped Lorrentzian or Ohmic spectral density. We can even do a numerical fitting for the coefficients using the `bath_correlation` function that I added now for any arbitrary spectral density and then feed it to the `configure` method of the new `Heom` class to build the RHS. This is a more generic version of the HEOM which separates the method from specific spectral densities and is close to implementing the following version that is simplified from @nwlambert 's paper :. ![screenshot 2019-03-05 14 41 25](https://user-images.githubusercontent.com/6968324/53809476-16468080-3f55-11e9-90bd-50159a075663.png). I am leaning more towards B and re-structuring the HEOM functions to seperate the SD and the implementation itself. This has some advantages in the future too perhaps if we want to work specificially on the HEOM part without caring about the form of the spectral density. The second point is:. Most of QuTiP's solvers are function based eg., `mesolve`. In `qutip.piqs` however, we tried to do things with the class called `Dicke`. We defined a `pisolve` method similar in spirit to `mesolve` which takes in an initial state, tlist and computes the evolution. For many sophisticated approaches like `piqs` or `heom`, there needs to be some amo",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/962
https://github.com/qutip/qutip/pull/962:2904,Modifiability,config,configure,2904,"he implementation itself. This has some advantages in the future too perhaps if we want to work specificially on the HEOM part without caring about the form of the spectral density. The second point is:. Most of QuTiP's solvers are function based eg., `mesolve`. In `qutip.piqs` however, we tried to do things with the class called `Dicke`. We defined a `pisolve` method similar in spirit to `mesolve` which takes in an initial state, tlist and computes the evolution. For many sophisticated approaches like `piqs` or `heom`, there needs to be some amount of pre-processing such as computing the Liouvillian/Lindbladian or the levels of the Hierarchy that needs to be done to get the RHS which is solved to get the dynamics. I saw similar approaches in `qutip.pdpsolve` with `StochasticSolverOptions`. I really like the `HEOMSolver` class defined here and was wondering if we can we have a similar abstract class which can be shared across all future solver methods and not just HEOM or the stochastic solver? I add an example below. @ajgpitch Does this make sense and should we strive to get some uniform class for all future solvers? ; @nathanshammah @nonhermitian . ```; class Solver(object):; """"""; A super-class specifying the basic methods required in a solver. Parameters; ----------; name: str; The name of the specific solver the sub-class represents, eg., `heom`.; default: None; """"""; def __init__(self, solver=None):; 	self.solver = solver. def configure(self, *args, **kwargs):; 	""""""; 	Configures the solver by computing the necessary objects required; 	to run the `solve` method.; 	""""""; 	raise NotImplementedError(""This is a abstract class only. ""; ""Use a subclass, for example `Dicke.configure`""). def solve(self, initial_state, tlist, options, *args, **kwargs):; 	""""""; 	Runs the solver to compute the evolution using the initial state and tlist.; 	""""""; 	raise NotImplementedError(""This is a abstract class only. ""; ""Use the solve method from a subclass, for example `Dicke.solve`""); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/962
https://github.com/qutip/qutip/pull/962:2946,Modifiability,Config,Configures,2946,"he implementation itself. This has some advantages in the future too perhaps if we want to work specificially on the HEOM part without caring about the form of the spectral density. The second point is:. Most of QuTiP's solvers are function based eg., `mesolve`. In `qutip.piqs` however, we tried to do things with the class called `Dicke`. We defined a `pisolve` method similar in spirit to `mesolve` which takes in an initial state, tlist and computes the evolution. For many sophisticated approaches like `piqs` or `heom`, there needs to be some amount of pre-processing such as computing the Liouvillian/Lindbladian or the levels of the Hierarchy that needs to be done to get the RHS which is solved to get the dynamics. I saw similar approaches in `qutip.pdpsolve` with `StochasticSolverOptions`. I really like the `HEOMSolver` class defined here and was wondering if we can we have a similar abstract class which can be shared across all future solver methods and not just HEOM or the stochastic solver? I add an example below. @ajgpitch Does this make sense and should we strive to get some uniform class for all future solvers? ; @nathanshammah @nonhermitian . ```; class Solver(object):; """"""; A super-class specifying the basic methods required in a solver. Parameters; ----------; name: str; The name of the specific solver the sub-class represents, eg., `heom`.; default: None; """"""; def __init__(self, solver=None):; 	self.solver = solver. def configure(self, *args, **kwargs):; 	""""""; 	Configures the solver by computing the necessary objects required; 	to run the `solve` method.; 	""""""; 	raise NotImplementedError(""This is a abstract class only. ""; ""Use a subclass, for example `Dicke.configure`""). def solve(self, initial_state, tlist, options, *args, **kwargs):; 	""""""; 	Runs the solver to compute the evolution using the initial state and tlist.; 	""""""; 	raise NotImplementedError(""This is a abstract class only. ""; ""Use the solve method from a subclass, for example `Dicke.solve`""); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/962
https://github.com/qutip/qutip/pull/962:3146,Modifiability,config,configure,3146,"he implementation itself. This has some advantages in the future too perhaps if we want to work specificially on the HEOM part without caring about the form of the spectral density. The second point is:. Most of QuTiP's solvers are function based eg., `mesolve`. In `qutip.piqs` however, we tried to do things with the class called `Dicke`. We defined a `pisolve` method similar in spirit to `mesolve` which takes in an initial state, tlist and computes the evolution. For many sophisticated approaches like `piqs` or `heom`, there needs to be some amount of pre-processing such as computing the Liouvillian/Lindbladian or the levels of the Hierarchy that needs to be done to get the RHS which is solved to get the dynamics. I saw similar approaches in `qutip.pdpsolve` with `StochasticSolverOptions`. I really like the `HEOMSolver` class defined here and was wondering if we can we have a similar abstract class which can be shared across all future solver methods and not just HEOM or the stochastic solver? I add an example below. @ajgpitch Does this make sense and should we strive to get some uniform class for all future solvers? ; @nathanshammah @nonhermitian . ```; class Solver(object):; """"""; A super-class specifying the basic methods required in a solver. Parameters; ----------; name: str; The name of the specific solver the sub-class represents, eg., `heom`.; default: None; """"""; def __init__(self, solver=None):; 	self.solver = solver. def configure(self, *args, **kwargs):; 	""""""; 	Configures the solver by computing the necessary objects required; 	to run the `solve` method.; 	""""""; 	raise NotImplementedError(""This is a abstract class only. ""; ""Use a subclass, for example `Dicke.configure`""). def solve(self, initial_state, tlist, options, *args, **kwargs):; 	""""""; 	Runs the solver to compute the evolution using the initial state and tlist.; 	""""""; 	raise NotImplementedError(""This is a abstract class only. ""; ""Use the solve method from a subclass, for example `Dicke.solve`""); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/962
https://github.com/qutip/qutip/pull/962:1184,Usability,simpl,simplified,1184,"sion on the design. For this specific PR, I am in two minds: . A. I follow the previous code and make a `HSolverUnderDampedBrownian` class. This will be quite different from the HSolverDL class as now, we will take the coefficients ck and vk separately for the non-Matsubara part and then the Mastsubara part and combine them to get the RHS instead of computing them from the coupling strength as before. B. Rewrite a new `Heom` class with the `configure` method taking the ck and vk values and not caring about the spectral density. We add some additional functions to compute the cks and vks based on Drude-Lorrentz, Underdamped Lorrentzian or Ohmic spectral density. We can even do a numerical fitting for the coefficients using the `bath_correlation` function that I added now for any arbitrary spectral density and then feed it to the `configure` method of the new `Heom` class to build the RHS. This is a more generic version of the HEOM which separates the method from specific spectral densities and is close to implementing the following version that is simplified from @nwlambert 's paper :. ![screenshot 2019-03-05 14 41 25](https://user-images.githubusercontent.com/6968324/53809476-16468080-3f55-11e9-90bd-50159a075663.png). I am leaning more towards B and re-structuring the HEOM functions to seperate the SD and the implementation itself. This has some advantages in the future too perhaps if we want to work specificially on the HEOM part without caring about the form of the spectral density. The second point is:. Most of QuTiP's solvers are function based eg., `mesolve`. In `qutip.piqs` however, we tried to do things with the class called `Dicke`. We defined a `pisolve` method similar in spirit to `mesolve` which takes in an initial state, tlist and computes the evolution. For many sophisticated approaches like `piqs` or `heom`, there needs to be some amount of pre-processing such as computing the Liouvillian/Lindbladian or the levels of the Hierarchy that needs to be done ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/962
https://github.com/qutip/qutip/issues/963:72,Availability,error,errors,72,"Originally reported in #944. Tests seem to be failing for MacOS. We get errors like; ```; python(2234,0x7fff95aef380) malloc: *** error for object 0x7fde6f2f0ff0: incorrect checksum for freed object - object was probably modified after being freed.; ```; The build is pretty much always failing, but sometimes passes. I think we only get the errors when tests are run, the functions work fine otherwise. I think someone tried pytest and still got same errors. So kind of a nasty one to investigate, but there might be an easy fix if we can work out what to do. I believe @nathanshammah has done some quite thorough investigation and could probably add to this.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/963
https://github.com/qutip/qutip/issues/963:130,Availability,error,error,130,"Originally reported in #944. Tests seem to be failing for MacOS. We get errors like; ```; python(2234,0x7fff95aef380) malloc: *** error for object 0x7fde6f2f0ff0: incorrect checksum for freed object - object was probably modified after being freed.; ```; The build is pretty much always failing, but sometimes passes. I think we only get the errors when tests are run, the functions work fine otherwise. I think someone tried pytest and still got same errors. So kind of a nasty one to investigate, but there might be an easy fix if we can work out what to do. I believe @nathanshammah has done some quite thorough investigation and could probably add to this.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/963
https://github.com/qutip/qutip/issues/963:342,Availability,error,errors,342,"Originally reported in #944. Tests seem to be failing for MacOS. We get errors like; ```; python(2234,0x7fff95aef380) malloc: *** error for object 0x7fde6f2f0ff0: incorrect checksum for freed object - object was probably modified after being freed.; ```; The build is pretty much always failing, but sometimes passes. I think we only get the errors when tests are run, the functions work fine otherwise. I think someone tried pytest and still got same errors. So kind of a nasty one to investigate, but there might be an easy fix if we can work out what to do. I believe @nathanshammah has done some quite thorough investigation and could probably add to this.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/963
https://github.com/qutip/qutip/issues/963:452,Availability,error,errors,452,"Originally reported in #944. Tests seem to be failing for MacOS. We get errors like; ```; python(2234,0x7fff95aef380) malloc: *** error for object 0x7fde6f2f0ff0: incorrect checksum for freed object - object was probably modified after being freed.; ```; The build is pretty much always failing, but sometimes passes. I think we only get the errors when tests are run, the functions work fine otherwise. I think someone tried pytest and still got same errors. So kind of a nasty one to investigate, but there might be an easy fix if we can work out what to do. I believe @nathanshammah has done some quite thorough investigation and could probably add to this.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/963
https://github.com/qutip/qutip/issues/963:173,Security,checksum,checksum,173,"Originally reported in #944. Tests seem to be failing for MacOS. We get errors like; ```; python(2234,0x7fff95aef380) malloc: *** error for object 0x7fde6f2f0ff0: incorrect checksum for freed object - object was probably modified after being freed.; ```; The build is pretty much always failing, but sometimes passes. I think we only get the errors when tests are run, the functions work fine otherwise. I think someone tried pytest and still got same errors. So kind of a nasty one to investigate, but there might be an easy fix if we can work out what to do. I believe @nathanshammah has done some quite thorough investigation and could probably add to this.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/963
https://github.com/qutip/qutip/issues/963:29,Testability,Test,Tests,29,"Originally reported in #944. Tests seem to be failing for MacOS. We get errors like; ```; python(2234,0x7fff95aef380) malloc: *** error for object 0x7fde6f2f0ff0: incorrect checksum for freed object - object was probably modified after being freed.; ```; The build is pretty much always failing, but sometimes passes. I think we only get the errors when tests are run, the functions work fine otherwise. I think someone tried pytest and still got same errors. So kind of a nasty one to investigate, but there might be an easy fix if we can work out what to do. I believe @nathanshammah has done some quite thorough investigation and could probably add to this.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/963
https://github.com/qutip/qutip/issues/963:354,Testability,test,tests,354,"Originally reported in #944. Tests seem to be failing for MacOS. We get errors like; ```; python(2234,0x7fff95aef380) malloc: *** error for object 0x7fde6f2f0ff0: incorrect checksum for freed object - object was probably modified after being freed.; ```; The build is pretty much always failing, but sometimes passes. I think we only get the errors when tests are run, the functions work fine otherwise. I think someone tried pytest and still got same errors. So kind of a nasty one to investigate, but there might be an easy fix if we can work out what to do. I believe @nathanshammah has done some quite thorough investigation and could probably add to this.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/963
https://github.com/qutip/qutip/issues/964:96,Deployability,release,release,96,"We (mainly @Ericgig ) are developing some changes that would only be included in the next major release. It would make sense to merge these into one branch, but not the `master` branch, so that we can test their compatibility. Maybe `development` is a good name, although we often refer to our `master` as the 'development' branch. I have seen some template for this in another project, but cannot remember where. If anyone has some ideas for this, then would be good if they could share here",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/964
https://github.com/qutip/qutip/issues/964:201,Testability,test,test,201,"We (mainly @Ericgig ) are developing some changes that would only be included in the next major release. It would make sense to merge these into one branch, but not the `master` branch, so that we can test their compatibility. Maybe `development` is a good name, although we often refer to our `master` as the 'development' branch. I have seen some template for this in another project, but cannot remember where. If anyone has some ideas for this, then would be good if they could share here",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/964
https://github.com/qutip/qutip/issues/965:88,Availability,error,error,88,"In file included from qutip/cy/spmatfuncs.cpp:639:; qutip/cy/src/zspmv.hpp:33:10: fatal error: 'complex' file not found; #include <complex>; ^~~~~~~~~; 1 error generated.; error: command 'gcc' failed with exit status 1. MAC os Mojave, python 3.6.4. How to fix this?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/965
https://github.com/qutip/qutip/issues/965:154,Availability,error,error,154,"In file included from qutip/cy/spmatfuncs.cpp:639:; qutip/cy/src/zspmv.hpp:33:10: fatal error: 'complex' file not found; #include <complex>; ^~~~~~~~~; 1 error generated.; error: command 'gcc' failed with exit status 1. MAC os Mojave, python 3.6.4. How to fix this?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/965
https://github.com/qutip/qutip/issues/965:172,Availability,error,error,172,"In file included from qutip/cy/spmatfuncs.cpp:639:; qutip/cy/src/zspmv.hpp:33:10: fatal error: 'complex' file not found; #include <complex>; ^~~~~~~~~; 1 error generated.; error: command 'gcc' failed with exit status 1. MAC os Mojave, python 3.6.4. How to fix this?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/965
https://github.com/qutip/qutip/issues/966:264,Availability,error,errors,264,"I am running an iterative method that requires calling mesolve many times.; At some point, the program crashes. It seems that every time mesolve is called, the list of arguments passed to the gcc complier grows. Eventually that list is too big for gcc and returns errors and stops the program. I wrote a simplified code that eventually leads to that problem. It took close to 2 hours to reproduce, and but maybe you can figure out a way to reach that point faster (faster calls ? more arguments passed to gcc to make it reach that point faster?). The screen capture shows how many calls were required in my case, how many seconds had elapsed since the program started, as well as how the error manifests. [test_qutip_error.txt](https://github.com/qutip/qutip/files/2973153/test_qutip_error.txt); <img width=""982"" alt=""Screen Shot"" src=""https://user-images.githubusercontent.com/28269924/54465696-b1034400-4739-11e9-91ab-be1fff21f057.png"">. I experienced this problem a while ago, both on my laptop and amazon instances, on Qutip 4.2.0 with Python 2.7.15. Both with the Anaconda and pip installs. Are there any ways to fix this? I need this for my research. Thank you very much !",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/966
https://github.com/qutip/qutip/issues/966:688,Availability,error,error,688,"I am running an iterative method that requires calling mesolve many times.; At some point, the program crashes. It seems that every time mesolve is called, the list of arguments passed to the gcc complier grows. Eventually that list is too big for gcc and returns errors and stops the program. I wrote a simplified code that eventually leads to that problem. It took close to 2 hours to reproduce, and but maybe you can figure out a way to reach that point faster (faster calls ? more arguments passed to gcc to make it reach that point faster?). The screen capture shows how many calls were required in my case, how many seconds had elapsed since the program started, as well as how the error manifests. [test_qutip_error.txt](https://github.com/qutip/qutip/files/2973153/test_qutip_error.txt); <img width=""982"" alt=""Screen Shot"" src=""https://user-images.githubusercontent.com/28269924/54465696-b1034400-4739-11e9-91ab-be1fff21f057.png"">. I experienced this problem a while ago, both on my laptop and amazon instances, on Qutip 4.2.0 with Python 2.7.15. Both with the Anaconda and pip installs. Are there any ways to fix this? I need this for my research. Thank you very much !",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/966
https://github.com/qutip/qutip/issues/966:1086,Deployability,install,installs,1086,"I am running an iterative method that requires calling mesolve many times.; At some point, the program crashes. It seems that every time mesolve is called, the list of arguments passed to the gcc complier grows. Eventually that list is too big for gcc and returns errors and stops the program. I wrote a simplified code that eventually leads to that problem. It took close to 2 hours to reproduce, and but maybe you can figure out a way to reach that point faster (faster calls ? more arguments passed to gcc to make it reach that point faster?). The screen capture shows how many calls were required in my case, how many seconds had elapsed since the program started, as well as how the error manifests. [test_qutip_error.txt](https://github.com/qutip/qutip/files/2973153/test_qutip_error.txt); <img width=""982"" alt=""Screen Shot"" src=""https://user-images.githubusercontent.com/28269924/54465696-b1034400-4739-11e9-91ab-be1fff21f057.png"">. I experienced this problem a while ago, both on my laptop and amazon instances, on Qutip 4.2.0 with Python 2.7.15. Both with the Anaconda and pip installs. Are there any ways to fix this? I need this for my research. Thank you very much !",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/966
https://github.com/qutip/qutip/issues/966:304,Usability,simpl,simplified,304,"I am running an iterative method that requires calling mesolve many times.; At some point, the program crashes. It seems that every time mesolve is called, the list of arguments passed to the gcc complier grows. Eventually that list is too big for gcc and returns errors and stops the program. I wrote a simplified code that eventually leads to that problem. It took close to 2 hours to reproduce, and but maybe you can figure out a way to reach that point faster (faster calls ? more arguments passed to gcc to make it reach that point faster?). The screen capture shows how many calls were required in my case, how many seconds had elapsed since the program started, as well as how the error manifests. [test_qutip_error.txt](https://github.com/qutip/qutip/files/2973153/test_qutip_error.txt); <img width=""982"" alt=""Screen Shot"" src=""https://user-images.githubusercontent.com/28269924/54465696-b1034400-4739-11e9-91ab-be1fff21f057.png"">. I experienced this problem a while ago, both on my laptop and amazon instances, on Qutip 4.2.0 with Python 2.7.15. Both with the Anaconda and pip installs. Are there any ways to fix this? I need this for my research. Thank you very much !",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/966
https://github.com/qutip/qutip/issues/1526:107,Usability,guid,guidelines,107,"It would be nice if the docstrings in QuTiP were well formatted, such that, when Sphinx builds the API and guidelines documentation, there are working link to QuTiP functions and classes. An example of working link is `qutip.steadystate.steadystate` in; http://qutip.org/docs/latest/guide/guide-steady.html#steady-state-solvers-in-qutip. An example of working link in the API doc is options: `qutip.solver.Options` in the attributes of the `HEOMSolver` class; http://qutip.org/docs/latest/apidoc/classes.html#non-markovian-solvers. A way to proceed would be to:. 1) reformat all instances in the docstrings of qutip/qutip such that they are in the form of :py:meth:`mymodule.MyClass.mymethod`, see; https://stackoverflow.com/questions/22700606/how-would-i-cross-reference-a-function-generated-by-autodoc-in-sphinx. 2) Build the documentation with Sphinx to check that the change works and generates an active hyperlink in the relative html page of the documentation. . 3) Iterate 1) and 2) for instances in which Qobj or other QuTiP functions or classes are found.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1526
https://github.com/qutip/qutip/issues/1526:283,Usability,guid,guide,283,"It would be nice if the docstrings in QuTiP were well formatted, such that, when Sphinx builds the API and guidelines documentation, there are working link to QuTiP functions and classes. An example of working link is `qutip.steadystate.steadystate` in; http://qutip.org/docs/latest/guide/guide-steady.html#steady-state-solvers-in-qutip. An example of working link in the API doc is options: `qutip.solver.Options` in the attributes of the `HEOMSolver` class; http://qutip.org/docs/latest/apidoc/classes.html#non-markovian-solvers. A way to proceed would be to:. 1) reformat all instances in the docstrings of qutip/qutip such that they are in the form of :py:meth:`mymodule.MyClass.mymethod`, see; https://stackoverflow.com/questions/22700606/how-would-i-cross-reference-a-function-generated-by-autodoc-in-sphinx. 2) Build the documentation with Sphinx to check that the change works and generates an active hyperlink in the relative html page of the documentation. . 3) Iterate 1) and 2) for instances in which Qobj or other QuTiP functions or classes are found.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1526
https://github.com/qutip/qutip/issues/1526:289,Usability,guid,guide-steady,289,"It would be nice if the docstrings in QuTiP were well formatted, such that, when Sphinx builds the API and guidelines documentation, there are working link to QuTiP functions and classes. An example of working link is `qutip.steadystate.steadystate` in; http://qutip.org/docs/latest/guide/guide-steady.html#steady-state-solvers-in-qutip. An example of working link in the API doc is options: `qutip.solver.Options` in the attributes of the `HEOMSolver` class; http://qutip.org/docs/latest/apidoc/classes.html#non-markovian-solvers. A way to proceed would be to:. 1) reformat all instances in the docstrings of qutip/qutip such that they are in the form of :py:meth:`mymodule.MyClass.mymethod`, see; https://stackoverflow.com/questions/22700606/how-would-i-cross-reference-a-function-generated-by-autodoc-in-sphinx. 2) Build the documentation with Sphinx to check that the change works and generates an active hyperlink in the relative html page of the documentation. . 3) Iterate 1) and 2) for instances in which Qobj or other QuTiP functions or classes are found.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1526
https://github.com/qutip/qutip/issues/1527:148,Usability,guid,guidelines,148,"The formatting of several .py files in qutip/qutip could be improved according to [PEP8](https://www.python.org/dev/peps/pep-0008/) and appropriate guidelines. An example in ; [qutip/piqs.py](https://github.com/qutip/qutip/blob/master/qutip/piqs.py) is given by . ```; def num_dicke_states(N):; """"""Calculate the number of Dicke states.; Parameters; ----------; N: int; The number of two-level systems.; ```; that can be changed to introduce spaces after the : ; ```; def num_dicke_states(N):; """"""Calculate the number of Dicke states.; Parameters; ----------; N : int; The number of two-level systems.; ```. These changes would affect the documentation upon build, but need to be made in qutip/qutip.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1527
https://github.com/qutip/qutip/pull/967:40,Deployability,update,updated,40,Issue #905 and #892; Numpy Requirements updated to 1.12 from 1.8 and Optional Dependency for Matplotlib added.; MacOS test is failing as mentioned in #963,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/967
https://github.com/qutip/qutip/pull/967:78,Integrability,Depend,Dependency,78,Issue #905 and #892; Numpy Requirements updated to 1.12 from 1.8 and Optional Dependency for Matplotlib added.; MacOS test is failing as mentioned in #963,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/967
https://github.com/qutip/qutip/pull/967:118,Testability,test,test,118,Issue #905 and #892; Numpy Requirements updated to 1.12 from 1.8 and Optional Dependency for Matplotlib added.; MacOS test is failing as mentioned in #963,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/967
https://github.com/qutip/qutip/issues/968:14,Availability,error,error,14,"The following error occurred several times while running the tests on my machine:; ```; ======================================================================; ERROR: Stochastic: ssesolve: heterodyne, time-dependent H; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Users\Boxi\Miniconda3\envs\qutip-dev-py3\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Users\Boxi\OneDrive\Studium\qutip-project\qutip\qutip\tests\test_stochastic_se.py"", line 208, in test_ssesolve_heterodyne; map_func=parallel_map, args={""a"":2}); File ""C:\Users\Boxi\OneDrive\Studium\qutip-project\qutip\qutip\stochastic.py"", line 698, in ssesolve; args=args, **kwargs); File ""C:\Users\Boxi\OneDrive\Studium\qutip-project\qutip\qutip\stochastic.py"", line 417, in __init__; self.noise = np.random.randint(0, 2**32, ntraj).astype(""u4""); File ""mtrand.pyx"", line 990, in mtrand.RandomState.randint; ValueError: high is out of bounds for int32. ----------------------------------------------------------------------; ```; It is due to the fact that the default integer of python on windows is int32 instead of int64. `np.random.randint(0, 2**32)` produces the same error on my machine. Maybe it is better to add `dtype=np.int64` or `dtype=np.uint32` since they are platform independent. If you agree I can work on fixing it.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/968
https://github.com/qutip/qutip/issues/968:160,Availability,ERROR,ERROR,160,"The following error occurred several times while running the tests on my machine:; ```; ======================================================================; ERROR: Stochastic: ssesolve: heterodyne, time-dependent H; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Users\Boxi\Miniconda3\envs\qutip-dev-py3\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Users\Boxi\OneDrive\Studium\qutip-project\qutip\qutip\tests\test_stochastic_se.py"", line 208, in test_ssesolve_heterodyne; map_func=parallel_map, args={""a"":2}); File ""C:\Users\Boxi\OneDrive\Studium\qutip-project\qutip\qutip\stochastic.py"", line 698, in ssesolve; args=args, **kwargs); File ""C:\Users\Boxi\OneDrive\Studium\qutip-project\qutip\qutip\stochastic.py"", line 417, in __init__; self.noise = np.random.randint(0, 2**32, ntraj).astype(""u4""); File ""mtrand.pyx"", line 990, in mtrand.RandomState.randint; ValueError: high is out of bounds for int32. ----------------------------------------------------------------------; ```; It is due to the fact that the default integer of python on windows is int32 instead of int64. `np.random.randint(0, 2**32)` produces the same error on my machine. Maybe it is better to add `dtype=np.int64` or `dtype=np.uint32` since they are platform independent. If you agree I can work on fixing it.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/968
https://github.com/qutip/qutip/issues/968:1237,Availability,error,error,1237,"The following error occurred several times while running the tests on my machine:; ```; ======================================================================; ERROR: Stochastic: ssesolve: heterodyne, time-dependent H; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Users\Boxi\Miniconda3\envs\qutip-dev-py3\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Users\Boxi\OneDrive\Studium\qutip-project\qutip\qutip\tests\test_stochastic_se.py"", line 208, in test_ssesolve_heterodyne; map_func=parallel_map, args={""a"":2}); File ""C:\Users\Boxi\OneDrive\Studium\qutip-project\qutip\qutip\stochastic.py"", line 698, in ssesolve; args=args, **kwargs); File ""C:\Users\Boxi\OneDrive\Studium\qutip-project\qutip\qutip\stochastic.py"", line 417, in __init__; self.noise = np.random.randint(0, 2**32, ntraj).astype(""u4""); File ""mtrand.pyx"", line 990, in mtrand.RandomState.randint; ValueError: high is out of bounds for int32. ----------------------------------------------------------------------; ```; It is due to the fact that the default integer of python on windows is int32 instead of int64. `np.random.randint(0, 2**32)` produces the same error on my machine. Maybe it is better to add `dtype=np.int64` or `dtype=np.uint32` since they are platform independent. If you agree I can work on fixing it.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/968
https://github.com/qutip/qutip/issues/968:206,Integrability,depend,dependent,206,"The following error occurred several times while running the tests on my machine:; ```; ======================================================================; ERROR: Stochastic: ssesolve: heterodyne, time-dependent H; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Users\Boxi\Miniconda3\envs\qutip-dev-py3\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Users\Boxi\OneDrive\Studium\qutip-project\qutip\qutip\tests\test_stochastic_se.py"", line 208, in test_ssesolve_heterodyne; map_func=parallel_map, args={""a"":2}); File ""C:\Users\Boxi\OneDrive\Studium\qutip-project\qutip\qutip\stochastic.py"", line 698, in ssesolve; args=args, **kwargs); File ""C:\Users\Boxi\OneDrive\Studium\qutip-project\qutip\qutip\stochastic.py"", line 417, in __init__; self.noise = np.random.randint(0, 2**32, ntraj).astype(""u4""); File ""mtrand.pyx"", line 990, in mtrand.RandomState.randint; ValueError: high is out of bounds for int32. ----------------------------------------------------------------------; ```; It is due to the fact that the default integer of python on windows is int32 instead of int64. `np.random.randint(0, 2**32)` produces the same error on my machine. Maybe it is better to add `dtype=np.int64` or `dtype=np.uint32` since they are platform independent. If you agree I can work on fixing it.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/968
https://github.com/qutip/qutip/issues/968:61,Testability,test,tests,61,"The following error occurred several times while running the tests on my machine:; ```; ======================================================================; ERROR: Stochastic: ssesolve: heterodyne, time-dependent H; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Users\Boxi\Miniconda3\envs\qutip-dev-py3\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Users\Boxi\OneDrive\Studium\qutip-project\qutip\qutip\tests\test_stochastic_se.py"", line 208, in test_ssesolve_heterodyne; map_func=parallel_map, args={""a"":2}); File ""C:\Users\Boxi\OneDrive\Studium\qutip-project\qutip\qutip\stochastic.py"", line 698, in ssesolve; args=args, **kwargs); File ""C:\Users\Boxi\OneDrive\Studium\qutip-project\qutip\qutip\stochastic.py"", line 417, in __init__; self.noise = np.random.randint(0, 2**32, ntraj).astype(""u4""); File ""mtrand.pyx"", line 990, in mtrand.RandomState.randint; ValueError: high is out of bounds for int32. ----------------------------------------------------------------------; ```; It is due to the fact that the default integer of python on windows is int32 instead of int64. `np.random.randint(0, 2**32)` produces the same error on my machine. Maybe it is better to add `dtype=np.int64` or `dtype=np.uint32` since they are platform independent. If you agree I can work on fixing it.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/968
https://github.com/qutip/qutip/issues/968:437,Testability,test,test,437,"The following error occurred several times while running the tests on my machine:; ```; ======================================================================; ERROR: Stochastic: ssesolve: heterodyne, time-dependent H; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Users\Boxi\Miniconda3\envs\qutip-dev-py3\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Users\Boxi\OneDrive\Studium\qutip-project\qutip\qutip\tests\test_stochastic_se.py"", line 208, in test_ssesolve_heterodyne; map_func=parallel_map, args={""a"":2}); File ""C:\Users\Boxi\OneDrive\Studium\qutip-project\qutip\qutip\stochastic.py"", line 698, in ssesolve; args=args, **kwargs); File ""C:\Users\Boxi\OneDrive\Studium\qutip-project\qutip\qutip\stochastic.py"", line 417, in __init__; self.noise = np.random.randint(0, 2**32, ntraj).astype(""u4""); File ""mtrand.pyx"", line 990, in mtrand.RandomState.randint; ValueError: high is out of bounds for int32. ----------------------------------------------------------------------; ```; It is due to the fact that the default integer of python on windows is int32 instead of int64. `np.random.randint(0, 2**32)` produces the same error on my machine. Maybe it is better to add `dtype=np.int64` or `dtype=np.uint32` since they are platform independent. If you agree I can work on fixing it.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/968
https://github.com/qutip/qutip/issues/968:517,Testability,test,tests,517,"The following error occurred several times while running the tests on my machine:; ```; ======================================================================; ERROR: Stochastic: ssesolve: heterodyne, time-dependent H; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Users\Boxi\Miniconda3\envs\qutip-dev-py3\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Users\Boxi\OneDrive\Studium\qutip-project\qutip\qutip\tests\test_stochastic_se.py"", line 208, in test_ssesolve_heterodyne; map_func=parallel_map, args={""a"":2}); File ""C:\Users\Boxi\OneDrive\Studium\qutip-project\qutip\qutip\stochastic.py"", line 698, in ssesolve; args=args, **kwargs); File ""C:\Users\Boxi\OneDrive\Studium\qutip-project\qutip\qutip\stochastic.py"", line 417, in __init__; self.noise = np.random.randint(0, 2**32, ntraj).astype(""u4""); File ""mtrand.pyx"", line 990, in mtrand.RandomState.randint; ValueError: high is out of bounds for int32. ----------------------------------------------------------------------; ```; It is due to the fact that the default integer of python on windows is int32 instead of int64. `np.random.randint(0, 2**32)` produces the same error on my machine. Maybe it is better to add `dtype=np.int64` or `dtype=np.uint32` since they are platform independent. If you agree I can work on fixing it.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/968
https://github.com/qutip/qutip/pull/969:97,Testability,test,test,97,"Rewrote sesolve, mesolve and mcsolve to use QobjEvo.; Compatible with previous version, solvers' test pass without modification. Feature/imporvement:; - state can be obtain as an argument as a vector or Qobj.; - expectation values also can be arguments.; - The system is saved in a object to be reuse.; - mcsolve is fully class based. (but the use as object is not documented); - s/mesolve follow a similar pattern to be easily made to class.; - Experimental: diagonalized mcsolve.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/969
https://github.com/qutip/qutip/pull/970:169,Testability,test,tested,169,The version of ptrace can support bigger system and is faster for large matrices. The ptrace of 4.3 create a integer overflow when the matrix size is `2**16` (#828).; I tested this version up to `2**25` without problem.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/970
https://github.com/qutip/qutip/pull/972:30,Deployability,install,installation,30,In .travis.yml: replaced nose installation lines with pytest installation lines.; Suggested in issue #958.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/972
https://github.com/qutip/qutip/pull/972:61,Deployability,install,installation,61,In .travis.yml: replaced nose installation lines with pytest installation lines.; Suggested in issue #958.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/972
https://github.com/qutip/qutip/pull/974:25,Availability,error,error,25,Will take some trial and error to make this useful but has some interesting stats.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/974
https://github.com/qutip/qutip/issues/975:202,Availability,rollback,rollback,202,"This was reported on the help group; https://groups.google.com/forum/#!topic/qutip/L-MIFFwK0xU. (copying from there); the newest mkl(Math library for intel) version(2019) can not work on QuTiP 4.3.1. I rollback it to mkl(2018.0.3), the qutip.testing then work well. If using mkl(2019.0), there will MKL read problems, like:; ```; File ""C:\Users\ym24chen\Anaconda3\; x = lu.solve(b, verbose=verbose); File ""C:\Users\ym24chen\Anaconda3\envs\qutip-env\lib\site-packages\qutip\_mkl\spsolve.py"", line 164, in solve; np_x, np_error); OSError: exception: access violation reading 0x0000000000000008; envs\qutip-env\lib\site-packages\qutip\_mkl\spsolve.py"", line 384, in mkl_spsolve; ```. Env info:; ```; QuTiP Version: 4.3.1; Numpy Version: 1.15.4; Scipy Version: 1.1.0; Cython Version: 0.29.6; Matplotlib Version: 3.0.3; Python Version: 3.7.2; Number of CPUs: 8; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Windows (AMD64); Installation path: C:\Users\canwa\AppData\Local\conda\conda\envs\qutipenv\lib\site-packages\qutip; ==============================================================================; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/975
https://github.com/qutip/qutip/issues/975:202,Deployability,rollback,rollback,202,"This was reported on the help group; https://groups.google.com/forum/#!topic/qutip/L-MIFFwK0xU. (copying from there); the newest mkl(Math library for intel) version(2019) can not work on QuTiP 4.3.1. I rollback it to mkl(2018.0.3), the qutip.testing then work well. If using mkl(2019.0), there will MKL read problems, like:; ```; File ""C:\Users\ym24chen\Anaconda3\; x = lu.solve(b, verbose=verbose); File ""C:\Users\ym24chen\Anaconda3\envs\qutip-env\lib\site-packages\qutip\_mkl\spsolve.py"", line 164, in solve; np_x, np_error); OSError: exception: access violation reading 0x0000000000000008; envs\qutip-env\lib\site-packages\qutip\_mkl\spsolve.py"", line 384, in mkl_spsolve; ```. Env info:; ```; QuTiP Version: 4.3.1; Numpy Version: 1.15.4; Scipy Version: 1.1.0; Cython Version: 0.29.6; Matplotlib Version: 3.0.3; Python Version: 3.7.2; Number of CPUs: 8; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Windows (AMD64); Installation path: C:\Users\canwa\AppData\Local\conda\conda\envs\qutipenv\lib\site-packages\qutip; ==============================================================================; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/975
https://github.com/qutip/qutip/issues/975:886,Deployability,Install,Installed,886,"This was reported on the help group; https://groups.google.com/forum/#!topic/qutip/L-MIFFwK0xU. (copying from there); the newest mkl(Math library for intel) version(2019) can not work on QuTiP 4.3.1. I rollback it to mkl(2018.0.3), the qutip.testing then work well. If using mkl(2019.0), there will MKL read problems, like:; ```; File ""C:\Users\ym24chen\Anaconda3\; x = lu.solve(b, verbose=verbose); File ""C:\Users\ym24chen\Anaconda3\envs\qutip-env\lib\site-packages\qutip\_mkl\spsolve.py"", line 164, in solve; np_x, np_error); OSError: exception: access violation reading 0x0000000000000008; envs\qutip-env\lib\site-packages\qutip\_mkl\spsolve.py"", line 384, in mkl_spsolve; ```. Env info:; ```; QuTiP Version: 4.3.1; Numpy Version: 1.15.4; Scipy Version: 1.1.0; Cython Version: 0.29.6; Matplotlib Version: 3.0.3; Python Version: 3.7.2; Number of CPUs: 8; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Windows (AMD64); Installation path: C:\Users\canwa\AppData\Local\conda\conda\envs\qutipenv\lib\site-packages\qutip; ==============================================================================; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/975
https://github.com/qutip/qutip/issues/975:957,Deployability,Install,Installation,957,"This was reported on the help group; https://groups.google.com/forum/#!topic/qutip/L-MIFFwK0xU. (copying from there); the newest mkl(Math library for intel) version(2019) can not work on QuTiP 4.3.1. I rollback it to mkl(2018.0.3), the qutip.testing then work well. If using mkl(2019.0), there will MKL read problems, like:; ```; File ""C:\Users\ym24chen\Anaconda3\; x = lu.solve(b, verbose=verbose); File ""C:\Users\ym24chen\Anaconda3\envs\qutip-env\lib\site-packages\qutip\_mkl\spsolve.py"", line 164, in solve; np_x, np_error); OSError: exception: access violation reading 0x0000000000000008; envs\qutip-env\lib\site-packages\qutip\_mkl\spsolve.py"", line 384, in mkl_spsolve; ```. Env info:; ```; QuTiP Version: 4.3.1; Numpy Version: 1.15.4; Scipy Version: 1.1.0; Cython Version: 0.29.6; Matplotlib Version: 3.0.3; Python Version: 3.7.2; Number of CPUs: 8; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Windows (AMD64); Installation path: C:\Users\canwa\AppData\Local\conda\conda\envs\qutipenv\lib\site-packages\qutip; ==============================================================================; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/975
https://github.com/qutip/qutip/issues/975:548,Security,access,access,548,"This was reported on the help group; https://groups.google.com/forum/#!topic/qutip/L-MIFFwK0xU. (copying from there); the newest mkl(Math library for intel) version(2019) can not work on QuTiP 4.3.1. I rollback it to mkl(2018.0.3), the qutip.testing then work well. If using mkl(2019.0), there will MKL read problems, like:; ```; File ""C:\Users\ym24chen\Anaconda3\; x = lu.solve(b, verbose=verbose); File ""C:\Users\ym24chen\Anaconda3\envs\qutip-env\lib\site-packages\qutip\_mkl\spsolve.py"", line 164, in solve; np_x, np_error); OSError: exception: access violation reading 0x0000000000000008; envs\qutip-env\lib\site-packages\qutip\_mkl\spsolve.py"", line 384, in mkl_spsolve; ```. Env info:; ```; QuTiP Version: 4.3.1; Numpy Version: 1.15.4; Scipy Version: 1.1.0; Cython Version: 0.29.6; Matplotlib Version: 3.0.3; Python Version: 3.7.2; Number of CPUs: 8; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Windows (AMD64); Installation path: C:\Users\canwa\AppData\Local\conda\conda\envs\qutipenv\lib\site-packages\qutip; ==============================================================================; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/975
https://github.com/qutip/qutip/issues/975:242,Testability,test,testing,242,"This was reported on the help group; https://groups.google.com/forum/#!topic/qutip/L-MIFFwK0xU. (copying from there); the newest mkl(Math library for intel) version(2019) can not work on QuTiP 4.3.1. I rollback it to mkl(2018.0.3), the qutip.testing then work well. If using mkl(2019.0), there will MKL read problems, like:; ```; File ""C:\Users\ym24chen\Anaconda3\; x = lu.solve(b, verbose=verbose); File ""C:\Users\ym24chen\Anaconda3\envs\qutip-env\lib\site-packages\qutip\_mkl\spsolve.py"", line 164, in solve; np_x, np_error); OSError: exception: access violation reading 0x0000000000000008; envs\qutip-env\lib\site-packages\qutip\_mkl\spsolve.py"", line 384, in mkl_spsolve; ```. Env info:; ```; QuTiP Version: 4.3.1; Numpy Version: 1.15.4; Scipy Version: 1.1.0; Cython Version: 0.29.6; Matplotlib Version: 3.0.3; Python Version: 3.7.2; Number of CPUs: 8; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Windows (AMD64); Installation path: C:\Users\canwa\AppData\Local\conda\conda\envs\qutipenv\lib\site-packages\qutip; ==============================================================================; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/975
https://github.com/qutip/qutip/pull/976:0,Deployability,update,updated,0,"updated docstrings in qutip/qobj.py containing instances of qobj with hyperlinks, as per issue 71",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/976
https://github.com/qutip/qutip/issues/977:252,Availability,error,error,252,"Given a density matrix `rho` created in QuTiP, I'd like to apply a unitary operator to it, like in the following code:. ```python; rho_coherent = coherent_dm(10, 0); rho_squeezing = squeeze(10,0.25)(rho_coherent); ```. However, it raises the following error:; ```batch; TypeError(""Can only act oper on ket or oper.""); ```. I've fixed it temporarily by adding another `if` line 775 of `qobj.py`:. ```python; elif self.type == ""oper"":; if other.type == ""ket"":; return self * other; elif other.type == ""oper"":; return self * other * self.dag(); else:; raise TypeError(""Can only act oper on ket or oper.""); ```. However, it's only a hack because it works only when the main object is a hermitian operator (observable or density matrix) and other is a unitary matrix. . What do you think would be a good solution to solve this issue?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/977
https://github.com/qutip/qutip/issues/1529:620,Testability,log,logo,620,"It could be nice to try interactive graphics using [Bokeh](https://bokeh.pydata.org/en/latest/) and QuTiP. I am not familiar with the tool, [this](https://github.com/bokeh/bokeh-notebooks) could be a starting point. ; These notebooks could be added to the QuTiP website at [qutip.org/tutorials](http://qutip.org/tutorials).; Maybe a first step could be to start from existing notebooks, such as the beautiful [Wigner functions gallery](https://nbviewer.jupyter.org/urls/raw.github.com/jrjohansson/qutip-lectures/master/Lecture-16-Gallery-of-Wigner-functions.ipynb)) and its Schrödinger cat states that define also QuTiP logo. Also, in the future some of current and upcoming research material by @quantshah could provide a wow effect if interactive.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1529
https://github.com/qutip/qutip/issues/981:96,Energy Efficiency,power,power,96,"If I define a 1-level annihilation operator with ``qutip.destroy(1)``, and then I try to take a power to any integer, qutip throws an exception. I think this is because scalars are recognized as bras, and bras are not operators.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/981
https://github.com/qutip/qutip/issues/982:4,Testability,assert,asserting,4,"I'm asserting that two operators are almost equal, and implementing a __round__ method for Qobj would be useful in this regard.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/982
https://github.com/qutip/qutip/issues/983:77,Availability,down,downloads,77,"Badges tell some features of a project, such as code coverage, build status, downloads. ; A comprehensive list of badges can be generated on [shields.io](https://shields.io).; Not any badge that can be generated is interesting to be displayed, but some badges might be cool and informative. ; Anaconda provides some of them at https://anaconda.org/conda-forge/qutip/badges. ; Recently the `conda-forge` download counter was added to Readme.md: [![Anaconda-Server Badge](https://anaconda.org/conda-forge/qutip/badges/downloads.svg)](https://anaconda.org/conda-forge/qutip).; It could be interesting to add meaningful badges from shields.io. On https://github.com/badges/shields it is even possible to generate new badges (one could eventually think of badges providing information about the integration with the quantum-tech ecosystem).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/983
https://github.com/qutip/qutip/issues/983:403,Availability,down,download,403,"Badges tell some features of a project, such as code coverage, build status, downloads. ; A comprehensive list of badges can be generated on [shields.io](https://shields.io).; Not any badge that can be generated is interesting to be displayed, but some badges might be cool and informative. ; Anaconda provides some of them at https://anaconda.org/conda-forge/qutip/badges. ; Recently the `conda-forge` download counter was added to Readme.md: [![Anaconda-Server Badge](https://anaconda.org/conda-forge/qutip/badges/downloads.svg)](https://anaconda.org/conda-forge/qutip).; It could be interesting to add meaningful badges from shields.io. On https://github.com/badges/shields it is even possible to generate new badges (one could eventually think of badges providing information about the integration with the quantum-tech ecosystem).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/983
https://github.com/qutip/qutip/issues/983:516,Availability,down,downloads,516,"Badges tell some features of a project, such as code coverage, build status, downloads. ; A comprehensive list of badges can be generated on [shields.io](https://shields.io).; Not any badge that can be generated is interesting to be displayed, but some badges might be cool and informative. ; Anaconda provides some of them at https://anaconda.org/conda-forge/qutip/badges. ; Recently the `conda-forge` download counter was added to Readme.md: [![Anaconda-Server Badge](https://anaconda.org/conda-forge/qutip/badges/downloads.svg)](https://anaconda.org/conda-forge/qutip).; It could be interesting to add meaningful badges from shields.io. On https://github.com/badges/shields it is even possible to generate new badges (one could eventually think of badges providing information about the integration with the quantum-tech ecosystem).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/983
https://github.com/qutip/qutip/issues/983:790,Deployability,integrat,integration,790,"Badges tell some features of a project, such as code coverage, build status, downloads. ; A comprehensive list of badges can be generated on [shields.io](https://shields.io).; Not any badge that can be generated is interesting to be displayed, but some badges might be cool and informative. ; Anaconda provides some of them at https://anaconda.org/conda-forge/qutip/badges. ; Recently the `conda-forge` download counter was added to Readme.md: [![Anaconda-Server Badge](https://anaconda.org/conda-forge/qutip/badges/downloads.svg)](https://anaconda.org/conda-forge/qutip).; It could be interesting to add meaningful badges from shields.io. On https://github.com/badges/shields it is even possible to generate new badges (one could eventually think of badges providing information about the integration with the quantum-tech ecosystem).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/983
https://github.com/qutip/qutip/issues/983:790,Integrability,integrat,integration,790,"Badges tell some features of a project, such as code coverage, build status, downloads. ; A comprehensive list of badges can be generated on [shields.io](https://shields.io).; Not any badge that can be generated is interesting to be displayed, but some badges might be cool and informative. ; Anaconda provides some of them at https://anaconda.org/conda-forge/qutip/badges. ; Recently the `conda-forge` download counter was added to Readme.md: [![Anaconda-Server Badge](https://anaconda.org/conda-forge/qutip/badges/downloads.svg)](https://anaconda.org/conda-forge/qutip).; It could be interesting to add meaningful badges from shields.io. On https://github.com/badges/shields it is even possible to generate new badges (one could eventually think of badges providing information about the integration with the quantum-tech ecosystem).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/983
https://github.com/qutip/qutip/issues/986:140,Usability,clear,clear,140,"`python3 setup.py clean` creates cpp files in qutip/control and qutip/cy. This is the exact opposite of what it should do. It's supposed to clear out build files, not create new ones.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/986
https://github.com/qutip/qutip/issues/987:106,Deployability,install,install,106,"`setup.py test` invokes test_td_formats.py, which generates rhs*.pyx files in the build subdir. `setup.py install` installs everything in the build subdir. So that includes the rhs*pyx test files. The test files get installed at the toplevel of the installation path, just above the qutip dir.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/987
https://github.com/qutip/qutip/issues/987:115,Deployability,install,installs,115,"`setup.py test` invokes test_td_formats.py, which generates rhs*.pyx files in the build subdir. `setup.py install` installs everything in the build subdir. So that includes the rhs*pyx test files. The test files get installed at the toplevel of the installation path, just above the qutip dir.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/987
https://github.com/qutip/qutip/issues/987:216,Deployability,install,installed,216,"`setup.py test` invokes test_td_formats.py, which generates rhs*.pyx files in the build subdir. `setup.py install` installs everything in the build subdir. So that includes the rhs*pyx test files. The test files get installed at the toplevel of the installation path, just above the qutip dir.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/987
https://github.com/qutip/qutip/issues/987:249,Deployability,install,installation,249,"`setup.py test` invokes test_td_formats.py, which generates rhs*.pyx files in the build subdir. `setup.py install` installs everything in the build subdir. So that includes the rhs*pyx test files. The test files get installed at the toplevel of the installation path, just above the qutip dir.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/987
https://github.com/qutip/qutip/issues/987:10,Testability,test,test,10,"`setup.py test` invokes test_td_formats.py, which generates rhs*.pyx files in the build subdir. `setup.py install` installs everything in the build subdir. So that includes the rhs*pyx test files. The test files get installed at the toplevel of the installation path, just above the qutip dir.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/987
https://github.com/qutip/qutip/issues/987:185,Testability,test,test,185,"`setup.py test` invokes test_td_formats.py, which generates rhs*.pyx files in the build subdir. `setup.py install` installs everything in the build subdir. So that includes the rhs*pyx test files. The test files get installed at the toplevel of the installation path, just above the qutip dir.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/987
https://github.com/qutip/qutip/issues/987:201,Testability,test,test,201,"`setup.py test` invokes test_td_formats.py, which generates rhs*.pyx files in the build subdir. `setup.py install` installs everything in the build subdir. So that includes the rhs*pyx test files. The test files get installed at the toplevel of the installation path, just above the qutip dir.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/987
https://github.com/qutip/qutip/issues/988:438,Deployability,install,installed,438,"This may not really be an issue per se, but I thought it would a good idea to post it anyway.; On updating my conda environment which is devoted for qutip I get, . > Collecting package metadata: done; Solving environment: \ ; The environment is inconsistent, please check the package plan carefully; The following packages are causing the inconsistency:; conda-forge/osx-64::qutip==4.2.0=np113py36_2; done; All requested packages already installed. Is this because qutip depends on somewhat older versions of it's dependencies (like numpy, etc)?; MacOS 10.13.6",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/988
https://github.com/qutip/qutip/issues/988:471,Integrability,depend,depends,471,"This may not really be an issue per se, but I thought it would a good idea to post it anyway.; On updating my conda environment which is devoted for qutip I get, . > Collecting package metadata: done; Solving environment: \ ; The environment is inconsistent, please check the package plan carefully; The following packages are causing the inconsistency:; conda-forge/osx-64::qutip==4.2.0=np113py36_2; done; All requested packages already installed. Is this because qutip depends on somewhat older versions of it's dependencies (like numpy, etc)?; MacOS 10.13.6",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/988
https://github.com/qutip/qutip/issues/988:514,Integrability,depend,dependencies,514,"This may not really be an issue per se, but I thought it would a good idea to post it anyway.; On updating my conda environment which is devoted for qutip I get, . > Collecting package metadata: done; Solving environment: \ ; The environment is inconsistent, please check the package plan carefully; The following packages are causing the inconsistency:; conda-forge/osx-64::qutip==4.2.0=np113py36_2; done; All requested packages already installed. Is this because qutip depends on somewhat older versions of it's dependencies (like numpy, etc)?; MacOS 10.13.6",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/988
https://github.com/qutip/qutip/pull/990:99,Deployability,update,update,99,"This PR is part of PR #969 , splitting that PR in two parts. It contains:; - `qobjevo`'s args that update with the state. (replacing rhs_with_state functionality) ; - method `norm` renamed to `_cdc` as it was not used as a norm.; - cython side of expect method no longer take `isherm` as an arguments.; - security check in propagator for `H` as a function with `batch` method.; - `propagator` uses `sesolve` capability to evolve operators.; - floquet now call `sesolve` instead of `mesolve` with no collapse.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/990
https://github.com/qutip/qutip/pull/990:422,Modifiability,evolve,evolve,422,"This PR is part of PR #969 , splitting that PR in two parts. It contains:; - `qobjevo`'s args that update with the state. (replacing rhs_with_state functionality) ; - method `norm` renamed to `_cdc` as it was not used as a norm.; - cython side of expect method no longer take `isherm` as an arguments.; - security check in propagator for `H` as a function with `batch` method.; - `propagator` uses `sesolve` capability to evolve operators.; - floquet now call `sesolve` instead of `mesolve` with no collapse.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/990
https://github.com/qutip/qutip/pull/990:305,Security,secur,security,305,"This PR is part of PR #969 , splitting that PR in two parts. It contains:; - `qobjevo`'s args that update with the state. (replacing rhs_with_state functionality) ; - method `norm` renamed to `_cdc` as it was not used as a norm.; - cython side of expect method no longer take `isherm` as an arguments.; - security check in propagator for `H` as a function with `batch` method.; - `propagator` uses `sesolve` capability to evolve operators.; - floquet now call `sesolve` instead of `mesolve` with no collapse.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/990
https://github.com/qutip/qutip/pull/991:24,Usability,simpl,simplified,24,"Rewrote, cythonized and simplified `mcsolve`.; `mcsolve` implementation based on `qobjevo`.; It is now class based with the general structure I would propose for solvers.; It has (experimental, hidden for now) support for diagonalized evolution.; Collapse history can be obtained by the Hamiltonian.; Otherwise the same algorithm than the previous version. Between #990 and #969",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/991
https://github.com/qutip/qutip/issues/992:83,Deployability,install,install,83,"QuTiP is currently distributed through both Anaconda's conda-forge channel (`conda install qutip`) and PyPI (`pip install qutip`).; It could be helpful to the maintainers to have the project also on the test channel of PyPI, https://test.pypi.org, testing the distribution before uploading a new release on the actual PyPI channel. The [instructions](https://packaging.python.org/guides/using-testpypi/) are straightforward. Placing this as a memo for v. 4.4. Testing this would be helpful also as we attempt the wheels configuration (#933), which, as I understood from @Ericgig, might not be so straightforward given the low-level calls that QuTiP makes in some functions.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/992
https://github.com/qutip/qutip/issues/992:114,Deployability,install,install,114,"QuTiP is currently distributed through both Anaconda's conda-forge channel (`conda install qutip`) and PyPI (`pip install qutip`).; It could be helpful to the maintainers to have the project also on the test channel of PyPI, https://test.pypi.org, testing the distribution before uploading a new release on the actual PyPI channel. The [instructions](https://packaging.python.org/guides/using-testpypi/) are straightforward. Placing this as a memo for v. 4.4. Testing this would be helpful also as we attempt the wheels configuration (#933), which, as I understood from @Ericgig, might not be so straightforward given the low-level calls that QuTiP makes in some functions.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/992
https://github.com/qutip/qutip/issues/992:296,Deployability,release,release,296,"QuTiP is currently distributed through both Anaconda's conda-forge channel (`conda install qutip`) and PyPI (`pip install qutip`).; It could be helpful to the maintainers to have the project also on the test channel of PyPI, https://test.pypi.org, testing the distribution before uploading a new release on the actual PyPI channel. The [instructions](https://packaging.python.org/guides/using-testpypi/) are straightforward. Placing this as a memo for v. 4.4. Testing this would be helpful also as we attempt the wheels configuration (#933), which, as I understood from @Ericgig, might not be so straightforward given the low-level calls that QuTiP makes in some functions.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/992
https://github.com/qutip/qutip/issues/992:520,Deployability,configurat,configuration,520,"QuTiP is currently distributed through both Anaconda's conda-forge channel (`conda install qutip`) and PyPI (`pip install qutip`).; It could be helpful to the maintainers to have the project also on the test channel of PyPI, https://test.pypi.org, testing the distribution before uploading a new release on the actual PyPI channel. The [instructions](https://packaging.python.org/guides/using-testpypi/) are straightforward. Placing this as a memo for v. 4.4. Testing this would be helpful also as we attempt the wheels configuration (#933), which, as I understood from @Ericgig, might not be so straightforward given the low-level calls that QuTiP makes in some functions.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/992
https://github.com/qutip/qutip/issues/992:520,Modifiability,config,configuration,520,"QuTiP is currently distributed through both Anaconda's conda-forge channel (`conda install qutip`) and PyPI (`pip install qutip`).; It could be helpful to the maintainers to have the project also on the test channel of PyPI, https://test.pypi.org, testing the distribution before uploading a new release on the actual PyPI channel. The [instructions](https://packaging.python.org/guides/using-testpypi/) are straightforward. Placing this as a memo for v. 4.4. Testing this would be helpful also as we attempt the wheels configuration (#933), which, as I understood from @Ericgig, might not be so straightforward given the low-level calls that QuTiP makes in some functions.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/992
https://github.com/qutip/qutip/issues/992:203,Testability,test,test,203,"QuTiP is currently distributed through both Anaconda's conda-forge channel (`conda install qutip`) and PyPI (`pip install qutip`).; It could be helpful to the maintainers to have the project also on the test channel of PyPI, https://test.pypi.org, testing the distribution before uploading a new release on the actual PyPI channel. The [instructions](https://packaging.python.org/guides/using-testpypi/) are straightforward. Placing this as a memo for v. 4.4. Testing this would be helpful also as we attempt the wheels configuration (#933), which, as I understood from @Ericgig, might not be so straightforward given the low-level calls that QuTiP makes in some functions.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/992
https://github.com/qutip/qutip/issues/992:233,Testability,test,test,233,"QuTiP is currently distributed through both Anaconda's conda-forge channel (`conda install qutip`) and PyPI (`pip install qutip`).; It could be helpful to the maintainers to have the project also on the test channel of PyPI, https://test.pypi.org, testing the distribution before uploading a new release on the actual PyPI channel. The [instructions](https://packaging.python.org/guides/using-testpypi/) are straightforward. Placing this as a memo for v. 4.4. Testing this would be helpful also as we attempt the wheels configuration (#933), which, as I understood from @Ericgig, might not be so straightforward given the low-level calls that QuTiP makes in some functions.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/992
https://github.com/qutip/qutip/issues/992:248,Testability,test,testing,248,"QuTiP is currently distributed through both Anaconda's conda-forge channel (`conda install qutip`) and PyPI (`pip install qutip`).; It could be helpful to the maintainers to have the project also on the test channel of PyPI, https://test.pypi.org, testing the distribution before uploading a new release on the actual PyPI channel. The [instructions](https://packaging.python.org/guides/using-testpypi/) are straightforward. Placing this as a memo for v. 4.4. Testing this would be helpful also as we attempt the wheels configuration (#933), which, as I understood from @Ericgig, might not be so straightforward given the low-level calls that QuTiP makes in some functions.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/992
https://github.com/qutip/qutip/issues/992:393,Testability,test,testpypi,393,"QuTiP is currently distributed through both Anaconda's conda-forge channel (`conda install qutip`) and PyPI (`pip install qutip`).; It could be helpful to the maintainers to have the project also on the test channel of PyPI, https://test.pypi.org, testing the distribution before uploading a new release on the actual PyPI channel. The [instructions](https://packaging.python.org/guides/using-testpypi/) are straightforward. Placing this as a memo for v. 4.4. Testing this would be helpful also as we attempt the wheels configuration (#933), which, as I understood from @Ericgig, might not be so straightforward given the low-level calls that QuTiP makes in some functions.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/992
https://github.com/qutip/qutip/issues/992:460,Testability,Test,Testing,460,"QuTiP is currently distributed through both Anaconda's conda-forge channel (`conda install qutip`) and PyPI (`pip install qutip`).; It could be helpful to the maintainers to have the project also on the test channel of PyPI, https://test.pypi.org, testing the distribution before uploading a new release on the actual PyPI channel. The [instructions](https://packaging.python.org/guides/using-testpypi/) are straightforward. Placing this as a memo for v. 4.4. Testing this would be helpful also as we attempt the wheels configuration (#933), which, as I understood from @Ericgig, might not be so straightforward given the low-level calls that QuTiP makes in some functions.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/992
https://github.com/qutip/qutip/issues/992:380,Usability,guid,guides,380,"QuTiP is currently distributed through both Anaconda's conda-forge channel (`conda install qutip`) and PyPI (`pip install qutip`).; It could be helpful to the maintainers to have the project also on the test channel of PyPI, https://test.pypi.org, testing the distribution before uploading a new release on the actual PyPI channel. The [instructions](https://packaging.python.org/guides/using-testpypi/) are straightforward. Placing this as a memo for v. 4.4. Testing this would be helpful also as we attempt the wheels configuration (#933), which, as I understood from @Ericgig, might not be so straightforward given the low-level calls that QuTiP makes in some functions.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/992
https://github.com/qutip/qutip/pull/995:204,Availability,error,error,204,"Some small changes:. 1. remove repetitive assignments of `self.arg_value` and` self.arg_label`; 2. move the description to the definition of class so the document will show it; 3. raise the corresponding error if targets is None while required or not an integer, e.g `Gate(""SWAP"")` or `Gate(""SWAP"", [0.5, 2])`",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/995
https://github.com/qutip/qutip/issues/997:88,Availability,down,downloads,88,"QuTiP is hosted on Anaconda's conda-forge channel and on PyPI. I would like to showcase downloads on the [website](https://github.com/qutip/qutip.github.io) and possibly have a development notebook (or in a personal repository) showing them updated, for QuTiP presentations. . * **conda install qutip**: For conda-forge, it is possible to use the `anaconda-package-data` with `dask` and `intake`, ; https://github.com/ContinuumIO/anaconda-package-data. * **pip install qutip**: For PyPI, it is possible to use, `pypinfo` ; https://github.com/ofek/pypinfo; Note that with`pypinfo` Google's Big Data queries are not free, but new accounts come with some budget credited. Some data: . *`pip install qutip` data starts in 2016. In 2018, 8000 downloads are reported. For 2019, well over 10,000 downloads are predicted. *`conda install qutip` data starts in March 2017. For 2018, 30,000 downloads have been performed. This data is useful to gauge the effective popularity of the two package managers and distribution platforms and can help in setting priorities for relative support and bug fixing. . ## Anaconda downloads; <img width=""441"" alt=""qutip-conda-forge-downloads"" src=""https://user-images.githubusercontent.com/14573436/57989417-45d94380-7ad5-11e9-9694-623fec86865b.png"">. ## PyPI downloads; ![pip-install-qutip-png](https://user-images.githubusercontent.com/14573436/57979590-df174400-7a5a-11e9-807e-c2f46bbb830e.png). With `pypinfo` we can also easily extract other information on users' machines details, such as python usage, which can provide guidance on aspects: . ### Python version; #### 2018; | python_version | percent | download_count |; | -------------- | ------: | -------------: |; | 3.6 | 47.33% | 4,079 |; | 2.7 | 24.25% | 2,090 |; | 3.7 | 13.97% | 1,204 |; | 3.5 | 12.43% | 1,071 |; | 3.4 | 1.94% | 167 |; | 2.6 | 0.09% | 8 |; | Total | | 8,619 |. #### 2017; | python_version | percent | download_count |; | -------------- | ------: | -------------: |; | 2.7 | 51.55% | 4,333 |; ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/997
https://github.com/qutip/qutip/issues/997:738,Availability,down,downloads,738,"QuTiP is hosted on Anaconda's conda-forge channel and on PyPI. I would like to showcase downloads on the [website](https://github.com/qutip/qutip.github.io) and possibly have a development notebook (or in a personal repository) showing them updated, for QuTiP presentations. . * **conda install qutip**: For conda-forge, it is possible to use the `anaconda-package-data` with `dask` and `intake`, ; https://github.com/ContinuumIO/anaconda-package-data. * **pip install qutip**: For PyPI, it is possible to use, `pypinfo` ; https://github.com/ofek/pypinfo; Note that with`pypinfo` Google's Big Data queries are not free, but new accounts come with some budget credited. Some data: . *`pip install qutip` data starts in 2016. In 2018, 8000 downloads are reported. For 2019, well over 10,000 downloads are predicted. *`conda install qutip` data starts in March 2017. For 2018, 30,000 downloads have been performed. This data is useful to gauge the effective popularity of the two package managers and distribution platforms and can help in setting priorities for relative support and bug fixing. . ## Anaconda downloads; <img width=""441"" alt=""qutip-conda-forge-downloads"" src=""https://user-images.githubusercontent.com/14573436/57989417-45d94380-7ad5-11e9-9694-623fec86865b.png"">. ## PyPI downloads; ![pip-install-qutip-png](https://user-images.githubusercontent.com/14573436/57979590-df174400-7a5a-11e9-807e-c2f46bbb830e.png). With `pypinfo` we can also easily extract other information on users' machines details, such as python usage, which can provide guidance on aspects: . ### Python version; #### 2018; | python_version | percent | download_count |; | -------------- | ------: | -------------: |; | 3.6 | 47.33% | 4,079 |; | 2.7 | 24.25% | 2,090 |; | 3.7 | 13.97% | 1,204 |; | 3.5 | 12.43% | 1,071 |; | 3.4 | 1.94% | 167 |; | 2.6 | 0.09% | 8 |; | Total | | 8,619 |. #### 2017; | python_version | percent | download_count |; | -------------- | ------: | -------------: |; | 2.7 | 51.55% | 4,333 |; ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/997
https://github.com/qutip/qutip/issues/997:789,Availability,down,downloads,789,"QuTiP is hosted on Anaconda's conda-forge channel and on PyPI. I would like to showcase downloads on the [website](https://github.com/qutip/qutip.github.io) and possibly have a development notebook (or in a personal repository) showing them updated, for QuTiP presentations. . * **conda install qutip**: For conda-forge, it is possible to use the `anaconda-package-data` with `dask` and `intake`, ; https://github.com/ContinuumIO/anaconda-package-data. * **pip install qutip**: For PyPI, it is possible to use, `pypinfo` ; https://github.com/ofek/pypinfo; Note that with`pypinfo` Google's Big Data queries are not free, but new accounts come with some budget credited. Some data: . *`pip install qutip` data starts in 2016. In 2018, 8000 downloads are reported. For 2019, well over 10,000 downloads are predicted. *`conda install qutip` data starts in March 2017. For 2018, 30,000 downloads have been performed. This data is useful to gauge the effective popularity of the two package managers and distribution platforms and can help in setting priorities for relative support and bug fixing. . ## Anaconda downloads; <img width=""441"" alt=""qutip-conda-forge-downloads"" src=""https://user-images.githubusercontent.com/14573436/57989417-45d94380-7ad5-11e9-9694-623fec86865b.png"">. ## PyPI downloads; ![pip-install-qutip-png](https://user-images.githubusercontent.com/14573436/57979590-df174400-7a5a-11e9-807e-c2f46bbb830e.png). With `pypinfo` we can also easily extract other information on users' machines details, such as python usage, which can provide guidance on aspects: . ### Python version; #### 2018; | python_version | percent | download_count |; | -------------- | ------: | -------------: |; | 3.6 | 47.33% | 4,079 |; | 2.7 | 24.25% | 2,090 |; | 3.7 | 13.97% | 1,204 |; | 3.5 | 12.43% | 1,071 |; | 3.4 | 1.94% | 167 |; | 2.6 | 0.09% | 8 |; | Total | | 8,619 |. #### 2017; | python_version | percent | download_count |; | -------------- | ------: | -------------: |; | 2.7 | 51.55% | 4,333 |; ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/997
https://github.com/qutip/qutip/issues/997:881,Availability,down,downloads,881,"QuTiP is hosted on Anaconda's conda-forge channel and on PyPI. I would like to showcase downloads on the [website](https://github.com/qutip/qutip.github.io) and possibly have a development notebook (or in a personal repository) showing them updated, for QuTiP presentations. . * **conda install qutip**: For conda-forge, it is possible to use the `anaconda-package-data` with `dask` and `intake`, ; https://github.com/ContinuumIO/anaconda-package-data. * **pip install qutip**: For PyPI, it is possible to use, `pypinfo` ; https://github.com/ofek/pypinfo; Note that with`pypinfo` Google's Big Data queries are not free, but new accounts come with some budget credited. Some data: . *`pip install qutip` data starts in 2016. In 2018, 8000 downloads are reported. For 2019, well over 10,000 downloads are predicted. *`conda install qutip` data starts in March 2017. For 2018, 30,000 downloads have been performed. This data is useful to gauge the effective popularity of the two package managers and distribution platforms and can help in setting priorities for relative support and bug fixing. . ## Anaconda downloads; <img width=""441"" alt=""qutip-conda-forge-downloads"" src=""https://user-images.githubusercontent.com/14573436/57989417-45d94380-7ad5-11e9-9694-623fec86865b.png"">. ## PyPI downloads; ![pip-install-qutip-png](https://user-images.githubusercontent.com/14573436/57979590-df174400-7a5a-11e9-807e-c2f46bbb830e.png). With `pypinfo` we can also easily extract other information on users' machines details, such as python usage, which can provide guidance on aspects: . ### Python version; #### 2018; | python_version | percent | download_count |; | -------------- | ------: | -------------: |; | 3.6 | 47.33% | 4,079 |; | 2.7 | 24.25% | 2,090 |; | 3.7 | 13.97% | 1,204 |; | 3.5 | 12.43% | 1,071 |; | 3.4 | 1.94% | 167 |; | 2.6 | 0.09% | 8 |; | Total | | 8,619 |. #### 2017; | python_version | percent | download_count |; | -------------- | ------: | -------------: |; | 2.7 | 51.55% | 4,333 |; ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/997
https://github.com/qutip/qutip/issues/997:1107,Availability,down,downloads,1107,"p.github.io) and possibly have a development notebook (or in a personal repository) showing them updated, for QuTiP presentations. . * **conda install qutip**: For conda-forge, it is possible to use the `anaconda-package-data` with `dask` and `intake`, ; https://github.com/ContinuumIO/anaconda-package-data. * **pip install qutip**: For PyPI, it is possible to use, `pypinfo` ; https://github.com/ofek/pypinfo; Note that with`pypinfo` Google's Big Data queries are not free, but new accounts come with some budget credited. Some data: . *`pip install qutip` data starts in 2016. In 2018, 8000 downloads are reported. For 2019, well over 10,000 downloads are predicted. *`conda install qutip` data starts in March 2017. For 2018, 30,000 downloads have been performed. This data is useful to gauge the effective popularity of the two package managers and distribution platforms and can help in setting priorities for relative support and bug fixing. . ## Anaconda downloads; <img width=""441"" alt=""qutip-conda-forge-downloads"" src=""https://user-images.githubusercontent.com/14573436/57989417-45d94380-7ad5-11e9-9694-623fec86865b.png"">. ## PyPI downloads; ![pip-install-qutip-png](https://user-images.githubusercontent.com/14573436/57979590-df174400-7a5a-11e9-807e-c2f46bbb830e.png). With `pypinfo` we can also easily extract other information on users' machines details, such as python usage, which can provide guidance on aspects: . ### Python version; #### 2018; | python_version | percent | download_count |; | -------------- | ------: | -------------: |; | 3.6 | 47.33% | 4,079 |; | 2.7 | 24.25% | 2,090 |; | 3.7 | 13.97% | 1,204 |; | 3.5 | 12.43% | 1,071 |; | 3.4 | 1.94% | 167 |; | 2.6 | 0.09% | 8 |; | Total | | 8,619 |. #### 2017; | python_version | percent | download_count |; | -------------- | ------: | -------------: |; | 2.7 | 51.55% | 4,333 |; | 3.6 | 22.13% | 1,860 |; | 3.5 | 19.73% | 1,658 |; | 3.4 | 6.00% | 504 |; | 3.3 | 0.35% | 29 |; | 2.6 | 0.18% | 15 |; | 3.7 | 0.05% | 4 |; | 3",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/997
https://github.com/qutip/qutip/issues/997:1158,Availability,down,downloads,1158,"p.github.io) and possibly have a development notebook (or in a personal repository) showing them updated, for QuTiP presentations. . * **conda install qutip**: For conda-forge, it is possible to use the `anaconda-package-data` with `dask` and `intake`, ; https://github.com/ContinuumIO/anaconda-package-data. * **pip install qutip**: For PyPI, it is possible to use, `pypinfo` ; https://github.com/ofek/pypinfo; Note that with`pypinfo` Google's Big Data queries are not free, but new accounts come with some budget credited. Some data: . *`pip install qutip` data starts in 2016. In 2018, 8000 downloads are reported. For 2019, well over 10,000 downloads are predicted. *`conda install qutip` data starts in March 2017. For 2018, 30,000 downloads have been performed. This data is useful to gauge the effective popularity of the two package managers and distribution platforms and can help in setting priorities for relative support and bug fixing. . ## Anaconda downloads; <img width=""441"" alt=""qutip-conda-forge-downloads"" src=""https://user-images.githubusercontent.com/14573436/57989417-45d94380-7ad5-11e9-9694-623fec86865b.png"">. ## PyPI downloads; ![pip-install-qutip-png](https://user-images.githubusercontent.com/14573436/57979590-df174400-7a5a-11e9-807e-c2f46bbb830e.png). With `pypinfo` we can also easily extract other information on users' machines details, such as python usage, which can provide guidance on aspects: . ### Python version; #### 2018; | python_version | percent | download_count |; | -------------- | ------: | -------------: |; | 3.6 | 47.33% | 4,079 |; | 2.7 | 24.25% | 2,090 |; | 3.7 | 13.97% | 1,204 |; | 3.5 | 12.43% | 1,071 |; | 3.4 | 1.94% | 167 |; | 2.6 | 0.09% | 8 |; | Total | | 8,619 |. #### 2017; | python_version | percent | download_count |; | -------------- | ------: | -------------: |; | 2.7 | 51.55% | 4,333 |; | 3.6 | 22.13% | 1,860 |; | 3.5 | 19.73% | 1,658 |; | 3.4 | 6.00% | 504 |; | 3.3 | 0.35% | 29 |; | 2.6 | 0.18% | 15 |; | 3.7 | 0.05% | 4 |; | 3",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/997
https://github.com/qutip/qutip/issues/997:1286,Availability,down,downloads,1286,"onda-forge, it is possible to use the `anaconda-package-data` with `dask` and `intake`, ; https://github.com/ContinuumIO/anaconda-package-data. * **pip install qutip**: For PyPI, it is possible to use, `pypinfo` ; https://github.com/ofek/pypinfo; Note that with`pypinfo` Google's Big Data queries are not free, but new accounts come with some budget credited. Some data: . *`pip install qutip` data starts in 2016. In 2018, 8000 downloads are reported. For 2019, well over 10,000 downloads are predicted. *`conda install qutip` data starts in March 2017. For 2018, 30,000 downloads have been performed. This data is useful to gauge the effective popularity of the two package managers and distribution platforms and can help in setting priorities for relative support and bug fixing. . ## Anaconda downloads; <img width=""441"" alt=""qutip-conda-forge-downloads"" src=""https://user-images.githubusercontent.com/14573436/57989417-45d94380-7ad5-11e9-9694-623fec86865b.png"">. ## PyPI downloads; ![pip-install-qutip-png](https://user-images.githubusercontent.com/14573436/57979590-df174400-7a5a-11e9-807e-c2f46bbb830e.png). With `pypinfo` we can also easily extract other information on users' machines details, such as python usage, which can provide guidance on aspects: . ### Python version; #### 2018; | python_version | percent | download_count |; | -------------- | ------: | -------------: |; | 3.6 | 47.33% | 4,079 |; | 2.7 | 24.25% | 2,090 |; | 3.7 | 13.97% | 1,204 |; | 3.5 | 12.43% | 1,071 |; | 3.4 | 1.94% | 167 |; | 2.6 | 0.09% | 8 |; | Total | | 8,619 |. #### 2017; | python_version | percent | download_count |; | -------------- | ------: | -------------: |; | 2.7 | 51.55% | 4,333 |; | 3.6 | 22.13% | 1,860 |; | 3.5 | 19.73% | 1,658 |; | 3.4 | 6.00% | 504 |; | 3.3 | 0.35% | 29 |; | 2.6 | 0.18% | 15 |; | 3.7 | 0.05% | 4 |; | 3.2 | 0.02% | 2 |; | Total | | 8,405 |. This information is relevant also regarding #882. About OS:; ### Operating System; #### 2018; | system_name | percent | downloa",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/997
https://github.com/qutip/qutip/issues/997:3179,Availability,down,downloads,3179,"14573436/57989417-45d94380-7ad5-11e9-9694-623fec86865b.png"">. ## PyPI downloads; ![pip-install-qutip-png](https://user-images.githubusercontent.com/14573436/57979590-df174400-7a5a-11e9-807e-c2f46bbb830e.png). With `pypinfo` we can also easily extract other information on users' machines details, such as python usage, which can provide guidance on aspects: . ### Python version; #### 2018; | python_version | percent | download_count |; | -------------- | ------: | -------------: |; | 3.6 | 47.33% | 4,079 |; | 2.7 | 24.25% | 2,090 |; | 3.7 | 13.97% | 1,204 |; | 3.5 | 12.43% | 1,071 |; | 3.4 | 1.94% | 167 |; | 2.6 | 0.09% | 8 |; | Total | | 8,619 |. #### 2017; | python_version | percent | download_count |; | -------------- | ------: | -------------: |; | 2.7 | 51.55% | 4,333 |; | 3.6 | 22.13% | 1,860 |; | 3.5 | 19.73% | 1,658 |; | 3.4 | 6.00% | 504 |; | 3.3 | 0.35% | 29 |; | 2.6 | 0.18% | 15 |; | 3.7 | 0.05% | 4 |; | 3.2 | 0.02% | 2 |; | Total | | 8,405 |. This information is relevant also regarding #882. About OS:; ### Operating System; #### 2018; | system_name | percent | download_count |; | -------------- | ------: | -------------: |; | Linux | 57.25% | 4,934 |; | Windows | 26.15% | 2,254 |; | Darwin | 16.38% | 1,412 |; | CYGWIN_NT-10.0 | 0.08% | 7 |; | FreeBSD | 0.07% | 6 |; | CYGWIN_NT-6.1 | 0.03% | 3 |; | DragonFly | 0.02% | 2 |; | MSYS_NT-10.0 | 0.01% | 1 |; | Total | | 8,619 |. This information is relevant for choices such as #959. . ### Country ; #### 2018; | country | percent | download_count |; | ------- | ------: | -------------: |; | US | 38.07% | 2,355 |; | None | 15.97% | 988 |; | DE | 10.01% | 619 |; | CN | 7.36% | 455 |; | NL | 6.16% | 381 |; | IN | 5.63% | 348 |; | GB | 5.42% | 335 |; | JP | 4.57% | 283 |; | CH | 3.46% | 214 |; | CA | 3.36% | 208 |; | Total | | 6,186 |. This data allows to better understand the user base of QuTiP. . * With google analytics it would be possible to keep track of QuTiP's zipped folder downloads from the qutip.org website.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/997
https://github.com/qutip/qutip/issues/997:241,Deployability,update,updated,241,"QuTiP is hosted on Anaconda's conda-forge channel and on PyPI. I would like to showcase downloads on the [website](https://github.com/qutip/qutip.github.io) and possibly have a development notebook (or in a personal repository) showing them updated, for QuTiP presentations. . * **conda install qutip**: For conda-forge, it is possible to use the `anaconda-package-data` with `dask` and `intake`, ; https://github.com/ContinuumIO/anaconda-package-data. * **pip install qutip**: For PyPI, it is possible to use, `pypinfo` ; https://github.com/ofek/pypinfo; Note that with`pypinfo` Google's Big Data queries are not free, but new accounts come with some budget credited. Some data: . *`pip install qutip` data starts in 2016. In 2018, 8000 downloads are reported. For 2019, well over 10,000 downloads are predicted. *`conda install qutip` data starts in March 2017. For 2018, 30,000 downloads have been performed. This data is useful to gauge the effective popularity of the two package managers and distribution platforms and can help in setting priorities for relative support and bug fixing. . ## Anaconda downloads; <img width=""441"" alt=""qutip-conda-forge-downloads"" src=""https://user-images.githubusercontent.com/14573436/57989417-45d94380-7ad5-11e9-9694-623fec86865b.png"">. ## PyPI downloads; ![pip-install-qutip-png](https://user-images.githubusercontent.com/14573436/57979590-df174400-7a5a-11e9-807e-c2f46bbb830e.png). With `pypinfo` we can also easily extract other information on users' machines details, such as python usage, which can provide guidance on aspects: . ### Python version; #### 2018; | python_version | percent | download_count |; | -------------- | ------: | -------------: |; | 3.6 | 47.33% | 4,079 |; | 2.7 | 24.25% | 2,090 |; | 3.7 | 13.97% | 1,204 |; | 3.5 | 12.43% | 1,071 |; | 3.4 | 1.94% | 167 |; | 2.6 | 0.09% | 8 |; | Total | | 8,619 |. #### 2017; | python_version | percent | download_count |; | -------------- | ------: | -------------: |; | 2.7 | 51.55% | 4,333 |; ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/997
https://github.com/qutip/qutip/issues/997:287,Deployability,install,install,287,"QuTiP is hosted on Anaconda's conda-forge channel and on PyPI. I would like to showcase downloads on the [website](https://github.com/qutip/qutip.github.io) and possibly have a development notebook (or in a personal repository) showing them updated, for QuTiP presentations. . * **conda install qutip**: For conda-forge, it is possible to use the `anaconda-package-data` with `dask` and `intake`, ; https://github.com/ContinuumIO/anaconda-package-data. * **pip install qutip**: For PyPI, it is possible to use, `pypinfo` ; https://github.com/ofek/pypinfo; Note that with`pypinfo` Google's Big Data queries are not free, but new accounts come with some budget credited. Some data: . *`pip install qutip` data starts in 2016. In 2018, 8000 downloads are reported. For 2019, well over 10,000 downloads are predicted. *`conda install qutip` data starts in March 2017. For 2018, 30,000 downloads have been performed. This data is useful to gauge the effective popularity of the two package managers and distribution platforms and can help in setting priorities for relative support and bug fixing. . ## Anaconda downloads; <img width=""441"" alt=""qutip-conda-forge-downloads"" src=""https://user-images.githubusercontent.com/14573436/57989417-45d94380-7ad5-11e9-9694-623fec86865b.png"">. ## PyPI downloads; ![pip-install-qutip-png](https://user-images.githubusercontent.com/14573436/57979590-df174400-7a5a-11e9-807e-c2f46bbb830e.png). With `pypinfo` we can also easily extract other information on users' machines details, such as python usage, which can provide guidance on aspects: . ### Python version; #### 2018; | python_version | percent | download_count |; | -------------- | ------: | -------------: |; | 3.6 | 47.33% | 4,079 |; | 2.7 | 24.25% | 2,090 |; | 3.7 | 13.97% | 1,204 |; | 3.5 | 12.43% | 1,071 |; | 3.4 | 1.94% | 167 |; | 2.6 | 0.09% | 8 |; | Total | | 8,619 |. #### 2017; | python_version | percent | download_count |; | -------------- | ------: | -------------: |; | 2.7 | 51.55% | 4,333 |; ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/997
https://github.com/qutip/qutip/issues/997:461,Deployability,install,install,461,"QuTiP is hosted on Anaconda's conda-forge channel and on PyPI. I would like to showcase downloads on the [website](https://github.com/qutip/qutip.github.io) and possibly have a development notebook (or in a personal repository) showing them updated, for QuTiP presentations. . * **conda install qutip**: For conda-forge, it is possible to use the `anaconda-package-data` with `dask` and `intake`, ; https://github.com/ContinuumIO/anaconda-package-data. * **pip install qutip**: For PyPI, it is possible to use, `pypinfo` ; https://github.com/ofek/pypinfo; Note that with`pypinfo` Google's Big Data queries are not free, but new accounts come with some budget credited. Some data: . *`pip install qutip` data starts in 2016. In 2018, 8000 downloads are reported. For 2019, well over 10,000 downloads are predicted. *`conda install qutip` data starts in March 2017. For 2018, 30,000 downloads have been performed. This data is useful to gauge the effective popularity of the two package managers and distribution platforms and can help in setting priorities for relative support and bug fixing. . ## Anaconda downloads; <img width=""441"" alt=""qutip-conda-forge-downloads"" src=""https://user-images.githubusercontent.com/14573436/57989417-45d94380-7ad5-11e9-9694-623fec86865b.png"">. ## PyPI downloads; ![pip-install-qutip-png](https://user-images.githubusercontent.com/14573436/57979590-df174400-7a5a-11e9-807e-c2f46bbb830e.png). With `pypinfo` we can also easily extract other information on users' machines details, such as python usage, which can provide guidance on aspects: . ### Python version; #### 2018; | python_version | percent | download_count |; | -------------- | ------: | -------------: |; | 3.6 | 47.33% | 4,079 |; | 2.7 | 24.25% | 2,090 |; | 3.7 | 13.97% | 1,204 |; | 3.5 | 12.43% | 1,071 |; | 3.4 | 1.94% | 167 |; | 2.6 | 0.09% | 8 |; | Total | | 8,619 |. #### 2017; | python_version | percent | download_count |; | -------------- | ------: | -------------: |; | 2.7 | 51.55% | 4,333 |; ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/997
https://github.com/qutip/qutip/issues/997:688,Deployability,install,install,688,"QuTiP is hosted on Anaconda's conda-forge channel and on PyPI. I would like to showcase downloads on the [website](https://github.com/qutip/qutip.github.io) and possibly have a development notebook (or in a personal repository) showing them updated, for QuTiP presentations. . * **conda install qutip**: For conda-forge, it is possible to use the `anaconda-package-data` with `dask` and `intake`, ; https://github.com/ContinuumIO/anaconda-package-data. * **pip install qutip**: For PyPI, it is possible to use, `pypinfo` ; https://github.com/ofek/pypinfo; Note that with`pypinfo` Google's Big Data queries are not free, but new accounts come with some budget credited. Some data: . *`pip install qutip` data starts in 2016. In 2018, 8000 downloads are reported. For 2019, well over 10,000 downloads are predicted. *`conda install qutip` data starts in March 2017. For 2018, 30,000 downloads have been performed. This data is useful to gauge the effective popularity of the two package managers and distribution platforms and can help in setting priorities for relative support and bug fixing. . ## Anaconda downloads; <img width=""441"" alt=""qutip-conda-forge-downloads"" src=""https://user-images.githubusercontent.com/14573436/57989417-45d94380-7ad5-11e9-9694-623fec86865b.png"">. ## PyPI downloads; ![pip-install-qutip-png](https://user-images.githubusercontent.com/14573436/57979590-df174400-7a5a-11e9-807e-c2f46bbb830e.png). With `pypinfo` we can also easily extract other information on users' machines details, such as python usage, which can provide guidance on aspects: . ### Python version; #### 2018; | python_version | percent | download_count |; | -------------- | ------: | -------------: |; | 3.6 | 47.33% | 4,079 |; | 2.7 | 24.25% | 2,090 |; | 3.7 | 13.97% | 1,204 |; | 3.5 | 12.43% | 1,071 |; | 3.4 | 1.94% | 167 |; | 2.6 | 0.09% | 8 |; | Total | | 8,619 |. #### 2017; | python_version | percent | download_count |; | -------------- | ------: | -------------: |; | 2.7 | 51.55% | 4,333 |; ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/997
https://github.com/qutip/qutip/issues/997:822,Deployability,install,install,822,"QuTiP is hosted on Anaconda's conda-forge channel and on PyPI. I would like to showcase downloads on the [website](https://github.com/qutip/qutip.github.io) and possibly have a development notebook (or in a personal repository) showing them updated, for QuTiP presentations. . * **conda install qutip**: For conda-forge, it is possible to use the `anaconda-package-data` with `dask` and `intake`, ; https://github.com/ContinuumIO/anaconda-package-data. * **pip install qutip**: For PyPI, it is possible to use, `pypinfo` ; https://github.com/ofek/pypinfo; Note that with`pypinfo` Google's Big Data queries are not free, but new accounts come with some budget credited. Some data: . *`pip install qutip` data starts in 2016. In 2018, 8000 downloads are reported. For 2019, well over 10,000 downloads are predicted. *`conda install qutip` data starts in March 2017. For 2018, 30,000 downloads have been performed. This data is useful to gauge the effective popularity of the two package managers and distribution platforms and can help in setting priorities for relative support and bug fixing. . ## Anaconda downloads; <img width=""441"" alt=""qutip-conda-forge-downloads"" src=""https://user-images.githubusercontent.com/14573436/57989417-45d94380-7ad5-11e9-9694-623fec86865b.png"">. ## PyPI downloads; ![pip-install-qutip-png](https://user-images.githubusercontent.com/14573436/57979590-df174400-7a5a-11e9-807e-c2f46bbb830e.png). With `pypinfo` we can also easily extract other information on users' machines details, such as python usage, which can provide guidance on aspects: . ### Python version; #### 2018; | python_version | percent | download_count |; | -------------- | ------: | -------------: |; | 3.6 | 47.33% | 4,079 |; | 2.7 | 24.25% | 2,090 |; | 3.7 | 13.97% | 1,204 |; | 3.5 | 12.43% | 1,071 |; | 3.4 | 1.94% | 167 |; | 2.6 | 0.09% | 8 |; | Total | | 8,619 |. #### 2017; | python_version | percent | download_count |; | -------------- | ------: | -------------: |; | 2.7 | 51.55% | 4,333 |; ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/997
https://github.com/qutip/qutip/issues/997:1303,Deployability,install,install-qutip-png,1303,"onda-forge, it is possible to use the `anaconda-package-data` with `dask` and `intake`, ; https://github.com/ContinuumIO/anaconda-package-data. * **pip install qutip**: For PyPI, it is possible to use, `pypinfo` ; https://github.com/ofek/pypinfo; Note that with`pypinfo` Google's Big Data queries are not free, but new accounts come with some budget credited. Some data: . *`pip install qutip` data starts in 2016. In 2018, 8000 downloads are reported. For 2019, well over 10,000 downloads are predicted. *`conda install qutip` data starts in March 2017. For 2018, 30,000 downloads have been performed. This data is useful to gauge the effective popularity of the two package managers and distribution platforms and can help in setting priorities for relative support and bug fixing. . ## Anaconda downloads; <img width=""441"" alt=""qutip-conda-forge-downloads"" src=""https://user-images.githubusercontent.com/14573436/57989417-45d94380-7ad5-11e9-9694-623fec86865b.png"">. ## PyPI downloads; ![pip-install-qutip-png](https://user-images.githubusercontent.com/14573436/57979590-df174400-7a5a-11e9-807e-c2f46bbb830e.png). With `pypinfo` we can also easily extract other information on users' machines details, such as python usage, which can provide guidance on aspects: . ### Python version; #### 2018; | python_version | percent | download_count |; | -------------- | ------: | -------------: |; | 3.6 | 47.33% | 4,079 |; | 2.7 | 24.25% | 2,090 |; | 3.7 | 13.97% | 1,204 |; | 3.5 | 12.43% | 1,071 |; | 3.4 | 1.94% | 167 |; | 2.6 | 0.09% | 8 |; | Total | | 8,619 |. #### 2017; | python_version | percent | download_count |; | -------------- | ------: | -------------: |; | 2.7 | 51.55% | 4,333 |; | 3.6 | 22.13% | 1,860 |; | 3.5 | 19.73% | 1,658 |; | 3.4 | 6.00% | 504 |; | 3.3 | 0.35% | 29 |; | 2.6 | 0.18% | 15 |; | 3.7 | 0.05% | 4 |; | 3.2 | 0.02% | 2 |; | Total | | 8,405 |. This information is relevant also regarding #882. About OS:; ### Operating System; #### 2018; | system_name | percent | downloa",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/997
https://github.com/qutip/qutip/issues/997:901,Performance,perform,performed,901,"QuTiP is hosted on Anaconda's conda-forge channel and on PyPI. I would like to showcase downloads on the [website](https://github.com/qutip/qutip.github.io) and possibly have a development notebook (or in a personal repository) showing them updated, for QuTiP presentations. . * **conda install qutip**: For conda-forge, it is possible to use the `anaconda-package-data` with `dask` and `intake`, ; https://github.com/ContinuumIO/anaconda-package-data. * **pip install qutip**: For PyPI, it is possible to use, `pypinfo` ; https://github.com/ofek/pypinfo; Note that with`pypinfo` Google's Big Data queries are not free, but new accounts come with some budget credited. Some data: . *`pip install qutip` data starts in 2016. In 2018, 8000 downloads are reported. For 2019, well over 10,000 downloads are predicted. *`conda install qutip` data starts in March 2017. For 2018, 30,000 downloads have been performed. This data is useful to gauge the effective popularity of the two package managers and distribution platforms and can help in setting priorities for relative support and bug fixing. . ## Anaconda downloads; <img width=""441"" alt=""qutip-conda-forge-downloads"" src=""https://user-images.githubusercontent.com/14573436/57989417-45d94380-7ad5-11e9-9694-623fec86865b.png"">. ## PyPI downloads; ![pip-install-qutip-png](https://user-images.githubusercontent.com/14573436/57979590-df174400-7a5a-11e9-807e-c2f46bbb830e.png). With `pypinfo` we can also easily extract other information on users' machines details, such as python usage, which can provide guidance on aspects: . ### Python version; #### 2018; | python_version | percent | download_count |; | -------------- | ------: | -------------: |; | 3.6 | 47.33% | 4,079 |; | 2.7 | 24.25% | 2,090 |; | 3.7 | 13.97% | 1,204 |; | 3.5 | 12.43% | 1,071 |; | 3.4 | 1.94% | 167 |; | 2.6 | 0.09% | 8 |; | Total | | 8,619 |. #### 2017; | python_version | percent | download_count |; | -------------- | ------: | -------------: |; | 2.7 | 51.55% | 4,333 |; ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/997
https://github.com/qutip/qutip/issues/997:803,Safety,predict,predicted,803,"QuTiP is hosted on Anaconda's conda-forge channel and on PyPI. I would like to showcase downloads on the [website](https://github.com/qutip/qutip.github.io) and possibly have a development notebook (or in a personal repository) showing them updated, for QuTiP presentations. . * **conda install qutip**: For conda-forge, it is possible to use the `anaconda-package-data` with `dask` and `intake`, ; https://github.com/ContinuumIO/anaconda-package-data. * **pip install qutip**: For PyPI, it is possible to use, `pypinfo` ; https://github.com/ofek/pypinfo; Note that with`pypinfo` Google's Big Data queries are not free, but new accounts come with some budget credited. Some data: . *`pip install qutip` data starts in 2016. In 2018, 8000 downloads are reported. For 2019, well over 10,000 downloads are predicted. *`conda install qutip` data starts in March 2017. For 2018, 30,000 downloads have been performed. This data is useful to gauge the effective popularity of the two package managers and distribution platforms and can help in setting priorities for relative support and bug fixing. . ## Anaconda downloads; <img width=""441"" alt=""qutip-conda-forge-downloads"" src=""https://user-images.githubusercontent.com/14573436/57989417-45d94380-7ad5-11e9-9694-623fec86865b.png"">. ## PyPI downloads; ![pip-install-qutip-png](https://user-images.githubusercontent.com/14573436/57979590-df174400-7a5a-11e9-807e-c2f46bbb830e.png). With `pypinfo` we can also easily extract other information on users' machines details, such as python usage, which can provide guidance on aspects: . ### Python version; #### 2018; | python_version | percent | download_count |; | -------------- | ------: | -------------: |; | 3.6 | 47.33% | 4,079 |; | 2.7 | 24.25% | 2,090 |; | 3.7 | 13.97% | 1,204 |; | 3.5 | 12.43% | 1,071 |; | 3.4 | 1.94% | 167 |; | 2.6 | 0.09% | 8 |; | Total | | 8,619 |. #### 2017; | python_version | percent | download_count |; | -------------- | ------: | -------------: |; | 2.7 | 51.55% | 4,333 |; ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/997
https://github.com/qutip/qutip/issues/997:1553,Usability,guid,guidance,1553,"ble to use, `pypinfo` ; https://github.com/ofek/pypinfo; Note that with`pypinfo` Google's Big Data queries are not free, but new accounts come with some budget credited. Some data: . *`pip install qutip` data starts in 2016. In 2018, 8000 downloads are reported. For 2019, well over 10,000 downloads are predicted. *`conda install qutip` data starts in March 2017. For 2018, 30,000 downloads have been performed. This data is useful to gauge the effective popularity of the two package managers and distribution platforms and can help in setting priorities for relative support and bug fixing. . ## Anaconda downloads; <img width=""441"" alt=""qutip-conda-forge-downloads"" src=""https://user-images.githubusercontent.com/14573436/57989417-45d94380-7ad5-11e9-9694-623fec86865b.png"">. ## PyPI downloads; ![pip-install-qutip-png](https://user-images.githubusercontent.com/14573436/57979590-df174400-7a5a-11e9-807e-c2f46bbb830e.png). With `pypinfo` we can also easily extract other information on users' machines details, such as python usage, which can provide guidance on aspects: . ### Python version; #### 2018; | python_version | percent | download_count |; | -------------- | ------: | -------------: |; | 3.6 | 47.33% | 4,079 |; | 2.7 | 24.25% | 2,090 |; | 3.7 | 13.97% | 1,204 |; | 3.5 | 12.43% | 1,071 |; | 3.4 | 1.94% | 167 |; | 2.6 | 0.09% | 8 |; | Total | | 8,619 |. #### 2017; | python_version | percent | download_count |; | -------------- | ------: | -------------: |; | 2.7 | 51.55% | 4,333 |; | 3.6 | 22.13% | 1,860 |; | 3.5 | 19.73% | 1,658 |; | 3.4 | 6.00% | 504 |; | 3.3 | 0.35% | 29 |; | 2.6 | 0.18% | 15 |; | 3.7 | 0.05% | 4 |; | 3.2 | 0.02% | 2 |; | Total | | 8,405 |. This information is relevant also regarding #882. About OS:; ### Operating System; #### 2018; | system_name | percent | download_count |; | -------------- | ------: | -------------: |; | Linux | 57.25% | 4,934 |; | Windows | 26.15% | 2,254 |; | Darwin | 16.38% | 1,412 |; | CYGWIN_NT-10.0 | 0.08% | 7 |; | FreeBSD | 0",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/997
https://github.com/qutip/qutip/pull/998:763,Modifiability,refactor,refactoring,763,"This PR suggests enhancing the `qutip.metrics` module by adding a new distance b/w quantum states: the quantum Hellinger distance (QHD), implemented as new function `qutip.metrics.hellinger_dist()`. Excellent description is provided for example in:; _Geometric measures of quantum correlations with Bures and Hellinger distances_, D. Spehner, F. Illuminati, M. Orszag, W. Roga, https://arxiv.org/abs/1611.03449. Albeit a bit less popular than already implemented Bures and trace distances, the QHD is actively studied, eg:; https://arxiv.org/abs/1903.10455; https://arxiv.org/abs/1806.10814; https://arxiv.org/abs/1510.06995. The PR contains tests of properties of the QHD as outlined in arXiv:1611.03449. I am of course keen on performing additional tests, code refactoring, documentation of this feature etc.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/998
https://github.com/qutip/qutip/pull/998:729,Performance,perform,performing,729,"This PR suggests enhancing the `qutip.metrics` module by adding a new distance b/w quantum states: the quantum Hellinger distance (QHD), implemented as new function `qutip.metrics.hellinger_dist()`. Excellent description is provided for example in:; _Geometric measures of quantum correlations with Bures and Hellinger distances_, D. Spehner, F. Illuminati, M. Orszag, W. Roga, https://arxiv.org/abs/1611.03449. Albeit a bit less popular than already implemented Bures and trace distances, the QHD is actively studied, eg:; https://arxiv.org/abs/1903.10455; https://arxiv.org/abs/1806.10814; https://arxiv.org/abs/1510.06995. The PR contains tests of properties of the QHD as outlined in arXiv:1611.03449. I am of course keen on performing additional tests, code refactoring, documentation of this feature etc.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/998
https://github.com/qutip/qutip/pull/998:642,Testability,test,tests,642,"This PR suggests enhancing the `qutip.metrics` module by adding a new distance b/w quantum states: the quantum Hellinger distance (QHD), implemented as new function `qutip.metrics.hellinger_dist()`. Excellent description is provided for example in:; _Geometric measures of quantum correlations with Bures and Hellinger distances_, D. Spehner, F. Illuminati, M. Orszag, W. Roga, https://arxiv.org/abs/1611.03449. Albeit a bit less popular than already implemented Bures and trace distances, the QHD is actively studied, eg:; https://arxiv.org/abs/1903.10455; https://arxiv.org/abs/1806.10814; https://arxiv.org/abs/1510.06995. The PR contains tests of properties of the QHD as outlined in arXiv:1611.03449. I am of course keen on performing additional tests, code refactoring, documentation of this feature etc.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/998
https://github.com/qutip/qutip/pull/998:751,Testability,test,tests,751,"This PR suggests enhancing the `qutip.metrics` module by adding a new distance b/w quantum states: the quantum Hellinger distance (QHD), implemented as new function `qutip.metrics.hellinger_dist()`. Excellent description is provided for example in:; _Geometric measures of quantum correlations with Bures and Hellinger distances_, D. Spehner, F. Illuminati, M. Orszag, W. Roga, https://arxiv.org/abs/1611.03449. Albeit a bit less popular than already implemented Bures and trace distances, the QHD is actively studied, eg:; https://arxiv.org/abs/1903.10455; https://arxiv.org/abs/1806.10814; https://arxiv.org/abs/1510.06995. The PR contains tests of properties of the QHD as outlined in arXiv:1611.03449. I am of course keen on performing additional tests, code refactoring, documentation of this feature etc.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/998
https://github.com/qutip/qutip/issues/999:1435,Availability,avail,available,1435,"Hi,. With scipy 1.3, QuTip is unimportable. The exact traceback is . ```python; In [1]: import qutip; ---------------------------------------------------------------------------; ImportError Traceback (most recent call last); <ipython-input-1-e01d5608f34f> in <module>(); ----> 1 import qutip. /usr/lib/python3.6/site-packages/qutip/__init__.py in <module>(); 169 ; 170 # core; --> 171 from qutip.qobj import *; 172 from qutip.states import *; 173 from qutip.operators import *. /usr/lib/python3.6/site-packages/qutip/qobj.py in <module>(); 58 import qutip.settings as settings; 59 from qutip import __version__; ---> 60 from qutip.fastsparse import fast_csr_matrix, fast_identity; 61 from qutip.cy.ptrace import _ptrace; 62 from qutip.permute import _permute. /usrl/lib/python3.6/site-packages/qutip/fastsparse.py in <module>(); 35 from scipy.sparse import (_sparsetools, isspmatrix, isspmatrix_csr,; 36 csr_matrix, coo_matrix, csc_matrix, dia_matrix); ---> 37 from scipy.sparse.sputils import (upcast, upcast_char, to_native, isdense, isshape,; 38 getdtype, isscalarlike, IndexMixin, get_index_dtype); 39 from scipy.sparse.base import spmatrix, isspmatrix, SparseEfficiencyWarning. ImportError: cannot import name 'IndexMixin'. ```. And actually `IndexMixin` is no longuer in `scipy.sparse.sputils`. It seems to be now in `scipy/sparse/_index.py `. It's maybe trivial to fix, but I don't have time right now. In few weeks I could be available for help if needed.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/999
https://github.com/qutip/qutip/pull/1000:0,Deployability,Update,Update,0,Update to account for moved function in scipy 1.3.; This increase the minimum requirement to scipy 1.0,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1000
https://github.com/qutip/qutip/issues/1002:12,Usability,learn,learning,12,"Hi all, I'm learning to use this great package and I've found it very helpful, but I'm having trouble looking for thermal equilibrium density operator, $e^{-\beta H}$. There is a thermal density matrix constructor `thermal_dm` in this package but it seems to be too simple for my purpose. Any advice on how to calculate this value? Thank you all in advance.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1002
https://github.com/qutip/qutip/issues/1002:266,Usability,simpl,simple,266,"Hi all, I'm learning to use this great package and I've found it very helpful, but I'm having trouble looking for thermal equilibrium density operator, $e^{-\beta H}$. There is a thermal density matrix constructor `thermal_dm` in this package but it seems to be too simple for my purpose. Any advice on how to calculate this value? Thank you all in advance.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1002
https://github.com/qutip/qutip/issues/1004:486,Deployability,install,installed,486,"```; Python 3.6.7 (default, Oct 22 2018, 11:32:17) ; [GCC 8.2.0] on linux; Type ""help"", ""copyright"", ""credits"" or ""license"" for more information.; >>> from qutip.ipynbtools import version_table; >>> version_table(); Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; File ""/home/mmmm1998/.local/lib/python3.6/site-packages/qutip/ipynbtools.py"", line 103, in version_table; (""Number of CPUs"", qutip.hardware_info.hardware_info()['cpus']),; KeyError: 'cpus'; ```. I installed qutip version 4.3.1 via pip3.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1004
https://github.com/qutip/qutip/issues/1530:253,Usability,learn,learn,253,"It could be nice to highlight also graphically the contents of the documentation and/or tutorials, using [`sphinx-gallery`](https://github.com/sphinx-gallery/sphinx-gallery). This could even be added to the website, as it is the case for https://scikit-learn.org, I think.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1530
https://github.com/qutip/qutip/pull/1007:2,Deployability,update,updated,2,I updated the use of Iterable and now there is no warning for it in the tests mentioned in #1003.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1007
https://github.com/qutip/qutip/pull/1007:72,Testability,test,tests,72,I updated the use of Iterable and now there is no warning for it in the tests mentioned in #1003.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1007
https://github.com/qutip/qutip/issues/1008:122,Availability,error,error,122,"I'm teaching a course where we use QuTiP, but recently we cannot import QuTiP anymore : /. The procedure to reproduce the error is to open a new notebook in [colab](http://colab.research.google.com/), install QuTiP with . !pip install qutip. and then just. import qutip. The error in this case is . AttributeError Traceback (most recent call last); /usr/local/lib/python3.6/dist-packages/qutip/__init__.py in <module>(); 46 __IPYTHON__; ---> 47 qutip.settings.ipython = True; 48 except:. AttributeError: module 'qutip' has no attribute 'settings'. During handling of the above exception, another exception occurred:. AttributeError Traceback (most recent call last); <ipython-input-6-e01d5608f34f> in <module>(); ----> 1 import qutip. /usr/local/lib/python3.6/dist-packages/qutip/__init__.py in <module>(); 47 qutip.settings.ipython = True; 48 except:; ---> 49 qutip.settings.ipython = False; 50 ; 51 # -----------------------------------------------------------------------------. AttributeError: module 'qutip' has no attribute 'settings'",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1008
https://github.com/qutip/qutip/issues/1008:275,Availability,error,error,275,"I'm teaching a course where we use QuTiP, but recently we cannot import QuTiP anymore : /. The procedure to reproduce the error is to open a new notebook in [colab](http://colab.research.google.com/), install QuTiP with . !pip install qutip. and then just. import qutip. The error in this case is . AttributeError Traceback (most recent call last); /usr/local/lib/python3.6/dist-packages/qutip/__init__.py in <module>(); 46 __IPYTHON__; ---> 47 qutip.settings.ipython = True; 48 except:. AttributeError: module 'qutip' has no attribute 'settings'. During handling of the above exception, another exception occurred:. AttributeError Traceback (most recent call last); <ipython-input-6-e01d5608f34f> in <module>(); ----> 1 import qutip. /usr/local/lib/python3.6/dist-packages/qutip/__init__.py in <module>(); 47 qutip.settings.ipython = True; 48 except:; ---> 49 qutip.settings.ipython = False; 50 ; 51 # -----------------------------------------------------------------------------. AttributeError: module 'qutip' has no attribute 'settings'",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1008
https://github.com/qutip/qutip/issues/1008:201,Deployability,install,install,201,"I'm teaching a course where we use QuTiP, but recently we cannot import QuTiP anymore : /. The procedure to reproduce the error is to open a new notebook in [colab](http://colab.research.google.com/), install QuTiP with . !pip install qutip. and then just. import qutip. The error in this case is . AttributeError Traceback (most recent call last); /usr/local/lib/python3.6/dist-packages/qutip/__init__.py in <module>(); 46 __IPYTHON__; ---> 47 qutip.settings.ipython = True; 48 except:. AttributeError: module 'qutip' has no attribute 'settings'. During handling of the above exception, another exception occurred:. AttributeError Traceback (most recent call last); <ipython-input-6-e01d5608f34f> in <module>(); ----> 1 import qutip. /usr/local/lib/python3.6/dist-packages/qutip/__init__.py in <module>(); 47 qutip.settings.ipython = True; 48 except:; ---> 49 qutip.settings.ipython = False; 50 ; 51 # -----------------------------------------------------------------------------. AttributeError: module 'qutip' has no attribute 'settings'",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1008
https://github.com/qutip/qutip/issues/1008:227,Deployability,install,install,227,"I'm teaching a course where we use QuTiP, but recently we cannot import QuTiP anymore : /. The procedure to reproduce the error is to open a new notebook in [colab](http://colab.research.google.com/), install QuTiP with . !pip install qutip. and then just. import qutip. The error in this case is . AttributeError Traceback (most recent call last); /usr/local/lib/python3.6/dist-packages/qutip/__init__.py in <module>(); 46 __IPYTHON__; ---> 47 qutip.settings.ipython = True; 48 except:. AttributeError: module 'qutip' has no attribute 'settings'. During handling of the above exception, another exception occurred:. AttributeError Traceback (most recent call last); <ipython-input-6-e01d5608f34f> in <module>(); ----> 1 import qutip. /usr/local/lib/python3.6/dist-packages/qutip/__init__.py in <module>(); 47 qutip.settings.ipython = True; 48 except:; ---> 49 qutip.settings.ipython = False; 50 ; 51 # -----------------------------------------------------------------------------. AttributeError: module 'qutip' has no attribute 'settings'",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1008
https://github.com/qutip/qutip/issues/1009:58,Deployability,install,installing,58,The following files get generated in the user's root when installing QuTiP: ; rhs77050.pyx; rhs77051.pyx; rhs77052.pyx; rhs77053.pyx; rhs77054.pyx; rhs77055.pyx; rhs77056.pyx; rhs77057.pyx; rhs77058.pyx; An example of the content is here https://gist.github.com/nathanshammah/7054fd9954d0e5abe17db1d1981903d4.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1009
https://github.com/qutip/qutip/pull/1010:258,Availability,error,error,258,"Photocurrent did not handle having 2 or more collapses in the same time step properly and the state became unnormalized in those case. This PR limit the number of collapse to 1 per time step.; It does it in a rough way and still have an avoidable `O(dt**2)` error, but it does not force to throw away the trajectory.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1010
https://github.com/qutip/qutip/pull/1010:237,Safety,avoid,avoidable,237,"Photocurrent did not handle having 2 or more collapses in the same time step properly and the state became unnormalized in those case. This PR limit the number of collapse to 1 per time step.; It does it in a rough way and still have an avoidable `O(dt**2)` error, but it does not force to throw away the trajectory.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1010
https://github.com/qutip/qutip/pull/1012:599,Modifiability,refactor,refactor,599,"Here is the newly implemented method for the `qip` module. I implemented a class `OptPulseProcessor`, which is the subclass of `circuitprocessor` in `qip.models`. It is defined by a set of Hamiltonians, usually determined by the hardware realization. It can take a `QubitsCircuit`, find the corresponding Hamiltonian representation of it (`self.load_circuit`) with `optaoptimize_pulse_unitary ` and then use these control pulses to simulate the circuit at the level of driven Hamiltonian (`self.run_state`). . A large part of it is actually more general and can be moved to circuitprocessor after I refactor `cqed `and `spinchain`. Glad to hear if you have any suggestions.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1012
https://github.com/qutip/qutip/pull/1013:16,Availability,error,error,16,Fix a docstring error prompting a segmentation fault when run on python 3.7.3 on Mac Mojave.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1013
https://github.com/qutip/qutip/pull/1013:47,Availability,fault,fault,47,Fix a docstring error prompting a segmentation fault when run on python 3.7.3 on Mac Mojave.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1013
https://github.com/qutip/qutip/issues/1015:214,Availability,error,error,214,"I am new to Qutip and I installed 4.3.1, and I was just trying to run the steady state solvers optomechanical script that was on Qutip's example notebooks. Running the cell ""Run Steady State Solvers"" Gives me this error:; ---------------------------------------------------------------------------; Exception Traceback (most recent call last); <ipython-input-14-e1b88270a1b6> in <module>; 8 use_rcm = False; 9 rho_ss, info = steadystate(H, c_ops, method=ss, use_precond=True, ; ---> 10 use_rcm=use_rcm, tol=1e-15, return_info=True); 11 print(ss,'solution time =',info['solution_time']); 12 rho_mech = ptrace(rho_ss, 1). /anaconda3/lib/python3.6/site-packages/qutip/steadystate.py in steadystate(A, c_op_list, method, solver, **kwargs); 271 else:; 272 raise Exception(; --> 273 ""Invalid keyword argument '""+key+""' passed to steadystate.""); 274 ; 275 # Set column perm to NATURAL if using RCM and not specified by user. Exception: Invalid keyword argument 'use_precond' passed to steadystate. and I cannot seem to get around it. I am not sure why its not working, I tried to install 4.3.0 instead and it still did not function. It runs if I comment out the use_precond but I am not sure why its giving me this error and how to proceed from here.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1015
https://github.com/qutip/qutip/issues/1015:1208,Availability,error,error,1208,"I am new to Qutip and I installed 4.3.1, and I was just trying to run the steady state solvers optomechanical script that was on Qutip's example notebooks. Running the cell ""Run Steady State Solvers"" Gives me this error:; ---------------------------------------------------------------------------; Exception Traceback (most recent call last); <ipython-input-14-e1b88270a1b6> in <module>; 8 use_rcm = False; 9 rho_ss, info = steadystate(H, c_ops, method=ss, use_precond=True, ; ---> 10 use_rcm=use_rcm, tol=1e-15, return_info=True); 11 print(ss,'solution time =',info['solution_time']); 12 rho_mech = ptrace(rho_ss, 1). /anaconda3/lib/python3.6/site-packages/qutip/steadystate.py in steadystate(A, c_op_list, method, solver, **kwargs); 271 else:; 272 raise Exception(; --> 273 ""Invalid keyword argument '""+key+""' passed to steadystate.""); 274 ; 275 # Set column perm to NATURAL if using RCM and not specified by user. Exception: Invalid keyword argument 'use_precond' passed to steadystate. and I cannot seem to get around it. I am not sure why its not working, I tried to install 4.3.0 instead and it still did not function. It runs if I comment out the use_precond but I am not sure why its giving me this error and how to proceed from here.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1015
https://github.com/qutip/qutip/issues/1015:24,Deployability,install,installed,24,"I am new to Qutip and I installed 4.3.1, and I was just trying to run the steady state solvers optomechanical script that was on Qutip's example notebooks. Running the cell ""Run Steady State Solvers"" Gives me this error:; ---------------------------------------------------------------------------; Exception Traceback (most recent call last); <ipython-input-14-e1b88270a1b6> in <module>; 8 use_rcm = False; 9 rho_ss, info = steadystate(H, c_ops, method=ss, use_precond=True, ; ---> 10 use_rcm=use_rcm, tol=1e-15, return_info=True); 11 print(ss,'solution time =',info['solution_time']); 12 rho_mech = ptrace(rho_ss, 1). /anaconda3/lib/python3.6/site-packages/qutip/steadystate.py in steadystate(A, c_op_list, method, solver, **kwargs); 271 else:; 272 raise Exception(; --> 273 ""Invalid keyword argument '""+key+""' passed to steadystate.""); 274 ; 275 # Set column perm to NATURAL if using RCM and not specified by user. Exception: Invalid keyword argument 'use_precond' passed to steadystate. and I cannot seem to get around it. I am not sure why its not working, I tried to install 4.3.0 instead and it still did not function. It runs if I comment out the use_precond but I am not sure why its giving me this error and how to proceed from here.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1015
https://github.com/qutip/qutip/issues/1015:1073,Deployability,install,install,1073,"I am new to Qutip and I installed 4.3.1, and I was just trying to run the steady state solvers optomechanical script that was on Qutip's example notebooks. Running the cell ""Run Steady State Solvers"" Gives me this error:; ---------------------------------------------------------------------------; Exception Traceback (most recent call last); <ipython-input-14-e1b88270a1b6> in <module>; 8 use_rcm = False; 9 rho_ss, info = steadystate(H, c_ops, method=ss, use_precond=True, ; ---> 10 use_rcm=use_rcm, tol=1e-15, return_info=True); 11 print(ss,'solution time =',info['solution_time']); 12 rho_mech = ptrace(rho_ss, 1). /anaconda3/lib/python3.6/site-packages/qutip/steadystate.py in steadystate(A, c_op_list, method, solver, **kwargs); 271 else:; 272 raise Exception(; --> 273 ""Invalid keyword argument '""+key+""' passed to steadystate.""); 274 ; 275 # Set column perm to NATURAL if using RCM and not specified by user. Exception: Invalid keyword argument 'use_precond' passed to steadystate. and I cannot seem to get around it. I am not sure why its not working, I tried to install 4.3.0 instead and it still did not function. It runs if I comment out the use_precond but I am not sure why its giving me this error and how to proceed from here.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1015
https://github.com/qutip/qutip/issues/1016:607,Availability,error,error,607,"The following codes come from the documentation of mcsolver; http://qutip.org/docs/latest/guide/dynamics/dynamics-monte.html; ```; from qutip import *; import numpy as np; times = np.linspace(0.0, 10.0, 200); psi0 = tensor(fock(2, 0), fock(10, 5)); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); H = 2 * np.pi * a.dag() * a + 2 * np.pi * sm.dag() * sm + 2 * np.pi * 0.25 * (sm * a.dag() + sm.dag() * a); data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]); ```; Sofar it is fine, but if I now try to print `data` with; ```; print(data); ```; The following error shows up in either Ipython or Jupyter Notebook; ```; c:\users\boxi\onedrive\studium\qutip-project\qutip\qutip\solver.py in __str__(self); 272 s += ""missing solver information.\n""; 273 s += ""-"" * (len(s) - 1) + ""\n""; --> 274 if self.states is not None and len(self.states) > 0:; 275 s += ""states = True\n""; 276 elif self.expect is not None and len(self.expect) > 0:; TypeError: len() of unsized object; ```; It is because in the default option is `store_states=False`. Maybe `self.states` should be initialized as e.g. an empty list.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1016
https://github.com/qutip/qutip/issues/1016:90,Usability,guid,guide,90,"The following codes come from the documentation of mcsolver; http://qutip.org/docs/latest/guide/dynamics/dynamics-monte.html; ```; from qutip import *; import numpy as np; times = np.linspace(0.0, 10.0, 200); psi0 = tensor(fock(2, 0), fock(10, 5)); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); H = 2 * np.pi * a.dag() * a + 2 * np.pi * sm.dag() * sm + 2 * np.pi * 0.25 * (sm * a.dag() + sm.dag() * a); data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]); ```; Sofar it is fine, but if I now try to print `data` with; ```; print(data); ```; The following error shows up in either Ipython or Jupyter Notebook; ```; c:\users\boxi\onedrive\studium\qutip-project\qutip\qutip\solver.py in __str__(self); 272 s += ""missing solver information.\n""; 273 s += ""-"" * (len(s) - 1) + ""\n""; --> 274 if self.states is not None and len(self.states) > 0:; 275 s += ""states = True\n""; 276 elif self.expect is not None and len(self.expect) > 0:; TypeError: len() of unsized object; ```; It is because in the default option is `store_states=False`. Maybe `self.states` should be initialized as e.g. an empty list.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1016
https://github.com/qutip/qutip/issues/1017:115,Availability,error,errors,115,"We were running the ""Steady State Solvers: Optomechanical System"" from QuTiP examples, but were repeatedly getting errors. Specifically, line 466 of `steadystate.py` tries to query `max_iter_refine` from `ss_args`, but this line is also executed when using a scipy solver, causing a `KeyError`. . We were using scipy specifically so that `use_precond` is a valid option.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1017
https://github.com/qutip/qutip/issues/1018:425,Availability,failure,failures,425,"I followed instruction on http://qutip.org/docs/4.1/installation.html and used pip to install qutip in my python3.5.2 virtualenv directory. All required packages listed under ""General Requirements"" were also installed. pip commands completed fine. I then cd into a directory peer to ""python3.5.2 virtualenv directory"" and launched jupyter notebook. Ran two import commands. Both failed. Any suggestions on how to debug these failures? I restarted firefox and jupyter notebook several times. 1. ""import qutip.testing as qt"" to verify installation; lib/python3.5/site-packages/qutip/__init__.py; 169 ; 170 # core; --> 171 from qutip.qobj import *; 172 from qutip.states import *; 173 from qutip.operators import *. lib/python3.5/site-packages/qutip/qobj.py; 58 import qutip.settings as settings; 59 from qutip import __version__; ---> 60 from qutip.fastsparse import fast_csr_matrix, fast_identity; 61 from qutip.cy.ptrace import _ptrace; 62 from qutip.permute import _permute. lib/python3.5/site-packages/qutip/fastsparse.py; 35 from scipy.sparse import (_sparsetools, isspmatrix, isspmatrix_csr,; 36 csr_matrix, coo_matrix, csc_matrix, dia_matrix); ---> 37 from scipy.sparse.sputils import (upcast, upcast_char, to_native, isdense, isshape,; 38 getdtype, isscalarlike, IndexMixin, get_index_dtype); 39 from scipy.sparse.base import spmatrix, isspmatrix, SparseEfficiencyWarning. ImportError: cannot import name 'IndexMixin'. 2. ""from qutip import *""; lib/python3.5/site-packages/qutip/__init__.py in <module>; 46 __IPYTHON__; ---> 47 qutip.settings.ipython = True; 48 except:. AttributeError: module 'qutip' has no attribute 'settings'. During handling of the above exception, another exception occurred:. AttributeError Traceback (most recent call last); <ipython-input-2-82c62ef8635d> in <module>; ----> 1 from qutip import *. lib/python3.5/site-packages/qutip/__init__.py in <module>; 47 qutip.settings.ipython = True; 48 except:; ---> 49 qutip.settings.ipython = False; 50 . AttributeError: module",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1018
https://github.com/qutip/qutip/issues/1018:52,Deployability,install,installation,52,"I followed instruction on http://qutip.org/docs/4.1/installation.html and used pip to install qutip in my python3.5.2 virtualenv directory. All required packages listed under ""General Requirements"" were also installed. pip commands completed fine. I then cd into a directory peer to ""python3.5.2 virtualenv directory"" and launched jupyter notebook. Ran two import commands. Both failed. Any suggestions on how to debug these failures? I restarted firefox and jupyter notebook several times. 1. ""import qutip.testing as qt"" to verify installation; lib/python3.5/site-packages/qutip/__init__.py; 169 ; 170 # core; --> 171 from qutip.qobj import *; 172 from qutip.states import *; 173 from qutip.operators import *. lib/python3.5/site-packages/qutip/qobj.py; 58 import qutip.settings as settings; 59 from qutip import __version__; ---> 60 from qutip.fastsparse import fast_csr_matrix, fast_identity; 61 from qutip.cy.ptrace import _ptrace; 62 from qutip.permute import _permute. lib/python3.5/site-packages/qutip/fastsparse.py; 35 from scipy.sparse import (_sparsetools, isspmatrix, isspmatrix_csr,; 36 csr_matrix, coo_matrix, csc_matrix, dia_matrix); ---> 37 from scipy.sparse.sputils import (upcast, upcast_char, to_native, isdense, isshape,; 38 getdtype, isscalarlike, IndexMixin, get_index_dtype); 39 from scipy.sparse.base import spmatrix, isspmatrix, SparseEfficiencyWarning. ImportError: cannot import name 'IndexMixin'. 2. ""from qutip import *""; lib/python3.5/site-packages/qutip/__init__.py in <module>; 46 __IPYTHON__; ---> 47 qutip.settings.ipython = True; 48 except:. AttributeError: module 'qutip' has no attribute 'settings'. During handling of the above exception, another exception occurred:. AttributeError Traceback (most recent call last); <ipython-input-2-82c62ef8635d> in <module>; ----> 1 from qutip import *. lib/python3.5/site-packages/qutip/__init__.py in <module>; 47 qutip.settings.ipython = True; 48 except:; ---> 49 qutip.settings.ipython = False; 50 . AttributeError: module",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1018
https://github.com/qutip/qutip/issues/1018:86,Deployability,install,install,86,"I followed instruction on http://qutip.org/docs/4.1/installation.html and used pip to install qutip in my python3.5.2 virtualenv directory. All required packages listed under ""General Requirements"" were also installed. pip commands completed fine. I then cd into a directory peer to ""python3.5.2 virtualenv directory"" and launched jupyter notebook. Ran two import commands. Both failed. Any suggestions on how to debug these failures? I restarted firefox and jupyter notebook several times. 1. ""import qutip.testing as qt"" to verify installation; lib/python3.5/site-packages/qutip/__init__.py; 169 ; 170 # core; --> 171 from qutip.qobj import *; 172 from qutip.states import *; 173 from qutip.operators import *. lib/python3.5/site-packages/qutip/qobj.py; 58 import qutip.settings as settings; 59 from qutip import __version__; ---> 60 from qutip.fastsparse import fast_csr_matrix, fast_identity; 61 from qutip.cy.ptrace import _ptrace; 62 from qutip.permute import _permute. lib/python3.5/site-packages/qutip/fastsparse.py; 35 from scipy.sparse import (_sparsetools, isspmatrix, isspmatrix_csr,; 36 csr_matrix, coo_matrix, csc_matrix, dia_matrix); ---> 37 from scipy.sparse.sputils import (upcast, upcast_char, to_native, isdense, isshape,; 38 getdtype, isscalarlike, IndexMixin, get_index_dtype); 39 from scipy.sparse.base import spmatrix, isspmatrix, SparseEfficiencyWarning. ImportError: cannot import name 'IndexMixin'. 2. ""from qutip import *""; lib/python3.5/site-packages/qutip/__init__.py in <module>; 46 __IPYTHON__; ---> 47 qutip.settings.ipython = True; 48 except:. AttributeError: module 'qutip' has no attribute 'settings'. During handling of the above exception, another exception occurred:. AttributeError Traceback (most recent call last); <ipython-input-2-82c62ef8635d> in <module>; ----> 1 from qutip import *. lib/python3.5/site-packages/qutip/__init__.py in <module>; 47 qutip.settings.ipython = True; 48 except:; ---> 49 qutip.settings.ipython = False; 50 . AttributeError: module",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1018
https://github.com/qutip/qutip/issues/1018:208,Deployability,install,installed,208,"I followed instruction on http://qutip.org/docs/4.1/installation.html and used pip to install qutip in my python3.5.2 virtualenv directory. All required packages listed under ""General Requirements"" were also installed. pip commands completed fine. I then cd into a directory peer to ""python3.5.2 virtualenv directory"" and launched jupyter notebook. Ran two import commands. Both failed. Any suggestions on how to debug these failures? I restarted firefox and jupyter notebook several times. 1. ""import qutip.testing as qt"" to verify installation; lib/python3.5/site-packages/qutip/__init__.py; 169 ; 170 # core; --> 171 from qutip.qobj import *; 172 from qutip.states import *; 173 from qutip.operators import *. lib/python3.5/site-packages/qutip/qobj.py; 58 import qutip.settings as settings; 59 from qutip import __version__; ---> 60 from qutip.fastsparse import fast_csr_matrix, fast_identity; 61 from qutip.cy.ptrace import _ptrace; 62 from qutip.permute import _permute. lib/python3.5/site-packages/qutip/fastsparse.py; 35 from scipy.sparse import (_sparsetools, isspmatrix, isspmatrix_csr,; 36 csr_matrix, coo_matrix, csc_matrix, dia_matrix); ---> 37 from scipy.sparse.sputils import (upcast, upcast_char, to_native, isdense, isshape,; 38 getdtype, isscalarlike, IndexMixin, get_index_dtype); 39 from scipy.sparse.base import spmatrix, isspmatrix, SparseEfficiencyWarning. ImportError: cannot import name 'IndexMixin'. 2. ""from qutip import *""; lib/python3.5/site-packages/qutip/__init__.py in <module>; 46 __IPYTHON__; ---> 47 qutip.settings.ipython = True; 48 except:. AttributeError: module 'qutip' has no attribute 'settings'. During handling of the above exception, another exception occurred:. AttributeError Traceback (most recent call last); <ipython-input-2-82c62ef8635d> in <module>; ----> 1 from qutip import *. lib/python3.5/site-packages/qutip/__init__.py in <module>; 47 qutip.settings.ipython = True; 48 except:; ---> 49 qutip.settings.ipython = False; 50 . AttributeError: module",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1018
https://github.com/qutip/qutip/issues/1018:533,Deployability,install,installation,533,"I followed instruction on http://qutip.org/docs/4.1/installation.html and used pip to install qutip in my python3.5.2 virtualenv directory. All required packages listed under ""General Requirements"" were also installed. pip commands completed fine. I then cd into a directory peer to ""python3.5.2 virtualenv directory"" and launched jupyter notebook. Ran two import commands. Both failed. Any suggestions on how to debug these failures? I restarted firefox and jupyter notebook several times. 1. ""import qutip.testing as qt"" to verify installation; lib/python3.5/site-packages/qutip/__init__.py; 169 ; 170 # core; --> 171 from qutip.qobj import *; 172 from qutip.states import *; 173 from qutip.operators import *. lib/python3.5/site-packages/qutip/qobj.py; 58 import qutip.settings as settings; 59 from qutip import __version__; ---> 60 from qutip.fastsparse import fast_csr_matrix, fast_identity; 61 from qutip.cy.ptrace import _ptrace; 62 from qutip.permute import _permute. lib/python3.5/site-packages/qutip/fastsparse.py; 35 from scipy.sparse import (_sparsetools, isspmatrix, isspmatrix_csr,; 36 csr_matrix, coo_matrix, csc_matrix, dia_matrix); ---> 37 from scipy.sparse.sputils import (upcast, upcast_char, to_native, isdense, isshape,; 38 getdtype, isscalarlike, IndexMixin, get_index_dtype); 39 from scipy.sparse.base import spmatrix, isspmatrix, SparseEfficiencyWarning. ImportError: cannot import name 'IndexMixin'. 2. ""from qutip import *""; lib/python3.5/site-packages/qutip/__init__.py in <module>; 46 __IPYTHON__; ---> 47 qutip.settings.ipython = True; 48 except:. AttributeError: module 'qutip' has no attribute 'settings'. During handling of the above exception, another exception occurred:. AttributeError Traceback (most recent call last); <ipython-input-2-82c62ef8635d> in <module>; ----> 1 from qutip import *. lib/python3.5/site-packages/qutip/__init__.py in <module>; 47 qutip.settings.ipython = True; 48 except:; ---> 49 qutip.settings.ipython = False; 50 . AttributeError: module",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1018
https://github.com/qutip/qutip/issues/1018:508,Testability,test,testing,508,"I followed instruction on http://qutip.org/docs/4.1/installation.html and used pip to install qutip in my python3.5.2 virtualenv directory. All required packages listed under ""General Requirements"" were also installed. pip commands completed fine. I then cd into a directory peer to ""python3.5.2 virtualenv directory"" and launched jupyter notebook. Ran two import commands. Both failed. Any suggestions on how to debug these failures? I restarted firefox and jupyter notebook several times. 1. ""import qutip.testing as qt"" to verify installation; lib/python3.5/site-packages/qutip/__init__.py; 169 ; 170 # core; --> 171 from qutip.qobj import *; 172 from qutip.states import *; 173 from qutip.operators import *. lib/python3.5/site-packages/qutip/qobj.py; 58 import qutip.settings as settings; 59 from qutip import __version__; ---> 60 from qutip.fastsparse import fast_csr_matrix, fast_identity; 61 from qutip.cy.ptrace import _ptrace; 62 from qutip.permute import _permute. lib/python3.5/site-packages/qutip/fastsparse.py; 35 from scipy.sparse import (_sparsetools, isspmatrix, isspmatrix_csr,; 36 csr_matrix, coo_matrix, csc_matrix, dia_matrix); ---> 37 from scipy.sparse.sputils import (upcast, upcast_char, to_native, isdense, isshape,; 38 getdtype, isscalarlike, IndexMixin, get_index_dtype); 39 from scipy.sparse.base import spmatrix, isspmatrix, SparseEfficiencyWarning. ImportError: cannot import name 'IndexMixin'. 2. ""from qutip import *""; lib/python3.5/site-packages/qutip/__init__.py in <module>; 46 __IPYTHON__; ---> 47 qutip.settings.ipython = True; 48 except:. AttributeError: module 'qutip' has no attribute 'settings'. During handling of the above exception, another exception occurred:. AttributeError Traceback (most recent call last); <ipython-input-2-82c62ef8635d> in <module>; ----> 1 from qutip import *. lib/python3.5/site-packages/qutip/__init__.py in <module>; 47 qutip.settings.ipython = True; 48 except:; ---> 49 qutip.settings.ipython = False; 50 . AttributeError: module",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1018
https://github.com/qutip/qutip/issues/1019:1014,Deployability,update,update,1014,"QuTiP cannot be imported after updating Scipy package to version 1.3.0. . Python 3.6.8 (tags/v3.6.8:3c6b436a57, Dec 24 2018, 00:16:47) [MSC v.1916 64 bit (AMD64)] on win32; Type ""help"", ""copyright"", ""credits"" or ""license"" for more information.; >>> import qutip; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; File ""D:\Python\Python36\lib\site-packages\qutip\__init__.py"", line 171, in <module>; from qutip.qobj import *; File ""D:\Python\Python36\lib\site-packages\qutip\qobj.py"", line 60, in <module>; from qutip.fastsparse import fast_csr_matrix, fast_identity; File ""D:\Python\Python36\lib\site-packages\qutip\fastsparse.py"", line 37, in <module>; from scipy.sparse.sputils import (upcast, upcast_char, to_native, isdense, isshape,; ImportError: cannot import name 'IndexMixin'; >>>. I've consulted the problem with the Scipy team and they suggested that:; IndexMixin got moved and changed in gh-7827. It was private though, so QuTiP should not be using it. So would it be possible to update the QuTiP and to fix this problem? Thanks.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1019
https://github.com/qutip/qutip/pull/1022:36,Availability,resilien,resilient,36,"Rework photocurrent code to be more resilient and lower numerical error.; Replace #1010 . euler solver: textbook equation directly used, no more improperly supported multiple collapses.; pred-corr solver: proper support for multiple collapses with no more O(dt) error at each collapses.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1022
https://github.com/qutip/qutip/pull/1022:66,Availability,error,error,66,"Rework photocurrent code to be more resilient and lower numerical error.; Replace #1010 . euler solver: textbook equation directly used, no more improperly supported multiple collapses.; pred-corr solver: proper support for multiple collapses with no more O(dt) error at each collapses.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1022
https://github.com/qutip/qutip/pull/1022:262,Availability,error,error,262,"Rework photocurrent code to be more resilient and lower numerical error.; Replace #1010 . euler solver: textbook equation directly used, no more improperly supported multiple collapses.; pred-corr solver: proper support for multiple collapses with no more O(dt) error at each collapses.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1022
https://github.com/qutip/qutip/issues/1023:209,Usability,progress bar,progress bar,209,"The latest changes in `mcsolve` with option `average_states = False, store_states = True` is much slower than `average_states = True, store_states = True`. . Strangely, the cell runs for much longer after the progress bar is completed.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1023
https://github.com/qutip/qutip/issues/1026:333,Availability,error,error,333,"I am using anaconda and qutip on Win10 system with VS2015 (community version). When solving Hamiltonian with time dependent coefficients, I get an ""ImportError"" that caused by cython which does not occur on linux. I've re-installed VS2015 and qutip many times, but this problem still exists. Is there any way to solve it? Here is my error message. **ImportError: Building module rhs22280 failed: [""distutils.errors.CompileError: command 'C:\\\\Program Files (x86)\\\\Microsoft Visual Studio 14.0\\\\VC\\\\bin\\\\cl.exe' failed with exit status 2\n""]**. [error_message.txt](https://github.com/qutip/qutip/files/3317876/error_message.txt)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1026
https://github.com/qutip/qutip/issues/1026:408,Availability,error,errors,408,"I am using anaconda and qutip on Win10 system with VS2015 (community version). When solving Hamiltonian with time dependent coefficients, I get an ""ImportError"" that caused by cython which does not occur on linux. I've re-installed VS2015 and qutip many times, but this problem still exists. Is there any way to solve it? Here is my error message. **ImportError: Building module rhs22280 failed: [""distutils.errors.CompileError: command 'C:\\\\Program Files (x86)\\\\Microsoft Visual Studio 14.0\\\\VC\\\\bin\\\\cl.exe' failed with exit status 2\n""]**. [error_message.txt](https://github.com/qutip/qutip/files/3317876/error_message.txt)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1026
https://github.com/qutip/qutip/issues/1026:222,Deployability,install,installed,222,"I am using anaconda and qutip on Win10 system with VS2015 (community version). When solving Hamiltonian with time dependent coefficients, I get an ""ImportError"" that caused by cython which does not occur on linux. I've re-installed VS2015 and qutip many times, but this problem still exists. Is there any way to solve it? Here is my error message. **ImportError: Building module rhs22280 failed: [""distutils.errors.CompileError: command 'C:\\\\Program Files (x86)\\\\Microsoft Visual Studio 14.0\\\\VC\\\\bin\\\\cl.exe' failed with exit status 2\n""]**. [error_message.txt](https://github.com/qutip/qutip/files/3317876/error_message.txt)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1026
https://github.com/qutip/qutip/issues/1026:114,Integrability,depend,dependent,114,"I am using anaconda and qutip on Win10 system with VS2015 (community version). When solving Hamiltonian with time dependent coefficients, I get an ""ImportError"" that caused by cython which does not occur on linux. I've re-installed VS2015 and qutip many times, but this problem still exists. Is there any way to solve it? Here is my error message. **ImportError: Building module rhs22280 failed: [""distutils.errors.CompileError: command 'C:\\\\Program Files (x86)\\\\Microsoft Visual Studio 14.0\\\\VC\\\\bin\\\\cl.exe' failed with exit status 2\n""]**. [error_message.txt](https://github.com/qutip/qutip/files/3317876/error_message.txt)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1026
https://github.com/qutip/qutip/issues/1026:339,Integrability,message,message,339,"I am using anaconda and qutip on Win10 system with VS2015 (community version). When solving Hamiltonian with time dependent coefficients, I get an ""ImportError"" that caused by cython which does not occur on linux. I've re-installed VS2015 and qutip many times, but this problem still exists. Is there any way to solve it? Here is my error message. **ImportError: Building module rhs22280 failed: [""distutils.errors.CompileError: command 'C:\\\\Program Files (x86)\\\\Microsoft Visual Studio 14.0\\\\VC\\\\bin\\\\cl.exe' failed with exit status 2\n""]**. [error_message.txt](https://github.com/qutip/qutip/files/3317876/error_message.txt)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1026
https://github.com/qutip/qutip/issues/1027:250,Availability,error,error,250,"```; from qutip import *; import numpy as np; #from mayavi import mlab; import matplotlib.pyplot as plt. b = Bloch(); pnt = [1/np.sqrt(3),1/np.sqrt(3),1/np.sqrt(3)]; b.add_points(pnt); Bloch().add_points(pnt); b.show(); qutip.about(); ```; gives the error in a Jupyter notebook:; ```; ---------------------------------------------------------------------------; ValueError Traceback (most recent call last); /miniconda3/lib/python3.7/site-packages/IPython/core/formatters.py in __call__(self, obj); 339 pass; 340 else:; --> 341 return printer(obj); 342 # Finally look for special method names; 343 method = get_real_method(obj, self.print_method). /miniconda3/lib/python3.7/site-packages/IPython/core/pylabtools.py in <lambda>(fig); 242 ; 243 if 'png' in formats:; --> 244 png_formatter.for_type(Figure, lambda fig: print_figure(fig, 'png', **kwargs)); 245 if 'retina' in formats or 'png2x' in formats:; 246 png_formatter.for_type(Figure, lambda fig: retina_figure(fig, **kwargs)). /miniconda3/lib/python3.7/site-packages/IPython/core/pylabtools.py in print_figure(fig, fmt, bbox_inches, **kwargs); 126 ; 127 bytes_io = BytesIO(); --> 128 fig.canvas.print_figure(bytes_io, **kw); 129 data = bytes_io.getvalue(); 130 if fmt == 'svg':. /miniconda3/lib/python3.7/site-packages/matplotlib/backend_bases.py in print_figure(self, filename, dpi, facecolor, edgecolor, orientation, format, bbox_inches, **kwargs); 2054 orientation=orientation,; 2055 dryrun=True,; -> 2056 **kwargs); 2057 renderer = self.figure._cachedRenderer; 2058 bbox_artists = kwargs.pop(""bbox_extra_artists"", None). /miniconda3/lib/python3.7/site-packages/matplotlib/backends/backend_agg.py in print_png(self, filename_or_obj, metadata, pil_kwargs, *args, **kwargs); 525 ; 526 else:; --> 527 FigureCanvasAgg.draw(self); 528 renderer = self.get_renderer(); 529 with cbook._setattr_cm(renderer, dpi=self.figure.dpi), \. /miniconda3/lib/python3.7/site-packages/matplotlib/backends/backend_agg.py in draw(self); 386 self.renderer = self.get_",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1027
https://github.com/qutip/qutip/issues/1027:5880,Availability,error,error,5880,"lly has writebackifcopy semantics. ValueError: operands could not be broadcast together with remapped shapes [original->remapped]: (0,4) and requested shape (2,4). <Figure size 360x360 with 1 Axes>. QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; A. J. Pitchford, P. D. Nation, R. J. Johansson, A. Grimsmo, and C. Granade. QuTiP Version: 4.3.1; Numpy Version: 1.15.4; Scipy Version: 1.2.1; Cython Version: 0.29.8; Matplotlib Version: 3.1.0; Python Version: 3.7.3; Number of CPUs: 2; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /miniconda3/lib/python3.7/site-packages/qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex file can be easily generated using `qutip.cite()`; ```; The error from a python script seems to shed more light into what is happening: ; ```; /miniconda3/lib/python3.7/site-packages/qutip/bloch.py:631: MatplotlibDeprecationWarning: Passing the block parameter of show() positionally is deprecated since Matplotlib 3.1; the parameter will become keyword-only in 3.3.; plt.show(self.fig); Traceback (most recent call last):; File ""/miniconda3/lib/python3.7/site-packages/matplotlib/backends/backend_macosx.py"", line 80, in _draw; self.figure.draw(renderer); File ""/miniconda3/lib/python3.7/site-packages/matplotlib/artist.py"", line 38, in draw_wrapper; return draw(artist, renderer, *args, **kwargs); File ""/miniconda3/lib/python3.7/site-packages/matplotlib/figure.py"", line 1709, in draw; renderer, self, artists, self.suppressComposite); File ""/miniconda3/lib/python3.7/site-packages/matplotlib/image.py"", line 135, in _draw_list_compositing_images; a.draw(renderer); File ""/miniconda3/lib/python3.7/site-packages/matplotlib/artist.py"", line 38, in draw_wrapper; return draw(artist, renderer, *args, **kw",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1027
https://github.com/qutip/qutip/issues/1027:2127,Deployability,update,update,2127,"anvas.print_figure(bytes_io, **kw); 129 data = bytes_io.getvalue(); 130 if fmt == 'svg':. /miniconda3/lib/python3.7/site-packages/matplotlib/backend_bases.py in print_figure(self, filename, dpi, facecolor, edgecolor, orientation, format, bbox_inches, **kwargs); 2054 orientation=orientation,; 2055 dryrun=True,; -> 2056 **kwargs); 2057 renderer = self.figure._cachedRenderer; 2058 bbox_artists = kwargs.pop(""bbox_extra_artists"", None). /miniconda3/lib/python3.7/site-packages/matplotlib/backends/backend_agg.py in print_png(self, filename_or_obj, metadata, pil_kwargs, *args, **kwargs); 525 ; 526 else:; --> 527 FigureCanvasAgg.draw(self); 528 renderer = self.get_renderer(); 529 with cbook._setattr_cm(renderer, dpi=self.figure.dpi), \. /miniconda3/lib/python3.7/site-packages/matplotlib/backends/backend_agg.py in draw(self); 386 self.renderer = self.get_renderer(cleared=True); 387 with RendererAgg.lock:; --> 388 self.figure.draw(self.renderer); 389 # A GUI class may be need to update a window using this draw, so; 390 # don't forget to call the superclass. /miniconda3/lib/python3.7/site-packages/matplotlib/artist.py in draw_wrapper(artist, renderer, *args, **kwargs); 36 renderer.start_filter(); 37 ; ---> 38 return draw(artist, renderer, *args, **kwargs); 39 finally:; 40 if artist.get_agg_filter() is not None:. /miniconda3/lib/python3.7/site-packages/matplotlib/figure.py in draw(self, renderer); 1707 self.patch.draw(renderer); 1708 mimage._draw_list_compositing_images(; -> 1709 renderer, self, artists, self.suppressComposite); 1710 ; 1711 renderer.close_group('figure'). /miniconda3/lib/python3.7/site-packages/matplotlib/image.py in _draw_list_compositing_images(renderer, parent, artists, suppress_composite); 133 if not_composite or not has_images:; 134 for a in artists:; --> 135 a.draw(renderer); 136 else:; 137 # Composite any adjacent images together. /miniconda3/lib/python3.7/site-packages/matplotlib/artist.py in draw_wrapper(artist, renderer, *args, **kwargs); 36 renderer.st",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1027
https://github.com/qutip/qutip/issues/1027:2562,Deployability,patch,patch,2562,"tists"", None). /miniconda3/lib/python3.7/site-packages/matplotlib/backends/backend_agg.py in print_png(self, filename_or_obj, metadata, pil_kwargs, *args, **kwargs); 525 ; 526 else:; --> 527 FigureCanvasAgg.draw(self); 528 renderer = self.get_renderer(); 529 with cbook._setattr_cm(renderer, dpi=self.figure.dpi), \. /miniconda3/lib/python3.7/site-packages/matplotlib/backends/backend_agg.py in draw(self); 386 self.renderer = self.get_renderer(cleared=True); 387 with RendererAgg.lock:; --> 388 self.figure.draw(self.renderer); 389 # A GUI class may be need to update a window using this draw, so; 390 # don't forget to call the superclass. /miniconda3/lib/python3.7/site-packages/matplotlib/artist.py in draw_wrapper(artist, renderer, *args, **kwargs); 36 renderer.start_filter(); 37 ; ---> 38 return draw(artist, renderer, *args, **kwargs); 39 finally:; 40 if artist.get_agg_filter() is not None:. /miniconda3/lib/python3.7/site-packages/matplotlib/figure.py in draw(self, renderer); 1707 self.patch.draw(renderer); 1708 mimage._draw_list_compositing_images(; -> 1709 renderer, self, artists, self.suppressComposite); 1710 ; 1711 renderer.close_group('figure'). /miniconda3/lib/python3.7/site-packages/matplotlib/image.py in _draw_list_compositing_images(renderer, parent, artists, suppress_composite); 133 if not_composite or not has_images:; 134 for a in artists:; --> 135 a.draw(renderer); 136 else:; 137 # Composite any adjacent images together. /miniconda3/lib/python3.7/site-packages/matplotlib/artist.py in draw_wrapper(artist, renderer, *args, **kwargs); 36 renderer.start_filter(); 37 ; ---> 38 return draw(artist, renderer, *args, **kwargs); 39 finally:; 40 if artist.get_agg_filter() is not None:. /miniconda3/lib/python3.7/site-packages/mpl_toolkits/mplot3d/axes3d.py in draw(self, renderer); 290 sorted(self.collections,; 291 key=lambda col: col.do_3d_projection(renderer),; --> 292 reverse=True)):; 293 col.zorder = zorder_offset + i; 294 for i, patch in enumerate(. /miniconda3/lib/",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1027
https://github.com/qutip/qutip/issues/1027:3528,Deployability,patch,patch,3528,"igure.py in draw(self, renderer); 1707 self.patch.draw(renderer); 1708 mimage._draw_list_compositing_images(; -> 1709 renderer, self, artists, self.suppressComposite); 1710 ; 1711 renderer.close_group('figure'). /miniconda3/lib/python3.7/site-packages/matplotlib/image.py in _draw_list_compositing_images(renderer, parent, artists, suppress_composite); 133 if not_composite or not has_images:; 134 for a in artists:; --> 135 a.draw(renderer); 136 else:; 137 # Composite any adjacent images together. /miniconda3/lib/python3.7/site-packages/matplotlib/artist.py in draw_wrapper(artist, renderer, *args, **kwargs); 36 renderer.start_filter(); 37 ; ---> 38 return draw(artist, renderer, *args, **kwargs); 39 finally:; 40 if artist.get_agg_filter() is not None:. /miniconda3/lib/python3.7/site-packages/mpl_toolkits/mplot3d/axes3d.py in draw(self, renderer); 290 sorted(self.collections,; 291 key=lambda col: col.do_3d_projection(renderer),; --> 292 reverse=True)):; 293 col.zorder = zorder_offset + i; 294 for i, patch in enumerate(. /miniconda3/lib/python3.7/site-packages/mpl_toolkits/mplot3d/axes3d.py in <lambda>(col); 289 for i, col in enumerate(; 290 sorted(self.collections,; --> 291 key=lambda col: col.do_3d_projection(renderer),; 292 reverse=True)):; 293 col.zorder = zorder_offset + i. /miniconda3/lib/python3.7/site-packages/mpl_toolkits/mplot3d/art3d.py in do_3d_projection(self, renderer); 543 self.set_facecolors(fcs); 544 ; --> 545 ecs = (_zalpha(self._edgecolor3d, vzs) if self._depthshade else; 546 self._edgecolor3d); 547 ecs = mcolors.to_rgba_array(ecs, self._alpha). /miniconda3/lib/python3.7/site-packages/mpl_toolkits/mplot3d/art3d.py in _zalpha(colors, zs); 845 norm = Normalize(min(zs), max(zs)); 846 sats = 1 - norm(zs) * 0.7; --> 847 rgba = np.broadcast_to(mcolors.to_rgba_array(colors), (len(zs), 4)); 848 return np.column_stack([rgba[:, :3], rgba[:, 3] * sats]); 849 . /miniconda3/lib/python3.7/site-packages/numpy/lib/stride_tricks.py in broadcast_to(array, shape, subok); 1",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1027
https://github.com/qutip/qutip/issues/1027:5452,Deployability,Install,Installed,5452,"roadcast_to(array, shape, subok); 174 [1, 2, 3]]); 175 """"""; --> 176 return _broadcast_to(array, shape, subok=subok, readonly=True); 177 ; 178 . /miniconda3/lib/python3.7/site-packages/numpy/lib/stride_tricks.py in _broadcast_to(array, shape, subok, readonly); 126 it = np.nditer(; 127 (array,), flags=['multi_index', 'refs_ok', 'zerosize_ok'] + extras,; --> 128 op_flags=[op_flag], itershape=shape, order='C'); 129 with it:; 130 # never really has writebackifcopy semantics. ValueError: operands could not be broadcast together with remapped shapes [original->remapped]: (0,4) and requested shape (2,4). <Figure size 360x360 with 1 Axes>. QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; A. J. Pitchford, P. D. Nation, R. J. Johansson, A. Grimsmo, and C. Granade. QuTiP Version: 4.3.1; Numpy Version: 1.15.4; Scipy Version: 1.2.1; Cython Version: 0.29.8; Matplotlib Version: 3.1.0; Python Version: 3.7.3; Number of CPUs: 2; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /miniconda3/lib/python3.7/site-packages/qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex file can be easily generated using `qutip.cite()`; ```; The error from a python script seems to shed more light into what is happening: ; ```; /miniconda3/lib/python3.7/site-packages/qutip/bloch.py:631: MatplotlibDeprecationWarning: Passing the block parameter of show() positionally is deprecated since Matplotlib 3.1; the parameter will become keyword-only in 3.3.; plt.show(self.fig); Traceback (most recent call last):; File ""/miniconda3/lib/python3.7/site-packages/matplotlib/backends/backend_macosx.py"", line 80, in _draw; self.figure.draw(renderer); File ""/miniconda3/lib/python3.7/site-packages/matplotlib/artist.py"", line 38, in draw_wrapper; return draw(a",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1027
https://github.com/qutip/qutip/issues/1027:5524,Deployability,Install,Installation,5524,"roadcast_to(array, shape, subok); 174 [1, 2, 3]]); 175 """"""; --> 176 return _broadcast_to(array, shape, subok=subok, readonly=True); 177 ; 178 . /miniconda3/lib/python3.7/site-packages/numpy/lib/stride_tricks.py in _broadcast_to(array, shape, subok, readonly); 126 it = np.nditer(; 127 (array,), flags=['multi_index', 'refs_ok', 'zerosize_ok'] + extras,; --> 128 op_flags=[op_flag], itershape=shape, order='C'); 129 with it:; 130 # never really has writebackifcopy semantics. ValueError: operands could not be broadcast together with remapped shapes [original->remapped]: (0,4) and requested shape (2,4). <Figure size 360x360 with 1 Axes>. QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; A. J. Pitchford, P. D. Nation, R. J. Johansson, A. Grimsmo, and C. Granade. QuTiP Version: 4.3.1; Numpy Version: 1.15.4; Scipy Version: 1.2.1; Cython Version: 0.29.8; Matplotlib Version: 3.1.0; Python Version: 3.7.3; Number of CPUs: 2; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /miniconda3/lib/python3.7/site-packages/qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex file can be easily generated using `qutip.cite()`; ```; The error from a python script seems to shed more light into what is happening: ; ```; /miniconda3/lib/python3.7/site-packages/qutip/bloch.py:631: MatplotlibDeprecationWarning: Passing the block parameter of show() positionally is deprecated since Matplotlib 3.1; the parameter will become keyword-only in 3.3.; plt.show(self.fig); Traceback (most recent call last):; File ""/miniconda3/lib/python3.7/site-packages/matplotlib/backends/backend_macosx.py"", line 80, in _draw; self.figure.draw(renderer); File ""/miniconda3/lib/python3.7/site-packages/matplotlib/artist.py"", line 38, in draw_wrapper; return draw(a",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1027
https://github.com/qutip/qutip/issues/1027:2010,Usability,clear,cleared,2010,"/IPython/core/pylabtools.py in print_figure(fig, fmt, bbox_inches, **kwargs); 126 ; 127 bytes_io = BytesIO(); --> 128 fig.canvas.print_figure(bytes_io, **kw); 129 data = bytes_io.getvalue(); 130 if fmt == 'svg':. /miniconda3/lib/python3.7/site-packages/matplotlib/backend_bases.py in print_figure(self, filename, dpi, facecolor, edgecolor, orientation, format, bbox_inches, **kwargs); 2054 orientation=orientation,; 2055 dryrun=True,; -> 2056 **kwargs); 2057 renderer = self.figure._cachedRenderer; 2058 bbox_artists = kwargs.pop(""bbox_extra_artists"", None). /miniconda3/lib/python3.7/site-packages/matplotlib/backends/backend_agg.py in print_png(self, filename_or_obj, metadata, pil_kwargs, *args, **kwargs); 525 ; 526 else:; --> 527 FigureCanvasAgg.draw(self); 528 renderer = self.get_renderer(); 529 with cbook._setattr_cm(renderer, dpi=self.figure.dpi), \. /miniconda3/lib/python3.7/site-packages/matplotlib/backends/backend_agg.py in draw(self); 386 self.renderer = self.get_renderer(cleared=True); 387 with RendererAgg.lock:; --> 388 self.figure.draw(self.renderer); 389 # A GUI class may be need to update a window using this draw, so; 390 # don't forget to call the superclass. /miniconda3/lib/python3.7/site-packages/matplotlib/artist.py in draw_wrapper(artist, renderer, *args, **kwargs); 36 renderer.start_filter(); 37 ; ---> 38 return draw(artist, renderer, *args, **kwargs); 39 finally:; 40 if artist.get_agg_filter() is not None:. /miniconda3/lib/python3.7/site-packages/matplotlib/figure.py in draw(self, renderer); 1707 self.patch.draw(renderer); 1708 mimage._draw_list_compositing_images(; -> 1709 renderer, self, artists, self.suppressComposite); 1710 ; 1711 renderer.close_group('figure'). /miniconda3/lib/python3.7/site-packages/matplotlib/image.py in _draw_list_compositing_images(renderer, parent, artists, suppress_composite); 133 if not_composite or not has_images:; 134 for a in artists:; --> 135 a.draw(renderer); 136 else:; 137 # Composite any adjacent images together. /min",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1027
https://github.com/qutip/qutip/issues/1029:1883,Availability,error,error,1883,"_ref = mesolve(H, rho0, times, c_ops, e_ops); #plot_expectation_values(result_ref); #plt.show(). L = liouvillian(H); D = lindblad_dissipator(c_ops[0]); d1_operator = L + D; def d1_rho_func(t, rho_vec):; return d1_operator * rho_vec. B1 = spre(c_ops[0]) + spost(c_ops[0].dag()); B2 = spre(c_ops[0]) + spost(c_ops[0].dag()); def d2_rho_func(t, rho_vec):; e1 = expect_rho_vec(B1.data, rho_vec, False); drho1 = B1 * rho_vec - e1 * rho_vec. e1 = expect_rho_vec(B2.data, rho_vec, False); drho2 = B2 * rho_vec - e1 * rho_vec. return np.vstack([1.0/np.sqrt(2) * drho1, -1.0j/np.sqrt(2) * drho2]); # Everything above is almost the same as the example. I only modified the following part; result = smesolve(H=H*0, rho0=ket2dm(rho0), times=times,; e_ops=e_ops,; d1=d1_rho_func, d2=d2_rho_func,; d2_len=2, ntraj=ntraj, nsubsteps=nsubsteps*2,; dW_factors=[np.sqrt(2/gamma), np.sqrt(2/gamma)],; store_measurement=True, map_func=parallel_map); ```. The error message; ```; ============================= test session starts ==============================; platform darwin -- Python 3.6.8, pytest-3.3.2, py-1.5.2, pluggy-0.6.0; rootdir: /Users/haiwen/PycharmProjects/Qutip_test, inifile:Total run time: 0.13s. test_smesolve2.py:None (test_smesolve2.py); multiprocessing.pool.RemoteTraceback: ; """"""; Traceback (most recent call last):; File ""/Users/haiwen/anaconda3/lib/python3.6/multiprocessing/pool.py"", line 119, in worker; result = (True, func(*args, **kwds)); File ""/Users/haiwen/anaconda3/lib/python3.6/site-packages/qutip/stochastic.py"", line 1040, in _smesolve_single_trajectory; A_ops, dt, dW[:, t_idx, j, :], d1, d2, sso.args); File ""/Users/haiwen/anaconda3/lib/python3.6/site-packages/qutip/stochastic.py"", line 1789, in _rhs_rho_euler_maruyama; dW_len = len(dW[0, :]); IndexError: index 0 is out of bounds for axis 0 with size 0; """""". The above exception was the direct cause of the following exception:; test_smesolve2.py:53: in <module>; store_measurement=True, map_func=parallel_map); ../../anaconda3/lib",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1029
https://github.com/qutip/qutip/issues/1029:3615,Availability,error,errors,3615,"y"", line 1789, in _rhs_rho_euler_maruyama; dW_len = len(dW[0, :]); IndexError: index 0 is out of bounds for axis 0 with size 0; """""". The above exception was the direct cause of the following exception:; test_smesolve2.py:53: in <module>; store_measurement=True, map_func=parallel_map); ../../anaconda3/lib/python3.6/site-packages/qutip/stochastic.py:593: in smesolve; res = _smesolve_generic(sso, sso.options, sso.progress_bar); ../../anaconda3/lib/python3.6/site-packages/qutip/stochastic.py:936: in _smesolve_generic; task_args, task_kwargs, **map_kwargs); ../../anaconda3/lib/python3.6/site-packages/qutip/parallel.py:260: in parallel_map; return [ar.get() for ar in async_res]; ../../anaconda3/lib/python3.6/site-packages/qutip/parallel.py:260: in <listcomp>; return [ar.get() for ar in async_res]; ../../anaconda3/lib/python3.6/multiprocessing/pool.py:644: in get; raise self._value; E IndexError: index 0 is out of bounds for axis 0 with size 0; collected 0 items / 1 errors; ==================================== ERRORS ====================================; ______________________ ERROR collecting test_smesolve2.py ______________________; multiprocessing.pool.RemoteTraceback: ; """"""; Traceback (most recent call last):; File ""/Users/haiwen/anaconda3/lib/python3.6/multiprocessing/pool.py"", line 119, in worker; result = (True, func(*args, **kwds)); File ""/Users/haiwen/anaconda3/lib/python3.6/site-packages/qutip/stochastic.py"", line 1040, in _smesolve_single_trajectory; A_ops, dt, dW[:, t_idx, j, :], d1, d2, sso.args); File ""/Users/haiwen/anaconda3/lib/python3.6/site-packages/qutip/stochastic.py"", line 1789, in _rhs_rho_euler_maruyama; dW_len = len(dW[0, :]); IndexError: index 0 is out of bounds for axis 0 with size 0; """""". The above exception was the direct cause of the following exception:; test_smesolve2.py:53: in <module>; store_measurement=True, map_func=parallel_map); ../../anaconda3/lib/python3.6/site-packages/qutip/stochastic.py:593: in smesolve; res = _smesolve_generic(sso",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1029
https://github.com/qutip/qutip/issues/1029:3660,Availability,ERROR,ERRORS,3660,"y"", line 1789, in _rhs_rho_euler_maruyama; dW_len = len(dW[0, :]); IndexError: index 0 is out of bounds for axis 0 with size 0; """""". The above exception was the direct cause of the following exception:; test_smesolve2.py:53: in <module>; store_measurement=True, map_func=parallel_map); ../../anaconda3/lib/python3.6/site-packages/qutip/stochastic.py:593: in smesolve; res = _smesolve_generic(sso, sso.options, sso.progress_bar); ../../anaconda3/lib/python3.6/site-packages/qutip/stochastic.py:936: in _smesolve_generic; task_args, task_kwargs, **map_kwargs); ../../anaconda3/lib/python3.6/site-packages/qutip/parallel.py:260: in parallel_map; return [ar.get() for ar in async_res]; ../../anaconda3/lib/python3.6/site-packages/qutip/parallel.py:260: in <listcomp>; return [ar.get() for ar in async_res]; ../../anaconda3/lib/python3.6/multiprocessing/pool.py:644: in get; raise self._value; E IndexError: index 0 is out of bounds for axis 0 with size 0; collected 0 items / 1 errors; ==================================== ERRORS ====================================; ______________________ ERROR collecting test_smesolve2.py ______________________; multiprocessing.pool.RemoteTraceback: ; """"""; Traceback (most recent call last):; File ""/Users/haiwen/anaconda3/lib/python3.6/multiprocessing/pool.py"", line 119, in worker; result = (True, func(*args, **kwds)); File ""/Users/haiwen/anaconda3/lib/python3.6/site-packages/qutip/stochastic.py"", line 1040, in _smesolve_single_trajectory; A_ops, dt, dW[:, t_idx, j, :], d1, d2, sso.args); File ""/Users/haiwen/anaconda3/lib/python3.6/site-packages/qutip/stochastic.py"", line 1789, in _rhs_rho_euler_maruyama; dW_len = len(dW[0, :]); IndexError: index 0 is out of bounds for axis 0 with size 0; """""". The above exception was the direct cause of the following exception:; test_smesolve2.py:53: in <module>; store_measurement=True, map_func=parallel_map); ../../anaconda3/lib/python3.6/site-packages/qutip/stochastic.py:593: in smesolve; res = _smesolve_generic(sso",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1029
https://github.com/qutip/qutip/issues/1029:3728,Availability,ERROR,ERROR,3728,"y"", line 1789, in _rhs_rho_euler_maruyama; dW_len = len(dW[0, :]); IndexError: index 0 is out of bounds for axis 0 with size 0; """""". The above exception was the direct cause of the following exception:; test_smesolve2.py:53: in <module>; store_measurement=True, map_func=parallel_map); ../../anaconda3/lib/python3.6/site-packages/qutip/stochastic.py:593: in smesolve; res = _smesolve_generic(sso, sso.options, sso.progress_bar); ../../anaconda3/lib/python3.6/site-packages/qutip/stochastic.py:936: in _smesolve_generic; task_args, task_kwargs, **map_kwargs); ../../anaconda3/lib/python3.6/site-packages/qutip/parallel.py:260: in parallel_map; return [ar.get() for ar in async_res]; ../../anaconda3/lib/python3.6/site-packages/qutip/parallel.py:260: in <listcomp>; return [ar.get() for ar in async_res]; ../../anaconda3/lib/python3.6/multiprocessing/pool.py:644: in get; raise self._value; E IndexError: index 0 is out of bounds for axis 0 with size 0; collected 0 items / 1 errors; ==================================== ERRORS ====================================; ______________________ ERROR collecting test_smesolve2.py ______________________; multiprocessing.pool.RemoteTraceback: ; """"""; Traceback (most recent call last):; File ""/Users/haiwen/anaconda3/lib/python3.6/multiprocessing/pool.py"", line 119, in worker; result = (True, func(*args, **kwds)); File ""/Users/haiwen/anaconda3/lib/python3.6/site-packages/qutip/stochastic.py"", line 1040, in _smesolve_single_trajectory; A_ops, dt, dW[:, t_idx, j, :], d1, d2, sso.args); File ""/Users/haiwen/anaconda3/lib/python3.6/site-packages/qutip/stochastic.py"", line 1789, in _rhs_rho_euler_maruyama; dW_len = len(dW[0, :]); IndexError: index 0 is out of bounds for axis 0 with size 0; """""". The above exception was the direct cause of the following exception:; test_smesolve2.py:53: in <module>; store_measurement=True, map_func=parallel_map); ../../anaconda3/lib/python3.6/site-packages/qutip/stochastic.py:593: in smesolve; res = _smesolve_generic(sso",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1029
https://github.com/qutip/qutip/issues/1029:5338,Availability,error,errors,5338,"0 with size 0; collected 0 items / 1 errors; ==================================== ERRORS ====================================; ______________________ ERROR collecting test_smesolve2.py ______________________; multiprocessing.pool.RemoteTraceback: ; """"""; Traceback (most recent call last):; File ""/Users/haiwen/anaconda3/lib/python3.6/multiprocessing/pool.py"", line 119, in worker; result = (True, func(*args, **kwds)); File ""/Users/haiwen/anaconda3/lib/python3.6/site-packages/qutip/stochastic.py"", line 1040, in _smesolve_single_trajectory; A_ops, dt, dW[:, t_idx, j, :], d1, d2, sso.args); File ""/Users/haiwen/anaconda3/lib/python3.6/site-packages/qutip/stochastic.py"", line 1789, in _rhs_rho_euler_maruyama; dW_len = len(dW[0, :]); IndexError: index 0 is out of bounds for axis 0 with size 0; """""". The above exception was the direct cause of the following exception:; test_smesolve2.py:53: in <module>; store_measurement=True, map_func=parallel_map); ../../anaconda3/lib/python3.6/site-packages/qutip/stochastic.py:593: in smesolve; res = _smesolve_generic(sso, sso.options, sso.progress_bar); ../../anaconda3/lib/python3.6/site-packages/qutip/stochastic.py:936: in _smesolve_generic; task_args, task_kwargs, **map_kwargs); ../../anaconda3/lib/python3.6/site-packages/qutip/parallel.py:260: in parallel_map; return [ar.get() for ar in async_res]; ../../anaconda3/lib/python3.6/site-packages/qutip/parallel.py:260: in <listcomp>; return [ar.get() for ar in async_res]; ../../anaconda3/lib/python3.6/multiprocessing/pool.py:644: in get; raise self._value; E IndexError: index 0 is out of bounds for axis 0 with size 0; ------------------------------- Captured stdout --------------------------------; Total run time: 0.13s; !!!!!!!!!!!!!!!!!!! Interrupted: 1 errors during collection !!!!!!!!!!!!!!!!!!!!; =========================== 1 error in 1.92 seconds ============================; Process finished with exit code 0; ```. Does anyone have suggestions on what is going wrong here? Thanks a lot!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1029
https://github.com/qutip/qutip/issues/1029:5415,Availability,error,error,5415,"0 with size 0; collected 0 items / 1 errors; ==================================== ERRORS ====================================; ______________________ ERROR collecting test_smesolve2.py ______________________; multiprocessing.pool.RemoteTraceback: ; """"""; Traceback (most recent call last):; File ""/Users/haiwen/anaconda3/lib/python3.6/multiprocessing/pool.py"", line 119, in worker; result = (True, func(*args, **kwds)); File ""/Users/haiwen/anaconda3/lib/python3.6/site-packages/qutip/stochastic.py"", line 1040, in _smesolve_single_trajectory; A_ops, dt, dW[:, t_idx, j, :], d1, d2, sso.args); File ""/Users/haiwen/anaconda3/lib/python3.6/site-packages/qutip/stochastic.py"", line 1789, in _rhs_rho_euler_maruyama; dW_len = len(dW[0, :]); IndexError: index 0 is out of bounds for axis 0 with size 0; """""". The above exception was the direct cause of the following exception:; test_smesolve2.py:53: in <module>; store_measurement=True, map_func=parallel_map); ../../anaconda3/lib/python3.6/site-packages/qutip/stochastic.py:593: in smesolve; res = _smesolve_generic(sso, sso.options, sso.progress_bar); ../../anaconda3/lib/python3.6/site-packages/qutip/stochastic.py:936: in _smesolve_generic; task_args, task_kwargs, **map_kwargs); ../../anaconda3/lib/python3.6/site-packages/qutip/parallel.py:260: in parallel_map; return [ar.get() for ar in async_res]; ../../anaconda3/lib/python3.6/site-packages/qutip/parallel.py:260: in <listcomp>; return [ar.get() for ar in async_res]; ../../anaconda3/lib/python3.6/multiprocessing/pool.py:644: in get; raise self._value; E IndexError: index 0 is out of bounds for axis 0 with size 0; ------------------------------- Captured stdout --------------------------------; Total run time: 0.13s; !!!!!!!!!!!!!!!!!!! Interrupted: 1 errors during collection !!!!!!!!!!!!!!!!!!!!; =========================== 1 error in 1.92 seconds ============================; Process finished with exit code 0; ```. Does anyone have suggestions on what is going wrong here? Thanks a lot!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1029
https://github.com/qutip/qutip/issues/1029:1889,Integrability,message,message,1889,"_ref = mesolve(H, rho0, times, c_ops, e_ops); #plot_expectation_values(result_ref); #plt.show(). L = liouvillian(H); D = lindblad_dissipator(c_ops[0]); d1_operator = L + D; def d1_rho_func(t, rho_vec):; return d1_operator * rho_vec. B1 = spre(c_ops[0]) + spost(c_ops[0].dag()); B2 = spre(c_ops[0]) + spost(c_ops[0].dag()); def d2_rho_func(t, rho_vec):; e1 = expect_rho_vec(B1.data, rho_vec, False); drho1 = B1 * rho_vec - e1 * rho_vec. e1 = expect_rho_vec(B2.data, rho_vec, False); drho2 = B2 * rho_vec - e1 * rho_vec. return np.vstack([1.0/np.sqrt(2) * drho1, -1.0j/np.sqrt(2) * drho2]); # Everything above is almost the same as the example. I only modified the following part; result = smesolve(H=H*0, rho0=ket2dm(rho0), times=times,; e_ops=e_ops,; d1=d1_rho_func, d2=d2_rho_func,; d2_len=2, ntraj=ntraj, nsubsteps=nsubsteps*2,; dW_factors=[np.sqrt(2/gamma), np.sqrt(2/gamma)],; store_measurement=True, map_func=parallel_map); ```. The error message; ```; ============================= test session starts ==============================; platform darwin -- Python 3.6.8, pytest-3.3.2, py-1.5.2, pluggy-0.6.0; rootdir: /Users/haiwen/PycharmProjects/Qutip_test, inifile:Total run time: 0.13s. test_smesolve2.py:None (test_smesolve2.py); multiprocessing.pool.RemoteTraceback: ; """"""; Traceback (most recent call last):; File ""/Users/haiwen/anaconda3/lib/python3.6/multiprocessing/pool.py"", line 119, in worker; result = (True, func(*args, **kwds)); File ""/Users/haiwen/anaconda3/lib/python3.6/site-packages/qutip/stochastic.py"", line 1040, in _smesolve_single_trajectory; A_ops, dt, dW[:, t_idx, j, :], d1, d2, sso.args); File ""/Users/haiwen/anaconda3/lib/python3.6/site-packages/qutip/stochastic.py"", line 1789, in _rhs_rho_euler_maruyama; dW_len = len(dW[0, :]); IndexError: index 0 is out of bounds for axis 0 with size 0; """""". The above exception was the direct cause of the following exception:; test_smesolve2.py:53: in <module>; store_measurement=True, map_func=parallel_map); ../../anaconda3/lib",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1029
https://github.com/qutip/qutip/issues/1029:1933,Testability,test,test,1933,"_ref = mesolve(H, rho0, times, c_ops, e_ops); #plot_expectation_values(result_ref); #plt.show(). L = liouvillian(H); D = lindblad_dissipator(c_ops[0]); d1_operator = L + D; def d1_rho_func(t, rho_vec):; return d1_operator * rho_vec. B1 = spre(c_ops[0]) + spost(c_ops[0].dag()); B2 = spre(c_ops[0]) + spost(c_ops[0].dag()); def d2_rho_func(t, rho_vec):; e1 = expect_rho_vec(B1.data, rho_vec, False); drho1 = B1 * rho_vec - e1 * rho_vec. e1 = expect_rho_vec(B2.data, rho_vec, False); drho2 = B2 * rho_vec - e1 * rho_vec. return np.vstack([1.0/np.sqrt(2) * drho1, -1.0j/np.sqrt(2) * drho2]); # Everything above is almost the same as the example. I only modified the following part; result = smesolve(H=H*0, rho0=ket2dm(rho0), times=times,; e_ops=e_ops,; d1=d1_rho_func, d2=d2_rho_func,; d2_len=2, ntraj=ntraj, nsubsteps=nsubsteps*2,; dW_factors=[np.sqrt(2/gamma), np.sqrt(2/gamma)],; store_measurement=True, map_func=parallel_map); ```. The error message; ```; ============================= test session starts ==============================; platform darwin -- Python 3.6.8, pytest-3.3.2, py-1.5.2, pluggy-0.6.0; rootdir: /Users/haiwen/PycharmProjects/Qutip_test, inifile:Total run time: 0.13s. test_smesolve2.py:None (test_smesolve2.py); multiprocessing.pool.RemoteTraceback: ; """"""; Traceback (most recent call last):; File ""/Users/haiwen/anaconda3/lib/python3.6/multiprocessing/pool.py"", line 119, in worker; result = (True, func(*args, **kwds)); File ""/Users/haiwen/anaconda3/lib/python3.6/site-packages/qutip/stochastic.py"", line 1040, in _smesolve_single_trajectory; A_ops, dt, dW[:, t_idx, j, :], d1, d2, sso.args); File ""/Users/haiwen/anaconda3/lib/python3.6/site-packages/qutip/stochastic.py"", line 1789, in _rhs_rho_euler_maruyama; dW_len = len(dW[0, :]); IndexError: index 0 is out of bounds for axis 0 with size 0; """""". The above exception was the direct cause of the following exception:; test_smesolve2.py:53: in <module>; store_measurement=True, map_func=parallel_map); ../../anaconda3/lib",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1029
https://github.com/qutip/qutip/issues/1030:282,Availability,error,error-limits,282,"MacOS Mojave deliberately deleted the `user/include` folder so when compiling cython code, gcc cannot find the headers. I struggled a bit after suddenly updating to the latest MacOS and could find the solution here:. https://programmer.help/blogs/how-to-resolve-pip-install-twisted-error-limits.h-no-such-file-or-directory.html. Just do . ```; open /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg; ```. In case others also update and end up with this error. @nathanshammah",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1030
https://github.com/qutip/qutip/issues/1030:486,Availability,error,error,486,"MacOS Mojave deliberately deleted the `user/include` folder so when compiling cython code, gcc cannot find the headers. I struggled a bit after suddenly updating to the latest MacOS and could find the solution here:. https://programmer.help/blogs/how-to-resolve-pip-install-twisted-error-limits.h-no-such-file-or-directory.html. Just do . ```; open /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg; ```. In case others also update and end up with this error. @nathanshammah",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1030
https://github.com/qutip/qutip/issues/1030:266,Deployability,install,install-twisted-error-limits,266,"MacOS Mojave deliberately deleted the `user/include` folder so when compiling cython code, gcc cannot find the headers. I struggled a bit after suddenly updating to the latest MacOS and could find the solution here:. https://programmer.help/blogs/how-to-resolve-pip-install-twisted-error-limits.h-no-such-file-or-directory.html. Just do . ```; open /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg; ```. In case others also update and end up with this error. @nathanshammah",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1030
https://github.com/qutip/qutip/issues/1030:458,Deployability,update,update,458,"MacOS Mojave deliberately deleted the `user/include` folder so when compiling cython code, gcc cannot find the headers. I struggled a bit after suddenly updating to the latest MacOS and could find the solution here:. https://programmer.help/blogs/how-to-resolve-pip-install-twisted-error-limits.h-no-such-file-or-directory.html. Just do . ```; open /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg; ```. In case others also update and end up with this error. @nathanshammah",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1030
https://github.com/qutip/qutip/issues/1031:1072,Testability,log,logic,1072,"I have tried to modify the grape_unitary() function in [grape.py](https://github.com/qutip/qutip/blob/master/qutip/control/grape.py) also to accommodate open quantum systems. One can use it to generate time varying fields for synthesising unitaries for them.; I have tried to run it for the same system as in this [notebook](https://github.com/qutip/qutip-notebooks/blob/master/examples/control-grape-cnot.ipynb).; > I have run into a problem as to some sets of collapse operators give spurious overlap values. The code seems to work well for the closed system, though it is slower than the original [notebook](https://github.com/qutip/qutip-notebooks/blob/master/examples/control-grape-cnot.ipynb). ; [The code](https://www.dropbox.com/sh/cag7q460a4macw6/AABxPWkpwQBfDv6pt4R2vNg5a?dl=0); I know that qutip has another implementation of GRAPE (along with CRAB) in this [file](https://github.com/qutip/qutip/blob/master/qutip/control/pulseoptim.py) and some others in [control](https://github.com/qutip/qutip/blob/master/qutip/control) folder. But it seemed too dense with logic for me to modify it. Hence I modified [grape.py](https://github.com/qutip/qutip/blob/master/qutip/control/grape.py).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1031
https://github.com/qutip/qutip/issues/1032:26,Availability,error,error,26,Would it be useful to add error bars to mcsolve results once the averages are computed?,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1032
https://github.com/qutip/qutip/pull/1034:57,Testability,test,tests,57,As we don't have a fix for #963 then this PR skips those tests on the `average_gate_fidelity` on Mac for the time being,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1034
https://github.com/qutip/qutip/pull/1036:6,Testability,test,test,6,Small test to see if mac tests would pass with openblas instead of mkl.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1036
https://github.com/qutip/qutip/pull/1036:25,Testability,test,tests,25,Small test to see if mac tests would pass with openblas instead of mkl.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1036
https://github.com/qutip/qutip/pull/1037:0,Deployability,Update,Update,0,Update master with the official version 4.4,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1037
https://github.com/qutip/qutip/issues/1038:4731,Deployability,Install,Installed,4731,"pump = 10'); plt.plot(times, result2.expect[2], label = 'pump = 1'); plt.xlabel('Time (ns)'); plt.ylabel('$\sigma_{11}$'); legend = plt.legend(); plt.savefig(""sigma_11.png""); plt.savefig(""sigma_11.pdf""); output_data = np.vstack((times, result1.expect[2])); file_data_store('sigma_11.dat',output_data.T, numtype = ""real""); output_data = np.vstack((times, result2.expect[2])); file_data_store('sigma_11.dat',output_data.T, numtype = ""real""); plt.title('g=120, nth=$10^{-6}$, T1=$10^{-3}$, T2=1'). plt.figure(); plt.plot(times, result1.expect[3], label = 'pump = 10'); plt.plot(times, result2.expect[3], label = 'pump = 1'); plt.xlabel('Time (ns)'); plt.ylabel('$\sigma_{22}$'); legend = plt.legend(); plt.savefig(""sigma_22.png""); plt.savefig(""sigma_22.pdf""); output_data = np.vstack((times, result1.expect[3])); file_data_store('sigma_22.dat',output_data.T, numtype = ""real""); output_data = np.vstack((times, result2.expect[3])); file_data_store('sigma_22.dat',output_data.T, numtype = ""real""); plt.title('g=120, nth=$10^{-6}$, T1=$10^{-3}$, T2=1'). plt.show(); ```. Being basis elements, the sum of the populations should be 1 and phonon number should not go negative but the plots obtain tell a different story:; [phonon number.pdf](https://github.com/qutip/qutip/files/3360514/phonon.number.pdf); [sigma_00.pdf](https://github.com/qutip/qutip/files/3360515/sigma_00.pdf); [sigma_11.pdf](https://github.com/qutip/qutip/files/3360516/sigma_11.pdf); [sigma_22.pdf](https://github.com/qutip/qutip/files/3360517/sigma_22.pdf). The version I am using is:; ```; QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; A. J. Pitchford, P. D. Nation, R. J. Johansson, A. Grimsmo, and C. Granade. QuTiP Version: 4.4.0.dev0; Numpy Version: 1.16.4; Scipy Version: 1.2.1; Cython Version: 0.29.11; Matplotlib Version: 3.1.0; Python Version: 3.7.3; Number of CPUs: 8; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Windows (AMD64); ```. Any help would mean a lot to me!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1038
https://github.com/qutip/qutip/issues/1038:65,Integrability,depend,dependent,65,"I have been trying to simulate a 3 level system which has a time-dependent Hamiltonian. However, the plots I obtain are wrong. I am new to qutip so I might be missing something very silly.; Here's the code: ; ```; from qutip import *; import numpy as np; import matplotlib.pyplot as plt. qd0 = basis(3,0); qd1 = basis(3,1); qd2 = basis(3,2). hbar = 6.582*10**-4. times = np.linspace(0.0,1,100000). sig00 = tensor(qd0*qd0.dag(), qeye(3)); sig11 = tensor(qd1*qd1.dag(), qeye(3)); sig22 = tensor(qd2*qd2.dag(), qeye(3)); sig01 = tensor(qd0*qd1.dag(), qeye(3)); sig02 = tensor(qd0*qd2.dag(), qeye(3)); sig12 = tensor(qd1*qd2.dag(), qeye(3)); sig21 = tensor(qd2*qd1.dag(), qeye(3)). a = tensor(qeye(3), destroy(3)). w1 = 2000.0/hbar; w2 = 2001.0/hbar; wph = 1.0/hbar; g = 120; pump1 = 10.0; pump2 = 1; gamma = 10**-3; nth = 10**-6; y = 0*times + nth. T1 = 0.001; T2 = 1. H01 = w1*sig11 + w2*sig22 + wph*a.dag()*a + g*(sig12*a.dag() + sig21*a); H1a = pump1*sig01; H2a = pump1*sig01.dag(). H1b = pump2*sig01; H2b = pump2*sig01.dag(). def H1_coeff(times, args):; return np.exp(w1*times*1j); def H2_coeff(times, args):; return np.exp(-w1*times*1j). Ha = [H01, [H1a, H1_coeff],[H2a, H2_coeff]]; Hb = [H01, [H1b, H1_coeff],[H2b, H2_coeff]]. psi0 = tensor(qd0, fock(3,1)). result1 = mesolve(Ha, psi0, times, [np.sqrt(T1)*sig01, np.sqrt(T2)*sig02, np.sqrt(gamma*(nth + 1))*a, np.sqrt(gamma*nth)*a.dag()], [a.dag()*a, sig00, sig11, sig22], progress_bar=True); result2 = mesolve(Hb, psi0, times, [np.sqrt(T1)*sig01, np.sqrt(T2)*sig02, np.sqrt(gamma*(nth + 1))*a, np.sqrt(gamma*nth)*a.dag()], [a.dag()*a, sig00, sig11, sig22], progress_bar=True). plt.figure(); plt.plot(times, result1.expect[0], label = 'pump = 10'); plt.plot(times, result2.expect[0], label = 'pump = 1'); plt.plot(times, y,'k'); plt.xlabel('Time (ns)'); plt.ylabel('Phonon number'); legend = plt.legend(); plt.savefig(""phonon number.png""); plt.savefig(""phonon number.pdf""); output_data = np.vstack((times, result1.expect[0])); file_data_store('phon",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1038
https://github.com/qutip/qutip/issues/1039:8,Deployability,install,installed,8,"Hi, . I installed qutip on my windows system and tried the testing codes and faced the problem (as the figure shows):. TypeError: Cannot convert _UnitedFuncCaller to qutip.cy.cqobjevo_factor.CoeffFunc. ![image](https://user-images.githubusercontent.com/13745165/60830800-9a9e5e00-a1ea-11e9-99d7-2ec24390083e.png). Here is the about() information:. QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; A. J. Pitchford, P. D. Nation, R. J. Johansson, A. Grimsmo, and C. Granade. QuTiP Version: 4.4.0.dev0; Numpy Version: 1.16.4; Scipy Version: 1.2.1; Cython Version: 0.29.11; Matplotlib Version: 3.1.0; Python Version: 3.7.3; Number of CPUs: 8; BLAS Info: INTEL MKL; OPENMP Installed: True; INTEL MKL Ext: True; Platform Info: Windows (AMD64); Installation path: C:\Anaconda\envs\qutip\lib\site-packages\qutip-4.4.0.dev0-py3.7-win-amd64.egg\qutip. I would appreciate it if you can give me some advice to help me pass the testing codes!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1039
https://github.com/qutip/qutip/issues/1039:684,Deployability,Install,Installed,684,"Hi, . I installed qutip on my windows system and tried the testing codes and faced the problem (as the figure shows):. TypeError: Cannot convert _UnitedFuncCaller to qutip.cy.cqobjevo_factor.CoeffFunc. ![image](https://user-images.githubusercontent.com/13745165/60830800-9a9e5e00-a1ea-11e9-99d7-2ec24390083e.png). Here is the about() information:. QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; A. J. Pitchford, P. D. Nation, R. J. Johansson, A. Grimsmo, and C. Granade. QuTiP Version: 4.4.0.dev0; Numpy Version: 1.16.4; Scipy Version: 1.2.1; Cython Version: 0.29.11; Matplotlib Version: 3.1.0; Python Version: 3.7.3; Number of CPUs: 8; BLAS Info: INTEL MKL; OPENMP Installed: True; INTEL MKL Ext: True; Platform Info: Windows (AMD64); Installation path: C:\Anaconda\envs\qutip\lib\site-packages\qutip-4.4.0.dev0-py3.7-win-amd64.egg\qutip. I would appreciate it if you can give me some advice to help me pass the testing codes!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1039
https://github.com/qutip/qutip/issues/1039:754,Deployability,Install,Installation,754,"Hi, . I installed qutip on my windows system and tried the testing codes and faced the problem (as the figure shows):. TypeError: Cannot convert _UnitedFuncCaller to qutip.cy.cqobjevo_factor.CoeffFunc. ![image](https://user-images.githubusercontent.com/13745165/60830800-9a9e5e00-a1ea-11e9-99d7-2ec24390083e.png). Here is the about() information:. QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; A. J. Pitchford, P. D. Nation, R. J. Johansson, A. Grimsmo, and C. Granade. QuTiP Version: 4.4.0.dev0; Numpy Version: 1.16.4; Scipy Version: 1.2.1; Cython Version: 0.29.11; Matplotlib Version: 3.1.0; Python Version: 3.7.3; Number of CPUs: 8; BLAS Info: INTEL MKL; OPENMP Installed: True; INTEL MKL Ext: True; Platform Info: Windows (AMD64); Installation path: C:\Anaconda\envs\qutip\lib\site-packages\qutip-4.4.0.dev0-py3.7-win-amd64.egg\qutip. I would appreciate it if you can give me some advice to help me pass the testing codes!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1039
https://github.com/qutip/qutip/issues/1039:59,Testability,test,testing,59,"Hi, . I installed qutip on my windows system and tried the testing codes and faced the problem (as the figure shows):. TypeError: Cannot convert _UnitedFuncCaller to qutip.cy.cqobjevo_factor.CoeffFunc. ![image](https://user-images.githubusercontent.com/13745165/60830800-9a9e5e00-a1ea-11e9-99d7-2ec24390083e.png). Here is the about() information:. QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; A. J. Pitchford, P. D. Nation, R. J. Johansson, A. Grimsmo, and C. Granade. QuTiP Version: 4.4.0.dev0; Numpy Version: 1.16.4; Scipy Version: 1.2.1; Cython Version: 0.29.11; Matplotlib Version: 3.1.0; Python Version: 3.7.3; Number of CPUs: 8; BLAS Info: INTEL MKL; OPENMP Installed: True; INTEL MKL Ext: True; Platform Info: Windows (AMD64); Installation path: C:\Anaconda\envs\qutip\lib\site-packages\qutip-4.4.0.dev0-py3.7-win-amd64.egg\qutip. I would appreciate it if you can give me some advice to help me pass the testing codes!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1039
https://github.com/qutip/qutip/issues/1039:931,Testability,test,testing,931,"Hi, . I installed qutip on my windows system and tried the testing codes and faced the problem (as the figure shows):. TypeError: Cannot convert _UnitedFuncCaller to qutip.cy.cqobjevo_factor.CoeffFunc. ![image](https://user-images.githubusercontent.com/13745165/60830800-9a9e5e00-a1ea-11e9-99d7-2ec24390083e.png). Here is the about() information:. QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; A. J. Pitchford, P. D. Nation, R. J. Johansson, A. Grimsmo, and C. Granade. QuTiP Version: 4.4.0.dev0; Numpy Version: 1.16.4; Scipy Version: 1.2.1; Cython Version: 0.29.11; Matplotlib Version: 3.1.0; Python Version: 3.7.3; Number of CPUs: 8; BLAS Info: INTEL MKL; OPENMP Installed: True; INTEL MKL Ext: True; Platform Info: Windows (AMD64); Installation path: C:\Anaconda\envs\qutip\lib\site-packages\qutip-4.4.0.dev0-py3.7-win-amd64.egg\qutip. I would appreciate it if you can give me some advice to help me pass the testing codes!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1039
https://github.com/qutip/qutip/pull/1040:54,Testability,test,test,54,Should fix the issue #1039 ; Added matching automated test.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1040
https://github.com/qutip/qutip/pull/1043:805,Deployability,patch,patches,805,"* import + sesolve. * psi in args part 1. * psi in args part 2. * state in args part3. * dyn args test1. * dyn args test2. * args debug. * ready for tests. * s/mesolve pass tests. * mcsolve rework. * mcsolve rework part 2. * mcsolve cython cleaning. * mcsolve working. * mcsolve cython as object. * mcsolve pass all test. * automated test almost passing. * pass all tests. * docs and cleaning. * diag ok. * clean propagator. * clean propagator 2. * clean floquet. * clean floquet 2. * mcsolve serial_map bugfix. * object args bug correction. * dense cQobjEvo bugfix. * spliting PR. * merge priority correction. * merge priority correction. * mcsolve based on qoevo. * better rouchon citation. * final state avg?. * faster postprocessing. * final_state average flag. * final state runs as property. * Some patches for qip.Gate (#995). * remove repetitive assignment. * move description to class def. Doc won't show it if it's under __init__. * check invalid input for targets and control. * all must be integer. * NotImplemented is not callable, use NotImplementedError. * add whitespace. * refactor. * format correction",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1043
https://github.com/qutip/qutip/pull/1043:1090,Modifiability,refactor,refactor,1090,"* import + sesolve. * psi in args part 1. * psi in args part 2. * state in args part3. * dyn args test1. * dyn args test2. * args debug. * ready for tests. * s/mesolve pass tests. * mcsolve rework. * mcsolve rework part 2. * mcsolve cython cleaning. * mcsolve working. * mcsolve cython as object. * mcsolve pass all test. * automated test almost passing. * pass all tests. * docs and cleaning. * diag ok. * clean propagator. * clean propagator 2. * clean floquet. * clean floquet 2. * mcsolve serial_map bugfix. * object args bug correction. * dense cQobjEvo bugfix. * spliting PR. * merge priority correction. * merge priority correction. * mcsolve based on qoevo. * better rouchon citation. * final state avg?. * faster postprocessing. * final_state average flag. * final state runs as property. * Some patches for qip.Gate (#995). * remove repetitive assignment. * move description to class def. Doc won't show it if it's under __init__. * check invalid input for targets and control. * all must be integer. * NotImplemented is not callable, use NotImplementedError. * add whitespace. * refactor. * format correction",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1043
https://github.com/qutip/qutip/pull/1043:149,Testability,test,tests,149,"* import + sesolve. * psi in args part 1. * psi in args part 2. * state in args part3. * dyn args test1. * dyn args test2. * args debug. * ready for tests. * s/mesolve pass tests. * mcsolve rework. * mcsolve rework part 2. * mcsolve cython cleaning. * mcsolve working. * mcsolve cython as object. * mcsolve pass all test. * automated test almost passing. * pass all tests. * docs and cleaning. * diag ok. * clean propagator. * clean propagator 2. * clean floquet. * clean floquet 2. * mcsolve serial_map bugfix. * object args bug correction. * dense cQobjEvo bugfix. * spliting PR. * merge priority correction. * merge priority correction. * mcsolve based on qoevo. * better rouchon citation. * final state avg?. * faster postprocessing. * final_state average flag. * final state runs as property. * Some patches for qip.Gate (#995). * remove repetitive assignment. * move description to class def. Doc won't show it if it's under __init__. * check invalid input for targets and control. * all must be integer. * NotImplemented is not callable, use NotImplementedError. * add whitespace. * refactor. * format correction",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1043
https://github.com/qutip/qutip/pull/1043:173,Testability,test,tests,173,"* import + sesolve. * psi in args part 1. * psi in args part 2. * state in args part3. * dyn args test1. * dyn args test2. * args debug. * ready for tests. * s/mesolve pass tests. * mcsolve rework. * mcsolve rework part 2. * mcsolve cython cleaning. * mcsolve working. * mcsolve cython as object. * mcsolve pass all test. * automated test almost passing. * pass all tests. * docs and cleaning. * diag ok. * clean propagator. * clean propagator 2. * clean floquet. * clean floquet 2. * mcsolve serial_map bugfix. * object args bug correction. * dense cQobjEvo bugfix. * spliting PR. * merge priority correction. * merge priority correction. * mcsolve based on qoevo. * better rouchon citation. * final state avg?. * faster postprocessing. * final_state average flag. * final state runs as property. * Some patches for qip.Gate (#995). * remove repetitive assignment. * move description to class def. Doc won't show it if it's under __init__. * check invalid input for targets and control. * all must be integer. * NotImplemented is not callable, use NotImplementedError. * add whitespace. * refactor. * format correction",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1043
https://github.com/qutip/qutip/pull/1043:316,Testability,test,test,316,"* import + sesolve. * psi in args part 1. * psi in args part 2. * state in args part3. * dyn args test1. * dyn args test2. * args debug. * ready for tests. * s/mesolve pass tests. * mcsolve rework. * mcsolve rework part 2. * mcsolve cython cleaning. * mcsolve working. * mcsolve cython as object. * mcsolve pass all test. * automated test almost passing. * pass all tests. * docs and cleaning. * diag ok. * clean propagator. * clean propagator 2. * clean floquet. * clean floquet 2. * mcsolve serial_map bugfix. * object args bug correction. * dense cQobjEvo bugfix. * spliting PR. * merge priority correction. * merge priority correction. * mcsolve based on qoevo. * better rouchon citation. * final state avg?. * faster postprocessing. * final_state average flag. * final state runs as property. * Some patches for qip.Gate (#995). * remove repetitive assignment. * move description to class def. Doc won't show it if it's under __init__. * check invalid input for targets and control. * all must be integer. * NotImplemented is not callable, use NotImplementedError. * add whitespace. * refactor. * format correction",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1043
https://github.com/qutip/qutip/pull/1043:334,Testability,test,test,334,"* import + sesolve. * psi in args part 1. * psi in args part 2. * state in args part3. * dyn args test1. * dyn args test2. * args debug. * ready for tests. * s/mesolve pass tests. * mcsolve rework. * mcsolve rework part 2. * mcsolve cython cleaning. * mcsolve working. * mcsolve cython as object. * mcsolve pass all test. * automated test almost passing. * pass all tests. * docs and cleaning. * diag ok. * clean propagator. * clean propagator 2. * clean floquet. * clean floquet 2. * mcsolve serial_map bugfix. * object args bug correction. * dense cQobjEvo bugfix. * spliting PR. * merge priority correction. * merge priority correction. * mcsolve based on qoevo. * better rouchon citation. * final state avg?. * faster postprocessing. * final_state average flag. * final state runs as property. * Some patches for qip.Gate (#995). * remove repetitive assignment. * move description to class def. Doc won't show it if it's under __init__. * check invalid input for targets and control. * all must be integer. * NotImplemented is not callable, use NotImplementedError. * add whitespace. * refactor. * format correction",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1043
https://github.com/qutip/qutip/pull/1043:366,Testability,test,tests,366,"* import + sesolve. * psi in args part 1. * psi in args part 2. * state in args part3. * dyn args test1. * dyn args test2. * args debug. * ready for tests. * s/mesolve pass tests. * mcsolve rework. * mcsolve rework part 2. * mcsolve cython cleaning. * mcsolve working. * mcsolve cython as object. * mcsolve pass all test. * automated test almost passing. * pass all tests. * docs and cleaning. * diag ok. * clean propagator. * clean propagator 2. * clean floquet. * clean floquet 2. * mcsolve serial_map bugfix. * object args bug correction. * dense cQobjEvo bugfix. * spliting PR. * merge priority correction. * merge priority correction. * mcsolve based on qoevo. * better rouchon citation. * final state avg?. * faster postprocessing. * final_state average flag. * final state runs as property. * Some patches for qip.Gate (#995). * remove repetitive assignment. * move description to class def. Doc won't show it if it's under __init__. * check invalid input for targets and control. * all must be integer. * NotImplemented is not callable, use NotImplementedError. * add whitespace. * refactor. * format correction",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1043
https://github.com/qutip/qutip/pull/1045:6,Usability,simpl,simple,6,"Add a simple method onto the Qobj to calculate the purity of a quantum object, `(rho*rho).tr()`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1045
https://github.com/qutip/qutip/pull/1046:609,Usability,Guid,Guide,609,Addressing #993: nonlinear functions such as the Von Neumann entropy or purity of a density matrix written in the Dicke basis need to account for the identical copies of the blocks relative to non-symmetrical Dicke states. . This can be done by cycling into the blocks and applying the correct weight accounting for degeneracy (using `piqs.state_degeneracy`). . This PR also contains auxiliary functions to visualize and unpack the Dicke-basis density matrix into the full 2^N space still of collective spin but with degenerate blocks. . It uses the `purity` method proposed in #1045. . Will add info in User Guide and notebooks to highlight this features that need to be considered to correctly calculate nonlinear functions of a density matrix in the Dicke basis.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1046
https://github.com/qutip/qutip/issues/1047:10,Deployability,update,update,10,"Since the update to version 4.4, calling `mesolve` without collapse operators prints a message ""no collapse operator, using sesolve"" to stdout. Is printing this message really necessary? It breaks our examples for the `krotov` package, see e.g. the notebook https://krotov.readthedocs.io/en/latest/notebooks/01_example_simple_state_to_state.html, where these messages show up in the notebook when it runs with qutip 4.4. Of course I understand that the message is technically correct, and we could work around the problem in `krotov`, but it was nice to be able to use `mesolve` as a catch-all for either a Schrödinger equation or a master equation. We'd have to start routing different cases to `mesolve` and `sesolve` manually, otherwise. Personally, I would argue that this kind of message should be emitted as `logger.debug` instead of `print`, if at all.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1047
https://github.com/qutip/qutip/issues/1047:87,Integrability,message,message,87,"Since the update to version 4.4, calling `mesolve` without collapse operators prints a message ""no collapse operator, using sesolve"" to stdout. Is printing this message really necessary? It breaks our examples for the `krotov` package, see e.g. the notebook https://krotov.readthedocs.io/en/latest/notebooks/01_example_simple_state_to_state.html, where these messages show up in the notebook when it runs with qutip 4.4. Of course I understand that the message is technically correct, and we could work around the problem in `krotov`, but it was nice to be able to use `mesolve` as a catch-all for either a Schrödinger equation or a master equation. We'd have to start routing different cases to `mesolve` and `sesolve` manually, otherwise. Personally, I would argue that this kind of message should be emitted as `logger.debug` instead of `print`, if at all.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1047
https://github.com/qutip/qutip/issues/1047:161,Integrability,message,message,161,"Since the update to version 4.4, calling `mesolve` without collapse operators prints a message ""no collapse operator, using sesolve"" to stdout. Is printing this message really necessary? It breaks our examples for the `krotov` package, see e.g. the notebook https://krotov.readthedocs.io/en/latest/notebooks/01_example_simple_state_to_state.html, where these messages show up in the notebook when it runs with qutip 4.4. Of course I understand that the message is technically correct, and we could work around the problem in `krotov`, but it was nice to be able to use `mesolve` as a catch-all for either a Schrödinger equation or a master equation. We'd have to start routing different cases to `mesolve` and `sesolve` manually, otherwise. Personally, I would argue that this kind of message should be emitted as `logger.debug` instead of `print`, if at all.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1047
https://github.com/qutip/qutip/issues/1047:359,Integrability,message,messages,359,"Since the update to version 4.4, calling `mesolve` without collapse operators prints a message ""no collapse operator, using sesolve"" to stdout. Is printing this message really necessary? It breaks our examples for the `krotov` package, see e.g. the notebook https://krotov.readthedocs.io/en/latest/notebooks/01_example_simple_state_to_state.html, where these messages show up in the notebook when it runs with qutip 4.4. Of course I understand that the message is technically correct, and we could work around the problem in `krotov`, but it was nice to be able to use `mesolve` as a catch-all for either a Schrödinger equation or a master equation. We'd have to start routing different cases to `mesolve` and `sesolve` manually, otherwise. Personally, I would argue that this kind of message should be emitted as `logger.debug` instead of `print`, if at all.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1047
https://github.com/qutip/qutip/issues/1047:453,Integrability,message,message,453,"Since the update to version 4.4, calling `mesolve` without collapse operators prints a message ""no collapse operator, using sesolve"" to stdout. Is printing this message really necessary? It breaks our examples for the `krotov` package, see e.g. the notebook https://krotov.readthedocs.io/en/latest/notebooks/01_example_simple_state_to_state.html, where these messages show up in the notebook when it runs with qutip 4.4. Of course I understand that the message is technically correct, and we could work around the problem in `krotov`, but it was nice to be able to use `mesolve` as a catch-all for either a Schrödinger equation or a master equation. We'd have to start routing different cases to `mesolve` and `sesolve` manually, otherwise. Personally, I would argue that this kind of message should be emitted as `logger.debug` instead of `print`, if at all.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1047
https://github.com/qutip/qutip/issues/1047:669,Integrability,rout,routing,669,"Since the update to version 4.4, calling `mesolve` without collapse operators prints a message ""no collapse operator, using sesolve"" to stdout. Is printing this message really necessary? It breaks our examples for the `krotov` package, see e.g. the notebook https://krotov.readthedocs.io/en/latest/notebooks/01_example_simple_state_to_state.html, where these messages show up in the notebook when it runs with qutip 4.4. Of course I understand that the message is technically correct, and we could work around the problem in `krotov`, but it was nice to be able to use `mesolve` as a catch-all for either a Schrödinger equation or a master equation. We'd have to start routing different cases to `mesolve` and `sesolve` manually, otherwise. Personally, I would argue that this kind of message should be emitted as `logger.debug` instead of `print`, if at all.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1047
https://github.com/qutip/qutip/issues/1047:785,Integrability,message,message,785,"Since the update to version 4.4, calling `mesolve` without collapse operators prints a message ""no collapse operator, using sesolve"" to stdout. Is printing this message really necessary? It breaks our examples for the `krotov` package, see e.g. the notebook https://krotov.readthedocs.io/en/latest/notebooks/01_example_simple_state_to_state.html, where these messages show up in the notebook when it runs with qutip 4.4. Of course I understand that the message is technically correct, and we could work around the problem in `krotov`, but it was nice to be able to use `mesolve` as a catch-all for either a Schrödinger equation or a master equation. We'd have to start routing different cases to `mesolve` and `sesolve` manually, otherwise. Personally, I would argue that this kind of message should be emitted as `logger.debug` instead of `print`, if at all.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1047
https://github.com/qutip/qutip/issues/1047:815,Testability,log,logger,815,"Since the update to version 4.4, calling `mesolve` without collapse operators prints a message ""no collapse operator, using sesolve"" to stdout. Is printing this message really necessary? It breaks our examples for the `krotov` package, see e.g. the notebook https://krotov.readthedocs.io/en/latest/notebooks/01_example_simple_state_to_state.html, where these messages show up in the notebook when it runs with qutip 4.4. Of course I understand that the message is technically correct, and we could work around the problem in `krotov`, but it was nice to be able to use `mesolve` as a catch-all for either a Schrödinger equation or a master equation. We'd have to start routing different cases to `mesolve` and `sesolve` manually, otherwise. Personally, I would argue that this kind of message should be emitted as `logger.debug` instead of `print`, if at all.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1047
https://github.com/qutip/qutip/issues/1048:25,Integrability,depend,dependant,25,"When using multiple time dependant functions (i.e. H = [H0,[H1,H1_coeff],[H2,H2_coeff],...]) the functions in qutip.correlations produce incorrect results. A couple observations:. - You get different results depending on the order of the time dependant parts. mesolve produces identical results.; - Even if the time-varying Hamiltonian is empty or the function returns zero, it can still affect the results. I've attached some code demonstrating this (3 level atom and a laser) and some images of the plots produced.; [corrtest.txt](https://github.com/qutip/qutip/files/3398074/corrtest.txt); [norder2](https://user-images.githubusercontent.com/42548316/61312064-962c0380-a7ef-11e9-84e7-964a5ff49f21.png); [corrorder2](https://user-images.githubusercontent.com/42548316/61312065-962c0380-a7ef-11e9-8e28-5797fb4004d3.png); [norder1](https://user-images.githubusercontent.com/42548316/61312066-962c0380-a7ef-11e9-9e5a-dce127d8be11.png); [corrorder1](https://user-images.githubusercontent.com/42548316/61312067-962c0380-a7ef-11e9-8eb2-532eec7bbb61.png). I'm assuming this is to do with how the Hamiltonian is propagated, maybe only one of the functions is being shifted in time? Any chance of a fix on this? A workaround is to make the entire Hamiltonian a single time dependant function but obviously this isn't ideal.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1048
https://github.com/qutip/qutip/issues/1048:208,Integrability,depend,depending,208,"When using multiple time dependant functions (i.e. H = [H0,[H1,H1_coeff],[H2,H2_coeff],...]) the functions in qutip.correlations produce incorrect results. A couple observations:. - You get different results depending on the order of the time dependant parts. mesolve produces identical results.; - Even if the time-varying Hamiltonian is empty or the function returns zero, it can still affect the results. I've attached some code demonstrating this (3 level atom and a laser) and some images of the plots produced.; [corrtest.txt](https://github.com/qutip/qutip/files/3398074/corrtest.txt); [norder2](https://user-images.githubusercontent.com/42548316/61312064-962c0380-a7ef-11e9-84e7-964a5ff49f21.png); [corrorder2](https://user-images.githubusercontent.com/42548316/61312065-962c0380-a7ef-11e9-8e28-5797fb4004d3.png); [norder1](https://user-images.githubusercontent.com/42548316/61312066-962c0380-a7ef-11e9-9e5a-dce127d8be11.png); [corrorder1](https://user-images.githubusercontent.com/42548316/61312067-962c0380-a7ef-11e9-8eb2-532eec7bbb61.png). I'm assuming this is to do with how the Hamiltonian is propagated, maybe only one of the functions is being shifted in time? Any chance of a fix on this? A workaround is to make the entire Hamiltonian a single time dependant function but obviously this isn't ideal.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1048
https://github.com/qutip/qutip/issues/1048:243,Integrability,depend,dependant,243,"When using multiple time dependant functions (i.e. H = [H0,[H1,H1_coeff],[H2,H2_coeff],...]) the functions in qutip.correlations produce incorrect results. A couple observations:. - You get different results depending on the order of the time dependant parts. mesolve produces identical results.; - Even if the time-varying Hamiltonian is empty or the function returns zero, it can still affect the results. I've attached some code demonstrating this (3 level atom and a laser) and some images of the plots produced.; [corrtest.txt](https://github.com/qutip/qutip/files/3398074/corrtest.txt); [norder2](https://user-images.githubusercontent.com/42548316/61312064-962c0380-a7ef-11e9-84e7-964a5ff49f21.png); [corrorder2](https://user-images.githubusercontent.com/42548316/61312065-962c0380-a7ef-11e9-8e28-5797fb4004d3.png); [norder1](https://user-images.githubusercontent.com/42548316/61312066-962c0380-a7ef-11e9-9e5a-dce127d8be11.png); [corrorder1](https://user-images.githubusercontent.com/42548316/61312067-962c0380-a7ef-11e9-8eb2-532eec7bbb61.png). I'm assuming this is to do with how the Hamiltonian is propagated, maybe only one of the functions is being shifted in time? Any chance of a fix on this? A workaround is to make the entire Hamiltonian a single time dependant function but obviously this isn't ideal.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1048
https://github.com/qutip/qutip/issues/1048:1266,Integrability,depend,dependant,1266,"When using multiple time dependant functions (i.e. H = [H0,[H1,H1_coeff],[H2,H2_coeff],...]) the functions in qutip.correlations produce incorrect results. A couple observations:. - You get different results depending on the order of the time dependant parts. mesolve produces identical results.; - Even if the time-varying Hamiltonian is empty or the function returns zero, it can still affect the results. I've attached some code demonstrating this (3 level atom and a laser) and some images of the plots produced.; [corrtest.txt](https://github.com/qutip/qutip/files/3398074/corrtest.txt); [norder2](https://user-images.githubusercontent.com/42548316/61312064-962c0380-a7ef-11e9-84e7-964a5ff49f21.png); [corrorder2](https://user-images.githubusercontent.com/42548316/61312065-962c0380-a7ef-11e9-8e28-5797fb4004d3.png); [norder1](https://user-images.githubusercontent.com/42548316/61312066-962c0380-a7ef-11e9-9e5a-dce127d8be11.png); [corrorder1](https://user-images.githubusercontent.com/42548316/61312067-962c0380-a7ef-11e9-8eb2-532eec7bbb61.png). I'm assuming this is to do with how the Hamiltonian is propagated, maybe only one of the functions is being shifted in time? Any chance of a fix on this? A workaround is to make the entire Hamiltonian a single time dependant function but obviously this isn't ideal.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1048
https://github.com/qutip/qutip/pull/1050:789,Performance,perform,performance,789,"Implement an option for using array-like coefficients as step-function instead of cubic-spline:; e.g. ; ```; tlist = np.array([0., 1., 2., 3.]); coeff = np.array([1., 2., 3., 3.]); ```; The coefficient is 1 in the time interval [0,1), 2 in [1,2) and so on. The last element in `coeff` is just a place holder and has no effect. @Ericgig Do you think the following might be useful?; 1. In `inter.pyx` many functions have two versions, one for complex input and one for float. Now there are 4 pairs of them, will it helps if I try to merge them with fused type in Cython?; 2. For non-uniform `tlist`, `_binary_search` is used to find the current index inside the method such as `_spline_float_t_second`, but very often we call this method within a loop for the same `t`. It would improve the performance if `_binary_search` is called outside once for all `t`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1050
https://github.com/qutip/qutip/issues/1051:400,Availability,repair,repairs,400,"When using the Qobj.permute function for a specific state and specific permutation we encounter the isherm-property to be set to False, while the state is Hermitian nevertheless. ; I attached the most minimalistic example I could built. . There we calculate a permutation of a small compound state that sets isherm=False, another one that works properly and a transformation (double transpose) that ""repairs"" the Qobj and sets isherm=True again. A double transpose of the state is our current work-around. With isherm=False you cannot calculate the partial trace of the density operator describing the state. [qutip_permute_isherm_bug.txt](https://github.com/qutip/qutip/files/3406839/qutip_permute_isherm_bug.txt)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1051
https://github.com/qutip/qutip/issues/1055:144,Deployability,release,release,144,"Once a Pull Request is merged to QuTiP, the contributor could add a short description to the Changelog, which contains changes of each [version release](http://qutip.org/docs/latest/changelog.html). ; It could be in the style of current changelog:. * A one-liner for **minor changes**, with a descriptive text and the author's name. ; * A short paragraph for **major changes**. . This guideline could be added to the contribution [how-to](https://github.com/qutip/qutip-doc/blob/master/qutip_dev_contrib.md ).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1055
https://github.com/qutip/qutip/issues/1055:385,Usability,guid,guideline,385,"Once a Pull Request is merged to QuTiP, the contributor could add a short description to the Changelog, which contains changes of each [version release](http://qutip.org/docs/latest/changelog.html). ; It could be in the style of current changelog:. * A one-liner for **minor changes**, with a descriptive text and the author's name. ; * A short paragraph for **major changes**. . This guideline could be added to the contribution [how-to](https://github.com/qutip/qutip-doc/blob/master/qutip_dev_contrib.md ).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1055
https://github.com/qutip/qutip/issues/1061:922,Usability,guid,guide,922,"There is a problem with `mesolve` and `sesolve`'s default `options`, which determine whether the propagated states are stored in the `result` object:. ~~~; >>> import qutip; >>> import numpy as np; >>> qutip.__version__; '4.5.0.dev0+19f172cb'; >>> H = qutip.sigmaz() + qutip.sigmax(); >>> psi = qutip.ket('0'); >>> tlist = np.linspace(0,10, 200); >>> p0 = qutip.ket2dm(psi); >>> res1 = qutip.mesolve(H, psi, tlist, e_ops=[p0]); >>> len(res1.states) # should be 0; 0; >>> len(res1.expect) # should be 1; 1; >>>; >>> len(res2.states) # should be 200; 200; >>> len(res2.expect) # should be 0; 0; >>> res3 = qutip.mesolve(H, psi, tlist, e_ops=[p0]); >>> len(res3.states) # should be 0 (same as res1); 200; >>> len(res3.expect) # should be 1; 1; ~~~; In `res3`, there should be no stored `states`, as I'm requesting expectation values. The problem is due to the common gotcha of [mutable default arguments](https://docs.python-guide.org/writing/gotchas/#mutable-default-arguments) in the definition of of e.g. `mesolve`:; ~~~; def mesolve(H, rho0, tlist, c_ops=[], e_ops=[], args={}, options=Options(),; progress_bar=BaseProgressBar(), _safe_mode=True); ~~~; What happens is that the default `options` get instantiated once when `qutip` is imported. In the example above `res2 = qutip.mesolve(H, psi, tlist)` will then internally set `options.store_states = True`, and this value will still be there for `res3 = qutip.mesolve(H, psi, tlist, e_ops=[p0])`. Also, `c_ops`, `e_ops`, `args`, and `progress_bar` are all mutable in this definition, which could cause more problems. The correct thing to do is to initialize with `None` and set the mutable defaults in the body of the function. I can prepare a pull request for this.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1061
https://github.com/qutip/qutip/issues/1063:1191,Usability,intuit,intuitive,1191,"QuTiP 4.4 changed the type of values that are returned from indexing into a `Qobj`:. ~~~; >>> import qutip; >>> CNOT = qutip.gates.cnot(); >>> CNOT[0,0] # (1+0j) on 4.3.1; array(1.+0.j); >>> type(CNOT[0,0]) # numpy.complex128 on 4.3.1; <class 'numpy.ndarray'>; >>> CNOT.data[0,0]; array(1.+0.j); ~~~. I'm using CNOT here as an example, but the same is true for any `Qobj`. The problem with the zero-dimensional `array(1.+0.j)` is that you can't multiply it to another `Qobj` (the result of the product is a sparse matrix, not a `Qobj`, as it would be for a scalar factor):; ~~~; >>> CNOT[0,0] * qutip.ket('10'); <4x1 sparse matrix of type '<class 'numpy.complex128'>'; with 1 stored elements in Compressed Sparse Row format>; ~~~ . In my specific case, it breaks this function I had: ; ~~~; def mapped_basis(gate, basis):; """"""Result of applying `gate` to `basis`""""""; return tuple([; sum([gate[i, j] * basis[i] for i in range(gate.shape[0])]); for j in range(gate.shape[1])]); ~~~. I can work around the new behavior by changing `gate[i, j]` to `complex(gate[i, j])`, but I still wanted to raise the issue, to see whether this change was intentional, and what the reasoning behind it was. My intuitive expectation would be for `gate[i, j]` to be a simple scalar. I could see the zero-dimensional array causing some subtle problems for users, e.g. if there were to index into a density matrix to get populations (apart from my `mapped_basis` use case above). Note that numpy itself returns scalars:; ~~~; >>> import numpy as np; >>> np.array(CNOT)[0, 0]; (1+0j); >>> type(np.array(CNOT)[0, 0]); <class 'numpy.complex128'>; ~~~. On the other hand, scipy's sparse matrices have the same behavior as the most recent QuTiP, so there is a precedent:; ~~~; >>> import scipy.sparse; >>> s = scipy.sparse.csr_matrix(CNOT); >>> s[0,0]; array(1.+0.j); ~~~. If the change in QuTiP is deliberate, feel free to close the issue.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1063
https://github.com/qutip/qutip/issues/1063:1247,Usability,simpl,simple,1247,"QuTiP 4.4 changed the type of values that are returned from indexing into a `Qobj`:. ~~~; >>> import qutip; >>> CNOT = qutip.gates.cnot(); >>> CNOT[0,0] # (1+0j) on 4.3.1; array(1.+0.j); >>> type(CNOT[0,0]) # numpy.complex128 on 4.3.1; <class 'numpy.ndarray'>; >>> CNOT.data[0,0]; array(1.+0.j); ~~~. I'm using CNOT here as an example, but the same is true for any `Qobj`. The problem with the zero-dimensional `array(1.+0.j)` is that you can't multiply it to another `Qobj` (the result of the product is a sparse matrix, not a `Qobj`, as it would be for a scalar factor):; ~~~; >>> CNOT[0,0] * qutip.ket('10'); <4x1 sparse matrix of type '<class 'numpy.complex128'>'; with 1 stored elements in Compressed Sparse Row format>; ~~~ . In my specific case, it breaks this function I had: ; ~~~; def mapped_basis(gate, basis):; """"""Result of applying `gate` to `basis`""""""; return tuple([; sum([gate[i, j] * basis[i] for i in range(gate.shape[0])]); for j in range(gate.shape[1])]); ~~~. I can work around the new behavior by changing `gate[i, j]` to `complex(gate[i, j])`, but I still wanted to raise the issue, to see whether this change was intentional, and what the reasoning behind it was. My intuitive expectation would be for `gate[i, j]` to be a simple scalar. I could see the zero-dimensional array causing some subtle problems for users, e.g. if there were to index into a density matrix to get populations (apart from my `mapped_basis` use case above). Note that numpy itself returns scalars:; ~~~; >>> import numpy as np; >>> np.array(CNOT)[0, 0]; (1+0j); >>> type(np.array(CNOT)[0, 0]); <class 'numpy.complex128'>; ~~~. On the other hand, scipy's sparse matrices have the same behavior as the most recent QuTiP, so there is a precedent:; ~~~; >>> import scipy.sparse; >>> s = scipy.sparse.csr_matrix(CNOT); >>> s[0,0]; array(1.+0.j); ~~~. If the change in QuTiP is deliberate, feel free to close the issue.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1063
https://github.com/qutip/qutip/pull/1065:788,Deployability,Update,Update,788,"This is the clean PR contains the main part of my commits to this GoSC project. It includes the following main points:. 1. A numerical Noisy Intermediate Scale Quantum Computing (NISQ) simulator using the QuTiP opens system solver.; 2. Refactoring the existing `SpinChain` and `CavityQED` module, so that they can also use the numerical simulator.; 3. A noise module `CircuitNoise` that complements the simulator with a framework for noise handling. Documentation can be found at https://github.com/qutip/qutip-doc/pull/85; Notebooks and examples are at https://github.com/qutip/qutip-notebooks/pull/88 . There are other small independent RPs. It would be helpful for the review if they are merged first. - [x] #1050 Modifies the QobjEvo class for step function coefficients; - [x] #1052 Update expand_operator for cyclic permutation; - [x] #1064 Fix the wrong type handling for constant QobjEvo; - [x] #1075 Fix the cyclic importation in the control module. After they get merged, the changed files should be limited within the `qip` module.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1065
https://github.com/qutip/qutip/pull/1065:236,Modifiability,Refactor,Refactoring,236,"This is the clean PR contains the main part of my commits to this GoSC project. It includes the following main points:. 1. A numerical Noisy Intermediate Scale Quantum Computing (NISQ) simulator using the QuTiP opens system solver.; 2. Refactoring the existing `SpinChain` and `CavityQED` module, so that they can also use the numerical simulator.; 3. A noise module `CircuitNoise` that complements the simulator with a framework for noise handling. Documentation can be found at https://github.com/qutip/qutip-doc/pull/85; Notebooks and examples are at https://github.com/qutip/qutip-notebooks/pull/88 . There are other small independent RPs. It would be helpful for the review if they are merged first. - [x] #1050 Modifies the QobjEvo class for step function coefficients; - [x] #1052 Update expand_operator for cyclic permutation; - [x] #1064 Fix the wrong type handling for constant QobjEvo; - [x] #1075 Fix the cyclic importation in the control module. After they get merged, the changed files should be limited within the `qip` module.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1065
https://github.com/qutip/qutip/issues/1067:162,Availability,error,error,162,"Hi, thank you for the amazing work that you do. When using qutip to diagonalise two simultaneously diagonalizible, hermitian operators it continues to throw this error:. ![Screen Shot 2019-08-08 at 11 29 59](https://user-images.githubusercontent.com/19754061/62691897-e0a83680-b9cf-11e9-8a92-a88a3716ae99.png). Which comes from `qutip.simdiag.py` in `simdiag(ops, evals)`:. ![Screen Shot 2019-08-08 at 11 27 34](https://user-images.githubusercontent.com/19754061/62691786-a76fc680-b9cf-11e9-8f99-7a9ba78db518.png). My installed packages:; QuTiP Version: 4.4.0; Numpy Version: 1.16.4; Scipy Version: 1.3.0; Cython Version: 0.29.12; Matplotlib Version: 3.1.0; Python Version: 3.7.3",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1067
https://github.com/qutip/qutip/issues/1067:518,Deployability,install,installed,518,"Hi, thank you for the amazing work that you do. When using qutip to diagonalise two simultaneously diagonalizible, hermitian operators it continues to throw this error:. ![Screen Shot 2019-08-08 at 11 29 59](https://user-images.githubusercontent.com/19754061/62691897-e0a83680-b9cf-11e9-8a92-a88a3716ae99.png). Which comes from `qutip.simdiag.py` in `simdiag(ops, evals)`:. ![Screen Shot 2019-08-08 at 11 27 34](https://user-images.githubusercontent.com/19754061/62691786-a76fc680-b9cf-11e9-8f99-7a9ba78db518.png). My installed packages:; QuTiP Version: 4.4.0; Numpy Version: 1.16.4; Scipy Version: 1.3.0; Cython Version: 0.29.12; Matplotlib Version: 3.1.0; Python Version: 3.7.3",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1067
https://github.com/qutip/qutip/pull/1069:65,Deployability,release,release,65,Proposal for 4.4.1 Mostly to fix the bugs reported since 4.4.0's release but include small improvements. Bug Fixes; -------------. - Fixed the pickling but that made solver unable to run in parallel on Windows. (Thank **lrunze** for reporting); - Removed warning when mesolve fall back on sesolve (by **Michael Goerz**).; - Fixed dimension check and confusing documentation in random ket (by **Yariv Yanay**).; - Fixed Qobj isherm not working after using Qobj.permute. (Thank **llorz1207** for reporting); - Correlation functions call now properly handle multiple time dependant functions. (Thank **taw181** for reporting); - Removed mutable default values in mesolve/sesolve (by **Michael Goerz**); - Fixed simdiag bug (Thank **Croydon-Brixton** for reporting); - Better support of constant QobjEvo. (by **Boxi Li**). Improvements; ------------------. - QobjEvo do not need to start from 0 anymore. (by **Eric Giguere**); - Add a quantum object purity function. (by **Nathan Shammah** and **Shahnawaz Ahmed**); - Add step function interpolation for array time-coefficient. (by **Boxi Li**),MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1069
https://github.com/qutip/qutip/pull/1069:569,Integrability,depend,dependant,569,Proposal for 4.4.1 Mostly to fix the bugs reported since 4.4.0's release but include small improvements. Bug Fixes; -------------. - Fixed the pickling but that made solver unable to run in parallel on Windows. (Thank **lrunze** for reporting); - Removed warning when mesolve fall back on sesolve (by **Michael Goerz**).; - Fixed dimension check and confusing documentation in random ket (by **Yariv Yanay**).; - Fixed Qobj isherm not working after using Qobj.permute. (Thank **llorz1207** for reporting); - Correlation functions call now properly handle multiple time dependant functions. (Thank **taw181** for reporting); - Removed mutable default values in mesolve/sesolve (by **Michael Goerz**); - Fixed simdiag bug (Thank **Croydon-Brixton** for reporting); - Better support of constant QobjEvo. (by **Boxi Li**). Improvements; ------------------. - QobjEvo do not need to start from 0 anymore. (by **Eric Giguere**); - Add a quantum object purity function. (by **Nathan Shammah** and **Shahnawaz Ahmed**); - Add step function interpolation for array time-coefficient. (by **Boxi Li**),MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1069
https://github.com/qutip/qutip/issues/1071:490,Deployability,release,release,490,"In this issue #580 we discussed ways to make the `import qutip` lighter. This can up again today when discussing the `qip` module with @BoxiLi during our mentor meeting. It would seem like a good idea to only import to level functions (that is not module functions in sub-folders) when ; ```; from qutip import *; ```; is used. This would be in-line with how SciPy works for instance. A lot of people use the * import, so we should give warning, and should probably only do this in a major release. So the suggestion is that when we release the new QIP features that we move to V5. Arguably we could have done this for the solver changes in 4.4.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1071
https://github.com/qutip/qutip/issues/1071:533,Deployability,release,release,533,"In this issue #580 we discussed ways to make the `import qutip` lighter. This can up again today when discussing the `qip` module with @BoxiLi during our mentor meeting. It would seem like a good idea to only import to level functions (that is not module functions in sub-folders) when ; ```; from qutip import *; ```; is used. This would be in-line with how SciPy works for instance. A lot of people use the * import, so we should give warning, and should probably only do this in a major release. So the suggestion is that when we release the new QIP features that we move to V5. Arguably we could have done this for the solver changes in 4.4.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1071
https://github.com/qutip/qutip/issues/1072:106,Deployability,update,update,106,"With the Google Summer of Code 2019 project by @BoxiLi on noise models, we are making some big changes to update the QIP module. One of the things that came up is having a `DeviceProcessor` or `Device`` class which interfaces with hardware implementations directly and runs quantum circuits on models such as SpinChain, cQED. We will also work towards linking the OptPulseProcessor to find optimal pulses to implement a circuit and add a `noise` module. I am opening this issue to discuss the restructuring of the QIP module and also adding a `measure` function/module (later) to get samples and expectation values from a circuit. We c can use this thread to discuss other issues too regarding the QIP module and how we can interface it better to QuTiP core functionalities. . - qip; - device/; - processor (which has DeviceProcessor (base class for spinchain, cqed), OptPulseProcessor etc); - spinchain; - cqed; - circuit.py; - operations.py (gates.py + qft.py); - noise.py; - measurement. @ajgpitch @nathanshammah @qutip/owners ; @BoxiLi please feel free to suggest, change or discuss more on this issue as you continue working on it. Thanks.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1072
https://github.com/qutip/qutip/issues/1072:216,Integrability,interface,interfaces,216,"With the Google Summer of Code 2019 project by @BoxiLi on noise models, we are making some big changes to update the QIP module. One of the things that came up is having a `DeviceProcessor` or `Device`` class which interfaces with hardware implementations directly and runs quantum circuits on models such as SpinChain, cQED. We will also work towards linking the OptPulseProcessor to find optimal pulses to implement a circuit and add a `noise` module. I am opening this issue to discuss the restructuring of the QIP module and also adding a `measure` function/module (later) to get samples and expectation values from a circuit. We c can use this thread to discuss other issues too regarding the QIP module and how we can interface it better to QuTiP core functionalities. . - qip; - device/; - processor (which has DeviceProcessor (base class for spinchain, cqed), OptPulseProcessor etc); - spinchain; - cqed; - circuit.py; - operations.py (gates.py + qft.py); - noise.py; - measurement. @ajgpitch @nathanshammah @qutip/owners ; @BoxiLi please feel free to suggest, change or discuss more on this issue as you continue working on it. Thanks.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1072
https://github.com/qutip/qutip/issues/1072:725,Integrability,interface,interface,725,"With the Google Summer of Code 2019 project by @BoxiLi on noise models, we are making some big changes to update the QIP module. One of the things that came up is having a `DeviceProcessor` or `Device`` class which interfaces with hardware implementations directly and runs quantum circuits on models such as SpinChain, cQED. We will also work towards linking the OptPulseProcessor to find optimal pulses to implement a circuit and add a `noise` module. I am opening this issue to discuss the restructuring of the QIP module and also adding a `measure` function/module (later) to get samples and expectation values from a circuit. We c can use this thread to discuss other issues too regarding the QIP module and how we can interface it better to QuTiP core functionalities. . - qip; - device/; - processor (which has DeviceProcessor (base class for spinchain, cqed), OptPulseProcessor etc); - spinchain; - cqed; - circuit.py; - operations.py (gates.py + qft.py); - noise.py; - measurement. @ajgpitch @nathanshammah @qutip/owners ; @BoxiLi please feel free to suggest, change or discuss more on this issue as you continue working on it. Thanks.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1072
https://github.com/qutip/qutip/pull/1073:0,Deployability,Update,Update,0,Update master with change made directly for 4.4.1; Somewhat messy merge because of mixed cherry-pick and direct commit...,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1073
https://github.com/qutip/qutip/pull/1074:115,Integrability,wrap,wrapper,115,"This could be a possible solution of deprecating the importing `qip` functions to the `qutip `namespace. I wrote a wrapper in the top-level `__init__.py` so that functions from the `qip` module will be wrapped with a deprecation warning when they are imported to the qutip namespace. In this way the all the members of `qip` module still work as usual and the warning will only be given if they are imported in the wrong way. The following code will give a warning; ```; >>> from qutip import *; >>> cnot(); __main__:1: DeprecationWarning: Importing functions/classes of the qip submodule directly from the namespace qutip is deprecated. Please import them from the submodule instead, e.g. qutip.qip import `func_name`.; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[1. 0. 0. 0.]; [0. 1. 0. 0.]; [0. 0. 0. 1.]; [0. 0. 1. 0.]]; ```; ```; >>> import qutip; >>> qutip.cnot(); __main__:1: DeprecationWarning: Importing functions/classes of the qip submodule directly from the namespace qutip is deprecated. Please import them from the submodule instead, e.g. qutip.qip import `func_name`.; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[1. 0. 0. 0.]; [0. 1. 0. 0.]; [0. 0. 0. 1.]; [0. 0. 1. 0.]]; >>> import qutip # warning appears only once.; >>> qutip.cnot(); Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[1. 0. 0. 0.]; [0. 1. 0. 0.]; [0. 0. 0. 1.]; [0. 0. 1. 0.]]; ```. The help function still works correctly:; ```; >>> help(cnot); Help on function cnot in module qutip.qip.gates:; cnot(N=None, control=0, target=1); Quantum object representing the CNOT gate. Returns; -------; cnot_gate : qobj; Quantum object representation of CNOT gate. Examples; --------; >>> cnot(); Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True; Qobj data =; [[ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j 0.+0.j]; [ 0.+",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1074
https://github.com/qutip/qutip/pull/1074:202,Integrability,wrap,wrapped,202,"This could be a possible solution of deprecating the importing `qip` functions to the `qutip `namespace. I wrote a wrapper in the top-level `__init__.py` so that functions from the `qip` module will be wrapped with a deprecation warning when they are imported to the qutip namespace. In this way the all the members of `qip` module still work as usual and the warning will only be given if they are imported in the wrong way. The following code will give a warning; ```; >>> from qutip import *; >>> cnot(); __main__:1: DeprecationWarning: Importing functions/classes of the qip submodule directly from the namespace qutip is deprecated. Please import them from the submodule instead, e.g. qutip.qip import `func_name`.; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[1. 0. 0. 0.]; [0. 1. 0. 0.]; [0. 0. 0. 1.]; [0. 0. 1. 0.]]; ```; ```; >>> import qutip; >>> qutip.cnot(); __main__:1: DeprecationWarning: Importing functions/classes of the qip submodule directly from the namespace qutip is deprecated. Please import them from the submodule instead, e.g. qutip.qip import `func_name`.; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[1. 0. 0. 0.]; [0. 1. 0. 0.]; [0. 0. 0. 1.]; [0. 0. 1. 0.]]; >>> import qutip # warning appears only once.; >>> qutip.cnot(); Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[1. 0. 0. 0.]; [0. 1. 0. 0.]; [0. 0. 0. 1.]; [0. 0. 1. 0.]]; ```. The help function still works correctly:; ```; >>> help(cnot); Help on function cnot in module qutip.qip.gates:; cnot(N=None, control=0, target=1); Quantum object representing the CNOT gate. Returns; -------; cnot_gate : qobj; Quantum object representation of CNOT gate. Examples; --------; >>> cnot(); Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True; Qobj data =; [[ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j 0.+0.j]; [ 0.+",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1074
https://github.com/qutip/qutip/pull/1074:2127,Integrability,wrap,wrapper,2127,"; >>> import qutip; >>> qutip.cnot(); __main__:1: DeprecationWarning: Importing functions/classes of the qip submodule directly from the namespace qutip is deprecated. Please import them from the submodule instead, e.g. qutip.qip import `func_name`.; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[1. 0. 0. 0.]; [0. 1. 0. 0.]; [0. 0. 0. 1.]; [0. 0. 1. 0.]]; >>> import qutip # warning appears only once.; >>> qutip.cnot(); Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[1. 0. 0. 0.]; [0. 1. 0. 0.]; [0. 0. 0. 1.]; [0. 0. 1. 0.]]; ```. The help function still works correctly:; ```; >>> help(cnot); Help on function cnot in module qutip.qip.gates:; cnot(N=None, control=0, target=1); Quantum object representing the CNOT gate. Returns; -------; cnot_gate : qobj; Quantum object representation of CNOT gate. Examples; --------; >>> cnot(); Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True; Qobj data =; [[ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j 0.+0.j]; [ 0.+0.j 0.+0.j 0.+0.j 1.+0.j]; [ 0.+0.j 0.+0.j 1.+0.j 0.+0.j]]; ```. The only flaw I found is that the traceback will stop at the wrapper function if the arguments are wrong; ```; >>> cnot(wrong_arg=1); __main__:1: DeprecationWarning: Importing functions/classes of the qip submodule directly from the namespace qutip is deprecated. Please import them from the submodule instead, e.g. qutip.qip import `func_name`.; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; File ""c:\users\boxi\onedrive\studium\qutip-project\qutip\qutip\__init__.py"", line 240, in deprecated_func; return func(*args, **kwargs); TypeError: cnot() got an unexpected keyword argument 'wrong_arg'; ```; Anyone would like to try it out and see if the behaviour is the same? For instance, running `test_entropy.py` now will give a warning because the importation is wrong there. All tests still pass.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1074
https://github.com/qutip/qutip/pull/1074:2872,Testability,test,tests,2872,"; >>> import qutip; >>> qutip.cnot(); __main__:1: DeprecationWarning: Importing functions/classes of the qip submodule directly from the namespace qutip is deprecated. Please import them from the submodule instead, e.g. qutip.qip import `func_name`.; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[1. 0. 0. 0.]; [0. 1. 0. 0.]; [0. 0. 0. 1.]; [0. 0. 1. 0.]]; >>> import qutip # warning appears only once.; >>> qutip.cnot(); Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[1. 0. 0. 0.]; [0. 1. 0. 0.]; [0. 0. 0. 1.]; [0. 0. 1. 0.]]; ```. The help function still works correctly:; ```; >>> help(cnot); Help on function cnot in module qutip.qip.gates:; cnot(N=None, control=0, target=1); Quantum object representing the CNOT gate. Returns; -------; cnot_gate : qobj; Quantum object representation of CNOT gate. Examples; --------; >>> cnot(); Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True; Qobj data =; [[ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j 0.+0.j]; [ 0.+0.j 0.+0.j 0.+0.j 1.+0.j]; [ 0.+0.j 0.+0.j 1.+0.j 0.+0.j]]; ```. The only flaw I found is that the traceback will stop at the wrapper function if the arguments are wrong; ```; >>> cnot(wrong_arg=1); __main__:1: DeprecationWarning: Importing functions/classes of the qip submodule directly from the namespace qutip is deprecated. Please import them from the submodule instead, e.g. qutip.qip import `func_name`.; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; File ""c:\users\boxi\onedrive\studium\qutip-project\qutip\qutip\__init__.py"", line 240, in deprecated_func; return func(*args, **kwargs); TypeError: cnot() got an unexpected keyword argument 'wrong_arg'; ```; Anyone would like to try it out and see if the behaviour is the same? For instance, running `test_entropy.py` now will give a warning because the importation is wrong there. All tests still pass.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1074
https://github.com/qutip/qutip/issues/1076:1009,Integrability,rout,routines,1009,"I've been playing around with larger systems recently; when I started out ptrace had a memory issue and couldn't handle what I was doing, so I had written a home-made version to do it. Recently I ended up doing the ptrace with the fixed built-in function and I found it to be much slower. I did some testing with my new function. At least on the machine I'm running on, with 9+ qubits it's about 10x faster for calculating a partial trace on a density matrix. If you're starting out with a ket, you can go even faster, an additional 5x improvement: (test code below); ```; Running time (ms/trace); 2 3 4 5 6 7 8 9 10 qubits; ptrace (dm) 0.4 0.3 0.3 0.3 0.6 1.9 6.6 33.4 137.9; new func (dm) 0.5 0.4 0.4 0.4 0.5 0.7 1.0 2.8 13.1 ; ptrace (ket) 0.6 0.5 0.5 0.5 0.9 2.7 8.5 37.2 167.7; new func (ket) 0.5 0.4 0.4 0.4 0.5 0.6 0.9 1.0 3.2 ; sum((rho-rho).norm()); dm 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; ket 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; ```. My new version is pretty simple, using numpy's built-in ndarray routines. I've looked at the code for ptrace and it's a bit opaque to me; at the moment I don't feel quite up to modifying it, so I'm just putting up the code I've used instead of doing a pull request. My new function is here:; ```; def ptracealt(rho,qkeep) :; rd = rho.dims[0]; nd = len(rd); qkeep = list(sort(qkeep)); dkeep = (np.array(rd)[qkeep]).tolist(); qtrace = list(set(np.arange(nd))-set(qkeep)); dtrace = (np.array(rd)[qtrace]).tolist(); if isket(rho) :; vmat = (rho.full(); .reshape(rd); .transpose(qkeep+qtrace); .reshape([prod(dkeep),prod(dtrace)])); rhomat = vmat.dot(vmat.conj().T); else :; rhomat = np.trace(rho.full(); .reshape(rd+rd); .transpose(qtrace+[nd+q for q in qtrace]+qkeep+[nd+q for q in qkeep]); .reshape([prod(dtrace),prod(dtrace),prod(dkeep),prod(dkeep)])); return Qobj(rhomat,dims=[dkeep, dkeep]); ```; and the test code here: ; ```; Nqmax=10; ntest = 100; trdiff = np.zeros([2,Nqmax-1]); ttr = np.zeros([4,Nqmax-1]); for nd in range(2,Nqmax+1) :; r0 = [ rand_d",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1076
https://github.com/qutip/qutip/issues/1076:300,Testability,test,testing,300,"I've been playing around with larger systems recently; when I started out ptrace had a memory issue and couldn't handle what I was doing, so I had written a home-made version to do it. Recently I ended up doing the ptrace with the fixed built-in function and I found it to be much slower. I did some testing with my new function. At least on the machine I'm running on, with 9+ qubits it's about 10x faster for calculating a partial trace on a density matrix. If you're starting out with a ket, you can go even faster, an additional 5x improvement: (test code below); ```; Running time (ms/trace); 2 3 4 5 6 7 8 9 10 qubits; ptrace (dm) 0.4 0.3 0.3 0.3 0.6 1.9 6.6 33.4 137.9; new func (dm) 0.5 0.4 0.4 0.4 0.5 0.7 1.0 2.8 13.1 ; ptrace (ket) 0.6 0.5 0.5 0.5 0.9 2.7 8.5 37.2 167.7; new func (ket) 0.5 0.4 0.4 0.4 0.5 0.6 0.9 1.0 3.2 ; sum((rho-rho).norm()); dm 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; ket 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; ```. My new version is pretty simple, using numpy's built-in ndarray routines. I've looked at the code for ptrace and it's a bit opaque to me; at the moment I don't feel quite up to modifying it, so I'm just putting up the code I've used instead of doing a pull request. My new function is here:; ```; def ptracealt(rho,qkeep) :; rd = rho.dims[0]; nd = len(rd); qkeep = list(sort(qkeep)); dkeep = (np.array(rd)[qkeep]).tolist(); qtrace = list(set(np.arange(nd))-set(qkeep)); dtrace = (np.array(rd)[qtrace]).tolist(); if isket(rho) :; vmat = (rho.full(); .reshape(rd); .transpose(qkeep+qtrace); .reshape([prod(dkeep),prod(dtrace)])); rhomat = vmat.dot(vmat.conj().T); else :; rhomat = np.trace(rho.full(); .reshape(rd+rd); .transpose(qtrace+[nd+q for q in qtrace]+qkeep+[nd+q for q in qkeep]); .reshape([prod(dtrace),prod(dtrace),prod(dkeep),prod(dkeep)])); return Qobj(rhomat,dims=[dkeep, dkeep]); ```; and the test code here: ; ```; Nqmax=10; ntest = 100; trdiff = np.zeros([2,Nqmax-1]); ttr = np.zeros([4,Nqmax-1]); for nd in range(2,Nqmax+1) :; r0 = [ rand_d",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1076
https://github.com/qutip/qutip/issues/1076:550,Testability,test,test,550,"I've been playing around with larger systems recently; when I started out ptrace had a memory issue and couldn't handle what I was doing, so I had written a home-made version to do it. Recently I ended up doing the ptrace with the fixed built-in function and I found it to be much slower. I did some testing with my new function. At least on the machine I'm running on, with 9+ qubits it's about 10x faster for calculating a partial trace on a density matrix. If you're starting out with a ket, you can go even faster, an additional 5x improvement: (test code below); ```; Running time (ms/trace); 2 3 4 5 6 7 8 9 10 qubits; ptrace (dm) 0.4 0.3 0.3 0.3 0.6 1.9 6.6 33.4 137.9; new func (dm) 0.5 0.4 0.4 0.4 0.5 0.7 1.0 2.8 13.1 ; ptrace (ket) 0.6 0.5 0.5 0.5 0.9 2.7 8.5 37.2 167.7; new func (ket) 0.5 0.4 0.4 0.4 0.5 0.6 0.9 1.0 3.2 ; sum((rho-rho).norm()); dm 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; ket 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; ```. My new version is pretty simple, using numpy's built-in ndarray routines. I've looked at the code for ptrace and it's a bit opaque to me; at the moment I don't feel quite up to modifying it, so I'm just putting up the code I've used instead of doing a pull request. My new function is here:; ```; def ptracealt(rho,qkeep) :; rd = rho.dims[0]; nd = len(rd); qkeep = list(sort(qkeep)); dkeep = (np.array(rd)[qkeep]).tolist(); qtrace = list(set(np.arange(nd))-set(qkeep)); dtrace = (np.array(rd)[qtrace]).tolist(); if isket(rho) :; vmat = (rho.full(); .reshape(rd); .transpose(qkeep+qtrace); .reshape([prod(dkeep),prod(dtrace)])); rhomat = vmat.dot(vmat.conj().T); else :; rhomat = np.trace(rho.full(); .reshape(rd+rd); .transpose(qtrace+[nd+q for q in qtrace]+qkeep+[nd+q for q in qkeep]); .reshape([prod(dtrace),prod(dtrace),prod(dkeep),prod(dkeep)])); return Qobj(rhomat,dims=[dkeep, dkeep]); ```; and the test code here: ; ```; Nqmax=10; ntest = 100; trdiff = np.zeros([2,Nqmax-1]); ttr = np.zeros([4,Nqmax-1]); for nd in range(2,Nqmax+1) :; r0 = [ rand_d",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1076
https://github.com/qutip/qutip/issues/1076:1851,Testability,test,test,1851," 0.9 1.0 3.2 ; sum((rho-rho).norm()); dm 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; ket 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; ```. My new version is pretty simple, using numpy's built-in ndarray routines. I've looked at the code for ptrace and it's a bit opaque to me; at the moment I don't feel quite up to modifying it, so I'm just putting up the code I've used instead of doing a pull request. My new function is here:; ```; def ptracealt(rho,qkeep) :; rd = rho.dims[0]; nd = len(rd); qkeep = list(sort(qkeep)); dkeep = (np.array(rd)[qkeep]).tolist(); qtrace = list(set(np.arange(nd))-set(qkeep)); dtrace = (np.array(rd)[qtrace]).tolist(); if isket(rho) :; vmat = (rho.full(); .reshape(rd); .transpose(qkeep+qtrace); .reshape([prod(dkeep),prod(dtrace)])); rhomat = vmat.dot(vmat.conj().T); else :; rhomat = np.trace(rho.full(); .reshape(rd+rd); .transpose(qtrace+[nd+q for q in qtrace]+qkeep+[nd+q for q in qkeep]); .reshape([prod(dtrace),prod(dtrace),prod(dkeep),prod(dkeep)])); return Qobj(rhomat,dims=[dkeep, dkeep]); ```; and the test code here: ; ```; Nqmax=10; ntest = 100; trdiff = np.zeros([2,Nqmax-1]); ttr = np.zeros([4,Nqmax-1]); for nd in range(2,Nqmax+1) :; r0 = [ rand_dm(2**nd,dims=[[2 for j in range(nd)] for l in range(2)]) for i in range(ntest) ]; v0 = [ rand_ket(2**nd) for i in range(ntest) ]; for v in v0 :; v.dims = [[2 for j in range(nd)],[1 for j in range(nd)]]; subs = [ np.random.choice(range(nd),np.random.randint(1,nd),replace=False).tolist() for i in range(ntest) ]; t0 = time.time(); rhotr1 = [r.ptrace(p) for r,p in zip(r0,subs)]; ttr[0,nd-2] = (time.time()-t0)/ntest; t0 = time.time(); rhotr2 = [ptracealt(r,p) for r,p in zip(r0,subs)]; ttr[1,nd-2] = (time.time()-t0)/ntest; t0 = time.time(); vtr1 = [v.ptrace(p) for v,p in zip(v0,subs)]; ttr[2,nd-2] = (time.time()-t0)/ntest; t0 = time.time(); vtr2 = [ptracealt(v,p) for v,p in zip(v0,subs)]; ttr[3,nd-2] = (time.time()-t0)/ntest; trdiff[0,nd-2] = sum([(r1 - r2).norm() for r1,r2 in zip(rhotr1,rhotr2)]); trdiff[1,nd-2] = ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1076
https://github.com/qutip/qutip/issues/1076:4204,Testability,log,log,4204," in range(ntest) ]; t0 = time.time(); rhotr1 = [r.ptrace(p) for r,p in zip(r0,subs)]; ttr[0,nd-2] = (time.time()-t0)/ntest; t0 = time.time(); rhotr2 = [ptracealt(r,p) for r,p in zip(r0,subs)]; ttr[1,nd-2] = (time.time()-t0)/ntest; t0 = time.time(); vtr1 = [v.ptrace(p) for v,p in zip(v0,subs)]; ttr[2,nd-2] = (time.time()-t0)/ntest; t0 = time.time(); vtr2 = [ptracealt(v,p) for v,p in zip(v0,subs)]; ttr[3,nd-2] = (time.time()-t0)/ntest; trdiff[0,nd-2] = sum([(r1 - r2).norm() for r1,r2 in zip(rhotr1,rhotr2)]); trdiff[1,nd-2] = sum([(r1 - r2).norm() for r1,r2 in zip(vtr1,vtr2)]); print(str(nd)+' qubits: rand dm rand ket'); print('ptrace: '+str(round(1000*ttr[0,nd-2],2))+' '+str(round(1000*ttr[2,nd-2],2))+' ms/trace'); print('new funcs: '+str(round(1000*ttr[1,nd-2],2))+' '+str(round(1000*ttr[3,nd-2],2))+' ms/trace'); print(' Sum diff = '+str(trdiff[0,nd-2])+', '+str(trdiff[1,nd-2])); print('Running time (ms/trace)'); print(' '+' '.join([str(n) for n in range(2,Nqmax+1)])+' qubits'); print('ptrace (dm) '+' '.join([(lambda x : x+''.join([' ' for m in range(5-len(x))]))(str(round(1000*x,1))) for x in ttr[0]])); print('new func (dm) '+' '.join([(lambda x : x+''.join([' ' for m in range(5-len(x))]))(str(round(1000*x,1))) for x in ttr[1]])); print('ptrace (ket) '+' '.join([(lambda x : x+''.join([' ' for m in range(5-len(x))]))(str(round(1000*x,1))) for x in ttr[2]])); print('new func (ket) '+' '.join([(lambda x : x+''.join([' ' for m in range(5-len(x))]))(str(round(1000*x,1))) for x in ttr[3]])); print('sum((rho-rho).norm())'); print('dm '+' '.join([str(x) for x in trdiff[0]])); print('ket '+' '.join([str(x) for x in trdiff[0]])); plt.plot(range(2,Nqmax+1),ttr[0],c='C0'); plt.plot(range(2,Nqmax+1),ttr[2],c='C0',linestyle='--'); plt.plot(range(2,Nqmax+1),ttr[1],c='C1'); plt.plot(range(2,Nqmax+1),ttr[3],c='C1',linestyle='--'); plt.xlabel('# qubits'); plt.ylabel('time/trace [s]'); plt.yscale('log'); plt.legend(['ptrace (dm)','ptrace (ket)', 'new func (dm)', 'new func (ket)']); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1076
https://github.com/qutip/qutip/issues/1076:970,Usability,simpl,simple,970,"I've been playing around with larger systems recently; when I started out ptrace had a memory issue and couldn't handle what I was doing, so I had written a home-made version to do it. Recently I ended up doing the ptrace with the fixed built-in function and I found it to be much slower. I did some testing with my new function. At least on the machine I'm running on, with 9+ qubits it's about 10x faster for calculating a partial trace on a density matrix. If you're starting out with a ket, you can go even faster, an additional 5x improvement: (test code below); ```; Running time (ms/trace); 2 3 4 5 6 7 8 9 10 qubits; ptrace (dm) 0.4 0.3 0.3 0.3 0.6 1.9 6.6 33.4 137.9; new func (dm) 0.5 0.4 0.4 0.4 0.5 0.7 1.0 2.8 13.1 ; ptrace (ket) 0.6 0.5 0.5 0.5 0.9 2.7 8.5 37.2 167.7; new func (ket) 0.5 0.4 0.4 0.4 0.5 0.6 0.9 1.0 3.2 ; sum((rho-rho).norm()); dm 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; ket 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; ```. My new version is pretty simple, using numpy's built-in ndarray routines. I've looked at the code for ptrace and it's a bit opaque to me; at the moment I don't feel quite up to modifying it, so I'm just putting up the code I've used instead of doing a pull request. My new function is here:; ```; def ptracealt(rho,qkeep) :; rd = rho.dims[0]; nd = len(rd); qkeep = list(sort(qkeep)); dkeep = (np.array(rd)[qkeep]).tolist(); qtrace = list(set(np.arange(nd))-set(qkeep)); dtrace = (np.array(rd)[qtrace]).tolist(); if isket(rho) :; vmat = (rho.full(); .reshape(rd); .transpose(qkeep+qtrace); .reshape([prod(dkeep),prod(dtrace)])); rhomat = vmat.dot(vmat.conj().T); else :; rhomat = np.trace(rho.full(); .reshape(rd+rd); .transpose(qtrace+[nd+q for q in qtrace]+qkeep+[nd+q for q in qkeep]); .reshape([prod(dtrace),prod(dtrace),prod(dkeep),prod(dkeep)])); return Qobj(rhomat,dims=[dkeep, dkeep]); ```; and the test code here: ; ```; Nqmax=10; ntest = 100; trdiff = np.zeros([2,Nqmax-1]); ttr = np.zeros([4,Nqmax-1]); for nd in range(2,Nqmax+1) :; r0 = [ rand_d",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1076
https://github.com/qutip/qutip/issues/1077:1071,Availability,error,error,1071,"n; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details.; QuTiP Version: 4.4.1; Numpy Version: 1.16.4; Scipy Version: 1.2.1; Cython Version: 0.29.12; Matplotlib Version: 3.1.0; Python Version: 3.7.3; Number of CPUs: 4; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Windows (AMD64); Installation path: C:\Users\migue\Anaconda\lib\site-packages\qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()` ; ```. and I get this error repeatedly when using the `steadystate` function. . ```; OSError Traceback (most recent call last); <ipython-input-3-4ef4797a881f> in <module>; 30 g2_v = []; 31 for p, x in enumerate(Gamma_vec):; ---> 32 j, z = calculate_avg_photons(N, x); 33 print(p); 34 n_avg.append(j). <ipython-input-3-4ef4797a881f> in calculate_avg_photons(N, Gamma); 18 c_ops.append(np.sqrt(rate)*sm.dag()); 19 ; ---> 20 rho = steadystate(H,c_ops); 21 n_cav = expect(a.dag()*a,rho); 22 g2_cav = expect(a.dag()*a.dag()*a*a,rho)/(n_cav**2). ~\Anaconda\lib\site-packages\qutip\steadystate.py in steadystate(A, c_op_list, method, solver, **kwargs); 288 if (ss_args['solver'] == 'scipy' and ss_args['sparse']) \; 289 or ss_args['solver'] == 'mkl':; --> 290 return _steadystate_direct_sparse(A, ss_args); 291 else:; 292 return _steadystate_direct_dense(A, ss_args). ~\Anaconda\lib\site-packages\qutip\steadystate.py in _steadystate_direct_sparse(L, ss_args); 458 max_iter_refine=ss_args['max_iter_refine'],; 459 scaling_vectors=ss_args['scaling_ve",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1077
https://github.com/qutip/qutip/issues/1077:2849,Availability,error,error,2849," ; ```. and I get this error repeatedly when using the `steadystate` function. . ```; OSError Traceback (most recent call last); <ipython-input-3-4ef4797a881f> in <module>; 30 g2_v = []; 31 for p, x in enumerate(Gamma_vec):; ---> 32 j, z = calculate_avg_photons(N, x); 33 print(p); 34 n_avg.append(j). <ipython-input-3-4ef4797a881f> in calculate_avg_photons(N, Gamma); 18 c_ops.append(np.sqrt(rate)*sm.dag()); 19 ; ---> 20 rho = steadystate(H,c_ops); 21 n_cav = expect(a.dag()*a,rho); 22 g2_cav = expect(a.dag()*a.dag()*a*a,rho)/(n_cav**2). ~\Anaconda\lib\site-packages\qutip\steadystate.py in steadystate(A, c_op_list, method, solver, **kwargs); 288 if (ss_args['solver'] == 'scipy' and ss_args['sparse']) \; 289 or ss_args['solver'] == 'mkl':; --> 290 return _steadystate_direct_sparse(A, ss_args); 291 else:; 292 return _steadystate_direct_dense(A, ss_args). ~\Anaconda\lib\site-packages\qutip\steadystate.py in _steadystate_direct_sparse(L, ss_args); 458 max_iter_refine=ss_args['max_iter_refine'],; 459 scaling_vectors=ss_args['scaling_vectors'],; --> 460 weighted_matching=ss_args['weighted_matching']); 461 _direct_end = time.time(); 462 ss_args['info']['solution_time'] = _direct_end-_direct_start. ~\Anaconda\lib\site-packages\qutip\_mkl\spsolve.py in mkl_spsolve(A, b, perm, verbose, **kwargs); 391 # Do dense RHS solving; 392 if not b_is_sparse:; --> 393 x = lu.solve(b, verbose=verbose); 394 # Solve each RHS vec individually and convert to sparse; 395 else:. ~\Anaconda\lib\site-packages\qutip\_mkl\spsolve.py in solve(self, b, verbose); 168 byref(c_int(33)), byref(c_int(self._dim)), self._data, self._indptr, self._indices,; 169 self._np_perm, byref(c_int(nrhs)), self._np_iparm, byref(c_int(0)), np_b,; --> 170 np_x, np_error); 171 self._solve_time = time.time() -_solve_start; 172 if error[0] != 0:. OSError: exception: access violation reading 0x0000000000000008; ``` . The does not raise every time I use the function and it has a different number at the end everytime it is shown.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1077
https://github.com/qutip/qutip/issues/1077:625,Deployability,Install,Installed,625,"Hello,. I'm using the following system and versions:; ```; QuTiP: Quantum Toolbox in Python; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details.; QuTiP Version: 4.4.1; Numpy Version: 1.16.4; Scipy Version: 1.2.1; Cython Version: 0.29.12; Matplotlib Version: 3.1.0; Python Version: 3.7.3; Number of CPUs: 4; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Windows (AMD64); Installation path: C:\Users\migue\Anaconda\lib\site-packages\qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()` ; ```. and I get this error repeatedly when using the `steadystate` function. . ```; OSError Traceback (most recent call last); <ipython-input-3-4ef4797a881f> in <module>; 30 g2_v = []; 31 for p, x in enumerate(Gamma_vec):; ---> 32 j, z = calculate_avg_photons(N, x); 33 print(p); 34 n_avg.append(j). <ipython-input-3-4ef4797a881f> in calculate_avg_photons(N, Gamma); 18 c_ops.append(np.sqrt(rate)*sm.dag()); 19 ; ---> 20 rho = steadystate(H,c_ops); 21 n_cav = expect(a.dag()*a,rho); 22 g2_cav = expect(a.dag()*a.dag()*a*a,rho)/(n_cav**2). ~\Anaconda\lib\site-packages\qutip\steadystate.py in steadystate(A, c_op_list, method, solver, **kwargs); 288 if (ss_args['solver'] == 'scipy' and ss_args['sparse']) \; 289 or ss_args['solver'] == 'mkl':; --> 290 return _steadystate_direct_sparse(A, ss_args); 291 else:; 292 return _steadystate_direct_dense(A, ss_args). ~\Anaconda\lib\site-packages\qutip\steadystate.py in _steadystate_direct_sparse(L, ss_args)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1077
https://github.com/qutip/qutip/issues/1077:696,Deployability,Install,Installation,696,"Hello,. I'm using the following system and versions:; ```; QuTiP: Quantum Toolbox in Python; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details.; QuTiP Version: 4.4.1; Numpy Version: 1.16.4; Scipy Version: 1.2.1; Cython Version: 0.29.12; Matplotlib Version: 3.1.0; Python Version: 3.7.3; Number of CPUs: 4; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Windows (AMD64); Installation path: C:\Users\migue\Anaconda\lib\site-packages\qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()` ; ```. and I get this error repeatedly when using the `steadystate` function. . ```; OSError Traceback (most recent call last); <ipython-input-3-4ef4797a881f> in <module>; 30 g2_v = []; 31 for p, x in enumerate(Gamma_vec):; ---> 32 j, z = calculate_avg_photons(N, x); 33 print(p); 34 n_avg.append(j). <ipython-input-3-4ef4797a881f> in calculate_avg_photons(N, Gamma); 18 c_ops.append(np.sqrt(rate)*sm.dag()); 19 ; ---> 20 rho = steadystate(H,c_ops); 21 n_cav = expect(a.dag()*a,rho); 22 g2_cav = expect(a.dag()*a.dag()*a*a,rho)/(n_cav**2). ~\Anaconda\lib\site-packages\qutip\steadystate.py in steadystate(A, c_op_list, method, solver, **kwargs); 288 if (ss_args['solver'] == 'scipy' and ss_args['sparse']) \; 289 or ss_args['solver'] == 'mkl':; --> 290 return _steadystate_direct_sparse(A, ss_args); 291 else:; 292 return _steadystate_direct_dense(A, ss_args). ~\Anaconda\lib\site-packages\qutip\steadystate.py in _steadystate_direct_sparse(L, ss_args)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1077
https://github.com/qutip/qutip/issues/1077:2885,Security,access,access,2885," ; ```. and I get this error repeatedly when using the `steadystate` function. . ```; OSError Traceback (most recent call last); <ipython-input-3-4ef4797a881f> in <module>; 30 g2_v = []; 31 for p, x in enumerate(Gamma_vec):; ---> 32 j, z = calculate_avg_photons(N, x); 33 print(p); 34 n_avg.append(j). <ipython-input-3-4ef4797a881f> in calculate_avg_photons(N, Gamma); 18 c_ops.append(np.sqrt(rate)*sm.dag()); 19 ; ---> 20 rho = steadystate(H,c_ops); 21 n_cav = expect(a.dag()*a,rho); 22 g2_cav = expect(a.dag()*a.dag()*a*a,rho)/(n_cav**2). ~\Anaconda\lib\site-packages\qutip\steadystate.py in steadystate(A, c_op_list, method, solver, **kwargs); 288 if (ss_args['solver'] == 'scipy' and ss_args['sparse']) \; 289 or ss_args['solver'] == 'mkl':; --> 290 return _steadystate_direct_sparse(A, ss_args); 291 else:; 292 return _steadystate_direct_dense(A, ss_args). ~\Anaconda\lib\site-packages\qutip\steadystate.py in _steadystate_direct_sparse(L, ss_args); 458 max_iter_refine=ss_args['max_iter_refine'],; 459 scaling_vectors=ss_args['scaling_vectors'],; --> 460 weighted_matching=ss_args['weighted_matching']); 461 _direct_end = time.time(); 462 ss_args['info']['solution_time'] = _direct_end-_direct_start. ~\Anaconda\lib\site-packages\qutip\_mkl\spsolve.py in mkl_spsolve(A, b, perm, verbose, **kwargs); 391 # Do dense RHS solving; 392 if not b_is_sparse:; --> 393 x = lu.solve(b, verbose=verbose); 394 # Solve each RHS vec individually and convert to sparse; 395 else:. ~\Anaconda\lib\site-packages\qutip\_mkl\spsolve.py in solve(self, b, verbose); 168 byref(c_int(33)), byref(c_int(self._dim)), self._data, self._indptr, self._indices,; 169 self._np_perm, byref(c_int(nrhs)), self._np_iparm, byref(c_int(0)), np_b,; --> 170 np_x, np_error); 171 self._solve_time = time.time() -_solve_start; 172 if error[0] != 0:. OSError: exception: access violation reading 0x0000000000000008; ``` . The does not raise every time I use the function and it has a different number at the end everytime it is shown.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1077
https://github.com/qutip/qutip/issues/1079:150,Availability,error,errors,150,"I had tried many times to install the anaconda3.5 3.6 and 3.7, for installing qutip 4.4.0or4.4.1. But when I verifying the Installation, some similar errors always occur, as indicated below; ![QQ截图20190831230327](https://user-images.githubusercontent.com/54746315/64065880-d92e2300-cc45-11e9-9672-f13fca2ffb36.png); ps: I have install vs2015 and option for c++ compiler; in addition, there are some installation information as below; ![QQ截图20190831224652](https://user-images.githubusercontent.com/54746315/64065902-26aa9000-cc46-11e9-9c60-6796fc1deff7.png); the red underline has indicated some problem, is it matter?; who can give some advice for dealing with it? ; Thanks a lot",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1079
https://github.com/qutip/qutip/issues/1079:26,Deployability,install,install,26,"I had tried many times to install the anaconda3.5 3.6 and 3.7, for installing qutip 4.4.0or4.4.1. But when I verifying the Installation, some similar errors always occur, as indicated below; ![QQ截图20190831230327](https://user-images.githubusercontent.com/54746315/64065880-d92e2300-cc45-11e9-9672-f13fca2ffb36.png); ps: I have install vs2015 and option for c++ compiler; in addition, there are some installation information as below; ![QQ截图20190831224652](https://user-images.githubusercontent.com/54746315/64065902-26aa9000-cc46-11e9-9c60-6796fc1deff7.png); the red underline has indicated some problem, is it matter?; who can give some advice for dealing with it? ; Thanks a lot",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1079
https://github.com/qutip/qutip/issues/1079:67,Deployability,install,installing,67,"I had tried many times to install the anaconda3.5 3.6 and 3.7, for installing qutip 4.4.0or4.4.1. But when I verifying the Installation, some similar errors always occur, as indicated below; ![QQ截图20190831230327](https://user-images.githubusercontent.com/54746315/64065880-d92e2300-cc45-11e9-9672-f13fca2ffb36.png); ps: I have install vs2015 and option for c++ compiler; in addition, there are some installation information as below; ![QQ截图20190831224652](https://user-images.githubusercontent.com/54746315/64065902-26aa9000-cc46-11e9-9c60-6796fc1deff7.png); the red underline has indicated some problem, is it matter?; who can give some advice for dealing with it? ; Thanks a lot",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1079
https://github.com/qutip/qutip/issues/1079:123,Deployability,Install,Installation,123,"I had tried many times to install the anaconda3.5 3.6 and 3.7, for installing qutip 4.4.0or4.4.1. But when I verifying the Installation, some similar errors always occur, as indicated below; ![QQ截图20190831230327](https://user-images.githubusercontent.com/54746315/64065880-d92e2300-cc45-11e9-9672-f13fca2ffb36.png); ps: I have install vs2015 and option for c++ compiler; in addition, there are some installation information as below; ![QQ截图20190831224652](https://user-images.githubusercontent.com/54746315/64065902-26aa9000-cc46-11e9-9c60-6796fc1deff7.png); the red underline has indicated some problem, is it matter?; who can give some advice for dealing with it? ; Thanks a lot",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1079
https://github.com/qutip/qutip/issues/1079:327,Deployability,install,install,327,"I had tried many times to install the anaconda3.5 3.6 and 3.7, for installing qutip 4.4.0or4.4.1. But when I verifying the Installation, some similar errors always occur, as indicated below; ![QQ截图20190831230327](https://user-images.githubusercontent.com/54746315/64065880-d92e2300-cc45-11e9-9672-f13fca2ffb36.png); ps: I have install vs2015 and option for c++ compiler; in addition, there are some installation information as below; ![QQ截图20190831224652](https://user-images.githubusercontent.com/54746315/64065902-26aa9000-cc46-11e9-9c60-6796fc1deff7.png); the red underline has indicated some problem, is it matter?; who can give some advice for dealing with it? ; Thanks a lot",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1079
https://github.com/qutip/qutip/issues/1079:399,Deployability,install,installation,399,"I had tried many times to install the anaconda3.5 3.6 and 3.7, for installing qutip 4.4.0or4.4.1. But when I verifying the Installation, some similar errors always occur, as indicated below; ![QQ截图20190831230327](https://user-images.githubusercontent.com/54746315/64065880-d92e2300-cc45-11e9-9672-f13fca2ffb36.png); ps: I have install vs2015 and option for c++ compiler; in addition, there are some installation information as below; ![QQ截图20190831224652](https://user-images.githubusercontent.com/54746315/64065902-26aa9000-cc46-11e9-9c60-6796fc1deff7.png); the red underline has indicated some problem, is it matter?; who can give some advice for dealing with it? ; Thanks a lot",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1079
https://github.com/qutip/qutip/issues/1081:84,Integrability,depend,dependent,84,"Dear @Ericgig,. I have a problem with interrupting calculation of sesolve with time dependent Hamiltonian. It just doesn't stop and shows this:. > ---------------------------------------------------------------------------; > KeyboardInterrupt Traceback (most recent call last); > //miniconda3/lib/python3.7/site-packages/qutip-4.5.0.dev0-py3.7-macosx-10.7-x86_64.egg/qutip/qobjevo.py in __call__(self, t, args); > 1639 self.args[name] = op.expect(t, state); > 1640 ; > -> 1641 def __call__(self, t, args=None):; > 1642 if args:; > 1643 now_args = self.args.copy(); > ; > KeyboardInterrupt: ; > ; > Exception ignored in: 'qutip.cy.cqobjevo.CQobjEvo._factor'; > Traceback (most recent call last):; > File ""//miniconda3/lib/python3.7/site-packages/qutip-4.5.0.dev0-py3.7-macosx-10.7-x86_64.egg/qutip/qobjevo.py"", line 1641, in __call__; > def __call__(self, t, args=None):; > KeyboardInterrupt. Any idea what can cause this problem?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1081
https://github.com/qutip/qutip/pull/1082:145,Availability,avail,available,145,"Added the option to import string to python instead of compiling to cython for QobjEvo.; This is default if no cython, or set manually if cython available. `QobjEvoInstance.use_cython = False`; Added test and updated docstring.; Work in parallel.; Did not do any benchmark yet.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1082
https://github.com/qutip/qutip/pull/1082:209,Deployability,update,updated,209,"Added the option to import string to python instead of compiling to cython for QobjEvo.; This is default if no cython, or set manually if cython available. `QobjEvoInstance.use_cython = False`; Added test and updated docstring.; Work in parallel.; Did not do any benchmark yet.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1082
https://github.com/qutip/qutip/pull/1082:200,Testability,test,test,200,"Added the option to import string to python instead of compiling to cython for QobjEvo.; This is default if no cython, or set manually if cython available. `QobjEvoInstance.use_cython = False`; Added test and updated docstring.; Work in parallel.; Did not do any benchmark yet.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1082
https://github.com/qutip/qutip/pull/1082:263,Testability,benchmark,benchmark,263,"Added the option to import string to python instead of compiling to cython for QobjEvo.; This is default if no cython, or set manually if cython available. `QobjEvoInstance.use_cython = False`; Added test and updated docstring.; Work in parallel.; Did not do any benchmark yet.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1082
https://github.com/qutip/qutip/issues/1084:69,Availability,error,error,69,"Running this code; import qutip.testing as qt; qt.run(); produces an error:. Monte-carlo: Collapse terms constant (str format) ... cl : Command line warning D9025 : overriding '/W3' with '/w'; cl : Command line warning D9025 : overriding '/Ox' with '/O1'; cqobjevo_compiled_coeff_130828459648281117.cpp; c:\anaconda\lib\site-packages\numpy\core\include\numpy\npy_1_7_deprecated_api.h(14) : Warning Msg: Using deprecated NumPy API, disable it with #define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION; Creating library C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_130828459648281117.cp37-win_amd64.lib and object C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_130828459648281117.cp37-win_amd64.exp; Generating code; Finished generating code; cl : Command line warning D9025 : overriding '/W3' with '/w'; cl : Command line warning D9025 : overriding '/Ox' with '/O1'; cqobjevo_compiled_coeff_8398411180025011525.cpp; c:\anaconda\lib\site-packages\numpy\core\include\numpy\npy_1_7_deprecated_api.h(14) : Warning Msg: Using deprecated NumPy API, disable it with #define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION; Creating library C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_8398411180025011525.cp37-win_amd64.lib and object C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_8398411180025011525.cp37-win_amd64.exp; Generating code; Finished generating code; Process SpawnPoolWorker-671:; Process SpawnPoolWorker-669:; Traceback (most recent call last):; Traceback (most recent call last):; File ""C:\Anaconda\lib\multiprocessing\process.py"", line 297, in _bootstrap; self.run(); File ""C:\Anaconda\lib\multiprocessing\process.py"", line 297, in _bootstrap; self.run(); File ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1084
https://github.com/qutip/qutip/issues/1084:559,Deployability,Release,Release,559,"Running this code; import qutip.testing as qt; qt.run(); produces an error:. Monte-carlo: Collapse terms constant (str format) ... cl : Command line warning D9025 : overriding '/W3' with '/w'; cl : Command line warning D9025 : overriding '/Ox' with '/O1'; cqobjevo_compiled_coeff_130828459648281117.cpp; c:\anaconda\lib\site-packages\numpy\core\include\numpy\npy_1_7_deprecated_api.h(14) : Warning Msg: Using deprecated NumPy API, disable it with #define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION; Creating library C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_130828459648281117.cp37-win_amd64.lib and object C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_130828459648281117.cp37-win_amd64.exp; Generating code; Finished generating code; cl : Command line warning D9025 : overriding '/W3' with '/w'; cl : Command line warning D9025 : overriding '/Ox' with '/O1'; cqobjevo_compiled_coeff_8398411180025011525.cpp; c:\anaconda\lib\site-packages\numpy\core\include\numpy\npy_1_7_deprecated_api.h(14) : Warning Msg: Using deprecated NumPy API, disable it with #define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION; Creating library C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_8398411180025011525.cp37-win_amd64.lib and object C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_8398411180025011525.cp37-win_amd64.exp; Generating code; Finished generating code; Process SpawnPoolWorker-671:; Process SpawnPoolWorker-669:; Traceback (most recent call last):; Traceback (most recent call last):; File ""C:\Anaconda\lib\multiprocessing\process.py"", line 297, in _bootstrap; self.run(); File ""C:\Anaconda\lib\multiprocessing\process.py"", line 297, in _bootstrap; self.run(); File ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1084
https://github.com/qutip/qutip/issues/1084:608,Deployability,Release,Release,608,"Running this code; import qutip.testing as qt; qt.run(); produces an error:. Monte-carlo: Collapse terms constant (str format) ... cl : Command line warning D9025 : overriding '/W3' with '/w'; cl : Command line warning D9025 : overriding '/Ox' with '/O1'; cqobjevo_compiled_coeff_130828459648281117.cpp; c:\anaconda\lib\site-packages\numpy\core\include\numpy\npy_1_7_deprecated_api.h(14) : Warning Msg: Using deprecated NumPy API, disable it with #define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION; Creating library C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_130828459648281117.cp37-win_amd64.lib and object C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_130828459648281117.cp37-win_amd64.exp; Generating code; Finished generating code; cl : Command line warning D9025 : overriding '/W3' with '/w'; cl : Command line warning D9025 : overriding '/Ox' with '/O1'; cqobjevo_compiled_coeff_8398411180025011525.cpp; c:\anaconda\lib\site-packages\numpy\core\include\numpy\npy_1_7_deprecated_api.h(14) : Warning Msg: Using deprecated NumPy API, disable it with #define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION; Creating library C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_8398411180025011525.cp37-win_amd64.lib and object C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_8398411180025011525.cp37-win_amd64.exp; Generating code; Finished generating code; Process SpawnPoolWorker-671:; Process SpawnPoolWorker-669:; Traceback (most recent call last):; Traceback (most recent call last):; File ""C:\Anaconda\lib\multiprocessing\process.py"", line 297, in _bootstrap; self.run(); File ""C:\Anaconda\lib\multiprocessing\process.py"", line 297, in _bootstrap; self.run(); File ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1084
https://github.com/qutip/qutip/issues/1084:739,Deployability,Release,Release,739,"Running this code; import qutip.testing as qt; qt.run(); produces an error:. Monte-carlo: Collapse terms constant (str format) ... cl : Command line warning D9025 : overriding '/W3' with '/w'; cl : Command line warning D9025 : overriding '/Ox' with '/O1'; cqobjevo_compiled_coeff_130828459648281117.cpp; c:\anaconda\lib\site-packages\numpy\core\include\numpy\npy_1_7_deprecated_api.h(14) : Warning Msg: Using deprecated NumPy API, disable it with #define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION; Creating library C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_130828459648281117.cp37-win_amd64.lib and object C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_130828459648281117.cp37-win_amd64.exp; Generating code; Finished generating code; cl : Command line warning D9025 : overriding '/W3' with '/w'; cl : Command line warning D9025 : overriding '/Ox' with '/O1'; cqobjevo_compiled_coeff_8398411180025011525.cpp; c:\anaconda\lib\site-packages\numpy\core\include\numpy\npy_1_7_deprecated_api.h(14) : Warning Msg: Using deprecated NumPy API, disable it with #define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION; Creating library C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_8398411180025011525.cp37-win_amd64.lib and object C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_8398411180025011525.cp37-win_amd64.exp; Generating code; Finished generating code; Process SpawnPoolWorker-671:; Process SpawnPoolWorker-669:; Traceback (most recent call last):; Traceback (most recent call last):; File ""C:\Anaconda\lib\multiprocessing\process.py"", line 297, in _bootstrap; self.run(); File ""C:\Anaconda\lib\multiprocessing\process.py"", line 297, in _bootstrap; self.run(); File ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1084
https://github.com/qutip/qutip/issues/1084:788,Deployability,Release,Release,788,"Running this code; import qutip.testing as qt; qt.run(); produces an error:. Monte-carlo: Collapse terms constant (str format) ... cl : Command line warning D9025 : overriding '/W3' with '/w'; cl : Command line warning D9025 : overriding '/Ox' with '/O1'; cqobjevo_compiled_coeff_130828459648281117.cpp; c:\anaconda\lib\site-packages\numpy\core\include\numpy\npy_1_7_deprecated_api.h(14) : Warning Msg: Using deprecated NumPy API, disable it with #define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION; Creating library C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_130828459648281117.cp37-win_amd64.lib and object C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_130828459648281117.cp37-win_amd64.exp; Generating code; Finished generating code; cl : Command line warning D9025 : overriding '/W3' with '/w'; cl : Command line warning D9025 : overriding '/Ox' with '/O1'; cqobjevo_compiled_coeff_8398411180025011525.cpp; c:\anaconda\lib\site-packages\numpy\core\include\numpy\npy_1_7_deprecated_api.h(14) : Warning Msg: Using deprecated NumPy API, disable it with #define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION; Creating library C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_8398411180025011525.cp37-win_amd64.lib and object C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_8398411180025011525.cp37-win_amd64.exp; Generating code; Finished generating code; Process SpawnPoolWorker-671:; Process SpawnPoolWorker-669:; Traceback (most recent call last):; Traceback (most recent call last):; File ""C:\Anaconda\lib\multiprocessing\process.py"", line 297, in _bootstrap; self.run(); File ""C:\Anaconda\lib\multiprocessing\process.py"", line 297, in _bootstrap; self.run(); File ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1084
https://github.com/qutip/qutip/issues/1084:1337,Deployability,Release,Release,1337,"clude\numpy\npy_1_7_deprecated_api.h(14) : Warning Msg: Using deprecated NumPy API, disable it with #define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION; Creating library C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_130828459648281117.cp37-win_amd64.lib and object C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_130828459648281117.cp37-win_amd64.exp; Generating code; Finished generating code; cl : Command line warning D9025 : overriding '/W3' with '/w'; cl : Command line warning D9025 : overriding '/Ox' with '/O1'; cqobjevo_compiled_coeff_8398411180025011525.cpp; c:\anaconda\lib\site-packages\numpy\core\include\numpy\npy_1_7_deprecated_api.h(14) : Warning Msg: Using deprecated NumPy API, disable it with #define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION; Creating library C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_8398411180025011525.cp37-win_amd64.lib and object C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_8398411180025011525.cp37-win_amd64.exp; Generating code; Finished generating code; Process SpawnPoolWorker-671:; Process SpawnPoolWorker-669:; Traceback (most recent call last):; Traceback (most recent call last):; File ""C:\Anaconda\lib\multiprocessing\process.py"", line 297, in _bootstrap; self.run(); File ""C:\Anaconda\lib\multiprocessing\process.py"", line 297, in _bootstrap; self.run(); File ""C:\Anaconda\lib\multiprocessing\process.py"", line 99, in run; self._target(*self._args, **self._kwargs); File ""C:\Anaconda\lib\multiprocessing\process.py"", line 99, in run; self._target(*self._args, **self._kwargs); File ""C:\Anaconda\lib\multiprocessing\pool.py"", line 110, in worker; task = get(); File ""C:\Anaconda\lib\multiprocessing\pool.py"",",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1084
https://github.com/qutip/qutip/issues/1084:1386,Deployability,Release,Release,1386,"cated NumPy API, disable it with #define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION; Creating library C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_130828459648281117.cp37-win_amd64.lib and object C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_130828459648281117.cp37-win_amd64.exp; Generating code; Finished generating code; cl : Command line warning D9025 : overriding '/W3' with '/w'; cl : Command line warning D9025 : overriding '/Ox' with '/O1'; cqobjevo_compiled_coeff_8398411180025011525.cpp; c:\anaconda\lib\site-packages\numpy\core\include\numpy\npy_1_7_deprecated_api.h(14) : Warning Msg: Using deprecated NumPy API, disable it with #define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION; Creating library C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_8398411180025011525.cp37-win_amd64.lib and object C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_8398411180025011525.cp37-win_amd64.exp; Generating code; Finished generating code; Process SpawnPoolWorker-671:; Process SpawnPoolWorker-669:; Traceback (most recent call last):; Traceback (most recent call last):; File ""C:\Anaconda\lib\multiprocessing\process.py"", line 297, in _bootstrap; self.run(); File ""C:\Anaconda\lib\multiprocessing\process.py"", line 297, in _bootstrap; self.run(); File ""C:\Anaconda\lib\multiprocessing\process.py"", line 99, in run; self._target(*self._args, **self._kwargs); File ""C:\Anaconda\lib\multiprocessing\process.py"", line 99, in run; self._target(*self._args, **self._kwargs); File ""C:\Anaconda\lib\multiprocessing\pool.py"", line 110, in worker; task = get(); File ""C:\Anaconda\lib\multiprocessing\pool.py"", line 110, in worker; task = get(); File ""C:\Anaconda\lib\multipro",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1084
https://github.com/qutip/qutip/issues/1084:1518,Deployability,Release,Release,1518,"tro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_130828459648281117.cp37-win_amd64.lib and object C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_130828459648281117.cp37-win_amd64.exp; Generating code; Finished generating code; cl : Command line warning D9025 : overriding '/W3' with '/w'; cl : Command line warning D9025 : overriding '/Ox' with '/O1'; cqobjevo_compiled_coeff_8398411180025011525.cpp; c:\anaconda\lib\site-packages\numpy\core\include\numpy\npy_1_7_deprecated_api.h(14) : Warning Msg: Using deprecated NumPy API, disable it with #define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION; Creating library C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_8398411180025011525.cp37-win_amd64.lib and object C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_8398411180025011525.cp37-win_amd64.exp; Generating code; Finished generating code; Process SpawnPoolWorker-671:; Process SpawnPoolWorker-669:; Traceback (most recent call last):; Traceback (most recent call last):; File ""C:\Anaconda\lib\multiprocessing\process.py"", line 297, in _bootstrap; self.run(); File ""C:\Anaconda\lib\multiprocessing\process.py"", line 297, in _bootstrap; self.run(); File ""C:\Anaconda\lib\multiprocessing\process.py"", line 99, in run; self._target(*self._args, **self._kwargs); File ""C:\Anaconda\lib\multiprocessing\process.py"", line 99, in run; self._target(*self._args, **self._kwargs); File ""C:\Anaconda\lib\multiprocessing\pool.py"", line 110, in worker; task = get(); File ""C:\Anaconda\lib\multiprocessing\pool.py"", line 110, in worker; task = get(); File ""C:\Anaconda\lib\multiprocessing\queues.py"", line 354, in get; return _ForkingPickler.loads(res); File ""C:\Anaconda\lib\multiprocessing\queu",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1084
https://github.com/qutip/qutip/issues/1084:1567,Deployability,Release,Release,1567,"in-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_130828459648281117.cp37-win_amd64.lib and object C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_130828459648281117.cp37-win_amd64.exp; Generating code; Finished generating code; cl : Command line warning D9025 : overriding '/W3' with '/w'; cl : Command line warning D9025 : overriding '/Ox' with '/O1'; cqobjevo_compiled_coeff_8398411180025011525.cpp; c:\anaconda\lib\site-packages\numpy\core\include\numpy\npy_1_7_deprecated_api.h(14) : Warning Msg: Using deprecated NumPy API, disable it with #define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION; Creating library C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_8398411180025011525.cp37-win_amd64.lib and object C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_8398411180025011525.cp37-win_amd64.exp; Generating code; Finished generating code; Process SpawnPoolWorker-671:; Process SpawnPoolWorker-669:; Traceback (most recent call last):; Traceback (most recent call last):; File ""C:\Anaconda\lib\multiprocessing\process.py"", line 297, in _bootstrap; self.run(); File ""C:\Anaconda\lib\multiprocessing\process.py"", line 297, in _bootstrap; self.run(); File ""C:\Anaconda\lib\multiprocessing\process.py"", line 99, in run; self._target(*self._args, **self._kwargs); File ""C:\Anaconda\lib\multiprocessing\process.py"", line 99, in run; self._target(*self._args, **self._kwargs); File ""C:\Anaconda\lib\multiprocessing\pool.py"", line 110, in worker; task = get(); File ""C:\Anaconda\lib\multiprocessing\pool.py"", line 110, in worker; task = get(); File ""C:\Anaconda\lib\multiprocessing\queues.py"", line 354, in get; return _ForkingPickler.loads(res); File ""C:\Anaconda\lib\multiprocessing\queues.py"", line 354, in get; return _ForkingPickler.loads(res); Modul",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1084
https://github.com/qutip/qutip/issues/1084:2769,Deployability,install,installed,2769,"objevo_compiled_coeff_130828459648281117.cp37-win_amd64.exp; Generating code; Finished generating code; cl : Command line warning D9025 : overriding '/W3' with '/w'; cl : Command line warning D9025 : overriding '/Ox' with '/O1'; cqobjevo_compiled_coeff_8398411180025011525.cpp; c:\anaconda\lib\site-packages\numpy\core\include\numpy\npy_1_7_deprecated_api.h(14) : Warning Msg: Using deprecated NumPy API, disable it with #define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION; Creating library C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_8398411180025011525.cp37-win_amd64.lib and object C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_8398411180025011525.cp37-win_amd64.exp; Generating code; Finished generating code; Process SpawnPoolWorker-671:; Process SpawnPoolWorker-669:; Traceback (most recent call last):; Traceback (most recent call last):; File ""C:\Anaconda\lib\multiprocessing\process.py"", line 297, in _bootstrap; self.run(); File ""C:\Anaconda\lib\multiprocessing\process.py"", line 297, in _bootstrap; self.run(); File ""C:\Anaconda\lib\multiprocessing\process.py"", line 99, in run; self._target(*self._args, **self._kwargs); File ""C:\Anaconda\lib\multiprocessing\process.py"", line 99, in run; self._target(*self._args, **self._kwargs); File ""C:\Anaconda\lib\multiprocessing\pool.py"", line 110, in worker; task = get(); File ""C:\Anaconda\lib\multiprocessing\pool.py"", line 110, in worker; task = get(); File ""C:\Anaconda\lib\multiprocessing\queues.py"", line 354, in get; return _ForkingPickler.loads(res); File ""C:\Anaconda\lib\multiprocessing\queues.py"", line 354, in get; return _ForkingPickler.loads(res); ModuleNotFoundError: No module named 'cqobjevo_compiled_coeff_130828459648281117'; ModuleNotFoundError: No module named 'cqobjevo_compiled_coeff_130828459648281117'. Note: I have installed qutip using pip installer",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1084
https://github.com/qutip/qutip/issues/1084:2795,Deployability,install,installer,2795,"objevo_compiled_coeff_130828459648281117.cp37-win_amd64.exp; Generating code; Finished generating code; cl : Command line warning D9025 : overriding '/W3' with '/w'; cl : Command line warning D9025 : overriding '/Ox' with '/O1'; cqobjevo_compiled_coeff_8398411180025011525.cpp; c:\anaconda\lib\site-packages\numpy\core\include\numpy\npy_1_7_deprecated_api.h(14) : Warning Msg: Using deprecated NumPy API, disable it with #define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION; Creating library C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_8398411180025011525.cp37-win_amd64.lib and object C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_8398411180025011525.cp37-win_amd64.exp; Generating code; Finished generating code; Process SpawnPoolWorker-671:; Process SpawnPoolWorker-669:; Traceback (most recent call last):; Traceback (most recent call last):; File ""C:\Anaconda\lib\multiprocessing\process.py"", line 297, in _bootstrap; self.run(); File ""C:\Anaconda\lib\multiprocessing\process.py"", line 297, in _bootstrap; self.run(); File ""C:\Anaconda\lib\multiprocessing\process.py"", line 99, in run; self._target(*self._args, **self._kwargs); File ""C:\Anaconda\lib\multiprocessing\process.py"", line 99, in run; self._target(*self._args, **self._kwargs); File ""C:\Anaconda\lib\multiprocessing\pool.py"", line 110, in worker; task = get(); File ""C:\Anaconda\lib\multiprocessing\pool.py"", line 110, in worker; task = get(); File ""C:\Anaconda\lib\multiprocessing\queues.py"", line 354, in get; return _ForkingPickler.loads(res); File ""C:\Anaconda\lib\multiprocessing\queues.py"", line 354, in get; return _ForkingPickler.loads(res); ModuleNotFoundError: No module named 'cqobjevo_compiled_coeff_130828459648281117'; ModuleNotFoundError: No module named 'cqobjevo_compiled_coeff_130828459648281117'. Note: I have installed qutip using pip installer",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1084
https://github.com/qutip/qutip/issues/1084:2422,Performance,queue,queues,2422,"objevo_compiled_coeff_130828459648281117.cp37-win_amd64.exp; Generating code; Finished generating code; cl : Command line warning D9025 : overriding '/W3' with '/w'; cl : Command line warning D9025 : overriding '/Ox' with '/O1'; cqobjevo_compiled_coeff_8398411180025011525.cpp; c:\anaconda\lib\site-packages\numpy\core\include\numpy\npy_1_7_deprecated_api.h(14) : Warning Msg: Using deprecated NumPy API, disable it with #define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION; Creating library C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_8398411180025011525.cp37-win_amd64.lib and object C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_8398411180025011525.cp37-win_amd64.exp; Generating code; Finished generating code; Process SpawnPoolWorker-671:; Process SpawnPoolWorker-669:; Traceback (most recent call last):; Traceback (most recent call last):; File ""C:\Anaconda\lib\multiprocessing\process.py"", line 297, in _bootstrap; self.run(); File ""C:\Anaconda\lib\multiprocessing\process.py"", line 297, in _bootstrap; self.run(); File ""C:\Anaconda\lib\multiprocessing\process.py"", line 99, in run; self._target(*self._args, **self._kwargs); File ""C:\Anaconda\lib\multiprocessing\process.py"", line 99, in run; self._target(*self._args, **self._kwargs); File ""C:\Anaconda\lib\multiprocessing\pool.py"", line 110, in worker; task = get(); File ""C:\Anaconda\lib\multiprocessing\pool.py"", line 110, in worker; task = get(); File ""C:\Anaconda\lib\multiprocessing\queues.py"", line 354, in get; return _ForkingPickler.loads(res); File ""C:\Anaconda\lib\multiprocessing\queues.py"", line 354, in get; return _ForkingPickler.loads(res); ModuleNotFoundError: No module named 'cqobjevo_compiled_coeff_130828459648281117'; ModuleNotFoundError: No module named 'cqobjevo_compiled_coeff_130828459648281117'. Note: I have installed qutip using pip installer",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1084
https://github.com/qutip/qutip/issues/1084:2475,Performance,load,loads,2475,"objevo_compiled_coeff_130828459648281117.cp37-win_amd64.exp; Generating code; Finished generating code; cl : Command line warning D9025 : overriding '/W3' with '/w'; cl : Command line warning D9025 : overriding '/Ox' with '/O1'; cqobjevo_compiled_coeff_8398411180025011525.cpp; c:\anaconda\lib\site-packages\numpy\core\include\numpy\npy_1_7_deprecated_api.h(14) : Warning Msg: Using deprecated NumPy API, disable it with #define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION; Creating library C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_8398411180025011525.cp37-win_amd64.lib and object C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_8398411180025011525.cp37-win_amd64.exp; Generating code; Finished generating code; Process SpawnPoolWorker-671:; Process SpawnPoolWorker-669:; Traceback (most recent call last):; Traceback (most recent call last):; File ""C:\Anaconda\lib\multiprocessing\process.py"", line 297, in _bootstrap; self.run(); File ""C:\Anaconda\lib\multiprocessing\process.py"", line 297, in _bootstrap; self.run(); File ""C:\Anaconda\lib\multiprocessing\process.py"", line 99, in run; self._target(*self._args, **self._kwargs); File ""C:\Anaconda\lib\multiprocessing\process.py"", line 99, in run; self._target(*self._args, **self._kwargs); File ""C:\Anaconda\lib\multiprocessing\pool.py"", line 110, in worker; task = get(); File ""C:\Anaconda\lib\multiprocessing\pool.py"", line 110, in worker; task = get(); File ""C:\Anaconda\lib\multiprocessing\queues.py"", line 354, in get; return _ForkingPickler.loads(res); File ""C:\Anaconda\lib\multiprocessing\queues.py"", line 354, in get; return _ForkingPickler.loads(res); ModuleNotFoundError: No module named 'cqobjevo_compiled_coeff_130828459648281117'; ModuleNotFoundError: No module named 'cqobjevo_compiled_coeff_130828459648281117'. Note: I have installed qutip using pip installer",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1084
https://github.com/qutip/qutip/issues/1084:2525,Performance,queue,queues,2525,"objevo_compiled_coeff_130828459648281117.cp37-win_amd64.exp; Generating code; Finished generating code; cl : Command line warning D9025 : overriding '/W3' with '/w'; cl : Command line warning D9025 : overriding '/Ox' with '/O1'; cqobjevo_compiled_coeff_8398411180025011525.cpp; c:\anaconda\lib\site-packages\numpy\core\include\numpy\npy_1_7_deprecated_api.h(14) : Warning Msg: Using deprecated NumPy API, disable it with #define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION; Creating library C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_8398411180025011525.cp37-win_amd64.lib and object C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_8398411180025011525.cp37-win_amd64.exp; Generating code; Finished generating code; Process SpawnPoolWorker-671:; Process SpawnPoolWorker-669:; Traceback (most recent call last):; Traceback (most recent call last):; File ""C:\Anaconda\lib\multiprocessing\process.py"", line 297, in _bootstrap; self.run(); File ""C:\Anaconda\lib\multiprocessing\process.py"", line 297, in _bootstrap; self.run(); File ""C:\Anaconda\lib\multiprocessing\process.py"", line 99, in run; self._target(*self._args, **self._kwargs); File ""C:\Anaconda\lib\multiprocessing\process.py"", line 99, in run; self._target(*self._args, **self._kwargs); File ""C:\Anaconda\lib\multiprocessing\pool.py"", line 110, in worker; task = get(); File ""C:\Anaconda\lib\multiprocessing\pool.py"", line 110, in worker; task = get(); File ""C:\Anaconda\lib\multiprocessing\queues.py"", line 354, in get; return _ForkingPickler.loads(res); File ""C:\Anaconda\lib\multiprocessing\queues.py"", line 354, in get; return _ForkingPickler.loads(res); ModuleNotFoundError: No module named 'cqobjevo_compiled_coeff_130828459648281117'; ModuleNotFoundError: No module named 'cqobjevo_compiled_coeff_130828459648281117'. Note: I have installed qutip using pip installer",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1084
https://github.com/qutip/qutip/issues/1084:2578,Performance,load,loads,2578,"objevo_compiled_coeff_130828459648281117.cp37-win_amd64.exp; Generating code; Finished generating code; cl : Command line warning D9025 : overriding '/W3' with '/w'; cl : Command line warning D9025 : overriding '/Ox' with '/O1'; cqobjevo_compiled_coeff_8398411180025011525.cpp; c:\anaconda\lib\site-packages\numpy\core\include\numpy\npy_1_7_deprecated_api.h(14) : Warning Msg: Using deprecated NumPy API, disable it with #define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION; Creating library C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_8398411180025011525.cp37-win_amd64.lib and object C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_8398411180025011525.cp37-win_amd64.exp; Generating code; Finished generating code; Process SpawnPoolWorker-671:; Process SpawnPoolWorker-669:; Traceback (most recent call last):; Traceback (most recent call last):; File ""C:\Anaconda\lib\multiprocessing\process.py"", line 297, in _bootstrap; self.run(); File ""C:\Anaconda\lib\multiprocessing\process.py"", line 297, in _bootstrap; self.run(); File ""C:\Anaconda\lib\multiprocessing\process.py"", line 99, in run; self._target(*self._args, **self._kwargs); File ""C:\Anaconda\lib\multiprocessing\process.py"", line 99, in run; self._target(*self._args, **self._kwargs); File ""C:\Anaconda\lib\multiprocessing\pool.py"", line 110, in worker; task = get(); File ""C:\Anaconda\lib\multiprocessing\pool.py"", line 110, in worker; task = get(); File ""C:\Anaconda\lib\multiprocessing\queues.py"", line 354, in get; return _ForkingPickler.loads(res); File ""C:\Anaconda\lib\multiprocessing\queues.py"", line 354, in get; return _ForkingPickler.loads(res); ModuleNotFoundError: No module named 'cqobjevo_compiled_coeff_130828459648281117'; ModuleNotFoundError: No module named 'cqobjevo_compiled_coeff_130828459648281117'. Note: I have installed qutip using pip installer",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1084
https://github.com/qutip/qutip/issues/1084:32,Testability,test,testing,32,"Running this code; import qutip.testing as qt; qt.run(); produces an error:. Monte-carlo: Collapse terms constant (str format) ... cl : Command line warning D9025 : overriding '/W3' with '/w'; cl : Command line warning D9025 : overriding '/Ox' with '/O1'; cqobjevo_compiled_coeff_130828459648281117.cpp; c:\anaconda\lib\site-packages\numpy\core\include\numpy\npy_1_7_deprecated_api.h(14) : Warning Msg: Using deprecated NumPy API, disable it with #define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION; Creating library C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_130828459648281117.cp37-win_amd64.lib and object C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_130828459648281117.cp37-win_amd64.exp; Generating code; Finished generating code; cl : Command line warning D9025 : overriding '/W3' with '/w'; cl : Command line warning D9025 : overriding '/Ox' with '/O1'; cqobjevo_compiled_coeff_8398411180025011525.cpp; c:\anaconda\lib\site-packages\numpy\core\include\numpy\npy_1_7_deprecated_api.h(14) : Warning Msg: Using deprecated NumPy API, disable it with #define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION; Creating library C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_8398411180025011525.cp37-win_amd64.lib and object C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_8398411180025011525.cp37-win_amd64.exp; Generating code; Finished generating code; Process SpawnPoolWorker-671:; Process SpawnPoolWorker-669:; Traceback (most recent call last):; Traceback (most recent call last):; File ""C:\Anaconda\lib\multiprocessing\process.py"", line 297, in _bootstrap; self.run(); File ""C:\Anaconda\lib\multiprocessing\process.py"", line 297, in _bootstrap; self.run(); File ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1084
https://github.com/qutip/qutip/issues/1085:602,Availability,down,down,602,"Hello. I'm working on a qutrit system (spin 1). Eventually need to do some pulse optimization but for testing I tried to propagate using a very simple Hamiltonian, namely just Sz^2 with D=2000. ; Units are µs for time (so MHz for frequency). . versions used:; ```python; matplotlib.pylab 1.16.4; qutip 4.4.1; matplotlib 3.1.1; numpy 1.16.4; scipy 1.3.1; CPython 3.7.3; IPython 7.5.0; ```. I solve with sesolve or mesolve with (|+. 1> + |0>)/sqrt(2) as initial state.; **expected:** quite trivially, population should stay 1/2 for any t for |+1> and |0>, 0 for |-1>; **result:** population of |+1> goes down linearly and |0> goes up ; a few observations: ; - if I make the coefficient of Sz^2 smaller, the population diverges less ; - with less time steps but same overall propagation time, I see the divergence less obviously because I see the beginning of it; - I am aware one can somehow optimize the number of time steps but this is about the convenient settings for the next steps for me; - I was thinking of increasing floating point precision or something like that but wasn't able to find a simple way to do that in the docs. it does not seem like having a coefficient on the order of 10000 or 10^5 time steps is that unreasonable, does it ?; anyway, this is about the right, convenient choice of unit for us here. any idea what's wrong ?. ```python; %load_ext watermark; import numpy as np; import scipy; import matplotlib; import matplotlib.pylab as plt; import qutip; %watermark -v --iversions; %matplotlib qt. #Spin 1 operators; S1_x = 1/np.sqrt(2)*qutip.Qobj([[0,1.,0],; [1.,0,1.],; [0,1.,0]]). S1_y = 1.j/np.sqrt(2)*qutip.Qobj([[0,-1.,0],; [1.,0,-1.],; [0,1.,0]]). S1_z = qutip.qdiags([1.,0,-1.], 0). #canonical basis with corresponding projectors; canon_100 = qutip.basis(3,0) #ket |+1>; canon_010 = qutip.basis(3,1) #ket |0>; canon_001 = qutip.basis(3,2) #ket |-1>. proj100 = qutip.ket2dm(canon_100); proj010 = qutip.ket2dm(canon_010); proj001 = qutip.ket2dm(canon_001). #Hamiltonian pa",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1085
https://github.com/qutip/qutip/issues/1085:81,Performance,optimiz,optimization,81,"Hello. I'm working on a qutrit system (spin 1). Eventually need to do some pulse optimization but for testing I tried to propagate using a very simple Hamiltonian, namely just Sz^2 with D=2000. ; Units are µs for time (so MHz for frequency). . versions used:; ```python; matplotlib.pylab 1.16.4; qutip 4.4.1; matplotlib 3.1.1; numpy 1.16.4; scipy 1.3.1; CPython 3.7.3; IPython 7.5.0; ```. I solve with sesolve or mesolve with (|+. 1> + |0>)/sqrt(2) as initial state.; **expected:** quite trivially, population should stay 1/2 for any t for |+1> and |0>, 0 for |-1>; **result:** population of |+1> goes down linearly and |0> goes up ; a few observations: ; - if I make the coefficient of Sz^2 smaller, the population diverges less ; - with less time steps but same overall propagation time, I see the divergence less obviously because I see the beginning of it; - I am aware one can somehow optimize the number of time steps but this is about the convenient settings for the next steps for me; - I was thinking of increasing floating point precision or something like that but wasn't able to find a simple way to do that in the docs. it does not seem like having a coefficient on the order of 10000 or 10^5 time steps is that unreasonable, does it ?; anyway, this is about the right, convenient choice of unit for us here. any idea what's wrong ?. ```python; %load_ext watermark; import numpy as np; import scipy; import matplotlib; import matplotlib.pylab as plt; import qutip; %watermark -v --iversions; %matplotlib qt. #Spin 1 operators; S1_x = 1/np.sqrt(2)*qutip.Qobj([[0,1.,0],; [1.,0,1.],; [0,1.,0]]). S1_y = 1.j/np.sqrt(2)*qutip.Qobj([[0,-1.,0],; [1.,0,-1.],; [0,1.,0]]). S1_z = qutip.qdiags([1.,0,-1.], 0). #canonical basis with corresponding projectors; canon_100 = qutip.basis(3,0) #ket |+1>; canon_010 = qutip.basis(3,1) #ket |0>; canon_001 = qutip.basis(3,2) #ket |-1>. proj100 = qutip.ket2dm(canon_100); proj010 = qutip.ket2dm(canon_010); proj001 = qutip.ket2dm(canon_001). #Hamiltonian pa",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1085
https://github.com/qutip/qutip/issues/1085:890,Performance,optimiz,optimize,890,"Hello. I'm working on a qutrit system (spin 1). Eventually need to do some pulse optimization but for testing I tried to propagate using a very simple Hamiltonian, namely just Sz^2 with D=2000. ; Units are µs for time (so MHz for frequency). . versions used:; ```python; matplotlib.pylab 1.16.4; qutip 4.4.1; matplotlib 3.1.1; numpy 1.16.4; scipy 1.3.1; CPython 3.7.3; IPython 7.5.0; ```. I solve with sesolve or mesolve with (|+. 1> + |0>)/sqrt(2) as initial state.; **expected:** quite trivially, population should stay 1/2 for any t for |+1> and |0>, 0 for |-1>; **result:** population of |+1> goes down linearly and |0> goes up ; a few observations: ; - if I make the coefficient of Sz^2 smaller, the population diverges less ; - with less time steps but same overall propagation time, I see the divergence less obviously because I see the beginning of it; - I am aware one can somehow optimize the number of time steps but this is about the convenient settings for the next steps for me; - I was thinking of increasing floating point precision or something like that but wasn't able to find a simple way to do that in the docs. it does not seem like having a coefficient on the order of 10000 or 10^5 time steps is that unreasonable, does it ?; anyway, this is about the right, convenient choice of unit for us here. any idea what's wrong ?. ```python; %load_ext watermark; import numpy as np; import scipy; import matplotlib; import matplotlib.pylab as plt; import qutip; %watermark -v --iversions; %matplotlib qt. #Spin 1 operators; S1_x = 1/np.sqrt(2)*qutip.Qobj([[0,1.,0],; [1.,0,1.],; [0,1.,0]]). S1_y = 1.j/np.sqrt(2)*qutip.Qobj([[0,-1.,0],; [1.,0,-1.],; [0,1.,0]]). S1_z = qutip.qdiags([1.,0,-1.], 0). #canonical basis with corresponding projectors; canon_100 = qutip.basis(3,0) #ket |+1>; canon_010 = qutip.basis(3,1) #ket |0>; canon_001 = qutip.basis(3,2) #ket |-1>. proj100 = qutip.ket2dm(canon_100); proj010 = qutip.ket2dm(canon_010); proj001 = qutip.ket2dm(canon_001). #Hamiltonian pa",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1085
https://github.com/qutip/qutip/issues/1085:102,Testability,test,testing,102,"Hello. I'm working on a qutrit system (spin 1). Eventually need to do some pulse optimization but for testing I tried to propagate using a very simple Hamiltonian, namely just Sz^2 with D=2000. ; Units are µs for time (so MHz for frequency). . versions used:; ```python; matplotlib.pylab 1.16.4; qutip 4.4.1; matplotlib 3.1.1; numpy 1.16.4; scipy 1.3.1; CPython 3.7.3; IPython 7.5.0; ```. I solve with sesolve or mesolve with (|+. 1> + |0>)/sqrt(2) as initial state.; **expected:** quite trivially, population should stay 1/2 for any t for |+1> and |0>, 0 for |-1>; **result:** population of |+1> goes down linearly and |0> goes up ; a few observations: ; - if I make the coefficient of Sz^2 smaller, the population diverges less ; - with less time steps but same overall propagation time, I see the divergence less obviously because I see the beginning of it; - I am aware one can somehow optimize the number of time steps but this is about the convenient settings for the next steps for me; - I was thinking of increasing floating point precision or something like that but wasn't able to find a simple way to do that in the docs. it does not seem like having a coefficient on the order of 10000 or 10^5 time steps is that unreasonable, does it ?; anyway, this is about the right, convenient choice of unit for us here. any idea what's wrong ?. ```python; %load_ext watermark; import numpy as np; import scipy; import matplotlib; import matplotlib.pylab as plt; import qutip; %watermark -v --iversions; %matplotlib qt. #Spin 1 operators; S1_x = 1/np.sqrt(2)*qutip.Qobj([[0,1.,0],; [1.,0,1.],; [0,1.,0]]). S1_y = 1.j/np.sqrt(2)*qutip.Qobj([[0,-1.,0],; [1.,0,-1.],; [0,1.,0]]). S1_z = qutip.qdiags([1.,0,-1.], 0). #canonical basis with corresponding projectors; canon_100 = qutip.basis(3,0) #ket |+1>; canon_010 = qutip.basis(3,1) #ket |0>; canon_001 = qutip.basis(3,2) #ket |-1>. proj100 = qutip.ket2dm(canon_100); proj010 = qutip.ket2dm(canon_010); proj001 = qutip.ket2dm(canon_001). #Hamiltonian pa",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1085
https://github.com/qutip/qutip/issues/1085:144,Usability,simpl,simple,144,"Hello. I'm working on a qutrit system (spin 1). Eventually need to do some pulse optimization but for testing I tried to propagate using a very simple Hamiltonian, namely just Sz^2 with D=2000. ; Units are µs for time (so MHz for frequency). . versions used:; ```python; matplotlib.pylab 1.16.4; qutip 4.4.1; matplotlib 3.1.1; numpy 1.16.4; scipy 1.3.1; CPython 3.7.3; IPython 7.5.0; ```. I solve with sesolve or mesolve with (|+. 1> + |0>)/sqrt(2) as initial state.; **expected:** quite trivially, population should stay 1/2 for any t for |+1> and |0>, 0 for |-1>; **result:** population of |+1> goes down linearly and |0> goes up ; a few observations: ; - if I make the coefficient of Sz^2 smaller, the population diverges less ; - with less time steps but same overall propagation time, I see the divergence less obviously because I see the beginning of it; - I am aware one can somehow optimize the number of time steps but this is about the convenient settings for the next steps for me; - I was thinking of increasing floating point precision or something like that but wasn't able to find a simple way to do that in the docs. it does not seem like having a coefficient on the order of 10000 or 10^5 time steps is that unreasonable, does it ?; anyway, this is about the right, convenient choice of unit for us here. any idea what's wrong ?. ```python; %load_ext watermark; import numpy as np; import scipy; import matplotlib; import matplotlib.pylab as plt; import qutip; %watermark -v --iversions; %matplotlib qt. #Spin 1 operators; S1_x = 1/np.sqrt(2)*qutip.Qobj([[0,1.,0],; [1.,0,1.],; [0,1.,0]]). S1_y = 1.j/np.sqrt(2)*qutip.Qobj([[0,-1.,0],; [1.,0,-1.],; [0,1.,0]]). S1_z = qutip.qdiags([1.,0,-1.], 0). #canonical basis with corresponding projectors; canon_100 = qutip.basis(3,0) #ket |+1>; canon_010 = qutip.basis(3,1) #ket |0>; canon_001 = qutip.basis(3,2) #ket |-1>. proj100 = qutip.ket2dm(canon_100); proj010 = qutip.ket2dm(canon_010); proj001 = qutip.ket2dm(canon_001). #Hamiltonian pa",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1085
https://github.com/qutip/qutip/issues/1085:1098,Usability,simpl,simple,1098,"Hello. I'm working on a qutrit system (spin 1). Eventually need to do some pulse optimization but for testing I tried to propagate using a very simple Hamiltonian, namely just Sz^2 with D=2000. ; Units are µs for time (so MHz for frequency). . versions used:; ```python; matplotlib.pylab 1.16.4; qutip 4.4.1; matplotlib 3.1.1; numpy 1.16.4; scipy 1.3.1; CPython 3.7.3; IPython 7.5.0; ```. I solve with sesolve or mesolve with (|+. 1> + |0>)/sqrt(2) as initial state.; **expected:** quite trivially, population should stay 1/2 for any t for |+1> and |0>, 0 for |-1>; **result:** population of |+1> goes down linearly and |0> goes up ; a few observations: ; - if I make the coefficient of Sz^2 smaller, the population diverges less ; - with less time steps but same overall propagation time, I see the divergence less obviously because I see the beginning of it; - I am aware one can somehow optimize the number of time steps but this is about the convenient settings for the next steps for me; - I was thinking of increasing floating point precision or something like that but wasn't able to find a simple way to do that in the docs. it does not seem like having a coefficient on the order of 10000 or 10^5 time steps is that unreasonable, does it ?; anyway, this is about the right, convenient choice of unit for us here. any idea what's wrong ?. ```python; %load_ext watermark; import numpy as np; import scipy; import matplotlib; import matplotlib.pylab as plt; import qutip; %watermark -v --iversions; %matplotlib qt. #Spin 1 operators; S1_x = 1/np.sqrt(2)*qutip.Qobj([[0,1.,0],; [1.,0,1.],; [0,1.,0]]). S1_y = 1.j/np.sqrt(2)*qutip.Qobj([[0,-1.,0],; [1.,0,-1.],; [0,1.,0]]). S1_z = qutip.qdiags([1.,0,-1.], 0). #canonical basis with corresponding projectors; canon_100 = qutip.basis(3,0) #ket |+1>; canon_010 = qutip.basis(3,1) #ket |0>; canon_001 = qutip.basis(3,2) #ket |-1>. proj100 = qutip.ket2dm(canon_100); proj010 = qutip.ket2dm(canon_010); proj001 = qutip.ket2dm(canon_001). #Hamiltonian pa",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1085
https://github.com/qutip/qutip/issues/1086:76,Availability,error,error,76,"Dear developers,. I'm failing to install qutip on Ubuntu 18.04 via pip. The error output says:; ```bash; error: invalid command 'bdist_wheel'; ; ----------------------------------------; Failed building wheel for qutip; ```. How can I solve this issue?. Regards. PS: The relevant software versions are; python3 3.6.8; python3-venv 3.6.7; qutip 4.4.1 (The version I tried to install.)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1086
https://github.com/qutip/qutip/issues/1086:105,Availability,error,error,105,"Dear developers,. I'm failing to install qutip on Ubuntu 18.04 via pip. The error output says:; ```bash; error: invalid command 'bdist_wheel'; ; ----------------------------------------; Failed building wheel for qutip; ```. How can I solve this issue?. Regards. PS: The relevant software versions are; python3 3.6.8; python3-venv 3.6.7; qutip 4.4.1 (The version I tried to install.)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1086
https://github.com/qutip/qutip/issues/1086:33,Deployability,install,install,33,"Dear developers,. I'm failing to install qutip on Ubuntu 18.04 via pip. The error output says:; ```bash; error: invalid command 'bdist_wheel'; ; ----------------------------------------; Failed building wheel for qutip; ```. How can I solve this issue?. Regards. PS: The relevant software versions are; python3 3.6.8; python3-venv 3.6.7; qutip 4.4.1 (The version I tried to install.)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1086
https://github.com/qutip/qutip/issues/1086:374,Deployability,install,install,374,"Dear developers,. I'm failing to install qutip on Ubuntu 18.04 via pip. The error output says:; ```bash; error: invalid command 'bdist_wheel'; ; ----------------------------------------; Failed building wheel for qutip; ```. How can I solve this issue?. Regards. PS: The relevant software versions are; python3 3.6.8; python3-venv 3.6.7; qutip 4.4.1 (The version I tried to install.)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1086
https://github.com/qutip/qutip/issues/1089:19,Modifiability,config,configuring,19,"I was wondering if configuring a bot might be beneficial for some tasks. For example, checking that the code is well formatted with `black`. Examples are given by Sympy and Cirq (although there they use it for CLAs). . https://github.com/topics/bot. This could also be a fun project for a student (or coder in general) willing to contribute to QuTiP on the software side instead of the physics side. . Maybe though, any interesting feature of a bot can be put in place by a given specific API.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1089
https://github.com/qutip/qutip/pull/1090:563,Availability,avail,available,563,"Hello! This is the first of hopefully a few PRs to add measurement functions to qutip. This PR adds a new module named `qutip.measurement` that contains two functions:. * `measure(op, state)` that performs a classic quantum measurement as described in most introductory texts (measurement collapses a state to an eigenvector of an hermitian operator and the result is the corresponding eigenvalue). It is intended to simulate a simple measurement that could be performed in a real experiment. * `measurement_statistics(op, state)` returns information that is not available via a real experiment, but is nevertheless often useful in simulator (the eigenvalues and vectors or projection operators for the measurement operator and the probabilities of each measurement result). Both functions support either kets or density matrices and return sensible results based on the kind of input. Not currently supported:. * Partial measurements of a system.; * Destructive measurements (aka von Neumann measurements of the second kind); * Density matrix ensembles (applying the measurement probabilities to the density matrix rather than making a specific measurement); * Any custom support for qubit measurement (my plan is to add those to a `qutip.qip.measurements` module once we have the basics of this module agreed on). Questions / things I'd like feedback on:. * Do the inputs and outputs of the current functions seem intuitive / sensible?; * What are the most important other features to support?; * I don't want to have too many functions, but I also don't necessarily want to cram all possible kinds of measurements into one function. Any thoughts on how to split these up?; * What other unit tests should I be writing?; * I haven't given any thought to performance yet. Anything egregious I should fix now or any important cases to optimize for?. General stylistic feedback welcomed too.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1090
https://github.com/qutip/qutip/pull/1090:197,Performance,perform,performs,197,"Hello! This is the first of hopefully a few PRs to add measurement functions to qutip. This PR adds a new module named `qutip.measurement` that contains two functions:. * `measure(op, state)` that performs a classic quantum measurement as described in most introductory texts (measurement collapses a state to an eigenvector of an hermitian operator and the result is the corresponding eigenvalue). It is intended to simulate a simple measurement that could be performed in a real experiment. * `measurement_statistics(op, state)` returns information that is not available via a real experiment, but is nevertheless often useful in simulator (the eigenvalues and vectors or projection operators for the measurement operator and the probabilities of each measurement result). Both functions support either kets or density matrices and return sensible results based on the kind of input. Not currently supported:. * Partial measurements of a system.; * Destructive measurements (aka von Neumann measurements of the second kind); * Density matrix ensembles (applying the measurement probabilities to the density matrix rather than making a specific measurement); * Any custom support for qubit measurement (my plan is to add those to a `qutip.qip.measurements` module once we have the basics of this module agreed on). Questions / things I'd like feedback on:. * Do the inputs and outputs of the current functions seem intuitive / sensible?; * What are the most important other features to support?; * I don't want to have too many functions, but I also don't necessarily want to cram all possible kinds of measurements into one function. Any thoughts on how to split these up?; * What other unit tests should I be writing?; * I haven't given any thought to performance yet. Anything egregious I should fix now or any important cases to optimize for?. General stylistic feedback welcomed too.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1090
https://github.com/qutip/qutip/pull/1090:461,Performance,perform,performed,461,"Hello! This is the first of hopefully a few PRs to add measurement functions to qutip. This PR adds a new module named `qutip.measurement` that contains two functions:. * `measure(op, state)` that performs a classic quantum measurement as described in most introductory texts (measurement collapses a state to an eigenvector of an hermitian operator and the result is the corresponding eigenvalue). It is intended to simulate a simple measurement that could be performed in a real experiment. * `measurement_statistics(op, state)` returns information that is not available via a real experiment, but is nevertheless often useful in simulator (the eigenvalues and vectors or projection operators for the measurement operator and the probabilities of each measurement result). Both functions support either kets or density matrices and return sensible results based on the kind of input. Not currently supported:. * Partial measurements of a system.; * Destructive measurements (aka von Neumann measurements of the second kind); * Density matrix ensembles (applying the measurement probabilities to the density matrix rather than making a specific measurement); * Any custom support for qubit measurement (my plan is to add those to a `qutip.qip.measurements` module once we have the basics of this module agreed on). Questions / things I'd like feedback on:. * Do the inputs and outputs of the current functions seem intuitive / sensible?; * What are the most important other features to support?; * I don't want to have too many functions, but I also don't necessarily want to cram all possible kinds of measurements into one function. Any thoughts on how to split these up?; * What other unit tests should I be writing?; * I haven't given any thought to performance yet. Anything egregious I should fix now or any important cases to optimize for?. General stylistic feedback welcomed too.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1090
https://github.com/qutip/qutip/pull/1090:1755,Performance,perform,performance,1755,"Hello! This is the first of hopefully a few PRs to add measurement functions to qutip. This PR adds a new module named `qutip.measurement` that contains two functions:. * `measure(op, state)` that performs a classic quantum measurement as described in most introductory texts (measurement collapses a state to an eigenvector of an hermitian operator and the result is the corresponding eigenvalue). It is intended to simulate a simple measurement that could be performed in a real experiment. * `measurement_statistics(op, state)` returns information that is not available via a real experiment, but is nevertheless often useful in simulator (the eigenvalues and vectors or projection operators for the measurement operator and the probabilities of each measurement result). Both functions support either kets or density matrices and return sensible results based on the kind of input. Not currently supported:. * Partial measurements of a system.; * Destructive measurements (aka von Neumann measurements of the second kind); * Density matrix ensembles (applying the measurement probabilities to the density matrix rather than making a specific measurement); * Any custom support for qubit measurement (my plan is to add those to a `qutip.qip.measurements` module once we have the basics of this module agreed on). Questions / things I'd like feedback on:. * Do the inputs and outputs of the current functions seem intuitive / sensible?; * What are the most important other features to support?; * I don't want to have too many functions, but I also don't necessarily want to cram all possible kinds of measurements into one function. Any thoughts on how to split these up?; * What other unit tests should I be writing?; * I haven't given any thought to performance yet. Anything egregious I should fix now or any important cases to optimize for?. General stylistic feedback welcomed too.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1090
https://github.com/qutip/qutip/pull/1090:1834,Performance,optimiz,optimize,1834,"Hello! This is the first of hopefully a few PRs to add measurement functions to qutip. This PR adds a new module named `qutip.measurement` that contains two functions:. * `measure(op, state)` that performs a classic quantum measurement as described in most introductory texts (measurement collapses a state to an eigenvector of an hermitian operator and the result is the corresponding eigenvalue). It is intended to simulate a simple measurement that could be performed in a real experiment. * `measurement_statistics(op, state)` returns information that is not available via a real experiment, but is nevertheless often useful in simulator (the eigenvalues and vectors or projection operators for the measurement operator and the probabilities of each measurement result). Both functions support either kets or density matrices and return sensible results based on the kind of input. Not currently supported:. * Partial measurements of a system.; * Destructive measurements (aka von Neumann measurements of the second kind); * Density matrix ensembles (applying the measurement probabilities to the density matrix rather than making a specific measurement); * Any custom support for qubit measurement (my plan is to add those to a `qutip.qip.measurements` module once we have the basics of this module agreed on). Questions / things I'd like feedback on:. * Do the inputs and outputs of the current functions seem intuitive / sensible?; * What are the most important other features to support?; * I don't want to have too many functions, but I also don't necessarily want to cram all possible kinds of measurements into one function. Any thoughts on how to split these up?; * What other unit tests should I be writing?; * I haven't given any thought to performance yet. Anything egregious I should fix now or any important cases to optimize for?. General stylistic feedback welcomed too.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1090
https://github.com/qutip/qutip/pull/1090:1694,Testability,test,tests,1694,"Hello! This is the first of hopefully a few PRs to add measurement functions to qutip. This PR adds a new module named `qutip.measurement` that contains two functions:. * `measure(op, state)` that performs a classic quantum measurement as described in most introductory texts (measurement collapses a state to an eigenvector of an hermitian operator and the result is the corresponding eigenvalue). It is intended to simulate a simple measurement that could be performed in a real experiment. * `measurement_statistics(op, state)` returns information that is not available via a real experiment, but is nevertheless often useful in simulator (the eigenvalues and vectors or projection operators for the measurement operator and the probabilities of each measurement result). Both functions support either kets or density matrices and return sensible results based on the kind of input. Not currently supported:. * Partial measurements of a system.; * Destructive measurements (aka von Neumann measurements of the second kind); * Density matrix ensembles (applying the measurement probabilities to the density matrix rather than making a specific measurement); * Any custom support for qubit measurement (my plan is to add those to a `qutip.qip.measurements` module once we have the basics of this module agreed on). Questions / things I'd like feedback on:. * Do the inputs and outputs of the current functions seem intuitive / sensible?; * What are the most important other features to support?; * I don't want to have too many functions, but I also don't necessarily want to cram all possible kinds of measurements into one function. Any thoughts on how to split these up?; * What other unit tests should I be writing?; * I haven't given any thought to performance yet. Anything egregious I should fix now or any important cases to optimize for?. General stylistic feedback welcomed too.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1090
https://github.com/qutip/qutip/pull/1090:428,Usability,simpl,simple,428,"Hello! This is the first of hopefully a few PRs to add measurement functions to qutip. This PR adds a new module named `qutip.measurement` that contains two functions:. * `measure(op, state)` that performs a classic quantum measurement as described in most introductory texts (measurement collapses a state to an eigenvector of an hermitian operator and the result is the corresponding eigenvalue). It is intended to simulate a simple measurement that could be performed in a real experiment. * `measurement_statistics(op, state)` returns information that is not available via a real experiment, but is nevertheless often useful in simulator (the eigenvalues and vectors or projection operators for the measurement operator and the probabilities of each measurement result). Both functions support either kets or density matrices and return sensible results based on the kind of input. Not currently supported:. * Partial measurements of a system.; * Destructive measurements (aka von Neumann measurements of the second kind); * Density matrix ensembles (applying the measurement probabilities to the density matrix rather than making a specific measurement); * Any custom support for qubit measurement (my plan is to add those to a `qutip.qip.measurements` module once we have the basics of this module agreed on). Questions / things I'd like feedback on:. * Do the inputs and outputs of the current functions seem intuitive / sensible?; * What are the most important other features to support?; * I don't want to have too many functions, but I also don't necessarily want to cram all possible kinds of measurements into one function. Any thoughts on how to split these up?; * What other unit tests should I be writing?; * I haven't given any thought to performance yet. Anything egregious I should fix now or any important cases to optimize for?. General stylistic feedback welcomed too.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1090
https://github.com/qutip/qutip/pull/1090:1344,Usability,feedback,feedback,1344,"Hello! This is the first of hopefully a few PRs to add measurement functions to qutip. This PR adds a new module named `qutip.measurement` that contains two functions:. * `measure(op, state)` that performs a classic quantum measurement as described in most introductory texts (measurement collapses a state to an eigenvector of an hermitian operator and the result is the corresponding eigenvalue). It is intended to simulate a simple measurement that could be performed in a real experiment. * `measurement_statistics(op, state)` returns information that is not available via a real experiment, but is nevertheless often useful in simulator (the eigenvalues and vectors or projection operators for the measurement operator and the probabilities of each measurement result). Both functions support either kets or density matrices and return sensible results based on the kind of input. Not currently supported:. * Partial measurements of a system.; * Destructive measurements (aka von Neumann measurements of the second kind); * Density matrix ensembles (applying the measurement probabilities to the density matrix rather than making a specific measurement); * Any custom support for qubit measurement (my plan is to add those to a `qutip.qip.measurements` module once we have the basics of this module agreed on). Questions / things I'd like feedback on:. * Do the inputs and outputs of the current functions seem intuitive / sensible?; * What are the most important other features to support?; * I don't want to have too many functions, but I also don't necessarily want to cram all possible kinds of measurements into one function. Any thoughts on how to split these up?; * What other unit tests should I be writing?; * I haven't given any thought to performance yet. Anything egregious I should fix now or any important cases to optimize for?. General stylistic feedback welcomed too.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1090
https://github.com/qutip/qutip/pull/1090:1416,Usability,intuit,intuitive,1416,"Hello! This is the first of hopefully a few PRs to add measurement functions to qutip. This PR adds a new module named `qutip.measurement` that contains two functions:. * `measure(op, state)` that performs a classic quantum measurement as described in most introductory texts (measurement collapses a state to an eigenvector of an hermitian operator and the result is the corresponding eigenvalue). It is intended to simulate a simple measurement that could be performed in a real experiment. * `measurement_statistics(op, state)` returns information that is not available via a real experiment, but is nevertheless often useful in simulator (the eigenvalues and vectors or projection operators for the measurement operator and the probabilities of each measurement result). Both functions support either kets or density matrices and return sensible results based on the kind of input. Not currently supported:. * Partial measurements of a system.; * Destructive measurements (aka von Neumann measurements of the second kind); * Density matrix ensembles (applying the measurement probabilities to the density matrix rather than making a specific measurement); * Any custom support for qubit measurement (my plan is to add those to a `qutip.qip.measurements` module once we have the basics of this module agreed on). Questions / things I'd like feedback on:. * Do the inputs and outputs of the current functions seem intuitive / sensible?; * What are the most important other features to support?; * I don't want to have too many functions, but I also don't necessarily want to cram all possible kinds of measurements into one function. Any thoughts on how to split these up?; * What other unit tests should I be writing?; * I haven't given any thought to performance yet. Anything egregious I should fix now or any important cases to optimize for?. General stylistic feedback welcomed too.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1090
https://github.com/qutip/qutip/pull/1090:1867,Usability,feedback,feedback,1867,"Hello! This is the first of hopefully a few PRs to add measurement functions to qutip. This PR adds a new module named `qutip.measurement` that contains two functions:. * `measure(op, state)` that performs a classic quantum measurement as described in most introductory texts (measurement collapses a state to an eigenvector of an hermitian operator and the result is the corresponding eigenvalue). It is intended to simulate a simple measurement that could be performed in a real experiment. * `measurement_statistics(op, state)` returns information that is not available via a real experiment, but is nevertheless often useful in simulator (the eigenvalues and vectors or projection operators for the measurement operator and the probabilities of each measurement result). Both functions support either kets or density matrices and return sensible results based on the kind of input. Not currently supported:. * Partial measurements of a system.; * Destructive measurements (aka von Neumann measurements of the second kind); * Density matrix ensembles (applying the measurement probabilities to the density matrix rather than making a specific measurement); * Any custom support for qubit measurement (my plan is to add those to a `qutip.qip.measurements` module once we have the basics of this module agreed on). Questions / things I'd like feedback on:. * Do the inputs and outputs of the current functions seem intuitive / sensible?; * What are the most important other features to support?; * I don't want to have too many functions, but I also don't necessarily want to cram all possible kinds of measurements into one function. Any thoughts on how to split these up?; * What other unit tests should I be writing?; * I haven't given any thought to performance yet. Anything egregious I should fix now or any important cases to optimize for?. General stylistic feedback welcomed too.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1090
https://github.com/qutip/qutip/issues/1531:749,Availability,ping,pinging,749,"In the latest documentation build, 4.4, the links to source code in the [API documentation](http://qutip.org/docs/latest/apidoc/apidoc.html) do not work. ; An example is the `Qobj` [source] link [in this page](http://qutip.org/docs/latest/apidoc/classes.html#qobj) that takes to this broken link, http://qutip.org/docs/latest/_modules/qutip/qobj.html#Qobj. ; The link is broken because it takes to `latest/_modules` instead of `latest/modules`, see for example the working link in 4.3, http://qutip.org/docs/4.3/modules/qutip/qobj.html#Qobj, or even the correct http://qutip.org/docs/latest/modules/qutip/qobj.html#Qobj. . Any help appreciated in fixing this in Sphinx, I think in `sphinx-apidoc`, cc @Ericgig @quantshah @ajgpitch @tehruhn @BoxiLi (pinging you as only Alex watches this repo and you all played with Sphinx recently).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1531
https://github.com/qutip/qutip/issues/1093:2042,Availability,ERROR,ERROR,2042,"aul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.0.dev0+d377c997; Numpy Version: 1.17.2; Scipy Version: 1.3.1; Cython Version: 0.29.13; Matplotlib Version: None; Python Version: 3.7.4; Number of CPUs: 2; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /Users/goerz/.pyenv/versions/miniconda3-latest/envs/qutip_testing_env/lib/python3.7/site-packages/qutip-4.5.0.dev0+; d377c997-py3.7-macosx-10.9-x86_64.egg/qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; nose.plugins.cover: ERROR: Coverage not available: unable to import coverage module; /Users/goerz/.pyenv/versions/miniconda3-latest/envs/qutip_testing_env/lib/python3.7/site-packages/qutip-4.5.0.dev0+d377c997-py3.7-macos; x-10.9-x86_64.egg/qutip/__init__.py:161: UserWarning: matplotlib not found: Graphics will not work.; warnings.warn(""matplotlib not found: Graphics will not work.""); Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1093
https://github.com/qutip/qutip/issues/1093:2062,Availability,avail,available,2062,"aul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.0.dev0+d377c997; Numpy Version: 1.17.2; Scipy Version: 1.3.1; Cython Version: 0.29.13; Matplotlib Version: None; Python Version: 3.7.4; Number of CPUs: 2; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /Users/goerz/.pyenv/versions/miniconda3-latest/envs/qutip_testing_env/lib/python3.7/site-packages/qutip-4.5.0.dev0+; d377c997-py3.7-macosx-10.9-x86_64.egg/qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; nose.plugins.cover: ERROR: Coverage not available: unable to import coverage module; /Users/goerz/.pyenv/versions/miniconda3-latest/envs/qutip_testing_env/lib/python3.7/site-packages/qutip-4.5.0.dev0+d377c997-py3.7-macos; x-10.9-x86_64.egg/qutip/__init__.py:161: UserWarning: matplotlib not found: Graphics will not work.; warnings.warn(""matplotlib not found: Graphics will not work.""); Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1093
https://github.com/qutip/qutip/issues/1093:3909,Availability,fault,fault,3909,"===========; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; nose.plugins.cover: ERROR: Coverage not available: unable to import coverage module; /Users/goerz/.pyenv/versions/miniconda3-latest/envs/qutip_testing_env/lib/python3.7/site-packages/qutip-4.5.0.dev0+d377c997-py3.7-macos; x-10.9-x86_64.egg/qutip/__init__.py:161: UserWarning: matplotlib not found: Graphics will not work.; warnings.warn(""matplotlib not found: Graphics will not work.""); Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmesolve: harmonic oscillator, finite temperature, states ... ok; brmesolve: Jaynes-Cummings model, zero temperature ... ok; brmesolve: Check for #572 bug. ... ok; brmesolve: input list of Qobj ... ok; td_brmesolve: passes all brmesolve tests ... ok; td_brmesolve: time-dependent a_ops ... ok; td_brmesolve: time-dependent a_ops tuple of strings ... ok; td_brmesolve: time-dependent a_ops tuple interp ... ok td_brmesolve: time-dependent a_ops & c_ops interp ... ok; td_brmesolve: non-Hermitian e_ops check ... ok; td_brmesolve: states check ... ok; td_brmesolve: split ops #1 ... ok; td_brmesolve: split ops #2 ... ok; td_brmesolve: split ops, Cubic_Spline td-terms ... ok; td_brmesolve: split ops, multiple ... ok; td_brmesolve: Hamiltonian args ... ok; BR Tools : zheevr ... Segmentation fault: 11; ~~~",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1093
https://github.com/qutip/qutip/issues/1093:195,Deployability,install,install,195,"I'm trying to run qutip's test suite locally on my Macbook. From a clean checkout of the `master` branch, I'm doing the following:. ~~~; conda create -q -n qutip_testing_env -y python=3.7; conda install -n qutip_testing_env -y blas=*=openblas numpy scipy nose cython ipython pytest; mkdir qutip_testing; cd qutip_testing; rm -rf /Users/goerz/.pyenv/versions/miniconda3-latest/envs/qutip_testing_env/lib/python3.7/site-packages/qutip*; rm -rf ../build ../dist/ ../qutip.egg-info/; (cd ../ && /Users/goerz/.pyenv/versions/miniconda3-latest/envs/qutip_testing_env/bin/python setup.py install); /Users/goerz/.pyenv/versions/miniconda3-latest/envs/qutip_testing_env/bin/python -m qutip.about; /Users/goerz/.pyenv/versions/miniconda3-latest/envs/qutip_testing_env/bin/nosetests --verbosity=2 --with-coverage --cover-package=qutip qutip; ~~~. The resulting output is:; ~~~; ...; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.0.dev0+d377c997; Numpy Version: 1.17.2; Scipy Version: 1.3.1; Cython Version: 0.29.13; Matplotlib Version: None; Python Version: 3.7.4; Number of CPUs: 2; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /Users/goerz/.pyenv/versions/miniconda3-latest/envs/qutip_testing_env/lib/python3.7/site-packages/qutip-4.5.0.dev0+; d377c997-py3.7-macosx-10.9-x86_64.egg/qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated u",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1093
https://github.com/qutip/qutip/issues/1093:581,Deployability,install,install,581,"I'm trying to run qutip's test suite locally on my Macbook. From a clean checkout of the `master` branch, I'm doing the following:. ~~~; conda create -q -n qutip_testing_env -y python=3.7; conda install -n qutip_testing_env -y blas=*=openblas numpy scipy nose cython ipython pytest; mkdir qutip_testing; cd qutip_testing; rm -rf /Users/goerz/.pyenv/versions/miniconda3-latest/envs/qutip_testing_env/lib/python3.7/site-packages/qutip*; rm -rf ../build ../dist/ ../qutip.egg-info/; (cd ../ && /Users/goerz/.pyenv/versions/miniconda3-latest/envs/qutip_testing_env/bin/python setup.py install); /Users/goerz/.pyenv/versions/miniconda3-latest/envs/qutip_testing_env/bin/python -m qutip.about; /Users/goerz/.pyenv/versions/miniconda3-latest/envs/qutip_testing_env/bin/nosetests --verbosity=2 --with-coverage --cover-package=qutip qutip; ~~~. The resulting output is:; ~~~; ...; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.0.dev0+d377c997; Numpy Version: 1.17.2; Scipy Version: 1.3.1; Cython Version: 0.29.13; Matplotlib Version: None; Python Version: 3.7.4; Number of CPUs: 2; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /Users/goerz/.pyenv/versions/miniconda3-latest/envs/qutip_testing_env/lib/python3.7/site-packages/qutip-4.5.0.dev0+; d377c997-py3.7-macosx-10.9-x86_64.egg/qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated u",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1093
https://github.com/qutip/qutip/issues/1093:1483,Deployability,Install,Installed,1483,"/versions/miniconda3-latest/envs/qutip_testing_env/bin/python setup.py install); /Users/goerz/.pyenv/versions/miniconda3-latest/envs/qutip_testing_env/bin/python -m qutip.about; /Users/goerz/.pyenv/versions/miniconda3-latest/envs/qutip_testing_env/bin/nosetests --verbosity=2 --with-coverage --cover-package=qutip qutip; ~~~. The resulting output is:; ~~~; ...; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.0.dev0+d377c997; Numpy Version: 1.17.2; Scipy Version: 1.3.1; Cython Version: 0.29.13; Matplotlib Version: None; Python Version: 3.7.4; Number of CPUs: 2; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /Users/goerz/.pyenv/versions/miniconda3-latest/envs/qutip_testing_env/lib/python3.7/site-packages/qutip-4.5.0.dev0+; d377c997-py3.7-macosx-10.9-x86_64.egg/qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; nose.plugins.cover: ERROR: Coverage not available: unable to import coverage module; /Users/goerz/.pyenv/versions/miniconda3-latest/envs/qutip_testing_env/lib/python3.7/site-packages/qutip-4.5.0.dev0+d377c997-py3.7-macos; x-10.9-x86_64.egg/qutip/__init__.py:161: UserWarning: matplotlib not found: Graphics will not work.; warnings.warn(""matplotlib not found: Graphics will not work.""); Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1093
https://github.com/qutip/qutip/issues/1093:1555,Deployability,Install,Installation,1555,"/versions/miniconda3-latest/envs/qutip_testing_env/bin/python setup.py install); /Users/goerz/.pyenv/versions/miniconda3-latest/envs/qutip_testing_env/bin/python -m qutip.about; /Users/goerz/.pyenv/versions/miniconda3-latest/envs/qutip_testing_env/bin/nosetests --verbosity=2 --with-coverage --cover-package=qutip qutip; ~~~. The resulting output is:; ~~~; ...; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.0.dev0+d377c997; Numpy Version: 1.17.2; Scipy Version: 1.3.1; Cython Version: 0.29.13; Matplotlib Version: None; Python Version: 3.7.4; Number of CPUs: 2; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /Users/goerz/.pyenv/versions/miniconda3-latest/envs/qutip_testing_env/lib/python3.7/site-packages/qutip-4.5.0.dev0+; d377c997-py3.7-macosx-10.9-x86_64.egg/qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; nose.plugins.cover: ERROR: Coverage not available: unable to import coverage module; /Users/goerz/.pyenv/versions/miniconda3-latest/envs/qutip_testing_env/lib/python3.7/site-packages/qutip-4.5.0.dev0+d377c997-py3.7-macos; x-10.9-x86_64.egg/qutip/__init__.py:161: UserWarning: matplotlib not found: Graphics will not work.; warnings.warn(""matplotlib not found: Graphics will not work.""); Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1093
https://github.com/qutip/qutip/issues/1093:3388,Integrability,depend,dependent,3388,"===========; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; nose.plugins.cover: ERROR: Coverage not available: unable to import coverage module; /Users/goerz/.pyenv/versions/miniconda3-latest/envs/qutip_testing_env/lib/python3.7/site-packages/qutip-4.5.0.dev0+d377c997-py3.7-macos; x-10.9-x86_64.egg/qutip/__init__.py:161: UserWarning: matplotlib not found: Graphics will not work.; warnings.warn(""matplotlib not found: Graphics will not work.""); Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmesolve: harmonic oscillator, finite temperature, states ... ok; brmesolve: Jaynes-Cummings model, zero temperature ... ok; brmesolve: Check for #572 bug. ... ok; brmesolve: input list of Qobj ... ok; td_brmesolve: passes all brmesolve tests ... ok; td_brmesolve: time-dependent a_ops ... ok; td_brmesolve: time-dependent a_ops tuple of strings ... ok; td_brmesolve: time-dependent a_ops tuple interp ... ok td_brmesolve: time-dependent a_ops & c_ops interp ... ok; td_brmesolve: non-Hermitian e_ops check ... ok; td_brmesolve: states check ... ok; td_brmesolve: split ops #1 ... ok; td_brmesolve: split ops #2 ... ok; td_brmesolve: split ops, Cubic_Spline td-terms ... ok; td_brmesolve: split ops, multiple ... ok; td_brmesolve: Hamiltonian args ... ok; BR Tools : zheevr ... Segmentation fault: 11; ~~~",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1093
https://github.com/qutip/qutip/issues/1093:3431,Integrability,depend,dependent,3431,"===========; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; nose.plugins.cover: ERROR: Coverage not available: unable to import coverage module; /Users/goerz/.pyenv/versions/miniconda3-latest/envs/qutip_testing_env/lib/python3.7/site-packages/qutip-4.5.0.dev0+d377c997-py3.7-macos; x-10.9-x86_64.egg/qutip/__init__.py:161: UserWarning: matplotlib not found: Graphics will not work.; warnings.warn(""matplotlib not found: Graphics will not work.""); Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmesolve: harmonic oscillator, finite temperature, states ... ok; brmesolve: Jaynes-Cummings model, zero temperature ... ok; brmesolve: Check for #572 bug. ... ok; brmesolve: input list of Qobj ... ok; td_brmesolve: passes all brmesolve tests ... ok; td_brmesolve: time-dependent a_ops ... ok; td_brmesolve: time-dependent a_ops tuple of strings ... ok; td_brmesolve: time-dependent a_ops tuple interp ... ok td_brmesolve: time-dependent a_ops & c_ops interp ... ok; td_brmesolve: non-Hermitian e_ops check ... ok; td_brmesolve: states check ... ok; td_brmesolve: split ops #1 ... ok; td_brmesolve: split ops #2 ... ok; td_brmesolve: split ops, Cubic_Spline td-terms ... ok; td_brmesolve: split ops, multiple ... ok; td_brmesolve: Hamiltonian args ... ok; BR Tools : zheevr ... Segmentation fault: 11; ~~~",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1093
https://github.com/qutip/qutip/issues/1093:3491,Integrability,depend,dependent,3491,"===========; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; nose.plugins.cover: ERROR: Coverage not available: unable to import coverage module; /Users/goerz/.pyenv/versions/miniconda3-latest/envs/qutip_testing_env/lib/python3.7/site-packages/qutip-4.5.0.dev0+d377c997-py3.7-macos; x-10.9-x86_64.egg/qutip/__init__.py:161: UserWarning: matplotlib not found: Graphics will not work.; warnings.warn(""matplotlib not found: Graphics will not work.""); Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmesolve: harmonic oscillator, finite temperature, states ... ok; brmesolve: Jaynes-Cummings model, zero temperature ... ok; brmesolve: Check for #572 bug. ... ok; brmesolve: input list of Qobj ... ok; td_brmesolve: passes all brmesolve tests ... ok; td_brmesolve: time-dependent a_ops ... ok; td_brmesolve: time-dependent a_ops tuple of strings ... ok; td_brmesolve: time-dependent a_ops tuple interp ... ok td_brmesolve: time-dependent a_ops & c_ops interp ... ok; td_brmesolve: non-Hermitian e_ops check ... ok; td_brmesolve: states check ... ok; td_brmesolve: split ops #1 ... ok; td_brmesolve: split ops #2 ... ok; td_brmesolve: split ops, Cubic_Spline td-terms ... ok; td_brmesolve: split ops, multiple ... ok; td_brmesolve: Hamiltonian args ... ok; BR Tools : zheevr ... Segmentation fault: 11; ~~~",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1093
https://github.com/qutip/qutip/issues/1093:3546,Integrability,depend,dependent,3546,"===========; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; nose.plugins.cover: ERROR: Coverage not available: unable to import coverage module; /Users/goerz/.pyenv/versions/miniconda3-latest/envs/qutip_testing_env/lib/python3.7/site-packages/qutip-4.5.0.dev0+d377c997-py3.7-macos; x-10.9-x86_64.egg/qutip/__init__.py:161: UserWarning: matplotlib not found: Graphics will not work.; warnings.warn(""matplotlib not found: Graphics will not work.""); Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmesolve: harmonic oscillator, finite temperature, states ... ok; brmesolve: Jaynes-Cummings model, zero temperature ... ok; brmesolve: Check for #572 bug. ... ok; brmesolve: input list of Qobj ... ok; td_brmesolve: passes all brmesolve tests ... ok; td_brmesolve: time-dependent a_ops ... ok; td_brmesolve: time-dependent a_ops tuple of strings ... ok; td_brmesolve: time-dependent a_ops tuple interp ... ok td_brmesolve: time-dependent a_ops & c_ops interp ... ok; td_brmesolve: non-Hermitian e_ops check ... ok; td_brmesolve: states check ... ok; td_brmesolve: split ops #1 ... ok; td_brmesolve: split ops #2 ... ok; td_brmesolve: split ops, Cubic_Spline td-terms ... ok; td_brmesolve: split ops, multiple ... ok; td_brmesolve: Hamiltonian args ... ok; BR Tools : zheevr ... Segmentation fault: 11; ~~~",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1093
https://github.com/qutip/qutip/issues/1093:2027,Modifiability,plugin,plugins,2027,"on.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.0.dev0+d377c997; Numpy Version: 1.17.2; Scipy Version: 1.3.1; Cython Version: 0.29.13; Matplotlib Version: None; Python Version: 3.7.4; Number of CPUs: 2; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /Users/goerz/.pyenv/versions/miniconda3-latest/envs/qutip_testing_env/lib/python3.7/site-packages/qutip-4.5.0.dev0+; d377c997-py3.7-macosx-10.9-x86_64.egg/qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; nose.plugins.cover: ERROR: Coverage not available: unable to import coverage module; /Users/goerz/.pyenv/versions/miniconda3-latest/envs/qutip_testing_env/lib/python3.7/site-packages/qutip-4.5.0.dev0+d377c997-py3.7-macos; x-10.9-x86_64.egg/qutip/__init__.py:161: UserWarning: matplotlib not found: Graphics will not work.; warnings.warn(""matplotlib not found: Graphics will not work.""); Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1093
https://github.com/qutip/qutip/issues/1093:26,Testability,test,test,26,"I'm trying to run qutip's test suite locally on my Macbook. From a clean checkout of the `master` branch, I'm doing the following:. ~~~; conda create -q -n qutip_testing_env -y python=3.7; conda install -n qutip_testing_env -y blas=*=openblas numpy scipy nose cython ipython pytest; mkdir qutip_testing; cd qutip_testing; rm -rf /Users/goerz/.pyenv/versions/miniconda3-latest/envs/qutip_testing_env/lib/python3.7/site-packages/qutip*; rm -rf ../build ../dist/ ../qutip.egg-info/; (cd ../ && /Users/goerz/.pyenv/versions/miniconda3-latest/envs/qutip_testing_env/bin/python setup.py install); /Users/goerz/.pyenv/versions/miniconda3-latest/envs/qutip_testing_env/bin/python -m qutip.about; /Users/goerz/.pyenv/versions/miniconda3-latest/envs/qutip_testing_env/bin/nosetests --verbosity=2 --with-coverage --cover-package=qutip qutip; ~~~. The resulting output is:; ~~~; ...; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.0.dev0+d377c997; Numpy Version: 1.17.2; Scipy Version: 1.3.1; Cython Version: 0.29.13; Matplotlib Version: None; Python Version: 3.7.4; Number of CPUs: 2; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /Users/goerz/.pyenv/versions/miniconda3-latest/envs/qutip_testing_env/lib/python3.7/site-packages/qutip-4.5.0.dev0+; d377c997-py3.7-macosx-10.9-x86_64.egg/qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated u",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1093
https://github.com/qutip/qutip/issues/1093:3355,Testability,test,tests,3355,"===========; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; nose.plugins.cover: ERROR: Coverage not available: unable to import coverage module; /Users/goerz/.pyenv/versions/miniconda3-latest/envs/qutip_testing_env/lib/python3.7/site-packages/qutip-4.5.0.dev0+d377c997-py3.7-macos; x-10.9-x86_64.egg/qutip/__init__.py:161: UserWarning: matplotlib not found: Graphics will not work.; warnings.warn(""matplotlib not found: Graphics will not work.""); Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmesolve: harmonic oscillator, finite temperature, states ... ok; brmesolve: Jaynes-Cummings model, zero temperature ... ok; brmesolve: Check for #572 bug. ... ok; brmesolve: input list of Qobj ... ok; td_brmesolve: passes all brmesolve tests ... ok; td_brmesolve: time-dependent a_ops ... ok; td_brmesolve: time-dependent a_ops tuple of strings ... ok; td_brmesolve: time-dependent a_ops tuple interp ... ok td_brmesolve: time-dependent a_ops & c_ops interp ... ok; td_brmesolve: non-Hermitian e_ops check ... ok; td_brmesolve: states check ... ok; td_brmesolve: split ops #1 ... ok; td_brmesolve: split ops #2 ... ok; td_brmesolve: split ops, Cubic_Spline td-terms ... ok; td_brmesolve: split ops, multiple ... ok; td_brmesolve: Hamiltonian args ... ok; BR Tools : zheevr ... Segmentation fault: 11; ~~~",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1093
https://github.com/qutip/qutip/issues/1093:2913,Usability,simpl,simple,2913,"======================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; nose.plugins.cover: ERROR: Coverage not available: unable to import coverage module; /Users/goerz/.pyenv/versions/miniconda3-latest/envs/qutip_testing_env/lib/python3.7/site-packages/qutip-4.5.0.dev0+d377c997-py3.7-macos; x-10.9-x86_64.egg/qutip/__init__.py:161: UserWarning: matplotlib not found: Graphics will not work.; warnings.warn(""matplotlib not found: Graphics will not work.""); Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmesolve: harmonic oscillator, finite temperature, states ... ok; brmesolve: Jaynes-Cummings model, zero temperature ... ok; brmesolve: Check for #572 bug. ... ok; brmesolve: input list of Qobj ... ok; td_brmesolve: passes all brmesolve tests ... ok; td_brmesolve: time-dependent a_ops ... ok; td_brmesolve: time-dependent a_ops tuple of strings ... ok; td_brmesolve: time-dependent a_ops tuple interp ... ok td_brmesolve: time-dependent a_ops & c_ops interp ... ok; td_brmesolve: non-Hermitian e_ops check ... ok; td_brmesolve: states check ... ok; td_brmesolve: split ops #1 ... ok; td_brmesolve: split ops #2 ... ok; td_brmesolve: split ops, Cubic_Spline td-terms ... ok; td_brmesolve: split ops, multiple ... ok; td_brmesolve: Hamiltonian args ... ok; BR Tools : zheevr ... Segmentation fau",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1093
https://github.com/qutip/qutip/issues/1096:153,Availability,avail,available,153,"QuTiP currently uses QCircuit 2 (version of 2011) to generate LaTeX circuits that are printed to screen or saved to file. A newer version of QCircuit is available, 2.6.0 (2018) https://www.ctan.org/pkg/qcircuit. * `qcircuit` could be updated to the latest version . * Also, the use of this open source package could be highlighted more evidently in the documentation. * Another package has been recently released, https://arxiv.org/abs/1809.03842, Quantikz, which has some features related to noise that could be useful especially with regard to PR #1065, Google Summer of Code project by @BoxiLi on noise modeling in QIP. As this other package is very young, maybe an option to draw the circuit with this package, instead of qcircuit, could be given, also to avoid issues.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1096
https://github.com/qutip/qutip/issues/1096:234,Deployability,update,updated,234,"QuTiP currently uses QCircuit 2 (version of 2011) to generate LaTeX circuits that are printed to screen or saved to file. A newer version of QCircuit is available, 2.6.0 (2018) https://www.ctan.org/pkg/qcircuit. * `qcircuit` could be updated to the latest version . * Also, the use of this open source package could be highlighted more evidently in the documentation. * Another package has been recently released, https://arxiv.org/abs/1809.03842, Quantikz, which has some features related to noise that could be useful especially with regard to PR #1065, Google Summer of Code project by @BoxiLi on noise modeling in QIP. As this other package is very young, maybe an option to draw the circuit with this package, instead of qcircuit, could be given, also to avoid issues.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1096
https://github.com/qutip/qutip/issues/1096:404,Deployability,release,released,404,"QuTiP currently uses QCircuit 2 (version of 2011) to generate LaTeX circuits that are printed to screen or saved to file. A newer version of QCircuit is available, 2.6.0 (2018) https://www.ctan.org/pkg/qcircuit. * `qcircuit` could be updated to the latest version . * Also, the use of this open source package could be highlighted more evidently in the documentation. * Another package has been recently released, https://arxiv.org/abs/1809.03842, Quantikz, which has some features related to noise that could be useful especially with regard to PR #1065, Google Summer of Code project by @BoxiLi on noise modeling in QIP. As this other package is very young, maybe an option to draw the circuit with this package, instead of qcircuit, could be given, also to avoid issues.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1096
https://github.com/qutip/qutip/issues/1096:760,Safety,avoid,avoid,760,"QuTiP currently uses QCircuit 2 (version of 2011) to generate LaTeX circuits that are printed to screen or saved to file. A newer version of QCircuit is available, 2.6.0 (2018) https://www.ctan.org/pkg/qcircuit. * `qcircuit` could be updated to the latest version . * Also, the use of this open source package could be highlighted more evidently in the documentation. * Another package has been recently released, https://arxiv.org/abs/1809.03842, Quantikz, which has some features related to noise that could be useful especially with regard to PR #1065, Google Summer of Code project by @BoxiLi on noise modeling in QIP. As this other package is very young, maybe an option to draw the circuit with this package, instead of qcircuit, could be given, also to avoid issues.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1096
https://github.com/qutip/qutip/pull/1097:126,Availability,down,down,126,"Fix adding points to the Bloch sphere, with `Bloch.add_points(point)`. ; This solves Issue #1027.; It was a bit tricky to pin down. In Matplotlib 3.1.0, differently from 3.0.3, `edgecolor='none'` somehow produced a broadcast error, whereas now it is set by default to `None`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1097
https://github.com/qutip/qutip/pull/1097:225,Availability,error,error,225,"Fix adding points to the Bloch sphere, with `Bloch.add_points(point)`. ; This solves Issue #1027.; It was a bit tricky to pin down. In Matplotlib 3.1.0, differently from 3.0.3, `edgecolor='none'` somehow produced a broadcast error, whereas now it is set by default to `None`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1097
https://github.com/qutip/qutip/issues/1102:1795,Deployability,Install,Installed,1795,"I tried to calculate the inverse of an operator as following:; ```; >>> import qutip as qt; >>> from scipy.sparse.linalg import inv; >>> inv(qt.sigmaz().data); C:\Users\username\Miniconda3\lib\site-packages\scipy\sparse\linalg\dsolve\linsolve.py:296: SparseEfficiencyWarning: splu requires CSC matrix format; warn('splu requires CSC matrix format', SparseEfficiencyWarning); C:\Users\username\Miniconda3\lib\site-packages\scipy\sparse\linalg\dsolve\linsolve.py:203: SparseEfficiencyWarning: spsolve is more efficient when sparse b is in the CSC matrix format; 'is in the CSC matrix format', SparseEfficiencyWarning); Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; File ""C:\Users\username\Miniconda3\lib\site-packages\scipy\sparse\linalg\matfuncs.py"", line 78, in inv ; Ainv = spsolve(A, I); File ""C:\Users\username\Miniconda3\lib\site-packages\scipy\sparse\linalg\dsolve\linsolve.py"", line 223, in spsolve; shape=b.shape, dtype=A.dtype); File ""C:\Users\username\Miniconda3\lib\site-packages\qutip\fastsparse.py"", line 59, in __init__; if args[1].shape[0] and args[1].dtype != np.int32:; AttributeError: 'tuple' object has no attribute 'shape'; ```; I don't know why this doesn't work.; Although I can convert it to be dense, and use `scipy.linalg.inv` to do the same job,; the super operaters to be inverted in my actual problems are extremely large and sparse, and the inverses are also expected to be sparse.; So I want to find a way without converting them to dense.; But I didn't find any function in QuTiP to do that. Or maybe I missed it?. BTW, the version I use is:; ```; QuTiP Version: 4.4.1; Numpy Version: 1.16.5; Scipy Version: 1.3.1; Cython Version: 0.29.13; Matplotlib Version: 3.1.1; Python Version: 3.7.3; Number of CPUs: 4; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Windows (AMD64); Installation path: C:\Users\username\Miniconda3\lib\site-packages\qutip; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1102
https://github.com/qutip/qutip/issues/1102:1866,Deployability,Install,Installation,1866,"I tried to calculate the inverse of an operator as following:; ```; >>> import qutip as qt; >>> from scipy.sparse.linalg import inv; >>> inv(qt.sigmaz().data); C:\Users\username\Miniconda3\lib\site-packages\scipy\sparse\linalg\dsolve\linsolve.py:296: SparseEfficiencyWarning: splu requires CSC matrix format; warn('splu requires CSC matrix format', SparseEfficiencyWarning); C:\Users\username\Miniconda3\lib\site-packages\scipy\sparse\linalg\dsolve\linsolve.py:203: SparseEfficiencyWarning: spsolve is more efficient when sparse b is in the CSC matrix format; 'is in the CSC matrix format', SparseEfficiencyWarning); Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; File ""C:\Users\username\Miniconda3\lib\site-packages\scipy\sparse\linalg\matfuncs.py"", line 78, in inv ; Ainv = spsolve(A, I); File ""C:\Users\username\Miniconda3\lib\site-packages\scipy\sparse\linalg\dsolve\linsolve.py"", line 223, in spsolve; shape=b.shape, dtype=A.dtype); File ""C:\Users\username\Miniconda3\lib\site-packages\qutip\fastsparse.py"", line 59, in __init__; if args[1].shape[0] and args[1].dtype != np.int32:; AttributeError: 'tuple' object has no attribute 'shape'; ```; I don't know why this doesn't work.; Although I can convert it to be dense, and use `scipy.linalg.inv` to do the same job,; the super operaters to be inverted in my actual problems are extremely large and sparse, and the inverses are also expected to be sparse.; So I want to find a way without converting them to dense.; But I didn't find any function in QuTiP to do that. Or maybe I missed it?. BTW, the version I use is:; ```; QuTiP Version: 4.4.1; Numpy Version: 1.16.5; Scipy Version: 1.3.1; Cython Version: 0.29.13; Matplotlib Version: 3.1.1; Python Version: 3.7.3; Number of CPUs: 4; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Windows (AMD64); Installation path: C:\Users\username\Miniconda3\lib\site-packages\qutip; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1102
https://github.com/qutip/qutip/issues/1102:507,Energy Efficiency,efficient,efficient,507,"I tried to calculate the inverse of an operator as following:; ```; >>> import qutip as qt; >>> from scipy.sparse.linalg import inv; >>> inv(qt.sigmaz().data); C:\Users\username\Miniconda3\lib\site-packages\scipy\sparse\linalg\dsolve\linsolve.py:296: SparseEfficiencyWarning: splu requires CSC matrix format; warn('splu requires CSC matrix format', SparseEfficiencyWarning); C:\Users\username\Miniconda3\lib\site-packages\scipy\sparse\linalg\dsolve\linsolve.py:203: SparseEfficiencyWarning: spsolve is more efficient when sparse b is in the CSC matrix format; 'is in the CSC matrix format', SparseEfficiencyWarning); Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; File ""C:\Users\username\Miniconda3\lib\site-packages\scipy\sparse\linalg\matfuncs.py"", line 78, in inv ; Ainv = spsolve(A, I); File ""C:\Users\username\Miniconda3\lib\site-packages\scipy\sparse\linalg\dsolve\linsolve.py"", line 223, in spsolve; shape=b.shape, dtype=A.dtype); File ""C:\Users\username\Miniconda3\lib\site-packages\qutip\fastsparse.py"", line 59, in __init__; if args[1].shape[0] and args[1].dtype != np.int32:; AttributeError: 'tuple' object has no attribute 'shape'; ```; I don't know why this doesn't work.; Although I can convert it to be dense, and use `scipy.linalg.inv` to do the same job,; the super operaters to be inverted in my actual problems are extremely large and sparse, and the inverses are also expected to be sparse.; So I want to find a way without converting them to dense.; But I didn't find any function in QuTiP to do that. Or maybe I missed it?. BTW, the version I use is:; ```; QuTiP Version: 4.4.1; Numpy Version: 1.16.5; Scipy Version: 1.3.1; Cython Version: 0.29.13; Matplotlib Version: 3.1.1; Python Version: 3.7.3; Number of CPUs: 4; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Windows (AMD64); Installation path: C:\Users\username\Miniconda3\lib\site-packages\qutip; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1102
https://github.com/qutip/qutip/issues/1103:770,Deployability,update,update,770,"Hi there! You people have done an incredible work with Qutip, but I still think there are many small settings that could be added probably without much effort;. When saving a Bloch sphere. ```python; from qutip import *. b = Bloch(); b.save(dirc = 'temp'); ```. It would be awesome to have a way to specify the resolution of the png image just like in pyplot. Something like this. ```python; b.save(dirc = 'temp', dpi = 600); ```. Not having this option currently forbids these images to be added to conference posters or HD animations since the resolution is too low. Is there any quick workaround for this? I really need to know how to do it if there's a way. ----------------------------------------------; I guess this is a more complicated thing for the next Qutip update since it would be good to not just increase the resolution of the saved image but also the number of polygons making the sphere (which I guess would look smoother when zooming in the image).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1103
https://github.com/qutip/qutip/pull/1104:124,Testability,test,test,124,"added an argument to take dpsi (dots per inch) in Bloch.save(), whose usage would be as follows :; ``` b = Bloch(); b.save(""test"", dpsi = 1000); ```; Only modified bloch.py, hence merge ready",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1104
https://github.com/qutip/qutip/issues/1105:3125,Deployability,toggle,toggle,3125,"for plotting**; In [the code](http://qutip.org/docs/4.0.2/modules/qutip/bloch.html) for the add_points function it is written that. ```; meth : str {'s', 'm', 'l'}; Type of points to plot, use 'm' for multicolored, 'l' for points; connected with a line.; ```. First of all, it is not true that `meth = 'l'` gives points connected by lines (which in pyplot would be done with the `linestyle='-'` and `marker='o'` parameters) but it gives lines without the point markers (`linestyle='-'` and `marker='None'` in pyplot). But this is not important since it is just a comment on a function. The thing that matters is that it would be great if we had a `b.linestyle` and `b.marker` methods for the Bloch sphere instead of a `meth` parameter which can only show either points or lines without them, just like/similar to the [line styles](https://matplotlib.org/3.1.1/gallery/lines_bars_and_markers/linestyles.html) and [marker styles](https://matplotlib.org/3.1.1/api/markers_api.html) of pyplot. Or any other idea that could allow the user to create more complicated graphs on the Bloch sphere. _______________________________________________________________. **3) Adding edge color parameter for plotted points**; The `b.point_color` method changes the color of the points but it doen't change the edge color of those marker points. This is important since right now one can only choose between two restrictive options; either we plot the points with large sizes ([like in this image](https://i.imgur.com/pGhU55e.png)) so the chosen color can be seen, or we have to see the dots as black points if we chose a smaller size for them ([like in thsi image](https://i.imgur.com/5Ql5sKM.png)). What I mean is that if I want to plot small points in red I just can't do it, since the black edge will dominate. Just like in pyplot, it would be good to have an option to toggle the edge or choose the edge color. Or if that is too complicated, maybe you could make the marker edge color the same as `b.point_color`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1105
https://github.com/qutip/qutip/issues/1105:34,Usability,simpl,simple,34,"Hello again. Since these are very simple and related issues I will adress them in a single post. **1) Adding control over plotted line width**; When we create a Bloch sphere with `b = Bloch()` and add points, `pnts_list`, to it with `b.add_points(pnts_list, meth = 'l')` we can use this handy `meth` parameter to instead of plotting points (which corresponds to the value `'s'` and [looks like this](https://i.imgur.com/pGhU55e.png)) connect them with line segments (which corresponds to the value `'l'` and [looks like this](https://i.imgur.com/QrvLSmd.png)). We can control de size of the points with `b.point_size` but we can't do it for lines (when `meth = 'l'` is been used). It would be nice to have that option, to allow control over the width of the lines plotted just like with points. In that way we could prevent it to be confused with the frame of the bloch sphere in a black and white image. Maybe a good way of solving this would be to use the value of `b.point_size` for that. Or maybe a better option would be to have a new `b.line_size` parameter to allow for different sizes between points and lines (which makes everything more customizable).; _______________________________________________________________. **2) Adding styles for markers and lines for plotting**; In [the code](http://qutip.org/docs/4.0.2/modules/qutip/bloch.html) for the add_points function it is written that. ```; meth : str {'s', 'm', 'l'}; Type of points to plot, use 'm' for multicolored, 'l' for points; connected with a line.; ```. First of all, it is not true that `meth = 'l'` gives points connected by lines (which in pyplot would be done with the `linestyle='-'` and `marker='o'` parameters) but it gives lines without the point markers (`linestyle='-'` and `marker='None'` in pyplot). But this is not important since it is just a comment on a function. The thing that matters is that it would be great if we had a `b.linestyle` and `b.marker` methods for the Bloch sphere instead of a `meth` paramet",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1105
https://github.com/qutip/qutip/issues/1106:581,Deployability,update,update,581,"Hi again,. In the documents [there is an example](http://qutip.org/docs/4.1/guide/guide-bloch.html#animating-with-the-bloch-sphere) of how to do an animation of a Bloch sphere by saving the frames of the movie using a for loop like so:. ```python; b = Bloch(); b.vector_color = ['r']; b.view = [-40,30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp'); ```. With `b.clear()` we erase the points and vectors in the image, which is nice for updating the data, but What if I want to update also the attributes of the Bloch sphere?. To give an example let's say that I want the viewing angle of the Bloch sphere to smoothly change throughout the animation. I can define a function like so:. ```python; def bloch_camera_path(t, dt, azim_0, azim_f, elev_0, elev_f):; azim = ((azim_f-azim_0)/dt)*t+azim_0; elev = ((elev_f-elev_0)/dt)*t+elev_0; return [azim, elev]; ```. This function changes the viewing angle across time from the initial `[azim_0, elev_0]` configuration to the final `[azim_f, elev_f]` configuration in a linear manner. So I thought that by doing. ```python; b = Bloch(); b.vector_color = ['r']; for i in range(len(t)):; b.clear(); b.view = bloch_camera_path(t[i], t[-1]-t[0], -80, -70, 45, 40); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp'); ```; My animation would had that change in position of the ""camera"", but the result is just as if `b.view` wouldn't update. The only way I can make this work is by making a new bloch sphere on each iteration and defining all the attributes again and again (which I find highly inconvenient in terms of speed), like so;. ```python; import os. for i in range(len(t)):; b = Bloch(); b.vector_color = ['r']; b.view = bloch_camera_path(t[i], t[-1]-t[0], -80, -70, 45, 40); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(os.getcwd()+'",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1106
https://github.com/qutip/qutip/issues/1106:1052,Deployability,configurat,configuration,1052,"e](http://qutip.org/docs/4.1/guide/guide-bloch.html#animating-with-the-bloch-sphere) of how to do an animation of a Bloch sphere by saving the frames of the movie using a for loop like so:. ```python; b = Bloch(); b.vector_color = ['r']; b.view = [-40,30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp'); ```. With `b.clear()` we erase the points and vectors in the image, which is nice for updating the data, but What if I want to update also the attributes of the Bloch sphere?. To give an example let's say that I want the viewing angle of the Bloch sphere to smoothly change throughout the animation. I can define a function like so:. ```python; def bloch_camera_path(t, dt, azim_0, azim_f, elev_0, elev_f):; azim = ((azim_f-azim_0)/dt)*t+azim_0; elev = ((elev_f-elev_0)/dt)*t+elev_0; return [azim, elev]; ```. This function changes the viewing angle across time from the initial `[azim_0, elev_0]` configuration to the final `[azim_f, elev_f]` configuration in a linear manner. So I thought that by doing. ```python; b = Bloch(); b.vector_color = ['r']; for i in range(len(t)):; b.clear(); b.view = bloch_camera_path(t[i], t[-1]-t[0], -80, -70, 45, 40); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp'); ```; My animation would had that change in position of the ""camera"", but the result is just as if `b.view` wouldn't update. The only way I can make this work is by making a new bloch sphere on each iteration and defining all the attributes again and again (which I find highly inconvenient in terms of speed), like so;. ```python; import os. for i in range(len(t)):; b = Bloch(); b.vector_color = ['r']; b.view = bloch_camera_path(t[i], t[-1]-t[0], -80, -70, 45, 40); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(os.getcwd()+'/temp/bloch_'+str(i)+'.png', dirc='temp'); b.c",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1106
https://github.com/qutip/qutip/issues/1106:1098,Deployability,configurat,configuration,1098,"e](http://qutip.org/docs/4.1/guide/guide-bloch.html#animating-with-the-bloch-sphere) of how to do an animation of a Bloch sphere by saving the frames of the movie using a for loop like so:. ```python; b = Bloch(); b.vector_color = ['r']; b.view = [-40,30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp'); ```. With `b.clear()` we erase the points and vectors in the image, which is nice for updating the data, but What if I want to update also the attributes of the Bloch sphere?. To give an example let's say that I want the viewing angle of the Bloch sphere to smoothly change throughout the animation. I can define a function like so:. ```python; def bloch_camera_path(t, dt, azim_0, azim_f, elev_0, elev_f):; azim = ((azim_f-azim_0)/dt)*t+azim_0; elev = ((elev_f-elev_0)/dt)*t+elev_0; return [azim, elev]; ```. This function changes the viewing angle across time from the initial `[azim_0, elev_0]` configuration to the final `[azim_f, elev_f]` configuration in a linear manner. So I thought that by doing. ```python; b = Bloch(); b.vector_color = ['r']; for i in range(len(t)):; b.clear(); b.view = bloch_camera_path(t[i], t[-1]-t[0], -80, -70, 45, 40); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp'); ```; My animation would had that change in position of the ""camera"", but the result is just as if `b.view` wouldn't update. The only way I can make this work is by making a new bloch sphere on each iteration and defining all the attributes again and again (which I find highly inconvenient in terms of speed), like so;. ```python; import os. for i in range(len(t)):; b = Bloch(); b.vector_color = ['r']; b.view = bloch_camera_path(t[i], t[-1]-t[0], -80, -70, 45, 40); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(os.getcwd()+'/temp/bloch_'+str(i)+'.png', dirc='temp'); b.c",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1106
https://github.com/qutip/qutip/issues/1106:1537,Deployability,update,update,1537,"r']; b.view = [-40,30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp'); ```. With `b.clear()` we erase the points and vectors in the image, which is nice for updating the data, but What if I want to update also the attributes of the Bloch sphere?. To give an example let's say that I want the viewing angle of the Bloch sphere to smoothly change throughout the animation. I can define a function like so:. ```python; def bloch_camera_path(t, dt, azim_0, azim_f, elev_0, elev_f):; azim = ((azim_f-azim_0)/dt)*t+azim_0; elev = ((elev_f-elev_0)/dt)*t+elev_0; return [azim, elev]; ```. This function changes the viewing angle across time from the initial `[azim_0, elev_0]` configuration to the final `[azim_f, elev_f]` configuration in a linear manner. So I thought that by doing. ```python; b = Bloch(); b.vector_color = ['r']; for i in range(len(t)):; b.clear(); b.view = bloch_camera_path(t[i], t[-1]-t[0], -80, -70, 45, 40); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp'); ```; My animation would had that change in position of the ""camera"", but the result is just as if `b.view` wouldn't update. The only way I can make this work is by making a new bloch sphere on each iteration and defining all the attributes again and again (which I find highly inconvenient in terms of speed), like so;. ```python; import os. for i in range(len(t)):; b = Bloch(); b.vector_color = ['r']; b.view = bloch_camera_path(t[i], t[-1]-t[0], -80, -70, 45, 40); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(os.getcwd()+'/temp/bloch_'+str(i)+'.png', dirc='temp'); b.clear(); ```. Could Qutip be modified so that attributes (such as viewing angle or the color of vectors) can be updated in the way I showed before? So that we don't have to create a new bloch sphere on each iteration of the animation?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1106
https://github.com/qutip/qutip/issues/1106:2158,Deployability,update,updated,2158,"r']; b.view = [-40,30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp'); ```. With `b.clear()` we erase the points and vectors in the image, which is nice for updating the data, but What if I want to update also the attributes of the Bloch sphere?. To give an example let's say that I want the viewing angle of the Bloch sphere to smoothly change throughout the animation. I can define a function like so:. ```python; def bloch_camera_path(t, dt, azim_0, azim_f, elev_0, elev_f):; azim = ((azim_f-azim_0)/dt)*t+azim_0; elev = ((elev_f-elev_0)/dt)*t+elev_0; return [azim, elev]; ```. This function changes the viewing angle across time from the initial `[azim_0, elev_0]` configuration to the final `[azim_f, elev_f]` configuration in a linear manner. So I thought that by doing. ```python; b = Bloch(); b.vector_color = ['r']; for i in range(len(t)):; b.clear(); b.view = bloch_camera_path(t[i], t[-1]-t[0], -80, -70, 45, 40); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp'); ```; My animation would had that change in position of the ""camera"", but the result is just as if `b.view` wouldn't update. The only way I can make this work is by making a new bloch sphere on each iteration and defining all the attributes again and again (which I find highly inconvenient in terms of speed), like so;. ```python; import os. for i in range(len(t)):; b = Bloch(); b.vector_color = ['r']; b.view = bloch_camera_path(t[i], t[-1]-t[0], -80, -70, 45, 40); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(os.getcwd()+'/temp/bloch_'+str(i)+'.png', dirc='temp'); b.clear(); ```. Could Qutip be modified so that attributes (such as viewing angle or the color of vectors) can be updated in the way I showed before? So that we don't have to create a new bloch sphere on each iteration of the animation?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1106
https://github.com/qutip/qutip/issues/1106:1052,Modifiability,config,configuration,1052,"e](http://qutip.org/docs/4.1/guide/guide-bloch.html#animating-with-the-bloch-sphere) of how to do an animation of a Bloch sphere by saving the frames of the movie using a for loop like so:. ```python; b = Bloch(); b.vector_color = ['r']; b.view = [-40,30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp'); ```. With `b.clear()` we erase the points and vectors in the image, which is nice for updating the data, but What if I want to update also the attributes of the Bloch sphere?. To give an example let's say that I want the viewing angle of the Bloch sphere to smoothly change throughout the animation. I can define a function like so:. ```python; def bloch_camera_path(t, dt, azim_0, azim_f, elev_0, elev_f):; azim = ((azim_f-azim_0)/dt)*t+azim_0; elev = ((elev_f-elev_0)/dt)*t+elev_0; return [azim, elev]; ```. This function changes the viewing angle across time from the initial `[azim_0, elev_0]` configuration to the final `[azim_f, elev_f]` configuration in a linear manner. So I thought that by doing. ```python; b = Bloch(); b.vector_color = ['r']; for i in range(len(t)):; b.clear(); b.view = bloch_camera_path(t[i], t[-1]-t[0], -80, -70, 45, 40); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp'); ```; My animation would had that change in position of the ""camera"", but the result is just as if `b.view` wouldn't update. The only way I can make this work is by making a new bloch sphere on each iteration and defining all the attributes again and again (which I find highly inconvenient in terms of speed), like so;. ```python; import os. for i in range(len(t)):; b = Bloch(); b.vector_color = ['r']; b.view = bloch_camera_path(t[i], t[-1]-t[0], -80, -70, 45, 40); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(os.getcwd()+'/temp/bloch_'+str(i)+'.png', dirc='temp'); b.c",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1106
https://github.com/qutip/qutip/issues/1106:1098,Modifiability,config,configuration,1098,"e](http://qutip.org/docs/4.1/guide/guide-bloch.html#animating-with-the-bloch-sphere) of how to do an animation of a Bloch sphere by saving the frames of the movie using a for loop like so:. ```python; b = Bloch(); b.vector_color = ['r']; b.view = [-40,30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp'); ```. With `b.clear()` we erase the points and vectors in the image, which is nice for updating the data, but What if I want to update also the attributes of the Bloch sphere?. To give an example let's say that I want the viewing angle of the Bloch sphere to smoothly change throughout the animation. I can define a function like so:. ```python; def bloch_camera_path(t, dt, azim_0, azim_f, elev_0, elev_f):; azim = ((azim_f-azim_0)/dt)*t+azim_0; elev = ((elev_f-elev_0)/dt)*t+elev_0; return [azim, elev]; ```. This function changes the viewing angle across time from the initial `[azim_0, elev_0]` configuration to the final `[azim_f, elev_f]` configuration in a linear manner. So I thought that by doing. ```python; b = Bloch(); b.vector_color = ['r']; for i in range(len(t)):; b.clear(); b.view = bloch_camera_path(t[i], t[-1]-t[0], -80, -70, 45, 40); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp'); ```; My animation would had that change in position of the ""camera"", but the result is just as if `b.view` wouldn't update. The only way I can make this work is by making a new bloch sphere on each iteration and defining all the attributes again and again (which I find highly inconvenient in terms of speed), like so;. ```python; import os. for i in range(len(t)):; b = Bloch(); b.vector_color = ['r']; b.view = bloch_camera_path(t[i], t[-1]-t[0], -80, -70, 45, 40); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(os.getcwd()+'/temp/bloch_'+str(i)+'.png', dirc='temp'); b.c",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1106
https://github.com/qutip/qutip/issues/1106:76,Usability,guid,guide,76,"Hi again,. In the documents [there is an example](http://qutip.org/docs/4.1/guide/guide-bloch.html#animating-with-the-bloch-sphere) of how to do an animation of a Bloch sphere by saving the frames of the movie using a for loop like so:. ```python; b = Bloch(); b.vector_color = ['r']; b.view = [-40,30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp'); ```. With `b.clear()` we erase the points and vectors in the image, which is nice for updating the data, but What if I want to update also the attributes of the Bloch sphere?. To give an example let's say that I want the viewing angle of the Bloch sphere to smoothly change throughout the animation. I can define a function like so:. ```python; def bloch_camera_path(t, dt, azim_0, azim_f, elev_0, elev_f):; azim = ((azim_f-azim_0)/dt)*t+azim_0; elev = ((elev_f-elev_0)/dt)*t+elev_0; return [azim, elev]; ```. This function changes the viewing angle across time from the initial `[azim_0, elev_0]` configuration to the final `[azim_f, elev_f]` configuration in a linear manner. So I thought that by doing. ```python; b = Bloch(); b.vector_color = ['r']; for i in range(len(t)):; b.clear(); b.view = bloch_camera_path(t[i], t[-1]-t[0], -80, -70, 45, 40); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp'); ```; My animation would had that change in position of the ""camera"", but the result is just as if `b.view` wouldn't update. The only way I can make this work is by making a new bloch sphere on each iteration and defining all the attributes again and again (which I find highly inconvenient in terms of speed), like so;. ```python; import os. for i in range(len(t)):; b = Bloch(); b.vector_color = ['r']; b.view = bloch_camera_path(t[i], t[-1]-t[0], -80, -70, 45, 40); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(os.getcwd()+'",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1106
https://github.com/qutip/qutip/issues/1106:82,Usability,guid,guide-bloch,82,"Hi again,. In the documents [there is an example](http://qutip.org/docs/4.1/guide/guide-bloch.html#animating-with-the-bloch-sphere) of how to do an animation of a Bloch sphere by saving the frames of the movie using a for loop like so:. ```python; b = Bloch(); b.vector_color = ['r']; b.view = [-40,30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp'); ```. With `b.clear()` we erase the points and vectors in the image, which is nice for updating the data, but What if I want to update also the attributes of the Bloch sphere?. To give an example let's say that I want the viewing angle of the Bloch sphere to smoothly change throughout the animation. I can define a function like so:. ```python; def bloch_camera_path(t, dt, azim_0, azim_f, elev_0, elev_f):; azim = ((azim_f-azim_0)/dt)*t+azim_0; elev = ((elev_f-elev_0)/dt)*t+elev_0; return [azim, elev]; ```. This function changes the viewing angle across time from the initial `[azim_0, elev_0]` configuration to the final `[azim_f, elev_f]` configuration in a linear manner. So I thought that by doing. ```python; b = Bloch(); b.vector_color = ['r']; for i in range(len(t)):; b.clear(); b.view = bloch_camera_path(t[i], t[-1]-t[0], -80, -70, 45, 40); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp'); ```; My animation would had that change in position of the ""camera"", but the result is just as if `b.view` wouldn't update. The only way I can make this work is by making a new bloch sphere on each iteration and defining all the attributes again and again (which I find highly inconvenient in terms of speed), like so;. ```python; import os. for i in range(len(t)):; b = Bloch(); b.vector_color = ['r']; b.view = bloch_camera_path(t[i], t[-1]-t[0], -80, -70, 45, 40); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(os.getcwd()+'",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1106
https://github.com/qutip/qutip/issues/1106:332,Usability,clear,clear,332,"Hi again,. In the documents [there is an example](http://qutip.org/docs/4.1/guide/guide-bloch.html#animating-with-the-bloch-sphere) of how to do an animation of a Bloch sphere by saving the frames of the movie using a for loop like so:. ```python; b = Bloch(); b.vector_color = ['r']; b.view = [-40,30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp'); ```. With `b.clear()` we erase the points and vectors in the image, which is nice for updating the data, but What if I want to update also the attributes of the Bloch sphere?. To give an example let's say that I want the viewing angle of the Bloch sphere to smoothly change throughout the animation. I can define a function like so:. ```python; def bloch_camera_path(t, dt, azim_0, azim_f, elev_0, elev_f):; azim = ((azim_f-azim_0)/dt)*t+azim_0; elev = ((elev_f-elev_0)/dt)*t+elev_0; return [azim, elev]; ```. This function changes the viewing angle across time from the initial `[azim_0, elev_0]` configuration to the final `[azim_f, elev_f]` configuration in a linear manner. So I thought that by doing. ```python; b = Bloch(); b.vector_color = ['r']; for i in range(len(t)):; b.clear(); b.view = bloch_camera_path(t[i], t[-1]-t[0], -80, -70, 45, 40); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp'); ```; My animation would had that change in position of the ""camera"", but the result is just as if `b.view` wouldn't update. The only way I can make this work is by making a new bloch sphere on each iteration and defining all the attributes again and again (which I find highly inconvenient in terms of speed), like so;. ```python; import os. for i in range(len(t)):; b = Bloch(); b.vector_color = ['r']; b.view = bloch_camera_path(t[i], t[-1]-t[0], -80, -70, 45, 40); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(os.getcwd()+'",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1106
https://github.com/qutip/qutip/issues/1106:467,Usability,clear,clear,467,"Hi again,. In the documents [there is an example](http://qutip.org/docs/4.1/guide/guide-bloch.html#animating-with-the-bloch-sphere) of how to do an animation of a Bloch sphere by saving the frames of the movie using a for loop like so:. ```python; b = Bloch(); b.vector_color = ['r']; b.view = [-40,30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp'); ```. With `b.clear()` we erase the points and vectors in the image, which is nice for updating the data, but What if I want to update also the attributes of the Bloch sphere?. To give an example let's say that I want the viewing angle of the Bloch sphere to smoothly change throughout the animation. I can define a function like so:. ```python; def bloch_camera_path(t, dt, azim_0, azim_f, elev_0, elev_f):; azim = ((azim_f-azim_0)/dt)*t+azim_0; elev = ((elev_f-elev_0)/dt)*t+elev_0; return [azim, elev]; ```. This function changes the viewing angle across time from the initial `[azim_0, elev_0]` configuration to the final `[azim_f, elev_f]` configuration in a linear manner. So I thought that by doing. ```python; b = Bloch(); b.vector_color = ['r']; for i in range(len(t)):; b.clear(); b.view = bloch_camera_path(t[i], t[-1]-t[0], -80, -70, 45, 40); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp'); ```; My animation would had that change in position of the ""camera"", but the result is just as if `b.view` wouldn't update. The only way I can make this work is by making a new bloch sphere on each iteration and defining all the attributes again and again (which I find highly inconvenient in terms of speed), like so;. ```python; import os. for i in range(len(t)):; b = Bloch(); b.vector_color = ['r']; b.view = bloch_camera_path(t[i], t[-1]-t[0], -80, -70, 45, 40); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(os.getcwd()+'",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1106
https://github.com/qutip/qutip/issues/1106:1235,Usability,clear,clear,1235,"python; b = Bloch(); b.vector_color = ['r']; b.view = [-40,30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp'); ```. With `b.clear()` we erase the points and vectors in the image, which is nice for updating the data, but What if I want to update also the attributes of the Bloch sphere?. To give an example let's say that I want the viewing angle of the Bloch sphere to smoothly change throughout the animation. I can define a function like so:. ```python; def bloch_camera_path(t, dt, azim_0, azim_f, elev_0, elev_f):; azim = ((azim_f-azim_0)/dt)*t+azim_0; elev = ((elev_f-elev_0)/dt)*t+elev_0; return [azim, elev]; ```. This function changes the viewing angle across time from the initial `[azim_0, elev_0]` configuration to the final `[azim_f, elev_f]` configuration in a linear manner. So I thought that by doing. ```python; b = Bloch(); b.vector_color = ['r']; for i in range(len(t)):; b.clear(); b.view = bloch_camera_path(t[i], t[-1]-t[0], -80, -70, 45, 40); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp'); ```; My animation would had that change in position of the ""camera"", but the result is just as if `b.view` wouldn't update. The only way I can make this work is by making a new bloch sphere on each iteration and defining all the attributes again and again (which I find highly inconvenient in terms of speed), like so;. ```python; import os. for i in range(len(t)):; b = Bloch(); b.vector_color = ['r']; b.view = bloch_camera_path(t[i], t[-1]-t[0], -80, -70, 45, 40); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(os.getcwd()+'/temp/bloch_'+str(i)+'.png', dirc='temp'); b.clear(); ```. Could Qutip be modified so that attributes (such as viewing angle or the color of vectors) can be updated in the way I showed before? So that we don't have to create a new bloch sph",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1106
https://github.com/qutip/qutip/issues/1106:2046,Usability,clear,clear,2046,"r']; b.view = [-40,30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp'); ```. With `b.clear()` we erase the points and vectors in the image, which is nice for updating the data, but What if I want to update also the attributes of the Bloch sphere?. To give an example let's say that I want the viewing angle of the Bloch sphere to smoothly change throughout the animation. I can define a function like so:. ```python; def bloch_camera_path(t, dt, azim_0, azim_f, elev_0, elev_f):; azim = ((azim_f-azim_0)/dt)*t+azim_0; elev = ((elev_f-elev_0)/dt)*t+elev_0; return [azim, elev]; ```. This function changes the viewing angle across time from the initial `[azim_0, elev_0]` configuration to the final `[azim_f, elev_f]` configuration in a linear manner. So I thought that by doing. ```python; b = Bloch(); b.vector_color = ['r']; for i in range(len(t)):; b.clear(); b.view = bloch_camera_path(t[i], t[-1]-t[0], -80, -70, 45, 40); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp'); ```; My animation would had that change in position of the ""camera"", but the result is just as if `b.view` wouldn't update. The only way I can make this work is by making a new bloch sphere on each iteration and defining all the attributes again and again (which I find highly inconvenient in terms of speed), like so;. ```python; import os. for i in range(len(t)):; b = Bloch(); b.vector_color = ['r']; b.view = bloch_camera_path(t[i], t[-1]-t[0], -80, -70, 45, 40); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(os.getcwd()+'/temp/bloch_'+str(i)+'.png', dirc='temp'); b.clear(); ```. Could Qutip be modified so that attributes (such as viewing angle or the color of vectors) can be updated in the way I showed before? So that we don't have to create a new bloch sphere on each iteration of the animation?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1106
https://github.com/qutip/qutip/pull/1107:865,Deployability,Update,Update,865,"While solving some time-dependent Hamiltonians, I decided to refactor the list-style definition of my Hamiltonian and completely get rid of all ```partial``` calls which made my code much cleaner. In particular, I implemented a small class to construct the time-dependent components that go into the Hamiltonian and overwrote the ```__call__``` method to make my class object directly callable by Qutip. However, this was rejected by Qutip as an ""Incorrect Hamiltonian specification"" due to the format check. Since, as far as I know, subclassing the built-in FunctionType ```function``` is not possible in Python, and subclasses of FunctionType would not be accepted by Qutip either (```_td_format_check``` calls ```isinstance``` and not ```issubclass```), I suggest that Qutip also accepts general objects which have the ```__call__``` attribute defined. Changes: Update ```_td_format_check``` by one extra condition to allow any object with attribute ```__call__``` in the definition of a Hamiltonian.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1107
https://github.com/qutip/qutip/pull/1107:24,Integrability,depend,dependent,24,"While solving some time-dependent Hamiltonians, I decided to refactor the list-style definition of my Hamiltonian and completely get rid of all ```partial``` calls which made my code much cleaner. In particular, I implemented a small class to construct the time-dependent components that go into the Hamiltonian and overwrote the ```__call__``` method to make my class object directly callable by Qutip. However, this was rejected by Qutip as an ""Incorrect Hamiltonian specification"" due to the format check. Since, as far as I know, subclassing the built-in FunctionType ```function``` is not possible in Python, and subclasses of FunctionType would not be accepted by Qutip either (```_td_format_check``` calls ```isinstance``` and not ```issubclass```), I suggest that Qutip also accepts general objects which have the ```__call__``` attribute defined. Changes: Update ```_td_format_check``` by one extra condition to allow any object with attribute ```__call__``` in the definition of a Hamiltonian.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1107
https://github.com/qutip/qutip/pull/1107:262,Integrability,depend,dependent,262,"While solving some time-dependent Hamiltonians, I decided to refactor the list-style definition of my Hamiltonian and completely get rid of all ```partial``` calls which made my code much cleaner. In particular, I implemented a small class to construct the time-dependent components that go into the Hamiltonian and overwrote the ```__call__``` method to make my class object directly callable by Qutip. However, this was rejected by Qutip as an ""Incorrect Hamiltonian specification"" due to the format check. Since, as far as I know, subclassing the built-in FunctionType ```function``` is not possible in Python, and subclasses of FunctionType would not be accepted by Qutip either (```_td_format_check``` calls ```isinstance``` and not ```issubclass```), I suggest that Qutip also accepts general objects which have the ```__call__``` attribute defined. Changes: Update ```_td_format_check``` by one extra condition to allow any object with attribute ```__call__``` in the definition of a Hamiltonian.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1107
https://github.com/qutip/qutip/pull/1107:61,Modifiability,refactor,refactor,61,"While solving some time-dependent Hamiltonians, I decided to refactor the list-style definition of my Hamiltonian and completely get rid of all ```partial``` calls which made my code much cleaner. In particular, I implemented a small class to construct the time-dependent components that go into the Hamiltonian and overwrote the ```__call__``` method to make my class object directly callable by Qutip. However, this was rejected by Qutip as an ""Incorrect Hamiltonian specification"" due to the format check. Since, as far as I know, subclassing the built-in FunctionType ```function``` is not possible in Python, and subclasses of FunctionType would not be accepted by Qutip either (```_td_format_check``` calls ```isinstance``` and not ```issubclass```), I suggest that Qutip also accepts general objects which have the ```__call__``` attribute defined. Changes: Update ```_td_format_check``` by one extra condition to allow any object with attribute ```__call__``` in the definition of a Hamiltonian.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1107
https://github.com/qutip/qutip/issues/1108:182,Deployability,release,release,182,"Referencing this : https://github.com/qutip/qutip-doc/pull/70. 1. Having manually compiled the changelog for v4.4.1 and v4.5.x today, I think that maybe we should try automating the release notes/changelogs with something like this : https://github.com/github-tools/github-release-notes; I'm attaching release notes generated by this for QuTiP.; [RELEASE_NOTES.txt](https://github.com/qutip/qutip/files/3728179/RELEASE_NOTES.txt). 2. We could also, in pursuit of having an automated release notes/changelog system start with making commits in more of a standard format, using some pre-decided keywords like [bugfix] or [improvement] in the commit message. I understand that this is a rather ambitious thing to say, but we can then use `grep` and `git log` itself to generate these in markdown. As a first step, I am proposing to use **Pull request /Issue** templates, something like this for instance : https://github.com/angular-translate/angular-translate/blob/master/.github/ISSUE_TEMPLATE.md; This way, all our Pull Requests and Issues will be homogeneously formatted.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1108
https://github.com/qutip/qutip/issues/1108:273,Deployability,release,release-notes,273,"Referencing this : https://github.com/qutip/qutip-doc/pull/70. 1. Having manually compiled the changelog for v4.4.1 and v4.5.x today, I think that maybe we should try automating the release notes/changelogs with something like this : https://github.com/github-tools/github-release-notes; I'm attaching release notes generated by this for QuTiP.; [RELEASE_NOTES.txt](https://github.com/qutip/qutip/files/3728179/RELEASE_NOTES.txt). 2. We could also, in pursuit of having an automated release notes/changelog system start with making commits in more of a standard format, using some pre-decided keywords like [bugfix] or [improvement] in the commit message. I understand that this is a rather ambitious thing to say, but we can then use `grep` and `git log` itself to generate these in markdown. As a first step, I am proposing to use **Pull request /Issue** templates, something like this for instance : https://github.com/angular-translate/angular-translate/blob/master/.github/ISSUE_TEMPLATE.md; This way, all our Pull Requests and Issues will be homogeneously formatted.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1108
https://github.com/qutip/qutip/issues/1108:302,Deployability,release,release,302,"Referencing this : https://github.com/qutip/qutip-doc/pull/70. 1. Having manually compiled the changelog for v4.4.1 and v4.5.x today, I think that maybe we should try automating the release notes/changelogs with something like this : https://github.com/github-tools/github-release-notes; I'm attaching release notes generated by this for QuTiP.; [RELEASE_NOTES.txt](https://github.com/qutip/qutip/files/3728179/RELEASE_NOTES.txt). 2. We could also, in pursuit of having an automated release notes/changelog system start with making commits in more of a standard format, using some pre-decided keywords like [bugfix] or [improvement] in the commit message. I understand that this is a rather ambitious thing to say, but we can then use `grep` and `git log` itself to generate these in markdown. As a first step, I am proposing to use **Pull request /Issue** templates, something like this for instance : https://github.com/angular-translate/angular-translate/blob/master/.github/ISSUE_TEMPLATE.md; This way, all our Pull Requests and Issues will be homogeneously formatted.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1108
https://github.com/qutip/qutip/issues/1108:483,Deployability,release,release,483,"Referencing this : https://github.com/qutip/qutip-doc/pull/70. 1. Having manually compiled the changelog for v4.4.1 and v4.5.x today, I think that maybe we should try automating the release notes/changelogs with something like this : https://github.com/github-tools/github-release-notes; I'm attaching release notes generated by this for QuTiP.; [RELEASE_NOTES.txt](https://github.com/qutip/qutip/files/3728179/RELEASE_NOTES.txt). 2. We could also, in pursuit of having an automated release notes/changelog system start with making commits in more of a standard format, using some pre-decided keywords like [bugfix] or [improvement] in the commit message. I understand that this is a rather ambitious thing to say, but we can then use `grep` and `git log` itself to generate these in markdown. As a first step, I am proposing to use **Pull request /Issue** templates, something like this for instance : https://github.com/angular-translate/angular-translate/blob/master/.github/ISSUE_TEMPLATE.md; This way, all our Pull Requests and Issues will be homogeneously formatted.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1108
https://github.com/qutip/qutip/issues/1108:647,Integrability,message,message,647,"Referencing this : https://github.com/qutip/qutip-doc/pull/70. 1. Having manually compiled the changelog for v4.4.1 and v4.5.x today, I think that maybe we should try automating the release notes/changelogs with something like this : https://github.com/github-tools/github-release-notes; I'm attaching release notes generated by this for QuTiP.; [RELEASE_NOTES.txt](https://github.com/qutip/qutip/files/3728179/RELEASE_NOTES.txt). 2. We could also, in pursuit of having an automated release notes/changelog system start with making commits in more of a standard format, using some pre-decided keywords like [bugfix] or [improvement] in the commit message. I understand that this is a rather ambitious thing to say, but we can then use `grep` and `git log` itself to generate these in markdown. As a first step, I am proposing to use **Pull request /Issue** templates, something like this for instance : https://github.com/angular-translate/angular-translate/blob/master/.github/ISSUE_TEMPLATE.md; This way, all our Pull Requests and Issues will be homogeneously formatted.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1108
https://github.com/qutip/qutip/issues/1108:751,Testability,log,log,751,"Referencing this : https://github.com/qutip/qutip-doc/pull/70. 1. Having manually compiled the changelog for v4.4.1 and v4.5.x today, I think that maybe we should try automating the release notes/changelogs with something like this : https://github.com/github-tools/github-release-notes; I'm attaching release notes generated by this for QuTiP.; [RELEASE_NOTES.txt](https://github.com/qutip/qutip/files/3728179/RELEASE_NOTES.txt). 2. We could also, in pursuit of having an automated release notes/changelog system start with making commits in more of a standard format, using some pre-decided keywords like [bugfix] or [improvement] in the commit message. I understand that this is a rather ambitious thing to say, but we can then use `grep` and `git log` itself to generate these in markdown. As a first step, I am proposing to use **Pull request /Issue** templates, something like this for instance : https://github.com/angular-translate/angular-translate/blob/master/.github/ISSUE_TEMPLATE.md; This way, all our Pull Requests and Issues will be homogeneously formatted.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1108
https://github.com/qutip/qutip/issues/1109:56,Availability,error,error,56,"Since merging PR #1082 , I've been getting this strange error whenever I import QuTiP:; ```; (qutip-env) tarun@trolldem0rt:~/riken-work$ python fidel.py ; cc1plus: warning: command line option ‘-Wstrict-prototypes’ is valid for C/ObjC but not for C++; /home/tarun/.pyxbld/temp.linux-x86_64-3.7/pyrex/qutip/cy/openmp/parfuncs.cpp:614:10: fatal error: src/zspmv_openmp.hpp: No such file or directory; #include ""src/zspmv_openmp.hpp""; ^~~~~~~~~~~~~~~~~~~~~~; compilation terminated.; ```; The codes however run fine. Here's the output from my qutip.about(). ```; >>> qutip.about(). QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.0.dev0+564c987b; Numpy Version: 1.16.4; Scipy Version: 1.2.1; Cython Version: 0.29.13; Matplotlib Version: 3.1.0; Python Version: 3.7.3; Number of CPUs: 2; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Linux (x86_64); Installation path: /home/tarun/riken-work/qutip/qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`. ```; @nathanshammah ran this on his Mac, and had the following results. The file runs fine on his Mac with . - (1) conda release 4.4.1; - (2) development version 4.5.0.dev0+f77f7e4a (previous to Eric's PR merge); - (3) updating the current development version 4.5.0.dev0+564c987b (with python setup.py develop). The file throws an error when:; - (4) updating the current development version 4.5.0.d",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1109
https://github.com/qutip/qutip/issues/1109:343,Availability,error,error,343,"Since merging PR #1082 , I've been getting this strange error whenever I import QuTiP:; ```; (qutip-env) tarun@trolldem0rt:~/riken-work$ python fidel.py ; cc1plus: warning: command line option ‘-Wstrict-prototypes’ is valid for C/ObjC but not for C++; /home/tarun/.pyxbld/temp.linux-x86_64-3.7/pyrex/qutip/cy/openmp/parfuncs.cpp:614:10: fatal error: src/zspmv_openmp.hpp: No such file or directory; #include ""src/zspmv_openmp.hpp""; ^~~~~~~~~~~~~~~~~~~~~~; compilation terminated.; ```; The codes however run fine. Here's the output from my qutip.about(). ```; >>> qutip.about(). QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.0.dev0+564c987b; Numpy Version: 1.16.4; Scipy Version: 1.2.1; Cython Version: 0.29.13; Matplotlib Version: 3.1.0; Python Version: 3.7.3; Number of CPUs: 2; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Linux (x86_64); Installation path: /home/tarun/riken-work/qutip/qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`. ```; @nathanshammah ran this on his Mac, and had the following results. The file runs fine on his Mac with . - (1) conda release 4.4.1; - (2) development version 4.5.0.dev0+f77f7e4a (previous to Eric's PR merge); - (3) updating the current development version 4.5.0.dev0+564c987b (with python setup.py develop). The file throws an error when:; - (4) updating the current development version 4.5.0.d",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1109
https://github.com/qutip/qutip/issues/1109:1934,Availability,error,error,1934," Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.0.dev0+564c987b; Numpy Version: 1.16.4; Scipy Version: 1.2.1; Cython Version: 0.29.13; Matplotlib Version: 3.1.0; Python Version: 3.7.3; Number of CPUs: 2; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Linux (x86_64); Installation path: /home/tarun/riken-work/qutip/qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`. ```; @nathanshammah ran this on his Mac, and had the following results. The file runs fine on his Mac with . - (1) conda release 4.4.1; - (2) development version 4.5.0.dev0+f77f7e4a (previous to Eric's PR merge); - (3) updating the current development version 4.5.0.dev0+564c987b (with python setup.py develop). The file throws an error when:; - (4) updating the current development version 4.5.0.dev0+564c987b (with python setup.py install). Error message (then the code runs anyway):; ```; (qutipdev45) nathans-mbp:Downloads nathanshammah$ python fidel.py; /Users/nathanshammah/.pyxbld/temp.macosx-10.9-x86_64-3.7/pyrex/qutip/cy/openmp/parfuncs.cpp:614:10: fatal error:; 'src/zspmv_openmp.hpp' file not found; #include ""src/zspmv_openmp.hpp""; ^~~~~~~~~~~~~~~~~~~~~~; 1 error generated.; ```. His qutip.about(): . ```; QuTiP Version: 4.5.0.dev0+f77f7e4a (or others); Numpy Version: 1.17.2; Scipy Version: 1.3.1; Cython Version: 0.29.13; Matplotlib Version: 3.1.1; Python Version: 3.7.4; Number of CPUs: 2; BLAS Info: INTEL MKL; OPENMP Installed: True; INTEL MKL Ext: True; Platform Info: Darwin (x86_64); ```. Notice that in his case OPEN MP seems installed.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1109
https://github.com/qutip/qutip/issues/1109:2046,Availability,Error,Error,2046," Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.0.dev0+564c987b; Numpy Version: 1.16.4; Scipy Version: 1.2.1; Cython Version: 0.29.13; Matplotlib Version: 3.1.0; Python Version: 3.7.3; Number of CPUs: 2; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Linux (x86_64); Installation path: /home/tarun/riken-work/qutip/qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`. ```; @nathanshammah ran this on his Mac, and had the following results. The file runs fine on his Mac with . - (1) conda release 4.4.1; - (2) development version 4.5.0.dev0+f77f7e4a (previous to Eric's PR merge); - (3) updating the current development version 4.5.0.dev0+564c987b (with python setup.py develop). The file throws an error when:; - (4) updating the current development version 4.5.0.dev0+564c987b (with python setup.py install). Error message (then the code runs anyway):; ```; (qutipdev45) nathans-mbp:Downloads nathanshammah$ python fidel.py; /Users/nathanshammah/.pyxbld/temp.macosx-10.9-x86_64-3.7/pyrex/qutip/cy/openmp/parfuncs.cpp:614:10: fatal error:; 'src/zspmv_openmp.hpp' file not found; #include ""src/zspmv_openmp.hpp""; ^~~~~~~~~~~~~~~~~~~~~~; 1 error generated.; ```. His qutip.about(): . ```; QuTiP Version: 4.5.0.dev0+f77f7e4a (or others); Numpy Version: 1.17.2; Scipy Version: 1.3.1; Cython Version: 0.29.13; Matplotlib Version: 3.1.1; Python Version: 3.7.4; Number of CPUs: 2; BLAS Info: INTEL MKL; OPENMP Installed: True; INTEL MKL Ext: True; Platform Info: Darwin (x86_64); ```. Notice that in his case OPEN MP seems installed.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1109
https://github.com/qutip/qutip/issues/1109:2120,Availability,Down,Downloads,2120," Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.0.dev0+564c987b; Numpy Version: 1.16.4; Scipy Version: 1.2.1; Cython Version: 0.29.13; Matplotlib Version: 3.1.0; Python Version: 3.7.3; Number of CPUs: 2; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Linux (x86_64); Installation path: /home/tarun/riken-work/qutip/qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`. ```; @nathanshammah ran this on his Mac, and had the following results. The file runs fine on his Mac with . - (1) conda release 4.4.1; - (2) development version 4.5.0.dev0+f77f7e4a (previous to Eric's PR merge); - (3) updating the current development version 4.5.0.dev0+564c987b (with python setup.py develop). The file throws an error when:; - (4) updating the current development version 4.5.0.dev0+564c987b (with python setup.py install). Error message (then the code runs anyway):; ```; (qutipdev45) nathans-mbp:Downloads nathanshammah$ python fidel.py; /Users/nathanshammah/.pyxbld/temp.macosx-10.9-x86_64-3.7/pyrex/qutip/cy/openmp/parfuncs.cpp:614:10: fatal error:; 'src/zspmv_openmp.hpp' file not found; #include ""src/zspmv_openmp.hpp""; ^~~~~~~~~~~~~~~~~~~~~~; 1 error generated.; ```. His qutip.about(): . ```; QuTiP Version: 4.5.0.dev0+f77f7e4a (or others); Numpy Version: 1.17.2; Scipy Version: 1.3.1; Cython Version: 0.29.13; Matplotlib Version: 3.1.1; Python Version: 3.7.4; Number of CPUs: 2; BLAS Info: INTEL MKL; OPENMP Installed: True; INTEL MKL Ext: True; Platform Info: Darwin (x86_64); ```. Notice that in his case OPEN MP seems installed.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1109
https://github.com/qutip/qutip/issues/1109:2268,Availability,error,error,2268," Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.0.dev0+564c987b; Numpy Version: 1.16.4; Scipy Version: 1.2.1; Cython Version: 0.29.13; Matplotlib Version: 3.1.0; Python Version: 3.7.3; Number of CPUs: 2; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Linux (x86_64); Installation path: /home/tarun/riken-work/qutip/qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`. ```; @nathanshammah ran this on his Mac, and had the following results. The file runs fine on his Mac with . - (1) conda release 4.4.1; - (2) development version 4.5.0.dev0+f77f7e4a (previous to Eric's PR merge); - (3) updating the current development version 4.5.0.dev0+564c987b (with python setup.py develop). The file throws an error when:; - (4) updating the current development version 4.5.0.dev0+564c987b (with python setup.py install). Error message (then the code runs anyway):; ```; (qutipdev45) nathans-mbp:Downloads nathanshammah$ python fidel.py; /Users/nathanshammah/.pyxbld/temp.macosx-10.9-x86_64-3.7/pyrex/qutip/cy/openmp/parfuncs.cpp:614:10: fatal error:; 'src/zspmv_openmp.hpp' file not found; #include ""src/zspmv_openmp.hpp""; ^~~~~~~~~~~~~~~~~~~~~~; 1 error generated.; ```. His qutip.about(): . ```; QuTiP Version: 4.5.0.dev0+f77f7e4a (or others); Numpy Version: 1.17.2; Scipy Version: 1.3.1; Cython Version: 0.29.13; Matplotlib Version: 3.1.1; Python Version: 3.7.4; Number of CPUs: 2; BLAS Info: INTEL MKL; OPENMP Installed: True; INTEL MKL Ext: True; Platform Info: Darwin (x86_64); ```. Notice that in his case OPEN MP seems installed.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1109
https://github.com/qutip/qutip/issues/1109:2374,Availability,error,error,2374," Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.0.dev0+564c987b; Numpy Version: 1.16.4; Scipy Version: 1.2.1; Cython Version: 0.29.13; Matplotlib Version: 3.1.0; Python Version: 3.7.3; Number of CPUs: 2; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Linux (x86_64); Installation path: /home/tarun/riken-work/qutip/qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`. ```; @nathanshammah ran this on his Mac, and had the following results. The file runs fine on his Mac with . - (1) conda release 4.4.1; - (2) development version 4.5.0.dev0+f77f7e4a (previous to Eric's PR merge); - (3) updating the current development version 4.5.0.dev0+564c987b (with python setup.py develop). The file throws an error when:; - (4) updating the current development version 4.5.0.dev0+564c987b (with python setup.py install). Error message (then the code runs anyway):; ```; (qutipdev45) nathans-mbp:Downloads nathanshammah$ python fidel.py; /Users/nathanshammah/.pyxbld/temp.macosx-10.9-x86_64-3.7/pyrex/qutip/cy/openmp/parfuncs.cpp:614:10: fatal error:; 'src/zspmv_openmp.hpp' file not found; #include ""src/zspmv_openmp.hpp""; ^~~~~~~~~~~~~~~~~~~~~~; 1 error generated.; ```. His qutip.about(): . ```; QuTiP Version: 4.5.0.dev0+f77f7e4a (or others); Numpy Version: 1.17.2; Scipy Version: 1.3.1; Cython Version: 0.29.13; Matplotlib Version: 3.1.1; Python Version: 3.7.4; Number of CPUs: 2; BLAS Info: INTEL MKL; OPENMP Installed: True; INTEL MKL Ext: True; Platform Info: Darwin (x86_64); ```. Notice that in his case OPEN MP seems installed.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1109
https://github.com/qutip/qutip/issues/1109:1192,Deployability,Install,Installed,1192,"4-3.7/pyrex/qutip/cy/openmp/parfuncs.cpp:614:10: fatal error: src/zspmv_openmp.hpp: No such file or directory; #include ""src/zspmv_openmp.hpp""; ^~~~~~~~~~~~~~~~~~~~~~; compilation terminated.; ```; The codes however run fine. Here's the output from my qutip.about(). ```; >>> qutip.about(). QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.0.dev0+564c987b; Numpy Version: 1.16.4; Scipy Version: 1.2.1; Cython Version: 0.29.13; Matplotlib Version: 3.1.0; Python Version: 3.7.3; Number of CPUs: 2; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Linux (x86_64); Installation path: /home/tarun/riken-work/qutip/qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`. ```; @nathanshammah ran this on his Mac, and had the following results. The file runs fine on his Mac with . - (1) conda release 4.4.1; - (2) development version 4.5.0.dev0+f77f7e4a (previous to Eric's PR merge); - (3) updating the current development version 4.5.0.dev0+564c987b (with python setup.py develop). The file throws an error when:; - (4) updating the current development version 4.5.0.dev0+564c987b (with python setup.py install). Error message (then the code runs anyway):; ```; (qutipdev45) nathans-mbp:Downloads nathanshammah$ python fidel.py; /Users/nathanshammah/.pyxbld/temp.macosx-10.9-x86_64-3.7/pyrex/qutip/cy/openmp/parfuncs.cpp:614:10: fatal error:; 'src/zspmv_o",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1109
https://github.com/qutip/qutip/issues/1109:1262,Deployability,Install,Installation,1262,"4-3.7/pyrex/qutip/cy/openmp/parfuncs.cpp:614:10: fatal error: src/zspmv_openmp.hpp: No such file or directory; #include ""src/zspmv_openmp.hpp""; ^~~~~~~~~~~~~~~~~~~~~~; compilation terminated.; ```; The codes however run fine. Here's the output from my qutip.about(). ```; >>> qutip.about(). QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.0.dev0+564c987b; Numpy Version: 1.16.4; Scipy Version: 1.2.1; Cython Version: 0.29.13; Matplotlib Version: 3.1.0; Python Version: 3.7.3; Number of CPUs: 2; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Linux (x86_64); Installation path: /home/tarun/riken-work/qutip/qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`. ```; @nathanshammah ran this on his Mac, and had the following results. The file runs fine on his Mac with . - (1) conda release 4.4.1; - (2) development version 4.5.0.dev0+f77f7e4a (previous to Eric's PR merge); - (3) updating the current development version 4.5.0.dev0+564c987b (with python setup.py develop). The file throws an error when:; - (4) updating the current development version 4.5.0.dev0+564c987b (with python setup.py install). Error message (then the code runs anyway):; ```; (qutipdev45) nathans-mbp:Downloads nathanshammah$ python fidel.py; /Users/nathanshammah/.pyxbld/temp.macosx-10.9-x86_64-3.7/pyrex/qutip/cy/openmp/parfuncs.cpp:614:10: fatal error:; 'src/zspmv_o",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1109
https://github.com/qutip/qutip/issues/1109:1724,Deployability,release,release,1724,"son & P. D. Nation.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.0.dev0+564c987b; Numpy Version: 1.16.4; Scipy Version: 1.2.1; Cython Version: 0.29.13; Matplotlib Version: 3.1.0; Python Version: 3.7.3; Number of CPUs: 2; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Linux (x86_64); Installation path: /home/tarun/riken-work/qutip/qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`. ```; @nathanshammah ran this on his Mac, and had the following results. The file runs fine on his Mac with . - (1) conda release 4.4.1; - (2) development version 4.5.0.dev0+f77f7e4a (previous to Eric's PR merge); - (3) updating the current development version 4.5.0.dev0+564c987b (with python setup.py develop). The file throws an error when:; - (4) updating the current development version 4.5.0.dev0+564c987b (with python setup.py install). Error message (then the code runs anyway):; ```; (qutipdev45) nathans-mbp:Downloads nathanshammah$ python fidel.py; /Users/nathanshammah/.pyxbld/temp.macosx-10.9-x86_64-3.7/pyrex/qutip/cy/openmp/parfuncs.cpp:614:10: fatal error:; 'src/zspmv_openmp.hpp' file not found; #include ""src/zspmv_openmp.hpp""; ^~~~~~~~~~~~~~~~~~~~~~; 1 error generated.; ```. His qutip.about(): . ```; QuTiP Version: 4.5.0.dev0+f77f7e4a (or others); Numpy Version: 1.17.2; Scipy Version: 1.3.1; Cython Version: 0.29.13; Matplotlib Version: 3.1.1; Python Version: 3.7.4; Number of CPUs: 2; BLAS Info: INTEL MKL; OPENMP Installed: True; INTEL MKL Ext: True; Platform Info: Darwin (x86_64); ```. Notice th",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1109
https://github.com/qutip/qutip/issues/1109:2036,Deployability,install,install,2036," Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.0.dev0+564c987b; Numpy Version: 1.16.4; Scipy Version: 1.2.1; Cython Version: 0.29.13; Matplotlib Version: 3.1.0; Python Version: 3.7.3; Number of CPUs: 2; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Linux (x86_64); Installation path: /home/tarun/riken-work/qutip/qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`. ```; @nathanshammah ran this on his Mac, and had the following results. The file runs fine on his Mac with . - (1) conda release 4.4.1; - (2) development version 4.5.0.dev0+f77f7e4a (previous to Eric's PR merge); - (3) updating the current development version 4.5.0.dev0+564c987b (with python setup.py develop). The file throws an error when:; - (4) updating the current development version 4.5.0.dev0+564c987b (with python setup.py install). Error message (then the code runs anyway):; ```; (qutipdev45) nathans-mbp:Downloads nathanshammah$ python fidel.py; /Users/nathanshammah/.pyxbld/temp.macosx-10.9-x86_64-3.7/pyrex/qutip/cy/openmp/parfuncs.cpp:614:10: fatal error:; 'src/zspmv_openmp.hpp' file not found; #include ""src/zspmv_openmp.hpp""; ^~~~~~~~~~~~~~~~~~~~~~; 1 error generated.; ```. His qutip.about(): . ```; QuTiP Version: 4.5.0.dev0+f77f7e4a (or others); Numpy Version: 1.17.2; Scipy Version: 1.3.1; Cython Version: 0.29.13; Matplotlib Version: 3.1.1; Python Version: 3.7.4; Number of CPUs: 2; BLAS Info: INTEL MKL; OPENMP Installed: True; INTEL MKL Ext: True; Platform Info: Darwin (x86_64); ```. Notice that in his case OPEN MP seems installed.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1109
https://github.com/qutip/qutip/issues/1109:2639,Deployability,Install,Installed,2639," Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.0.dev0+564c987b; Numpy Version: 1.16.4; Scipy Version: 1.2.1; Cython Version: 0.29.13; Matplotlib Version: 3.1.0; Python Version: 3.7.3; Number of CPUs: 2; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Linux (x86_64); Installation path: /home/tarun/riken-work/qutip/qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`. ```; @nathanshammah ran this on his Mac, and had the following results. The file runs fine on his Mac with . - (1) conda release 4.4.1; - (2) development version 4.5.0.dev0+f77f7e4a (previous to Eric's PR merge); - (3) updating the current development version 4.5.0.dev0+564c987b (with python setup.py develop). The file throws an error when:; - (4) updating the current development version 4.5.0.dev0+564c987b (with python setup.py install). Error message (then the code runs anyway):; ```; (qutipdev45) nathans-mbp:Downloads nathanshammah$ python fidel.py; /Users/nathanshammah/.pyxbld/temp.macosx-10.9-x86_64-3.7/pyrex/qutip/cy/openmp/parfuncs.cpp:614:10: fatal error:; 'src/zspmv_openmp.hpp' file not found; #include ""src/zspmv_openmp.hpp""; ^~~~~~~~~~~~~~~~~~~~~~; 1 error generated.; ```. His qutip.about(): . ```; QuTiP Version: 4.5.0.dev0+f77f7e4a (or others); Numpy Version: 1.17.2; Scipy Version: 1.3.1; Cython Version: 0.29.13; Matplotlib Version: 3.1.1; Python Version: 3.7.4; Number of CPUs: 2; BLAS Info: INTEL MKL; OPENMP Installed: True; INTEL MKL Ext: True; Platform Info: Darwin (x86_64); ```. Notice that in his case OPEN MP seems installed.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1109
https://github.com/qutip/qutip/issues/1109:2752,Deployability,install,installed,2752," Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.0.dev0+564c987b; Numpy Version: 1.16.4; Scipy Version: 1.2.1; Cython Version: 0.29.13; Matplotlib Version: 3.1.0; Python Version: 3.7.3; Number of CPUs: 2; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Linux (x86_64); Installation path: /home/tarun/riken-work/qutip/qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`. ```; @nathanshammah ran this on his Mac, and had the following results. The file runs fine on his Mac with . - (1) conda release 4.4.1; - (2) development version 4.5.0.dev0+f77f7e4a (previous to Eric's PR merge); - (3) updating the current development version 4.5.0.dev0+564c987b (with python setup.py develop). The file throws an error when:; - (4) updating the current development version 4.5.0.dev0+564c987b (with python setup.py install). Error message (then the code runs anyway):; ```; (qutipdev45) nathans-mbp:Downloads nathanshammah$ python fidel.py; /Users/nathanshammah/.pyxbld/temp.macosx-10.9-x86_64-3.7/pyrex/qutip/cy/openmp/parfuncs.cpp:614:10: fatal error:; 'src/zspmv_openmp.hpp' file not found; #include ""src/zspmv_openmp.hpp""; ^~~~~~~~~~~~~~~~~~~~~~; 1 error generated.; ```. His qutip.about(): . ```; QuTiP Version: 4.5.0.dev0+f77f7e4a (or others); Numpy Version: 1.17.2; Scipy Version: 1.3.1; Cython Version: 0.29.13; Matplotlib Version: 3.1.1; Python Version: 3.7.4; Number of CPUs: 2; BLAS Info: INTEL MKL; OPENMP Installed: True; INTEL MKL Ext: True; Platform Info: Darwin (x86_64); ```. Notice that in his case OPEN MP seems installed.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1109
https://github.com/qutip/qutip/issues/1109:2052,Integrability,message,message,2052," Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.0.dev0+564c987b; Numpy Version: 1.16.4; Scipy Version: 1.2.1; Cython Version: 0.29.13; Matplotlib Version: 3.1.0; Python Version: 3.7.3; Number of CPUs: 2; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Linux (x86_64); Installation path: /home/tarun/riken-work/qutip/qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`. ```; @nathanshammah ran this on his Mac, and had the following results. The file runs fine on his Mac with . - (1) conda release 4.4.1; - (2) development version 4.5.0.dev0+f77f7e4a (previous to Eric's PR merge); - (3) updating the current development version 4.5.0.dev0+564c987b (with python setup.py develop). The file throws an error when:; - (4) updating the current development version 4.5.0.dev0+564c987b (with python setup.py install). Error message (then the code runs anyway):; ```; (qutipdev45) nathans-mbp:Downloads nathanshammah$ python fidel.py; /Users/nathanshammah/.pyxbld/temp.macosx-10.9-x86_64-3.7/pyrex/qutip/cy/openmp/parfuncs.cpp:614:10: fatal error:; 'src/zspmv_openmp.hpp' file not found; #include ""src/zspmv_openmp.hpp""; ^~~~~~~~~~~~~~~~~~~~~~; 1 error generated.; ```. His qutip.about(): . ```; QuTiP Version: 4.5.0.dev0+f77f7e4a (or others); Numpy Version: 1.17.2; Scipy Version: 1.3.1; Cython Version: 0.29.13; Matplotlib Version: 3.1.1; Python Version: 3.7.4; Number of CPUs: 2; BLAS Info: INTEL MKL; OPENMP Installed: True; INTEL MKL Ext: True; Platform Info: Darwin (x86_64); ```. Notice that in his case OPEN MP seems installed.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1109
https://github.com/qutip/qutip/pull/1110:11,Availability,error,error,11,Remove the error showing in #1109,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1110
https://github.com/qutip/qutip/issues/1111:2058,Availability,error,error,2058,"port optimize; from scipy.optimize import minimize_scalar; import random ; ket0=basis(2,0); ket1=basis(2,1); ket00=tensor(ket0,ket0);ket01=tensor(ket0,ket1);ket10=tensor(ket1,ket0);ket11=tensor(ket1,ket1);; angle = np.linspace(0.0, 2 * np.pi, 100); def B1(x):; b1=(cos(x[0]/2)**2+ x[3]**2*sin(x[0]/2)**2)*ket0*ket0.dag()+(1j*(x[1]-1j*x[2])*sin(x[0]/2)*(cos(x[0]/2)-1j*x[3]*sin(x[0]/2)))*ket0*ket1.dag(); -(1j*(x[1]+1j*x[2])*sin(x[0]/2)*(cos(x[0]/2)+1j*x[3]*sin(x[0]/2)))*ket1*ket0.dag()+((x[1]**2+ x[2]**2)*sin(x[0]/2)**2)*ket1*ket1.dag(); return b1. def B2(x):; b2=(cos(x[0]/2)**2+ x[3]**2*sin(x[0]/2)**2)*ket1*ket1.dag()-(1j*(x[1]-1j*x[2])*sin(x[0]/2)*(cos(x[0]/2)-1j*x[3]*sin(x[0]/2)))*ket0*ket1.dag(); +(1j*(x[1]+1j*x[2])*sin(x[0]/2)*(cos(x[0]/2)+1j*x[3]*sin(x[0]/2)))*ket1*ket0.dag()+((x[1]**2+ x[2]**2)*sin(x[0]/2)**2)*ket0*ket0.dag(); return b2. rho=0.25*ket00*ket00.dag()+0.25*ket00*ket11.dag()+0.25*ket01*ket01.dag()+0.25*ket01*ket10.dag()+0.25*ket10*ket01.dag()+0.25*ket10*ket10.dag()+0.25*ket11*ket00.dag()+0.25*ket11*ket11.dag(). def P1(x):; p1=1/(tensor(qeye(2),B1(x))).tr()*tensor(qeye(2),B1(x))*rho*tensor(qeye(2),B1(x)); return p1. def P2(x):; p2=1/(tensor(qeye(2),B2(x))).tr()*tensor(qeye(2),B2(x))*rho*tensor(qeye(2),B2(x)); return p2. def S(x):; p1=1/(tensor(qeye(2),B1(x))).tr()*tensor(qeye(2),B1(x))*rho*tensor(qeye(2),B1(x)); p2=1/(tensor(qeye(2),B2(x))).tr()*tensor(qeye(2),B2(x))*rho*tensor(qeye(2),B2(x)); s=1/(tensor(qeye(2),B1(x))).tr()*entropy_vn(p1)+1/(tensor(qeye(2),B2(x))).tr()*entropy_vn(p2); return s; list3=[];list4=[];list5=[];. for i in range(100):; t=uniform(0,1); y=uniform(0,1); z=uniform(0,1); if t**2+y**2+z**2==1:; continue; list3.append(t); list4.append(y); list5.append(z); #print(t,y,z); for x in zip(angle,list3,list4,list5):; x0=[0,0,0,0]; res = minimize(S,x0, method='Nelder-Mead',options={'xtol': 1e-8, 'disp': True}); print(res.x); ```; In this program error coming for minimize entropy; ""TypeError: can't convert complex to float""; can you help me?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1111
https://github.com/qutip/qutip/issues/1111:123,Performance,optimiz,optimize,123,"```python; from qutip import *; import numpy as np; from numpy import*; from math import*; from random import*; from scipy.optimize import*; from scipy import optimize; from scipy.optimize import minimize_scalar; import random ; ket0=basis(2,0); ket1=basis(2,1); ket00=tensor(ket0,ket0);ket01=tensor(ket0,ket1);ket10=tensor(ket1,ket0);ket11=tensor(ket1,ket1);; angle = np.linspace(0.0, 2 * np.pi, 100); def B1(x):; b1=(cos(x[0]/2)**2+ x[3]**2*sin(x[0]/2)**2)*ket0*ket0.dag()+(1j*(x[1]-1j*x[2])*sin(x[0]/2)*(cos(x[0]/2)-1j*x[3]*sin(x[0]/2)))*ket0*ket1.dag(); -(1j*(x[1]+1j*x[2])*sin(x[0]/2)*(cos(x[0]/2)+1j*x[3]*sin(x[0]/2)))*ket1*ket0.dag()+((x[1]**2+ x[2]**2)*sin(x[0]/2)**2)*ket1*ket1.dag(); return b1. def B2(x):; b2=(cos(x[0]/2)**2+ x[3]**2*sin(x[0]/2)**2)*ket1*ket1.dag()-(1j*(x[1]-1j*x[2])*sin(x[0]/2)*(cos(x[0]/2)-1j*x[3]*sin(x[0]/2)))*ket0*ket1.dag(); +(1j*(x[1]+1j*x[2])*sin(x[0]/2)*(cos(x[0]/2)+1j*x[3]*sin(x[0]/2)))*ket1*ket0.dag()+((x[1]**2+ x[2]**2)*sin(x[0]/2)**2)*ket0*ket0.dag(); return b2. rho=0.25*ket00*ket00.dag()+0.25*ket00*ket11.dag()+0.25*ket01*ket01.dag()+0.25*ket01*ket10.dag()+0.25*ket10*ket01.dag()+0.25*ket10*ket10.dag()+0.25*ket11*ket00.dag()+0.25*ket11*ket11.dag(). def P1(x):; p1=1/(tensor(qeye(2),B1(x))).tr()*tensor(qeye(2),B1(x))*rho*tensor(qeye(2),B1(x)); return p1. def P2(x):; p2=1/(tensor(qeye(2),B2(x))).tr()*tensor(qeye(2),B2(x))*rho*tensor(qeye(2),B2(x)); return p2. def S(x):; p1=1/(tensor(qeye(2),B1(x))).tr()*tensor(qeye(2),B1(x))*rho*tensor(qeye(2),B1(x)); p2=1/(tensor(qeye(2),B2(x))).tr()*tensor(qeye(2),B2(x))*rho*tensor(qeye(2),B2(x)); s=1/(tensor(qeye(2),B1(x))).tr()*entropy_vn(p1)+1/(tensor(qeye(2),B2(x))).tr()*entropy_vn(p2); return s; list3=[];list4=[];list5=[];. for i in range(100):; t=uniform(0,1); y=uniform(0,1); z=uniform(0,1); if t**2+y**2+z**2==1:; continue; list3.append(t); list4.append(y); list5.append(z); #print(t,y,z); for x in zip(angle,list3,list4,list5):; x0=[0,0,0,0]; res = minimize(S,x0, method='Nelder-Mead',options={'xtol': ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1111
https://github.com/qutip/qutip/issues/1111:159,Performance,optimiz,optimize,159,"```python; from qutip import *; import numpy as np; from numpy import*; from math import*; from random import*; from scipy.optimize import*; from scipy import optimize; from scipy.optimize import minimize_scalar; import random ; ket0=basis(2,0); ket1=basis(2,1); ket00=tensor(ket0,ket0);ket01=tensor(ket0,ket1);ket10=tensor(ket1,ket0);ket11=tensor(ket1,ket1);; angle = np.linspace(0.0, 2 * np.pi, 100); def B1(x):; b1=(cos(x[0]/2)**2+ x[3]**2*sin(x[0]/2)**2)*ket0*ket0.dag()+(1j*(x[1]-1j*x[2])*sin(x[0]/2)*(cos(x[0]/2)-1j*x[3]*sin(x[0]/2)))*ket0*ket1.dag(); -(1j*(x[1]+1j*x[2])*sin(x[0]/2)*(cos(x[0]/2)+1j*x[3]*sin(x[0]/2)))*ket1*ket0.dag()+((x[1]**2+ x[2]**2)*sin(x[0]/2)**2)*ket1*ket1.dag(); return b1. def B2(x):; b2=(cos(x[0]/2)**2+ x[3]**2*sin(x[0]/2)**2)*ket1*ket1.dag()-(1j*(x[1]-1j*x[2])*sin(x[0]/2)*(cos(x[0]/2)-1j*x[3]*sin(x[0]/2)))*ket0*ket1.dag(); +(1j*(x[1]+1j*x[2])*sin(x[0]/2)*(cos(x[0]/2)+1j*x[3]*sin(x[0]/2)))*ket1*ket0.dag()+((x[1]**2+ x[2]**2)*sin(x[0]/2)**2)*ket0*ket0.dag(); return b2. rho=0.25*ket00*ket00.dag()+0.25*ket00*ket11.dag()+0.25*ket01*ket01.dag()+0.25*ket01*ket10.dag()+0.25*ket10*ket01.dag()+0.25*ket10*ket10.dag()+0.25*ket11*ket00.dag()+0.25*ket11*ket11.dag(). def P1(x):; p1=1/(tensor(qeye(2),B1(x))).tr()*tensor(qeye(2),B1(x))*rho*tensor(qeye(2),B1(x)); return p1. def P2(x):; p2=1/(tensor(qeye(2),B2(x))).tr()*tensor(qeye(2),B2(x))*rho*tensor(qeye(2),B2(x)); return p2. def S(x):; p1=1/(tensor(qeye(2),B1(x))).tr()*tensor(qeye(2),B1(x))*rho*tensor(qeye(2),B1(x)); p2=1/(tensor(qeye(2),B2(x))).tr()*tensor(qeye(2),B2(x))*rho*tensor(qeye(2),B2(x)); s=1/(tensor(qeye(2),B1(x))).tr()*entropy_vn(p1)+1/(tensor(qeye(2),B2(x))).tr()*entropy_vn(p2); return s; list3=[];list4=[];list5=[];. for i in range(100):; t=uniform(0,1); y=uniform(0,1); z=uniform(0,1); if t**2+y**2+z**2==1:; continue; list3.append(t); list4.append(y); list5.append(z); #print(t,y,z); for x in zip(angle,list3,list4,list5):; x0=[0,0,0,0]; res = minimize(S,x0, method='Nelder-Mead',options={'xtol': ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1111
https://github.com/qutip/qutip/issues/1111:180,Performance,optimiz,optimize,180,"```python; from qutip import *; import numpy as np; from numpy import*; from math import*; from random import*; from scipy.optimize import*; from scipy import optimize; from scipy.optimize import minimize_scalar; import random ; ket0=basis(2,0); ket1=basis(2,1); ket00=tensor(ket0,ket0);ket01=tensor(ket0,ket1);ket10=tensor(ket1,ket0);ket11=tensor(ket1,ket1);; angle = np.linspace(0.0, 2 * np.pi, 100); def B1(x):; b1=(cos(x[0]/2)**2+ x[3]**2*sin(x[0]/2)**2)*ket0*ket0.dag()+(1j*(x[1]-1j*x[2])*sin(x[0]/2)*(cos(x[0]/2)-1j*x[3]*sin(x[0]/2)))*ket0*ket1.dag(); -(1j*(x[1]+1j*x[2])*sin(x[0]/2)*(cos(x[0]/2)+1j*x[3]*sin(x[0]/2)))*ket1*ket0.dag()+((x[1]**2+ x[2]**2)*sin(x[0]/2)**2)*ket1*ket1.dag(); return b1. def B2(x):; b2=(cos(x[0]/2)**2+ x[3]**2*sin(x[0]/2)**2)*ket1*ket1.dag()-(1j*(x[1]-1j*x[2])*sin(x[0]/2)*(cos(x[0]/2)-1j*x[3]*sin(x[0]/2)))*ket0*ket1.dag(); +(1j*(x[1]+1j*x[2])*sin(x[0]/2)*(cos(x[0]/2)+1j*x[3]*sin(x[0]/2)))*ket1*ket0.dag()+((x[1]**2+ x[2]**2)*sin(x[0]/2)**2)*ket0*ket0.dag(); return b2. rho=0.25*ket00*ket00.dag()+0.25*ket00*ket11.dag()+0.25*ket01*ket01.dag()+0.25*ket01*ket10.dag()+0.25*ket10*ket01.dag()+0.25*ket10*ket10.dag()+0.25*ket11*ket00.dag()+0.25*ket11*ket11.dag(). def P1(x):; p1=1/(tensor(qeye(2),B1(x))).tr()*tensor(qeye(2),B1(x))*rho*tensor(qeye(2),B1(x)); return p1. def P2(x):; p2=1/(tensor(qeye(2),B2(x))).tr()*tensor(qeye(2),B2(x))*rho*tensor(qeye(2),B2(x)); return p2. def S(x):; p1=1/(tensor(qeye(2),B1(x))).tr()*tensor(qeye(2),B1(x))*rho*tensor(qeye(2),B1(x)); p2=1/(tensor(qeye(2),B2(x))).tr()*tensor(qeye(2),B2(x))*rho*tensor(qeye(2),B2(x)); s=1/(tensor(qeye(2),B1(x))).tr()*entropy_vn(p1)+1/(tensor(qeye(2),B2(x))).tr()*entropy_vn(p2); return s; list3=[];list4=[];list5=[];. for i in range(100):; t=uniform(0,1); y=uniform(0,1); z=uniform(0,1); if t**2+y**2+z**2==1:; continue; list3.append(t); list4.append(y); list5.append(z); #print(t,y,z); for x in zip(angle,list3,list4,list5):; x0=[0,0,0,0]; res = minimize(S,x0, method='Nelder-Mead',options={'xtol': ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1111
https://github.com/qutip/qutip/issues/1112:468,Deployability,patch,patch,468,"The default scaling factor of \sqrt(2) used by wigner() and plot_wigner() is confusing. ```; alpha = 3; psi = coherent(N,alpha); plot_wigner(psi); ```. produced a plot with coherent state that is NOT centered at alpha = 3 (mega confusing). Does anyone know where this default scaling of $\sqrt{2}$ comes from? . In particular, I would suggest that the default be changed to g = 1 to make the above code segment not internally self-inconsisitent. I can easily submit a patch if needed",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1112
https://github.com/qutip/qutip/pull/1113:367,Deployability,update,updated,367,"2 improvement to Qobj:; - `inv` method. (close #1102); - faster `ptrace` using dense matrix (taken from #1076); Both dense and sparse method are kept. Default is use sparse method when the matrix density in under 10%. `inv` method also has a sparse and dense version, but sparse is almost always slower. Some improvement to random Qobj to remove edge case. Tests are updated. (Not merge ready yet.)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1113
https://github.com/qutip/qutip/pull/1113:357,Testability,Test,Tests,357,"2 improvement to Qobj:; - `inv` method. (close #1102); - faster `ptrace` using dense matrix (taken from #1076); Both dense and sparse method are kept. Default is use sparse method when the matrix density in under 10%. `inv` method also has a sparse and dense version, but sparse is almost always slower. Some improvement to random Qobj to remove edge case. Tests are updated. (Not merge ready yet.)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1113
https://github.com/qutip/qutip/issues/1114:95,Energy Efficiency,power,power,95,"Say I have the operator `b = tensor(destroy(3), qeye(3))`. When I want to calculate the fourth power of `(b + b.dag())` I have several possibilities to do that, but they give different answers.; Let's define:; `B1 = (b + b.dag())**4`;; `B2 = (b + b.dag()) * (b + b.dag()) * (b + b.dag()) * (b + b.dag())`, and; `B3 = b*b*b*b`; `B3 += b.dag()*b*b*b + b*b.dag()*b*b + b*b*b.dag()*b + b*b*b*b.dag()`; `B3 += b.dag()*b.dag()*b*b + b.dag()*b*b.dag()*b + b.dag()*b*b*b.dag()`; `B3 += b*b.dag()*b.dag()*b + b*b.dag()*b*b.dag() + b*b*b.dag()*b.dag()`; `B3 += b.dag()*b.dag()*b.dag()*b + b.dag()*b.dag()*b*b.dag() + b.dag()*b*b.dag()*b.dag() + b*b.dag()*b.dag()*b.dag()`; `B3 += b.dag()+b.dag()+b.dag()+b.dag()`. B1 and B2 give the same output, but that is different from B3. How can this possibly be? And which one should I trust?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1114
https://github.com/qutip/qutip/pull/1115:77,Availability,error,error,77,When using the `average_states` solver option `general_stochastic` seemed to error when summing the timeslot states. This PR provides a fix for this. Also included is some hopefully more succinct messages from the safety checks in `general_stochastic`.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1115
https://github.com/qutip/qutip/pull/1115:196,Integrability,message,messages,196,When using the `average_states` solver option `general_stochastic` seemed to error when summing the timeslot states. This PR provides a fix for this. Also included is some hopefully more succinct messages from the safety checks in `general_stochastic`.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1115
https://github.com/qutip/qutip/pull/1115:214,Safety,safe,safety,214,When using the `average_states` solver option `general_stochastic` seemed to error when summing the timeslot states. This PR provides a fix for this. Also included is some hopefully more succinct messages from the safety checks in `general_stochastic`.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1115
https://github.com/qutip/qutip/issues/1118:164,Deployability,update,update,164,"The eigenvectors returned by .eigenstates() method are determined up to a sign (which is correct, but leads to interesting issues in some cases). Is it possible to update the eigenstates method to fix these internally? A simple workaround is to invert (multiply by -1) any eigenstates that cause trouble, but I'm not sure I know of a universal test for ""trouble"". As an example, [this gist](https://gist.github.com/amcdawes/437f8756fcb8ff8ca4c1b720600adf43) demonstrates a fix whereby all eigenstates are made to have positive initial values. I suspect this fix is specific to SHO states, but perhaps a universal standard exists where each vector could be made to match the expected result?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1118
https://github.com/qutip/qutip/issues/1118:344,Testability,test,test,344,"The eigenvectors returned by .eigenstates() method are determined up to a sign (which is correct, but leads to interesting issues in some cases). Is it possible to update the eigenstates method to fix these internally? A simple workaround is to invert (multiply by -1) any eigenstates that cause trouble, but I'm not sure I know of a universal test for ""trouble"". As an example, [this gist](https://gist.github.com/amcdawes/437f8756fcb8ff8ca4c1b720600adf43) demonstrates a fix whereby all eigenstates are made to have positive initial values. I suspect this fix is specific to SHO states, but perhaps a universal standard exists where each vector could be made to match the expected result?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1118
https://github.com/qutip/qutip/issues/1118:221,Usability,simpl,simple,221,"The eigenvectors returned by .eigenstates() method are determined up to a sign (which is correct, but leads to interesting issues in some cases). Is it possible to update the eigenstates method to fix these internally? A simple workaround is to invert (multiply by -1) any eigenstates that cause trouble, but I'm not sure I know of a universal test for ""trouble"". As an example, [this gist](https://gist.github.com/amcdawes/437f8756fcb8ff8ca4c1b720600adf43) demonstrates a fix whereby all eigenstates are made to have positive initial values. I suspect this fix is specific to SHO states, but perhaps a universal standard exists where each vector could be made to match the expected result?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1118
https://github.com/qutip/qutip/issues/1119:133,Availability,error,error,133,"When I was trying to run a script written with qutip on a cluster with Ubunt 18.04, python 2.7 conda 4.7.12 installed, the following error occurred. Traceback (most recent call last):; File ""test.py"", line 13, in <module>; from qutip import *; File ""/home/user/miniconda2/lib/python2.7/site-packages/qutip/__init__.py"", line 171, in <module>; from qutip.qobj import *; File ""/home/user/miniconda2/lib/python2.7/site-packages/qutip/qobj.py"", line 2434, in <module>; import qutip.superop_reps as sr; File ""/home/user/miniconda2/lib/python2.7/site-packages/qutip/superop_reps.py"", line 61, in <module>; from qutip.superoperator import vec2mat, spre, spost, operator_to_vector; File ""/home/user/miniconda2/lib/python2.7/site-packages/qutip/superoperator.py"", line 408, in <module>; from qutip.qobjevo import QobjEvo; File ""/home/user/miniconda2/lib/python2.7/site-packages/qutip/qobjevo.py"", line 515; raise TypeError(""Qobj not compatible."") from e",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1119
https://github.com/qutip/qutip/issues/1119:108,Deployability,install,installed,108,"When I was trying to run a script written with qutip on a cluster with Ubunt 18.04, python 2.7 conda 4.7.12 installed, the following error occurred. Traceback (most recent call last):; File ""test.py"", line 13, in <module>; from qutip import *; File ""/home/user/miniconda2/lib/python2.7/site-packages/qutip/__init__.py"", line 171, in <module>; from qutip.qobj import *; File ""/home/user/miniconda2/lib/python2.7/site-packages/qutip/qobj.py"", line 2434, in <module>; import qutip.superop_reps as sr; File ""/home/user/miniconda2/lib/python2.7/site-packages/qutip/superop_reps.py"", line 61, in <module>; from qutip.superoperator import vec2mat, spre, spost, operator_to_vector; File ""/home/user/miniconda2/lib/python2.7/site-packages/qutip/superoperator.py"", line 408, in <module>; from qutip.qobjevo import QobjEvo; File ""/home/user/miniconda2/lib/python2.7/site-packages/qutip/qobjevo.py"", line 515; raise TypeError(""Qobj not compatible."") from e",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1119
https://github.com/qutip/qutip/issues/1119:191,Testability,test,test,191,"When I was trying to run a script written with qutip on a cluster with Ubunt 18.04, python 2.7 conda 4.7.12 installed, the following error occurred. Traceback (most recent call last):; File ""test.py"", line 13, in <module>; from qutip import *; File ""/home/user/miniconda2/lib/python2.7/site-packages/qutip/__init__.py"", line 171, in <module>; from qutip.qobj import *; File ""/home/user/miniconda2/lib/python2.7/site-packages/qutip/qobj.py"", line 2434, in <module>; import qutip.superop_reps as sr; File ""/home/user/miniconda2/lib/python2.7/site-packages/qutip/superop_reps.py"", line 61, in <module>; from qutip.superoperator import vec2mat, spre, spost, operator_to_vector; File ""/home/user/miniconda2/lib/python2.7/site-packages/qutip/superoperator.py"", line 408, in <module>; from qutip.qobjevo import QobjEvo; File ""/home/user/miniconda2/lib/python2.7/site-packages/qutip/qobjevo.py"", line 515; raise TypeError(""Qobj not compatible."") from e",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1119
https://github.com/qutip/qutip/issues/1120:188,Availability,error,error,188,"After installing qutip via conda (conda install qutip) on Mac 10.15.1 High Sierra, I ran the testing script using:. >> import qutip.testing as qt ; >> qt.run(). I am getting the following error: . Qobj subtraction ... python(4259,0x119a26dc0) malloc: Incorrect checksum for freed object 0x7fdbb05c5910: probably modified after being freed.; Corrupt value: 0x3ff0000000000000; python(4259,0x119a26dc0) malloc: *** set a breakpoint in malloc_error_break to debug; Abort trap: 6. Does anyone know what is causing this, how to fix it, or what kinds of problems it might cause later? Thank you!. Sacha",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1120
https://github.com/qutip/qutip/issues/1120:6,Deployability,install,installing,6,"After installing qutip via conda (conda install qutip) on Mac 10.15.1 High Sierra, I ran the testing script using:. >> import qutip.testing as qt ; >> qt.run(). I am getting the following error: . Qobj subtraction ... python(4259,0x119a26dc0) malloc: Incorrect checksum for freed object 0x7fdbb05c5910: probably modified after being freed.; Corrupt value: 0x3ff0000000000000; python(4259,0x119a26dc0) malloc: *** set a breakpoint in malloc_error_break to debug; Abort trap: 6. Does anyone know what is causing this, how to fix it, or what kinds of problems it might cause later? Thank you!. Sacha",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1120
https://github.com/qutip/qutip/issues/1120:40,Deployability,install,install,40,"After installing qutip via conda (conda install qutip) on Mac 10.15.1 High Sierra, I ran the testing script using:. >> import qutip.testing as qt ; >> qt.run(). I am getting the following error: . Qobj subtraction ... python(4259,0x119a26dc0) malloc: Incorrect checksum for freed object 0x7fdbb05c5910: probably modified after being freed.; Corrupt value: 0x3ff0000000000000; python(4259,0x119a26dc0) malloc: *** set a breakpoint in malloc_error_break to debug; Abort trap: 6. Does anyone know what is causing this, how to fix it, or what kinds of problems it might cause later? Thank you!. Sacha",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1120
https://github.com/qutip/qutip/issues/1120:462,Safety,Abort,Abort,462,"After installing qutip via conda (conda install qutip) on Mac 10.15.1 High Sierra, I ran the testing script using:. >> import qutip.testing as qt ; >> qt.run(). I am getting the following error: . Qobj subtraction ... python(4259,0x119a26dc0) malloc: Incorrect checksum for freed object 0x7fdbb05c5910: probably modified after being freed.; Corrupt value: 0x3ff0000000000000; python(4259,0x119a26dc0) malloc: *** set a breakpoint in malloc_error_break to debug; Abort trap: 6. Does anyone know what is causing this, how to fix it, or what kinds of problems it might cause later? Thank you!. Sacha",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1120
https://github.com/qutip/qutip/issues/1120:261,Security,checksum,checksum,261,"After installing qutip via conda (conda install qutip) on Mac 10.15.1 High Sierra, I ran the testing script using:. >> import qutip.testing as qt ; >> qt.run(). I am getting the following error: . Qobj subtraction ... python(4259,0x119a26dc0) malloc: Incorrect checksum for freed object 0x7fdbb05c5910: probably modified after being freed.; Corrupt value: 0x3ff0000000000000; python(4259,0x119a26dc0) malloc: *** set a breakpoint in malloc_error_break to debug; Abort trap: 6. Does anyone know what is causing this, how to fix it, or what kinds of problems it might cause later? Thank you!. Sacha",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1120
https://github.com/qutip/qutip/issues/1120:93,Testability,test,testing,93,"After installing qutip via conda (conda install qutip) on Mac 10.15.1 High Sierra, I ran the testing script using:. >> import qutip.testing as qt ; >> qt.run(). I am getting the following error: . Qobj subtraction ... python(4259,0x119a26dc0) malloc: Incorrect checksum for freed object 0x7fdbb05c5910: probably modified after being freed.; Corrupt value: 0x3ff0000000000000; python(4259,0x119a26dc0) malloc: *** set a breakpoint in malloc_error_break to debug; Abort trap: 6. Does anyone know what is causing this, how to fix it, or what kinds of problems it might cause later? Thank you!. Sacha",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1120
https://github.com/qutip/qutip/issues/1120:132,Testability,test,testing,132,"After installing qutip via conda (conda install qutip) on Mac 10.15.1 High Sierra, I ran the testing script using:. >> import qutip.testing as qt ; >> qt.run(). I am getting the following error: . Qobj subtraction ... python(4259,0x119a26dc0) malloc: Incorrect checksum for freed object 0x7fdbb05c5910: probably modified after being freed.; Corrupt value: 0x3ff0000000000000; python(4259,0x119a26dc0) malloc: *** set a breakpoint in malloc_error_break to debug; Abort trap: 6. Does anyone know what is causing this, how to fix it, or what kinds of problems it might cause later? Thank you!. Sacha",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1120
https://github.com/qutip/qutip/issues/1121:33,Deployability,update,updated,33,"The message in `qutip.cite()` is updated with current lead developers. The previous lead/core developers can be added, uniformly with the names listed in the [readme](https://github.com/qutip/qutip) page.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1121
https://github.com/qutip/qutip/issues/1121:4,Integrability,message,message,4,"The message in `qutip.cite()` is updated with current lead developers. The previous lead/core developers can be added, uniformly with the names listed in the [readme](https://github.com/qutip/qutip) page.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1121
https://github.com/qutip/qutip/pull/1122:40,Integrability,message,message,40,Docstring change to the `qutip.about()` message.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1122
https://github.com/qutip/qutip/pull/1123:630,Deployability,update,updated,630,"Add a wrapper for function returning `Qobj` to be treated as `QobjEvo`: `QobjEvoFunc`; Wrapped function have access to all method of `QobjEvo` therefore only one version of the code should be sufficient for time dependant problems using both list format and function.; Any callable is considered a function, allowing for class method etc. The new function `qobjevo_maker` can take any valid time dependant quantum object and make it a `QobjEvo` like object. Added wrapper for function using the old `rhs_with_state` format and using no `args`. . Tests for `QobjEvoFunc` have been added but not for `qobjevo_maker`. Solver are not updated to use it yet. @ajgpitch I added it last minute in stochastic, but did not tried it yet.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1123
https://github.com/qutip/qutip/pull/1123:6,Integrability,wrap,wrapper,6,"Add a wrapper for function returning `Qobj` to be treated as `QobjEvo`: `QobjEvoFunc`; Wrapped function have access to all method of `QobjEvo` therefore only one version of the code should be sufficient for time dependant problems using both list format and function.; Any callable is considered a function, allowing for class method etc. The new function `qobjevo_maker` can take any valid time dependant quantum object and make it a `QobjEvo` like object. Added wrapper for function using the old `rhs_with_state` format and using no `args`. . Tests for `QobjEvoFunc` have been added but not for `qobjevo_maker`. Solver are not updated to use it yet. @ajgpitch I added it last minute in stochastic, but did not tried it yet.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1123
https://github.com/qutip/qutip/pull/1123:87,Integrability,Wrap,Wrapped,87,"Add a wrapper for function returning `Qobj` to be treated as `QobjEvo`: `QobjEvoFunc`; Wrapped function have access to all method of `QobjEvo` therefore only one version of the code should be sufficient for time dependant problems using both list format and function.; Any callable is considered a function, allowing for class method etc. The new function `qobjevo_maker` can take any valid time dependant quantum object and make it a `QobjEvo` like object. Added wrapper for function using the old `rhs_with_state` format and using no `args`. . Tests for `QobjEvoFunc` have been added but not for `qobjevo_maker`. Solver are not updated to use it yet. @ajgpitch I added it last minute in stochastic, but did not tried it yet.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1123
https://github.com/qutip/qutip/pull/1123:212,Integrability,depend,dependant,212,"Add a wrapper for function returning `Qobj` to be treated as `QobjEvo`: `QobjEvoFunc`; Wrapped function have access to all method of `QobjEvo` therefore only one version of the code should be sufficient for time dependant problems using both list format and function.; Any callable is considered a function, allowing for class method etc. The new function `qobjevo_maker` can take any valid time dependant quantum object and make it a `QobjEvo` like object. Added wrapper for function using the old `rhs_with_state` format and using no `args`. . Tests for `QobjEvoFunc` have been added but not for `qobjevo_maker`. Solver are not updated to use it yet. @ajgpitch I added it last minute in stochastic, but did not tried it yet.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1123
https://github.com/qutip/qutip/pull/1123:396,Integrability,depend,dependant,396,"Add a wrapper for function returning `Qobj` to be treated as `QobjEvo`: `QobjEvoFunc`; Wrapped function have access to all method of `QobjEvo` therefore only one version of the code should be sufficient for time dependant problems using both list format and function.; Any callable is considered a function, allowing for class method etc. The new function `qobjevo_maker` can take any valid time dependant quantum object and make it a `QobjEvo` like object. Added wrapper for function using the old `rhs_with_state` format and using no `args`. . Tests for `QobjEvoFunc` have been added but not for `qobjevo_maker`. Solver are not updated to use it yet. @ajgpitch I added it last minute in stochastic, but did not tried it yet.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1123
https://github.com/qutip/qutip/pull/1123:464,Integrability,wrap,wrapper,464,"Add a wrapper for function returning `Qobj` to be treated as `QobjEvo`: `QobjEvoFunc`; Wrapped function have access to all method of `QobjEvo` therefore only one version of the code should be sufficient for time dependant problems using both list format and function.; Any callable is considered a function, allowing for class method etc. The new function `qobjevo_maker` can take any valid time dependant quantum object and make it a `QobjEvo` like object. Added wrapper for function using the old `rhs_with_state` format and using no `args`. . Tests for `QobjEvoFunc` have been added but not for `qobjevo_maker`. Solver are not updated to use it yet. @ajgpitch I added it last minute in stochastic, but did not tried it yet.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1123
https://github.com/qutip/qutip/pull/1123:109,Security,access,access,109,"Add a wrapper for function returning `Qobj` to be treated as `QobjEvo`: `QobjEvoFunc`; Wrapped function have access to all method of `QobjEvo` therefore only one version of the code should be sufficient for time dependant problems using both list format and function.; Any callable is considered a function, allowing for class method etc. The new function `qobjevo_maker` can take any valid time dependant quantum object and make it a `QobjEvo` like object. Added wrapper for function using the old `rhs_with_state` format and using no `args`. . Tests for `QobjEvoFunc` have been added but not for `qobjevo_maker`. Solver are not updated to use it yet. @ajgpitch I added it last minute in stochastic, but did not tried it yet.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1123
https://github.com/qutip/qutip/pull/1123:546,Testability,Test,Tests,546,"Add a wrapper for function returning `Qobj` to be treated as `QobjEvo`: `QobjEvoFunc`; Wrapped function have access to all method of `QobjEvo` therefore only one version of the code should be sufficient for time dependant problems using both list format and function.; Any callable is considered a function, allowing for class method etc. The new function `qobjevo_maker` can take any valid time dependant quantum object and make it a `QobjEvo` like object. Added wrapper for function using the old `rhs_with_state` format and using no `args`. . Tests for `QobjEvoFunc` have been added but not for `qobjevo_maker`. Solver are not updated to use it yet. @ajgpitch I added it last minute in stochastic, but did not tried it yet.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1123
https://github.com/qutip/qutip/issues/1124:2717,Availability,fault,fault,2717,"==========================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmesolve: harmonic oscillator, finite temperature, states ... ok; brmesolve: Jaynes-Cummings model, zero temperature ... ok; brmesolve: Check for #572 bug. ... ok; brmesolve: input list of Qobj ... ok; td_brmesolve: passes all brmesolve tests ... ok; td_brmesolve: time-dependent a_ops ... ok; td_brmesolve: time-dependent a_ops tuple of strings ... ok; td_brmesolve: time-dependent a_ops tuple interp ... ok; td_brmesolve: time-dependent a_ops & c_ops interp ... ok; td_brmesolve: non-Hermitian e_ops check ... ok; td_brmesolve: states check ... ok; td_brmesolve: split ops #1 ... ok; td_brmesolve: split ops #2 ... ok; td_brmesolve: split ops, Cubic_Spline td-terms ... ok; td_brmesolve: split ops, multiple ... ok; td_brmesolve: Hamiltonian args ... ok; BR Tools : zheevr ... Segmentation fault: 11; ```. I'm unsure what is going on here. I tried reinstalling qutip without any change. Prior I had a lot of errors referring to xcrun but I fixed that by installing xcode. Is there something else I need to get this working?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1124
https://github.com/qutip/qutip/issues/1124:2835,Availability,error,errors,2835,"==========================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmesolve: harmonic oscillator, finite temperature, states ... ok; brmesolve: Jaynes-Cummings model, zero temperature ... ok; brmesolve: Check for #572 bug. ... ok; brmesolve: input list of Qobj ... ok; td_brmesolve: passes all brmesolve tests ... ok; td_brmesolve: time-dependent a_ops ... ok; td_brmesolve: time-dependent a_ops tuple of strings ... ok; td_brmesolve: time-dependent a_ops tuple interp ... ok; td_brmesolve: time-dependent a_ops & c_ops interp ... ok; td_brmesolve: non-Hermitian e_ops check ... ok; td_brmesolve: states check ... ok; td_brmesolve: split ops #1 ... ok; td_brmesolve: split ops #2 ... ok; td_brmesolve: split ops, Cubic_Spline td-terms ... ok; td_brmesolve: split ops, multiple ... ok; td_brmesolve: Hamiltonian args ... ok; BR Tools : zheevr ... Segmentation fault: 11; ```. I'm unsure what is going on here. I tried reinstalling qutip without any change. Prior I had a lot of errors referring to xcrun but I fixed that by installing xcode. Is there something else I need to get this working?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1124
https://github.com/qutip/qutip/issues/1124:759,Deployability,Install,Installed,759,"I am trying to learn to use qutip and I made a local environment. As per the instruction guide, I ran the qutip testing environment and got the following: . ```; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.4.1; Numpy Version: 1.17.3; Scipy Version: 1.3.1; Cython Version: 0.29.13; Matplotlib Version: 3.1.1; Python Version: 3.7.3; Number of CPUs: 4; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /Users/nathanholman/opt/anaconda3/envs/qutip/lib/python3.7/site-packages/qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmesolve: harmonic oscillator, finite temperature, states ... ok; brmesolve:",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1124
https://github.com/qutip/qutip/issues/1124:831,Deployability,Install,Installation,831,"I am trying to learn to use qutip and I made a local environment. As per the instruction guide, I ran the qutip testing environment and got the following: . ```; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.4.1; Numpy Version: 1.17.3; Scipy Version: 1.3.1; Cython Version: 0.29.13; Matplotlib Version: 3.1.1; Python Version: 3.7.3; Number of CPUs: 4; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /Users/nathanholman/opt/anaconda3/envs/qutip/lib/python3.7/site-packages/qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmesolve: harmonic oscillator, finite temperature, states ... ok; brmesolve:",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1124
https://github.com/qutip/qutip/issues/1124:2881,Deployability,install,installing,2881,"==========================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmesolve: harmonic oscillator, finite temperature, states ... ok; brmesolve: Jaynes-Cummings model, zero temperature ... ok; brmesolve: Check for #572 bug. ... ok; brmesolve: input list of Qobj ... ok; td_brmesolve: passes all brmesolve tests ... ok; td_brmesolve: time-dependent a_ops ... ok; td_brmesolve: time-dependent a_ops tuple of strings ... ok; td_brmesolve: time-dependent a_ops tuple interp ... ok; td_brmesolve: time-dependent a_ops & c_ops interp ... ok; td_brmesolve: non-Hermitian e_ops check ... ok; td_brmesolve: states check ... ok; td_brmesolve: split ops #1 ... ok; td_brmesolve: split ops #2 ... ok; td_brmesolve: split ops, Cubic_Spline td-terms ... ok; td_brmesolve: split ops, multiple ... ok; td_brmesolve: Hamiltonian args ... ok; BR Tools : zheevr ... Segmentation fault: 11; ```. I'm unsure what is going on here. I tried reinstalling qutip without any change. Prior I had a lot of errors referring to xcrun but I fixed that by installing xcode. Is there something else I need to get this working?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1124
https://github.com/qutip/qutip/issues/1124:2195,Integrability,depend,dependent,2195,"==========================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmesolve: harmonic oscillator, finite temperature, states ... ok; brmesolve: Jaynes-Cummings model, zero temperature ... ok; brmesolve: Check for #572 bug. ... ok; brmesolve: input list of Qobj ... ok; td_brmesolve: passes all brmesolve tests ... ok; td_brmesolve: time-dependent a_ops ... ok; td_brmesolve: time-dependent a_ops tuple of strings ... ok; td_brmesolve: time-dependent a_ops tuple interp ... ok; td_brmesolve: time-dependent a_ops & c_ops interp ... ok; td_brmesolve: non-Hermitian e_ops check ... ok; td_brmesolve: states check ... ok; td_brmesolve: split ops #1 ... ok; td_brmesolve: split ops #2 ... ok; td_brmesolve: split ops, Cubic_Spline td-terms ... ok; td_brmesolve: split ops, multiple ... ok; td_brmesolve: Hamiltonian args ... ok; BR Tools : zheevr ... Segmentation fault: 11; ```. I'm unsure what is going on here. I tried reinstalling qutip without any change. Prior I had a lot of errors referring to xcrun but I fixed that by installing xcode. Is there something else I need to get this working?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1124
https://github.com/qutip/qutip/issues/1124:2238,Integrability,depend,dependent,2238,"==========================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmesolve: harmonic oscillator, finite temperature, states ... ok; brmesolve: Jaynes-Cummings model, zero temperature ... ok; brmesolve: Check for #572 bug. ... ok; brmesolve: input list of Qobj ... ok; td_brmesolve: passes all brmesolve tests ... ok; td_brmesolve: time-dependent a_ops ... ok; td_brmesolve: time-dependent a_ops tuple of strings ... ok; td_brmesolve: time-dependent a_ops tuple interp ... ok; td_brmesolve: time-dependent a_ops & c_ops interp ... ok; td_brmesolve: non-Hermitian e_ops check ... ok; td_brmesolve: states check ... ok; td_brmesolve: split ops #1 ... ok; td_brmesolve: split ops #2 ... ok; td_brmesolve: split ops, Cubic_Spline td-terms ... ok; td_brmesolve: split ops, multiple ... ok; td_brmesolve: Hamiltonian args ... ok; BR Tools : zheevr ... Segmentation fault: 11; ```. I'm unsure what is going on here. I tried reinstalling qutip without any change. Prior I had a lot of errors referring to xcrun but I fixed that by installing xcode. Is there something else I need to get this working?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1124
https://github.com/qutip/qutip/issues/1124:2298,Integrability,depend,dependent,2298,"==========================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmesolve: harmonic oscillator, finite temperature, states ... ok; brmesolve: Jaynes-Cummings model, zero temperature ... ok; brmesolve: Check for #572 bug. ... ok; brmesolve: input list of Qobj ... ok; td_brmesolve: passes all brmesolve tests ... ok; td_brmesolve: time-dependent a_ops ... ok; td_brmesolve: time-dependent a_ops tuple of strings ... ok; td_brmesolve: time-dependent a_ops tuple interp ... ok; td_brmesolve: time-dependent a_ops & c_ops interp ... ok; td_brmesolve: non-Hermitian e_ops check ... ok; td_brmesolve: states check ... ok; td_brmesolve: split ops #1 ... ok; td_brmesolve: split ops #2 ... ok; td_brmesolve: split ops, Cubic_Spline td-terms ... ok; td_brmesolve: split ops, multiple ... ok; td_brmesolve: Hamiltonian args ... ok; BR Tools : zheevr ... Segmentation fault: 11; ```. I'm unsure what is going on here. I tried reinstalling qutip without any change. Prior I had a lot of errors referring to xcrun but I fixed that by installing xcode. Is there something else I need to get this working?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1124
https://github.com/qutip/qutip/issues/1124:2354,Integrability,depend,dependent,2354,"==========================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmesolve: harmonic oscillator, finite temperature, states ... ok; brmesolve: Jaynes-Cummings model, zero temperature ... ok; brmesolve: Check for #572 bug. ... ok; brmesolve: input list of Qobj ... ok; td_brmesolve: passes all brmesolve tests ... ok; td_brmesolve: time-dependent a_ops ... ok; td_brmesolve: time-dependent a_ops tuple of strings ... ok; td_brmesolve: time-dependent a_ops tuple interp ... ok; td_brmesolve: time-dependent a_ops & c_ops interp ... ok; td_brmesolve: non-Hermitian e_ops check ... ok; td_brmesolve: states check ... ok; td_brmesolve: split ops #1 ... ok; td_brmesolve: split ops #2 ... ok; td_brmesolve: split ops, Cubic_Spline td-terms ... ok; td_brmesolve: split ops, multiple ... ok; td_brmesolve: Hamiltonian args ... ok; BR Tools : zheevr ... Segmentation fault: 11; ```. I'm unsure what is going on here. I tried reinstalling qutip without any change. Prior I had a lot of errors referring to xcrun but I fixed that by installing xcode. Is there something else I need to get this working?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1124
https://github.com/qutip/qutip/issues/1124:112,Testability,test,testing,112,"I am trying to learn to use qutip and I made a local environment. As per the instruction guide, I ran the qutip testing environment and got the following: . ```; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.4.1; Numpy Version: 1.17.3; Scipy Version: 1.3.1; Cython Version: 0.29.13; Matplotlib Version: 3.1.1; Python Version: 3.7.3; Number of CPUs: 4; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /Users/nathanholman/opt/anaconda3/envs/qutip/lib/python3.7/site-packages/qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmesolve: harmonic oscillator, finite temperature, states ... ok; brmesolve:",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1124
https://github.com/qutip/qutip/issues/1124:2162,Testability,test,tests,2162,"==========================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmesolve: harmonic oscillator, finite temperature, states ... ok; brmesolve: Jaynes-Cummings model, zero temperature ... ok; brmesolve: Check for #572 bug. ... ok; brmesolve: input list of Qobj ... ok; td_brmesolve: passes all brmesolve tests ... ok; td_brmesolve: time-dependent a_ops ... ok; td_brmesolve: time-dependent a_ops tuple of strings ... ok; td_brmesolve: time-dependent a_ops tuple interp ... ok; td_brmesolve: time-dependent a_ops & c_ops interp ... ok; td_brmesolve: non-Hermitian e_ops check ... ok; td_brmesolve: states check ... ok; td_brmesolve: split ops #1 ... ok; td_brmesolve: split ops #2 ... ok; td_brmesolve: split ops, Cubic_Spline td-terms ... ok; td_brmesolve: split ops, multiple ... ok; td_brmesolve: Hamiltonian args ... ok; BR Tools : zheevr ... Segmentation fault: 11; ```. I'm unsure what is going on here. I tried reinstalling qutip without any change. Prior I had a lot of errors referring to xcrun but I fixed that by installing xcode. Is there something else I need to get this working?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1124
https://github.com/qutip/qutip/issues/1124:15,Usability,learn,learn,15,"I am trying to learn to use qutip and I made a local environment. As per the instruction guide, I ran the qutip testing environment and got the following: . ```; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.4.1; Numpy Version: 1.17.3; Scipy Version: 1.3.1; Cython Version: 0.29.13; Matplotlib Version: 3.1.1; Python Version: 3.7.3; Number of CPUs: 4; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /Users/nathanholman/opt/anaconda3/envs/qutip/lib/python3.7/site-packages/qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmesolve: harmonic oscillator, finite temperature, states ... ok; brmesolve:",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1124
https://github.com/qutip/qutip/issues/1124:89,Usability,guid,guide,89,"I am trying to learn to use qutip and I made a local environment. As per the instruction guide, I ran the qutip testing environment and got the following: . ```; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.4.1; Numpy Version: 1.17.3; Scipy Version: 1.3.1; Cython Version: 0.29.13; Matplotlib Version: 3.1.1; Python Version: 3.7.3; Number of CPUs: 4; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /Users/nathanholman/opt/anaconda3/envs/qutip/lib/python3.7/site-packages/qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmesolve: harmonic oscillator, finite temperature, states ... ok; brmesolve:",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1124
https://github.com/qutip/qutip/issues/1124:1720,Usability,simpl,simple,1720," of CPUs: 4; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /Users/nathanholman/opt/anaconda3/envs/qutip/lib/python3.7/site-packages/qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmesolve: harmonic oscillator, finite temperature, states ... ok; brmesolve: Jaynes-Cummings model, zero temperature ... ok; brmesolve: Check for #572 bug. ... ok; brmesolve: input list of Qobj ... ok; td_brmesolve: passes all brmesolve tests ... ok; td_brmesolve: time-dependent a_ops ... ok; td_brmesolve: time-dependent a_ops tuple of strings ... ok; td_brmesolve: time-dependent a_ops tuple interp ... ok; td_brmesolve: time-dependent a_ops & c_ops interp ... ok; td_brmesolve: non-Hermitian e_ops check ... ok; td_brmesolve: states check ... ok; td_brmesolve: split ops #1 ... ok; td_brmesolve: split ops #2 ... ok; td_brmesolve: split ops, Cubic_Spline td-terms ... ok; td_brmesolve: split ops, multiple ... ok; td_brmesolve: Hamiltonian args ... ok; BR Tools : zheevr ... Segmentation fa",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1124
https://github.com/qutip/qutip/pull/1125:138,Availability,error,errors,138,Add a linux python 3.8 test; Fix MacOS python version to 3.7 as our test environment result in conflict on 3.8; * Does not fix mac tests' errors,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1125
https://github.com/qutip/qutip/pull/1125:23,Testability,test,test,23,Add a linux python 3.8 test; Fix MacOS python version to 3.7 as our test environment result in conflict on 3.8; * Does not fix mac tests' errors,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1125
https://github.com/qutip/qutip/pull/1125:68,Testability,test,test,68,Add a linux python 3.8 test; Fix MacOS python version to 3.7 as our test environment result in conflict on 3.8; * Does not fix mac tests' errors,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1125
https://github.com/qutip/qutip/pull/1125:131,Testability,test,tests,131,Add a linux python 3.8 test; Fix MacOS python version to 3.7 as our test environment result in conflict on 3.8; * Does not fix mac tests' errors,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1125
https://github.com/qutip/qutip/pull/1126:98,Availability,error,errors,98,"This is a real shot in the dark, but it appears to have fixed an issue with lots of random malloc errors popping up on the mac platform (see #1120 and other recent discussions on the google group. It appears this is literally the only call to `free()` in all of qutip so perhaps there is a better way to do low-level memory work? I only know enough C to be dangerous, and found a random hint about setting pointers to NULL after freeing them. I gave it a shot and no longer see the issue on my mac when running py2.7.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1126
https://github.com/qutip/qutip/pull/1127:27,Integrability,depend,depending,27,Fix bugs in QobjEvo's args depending on state and added solver tests using them.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1127
https://github.com/qutip/qutip/pull/1127:63,Testability,test,tests,63,Fix bugs in QobjEvo's args depending on state and added solver tests using them.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1127
https://github.com/qutip/qutip/issues/1129:168,Availability,Error,Error,168,"By installing qutip via. pip2 install qutip==4.3.1. (I had another problem with qutip 4.4.1 with the python2.7 interpreter) I ran into a problem with cython - several ""Error compiling Cython file"" messages. Here I have cython v. 0.23.4 and the minimum requirement is displayed as 0.21. I guess this minimum requirement should be changed",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1129
https://github.com/qutip/qutip/issues/1129:3,Deployability,install,installing,3,"By installing qutip via. pip2 install qutip==4.3.1. (I had another problem with qutip 4.4.1 with the python2.7 interpreter) I ran into a problem with cython - several ""Error compiling Cython file"" messages. Here I have cython v. 0.23.4 and the minimum requirement is displayed as 0.21. I guess this minimum requirement should be changed",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1129
https://github.com/qutip/qutip/issues/1129:30,Deployability,install,install,30,"By installing qutip via. pip2 install qutip==4.3.1. (I had another problem with qutip 4.4.1 with the python2.7 interpreter) I ran into a problem with cython - several ""Error compiling Cython file"" messages. Here I have cython v. 0.23.4 and the minimum requirement is displayed as 0.21. I guess this minimum requirement should be changed",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1129
https://github.com/qutip/qutip/issues/1129:197,Integrability,message,messages,197,"By installing qutip via. pip2 install qutip==4.3.1. (I had another problem with qutip 4.4.1 with the python2.7 interpreter) I ran into a problem with cython - several ""Error compiling Cython file"" messages. Here I have cython v. 0.23.4 and the minimum requirement is displayed as 0.21. I guess this minimum requirement should be changed",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1129
https://github.com/qutip/qutip/pull/1131:0,Deployability,Update,Updated,0,Updated travis.yml to move to pytest. ; Also updated qutip.testing to use pytest.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1131
https://github.com/qutip/qutip/pull/1131:45,Deployability,update,updated,45,Updated travis.yml to move to pytest. ; Also updated qutip.testing to use pytest.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1131
https://github.com/qutip/qutip/pull/1131:59,Testability,test,testing,59,Updated travis.yml to move to pytest. ; Also updated qutip.testing to use pytest.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1131
https://github.com/qutip/qutip/issues/1132:2255,Availability,avail,available,2255,"re is the opportunity for students projects over the winter. I will begin with proposing mine, but this is an opportunity also for mentors to propose their projects, beginning in priority from the lead developers. . ## Other Funding Schemes; Similarly, I have been writing NumFOCUS [small development grants](https://numfocus.org/blog/fall-2018-open-source-development-grants), which have a different goal but can be set up similarly. Also, in the future we may apply again to [Google Season of Docs](https://developers.google.com/season-of-docs). . ## Future Opportunities; Several senior researchers and team leaders have aired the desire to contribute to the project more actively. Setting up a space where they can propose projects, even on their own funding resources (most probably together with the development of research projects), in coordination with the lead development team, could help foster development in a more sustainable way. . ## Proposal; I propose to help sustain available projects in a more structural way than what is done now. This is an example of a what we could call a **QEP, or ""QuTiP Enhancement Proposal"".**. - One thing that could be done is to simply expand the existing Wiki. The downside of taking only this action is that only organization members can modify the wiki. So this could work, but mainly as a more static and cleaner staple. . - I propose to integrate the Wiki with Issues that contain the projects, adding a `projects` (or similar) label. This is in the spirit also of other large quantum open source projects such as Qiskit, which has even an ad-hoc `qiskit-community` repository, https://github.com/qiskit-community/. In QuTiP case, we could create a new repository similar to the notebooks one, e.g., https://github.com/qutip/qutip-community/. The downside is that in general the division is subfolders is not advised for easiness of maintainability. So one could just open issues with open projects. Of course, for physics questions, sometimes s",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1132
https://github.com/qutip/qutip/issues/1132:2484,Availability,down,downside,2484,"heir projects, beginning in priority from the lead developers. . ## Other Funding Schemes; Similarly, I have been writing NumFOCUS [small development grants](https://numfocus.org/blog/fall-2018-open-source-development-grants), which have a different goal but can be set up similarly. Also, in the future we may apply again to [Google Season of Docs](https://developers.google.com/season-of-docs). . ## Future Opportunities; Several senior researchers and team leaders have aired the desire to contribute to the project more actively. Setting up a space where they can propose projects, even on their own funding resources (most probably together with the development of research projects), in coordination with the lead development team, could help foster development in a more sustainable way. . ## Proposal; I propose to help sustain available projects in a more structural way than what is done now. This is an example of a what we could call a **QEP, or ""QuTiP Enhancement Proposal"".**. - One thing that could be done is to simply expand the existing Wiki. The downside of taking only this action is that only organization members can modify the wiki. So this could work, but mainly as a more static and cleaner staple. . - I propose to integrate the Wiki with Issues that contain the projects, adding a `projects` (or similar) label. This is in the spirit also of other large quantum open source projects such as Qiskit, which has even an ad-hoc `qiskit-community` repository, https://github.com/qiskit-community/. In QuTiP case, we could create a new repository similar to the notebooks one, e.g., https://github.com/qutip/qutip-community/. The downside is that in general the division is subfolders is not advised for easiness of maintainability. So one could just open issues with open projects. Of course, for physics questions, sometimes spilling in to PRs and Issues, qutip already has a Google Group forum, where I advise that this new capabilities may be advertised with a proper thread.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1132
https://github.com/qutip/qutip/issues/1132:3070,Availability,down,downside,3070,"heir projects, beginning in priority from the lead developers. . ## Other Funding Schemes; Similarly, I have been writing NumFOCUS [small development grants](https://numfocus.org/blog/fall-2018-open-source-development-grants), which have a different goal but can be set up similarly. Also, in the future we may apply again to [Google Season of Docs](https://developers.google.com/season-of-docs). . ## Future Opportunities; Several senior researchers and team leaders have aired the desire to contribute to the project more actively. Setting up a space where they can propose projects, even on their own funding resources (most probably together with the development of research projects), in coordination with the lead development team, could help foster development in a more sustainable way. . ## Proposal; I propose to help sustain available projects in a more structural way than what is done now. This is an example of a what we could call a **QEP, or ""QuTiP Enhancement Proposal"".**. - One thing that could be done is to simply expand the existing Wiki. The downside of taking only this action is that only organization members can modify the wiki. So this could work, but mainly as a more static and cleaner staple. . - I propose to integrate the Wiki with Issues that contain the projects, adding a `projects` (or similar) label. This is in the spirit also of other large quantum open source projects such as Qiskit, which has even an ad-hoc `qiskit-community` repository, https://github.com/qiskit-community/. In QuTiP case, we could create a new repository similar to the notebooks one, e.g., https://github.com/qutip/qutip-community/. The downside is that in general the division is subfolders is not advised for easiness of maintainability. So one could just open issues with open projects. Of course, for physics questions, sometimes spilling in to PRs and Issues, qutip already has a Google Group forum, where I advise that this new capabilities may be advertised with a proper thread.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1132
https://github.com/qutip/qutip/issues/1132:55,Deployability,continuous,continuous,55,"QuTiP development is now based on a large community of continuous users and a smaller group of sporadic developers. Some developers continuously contribute to the development. . The nature of QuTiP, at the frontier of quantum physics research, implies that the development of new modules sometimes overlaps or stems from research projects. It could be nice to enhance the rate of contribution and mentoring from the users community in the spirit of openness and scalability. . ## GSoC and Wiki; An example of project ideas has been provided by the [Google Summer of Code 2019](https://numfocus.org/programs/google-summer-code), for which various researchers and coders, even if not directly part of the lead development team, proposed new projects on the [Wiki](https://github.com/qutip/qutip/wiki//Google-Summer-of-Code-2019). Two of these ideas were eventually brought forth by two students to develop their own projects over the summer. . The details are here https://gsoc2019-boxili.blogspot.com/ and here https://latticemodelfunctions.blogspot.com/. ## KWoC; I applied to the Kharagpur Winter of Code ([KWoC](https://kwoc.kossiitkgp.org/)) where mainly BSc and also MSc / PhDs can participate over the winter to a project on QuTiP. QuTiP just got selected and there is the opportunity for students projects over the winter. I will begin with proposing mine, but this is an opportunity also for mentors to propose their projects, beginning in priority from the lead developers. . ## Other Funding Schemes; Similarly, I have been writing NumFOCUS [small development grants](https://numfocus.org/blog/fall-2018-open-source-development-grants), which have a different goal but can be set up similarly. Also, in the future we may apply again to [Google Season of Docs](https://developers.google.com/season-of-docs). . ## Future Opportunities; Several senior researchers and team leaders have aired the desire to contribute to the project more actively. Setting up a space where they can propose projec",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1132
https://github.com/qutip/qutip/issues/1132:132,Deployability,continuous,continuously,132,"QuTiP development is now based on a large community of continuous users and a smaller group of sporadic developers. Some developers continuously contribute to the development. . The nature of QuTiP, at the frontier of quantum physics research, implies that the development of new modules sometimes overlaps or stems from research projects. It could be nice to enhance the rate of contribution and mentoring from the users community in the spirit of openness and scalability. . ## GSoC and Wiki; An example of project ideas has been provided by the [Google Summer of Code 2019](https://numfocus.org/programs/google-summer-code), for which various researchers and coders, even if not directly part of the lead development team, proposed new projects on the [Wiki](https://github.com/qutip/qutip/wiki//Google-Summer-of-Code-2019). Two of these ideas were eventually brought forth by two students to develop their own projects over the summer. . The details are here https://gsoc2019-boxili.blogspot.com/ and here https://latticemodelfunctions.blogspot.com/. ## KWoC; I applied to the Kharagpur Winter of Code ([KWoC](https://kwoc.kossiitkgp.org/)) where mainly BSc and also MSc / PhDs can participate over the winter to a project on QuTiP. QuTiP just got selected and there is the opportunity for students projects over the winter. I will begin with proposing mine, but this is an opportunity also for mentors to propose their projects, beginning in priority from the lead developers. . ## Other Funding Schemes; Similarly, I have been writing NumFOCUS [small development grants](https://numfocus.org/blog/fall-2018-open-source-development-grants), which have a different goal but can be set up similarly. Also, in the future we may apply again to [Google Season of Docs](https://developers.google.com/season-of-docs). . ## Future Opportunities; Several senior researchers and team leaders have aired the desire to contribute to the project more actively. Setting up a space where they can propose projec",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1132
https://github.com/qutip/qutip/issues/1132:2660,Deployability,integrat,integrate,2660,"heir projects, beginning in priority from the lead developers. . ## Other Funding Schemes; Similarly, I have been writing NumFOCUS [small development grants](https://numfocus.org/blog/fall-2018-open-source-development-grants), which have a different goal but can be set up similarly. Also, in the future we may apply again to [Google Season of Docs](https://developers.google.com/season-of-docs). . ## Future Opportunities; Several senior researchers and team leaders have aired the desire to contribute to the project more actively. Setting up a space where they can propose projects, even on their own funding resources (most probably together with the development of research projects), in coordination with the lead development team, could help foster development in a more sustainable way. . ## Proposal; I propose to help sustain available projects in a more structural way than what is done now. This is an example of a what we could call a **QEP, or ""QuTiP Enhancement Proposal"".**. - One thing that could be done is to simply expand the existing Wiki. The downside of taking only this action is that only organization members can modify the wiki. So this could work, but mainly as a more static and cleaner staple. . - I propose to integrate the Wiki with Issues that contain the projects, adding a `projects` (or similar) label. This is in the spirit also of other large quantum open source projects such as Qiskit, which has even an ad-hoc `qiskit-community` repository, https://github.com/qiskit-community/. In QuTiP case, we could create a new repository similar to the notebooks one, e.g., https://github.com/qutip/qutip-community/. The downside is that in general the division is subfolders is not advised for easiness of maintainability. So one could just open issues with open projects. Of course, for physics questions, sometimes spilling in to PRs and Issues, qutip already has a Google Group forum, where I advise that this new capabilities may be advertised with a proper thread.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1132
https://github.com/qutip/qutip/issues/1132:2197,Energy Efficiency,sustainab,sustainable,2197,"haragpur Winter of Code ([KWoC](https://kwoc.kossiitkgp.org/)) where mainly BSc and also MSc / PhDs can participate over the winter to a project on QuTiP. QuTiP just got selected and there is the opportunity for students projects over the winter. I will begin with proposing mine, but this is an opportunity also for mentors to propose their projects, beginning in priority from the lead developers. . ## Other Funding Schemes; Similarly, I have been writing NumFOCUS [small development grants](https://numfocus.org/blog/fall-2018-open-source-development-grants), which have a different goal but can be set up similarly. Also, in the future we may apply again to [Google Season of Docs](https://developers.google.com/season-of-docs). . ## Future Opportunities; Several senior researchers and team leaders have aired the desire to contribute to the project more actively. Setting up a space where they can propose projects, even on their own funding resources (most probably together with the development of research projects), in coordination with the lead development team, could help foster development in a more sustainable way. . ## Proposal; I propose to help sustain available projects in a more structural way than what is done now. This is an example of a what we could call a **QEP, or ""QuTiP Enhancement Proposal"".**. - One thing that could be done is to simply expand the existing Wiki. The downside of taking only this action is that only organization members can modify the wiki. So this could work, but mainly as a more static and cleaner staple. . - I propose to integrate the Wiki with Issues that contain the projects, adding a `projects` (or similar) label. This is in the spirit also of other large quantum open source projects such as Qiskit, which has even an ad-hoc `qiskit-community` repository, https://github.com/qiskit-community/. In QuTiP case, we could create a new repository similar to the notebooks one, e.g., https://github.com/qutip/qutip-community/. The downside is t",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1132
https://github.com/qutip/qutip/issues/1132:2660,Integrability,integrat,integrate,2660,"heir projects, beginning in priority from the lead developers. . ## Other Funding Schemes; Similarly, I have been writing NumFOCUS [small development grants](https://numfocus.org/blog/fall-2018-open-source-development-grants), which have a different goal but can be set up similarly. Also, in the future we may apply again to [Google Season of Docs](https://developers.google.com/season-of-docs). . ## Future Opportunities; Several senior researchers and team leaders have aired the desire to contribute to the project more actively. Setting up a space where they can propose projects, even on their own funding resources (most probably together with the development of research projects), in coordination with the lead development team, could help foster development in a more sustainable way. . ## Proposal; I propose to help sustain available projects in a more structural way than what is done now. This is an example of a what we could call a **QEP, or ""QuTiP Enhancement Proposal"".**. - One thing that could be done is to simply expand the existing Wiki. The downside of taking only this action is that only organization members can modify the wiki. So this could work, but mainly as a more static and cleaner staple. . - I propose to integrate the Wiki with Issues that contain the projects, adding a `projects` (or similar) label. This is in the spirit also of other large quantum open source projects such as Qiskit, which has even an ad-hoc `qiskit-community` repository, https://github.com/qiskit-community/. In QuTiP case, we could create a new repository similar to the notebooks one, e.g., https://github.com/qutip/qutip-community/. The downside is that in general the division is subfolders is not advised for easiness of maintainability. So one could just open issues with open projects. Of course, for physics questions, sometimes spilling in to PRs and Issues, qutip already has a Google Group forum, where I advise that this new capabilities may be advertised with a proper thread.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1132
https://github.com/qutip/qutip/issues/1132:360,Modifiability,enhance,enhance,360,"QuTiP development is now based on a large community of continuous users and a smaller group of sporadic developers. Some developers continuously contribute to the development. . The nature of QuTiP, at the frontier of quantum physics research, implies that the development of new modules sometimes overlaps or stems from research projects. It could be nice to enhance the rate of contribution and mentoring from the users community in the spirit of openness and scalability. . ## GSoC and Wiki; An example of project ideas has been provided by the [Google Summer of Code 2019](https://numfocus.org/programs/google-summer-code), for which various researchers and coders, even if not directly part of the lead development team, proposed new projects on the [Wiki](https://github.com/qutip/qutip/wiki//Google-Summer-of-Code-2019). Two of these ideas were eventually brought forth by two students to develop their own projects over the summer. . The details are here https://gsoc2019-boxili.blogspot.com/ and here https://latticemodelfunctions.blogspot.com/. ## KWoC; I applied to the Kharagpur Winter of Code ([KWoC](https://kwoc.kossiitkgp.org/)) where mainly BSc and also MSc / PhDs can participate over the winter to a project on QuTiP. QuTiP just got selected and there is the opportunity for students projects over the winter. I will begin with proposing mine, but this is an opportunity also for mentors to propose their projects, beginning in priority from the lead developers. . ## Other Funding Schemes; Similarly, I have been writing NumFOCUS [small development grants](https://numfocus.org/blog/fall-2018-open-source-development-grants), which have a different goal but can be set up similarly. Also, in the future we may apply again to [Google Season of Docs](https://developers.google.com/season-of-docs). . ## Future Opportunities; Several senior researchers and team leaders have aired the desire to contribute to the project more actively. Setting up a space where they can propose projec",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1132
https://github.com/qutip/qutip/issues/1132:2384,Modifiability,Enhance,Enhancement,2384,"but this is an opportunity also for mentors to propose their projects, beginning in priority from the lead developers. . ## Other Funding Schemes; Similarly, I have been writing NumFOCUS [small development grants](https://numfocus.org/blog/fall-2018-open-source-development-grants), which have a different goal but can be set up similarly. Also, in the future we may apply again to [Google Season of Docs](https://developers.google.com/season-of-docs). . ## Future Opportunities; Several senior researchers and team leaders have aired the desire to contribute to the project more actively. Setting up a space where they can propose projects, even on their own funding resources (most probably together with the development of research projects), in coordination with the lead development team, could help foster development in a more sustainable way. . ## Proposal; I propose to help sustain available projects in a more structural way than what is done now. This is an example of a what we could call a **QEP, or ""QuTiP Enhancement Proposal"".**. - One thing that could be done is to simply expand the existing Wiki. The downside of taking only this action is that only organization members can modify the wiki. So this could work, but mainly as a more static and cleaner staple. . - I propose to integrate the Wiki with Issues that contain the projects, adding a `projects` (or similar) label. This is in the spirit also of other large quantum open source projects such as Qiskit, which has even an ad-hoc `qiskit-community` repository, https://github.com/qiskit-community/. In QuTiP case, we could create a new repository similar to the notebooks one, e.g., https://github.com/qutip/qutip-community/. The downside is that in general the division is subfolders is not advised for easiness of maintainability. So one could just open issues with open projects. Of course, for physics questions, sometimes spilling in to PRs and Issues, qutip already has a Google Group forum, where I advise that this n",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1132
https://github.com/qutip/qutip/issues/1132:3156,Modifiability,maintainab,maintainability,3156,"heir projects, beginning in priority from the lead developers. . ## Other Funding Schemes; Similarly, I have been writing NumFOCUS [small development grants](https://numfocus.org/blog/fall-2018-open-source-development-grants), which have a different goal but can be set up similarly. Also, in the future we may apply again to [Google Season of Docs](https://developers.google.com/season-of-docs). . ## Future Opportunities; Several senior researchers and team leaders have aired the desire to contribute to the project more actively. Setting up a space where they can propose projects, even on their own funding resources (most probably together with the development of research projects), in coordination with the lead development team, could help foster development in a more sustainable way. . ## Proposal; I propose to help sustain available projects in a more structural way than what is done now. This is an example of a what we could call a **QEP, or ""QuTiP Enhancement Proposal"".**. - One thing that could be done is to simply expand the existing Wiki. The downside of taking only this action is that only organization members can modify the wiki. So this could work, but mainly as a more static and cleaner staple. . - I propose to integrate the Wiki with Issues that contain the projects, adding a `projects` (or similar) label. This is in the spirit also of other large quantum open source projects such as Qiskit, which has even an ad-hoc `qiskit-community` repository, https://github.com/qiskit-community/. In QuTiP case, we could create a new repository similar to the notebooks one, e.g., https://github.com/qutip/qutip-community/. The downside is that in general the division is subfolders is not advised for easiness of maintainability. So one could just open issues with open projects. Of course, for physics questions, sometimes spilling in to PRs and Issues, qutip already has a Google Group forum, where I advise that this new capabilities may be advertised with a proper thread.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1132
https://github.com/qutip/qutip/issues/1132:462,Performance,scalab,scalability,462,"QuTiP development is now based on a large community of continuous users and a smaller group of sporadic developers. Some developers continuously contribute to the development. . The nature of QuTiP, at the frontier of quantum physics research, implies that the development of new modules sometimes overlaps or stems from research projects. It could be nice to enhance the rate of contribution and mentoring from the users community in the spirit of openness and scalability. . ## GSoC and Wiki; An example of project ideas has been provided by the [Google Summer of Code 2019](https://numfocus.org/programs/google-summer-code), for which various researchers and coders, even if not directly part of the lead development team, proposed new projects on the [Wiki](https://github.com/qutip/qutip/wiki//Google-Summer-of-Code-2019). Two of these ideas were eventually brought forth by two students to develop their own projects over the summer. . The details are here https://gsoc2019-boxili.blogspot.com/ and here https://latticemodelfunctions.blogspot.com/. ## KWoC; I applied to the Kharagpur Winter of Code ([KWoC](https://kwoc.kossiitkgp.org/)) where mainly BSc and also MSc / PhDs can participate over the winter to a project on QuTiP. QuTiP just got selected and there is the opportunity for students projects over the winter. I will begin with proposing mine, but this is an opportunity also for mentors to propose their projects, beginning in priority from the lead developers. . ## Other Funding Schemes; Similarly, I have been writing NumFOCUS [small development grants](https://numfocus.org/blog/fall-2018-open-source-development-grants), which have a different goal but can be set up similarly. Also, in the future we may apply again to [Google Season of Docs](https://developers.google.com/season-of-docs). . ## Future Opportunities; Several senior researchers and team leaders have aired the desire to contribute to the project more actively. Setting up a space where they can propose projec",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1132
https://github.com/qutip/qutip/issues/1132:2447,Usability,simpl,simply,2447,"heir projects, beginning in priority from the lead developers. . ## Other Funding Schemes; Similarly, I have been writing NumFOCUS [small development grants](https://numfocus.org/blog/fall-2018-open-source-development-grants), which have a different goal but can be set up similarly. Also, in the future we may apply again to [Google Season of Docs](https://developers.google.com/season-of-docs). . ## Future Opportunities; Several senior researchers and team leaders have aired the desire to contribute to the project more actively. Setting up a space where they can propose projects, even on their own funding resources (most probably together with the development of research projects), in coordination with the lead development team, could help foster development in a more sustainable way. . ## Proposal; I propose to help sustain available projects in a more structural way than what is done now. This is an example of a what we could call a **QEP, or ""QuTiP Enhancement Proposal"".**. - One thing that could be done is to simply expand the existing Wiki. The downside of taking only this action is that only organization members can modify the wiki. So this could work, but mainly as a more static and cleaner staple. . - I propose to integrate the Wiki with Issues that contain the projects, adding a `projects` (or similar) label. This is in the spirit also of other large quantum open source projects such as Qiskit, which has even an ad-hoc `qiskit-community` repository, https://github.com/qiskit-community/. In QuTiP case, we could create a new repository similar to the notebooks one, e.g., https://github.com/qutip/qutip-community/. The downside is that in general the division is subfolders is not advised for easiness of maintainability. So one could just open issues with open projects. Of course, for physics questions, sometimes spilling in to PRs and Issues, qutip already has a Google Group forum, where I advise that this new capabilities may be advertised with a proper thread.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1132
https://github.com/qutip/qutip/issues/1133:186,Deployability,update,updated,186,"Running `travis lint` gives a bunch of warning. Like for instance, `sudo : required` is no longer needed, and Travis migrated to a new architecture. So the `travis.yml` file needs to be updated. https://blog.travis-ci.com/2018-10-04-combining-linux-infrastructures",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1133
https://github.com/qutip/qutip/issues/1134:78,Testability,test,test,78,"While trying to migrate to pytest from nose , #1131, there is only one failed test arising on all platforms. ; The problem seems to be a test in the `control` module, exactly it is `qutip.tests.test_control_pulseoptim.TestPulseOptim` called by `test_03_dumping(self):` on line 340. . ```; AttributeError: 'TestPulseOptim' object has no attribute 'tmp_dirs'; ```; Indeed, TestPulseOptim seems to have this attribute where `tmp_dirs`; are defined, ; ```; def setUp(self):; # list of file paths to be removed after test; self.tmp_files = []; # list of folder paths to be removed after test; self.tmp_dirs = []; ```; Any help @tehruhn and @ajgpitch would be great. I think one should call `setUp`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1134
https://github.com/qutip/qutip/issues/1134:137,Testability,test,test,137,"While trying to migrate to pytest from nose , #1131, there is only one failed test arising on all platforms. ; The problem seems to be a test in the `control` module, exactly it is `qutip.tests.test_control_pulseoptim.TestPulseOptim` called by `test_03_dumping(self):` on line 340. . ```; AttributeError: 'TestPulseOptim' object has no attribute 'tmp_dirs'; ```; Indeed, TestPulseOptim seems to have this attribute where `tmp_dirs`; are defined, ; ```; def setUp(self):; # list of file paths to be removed after test; self.tmp_files = []; # list of folder paths to be removed after test; self.tmp_dirs = []; ```; Any help @tehruhn and @ajgpitch would be great. I think one should call `setUp`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1134
https://github.com/qutip/qutip/issues/1134:188,Testability,test,tests,188,"While trying to migrate to pytest from nose , #1131, there is only one failed test arising on all platforms. ; The problem seems to be a test in the `control` module, exactly it is `qutip.tests.test_control_pulseoptim.TestPulseOptim` called by `test_03_dumping(self):` on line 340. . ```; AttributeError: 'TestPulseOptim' object has no attribute 'tmp_dirs'; ```; Indeed, TestPulseOptim seems to have this attribute where `tmp_dirs`; are defined, ; ```; def setUp(self):; # list of file paths to be removed after test; self.tmp_files = []; # list of folder paths to be removed after test; self.tmp_dirs = []; ```; Any help @tehruhn and @ajgpitch would be great. I think one should call `setUp`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1134
https://github.com/qutip/qutip/issues/1134:218,Testability,Test,TestPulseOptim,218,"While trying to migrate to pytest from nose , #1131, there is only one failed test arising on all platforms. ; The problem seems to be a test in the `control` module, exactly it is `qutip.tests.test_control_pulseoptim.TestPulseOptim` called by `test_03_dumping(self):` on line 340. . ```; AttributeError: 'TestPulseOptim' object has no attribute 'tmp_dirs'; ```; Indeed, TestPulseOptim seems to have this attribute where `tmp_dirs`; are defined, ; ```; def setUp(self):; # list of file paths to be removed after test; self.tmp_files = []; # list of folder paths to be removed after test; self.tmp_dirs = []; ```; Any help @tehruhn and @ajgpitch would be great. I think one should call `setUp`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1134
https://github.com/qutip/qutip/issues/1134:306,Testability,Test,TestPulseOptim,306,"While trying to migrate to pytest from nose , #1131, there is only one failed test arising on all platforms. ; The problem seems to be a test in the `control` module, exactly it is `qutip.tests.test_control_pulseoptim.TestPulseOptim` called by `test_03_dumping(self):` on line 340. . ```; AttributeError: 'TestPulseOptim' object has no attribute 'tmp_dirs'; ```; Indeed, TestPulseOptim seems to have this attribute where `tmp_dirs`; are defined, ; ```; def setUp(self):; # list of file paths to be removed after test; self.tmp_files = []; # list of folder paths to be removed after test; self.tmp_dirs = []; ```; Any help @tehruhn and @ajgpitch would be great. I think one should call `setUp`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1134
https://github.com/qutip/qutip/issues/1134:371,Testability,Test,TestPulseOptim,371,"While trying to migrate to pytest from nose , #1131, there is only one failed test arising on all platforms. ; The problem seems to be a test in the `control` module, exactly it is `qutip.tests.test_control_pulseoptim.TestPulseOptim` called by `test_03_dumping(self):` on line 340. . ```; AttributeError: 'TestPulseOptim' object has no attribute 'tmp_dirs'; ```; Indeed, TestPulseOptim seems to have this attribute where `tmp_dirs`; are defined, ; ```; def setUp(self):; # list of file paths to be removed after test; self.tmp_files = []; # list of folder paths to be removed after test; self.tmp_dirs = []; ```; Any help @tehruhn and @ajgpitch would be great. I think one should call `setUp`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1134
https://github.com/qutip/qutip/issues/1134:512,Testability,test,test,512,"While trying to migrate to pytest from nose , #1131, there is only one failed test arising on all platforms. ; The problem seems to be a test in the `control` module, exactly it is `qutip.tests.test_control_pulseoptim.TestPulseOptim` called by `test_03_dumping(self):` on line 340. . ```; AttributeError: 'TestPulseOptim' object has no attribute 'tmp_dirs'; ```; Indeed, TestPulseOptim seems to have this attribute where `tmp_dirs`; are defined, ; ```; def setUp(self):; # list of file paths to be removed after test; self.tmp_files = []; # list of folder paths to be removed after test; self.tmp_dirs = []; ```; Any help @tehruhn and @ajgpitch would be great. I think one should call `setUp`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1134
https://github.com/qutip/qutip/issues/1134:582,Testability,test,test,582,"While trying to migrate to pytest from nose , #1131, there is only one failed test arising on all platforms. ; The problem seems to be a test in the `control` module, exactly it is `qutip.tests.test_control_pulseoptim.TestPulseOptim` called by `test_03_dumping(self):` on line 340. . ```; AttributeError: 'TestPulseOptim' object has no attribute 'tmp_dirs'; ```; Indeed, TestPulseOptim seems to have this attribute where `tmp_dirs`; are defined, ; ```; def setUp(self):; # list of file paths to be removed after test; self.tmp_files = []; # list of folder paths to be removed after test; self.tmp_dirs = []; ```; Any help @tehruhn and @ajgpitch would be great. I think one should call `setUp`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1134
https://github.com/qutip/qutip/issues/1135:62,Usability,guid,guidelines,62,"There are two places where one can read about the development guidelines. One is ; on `qutip/qutip`'s Wiki page:; https://github.com/qutip/qutip/wiki/QuTiP-Development-Guidelines. The other one is in `[qutip-doc/qutip_dev_contrib.md`](https://github.com/qutip/qutip-doc/blob/2ffd6d1cc581e858674d43fe97a9297e9476a278/qutip_dev_contrib.md). I see that we may want both to be there, but I guess they should contain the same information and possibly cross-reference each other.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1135
https://github.com/qutip/qutip/issues/1135:168,Usability,Guid,Guidelines,168,"There are two places where one can read about the development guidelines. One is ; on `qutip/qutip`'s Wiki page:; https://github.com/qutip/qutip/wiki/QuTiP-Development-Guidelines. The other one is in `[qutip-doc/qutip_dev_contrib.md`](https://github.com/qutip/qutip-doc/blob/2ffd6d1cc581e858674d43fe97a9297e9476a278/qutip_dev_contrib.md). I see that we may want both to be there, but I guess they should contain the same information and possibly cross-reference each other.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1135
https://github.com/qutip/qutip/issues/1136:2348,Availability,avail,available,2348,"ture using options. . The best signature I believe is `f(t, **args)` since it allows to use more natural function call using kwargs (`f(t, w=0, a=1)`). However, it is the slowest in the #1123 implementation (up to 10x): some items are added to `args` for internal use and they need to be filtered at each call. It could be brought to 2.5x with some work, but no better. `f(t)` is about 2x slower than `f(t, args)`. But it's less agile: if the Hamiltonian use `f(t, w1=0)`, we cannot add a c_ops using `f(t, w2=0)`, both function must accept `w1` and `w2`. `args` could just hide unused items. Which ever we choose as the main one will be 2~3x faster than the other. We can have automatic detection of the signature if we want to be fancy. Which signature do you think is better?. Second, these function can depend on the state with the option `rhs_with_state`. Thus the coefficients are `f(t, state, args)` with `state` a 1D numpy array.; When making QobjEvo, I added special `args`' keys that indicate that the value should be updated with the state: setting `args = {""val=Qobj"":psi0, ""val"":psi0}` would tell `args[""val""]` to be updated with the state at each use in the solver. The state can be obtained as Qobj, np.array or the args could be updated to be the expectation value of another Qobj.; There are some bug for it in master presently but it will work with PR #1127. Using these special keys for this work well but they need to be removed for the new signature candidate (`f(t, **args)`). Also you cannot remove / fix to a constant them once declared. Since they are not used/working yet, now is the time to change to something better. I could see 2 other options:; - reserved keys: `args = {""state_vec"":psi0}`, this will always be the state (np.array) if available.; -- collapse are less practical this way.; - special values: `args = {""state_vec"":qt.feedback(""vec"")}`. This seems the most natural to me since the value is what change. . I would appreciate feedback and ideas on the issue.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1136
https://github.com/qutip/qutip/issues/1136:1610,Deployability,update,updated,1610,"ture using options. . The best signature I believe is `f(t, **args)` since it allows to use more natural function call using kwargs (`f(t, w=0, a=1)`). However, it is the slowest in the #1123 implementation (up to 10x): some items are added to `args` for internal use and they need to be filtered at each call. It could be brought to 2.5x with some work, but no better. `f(t)` is about 2x slower than `f(t, args)`. But it's less agile: if the Hamiltonian use `f(t, w1=0)`, we cannot add a c_ops using `f(t, w2=0)`, both function must accept `w1` and `w2`. `args` could just hide unused items. Which ever we choose as the main one will be 2~3x faster than the other. We can have automatic detection of the signature if we want to be fancy. Which signature do you think is better?. Second, these function can depend on the state with the option `rhs_with_state`. Thus the coefficients are `f(t, state, args)` with `state` a 1D numpy array.; When making QobjEvo, I added special `args`' keys that indicate that the value should be updated with the state: setting `args = {""val=Qobj"":psi0, ""val"":psi0}` would tell `args[""val""]` to be updated with the state at each use in the solver. The state can be obtained as Qobj, np.array or the args could be updated to be the expectation value of another Qobj.; There are some bug for it in master presently but it will work with PR #1127. Using these special keys for this work well but they need to be removed for the new signature candidate (`f(t, **args)`). Also you cannot remove / fix to a constant them once declared. Since they are not used/working yet, now is the time to change to something better. I could see 2 other options:; - reserved keys: `args = {""state_vec"":psi0}`, this will always be the state (np.array) if available.; -- collapse are less practical this way.; - special values: `args = {""state_vec"":qt.feedback(""vec"")}`. This seems the most natural to me since the value is what change. . I would appreciate feedback and ideas on the issue.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1136
https://github.com/qutip/qutip/issues/1136:1712,Deployability,update,updated,1712,"ture using options. . The best signature I believe is `f(t, **args)` since it allows to use more natural function call using kwargs (`f(t, w=0, a=1)`). However, it is the slowest in the #1123 implementation (up to 10x): some items are added to `args` for internal use and they need to be filtered at each call. It could be brought to 2.5x with some work, but no better. `f(t)` is about 2x slower than `f(t, args)`. But it's less agile: if the Hamiltonian use `f(t, w1=0)`, we cannot add a c_ops using `f(t, w2=0)`, both function must accept `w1` and `w2`. `args` could just hide unused items. Which ever we choose as the main one will be 2~3x faster than the other. We can have automatic detection of the signature if we want to be fancy. Which signature do you think is better?. Second, these function can depend on the state with the option `rhs_with_state`. Thus the coefficients are `f(t, state, args)` with `state` a 1D numpy array.; When making QobjEvo, I added special `args`' keys that indicate that the value should be updated with the state: setting `args = {""val=Qobj"":psi0, ""val"":psi0}` would tell `args[""val""]` to be updated with the state at each use in the solver. The state can be obtained as Qobj, np.array or the args could be updated to be the expectation value of another Qobj.; There are some bug for it in master presently but it will work with PR #1127. Using these special keys for this work well but they need to be removed for the new signature candidate (`f(t, **args)`). Also you cannot remove / fix to a constant them once declared. Since they are not used/working yet, now is the time to change to something better. I could see 2 other options:; - reserved keys: `args = {""state_vec"":psi0}`, this will always be the state (np.array) if available.; -- collapse are less practical this way.; - special values: `args = {""state_vec"":qt.feedback(""vec"")}`. This seems the most natural to me since the value is what change. . I would appreciate feedback and ideas on the issue.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1136
https://github.com/qutip/qutip/issues/1136:1827,Deployability,update,updated,1827,"ture using options. . The best signature I believe is `f(t, **args)` since it allows to use more natural function call using kwargs (`f(t, w=0, a=1)`). However, it is the slowest in the #1123 implementation (up to 10x): some items are added to `args` for internal use and they need to be filtered at each call. It could be brought to 2.5x with some work, but no better. `f(t)` is about 2x slower than `f(t, args)`. But it's less agile: if the Hamiltonian use `f(t, w1=0)`, we cannot add a c_ops using `f(t, w2=0)`, both function must accept `w1` and `w2`. `args` could just hide unused items. Which ever we choose as the main one will be 2~3x faster than the other. We can have automatic detection of the signature if we want to be fancy. Which signature do you think is better?. Second, these function can depend on the state with the option `rhs_with_state`. Thus the coefficients are `f(t, state, args)` with `state` a 1D numpy array.; When making QobjEvo, I added special `args`' keys that indicate that the value should be updated with the state: setting `args = {""val=Qobj"":psi0, ""val"":psi0}` would tell `args[""val""]` to be updated with the state at each use in the solver. The state can be obtained as Qobj, np.array or the args could be updated to be the expectation value of another Qobj.; There are some bug for it in master presently but it will work with PR #1127. Using these special keys for this work well but they need to be removed for the new signature candidate (`f(t, **args)`). Also you cannot remove / fix to a constant them once declared. Since they are not used/working yet, now is the time to change to something better. I could see 2 other options:; - reserved keys: `args = {""state_vec"":psi0}`, this will always be the state (np.array) if available.; -- collapse are less practical this way.; - special values: `args = {""state_vec"":qt.feedback(""vec"")}`. This seems the most natural to me since the value is what change. . I would appreciate feedback and ideas on the issue.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1136
https://github.com/qutip/qutip/issues/1136:57,Integrability,depend,dependent,57,"Hi,; I want to discuss 2 points about how we manage time dependent Hamiltonian, relating to the discussion started on qucontrol/krotov#56. First, presently function coefficients are defined as:; ```; def f(t, args):; return ...; ```; With `args` is a dictionary containing extra variables to pass to the function. For backward compatibility; ```; def f(t, state, args):; return ...; ```; is also accepted if the option `rhs_with_state` is set to `True`. . But there have been demand to accept more signatures: `f(t)` and `f(t, **args)`. PR #1123, when ready, should allow both signature using options. . The best signature I believe is `f(t, **args)` since it allows to use more natural function call using kwargs (`f(t, w=0, a=1)`). However, it is the slowest in the #1123 implementation (up to 10x): some items are added to `args` for internal use and they need to be filtered at each call. It could be brought to 2.5x with some work, but no better. `f(t)` is about 2x slower than `f(t, args)`. But it's less agile: if the Hamiltonian use `f(t, w1=0)`, we cannot add a c_ops using `f(t, w2=0)`, both function must accept `w1` and `w2`. `args` could just hide unused items. Which ever we choose as the main one will be 2~3x faster than the other. We can have automatic detection of the signature if we want to be fancy. Which signature do you think is better?. Second, these function can depend on the state with the option `rhs_with_state`. Thus the coefficients are `f(t, state, args)` with `state` a 1D numpy array.; When making QobjEvo, I added special `args`' keys that indicate that the value should be updated with the state: setting `args = {""val=Qobj"":psi0, ""val"":psi0}` would tell `args[""val""]` to be updated with the state at each use in the solver. The state can be obtained as Qobj, np.array or the args could be updated to be the expectation value of another Qobj.; There are some bug for it in master presently but it will work with PR #1127. Using these special keys for this work wel",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1136
https://github.com/qutip/qutip/issues/1136:1389,Integrability,depend,depend,1389,"ted if the option `rhs_with_state` is set to `True`. . But there have been demand to accept more signatures: `f(t)` and `f(t, **args)`. PR #1123, when ready, should allow both signature using options. . The best signature I believe is `f(t, **args)` since it allows to use more natural function call using kwargs (`f(t, w=0, a=1)`). However, it is the slowest in the #1123 implementation (up to 10x): some items are added to `args` for internal use and they need to be filtered at each call. It could be brought to 2.5x with some work, but no better. `f(t)` is about 2x slower than `f(t, args)`. But it's less agile: if the Hamiltonian use `f(t, w1=0)`, we cannot add a c_ops using `f(t, w2=0)`, both function must accept `w1` and `w2`. `args` could just hide unused items. Which ever we choose as the main one will be 2~3x faster than the other. We can have automatic detection of the signature if we want to be fancy. Which signature do you think is better?. Second, these function can depend on the state with the option `rhs_with_state`. Thus the coefficients are `f(t, state, args)` with `state` a 1D numpy array.; When making QobjEvo, I added special `args`' keys that indicate that the value should be updated with the state: setting `args = {""val=Qobj"":psi0, ""val"":psi0}` would tell `args[""val""]` to be updated with the state at each use in the solver. The state can be obtained as Qobj, np.array or the args could be updated to be the expectation value of another Qobj.; There are some bug for it in master presently but it will work with PR #1127. Using these special keys for this work well but they need to be removed for the new signature candidate (`f(t, **args)`). Also you cannot remove / fix to a constant them once declared. Since they are not used/working yet, now is the time to change to something better. I could see 2 other options:; - reserved keys: `args = {""state_vec"":psi0}`, this will always be the state (np.array) if available.; -- collapse are less practical this way.; ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1136
https://github.com/qutip/qutip/issues/1136:279,Modifiability,variab,variables,279,"Hi,; I want to discuss 2 points about how we manage time dependent Hamiltonian, relating to the discussion started on qucontrol/krotov#56. First, presently function coefficients are defined as:; ```; def f(t, args):; return ...; ```; With `args` is a dictionary containing extra variables to pass to the function. For backward compatibility; ```; def f(t, state, args):; return ...; ```; is also accepted if the option `rhs_with_state` is set to `True`. . But there have been demand to accept more signatures: `f(t)` and `f(t, **args)`. PR #1123, when ready, should allow both signature using options. . The best signature I believe is `f(t, **args)` since it allows to use more natural function call using kwargs (`f(t, w=0, a=1)`). However, it is the slowest in the #1123 implementation (up to 10x): some items are added to `args` for internal use and they need to be filtered at each call. It could be brought to 2.5x with some work, but no better. `f(t)` is about 2x slower than `f(t, args)`. But it's less agile: if the Hamiltonian use `f(t, w1=0)`, we cannot add a c_ops using `f(t, w2=0)`, both function must accept `w1` and `w2`. `args` could just hide unused items. Which ever we choose as the main one will be 2~3x faster than the other. We can have automatic detection of the signature if we want to be fancy. Which signature do you think is better?. Second, these function can depend on the state with the option `rhs_with_state`. Thus the coefficients are `f(t, state, args)` with `state` a 1D numpy array.; When making QobjEvo, I added special `args`' keys that indicate that the value should be updated with the state: setting `args = {""val=Qobj"":psi0, ""val"":psi0}` would tell `args[""val""]` to be updated with the state at each use in the solver. The state can be obtained as Qobj, np.array or the args could be updated to be the expectation value of another Qobj.; There are some bug for it in master presently but it will work with PR #1127. Using these special keys for this work wel",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1136
https://github.com/qutip/qutip/issues/1136:1270,Safety,detect,detection,1270,"ables to pass to the function. For backward compatibility; ```; def f(t, state, args):; return ...; ```; is also accepted if the option `rhs_with_state` is set to `True`. . But there have been demand to accept more signatures: `f(t)` and `f(t, **args)`. PR #1123, when ready, should allow both signature using options. . The best signature I believe is `f(t, **args)` since it allows to use more natural function call using kwargs (`f(t, w=0, a=1)`). However, it is the slowest in the #1123 implementation (up to 10x): some items are added to `args` for internal use and they need to be filtered at each call. It could be brought to 2.5x with some work, but no better. `f(t)` is about 2x slower than `f(t, args)`. But it's less agile: if the Hamiltonian use `f(t, w1=0)`, we cannot add a c_ops using `f(t, w2=0)`, both function must accept `w1` and `w2`. `args` could just hide unused items. Which ever we choose as the main one will be 2~3x faster than the other. We can have automatic detection of the signature if we want to be fancy. Which signature do you think is better?. Second, these function can depend on the state with the option `rhs_with_state`. Thus the coefficients are `f(t, state, args)` with `state` a 1D numpy array.; When making QobjEvo, I added special `args`' keys that indicate that the value should be updated with the state: setting `args = {""val=Qobj"":psi0, ""val"":psi0}` would tell `args[""val""]` to be updated with the state at each use in the solver. The state can be obtained as Qobj, np.array or the args could be updated to be the expectation value of another Qobj.; There are some bug for it in master presently but it will work with PR #1127. Using these special keys for this work well but they need to be removed for the new signature candidate (`f(t, **args)`). Also you cannot remove / fix to a constant them once declared. Since they are not used/working yet, now is the time to change to something better. I could see 2 other options:; - reserved keys: `args = {",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1136
https://github.com/qutip/qutip/issues/1136:2444,Usability,feedback,feedback,2444,"ture using options. . The best signature I believe is `f(t, **args)` since it allows to use more natural function call using kwargs (`f(t, w=0, a=1)`). However, it is the slowest in the #1123 implementation (up to 10x): some items are added to `args` for internal use and they need to be filtered at each call. It could be brought to 2.5x with some work, but no better. `f(t)` is about 2x slower than `f(t, args)`. But it's less agile: if the Hamiltonian use `f(t, w1=0)`, we cannot add a c_ops using `f(t, w2=0)`, both function must accept `w1` and `w2`. `args` could just hide unused items. Which ever we choose as the main one will be 2~3x faster than the other. We can have automatic detection of the signature if we want to be fancy. Which signature do you think is better?. Second, these function can depend on the state with the option `rhs_with_state`. Thus the coefficients are `f(t, state, args)` with `state` a 1D numpy array.; When making QobjEvo, I added special `args`' keys that indicate that the value should be updated with the state: setting `args = {""val=Qobj"":psi0, ""val"":psi0}` would tell `args[""val""]` to be updated with the state at each use in the solver. The state can be obtained as Qobj, np.array or the args could be updated to be the expectation value of another Qobj.; There are some bug for it in master presently but it will work with PR #1127. Using these special keys for this work well but they need to be removed for the new signature candidate (`f(t, **args)`). Also you cannot remove / fix to a constant them once declared. Since they are not used/working yet, now is the time to change to something better. I could see 2 other options:; - reserved keys: `args = {""state_vec"":psi0}`, this will always be the state (np.array) if available.; -- collapse are less practical this way.; - special values: `args = {""state_vec"":qt.feedback(""vec"")}`. This seems the most natural to me since the value is what change. . I would appreciate feedback and ideas on the issue.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1136
https://github.com/qutip/qutip/issues/1136:2550,Usability,feedback,feedback,2550,"ture using options. . The best signature I believe is `f(t, **args)` since it allows to use more natural function call using kwargs (`f(t, w=0, a=1)`). However, it is the slowest in the #1123 implementation (up to 10x): some items are added to `args` for internal use and they need to be filtered at each call. It could be brought to 2.5x with some work, but no better. `f(t)` is about 2x slower than `f(t, args)`. But it's less agile: if the Hamiltonian use `f(t, w1=0)`, we cannot add a c_ops using `f(t, w2=0)`, both function must accept `w1` and `w2`. `args` could just hide unused items. Which ever we choose as the main one will be 2~3x faster than the other. We can have automatic detection of the signature if we want to be fancy. Which signature do you think is better?. Second, these function can depend on the state with the option `rhs_with_state`. Thus the coefficients are `f(t, state, args)` with `state` a 1D numpy array.; When making QobjEvo, I added special `args`' keys that indicate that the value should be updated with the state: setting `args = {""val=Qobj"":psi0, ""val"":psi0}` would tell `args[""val""]` to be updated with the state at each use in the solver. The state can be obtained as Qobj, np.array or the args could be updated to be the expectation value of another Qobj.; There are some bug for it in master presently but it will work with PR #1127. Using these special keys for this work well but they need to be removed for the new signature candidate (`f(t, **args)`). Also you cannot remove / fix to a constant them once declared. Since they are not used/working yet, now is the time to change to something better. I could see 2 other options:; - reserved keys: `args = {""state_vec"":psi0}`, this will always be the state (np.array) if available.; -- collapse are less practical this way.; - special values: `args = {""state_vec"":qt.feedback(""vec"")}`. This seems the most natural to me since the value is what change. . I would appreciate feedback and ideas on the issue.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1136
https://github.com/qutip/qutip/pull/1138:168,Availability,avail,available,168,"It adds support for importing qasm v1 files. The support for quantum gates and loops are added. Support for classical control, measurement, and qbit preparation is not available and syntax is ignored.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1138
https://github.com/qutip/qutip/issues/1141:620,Deployability,toggle,toggle,620,"The current version of `clebsch` gives wildly incorrect results for high `j`, because it relies on the precise cancellation of extremely large quantities. This leads to incorrect answers for anything that depends on this function, such as the spin Wigner function for Rydberg atoms. Example of problem:. ```; clebsch(15, 15, 30, 0, 0, 0) ; > 7.03237620084722 ; clebsch(20, 20, 40, 0, 0, 0); > 8986860.153685257; clebsch(30, 30, 60, 0, 0, 0); > nan; ```. Is it possible to implement one of the many higher-precision methods to compute Clebsch-Gordan coefficients? If that would be slower, is it possible to add a flag to toggle between the methods?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1141
https://github.com/qutip/qutip/issues/1141:205,Integrability,depend,depends,205,"The current version of `clebsch` gives wildly incorrect results for high `j`, because it relies on the precise cancellation of extremely large quantities. This leads to incorrect answers for anything that depends on this function, such as the spin Wigner function for Rydberg atoms. Example of problem:. ```; clebsch(15, 15, 30, 0, 0, 0) ; > 7.03237620084722 ; clebsch(20, 20, 40, 0, 0, 0); > 8986860.153685257; clebsch(30, 30, 60, 0, 0, 0); > nan; ```. Is it possible to implement one of the many higher-precision methods to compute Clebsch-Gordan coefficients? If that would be slower, is it possible to add a flag to toggle between the methods?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1141
https://github.com/qutip/qutip/pull/1142:86,Availability,error,error,86,Rewrote `clebsch` function based on long integer fraction. Thus escaping the rounding error mentioned in #1141. Surprisingly it's a little faster than the float implementation. . Also added tests for the function. Closes #1141,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1142
https://github.com/qutip/qutip/pull/1142:190,Testability,test,tests,190,Rewrote `clebsch` function based on long integer fraction. Thus escaping the rounding error mentioned in #1141. Surprisingly it's a little faster than the float implementation. . Also added tests for the function. Closes #1141,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1142
https://github.com/qutip/qutip/issues/1147:226,Testability,test,test,226,I am packaging qutip for [nixpkgs](https://github.com/NixOS/nixpkgs) https://github.com/NixOS/nixpkgs/pull/76661 from version 2.2.0 -> 4.4.1. Right now the only issue with the build is that qutip takes way too long to run the test suite in proportion to its usage in nixpkgs. Do you have a recommended set of tests that we should run? For nixpkgs I will likely just delete some of these files https://github.com/qutip/qutip/tree/master/qutip/tests. Currently the test suite takes around 2 hours and would like to get it to around 10 minutes or less.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1147
https://github.com/qutip/qutip/issues/1147:309,Testability,test,tests,309,I am packaging qutip for [nixpkgs](https://github.com/NixOS/nixpkgs) https://github.com/NixOS/nixpkgs/pull/76661 from version 2.2.0 -> 4.4.1. Right now the only issue with the build is that qutip takes way too long to run the test suite in proportion to its usage in nixpkgs. Do you have a recommended set of tests that we should run? For nixpkgs I will likely just delete some of these files https://github.com/qutip/qutip/tree/master/qutip/tests. Currently the test suite takes around 2 hours and would like to get it to around 10 minutes or less.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1147
https://github.com/qutip/qutip/issues/1147:442,Testability,test,tests,442,I am packaging qutip for [nixpkgs](https://github.com/NixOS/nixpkgs) https://github.com/NixOS/nixpkgs/pull/76661 from version 2.2.0 -> 4.4.1. Right now the only issue with the build is that qutip takes way too long to run the test suite in proportion to its usage in nixpkgs. Do you have a recommended set of tests that we should run? For nixpkgs I will likely just delete some of these files https://github.com/qutip/qutip/tree/master/qutip/tests. Currently the test suite takes around 2 hours and would like to get it to around 10 minutes or less.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1147
https://github.com/qutip/qutip/issues/1147:463,Testability,test,test,463,I am packaging qutip for [nixpkgs](https://github.com/NixOS/nixpkgs) https://github.com/NixOS/nixpkgs/pull/76661 from version 2.2.0 -> 4.4.1. Right now the only issue with the build is that qutip takes way too long to run the test suite in proportion to its usage in nixpkgs. Do you have a recommended set of tests that we should run? For nixpkgs I will likely just delete some of these files https://github.com/qutip/qutip/tree/master/qutip/tests. Currently the test suite takes around 2 hours and would like to get it to around 10 minutes or less.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1147
https://github.com/qutip/qutip/issues/1150:426,Availability,error,error,426,"I have a trouble in solving a time dependent Bloch-Redfield master equation with arguments.; Let me use an example discussed in [here](https://github.com/qutip/qutip/issues/966); The schedule functions of the time dependent Hamiltonian are defined by using some parameters which are passed to mesolve as args.; This method works well for sesolve and mesolve.; However, if I try to use the same method in brmesolve, it returns error in compiling Cython. I attached a python code which demonstrates the above observation. . I also noticed that in bloch_redfield.py it says; args : dict ; Placeholder for future implementation, kept for API consistency. Would it be possible to use arguments in brmesolve? If not, how could I use parametrically defined schedule functions while avoiding the issue raised in [here](https://github.com/qutip/qutip/issues/966)?. I need this for my research and I would appreciate your help very much. [Qutip Redfield master issue.py.zip](https://github.com/qutip/qutip/files/4028211/Qutip.Redfield.master.issue.py.zip)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1150
https://github.com/qutip/qutip/issues/1150:183,Energy Efficiency,schedul,schedule,183,"I have a trouble in solving a time dependent Bloch-Redfield master equation with arguments.; Let me use an example discussed in [here](https://github.com/qutip/qutip/issues/966); The schedule functions of the time dependent Hamiltonian are defined by using some parameters which are passed to mesolve as args.; This method works well for sesolve and mesolve.; However, if I try to use the same method in brmesolve, it returns error in compiling Cython. I attached a python code which demonstrates the above observation. . I also noticed that in bloch_redfield.py it says; args : dict ; Placeholder for future implementation, kept for API consistency. Would it be possible to use arguments in brmesolve? If not, how could I use parametrically defined schedule functions while avoiding the issue raised in [here](https://github.com/qutip/qutip/issues/966)?. I need this for my research and I would appreciate your help very much. [Qutip Redfield master issue.py.zip](https://github.com/qutip/qutip/files/4028211/Qutip.Redfield.master.issue.py.zip)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1150
https://github.com/qutip/qutip/issues/1150:750,Energy Efficiency,schedul,schedule,750,"I have a trouble in solving a time dependent Bloch-Redfield master equation with arguments.; Let me use an example discussed in [here](https://github.com/qutip/qutip/issues/966); The schedule functions of the time dependent Hamiltonian are defined by using some parameters which are passed to mesolve as args.; This method works well for sesolve and mesolve.; However, if I try to use the same method in brmesolve, it returns error in compiling Cython. I attached a python code which demonstrates the above observation. . I also noticed that in bloch_redfield.py it says; args : dict ; Placeholder for future implementation, kept for API consistency. Would it be possible to use arguments in brmesolve? If not, how could I use parametrically defined schedule functions while avoiding the issue raised in [here](https://github.com/qutip/qutip/issues/966)?. I need this for my research and I would appreciate your help very much. [Qutip Redfield master issue.py.zip](https://github.com/qutip/qutip/files/4028211/Qutip.Redfield.master.issue.py.zip)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1150
https://github.com/qutip/qutip/issues/1150:35,Integrability,depend,dependent,35,"I have a trouble in solving a time dependent Bloch-Redfield master equation with arguments.; Let me use an example discussed in [here](https://github.com/qutip/qutip/issues/966); The schedule functions of the time dependent Hamiltonian are defined by using some parameters which are passed to mesolve as args.; This method works well for sesolve and mesolve.; However, if I try to use the same method in brmesolve, it returns error in compiling Cython. I attached a python code which demonstrates the above observation. . I also noticed that in bloch_redfield.py it says; args : dict ; Placeholder for future implementation, kept for API consistency. Would it be possible to use arguments in brmesolve? If not, how could I use parametrically defined schedule functions while avoiding the issue raised in [here](https://github.com/qutip/qutip/issues/966)?. I need this for my research and I would appreciate your help very much. [Qutip Redfield master issue.py.zip](https://github.com/qutip/qutip/files/4028211/Qutip.Redfield.master.issue.py.zip)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1150
https://github.com/qutip/qutip/issues/1150:214,Integrability,depend,dependent,214,"I have a trouble in solving a time dependent Bloch-Redfield master equation with arguments.; Let me use an example discussed in [here](https://github.com/qutip/qutip/issues/966); The schedule functions of the time dependent Hamiltonian are defined by using some parameters which are passed to mesolve as args.; This method works well for sesolve and mesolve.; However, if I try to use the same method in brmesolve, it returns error in compiling Cython. I attached a python code which demonstrates the above observation. . I also noticed that in bloch_redfield.py it says; args : dict ; Placeholder for future implementation, kept for API consistency. Would it be possible to use arguments in brmesolve? If not, how could I use parametrically defined schedule functions while avoiding the issue raised in [here](https://github.com/qutip/qutip/issues/966)?. I need this for my research and I would appreciate your help very much. [Qutip Redfield master issue.py.zip](https://github.com/qutip/qutip/files/4028211/Qutip.Redfield.master.issue.py.zip)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1150
https://github.com/qutip/qutip/issues/1150:775,Safety,avoid,avoiding,775,"I have a trouble in solving a time dependent Bloch-Redfield master equation with arguments.; Let me use an example discussed in [here](https://github.com/qutip/qutip/issues/966); The schedule functions of the time dependent Hamiltonian are defined by using some parameters which are passed to mesolve as args.; This method works well for sesolve and mesolve.; However, if I try to use the same method in brmesolve, it returns error in compiling Cython. I attached a python code which demonstrates the above observation. . I also noticed that in bloch_redfield.py it says; args : dict ; Placeholder for future implementation, kept for API consistency. Would it be possible to use arguments in brmesolve? If not, how could I use parametrically defined schedule functions while avoiding the issue raised in [here](https://github.com/qutip/qutip/issues/966)?. I need this for my research and I would appreciate your help very much. [Qutip Redfield master issue.py.zip](https://github.com/qutip/qutip/files/4028211/Qutip.Redfield.master.issue.py.zip)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1150
https://github.com/qutip/qutip/pull/1151:24,Testability,test,test,24,"Mark some of the slower test to be skipped when running. `qutip.testing.run()`: about 5 min.; `qutip.testing.run(full=True)`: about 30 min. Keep test for every function: stochastic only test the default solver... ; Also speed up some test by limiting the tests (shorter time for solver, less ""pixel"" for wigner). Build on top of #1131, must be merged after that PR.; Should solve #1147",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1151
https://github.com/qutip/qutip/pull/1151:64,Testability,test,testing,64,"Mark some of the slower test to be skipped when running. `qutip.testing.run()`: about 5 min.; `qutip.testing.run(full=True)`: about 30 min. Keep test for every function: stochastic only test the default solver... ; Also speed up some test by limiting the tests (shorter time for solver, less ""pixel"" for wigner). Build on top of #1131, must be merged after that PR.; Should solve #1147",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1151
https://github.com/qutip/qutip/pull/1151:101,Testability,test,testing,101,"Mark some of the slower test to be skipped when running. `qutip.testing.run()`: about 5 min.; `qutip.testing.run(full=True)`: about 30 min. Keep test for every function: stochastic only test the default solver... ; Also speed up some test by limiting the tests (shorter time for solver, less ""pixel"" for wigner). Build on top of #1131, must be merged after that PR.; Should solve #1147",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1151
https://github.com/qutip/qutip/pull/1151:145,Testability,test,test,145,"Mark some of the slower test to be skipped when running. `qutip.testing.run()`: about 5 min.; `qutip.testing.run(full=True)`: about 30 min. Keep test for every function: stochastic only test the default solver... ; Also speed up some test by limiting the tests (shorter time for solver, less ""pixel"" for wigner). Build on top of #1131, must be merged after that PR.; Should solve #1147",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1151
https://github.com/qutip/qutip/pull/1151:186,Testability,test,test,186,"Mark some of the slower test to be skipped when running. `qutip.testing.run()`: about 5 min.; `qutip.testing.run(full=True)`: about 30 min. Keep test for every function: stochastic only test the default solver... ; Also speed up some test by limiting the tests (shorter time for solver, less ""pixel"" for wigner). Build on top of #1131, must be merged after that PR.; Should solve #1147",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1151
https://github.com/qutip/qutip/pull/1151:234,Testability,test,test,234,"Mark some of the slower test to be skipped when running. `qutip.testing.run()`: about 5 min.; `qutip.testing.run(full=True)`: about 30 min. Keep test for every function: stochastic only test the default solver... ; Also speed up some test by limiting the tests (shorter time for solver, less ""pixel"" for wigner). Build on top of #1131, must be merged after that PR.; Should solve #1147",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1151
https://github.com/qutip/qutip/pull/1151:255,Testability,test,tests,255,"Mark some of the slower test to be skipped when running. `qutip.testing.run()`: about 5 min.; `qutip.testing.run(full=True)`: about 30 min. Keep test for every function: stochastic only test the default solver... ; Also speed up some test by limiting the tests (shorter time for solver, less ""pixel"" for wigner). Build on top of #1131, must be merged after that PR.; Should solve #1147",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1151
https://github.com/qutip/qutip/issues/1152:184,Testability,test,tested,184,"When using qutip.propagator with unitary_mode='single' and parallel=False, the result does not have the same dims as the Hamiltonian, for other setting it does work.; Minimal example (tested with qutip 4.4.1):; ```; In [1]: import qutip . In [2]: H = qutip.tensor([qutip.qeye(2)]*2) . In [3]: H.dims ; Out[3]: [[2, 2], [2, 2]]. In [4]: qutip.propagator(H, 1 , unitary_mode='single', parallel=True).dims ; Out[4]: [[2, 2], [2, 2]]. In [5]: qutip.propagator(H, 1, unitary_mode='batch').dims ; Out[5]: [[2, 2], [2, 2]]. In [6]: qutip.propagator(H, 1 , unitary_mode='single').dims ; Out[6]: [[4], [4]]```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1152
https://github.com/qutip/qutip/pull/1154:7,Testability,test,test,7,"Openmp test on travis tend to hang at the calibration step.; The calibration function compute the matrix vector product with increasing size until the parallel version is faster or it give up. But on Travis, there is only 1 cpu, so the speed up is never observed and the calibration does not give up searching quickly enough. (Over 10min). In this PR:; - Skip calibration if only 1 cpu.; - Faster calibration by skipping some of the later size and testing only up to 100000 elements. (threshold around 1000 on my cpus); - Settings used in tests are fixed to use omp if compiled with it, even if slower. (thresh hold at 100)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1154
https://github.com/qutip/qutip/pull/1154:448,Testability,test,testing,448,"Openmp test on travis tend to hang at the calibration step.; The calibration function compute the matrix vector product with increasing size until the parallel version is faster or it give up. But on Travis, there is only 1 cpu, so the speed up is never observed and the calibration does not give up searching quickly enough. (Over 10min). In this PR:; - Skip calibration if only 1 cpu.; - Faster calibration by skipping some of the later size and testing only up to 100000 elements. (threshold around 1000 on my cpus); - Settings used in tests are fixed to use omp if compiled with it, even if slower. (thresh hold at 100)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1154
https://github.com/qutip/qutip/pull/1154:539,Testability,test,tests,539,"Openmp test on travis tend to hang at the calibration step.; The calibration function compute the matrix vector product with increasing size until the parallel version is faster or it give up. But on Travis, there is only 1 cpu, so the speed up is never observed and the calibration does not give up searching quickly enough. (Over 10min). In this PR:; - Skip calibration if only 1 cpu.; - Faster calibration by skipping some of the later size and testing only up to 100000 elements. (threshold around 1000 on my cpus); - Settings used in tests are fixed to use omp if compiled with it, even if slower. (thresh hold at 100)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1154
https://github.com/qutip/qutip/pull/1155:101,Deployability,release,released,101,"We have been talking about pulse level control in the `qip` device simulator for a while, but I just released that we didn't really define it in as separate ""pulse"". I find it really important and therefore I rewrite the data part of the `qip` numerical simulator as a new class `Pulse`. It's quite interesting that I end up to define a class very similar to `EvoElement` in `Qobjevo` (I called it `_EvoElement` for internal use, cannot find a better name). Instead of the full Hamiltonian, I only save the target qubits label and the non-trivial Hamiltonian (e.g. `sigmaz()` instead of `tensor(sigmaz(), identity(2)`). It is defined in this way for easy inspection after initialized, such as adding noise. `_EvoElement` consists of; - Hamlitonian; - Target qutbis label; - `tlist`; - `coeff`. `Pulse` consists of. - ideal part: `_Evoelement`; - coherent noise: list of `_Evoelement`; - lindblad noise: list of `_Evoelement`. The advantages are:; - A list of `Pulse `is easier to understand and manipulate compared to the old design: a list of H and a list of `coeff`. Now different `tlist `can also be defined for different pulses.; - Adding noise is much easier as we now can get the non-trivial part of the Hamiltonian and the targets of each pulse, instead of only a huge Hamiltonian in `QobjEvo`. One can now define noise for each Pulse. Still working on the docs.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1155
https://github.com/qutip/qutip/pull/1155:209,Modifiability,rewrite,rewrite,209,"We have been talking about pulse level control in the `qip` device simulator for a while, but I just released that we didn't really define it in as separate ""pulse"". I find it really important and therefore I rewrite the data part of the `qip` numerical simulator as a new class `Pulse`. It's quite interesting that I end up to define a class very similar to `EvoElement` in `Qobjevo` (I called it `_EvoElement` for internal use, cannot find a better name). Instead of the full Hamiltonian, I only save the target qubits label and the non-trivial Hamiltonian (e.g. `sigmaz()` instead of `tensor(sigmaz(), identity(2)`). It is defined in this way for easy inspection after initialized, such as adding noise. `_EvoElement` consists of; - Hamlitonian; - Target qutbis label; - `tlist`; - `coeff`. `Pulse` consists of. - ideal part: `_Evoelement`; - coherent noise: list of `_Evoelement`; - lindblad noise: list of `_Evoelement`. The advantages are:; - A list of `Pulse `is easier to understand and manipulate compared to the old design: a list of H and a list of `coeff`. Now different `tlist `can also be defined for different pulses.; - Adding noise is much easier as we now can get the non-trivial part of the Hamiltonian and the targets of each pulse, instead of only a huge Hamiltonian in `QobjEvo`. One can now define noise for each Pulse. Still working on the docs.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1155
https://github.com/qutip/qutip/issues/1156:1401,Deployability,install,installed,1401,"Hello,. I'm using qutip alongside another library, which does something like this:; ```py; import logging; logger = logging.getLogger(); logger.setLevel(logging.DEBUG); ```; Im not entirely sure why it does so, but nevertheless debug messages don't show up anywhere, since the root logger doesn't print anything without it being configured. If you run the above code in Ipython but add `import qutip` before it, `logging.debug(""foo"")` prints to the stderr (without qutip it doesn't). So when I started using the library with qutip, suddenly all debug messages started getting printed to stderr. Apparently, this is somewhat on purpose, by looking at the code [here](https://github.com/qutip/qutip/blob/eff1c3a606cad64b8d16f3232181b0463d65d746/qutip/logging_utils.py#L99). I'm not entirely sure what tho think about that, because as shown above this causes something unexpected. Nevertheless, I thought I could work around this by setting `log_handler = ""null""` in my settings file, but that in turn causes qutip to crash, because the rc loader [expects](https://github.com/qutip/qutip/blob/eff1c3a606cad64b8d16f3232181b0463d65d746/qutip/configrc.py#L97) `log_handler` to be a boolean for some reason. Also, it took me a while to find this, since the `log_handler` option is [not documented](http://qutip.org/docs/latest/guide/guide-settings.html?highlight=log). I'm using python 3.7.4 and QuTiP 4.4.1 installed with pip.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1156
https://github.com/qutip/qutip/issues/1156:234,Integrability,message,messages,234,"Hello,. I'm using qutip alongside another library, which does something like this:; ```py; import logging; logger = logging.getLogger(); logger.setLevel(logging.DEBUG); ```; Im not entirely sure why it does so, but nevertheless debug messages don't show up anywhere, since the root logger doesn't print anything without it being configured. If you run the above code in Ipython but add `import qutip` before it, `logging.debug(""foo"")` prints to the stderr (without qutip it doesn't). So when I started using the library with qutip, suddenly all debug messages started getting printed to stderr. Apparently, this is somewhat on purpose, by looking at the code [here](https://github.com/qutip/qutip/blob/eff1c3a606cad64b8d16f3232181b0463d65d746/qutip/logging_utils.py#L99). I'm not entirely sure what tho think about that, because as shown above this causes something unexpected. Nevertheless, I thought I could work around this by setting `log_handler = ""null""` in my settings file, but that in turn causes qutip to crash, because the rc loader [expects](https://github.com/qutip/qutip/blob/eff1c3a606cad64b8d16f3232181b0463d65d746/qutip/configrc.py#L97) `log_handler` to be a boolean for some reason. Also, it took me a while to find this, since the `log_handler` option is [not documented](http://qutip.org/docs/latest/guide/guide-settings.html?highlight=log). I'm using python 3.7.4 and QuTiP 4.4.1 installed with pip.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1156
https://github.com/qutip/qutip/issues/1156:551,Integrability,message,messages,551,"Hello,. I'm using qutip alongside another library, which does something like this:; ```py; import logging; logger = logging.getLogger(); logger.setLevel(logging.DEBUG); ```; Im not entirely sure why it does so, but nevertheless debug messages don't show up anywhere, since the root logger doesn't print anything without it being configured. If you run the above code in Ipython but add `import qutip` before it, `logging.debug(""foo"")` prints to the stderr (without qutip it doesn't). So when I started using the library with qutip, suddenly all debug messages started getting printed to stderr. Apparently, this is somewhat on purpose, by looking at the code [here](https://github.com/qutip/qutip/blob/eff1c3a606cad64b8d16f3232181b0463d65d746/qutip/logging_utils.py#L99). I'm not entirely sure what tho think about that, because as shown above this causes something unexpected. Nevertheless, I thought I could work around this by setting `log_handler = ""null""` in my settings file, but that in turn causes qutip to crash, because the rc loader [expects](https://github.com/qutip/qutip/blob/eff1c3a606cad64b8d16f3232181b0463d65d746/qutip/configrc.py#L97) `log_handler` to be a boolean for some reason. Also, it took me a while to find this, since the `log_handler` option is [not documented](http://qutip.org/docs/latest/guide/guide-settings.html?highlight=log). I'm using python 3.7.4 and QuTiP 4.4.1 installed with pip.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1156
https://github.com/qutip/qutip/issues/1156:329,Modifiability,config,configured,329,"Hello,. I'm using qutip alongside another library, which does something like this:; ```py; import logging; logger = logging.getLogger(); logger.setLevel(logging.DEBUG); ```; Im not entirely sure why it does so, but nevertheless debug messages don't show up anywhere, since the root logger doesn't print anything without it being configured. If you run the above code in Ipython but add `import qutip` before it, `logging.debug(""foo"")` prints to the stderr (without qutip it doesn't). So when I started using the library with qutip, suddenly all debug messages started getting printed to stderr. Apparently, this is somewhat on purpose, by looking at the code [here](https://github.com/qutip/qutip/blob/eff1c3a606cad64b8d16f3232181b0463d65d746/qutip/logging_utils.py#L99). I'm not entirely sure what tho think about that, because as shown above this causes something unexpected. Nevertheless, I thought I could work around this by setting `log_handler = ""null""` in my settings file, but that in turn causes qutip to crash, because the rc loader [expects](https://github.com/qutip/qutip/blob/eff1c3a606cad64b8d16f3232181b0463d65d746/qutip/configrc.py#L97) `log_handler` to be a boolean for some reason. Also, it took me a while to find this, since the `log_handler` option is [not documented](http://qutip.org/docs/latest/guide/guide-settings.html?highlight=log). I'm using python 3.7.4 and QuTiP 4.4.1 installed with pip.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1156
https://github.com/qutip/qutip/issues/1156:1137,Modifiability,config,configrc,1137,"Hello,. I'm using qutip alongside another library, which does something like this:; ```py; import logging; logger = logging.getLogger(); logger.setLevel(logging.DEBUG); ```; Im not entirely sure why it does so, but nevertheless debug messages don't show up anywhere, since the root logger doesn't print anything without it being configured. If you run the above code in Ipython but add `import qutip` before it, `logging.debug(""foo"")` prints to the stderr (without qutip it doesn't). So when I started using the library with qutip, suddenly all debug messages started getting printed to stderr. Apparently, this is somewhat on purpose, by looking at the code [here](https://github.com/qutip/qutip/blob/eff1c3a606cad64b8d16f3232181b0463d65d746/qutip/logging_utils.py#L99). I'm not entirely sure what tho think about that, because as shown above this causes something unexpected. Nevertheless, I thought I could work around this by setting `log_handler = ""null""` in my settings file, but that in turn causes qutip to crash, because the rc loader [expects](https://github.com/qutip/qutip/blob/eff1c3a606cad64b8d16f3232181b0463d65d746/qutip/configrc.py#L97) `log_handler` to be a boolean for some reason. Also, it took me a while to find this, since the `log_handler` option is [not documented](http://qutip.org/docs/latest/guide/guide-settings.html?highlight=log). I'm using python 3.7.4 and QuTiP 4.4.1 installed with pip.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1156
https://github.com/qutip/qutip/issues/1156:1037,Performance,load,loader,1037,"Hello,. I'm using qutip alongside another library, which does something like this:; ```py; import logging; logger = logging.getLogger(); logger.setLevel(logging.DEBUG); ```; Im not entirely sure why it does so, but nevertheless debug messages don't show up anywhere, since the root logger doesn't print anything without it being configured. If you run the above code in Ipython but add `import qutip` before it, `logging.debug(""foo"")` prints to the stderr (without qutip it doesn't). So when I started using the library with qutip, suddenly all debug messages started getting printed to stderr. Apparently, this is somewhat on purpose, by looking at the code [here](https://github.com/qutip/qutip/blob/eff1c3a606cad64b8d16f3232181b0463d65d746/qutip/logging_utils.py#L99). I'm not entirely sure what tho think about that, because as shown above this causes something unexpected. Nevertheless, I thought I could work around this by setting `log_handler = ""null""` in my settings file, but that in turn causes qutip to crash, because the rc loader [expects](https://github.com/qutip/qutip/blob/eff1c3a606cad64b8d16f3232181b0463d65d746/qutip/configrc.py#L97) `log_handler` to be a boolean for some reason. Also, it took me a while to find this, since the `log_handler` option is [not documented](http://qutip.org/docs/latest/guide/guide-settings.html?highlight=log). I'm using python 3.7.4 and QuTiP 4.4.1 installed with pip.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1156
https://github.com/qutip/qutip/issues/1156:98,Testability,log,logging,98,"Hello,. I'm using qutip alongside another library, which does something like this:; ```py; import logging; logger = logging.getLogger(); logger.setLevel(logging.DEBUG); ```; Im not entirely sure why it does so, but nevertheless debug messages don't show up anywhere, since the root logger doesn't print anything without it being configured. If you run the above code in Ipython but add `import qutip` before it, `logging.debug(""foo"")` prints to the stderr (without qutip it doesn't). So when I started using the library with qutip, suddenly all debug messages started getting printed to stderr. Apparently, this is somewhat on purpose, by looking at the code [here](https://github.com/qutip/qutip/blob/eff1c3a606cad64b8d16f3232181b0463d65d746/qutip/logging_utils.py#L99). I'm not entirely sure what tho think about that, because as shown above this causes something unexpected. Nevertheless, I thought I could work around this by setting `log_handler = ""null""` in my settings file, but that in turn causes qutip to crash, because the rc loader [expects](https://github.com/qutip/qutip/blob/eff1c3a606cad64b8d16f3232181b0463d65d746/qutip/configrc.py#L97) `log_handler` to be a boolean for some reason. Also, it took me a while to find this, since the `log_handler` option is [not documented](http://qutip.org/docs/latest/guide/guide-settings.html?highlight=log). I'm using python 3.7.4 and QuTiP 4.4.1 installed with pip.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1156
https://github.com/qutip/qutip/issues/1156:107,Testability,log,logger,107,"Hello,. I'm using qutip alongside another library, which does something like this:; ```py; import logging; logger = logging.getLogger(); logger.setLevel(logging.DEBUG); ```; Im not entirely sure why it does so, but nevertheless debug messages don't show up anywhere, since the root logger doesn't print anything without it being configured. If you run the above code in Ipython but add `import qutip` before it, `logging.debug(""foo"")` prints to the stderr (without qutip it doesn't). So when I started using the library with qutip, suddenly all debug messages started getting printed to stderr. Apparently, this is somewhat on purpose, by looking at the code [here](https://github.com/qutip/qutip/blob/eff1c3a606cad64b8d16f3232181b0463d65d746/qutip/logging_utils.py#L99). I'm not entirely sure what tho think about that, because as shown above this causes something unexpected. Nevertheless, I thought I could work around this by setting `log_handler = ""null""` in my settings file, but that in turn causes qutip to crash, because the rc loader [expects](https://github.com/qutip/qutip/blob/eff1c3a606cad64b8d16f3232181b0463d65d746/qutip/configrc.py#L97) `log_handler` to be a boolean for some reason. Also, it took me a while to find this, since the `log_handler` option is [not documented](http://qutip.org/docs/latest/guide/guide-settings.html?highlight=log). I'm using python 3.7.4 and QuTiP 4.4.1 installed with pip.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1156
https://github.com/qutip/qutip/issues/1156:116,Testability,log,logging,116,"Hello,. I'm using qutip alongside another library, which does something like this:; ```py; import logging; logger = logging.getLogger(); logger.setLevel(logging.DEBUG); ```; Im not entirely sure why it does so, but nevertheless debug messages don't show up anywhere, since the root logger doesn't print anything without it being configured. If you run the above code in Ipython but add `import qutip` before it, `logging.debug(""foo"")` prints to the stderr (without qutip it doesn't). So when I started using the library with qutip, suddenly all debug messages started getting printed to stderr. Apparently, this is somewhat on purpose, by looking at the code [here](https://github.com/qutip/qutip/blob/eff1c3a606cad64b8d16f3232181b0463d65d746/qutip/logging_utils.py#L99). I'm not entirely sure what tho think about that, because as shown above this causes something unexpected. Nevertheless, I thought I could work around this by setting `log_handler = ""null""` in my settings file, but that in turn causes qutip to crash, because the rc loader [expects](https://github.com/qutip/qutip/blob/eff1c3a606cad64b8d16f3232181b0463d65d746/qutip/configrc.py#L97) `log_handler` to be a boolean for some reason. Also, it took me a while to find this, since the `log_handler` option is [not documented](http://qutip.org/docs/latest/guide/guide-settings.html?highlight=log). I'm using python 3.7.4 and QuTiP 4.4.1 installed with pip.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1156
https://github.com/qutip/qutip/issues/1156:137,Testability,log,logger,137,"Hello,. I'm using qutip alongside another library, which does something like this:; ```py; import logging; logger = logging.getLogger(); logger.setLevel(logging.DEBUG); ```; Im not entirely sure why it does so, but nevertheless debug messages don't show up anywhere, since the root logger doesn't print anything without it being configured. If you run the above code in Ipython but add `import qutip` before it, `logging.debug(""foo"")` prints to the stderr (without qutip it doesn't). So when I started using the library with qutip, suddenly all debug messages started getting printed to stderr. Apparently, this is somewhat on purpose, by looking at the code [here](https://github.com/qutip/qutip/blob/eff1c3a606cad64b8d16f3232181b0463d65d746/qutip/logging_utils.py#L99). I'm not entirely sure what tho think about that, because as shown above this causes something unexpected. Nevertheless, I thought I could work around this by setting `log_handler = ""null""` in my settings file, but that in turn causes qutip to crash, because the rc loader [expects](https://github.com/qutip/qutip/blob/eff1c3a606cad64b8d16f3232181b0463d65d746/qutip/configrc.py#L97) `log_handler` to be a boolean for some reason. Also, it took me a while to find this, since the `log_handler` option is [not documented](http://qutip.org/docs/latest/guide/guide-settings.html?highlight=log). I'm using python 3.7.4 and QuTiP 4.4.1 installed with pip.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1156
https://github.com/qutip/qutip/issues/1156:153,Testability,log,logging,153,"Hello,. I'm using qutip alongside another library, which does something like this:; ```py; import logging; logger = logging.getLogger(); logger.setLevel(logging.DEBUG); ```; Im not entirely sure why it does so, but nevertheless debug messages don't show up anywhere, since the root logger doesn't print anything without it being configured. If you run the above code in Ipython but add `import qutip` before it, `logging.debug(""foo"")` prints to the stderr (without qutip it doesn't). So when I started using the library with qutip, suddenly all debug messages started getting printed to stderr. Apparently, this is somewhat on purpose, by looking at the code [here](https://github.com/qutip/qutip/blob/eff1c3a606cad64b8d16f3232181b0463d65d746/qutip/logging_utils.py#L99). I'm not entirely sure what tho think about that, because as shown above this causes something unexpected. Nevertheless, I thought I could work around this by setting `log_handler = ""null""` in my settings file, but that in turn causes qutip to crash, because the rc loader [expects](https://github.com/qutip/qutip/blob/eff1c3a606cad64b8d16f3232181b0463d65d746/qutip/configrc.py#L97) `log_handler` to be a boolean for some reason. Also, it took me a while to find this, since the `log_handler` option is [not documented](http://qutip.org/docs/latest/guide/guide-settings.html?highlight=log). I'm using python 3.7.4 and QuTiP 4.4.1 installed with pip.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1156
https://github.com/qutip/qutip/issues/1156:282,Testability,log,logger,282,"Hello,. I'm using qutip alongside another library, which does something like this:; ```py; import logging; logger = logging.getLogger(); logger.setLevel(logging.DEBUG); ```; Im not entirely sure why it does so, but nevertheless debug messages don't show up anywhere, since the root logger doesn't print anything without it being configured. If you run the above code in Ipython but add `import qutip` before it, `logging.debug(""foo"")` prints to the stderr (without qutip it doesn't). So when I started using the library with qutip, suddenly all debug messages started getting printed to stderr. Apparently, this is somewhat on purpose, by looking at the code [here](https://github.com/qutip/qutip/blob/eff1c3a606cad64b8d16f3232181b0463d65d746/qutip/logging_utils.py#L99). I'm not entirely sure what tho think about that, because as shown above this causes something unexpected. Nevertheless, I thought I could work around this by setting `log_handler = ""null""` in my settings file, but that in turn causes qutip to crash, because the rc loader [expects](https://github.com/qutip/qutip/blob/eff1c3a606cad64b8d16f3232181b0463d65d746/qutip/configrc.py#L97) `log_handler` to be a boolean for some reason. Also, it took me a while to find this, since the `log_handler` option is [not documented](http://qutip.org/docs/latest/guide/guide-settings.html?highlight=log). I'm using python 3.7.4 and QuTiP 4.4.1 installed with pip.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1156
https://github.com/qutip/qutip/issues/1156:413,Testability,log,logging,413,"Hello,. I'm using qutip alongside another library, which does something like this:; ```py; import logging; logger = logging.getLogger(); logger.setLevel(logging.DEBUG); ```; Im not entirely sure why it does so, but nevertheless debug messages don't show up anywhere, since the root logger doesn't print anything without it being configured. If you run the above code in Ipython but add `import qutip` before it, `logging.debug(""foo"")` prints to the stderr (without qutip it doesn't). So when I started using the library with qutip, suddenly all debug messages started getting printed to stderr. Apparently, this is somewhat on purpose, by looking at the code [here](https://github.com/qutip/qutip/blob/eff1c3a606cad64b8d16f3232181b0463d65d746/qutip/logging_utils.py#L99). I'm not entirely sure what tho think about that, because as shown above this causes something unexpected. Nevertheless, I thought I could work around this by setting `log_handler = ""null""` in my settings file, but that in turn causes qutip to crash, because the rc loader [expects](https://github.com/qutip/qutip/blob/eff1c3a606cad64b8d16f3232181b0463d65d746/qutip/configrc.py#L97) `log_handler` to be a boolean for some reason. Also, it took me a while to find this, since the `log_handler` option is [not documented](http://qutip.org/docs/latest/guide/guide-settings.html?highlight=log). I'm using python 3.7.4 and QuTiP 4.4.1 installed with pip.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1156
https://github.com/qutip/qutip/issues/1156:1356,Testability,log,log,1356,"Hello,. I'm using qutip alongside another library, which does something like this:; ```py; import logging; logger = logging.getLogger(); logger.setLevel(logging.DEBUG); ```; Im not entirely sure why it does so, but nevertheless debug messages don't show up anywhere, since the root logger doesn't print anything without it being configured. If you run the above code in Ipython but add `import qutip` before it, `logging.debug(""foo"")` prints to the stderr (without qutip it doesn't). So when I started using the library with qutip, suddenly all debug messages started getting printed to stderr. Apparently, this is somewhat on purpose, by looking at the code [here](https://github.com/qutip/qutip/blob/eff1c3a606cad64b8d16f3232181b0463d65d746/qutip/logging_utils.py#L99). I'm not entirely sure what tho think about that, because as shown above this causes something unexpected. Nevertheless, I thought I could work around this by setting `log_handler = ""null""` in my settings file, but that in turn causes qutip to crash, because the rc loader [expects](https://github.com/qutip/qutip/blob/eff1c3a606cad64b8d16f3232181b0463d65d746/qutip/configrc.py#L97) `log_handler` to be a boolean for some reason. Also, it took me a while to find this, since the `log_handler` option is [not documented](http://qutip.org/docs/latest/guide/guide-settings.html?highlight=log). I'm using python 3.7.4 and QuTiP 4.4.1 installed with pip.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1156
https://github.com/qutip/qutip/issues/1156:1320,Usability,guid,guide,1320,"Hello,. I'm using qutip alongside another library, which does something like this:; ```py; import logging; logger = logging.getLogger(); logger.setLevel(logging.DEBUG); ```; Im not entirely sure why it does so, but nevertheless debug messages don't show up anywhere, since the root logger doesn't print anything without it being configured. If you run the above code in Ipython but add `import qutip` before it, `logging.debug(""foo"")` prints to the stderr (without qutip it doesn't). So when I started using the library with qutip, suddenly all debug messages started getting printed to stderr. Apparently, this is somewhat on purpose, by looking at the code [here](https://github.com/qutip/qutip/blob/eff1c3a606cad64b8d16f3232181b0463d65d746/qutip/logging_utils.py#L99). I'm not entirely sure what tho think about that, because as shown above this causes something unexpected. Nevertheless, I thought I could work around this by setting `log_handler = ""null""` in my settings file, but that in turn causes qutip to crash, because the rc loader [expects](https://github.com/qutip/qutip/blob/eff1c3a606cad64b8d16f3232181b0463d65d746/qutip/configrc.py#L97) `log_handler` to be a boolean for some reason. Also, it took me a while to find this, since the `log_handler` option is [not documented](http://qutip.org/docs/latest/guide/guide-settings.html?highlight=log). I'm using python 3.7.4 and QuTiP 4.4.1 installed with pip.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1156
https://github.com/qutip/qutip/issues/1156:1326,Usability,guid,guide-settings,1326,"Hello,. I'm using qutip alongside another library, which does something like this:; ```py; import logging; logger = logging.getLogger(); logger.setLevel(logging.DEBUG); ```; Im not entirely sure why it does so, but nevertheless debug messages don't show up anywhere, since the root logger doesn't print anything without it being configured. If you run the above code in Ipython but add `import qutip` before it, `logging.debug(""foo"")` prints to the stderr (without qutip it doesn't). So when I started using the library with qutip, suddenly all debug messages started getting printed to stderr. Apparently, this is somewhat on purpose, by looking at the code [here](https://github.com/qutip/qutip/blob/eff1c3a606cad64b8d16f3232181b0463d65d746/qutip/logging_utils.py#L99). I'm not entirely sure what tho think about that, because as shown above this causes something unexpected. Nevertheless, I thought I could work around this by setting `log_handler = ""null""` in my settings file, but that in turn causes qutip to crash, because the rc loader [expects](https://github.com/qutip/qutip/blob/eff1c3a606cad64b8d16f3232181b0463d65d746/qutip/configrc.py#L97) `log_handler` to be a boolean for some reason. Also, it took me a while to find this, since the `log_handler` option is [not documented](http://qutip.org/docs/latest/guide/guide-settings.html?highlight=log). I'm using python 3.7.4 and QuTiP 4.4.1 installed with pip.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1156
https://github.com/qutip/qutip/pull/1157:435,Availability,error,error,435,"Hello,. There is currently a circular function call in the tensor produce part of `qeye()` - the list comprehension calls `identity()` for each element of the space, which is just a pass-through back to `qeye()`, rather than explicitly recursing. I've just made the recursion explicit. Also, as it stands, the ""list of ints"" argument will accept arbitrarily-nested lists of integers, and silently flatten it out. Is it worth adding an error check to catch what is (presumably) user error?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1157
https://github.com/qutip/qutip/pull/1157:482,Availability,error,error,482,"Hello,. There is currently a circular function call in the tensor produce part of `qeye()` - the list comprehension calls `identity()` for each element of the space, which is just a pass-through back to `qeye()`, rather than explicitly recursing. I've just made the recursion explicit. Also, as it stands, the ""list of ints"" argument will accept arbitrarily-nested lists of integers, and silently flatten it out. Is it worth adding an error check to catch what is (presumably) user error?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1157
https://github.com/qutip/qutip/issues/1158:59,Testability,test,testing,59,"I think there's been some form of merge conflict in `qutip.testing` - for one, it looks like the tests are intended to run twice (once under `pytest` and once under `nose`), and secondly it refers to the name `qset`, which isn't defined.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1158
https://github.com/qutip/qutip/issues/1158:97,Testability,test,tests,97,"I think there's been some form of merge conflict in `qutip.testing` - for one, it looks like the tests are intended to run twice (once under `pytest` and once under `nose`), and secondly it refers to the name `qset`, which isn't defined.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1158
https://github.com/qutip/qutip/issues/1160:210,Availability,error,error,210,"On my Mac (Mojave 10.14.5) the latest development version of qutip tests can fail at different points. . First, I run into an abort trap at ptrace. . Then, upon another run, I bumped into this other abort trap error ; ```; tests/test_superop_reps.py::TestSuperopReps::test_ChoiKrausChoi Fatal Python error: Aborted. Current thread 0x000000010b9155c0 (most recent call first):; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/qutip-4.5.0.dev0+d13f5435-py3.7-macosx-10.9-x86_64.egg/qutip/superop_reps.py"", line 547 in to_kraus; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/qutip-4.5.0.dev0+d13f5435-py3.7-macosx-10.9-x86_64.egg/qutip/tests/test_superop_reps.py"", line 106 in test_ChoiKrausChoi; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/python.py"", line 166 in pytest_pyfunc_call; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/callers.py"", line 187 in _multicall; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 87 in <lambda>; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 93 in _hookexec; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/hooks.py"", line 286 in __call__; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/python.py"", line 1435 in runtest; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/runner.py"", line 131 in pytest_runtest_call; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/callers.py"", line 187 in _multicall; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 87 in <lambda>; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 93 in _hookexec; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/hooks.py"", line 286 in __call__; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/runner.py"", line 207 in <lambda>; File ""/min",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1160
https://github.com/qutip/qutip/issues/1160:300,Availability,error,error,300,"On my Mac (Mojave 10.14.5) the latest development version of qutip tests can fail at different points. . First, I run into an abort trap at ptrace. . Then, upon another run, I bumped into this other abort trap error ; ```; tests/test_superop_reps.py::TestSuperopReps::test_ChoiKrausChoi Fatal Python error: Aborted. Current thread 0x000000010b9155c0 (most recent call first):; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/qutip-4.5.0.dev0+d13f5435-py3.7-macosx-10.9-x86_64.egg/qutip/superop_reps.py"", line 547 in to_kraus; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/qutip-4.5.0.dev0+d13f5435-py3.7-macosx-10.9-x86_64.egg/qutip/tests/test_superop_reps.py"", line 106 in test_ChoiKrausChoi; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/python.py"", line 166 in pytest_pyfunc_call; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/callers.py"", line 187 in _multicall; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 87 in <lambda>; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 93 in _hookexec; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/hooks.py"", line 286 in __call__; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/python.py"", line 1435 in runtest; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/runner.py"", line 131 in pytest_runtest_call; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/callers.py"", line 187 in _multicall; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 87 in <lambda>; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 93 in _hookexec; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/hooks.py"", line 286 in __call__; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/runner.py"", line 207 in <lambda>; File ""/min",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1160
https://github.com/qutip/qutip/issues/1160:4948,Deployability,Install,Installed,4948,"ne 187 in _multicall; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 87 in <lambda>; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 93 in _hookexec; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/hooks.py"", line 286 in __call__; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/main.py"", line 246 in _main; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/main.py"", line 196 in wrap_session; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/main.py"", line 239 in pytest_cmdline_main; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/callers.py"", line 187 in _multicall; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 87 in <lambda>; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 93 in _hookexec; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/hooks.py"", line 286 in __call__; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/config/__init__.py"", line 92 in main; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/qutip-4.5.0.dev0+d13f5435-py3.7-macosx-10.9-x86_64.egg/qutip/testing.py"", line 45 in run; File ""<stdin>"", line 1 in <module>; Abort trap: 6; ```; This is in a conda environment with qutip development version with ; ```; Python 3.7.4 (default, Aug 13 2019, 15:17:50); [Clang 4.0.1 (tags/RELEASE_401/final)] :: Anaconda, Inc. on darwin; ```; and ; ```; QuTiP Version: 4.5.0.dev0+d13f5435; Numpy Version: 1.17.2; Scipy Version: 1.3.1; Cython Version: 0.29.13; Matplotlib Version: 3.1.1; Python Version: 3.7.4; Number of CPUs: 2; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Darwin (x86_64); Installation path: /miniconda3/envs/qutipdev45/lib/python3.7/site-packages/qutip-4.5.0.dev0+d13f5435-py3.7-macosx-10.9-x86_64.egg/qutip; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1160
https://github.com/qutip/qutip/issues/1160:5019,Deployability,Install,Installation,5019,"ne 187 in _multicall; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 87 in <lambda>; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 93 in _hookexec; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/hooks.py"", line 286 in __call__; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/main.py"", line 246 in _main; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/main.py"", line 196 in wrap_session; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/main.py"", line 239 in pytest_cmdline_main; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/callers.py"", line 187 in _multicall; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 87 in <lambda>; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 93 in _hookexec; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/hooks.py"", line 286 in __call__; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/config/__init__.py"", line 92 in main; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/qutip-4.5.0.dev0+d13f5435-py3.7-macosx-10.9-x86_64.egg/qutip/testing.py"", line 45 in run; File ""<stdin>"", line 1 in <module>; Abort trap: 6; ```; This is in a conda environment with qutip development version with ; ```; Python 3.7.4 (default, Aug 13 2019, 15:17:50); [Clang 4.0.1 (tags/RELEASE_401/final)] :: Anaconda, Inc. on darwin; ```; and ; ```; QuTiP Version: 4.5.0.dev0+d13f5435; Numpy Version: 1.17.2; Scipy Version: 1.3.1; Cython Version: 0.29.13; Matplotlib Version: 3.1.1; Python Version: 3.7.4; Number of CPUs: 2; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Darwin (x86_64); Installation path: /miniconda3/envs/qutipdev45/lib/python3.7/site-packages/qutip-4.5.0.dev0+d13f5435-py3.7-macosx-10.9-x86_64.egg/qutip; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1160
https://github.com/qutip/qutip/issues/1160:4293,Modifiability,config,config,4293,"ne 187 in _multicall; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 87 in <lambda>; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 93 in _hookexec; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/hooks.py"", line 286 in __call__; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/main.py"", line 246 in _main; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/main.py"", line 196 in wrap_session; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/main.py"", line 239 in pytest_cmdline_main; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/callers.py"", line 187 in _multicall; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 87 in <lambda>; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 93 in _hookexec; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/hooks.py"", line 286 in __call__; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/config/__init__.py"", line 92 in main; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/qutip-4.5.0.dev0+d13f5435-py3.7-macosx-10.9-x86_64.egg/qutip/testing.py"", line 45 in run; File ""<stdin>"", line 1 in <module>; Abort trap: 6; ```; This is in a conda environment with qutip development version with ; ```; Python 3.7.4 (default, Aug 13 2019, 15:17:50); [Clang 4.0.1 (tags/RELEASE_401/final)] :: Anaconda, Inc. on darwin; ```; and ; ```; QuTiP Version: 4.5.0.dev0+d13f5435; Numpy Version: 1.17.2; Scipy Version: 1.3.1; Cython Version: 0.29.13; Matplotlib Version: 3.1.1; Python Version: 3.7.4; Number of CPUs: 2; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Darwin (x86_64); Installation path: /miniconda3/envs/qutipdev45/lib/python3.7/site-packages/qutip-4.5.0.dev0+d13f5435-py3.7-macosx-10.9-x86_64.egg/qutip; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1160
https://github.com/qutip/qutip/issues/1160:126,Safety,abort,abort,126,"On my Mac (Mojave 10.14.5) the latest development version of qutip tests can fail at different points. . First, I run into an abort trap at ptrace. . Then, upon another run, I bumped into this other abort trap error ; ```; tests/test_superop_reps.py::TestSuperopReps::test_ChoiKrausChoi Fatal Python error: Aborted. Current thread 0x000000010b9155c0 (most recent call first):; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/qutip-4.5.0.dev0+d13f5435-py3.7-macosx-10.9-x86_64.egg/qutip/superop_reps.py"", line 547 in to_kraus; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/qutip-4.5.0.dev0+d13f5435-py3.7-macosx-10.9-x86_64.egg/qutip/tests/test_superop_reps.py"", line 106 in test_ChoiKrausChoi; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/python.py"", line 166 in pytest_pyfunc_call; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/callers.py"", line 187 in _multicall; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 87 in <lambda>; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 93 in _hookexec; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/hooks.py"", line 286 in __call__; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/python.py"", line 1435 in runtest; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/runner.py"", line 131 in pytest_runtest_call; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/callers.py"", line 187 in _multicall; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 87 in <lambda>; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 93 in _hookexec; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/hooks.py"", line 286 in __call__; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/runner.py"", line 207 in <lambda>; File ""/min",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1160
https://github.com/qutip/qutip/issues/1160:199,Safety,abort,abort,199,"On my Mac (Mojave 10.14.5) the latest development version of qutip tests can fail at different points. . First, I run into an abort trap at ptrace. . Then, upon another run, I bumped into this other abort trap error ; ```; tests/test_superop_reps.py::TestSuperopReps::test_ChoiKrausChoi Fatal Python error: Aborted. Current thread 0x000000010b9155c0 (most recent call first):; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/qutip-4.5.0.dev0+d13f5435-py3.7-macosx-10.9-x86_64.egg/qutip/superop_reps.py"", line 547 in to_kraus; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/qutip-4.5.0.dev0+d13f5435-py3.7-macosx-10.9-x86_64.egg/qutip/tests/test_superop_reps.py"", line 106 in test_ChoiKrausChoi; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/python.py"", line 166 in pytest_pyfunc_call; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/callers.py"", line 187 in _multicall; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 87 in <lambda>; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 93 in _hookexec; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/hooks.py"", line 286 in __call__; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/python.py"", line 1435 in runtest; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/runner.py"", line 131 in pytest_runtest_call; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/callers.py"", line 187 in _multicall; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 87 in <lambda>; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 93 in _hookexec; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/hooks.py"", line 286 in __call__; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/runner.py"", line 207 in <lambda>; File ""/min",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1160
https://github.com/qutip/qutip/issues/1160:307,Safety,Abort,Aborted,307,"On my Mac (Mojave 10.14.5) the latest development version of qutip tests can fail at different points. . First, I run into an abort trap at ptrace. . Then, upon another run, I bumped into this other abort trap error ; ```; tests/test_superop_reps.py::TestSuperopReps::test_ChoiKrausChoi Fatal Python error: Aborted. Current thread 0x000000010b9155c0 (most recent call first):; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/qutip-4.5.0.dev0+d13f5435-py3.7-macosx-10.9-x86_64.egg/qutip/superop_reps.py"", line 547 in to_kraus; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/qutip-4.5.0.dev0+d13f5435-py3.7-macosx-10.9-x86_64.egg/qutip/tests/test_superop_reps.py"", line 106 in test_ChoiKrausChoi; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/python.py"", line 166 in pytest_pyfunc_call; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/callers.py"", line 187 in _multicall; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 87 in <lambda>; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 93 in _hookexec; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/hooks.py"", line 286 in __call__; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/python.py"", line 1435 in runtest; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/runner.py"", line 131 in pytest_runtest_call; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/callers.py"", line 187 in _multicall; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 87 in <lambda>; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 93 in _hookexec; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/hooks.py"", line 286 in __call__; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/runner.py"", line 207 in <lambda>; File ""/min",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1160
https://github.com/qutip/qutip/issues/1160:4519,Safety,Abort,Abort,4519,"ne 187 in _multicall; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 87 in <lambda>; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 93 in _hookexec; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/hooks.py"", line 286 in __call__; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/main.py"", line 246 in _main; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/main.py"", line 196 in wrap_session; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/main.py"", line 239 in pytest_cmdline_main; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/callers.py"", line 187 in _multicall; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 87 in <lambda>; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 93 in _hookexec; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/hooks.py"", line 286 in __call__; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/config/__init__.py"", line 92 in main; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/qutip-4.5.0.dev0+d13f5435-py3.7-macosx-10.9-x86_64.egg/qutip/testing.py"", line 45 in run; File ""<stdin>"", line 1 in <module>; Abort trap: 6; ```; This is in a conda environment with qutip development version with ; ```; Python 3.7.4 (default, Aug 13 2019, 15:17:50); [Clang 4.0.1 (tags/RELEASE_401/final)] :: Anaconda, Inc. on darwin; ```; and ; ```; QuTiP Version: 4.5.0.dev0+d13f5435; Numpy Version: 1.17.2; Scipy Version: 1.3.1; Cython Version: 0.29.13; Matplotlib Version: 3.1.1; Python Version: 3.7.4; Number of CPUs: 2; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Darwin (x86_64); Installation path: /miniconda3/envs/qutipdev45/lib/python3.7/site-packages/qutip-4.5.0.dev0+d13f5435-py3.7-macosx-10.9-x86_64.egg/qutip; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1160
https://github.com/qutip/qutip/issues/1160:67,Testability,test,tests,67,"On my Mac (Mojave 10.14.5) the latest development version of qutip tests can fail at different points. . First, I run into an abort trap at ptrace. . Then, upon another run, I bumped into this other abort trap error ; ```; tests/test_superop_reps.py::TestSuperopReps::test_ChoiKrausChoi Fatal Python error: Aborted. Current thread 0x000000010b9155c0 (most recent call first):; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/qutip-4.5.0.dev0+d13f5435-py3.7-macosx-10.9-x86_64.egg/qutip/superop_reps.py"", line 547 in to_kraus; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/qutip-4.5.0.dev0+d13f5435-py3.7-macosx-10.9-x86_64.egg/qutip/tests/test_superop_reps.py"", line 106 in test_ChoiKrausChoi; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/python.py"", line 166 in pytest_pyfunc_call; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/callers.py"", line 187 in _multicall; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 87 in <lambda>; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 93 in _hookexec; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/hooks.py"", line 286 in __call__; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/python.py"", line 1435 in runtest; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/runner.py"", line 131 in pytest_runtest_call; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/callers.py"", line 187 in _multicall; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 87 in <lambda>; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 93 in _hookexec; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/hooks.py"", line 286 in __call__; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/runner.py"", line 207 in <lambda>; File ""/min",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1160
https://github.com/qutip/qutip/issues/1160:223,Testability,test,tests,223,"On my Mac (Mojave 10.14.5) the latest development version of qutip tests can fail at different points. . First, I run into an abort trap at ptrace. . Then, upon another run, I bumped into this other abort trap error ; ```; tests/test_superop_reps.py::TestSuperopReps::test_ChoiKrausChoi Fatal Python error: Aborted. Current thread 0x000000010b9155c0 (most recent call first):; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/qutip-4.5.0.dev0+d13f5435-py3.7-macosx-10.9-x86_64.egg/qutip/superop_reps.py"", line 547 in to_kraus; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/qutip-4.5.0.dev0+d13f5435-py3.7-macosx-10.9-x86_64.egg/qutip/tests/test_superop_reps.py"", line 106 in test_ChoiKrausChoi; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/python.py"", line 166 in pytest_pyfunc_call; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/callers.py"", line 187 in _multicall; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 87 in <lambda>; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 93 in _hookexec; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/hooks.py"", line 286 in __call__; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/python.py"", line 1435 in runtest; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/runner.py"", line 131 in pytest_runtest_call; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/callers.py"", line 187 in _multicall; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 87 in <lambda>; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 93 in _hookexec; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/hooks.py"", line 286 in __call__; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/runner.py"", line 207 in <lambda>; File ""/min",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1160
https://github.com/qutip/qutip/issues/1160:251,Testability,Test,TestSuperopReps,251,"On my Mac (Mojave 10.14.5) the latest development version of qutip tests can fail at different points. . First, I run into an abort trap at ptrace. . Then, upon another run, I bumped into this other abort trap error ; ```; tests/test_superop_reps.py::TestSuperopReps::test_ChoiKrausChoi Fatal Python error: Aborted. Current thread 0x000000010b9155c0 (most recent call first):; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/qutip-4.5.0.dev0+d13f5435-py3.7-macosx-10.9-x86_64.egg/qutip/superop_reps.py"", line 547 in to_kraus; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/qutip-4.5.0.dev0+d13f5435-py3.7-macosx-10.9-x86_64.egg/qutip/tests/test_superop_reps.py"", line 106 in test_ChoiKrausChoi; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/python.py"", line 166 in pytest_pyfunc_call; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/callers.py"", line 187 in _multicall; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 87 in <lambda>; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 93 in _hookexec; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/hooks.py"", line 286 in __call__; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/python.py"", line 1435 in runtest; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/runner.py"", line 131 in pytest_runtest_call; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/callers.py"", line 187 in _multicall; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 87 in <lambda>; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 93 in _hookexec; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/hooks.py"", line 286 in __call__; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/runner.py"", line 207 in <lambda>; File ""/min",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1160
https://github.com/qutip/qutip/issues/1160:663,Testability,test,tests,663,"On my Mac (Mojave 10.14.5) the latest development version of qutip tests can fail at different points. . First, I run into an abort trap at ptrace. . Then, upon another run, I bumped into this other abort trap error ; ```; tests/test_superop_reps.py::TestSuperopReps::test_ChoiKrausChoi Fatal Python error: Aborted. Current thread 0x000000010b9155c0 (most recent call first):; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/qutip-4.5.0.dev0+d13f5435-py3.7-macosx-10.9-x86_64.egg/qutip/superop_reps.py"", line 547 in to_kraus; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/qutip-4.5.0.dev0+d13f5435-py3.7-macosx-10.9-x86_64.egg/qutip/tests/test_superop_reps.py"", line 106 in test_ChoiKrausChoi; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/python.py"", line 166 in pytest_pyfunc_call; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/callers.py"", line 187 in _multicall; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 87 in <lambda>; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 93 in _hookexec; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/hooks.py"", line 286 in __call__; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/python.py"", line 1435 in runtest; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/runner.py"", line 131 in pytest_runtest_call; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/callers.py"", line 187 in _multicall; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 87 in <lambda>; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 93 in _hookexec; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/hooks.py"", line 286 in __call__; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/runner.py"", line 207 in <lambda>; File ""/min",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1160
https://github.com/qutip/qutip/issues/1160:4454,Testability,test,testing,4454,"ne 187 in _multicall; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 87 in <lambda>; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 93 in _hookexec; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/hooks.py"", line 286 in __call__; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/main.py"", line 246 in _main; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/main.py"", line 196 in wrap_session; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/main.py"", line 239 in pytest_cmdline_main; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/callers.py"", line 187 in _multicall; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 87 in <lambda>; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 93 in _hookexec; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/hooks.py"", line 286 in __call__; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/config/__init__.py"", line 92 in main; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/qutip-4.5.0.dev0+d13f5435-py3.7-macosx-10.9-x86_64.egg/qutip/testing.py"", line 45 in run; File ""<stdin>"", line 1 in <module>; Abort trap: 6; ```; This is in a conda environment with qutip development version with ; ```; Python 3.7.4 (default, Aug 13 2019, 15:17:50); [Clang 4.0.1 (tags/RELEASE_401/final)] :: Anaconda, Inc. on darwin; ```; and ; ```; QuTiP Version: 4.5.0.dev0+d13f5435; Numpy Version: 1.17.2; Scipy Version: 1.3.1; Cython Version: 0.29.13; Matplotlib Version: 3.1.1; Python Version: 3.7.4; Number of CPUs: 2; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Darwin (x86_64); Installation path: /miniconda3/envs/qutipdev45/lib/python3.7/site-packages/qutip-4.5.0.dev0+d13f5435-py3.7-macosx-10.9-x86_64.egg/qutip; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1160
https://github.com/qutip/qutip/pull/1161:19,Testability,test,test,19,"Removes the `nose` test runners found in `qutip.testing.run()` in #1158. This isn't ready to be merged yet, I think - there's still references to `nose` in `setup.py`, and a comment in `test_qobj.py`, the context of which suggests that the tests are organised specifically for `nose`. I'm not familiar enough with the differences between `nose`, `pytest` and `unittest` to know how much of a problem the latter is, though.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1161
https://github.com/qutip/qutip/pull/1161:48,Testability,test,testing,48,"Removes the `nose` test runners found in `qutip.testing.run()` in #1158. This isn't ready to be merged yet, I think - there's still references to `nose` in `setup.py`, and a comment in `test_qobj.py`, the context of which suggests that the tests are organised specifically for `nose`. I'm not familiar enough with the differences between `nose`, `pytest` and `unittest` to know how much of a problem the latter is, though.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1161
https://github.com/qutip/qutip/pull/1161:240,Testability,test,tests,240,"Removes the `nose` test runners found in `qutip.testing.run()` in #1158. This isn't ready to be merged yet, I think - there's still references to `nose` in `setup.py`, and a comment in `test_qobj.py`, the context of which suggests that the tests are organised specifically for `nose`. I'm not familiar enough with the differences between `nose`, `pytest` and `unittest` to know how much of a problem the latter is, though.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1161
https://github.com/qutip/qutip/issues/1163:215,Usability,guid,guide,215,"Hi all,; I am trying to reproduce the results of the photocurrent solver for open systems with my own methods, but I see some differences in the dynamics. In the [documentation webpage](http://qutip.org/docs/latest/guide/dynamics/dynamics-photocurrent.html#open-system) to what L_sys is, and why it should be corrected with that effective term. Can someone please give provide a reference for that statement?. Furthermore, are C_n in that equation equivalent to the sc_ops in Qutip?. Thank you for your help!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1163
https://github.com/qutip/qutip/pull/1164:85,Testability,test,tests,85,"To get more familiar with bits of the internals, I'm going through and migrating the tests to `pytest`. While I'm at it, I'm also fixing PEP8 issues in the testing files, since CodeClimate will moan at me if I don't. I'm basically learning how to use `pytest` and how to code as part of an organisation as I go, so please feel free to correct me if I'm doing something wrong. I'll leave this PR as in draft mode until I've made it through more of the testing files.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1164
https://github.com/qutip/qutip/pull/1164:156,Testability,test,testing,156,"To get more familiar with bits of the internals, I'm going through and migrating the tests to `pytest`. While I'm at it, I'm also fixing PEP8 issues in the testing files, since CodeClimate will moan at me if I don't. I'm basically learning how to use `pytest` and how to code as part of an organisation as I go, so please feel free to correct me if I'm doing something wrong. I'll leave this PR as in draft mode until I've made it through more of the testing files.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1164
https://github.com/qutip/qutip/pull/1164:451,Testability,test,testing,451,"To get more familiar with bits of the internals, I'm going through and migrating the tests to `pytest`. While I'm at it, I'm also fixing PEP8 issues in the testing files, since CodeClimate will moan at me if I don't. I'm basically learning how to use `pytest` and how to code as part of an organisation as I go, so please feel free to correct me if I'm doing something wrong. I'll leave this PR as in draft mode until I've made it through more of the testing files.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1164
https://github.com/qutip/qutip/pull/1164:231,Usability,learn,learning,231,"To get more familiar with bits of the internals, I'm going through and migrating the tests to `pytest`. While I'm at it, I'm also fixing PEP8 issues in the testing files, since CodeClimate will moan at me if I don't. I'm basically learning how to use `pytest` and how to code as part of an organisation as I go, so please feel free to correct me if I'm doing something wrong. I'll leave this PR as in draft mode until I've made it through more of the testing files.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1164
https://github.com/qutip/qutip/issues/1166:147,Availability,error,error,147,"Trying to run the Qutip `propagator` for a Hamiltonian that is a `QobjEvo` object does not work and will result in _Invalid time-dependent format_ error. Example of a piece of code. ```; N = 3; a = destroy(N); t_total = 10; tlist = np.linspace(0, t_total, 1000); H = a.dag()**2 * a**2; H1 = a.dag()*a; H_tot = QobjEvo([H,[H1,np.cos(tlist)]],tlist=tlist); prop = propagator(H_tot, tlist, []); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1166
https://github.com/qutip/qutip/issues/1166:129,Integrability,depend,dependent,129,"Trying to run the Qutip `propagator` for a Hamiltonian that is a `QobjEvo` object does not work and will result in _Invalid time-dependent format_ error. Example of a piece of code. ```; N = 3; a = destroy(N); t_total = 10; tlist = np.linspace(0, t_total, 1000); H = a.dag()**2 * a**2; H1 = a.dag()*a; H_tot = QobjEvo([H,[H1,np.cos(tlist)]],tlist=tlist); prop = propagator(H_tot, tlist, []); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1166
https://github.com/qutip/qutip/pull/1169:111,Availability,error,error,111,"Should fix tests/test_propagator.py::testPropHOStrTd sometime failing, ran it 100 times with the patch without error.; Cause: compiling the same string by multiple process at once resulted in them writing temp files with the same filename, resulting in a race condition and random fails. Not sure why it was not caught before.; @nathanshammah, @ajgpitch",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1169
https://github.com/qutip/qutip/pull/1169:97,Deployability,patch,patch,97,"Should fix tests/test_propagator.py::testPropHOStrTd sometime failing, ran it 100 times with the patch without error.; Cause: compiling the same string by multiple process at once resulted in them writing temp files with the same filename, resulting in a race condition and random fails. Not sure why it was not caught before.; @nathanshammah, @ajgpitch",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1169
https://github.com/qutip/qutip/pull/1169:255,Performance,race condition,race condition,255,"Should fix tests/test_propagator.py::testPropHOStrTd sometime failing, ran it 100 times with the patch without error.; Cause: compiling the same string by multiple process at once resulted in them writing temp files with the same filename, resulting in a race condition and random fails. Not sure why it was not caught before.; @nathanshammah, @ajgpitch",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1169
https://github.com/qutip/qutip/pull/1169:11,Testability,test,tests,11,"Should fix tests/test_propagator.py::testPropHOStrTd sometime failing, ran it 100 times with the patch without error.; Cause: compiling the same string by multiple process at once resulted in them writing temp files with the same filename, resulting in a race condition and random fails. Not sure why it was not caught before.; @nathanshammah, @ajgpitch",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1169
https://github.com/qutip/qutip/pull/1169:37,Testability,test,testPropHOStrTd,37,"Should fix tests/test_propagator.py::testPropHOStrTd sometime failing, ran it 100 times with the patch without error.; Cause: compiling the same string by multiple process at once resulted in them writing temp files with the same filename, resulting in a race condition and random fails. Not sure why it was not caught before.; @nathanshammah, @ajgpitch",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1169
https://github.com/qutip/qutip/issues/1533:84,Deployability,update,update,84,"# Change log; Right now, maintainers need to go through the PRs in `qutip/qutip` to update the changelog. This is quite time consuming. . There may be automated tools to generate the change log. . I propose at minimum to keep a changelog file also in `qutip/qutip`, asking contributors to update it before merging the PR. This makes it simpler than for them to open another PR to `qutip/qutip-doc`. # Classes and functions; As note in the [`release_distribution`](https://github.com/qutip/qutip-doc/blob/master/release_distribution.rst) guidelines, one should check that new functions and classes are included in the `classes.rst` and `functions.rst` files. Having a recipe to check this quickly or automatically, maybe with a script like this [one](https://stackoverflow.com/questions/1796180/how-can-i-get-a-list-of-all-classes-within-current-module-in-python).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1533
https://github.com/qutip/qutip/issues/1533:289,Deployability,update,update,289,"# Change log; Right now, maintainers need to go through the PRs in `qutip/qutip` to update the changelog. This is quite time consuming. . There may be automated tools to generate the change log. . I propose at minimum to keep a changelog file also in `qutip/qutip`, asking contributors to update it before merging the PR. This makes it simpler than for them to open another PR to `qutip/qutip-doc`. # Classes and functions; As note in the [`release_distribution`](https://github.com/qutip/qutip-doc/blob/master/release_distribution.rst) guidelines, one should check that new functions and classes are included in the `classes.rst` and `functions.rst` files. Having a recipe to check this quickly or automatically, maybe with a script like this [one](https://stackoverflow.com/questions/1796180/how-can-i-get-a-list-of-all-classes-within-current-module-in-python).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1533
https://github.com/qutip/qutip/issues/1533:9,Testability,log,log,9,"# Change log; Right now, maintainers need to go through the PRs in `qutip/qutip` to update the changelog. This is quite time consuming. . There may be automated tools to generate the change log. . I propose at minimum to keep a changelog file also in `qutip/qutip`, asking contributors to update it before merging the PR. This makes it simpler than for them to open another PR to `qutip/qutip-doc`. # Classes and functions; As note in the [`release_distribution`](https://github.com/qutip/qutip-doc/blob/master/release_distribution.rst) guidelines, one should check that new functions and classes are included in the `classes.rst` and `functions.rst` files. Having a recipe to check this quickly or automatically, maybe with a script like this [one](https://stackoverflow.com/questions/1796180/how-can-i-get-a-list-of-all-classes-within-current-module-in-python).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1533
https://github.com/qutip/qutip/issues/1533:190,Testability,log,log,190,"# Change log; Right now, maintainers need to go through the PRs in `qutip/qutip` to update the changelog. This is quite time consuming. . There may be automated tools to generate the change log. . I propose at minimum to keep a changelog file also in `qutip/qutip`, asking contributors to update it before merging the PR. This makes it simpler than for them to open another PR to `qutip/qutip-doc`. # Classes and functions; As note in the [`release_distribution`](https://github.com/qutip/qutip-doc/blob/master/release_distribution.rst) guidelines, one should check that new functions and classes are included in the `classes.rst` and `functions.rst` files. Having a recipe to check this quickly or automatically, maybe with a script like this [one](https://stackoverflow.com/questions/1796180/how-can-i-get-a-list-of-all-classes-within-current-module-in-python).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1533
https://github.com/qutip/qutip/issues/1533:336,Usability,simpl,simpler,336,"# Change log; Right now, maintainers need to go through the PRs in `qutip/qutip` to update the changelog. This is quite time consuming. . There may be automated tools to generate the change log. . I propose at minimum to keep a changelog file also in `qutip/qutip`, asking contributors to update it before merging the PR. This makes it simpler than for them to open another PR to `qutip/qutip-doc`. # Classes and functions; As note in the [`release_distribution`](https://github.com/qutip/qutip-doc/blob/master/release_distribution.rst) guidelines, one should check that new functions and classes are included in the `classes.rst` and `functions.rst` files. Having a recipe to check this quickly or automatically, maybe with a script like this [one](https://stackoverflow.com/questions/1796180/how-can-i-get-a-list-of-all-classes-within-current-module-in-python).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1533
https://github.com/qutip/qutip/issues/1533:537,Usability,guid,guidelines,537,"# Change log; Right now, maintainers need to go through the PRs in `qutip/qutip` to update the changelog. This is quite time consuming. . There may be automated tools to generate the change log. . I propose at minimum to keep a changelog file also in `qutip/qutip`, asking contributors to update it before merging the PR. This makes it simpler than for them to open another PR to `qutip/qutip-doc`. # Classes and functions; As note in the [`release_distribution`](https://github.com/qutip/qutip-doc/blob/master/release_distribution.rst) guidelines, one should check that new functions and classes are included in the `classes.rst` and `functions.rst` files. Having a recipe to check this quickly or automatically, maybe with a script like this [one](https://stackoverflow.com/questions/1796180/how-can-i-get-a-list-of-all-classes-within-current-module-in-python).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1533
https://github.com/qutip/qutip/issues/1534:27,Usability,guid,guide,27,"Building the documentation guide, dynamics-monte takes minutes; ```; Reading sources... [ 41%] guide/dynamics/dynamics-monte; ```; as well parfor",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1534
https://github.com/qutip/qutip/issues/1534:95,Usability,guid,guide,95,"Building the documentation guide, dynamics-monte takes minutes; ```; Reading sources... [ 41%] guide/dynamics/dynamics-monte; ```; as well parfor",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1534
https://github.com/qutip/qutip/pull/1170:15,Deployability,release,released,15,"Python 3.8 was released awhile ago, so I thought I'd try activate its travis build and see if it passes.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1170
https://github.com/qutip/qutip/pull/1171:79,Deployability,release,release,79,I had forgotten to do this version bump in the setup.py file after the version release. This PR needs to be merged before any other PR.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1171
https://github.com/qutip/qutip/issues/1172:262,Availability,mainten,maintenance,262,"## Changelog; The changelog file is present in `qutip/qutip-doc`. This means that for each new release, the maintainers need to go through the merged PRs and update the file accordingly. . I propose introducing a copy of the changelog file, which would simplify maintenance: each contributor could update their own contribution without opening a PR in the separate repository, which often does not happen. A message of a basic template with checklist could be prompted in the PR for itself. . ## PR template; To prompt these actions, just like for the changelog, [a template](https://help.github.com/en/github/committing-changes-to-your-project/creating-a-commit-with-multiple-authors) with suggested checklist could be made in the PRs. . ## Repositories refactoring ; Actually, this is all part of a wider problem for which the `qutip-doc` does not get well updated in general. In Qutip 4.5.0 I added a lot of missing elements to `functions.rst` and `classes.rst` in the api-doc. Moreover, the User guide is seldom updated. Maybe, moving the `qutip-doc` repository in the main `qutip/qutip` repository could help in this regard.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1172
https://github.com/qutip/qutip/issues/1172:95,Deployability,release,release,95,"## Changelog; The changelog file is present in `qutip/qutip-doc`. This means that for each new release, the maintainers need to go through the merged PRs and update the file accordingly. . I propose introducing a copy of the changelog file, which would simplify maintenance: each contributor could update their own contribution without opening a PR in the separate repository, which often does not happen. A message of a basic template with checklist could be prompted in the PR for itself. . ## PR template; To prompt these actions, just like for the changelog, [a template](https://help.github.com/en/github/committing-changes-to-your-project/creating-a-commit-with-multiple-authors) with suggested checklist could be made in the PRs. . ## Repositories refactoring ; Actually, this is all part of a wider problem for which the `qutip-doc` does not get well updated in general. In Qutip 4.5.0 I added a lot of missing elements to `functions.rst` and `classes.rst` in the api-doc. Moreover, the User guide is seldom updated. Maybe, moving the `qutip-doc` repository in the main `qutip/qutip` repository could help in this regard.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1172
https://github.com/qutip/qutip/issues/1172:158,Deployability,update,update,158,"## Changelog; The changelog file is present in `qutip/qutip-doc`. This means that for each new release, the maintainers need to go through the merged PRs and update the file accordingly. . I propose introducing a copy of the changelog file, which would simplify maintenance: each contributor could update their own contribution without opening a PR in the separate repository, which often does not happen. A message of a basic template with checklist could be prompted in the PR for itself. . ## PR template; To prompt these actions, just like for the changelog, [a template](https://help.github.com/en/github/committing-changes-to-your-project/creating-a-commit-with-multiple-authors) with suggested checklist could be made in the PRs. . ## Repositories refactoring ; Actually, this is all part of a wider problem for which the `qutip-doc` does not get well updated in general. In Qutip 4.5.0 I added a lot of missing elements to `functions.rst` and `classes.rst` in the api-doc. Moreover, the User guide is seldom updated. Maybe, moving the `qutip-doc` repository in the main `qutip/qutip` repository could help in this regard.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1172
https://github.com/qutip/qutip/issues/1172:298,Deployability,update,update,298,"## Changelog; The changelog file is present in `qutip/qutip-doc`. This means that for each new release, the maintainers need to go through the merged PRs and update the file accordingly. . I propose introducing a copy of the changelog file, which would simplify maintenance: each contributor could update their own contribution without opening a PR in the separate repository, which often does not happen. A message of a basic template with checklist could be prompted in the PR for itself. . ## PR template; To prompt these actions, just like for the changelog, [a template](https://help.github.com/en/github/committing-changes-to-your-project/creating-a-commit-with-multiple-authors) with suggested checklist could be made in the PRs. . ## Repositories refactoring ; Actually, this is all part of a wider problem for which the `qutip-doc` does not get well updated in general. In Qutip 4.5.0 I added a lot of missing elements to `functions.rst` and `classes.rst` in the api-doc. Moreover, the User guide is seldom updated. Maybe, moving the `qutip-doc` repository in the main `qutip/qutip` repository could help in this regard.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1172
https://github.com/qutip/qutip/issues/1172:859,Deployability,update,updated,859,"## Changelog; The changelog file is present in `qutip/qutip-doc`. This means that for each new release, the maintainers need to go through the merged PRs and update the file accordingly. . I propose introducing a copy of the changelog file, which would simplify maintenance: each contributor could update their own contribution without opening a PR in the separate repository, which often does not happen. A message of a basic template with checklist could be prompted in the PR for itself. . ## PR template; To prompt these actions, just like for the changelog, [a template](https://help.github.com/en/github/committing-changes-to-your-project/creating-a-commit-with-multiple-authors) with suggested checklist could be made in the PRs. . ## Repositories refactoring ; Actually, this is all part of a wider problem for which the `qutip-doc` does not get well updated in general. In Qutip 4.5.0 I added a lot of missing elements to `functions.rst` and `classes.rst` in the api-doc. Moreover, the User guide is seldom updated. Maybe, moving the `qutip-doc` repository in the main `qutip/qutip` repository could help in this regard.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1172
https://github.com/qutip/qutip/issues/1172:1016,Deployability,update,updated,1016,"## Changelog; The changelog file is present in `qutip/qutip-doc`. This means that for each new release, the maintainers need to go through the merged PRs and update the file accordingly. . I propose introducing a copy of the changelog file, which would simplify maintenance: each contributor could update their own contribution without opening a PR in the separate repository, which often does not happen. A message of a basic template with checklist could be prompted in the PR for itself. . ## PR template; To prompt these actions, just like for the changelog, [a template](https://help.github.com/en/github/committing-changes-to-your-project/creating-a-commit-with-multiple-authors) with suggested checklist could be made in the PRs. . ## Repositories refactoring ; Actually, this is all part of a wider problem for which the `qutip-doc` does not get well updated in general. In Qutip 4.5.0 I added a lot of missing elements to `functions.rst` and `classes.rst` in the api-doc. Moreover, the User guide is seldom updated. Maybe, moving the `qutip-doc` repository in the main `qutip/qutip` repository could help in this regard.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1172
https://github.com/qutip/qutip/issues/1172:408,Integrability,message,message,408,"## Changelog; The changelog file is present in `qutip/qutip-doc`. This means that for each new release, the maintainers need to go through the merged PRs and update the file accordingly. . I propose introducing a copy of the changelog file, which would simplify maintenance: each contributor could update their own contribution without opening a PR in the separate repository, which often does not happen. A message of a basic template with checklist could be prompted in the PR for itself. . ## PR template; To prompt these actions, just like for the changelog, [a template](https://help.github.com/en/github/committing-changes-to-your-project/creating-a-commit-with-multiple-authors) with suggested checklist could be made in the PRs. . ## Repositories refactoring ; Actually, this is all part of a wider problem for which the `qutip-doc` does not get well updated in general. In Qutip 4.5.0 I added a lot of missing elements to `functions.rst` and `classes.rst` in the api-doc. Moreover, the User guide is seldom updated. Maybe, moving the `qutip-doc` repository in the main `qutip/qutip` repository could help in this regard.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1172
https://github.com/qutip/qutip/issues/1172:755,Modifiability,refactor,refactoring,755,"## Changelog; The changelog file is present in `qutip/qutip-doc`. This means that for each new release, the maintainers need to go through the merged PRs and update the file accordingly. . I propose introducing a copy of the changelog file, which would simplify maintenance: each contributor could update their own contribution without opening a PR in the separate repository, which often does not happen. A message of a basic template with checklist could be prompted in the PR for itself. . ## PR template; To prompt these actions, just like for the changelog, [a template](https://help.github.com/en/github/committing-changes-to-your-project/creating-a-commit-with-multiple-authors) with suggested checklist could be made in the PRs. . ## Repositories refactoring ; Actually, this is all part of a wider problem for which the `qutip-doc` does not get well updated in general. In Qutip 4.5.0 I added a lot of missing elements to `functions.rst` and `classes.rst` in the api-doc. Moreover, the User guide is seldom updated. Maybe, moving the `qutip-doc` repository in the main `qutip/qutip` repository could help in this regard.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1172
https://github.com/qutip/qutip/issues/1172:253,Usability,simpl,simplify,253,"## Changelog; The changelog file is present in `qutip/qutip-doc`. This means that for each new release, the maintainers need to go through the merged PRs and update the file accordingly. . I propose introducing a copy of the changelog file, which would simplify maintenance: each contributor could update their own contribution without opening a PR in the separate repository, which often does not happen. A message of a basic template with checklist could be prompted in the PR for itself. . ## PR template; To prompt these actions, just like for the changelog, [a template](https://help.github.com/en/github/committing-changes-to-your-project/creating-a-commit-with-multiple-authors) with suggested checklist could be made in the PRs. . ## Repositories refactoring ; Actually, this is all part of a wider problem for which the `qutip-doc` does not get well updated in general. In Qutip 4.5.0 I added a lot of missing elements to `functions.rst` and `classes.rst` in the api-doc. Moreover, the User guide is seldom updated. Maybe, moving the `qutip-doc` repository in the main `qutip/qutip` repository could help in this regard.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1172
https://github.com/qutip/qutip/issues/1172:1000,Usability,guid,guide,1000,"## Changelog; The changelog file is present in `qutip/qutip-doc`. This means that for each new release, the maintainers need to go through the merged PRs and update the file accordingly. . I propose introducing a copy of the changelog file, which would simplify maintenance: each contributor could update their own contribution without opening a PR in the separate repository, which often does not happen. A message of a basic template with checklist could be prompted in the PR for itself. . ## PR template; To prompt these actions, just like for the changelog, [a template](https://help.github.com/en/github/committing-changes-to-your-project/creating-a-commit-with-multiple-authors) with suggested checklist could be made in the PRs. . ## Repositories refactoring ; Actually, this is all part of a wider problem for which the `qutip-doc` does not get well updated in general. In Qutip 4.5.0 I added a lot of missing elements to `functions.rst` and `classes.rst` in the api-doc. Moreover, the User guide is seldom updated. Maybe, moving the `qutip-doc` repository in the main `qutip/qutip` repository could help in this regard.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1172
https://github.com/qutip/qutip/pull/1173:0,Deployability,Update,Update,0,Update with micro release to 4.5.1 to include bug fix on tests.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1173
https://github.com/qutip/qutip/pull/1173:18,Deployability,release,release,18,Update with micro release to 4.5.1 to include bug fix on tests.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1173
https://github.com/qutip/qutip/pull/1173:57,Testability,test,tests,57,Update with micro release to 4.5.1 to include bug fix on tests.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1173
https://github.com/qutip/qutip/issues/1174:0,Deployability,Install,Installing,0,"Installing `qutip` as an external dependency fails if `cython` is not installed since it's imported without checks in [`setup.py`.](https://github.com/qutip/qutip/blob/0f412cd4bf983a3b497d54406103d0209b553a7a/setup.py#L52-53). From what I can tell, this was an issue before (#426) and was subsequently fixed (#489) but then again broken (https://github.com/qutip/qutip/commit/82e209512927a0d6086de31364004fdb0da8c59a). Sidestepping this would be great since for instance readthedocs to my knowledge doesn't allow running custom commands (like `pip install cython`) before installing dependencies when building a documentation that requires `qutip`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1174
https://github.com/qutip/qutip/issues/1174:70,Deployability,install,installed,70,"Installing `qutip` as an external dependency fails if `cython` is not installed since it's imported without checks in [`setup.py`.](https://github.com/qutip/qutip/blob/0f412cd4bf983a3b497d54406103d0209b553a7a/setup.py#L52-53). From what I can tell, this was an issue before (#426) and was subsequently fixed (#489) but then again broken (https://github.com/qutip/qutip/commit/82e209512927a0d6086de31364004fdb0da8c59a). Sidestepping this would be great since for instance readthedocs to my knowledge doesn't allow running custom commands (like `pip install cython`) before installing dependencies when building a documentation that requires `qutip`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1174
https://github.com/qutip/qutip/issues/1174:548,Deployability,install,install,548,"Installing `qutip` as an external dependency fails if `cython` is not installed since it's imported without checks in [`setup.py`.](https://github.com/qutip/qutip/blob/0f412cd4bf983a3b497d54406103d0209b553a7a/setup.py#L52-53). From what I can tell, this was an issue before (#426) and was subsequently fixed (#489) but then again broken (https://github.com/qutip/qutip/commit/82e209512927a0d6086de31364004fdb0da8c59a). Sidestepping this would be great since for instance readthedocs to my knowledge doesn't allow running custom commands (like `pip install cython`) before installing dependencies when building a documentation that requires `qutip`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1174
https://github.com/qutip/qutip/issues/1174:572,Deployability,install,installing,572,"Installing `qutip` as an external dependency fails if `cython` is not installed since it's imported without checks in [`setup.py`.](https://github.com/qutip/qutip/blob/0f412cd4bf983a3b497d54406103d0209b553a7a/setup.py#L52-53). From what I can tell, this was an issue before (#426) and was subsequently fixed (#489) but then again broken (https://github.com/qutip/qutip/commit/82e209512927a0d6086de31364004fdb0da8c59a). Sidestepping this would be great since for instance readthedocs to my knowledge doesn't allow running custom commands (like `pip install cython`) before installing dependencies when building a documentation that requires `qutip`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1174
https://github.com/qutip/qutip/issues/1174:34,Integrability,depend,dependency,34,"Installing `qutip` as an external dependency fails if `cython` is not installed since it's imported without checks in [`setup.py`.](https://github.com/qutip/qutip/blob/0f412cd4bf983a3b497d54406103d0209b553a7a/setup.py#L52-53). From what I can tell, this was an issue before (#426) and was subsequently fixed (#489) but then again broken (https://github.com/qutip/qutip/commit/82e209512927a0d6086de31364004fdb0da8c59a). Sidestepping this would be great since for instance readthedocs to my knowledge doesn't allow running custom commands (like `pip install cython`) before installing dependencies when building a documentation that requires `qutip`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1174
https://github.com/qutip/qutip/issues/1174:583,Integrability,depend,dependencies,583,"Installing `qutip` as an external dependency fails if `cython` is not installed since it's imported without checks in [`setup.py`.](https://github.com/qutip/qutip/blob/0f412cd4bf983a3b497d54406103d0209b553a7a/setup.py#L52-53). From what I can tell, this was an issue before (#426) and was subsequently fixed (#489) but then again broken (https://github.com/qutip/qutip/commit/82e209512927a0d6086de31364004fdb0da8c59a). Sidestepping this would be great since for instance readthedocs to my knowledge doesn't allow running custom commands (like `pip install cython`) before installing dependencies when building a documentation that requires `qutip`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1174
https://github.com/qutip/qutip/issues/1175:311,Availability,down,down,311,"I am distributing some qutip code to several cores. I want to enforce that qutip only uses one core per job with qutip.settings.num_cpus=1, but it is not working, the processes still take all the processors of my machine, so that if I have N cores, the multiprocessing ends up using N*N threads, slowing things down a lot! How can I force qutip to use only 1 core? Currently loading like this:. ```; from qutip import create, destroy, Qobj, expect, tensor, qeye, fidelity, basis, variance, settings; from pathos.multiprocessing import ProcessingPool. settings.num_cpus = 1; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1175
https://github.com/qutip/qutip/issues/1175:375,Performance,load,loading,375,"I am distributing some qutip code to several cores. I want to enforce that qutip only uses one core per job with qutip.settings.num_cpus=1, but it is not working, the processes still take all the processors of my machine, so that if I have N cores, the multiprocessing ends up using N*N threads, slowing things down a lot! How can I force qutip to use only 1 core? Currently loading like this:. ```; from qutip import create, destroy, Qobj, expect, tensor, qeye, fidelity, basis, variance, settings; from pathos.multiprocessing import ProcessingPool. settings.num_cpus = 1; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1175
https://github.com/qutip/qutip/issues/1176:26,Availability,error,error,26,"I'm getting the following error when the first three arguments for the clebsch function aren't all ints: ; ```; c_factor = np.zeros((j1 + j2 + j3 + 1), np.int32); TypeError: 'float' object cannot be interpreted as an integer; ```; Fixed by changing ; `c_factor = np.zeros((j1 + j2 + j3 + 1), np.int32) `; to ; `c_factor = np.zeros((int(j1 + j2 + j3 + 1)), np.int32)`; and same for _factorial_prod() etc. It's now giving expected results. This shouldn't break anything as j1 +/- j2 +/- j3 should always give an integer. Seems to have been caused by #1142 in response to #1141.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1176
https://github.com/qutip/qutip/pull/1177:47,Testability,Test,Test,47,"Changed `clebsch` to work with non-int inputs. Test file shows it working for both int and float inputs, giving expected results.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1177
https://github.com/qutip/qutip/pull/1178:8,Availability,error,error,8,Removed error when converting qcirc.pdf to qcirc.png on windows.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1178
https://github.com/qutip/qutip/pull/1179:8,Availability,error,error,8,Removed error when converting qcirc.pdf to qcirc.png on windows.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1179
https://github.com/qutip/qutip/issues/1180:598,Deployability,integrat,integrate,598,"I'm using qutip to simulate lindblad dynamics. However, compared to the method I wrote myself with scipy, the one I wrote with qutip mesolve() was much slower. Did I do something wrong or it's expected?; Here's my code. ```python; def simulate_lind (self, t):; 		""""""simulate the lindblad dynamics; 		Arguments:; 			t -- time for propagation; 		""""""; 		if self.impl == 'direct':#my implementation; 			rho0 = np.reshape(self.psi0, (self.n)**2); 			r = ode(self.__lind).set_integrator('zvode', method='bdf'); 			r.set_initial_value(rho0, 0); 			r.set_f_params(self.H, self.gamma, self.A, self.n); 			r.integrate(r.t); 			rhot = r.y; 			rhot = np.reshape(rhot, (self.n, self.n)); 		elif self.impl == 'qutip': #with qutip; 			rho0 = Qobj(self.psi0); 			rhot = mesolve(Qobj(self.H), rho0, [0, t], [np.sqrt(self.gamma) * Qobj(self.A)]).states[-1].full(); 		self.psi0 = rhot; 		return self.psi0; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1180
https://github.com/qutip/qutip/issues/1180:598,Integrability,integrat,integrate,598,"I'm using qutip to simulate lindblad dynamics. However, compared to the method I wrote myself with scipy, the one I wrote with qutip mesolve() was much slower. Did I do something wrong or it's expected?; Here's my code. ```python; def simulate_lind (self, t):; 		""""""simulate the lindblad dynamics; 		Arguments:; 			t -- time for propagation; 		""""""; 		if self.impl == 'direct':#my implementation; 			rho0 = np.reshape(self.psi0, (self.n)**2); 			r = ode(self.__lind).set_integrator('zvode', method='bdf'); 			r.set_initial_value(rho0, 0); 			r.set_f_params(self.H, self.gamma, self.A, self.n); 			r.integrate(r.t); 			rhot = r.y; 			rhot = np.reshape(rhot, (self.n, self.n)); 		elif self.impl == 'qutip': #with qutip; 			rho0 = Qobj(self.psi0); 			rhot = mesolve(Qobj(self.H), rho0, [0, t], [np.sqrt(self.gamma) * Qobj(self.A)]).states[-1].full(); 		self.psi0 = rhot; 		return self.psi0; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1180
https://github.com/qutip/qutip/pull/1181:70,Integrability,depend,depending,70,"Continuing the work of #1164 - this is part two of many more to come, depending on how long I can keep doing this! Of particular note is the first commit in this PR, which registers `pytest.mark.slow` with `pytest` to stop it warning about an unknown mark in use. There are several additional comments and explanations in the expanded commit messages, where I've tried to explain a little bit about bugs I found and reasons for swapping over to certain libraries (e.g. for temporary file handling). I'm in part opening a new PR now so that I can see if the CodeClimate tests are passing. I shouldn't have many pep8 issues because I have a tool to check, but I don't have CodeClimate working locally for things like the complexity (if it even checks them for tests...). I've been really rather aggressively using the parametrisation that `pytest` offers for fixtures, which is cutting out an awful lot of code duplication, and hopefully making it a bit clearer when things are exactly the same. One common theme I'm finding when I'm running these tests is that there's an awful lot of warnings caused by `pyximport`, a part of `Cython`, which is using the Python 2 era `imp` instead of the newer `importlib`. I'm not sure there's anything we can or should do about this, though.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1181
https://github.com/qutip/qutip/pull/1181:342,Integrability,message,messages,342,"Continuing the work of #1164 - this is part two of many more to come, depending on how long I can keep doing this! Of particular note is the first commit in this PR, which registers `pytest.mark.slow` with `pytest` to stop it warning about an unknown mark in use. There are several additional comments and explanations in the expanded commit messages, where I've tried to explain a little bit about bugs I found and reasons for swapping over to certain libraries (e.g. for temporary file handling). I'm in part opening a new PR now so that I can see if the CodeClimate tests are passing. I shouldn't have many pep8 issues because I have a tool to check, but I don't have CodeClimate working locally for things like the complexity (if it even checks them for tests...). I've been really rather aggressively using the parametrisation that `pytest` offers for fixtures, which is cutting out an awful lot of code duplication, and hopefully making it a bit clearer when things are exactly the same. One common theme I'm finding when I'm running these tests is that there's an awful lot of warnings caused by `pyximport`, a part of `Cython`, which is using the Python 2 era `imp` instead of the newer `importlib`. I'm not sure there's anything we can or should do about this, though.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1181
https://github.com/qutip/qutip/pull/1181:569,Testability,test,tests,569,"Continuing the work of #1164 - this is part two of many more to come, depending on how long I can keep doing this! Of particular note is the first commit in this PR, which registers `pytest.mark.slow` with `pytest` to stop it warning about an unknown mark in use. There are several additional comments and explanations in the expanded commit messages, where I've tried to explain a little bit about bugs I found and reasons for swapping over to certain libraries (e.g. for temporary file handling). I'm in part opening a new PR now so that I can see if the CodeClimate tests are passing. I shouldn't have many pep8 issues because I have a tool to check, but I don't have CodeClimate working locally for things like the complexity (if it even checks them for tests...). I've been really rather aggressively using the parametrisation that `pytest` offers for fixtures, which is cutting out an awful lot of code duplication, and hopefully making it a bit clearer when things are exactly the same. One common theme I'm finding when I'm running these tests is that there's an awful lot of warnings caused by `pyximport`, a part of `Cython`, which is using the Python 2 era `imp` instead of the newer `importlib`. I'm not sure there's anything we can or should do about this, though.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1181
https://github.com/qutip/qutip/pull/1181:758,Testability,test,tests,758,"Continuing the work of #1164 - this is part two of many more to come, depending on how long I can keep doing this! Of particular note is the first commit in this PR, which registers `pytest.mark.slow` with `pytest` to stop it warning about an unknown mark in use. There are several additional comments and explanations in the expanded commit messages, where I've tried to explain a little bit about bugs I found and reasons for swapping over to certain libraries (e.g. for temporary file handling). I'm in part opening a new PR now so that I can see if the CodeClimate tests are passing. I shouldn't have many pep8 issues because I have a tool to check, but I don't have CodeClimate working locally for things like the complexity (if it even checks them for tests...). I've been really rather aggressively using the parametrisation that `pytest` offers for fixtures, which is cutting out an awful lot of code duplication, and hopefully making it a bit clearer when things are exactly the same. One common theme I'm finding when I'm running these tests is that there's an awful lot of warnings caused by `pyximport`, a part of `Cython`, which is using the Python 2 era `imp` instead of the newer `importlib`. I'm not sure there's anything we can or should do about this, though.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1181
https://github.com/qutip/qutip/pull/1181:1046,Testability,test,tests,1046,"Continuing the work of #1164 - this is part two of many more to come, depending on how long I can keep doing this! Of particular note is the first commit in this PR, which registers `pytest.mark.slow` with `pytest` to stop it warning about an unknown mark in use. There are several additional comments and explanations in the expanded commit messages, where I've tried to explain a little bit about bugs I found and reasons for swapping over to certain libraries (e.g. for temporary file handling). I'm in part opening a new PR now so that I can see if the CodeClimate tests are passing. I shouldn't have many pep8 issues because I have a tool to check, but I don't have CodeClimate working locally for things like the complexity (if it even checks them for tests...). I've been really rather aggressively using the parametrisation that `pytest` offers for fixtures, which is cutting out an awful lot of code duplication, and hopefully making it a bit clearer when things are exactly the same. One common theme I'm finding when I'm running these tests is that there's an awful lot of warnings caused by `pyximport`, a part of `Cython`, which is using the Python 2 era `imp` instead of the newer `importlib`. I'm not sure there's anything we can or should do about this, though.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1181
https://github.com/qutip/qutip/pull/1181:952,Usability,clear,clearer,952,"Continuing the work of #1164 - this is part two of many more to come, depending on how long I can keep doing this! Of particular note is the first commit in this PR, which registers `pytest.mark.slow` with `pytest` to stop it warning about an unknown mark in use. There are several additional comments and explanations in the expanded commit messages, where I've tried to explain a little bit about bugs I found and reasons for swapping over to certain libraries (e.g. for temporary file handling). I'm in part opening a new PR now so that I can see if the CodeClimate tests are passing. I shouldn't have many pep8 issues because I have a tool to check, but I don't have CodeClimate working locally for things like the complexity (if it even checks them for tests...). I've been really rather aggressively using the parametrisation that `pytest` offers for fixtures, which is cutting out an awful lot of code duplication, and hopefully making it a bit clearer when things are exactly the same. One common theme I'm finding when I'm running these tests is that there's an awful lot of warnings caused by `pyximport`, a part of `Cython`, which is using the Python 2 era `imp` instead of the newer `importlib`. I'm not sure there's anything we can or should do about this, though.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1181
https://github.com/qutip/qutip/issues/1182:736,Integrability,depend,depending,736,"Consider the following code:. ```; import qutip; import matplotlib.pyplot as plt. b = qutip.Bloch(); b.show(); ```. When run in a Jupyter notebook, as per the tutorial on http://qutip.org/docs/latest/guide/guide-bloch.html, the Bloch sphere is immediately displayed in the cell output. However, nothing is displayed (no matplotlib window opens) when this code is run as a standalone script from the terminal, or even in IPython. For this, an additional call to `plt.show()` is required. I understand how this behaviour could be useful when moving code that has been developed in a notebook into a standalone script, as `plt.show()` is a blocking command. However, I still see this as inconsistent as we get distinctly different results depending on where the code is being run. If this is indeed intentional behaviour, might I suggest a note in the tutorial/API documentation? At present, there is no way to tell that this is what happens and if this is consistent. (It is possible that this is specific to my OS/environment, so I can provide those details if necessary)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1182
https://github.com/qutip/qutip/issues/1182:200,Usability,guid,guide,200,"Consider the following code:. ```; import qutip; import matplotlib.pyplot as plt. b = qutip.Bloch(); b.show(); ```. When run in a Jupyter notebook, as per the tutorial on http://qutip.org/docs/latest/guide/guide-bloch.html, the Bloch sphere is immediately displayed in the cell output. However, nothing is displayed (no matplotlib window opens) when this code is run as a standalone script from the terminal, or even in IPython. For this, an additional call to `plt.show()` is required. I understand how this behaviour could be useful when moving code that has been developed in a notebook into a standalone script, as `plt.show()` is a blocking command. However, I still see this as inconsistent as we get distinctly different results depending on where the code is being run. If this is indeed intentional behaviour, might I suggest a note in the tutorial/API documentation? At present, there is no way to tell that this is what happens and if this is consistent. (It is possible that this is specific to my OS/environment, so I can provide those details if necessary)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1182
https://github.com/qutip/qutip/issues/1182:206,Usability,guid,guide-bloch,206,"Consider the following code:. ```; import qutip; import matplotlib.pyplot as plt. b = qutip.Bloch(); b.show(); ```. When run in a Jupyter notebook, as per the tutorial on http://qutip.org/docs/latest/guide/guide-bloch.html, the Bloch sphere is immediately displayed in the cell output. However, nothing is displayed (no matplotlib window opens) when this code is run as a standalone script from the terminal, or even in IPython. For this, an additional call to `plt.show()` is required. I understand how this behaviour could be useful when moving code that has been developed in a notebook into a standalone script, as `plt.show()` is a blocking command. However, I still see this as inconsistent as we get distinctly different results depending on where the code is being run. If this is indeed intentional behaviour, might I suggest a note in the tutorial/API documentation? At present, there is no way to tell that this is what happens and if this is consistent. (It is possible that this is specific to my OS/environment, so I can provide those details if necessary)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1182
https://github.com/qutip/qutip/issues/1183:90,Availability,error,error,90,"Hi, I am trying to take tensor product of time dependent collapse operators but following error crops up,. TypeError: One of inputs is not a quantum object. Following is the tensor product I wanted to take:. V_ft=np.sqrt(kappa_f)*tensor([[destroy(2),[Qobj(np.array([[0,complex(0,-1)*np.conj(H_a01)],[0,0]]),dims=[[2],[2]]), u_t]],[destroy(2),[Qobj(np.array([[0,complex(0,-1)*np.conj(H_b01)],[0,0]]),dims=[[2],[2]]), u_t]],[destroy(2),[Qobj(np.array([[0,complex(0,-1)*np.conj(H_c01)],[0,0]]),dims=[[2],[2]]), u_t]]]",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1183
https://github.com/qutip/qutip/issues/1183:47,Integrability,depend,dependent,47,"Hi, I am trying to take tensor product of time dependent collapse operators but following error crops up,. TypeError: One of inputs is not a quantum object. Following is the tensor product I wanted to take:. V_ft=np.sqrt(kappa_f)*tensor([[destroy(2),[Qobj(np.array([[0,complex(0,-1)*np.conj(H_a01)],[0,0]]),dims=[[2],[2]]), u_t]],[destroy(2),[Qobj(np.array([[0,complex(0,-1)*np.conj(H_b01)],[0,0]]),dims=[[2],[2]]), u_t]],[destroy(2),[Qobj(np.array([[0,complex(0,-1)*np.conj(H_c01)],[0,0]]),dims=[[2],[2]]), u_t]]]",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1183
https://github.com/qutip/qutip/issues/1184:58,Availability,Error,Error,58,"I have some detail information for the GSoC 2020 project ""Error mitigation in QuTiP"". Unfortunately, I don't have writing access to the QuTiP GitHub Wiki page. I post it here so if anyone finding it nice could copy it to the Wiki page. I add some details based on the original description:. -----------------------------------; ## 1. Error mitigation in QuTiP; From the QuTiP 4.5 release, the qutip.qip module now contains the noisy quantum circuit simulator (which was a GSoC project) providing enhanced features for a pulse-level description of quantum circuits and noise models. A new class `Processor` and several subclasses are added to represent different platforms for quantum computing. They can transfer a quantum circuit into the corresponding control sequence and simulate the dynamics with QuTiP solvers. Different noise models can be added to `qutip.qip.noise` to simulate noise in a quantum device. . This module is still young and many features can be improved, including new device models, new noise models and integration with the existing general framework for quantum circuits (`qutip.qip.circuit`). There are also possible applications such as error mitigation techniques [1-3]. The tutorial notebooks can be found at http://qutip.org/tutorials.html#nisq. A recent presentation on the FOSDEM conference may help you get an overview (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github Project page for a collection of related issues and ongoing Pull Requests. ### Expected outcomes; - More devices defined in the `qutip.qip.device` module. At the moment, we have two models: spin chain and cavity QED. We would like to include some other commonly used planform such as Superconducting system, Ion trap system or silicon system. Each model will need a new set of control hamiltonian and a compiler that find the control pulse of a quantum gate. This part is gonna involve some physics and study of commonly used hardware platforms. The related code can be fo",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1184
https://github.com/qutip/qutip/issues/1184:334,Availability,Error,Error,334,"I have some detail information for the GSoC 2020 project ""Error mitigation in QuTiP"". Unfortunately, I don't have writing access to the QuTiP GitHub Wiki page. I post it here so if anyone finding it nice could copy it to the Wiki page. I add some details based on the original description:. -----------------------------------; ## 1. Error mitigation in QuTiP; From the QuTiP 4.5 release, the qutip.qip module now contains the noisy quantum circuit simulator (which was a GSoC project) providing enhanced features for a pulse-level description of quantum circuits and noise models. A new class `Processor` and several subclasses are added to represent different platforms for quantum computing. They can transfer a quantum circuit into the corresponding control sequence and simulate the dynamics with QuTiP solvers. Different noise models can be added to `qutip.qip.noise` to simulate noise in a quantum device. . This module is still young and many features can be improved, including new device models, new noise models and integration with the existing general framework for quantum circuits (`qutip.qip.circuit`). There are also possible applications such as error mitigation techniques [1-3]. The tutorial notebooks can be found at http://qutip.org/tutorials.html#nisq. A recent presentation on the FOSDEM conference may help you get an overview (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github Project page for a collection of related issues and ongoing Pull Requests. ### Expected outcomes; - More devices defined in the `qutip.qip.device` module. At the moment, we have two models: spin chain and cavity QED. We would like to include some other commonly used planform such as Superconducting system, Ion trap system or silicon system. Each model will need a new set of control hamiltonian and a compiler that find the control pulse of a quantum gate. This part is gonna involve some physics and study of commonly used hardware platforms. The related code can be fo",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1184
https://github.com/qutip/qutip/issues/1184:1164,Availability,error,error,1164,". I post it here so if anyone finding it nice could copy it to the Wiki page. I add some details based on the original description:. -----------------------------------; ## 1. Error mitigation in QuTiP; From the QuTiP 4.5 release, the qutip.qip module now contains the noisy quantum circuit simulator (which was a GSoC project) providing enhanced features for a pulse-level description of quantum circuits and noise models. A new class `Processor` and several subclasses are added to represent different platforms for quantum computing. They can transfer a quantum circuit into the corresponding control sequence and simulate the dynamics with QuTiP solvers. Different noise models can be added to `qutip.qip.noise` to simulate noise in a quantum device. . This module is still young and many features can be improved, including new device models, new noise models and integration with the existing general framework for quantum circuits (`qutip.qip.circuit`). There are also possible applications such as error mitigation techniques [1-3]. The tutorial notebooks can be found at http://qutip.org/tutorials.html#nisq. A recent presentation on the FOSDEM conference may help you get an overview (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github Project page for a collection of related issues and ongoing Pull Requests. ### Expected outcomes; - More devices defined in the `qutip.qip.device` module. At the moment, we have two models: spin chain and cavity QED. We would like to include some other commonly used planform such as Superconducting system, Ion trap system or silicon system. Each model will need a new set of control hamiltonian and a compiler that find the control pulse of a quantum gate. This part is gonna involve some physics and study of commonly used hardware platforms. The related code can be found in `qutip.qip.device` and `qutip.qip.compiler`; - Refactoring the circuit compiler to allow simple pulse scheduling, e.g. Restriction one pulses that can",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1184
https://github.com/qutip/qutip/issues/1184:2213,Availability,error,error,2213,"g. They can transfer a quantum circuit into the corresponding control sequence and simulate the dynamics with QuTiP solvers. Different noise models can be added to `qutip.qip.noise` to simulate noise in a quantum device. . This module is still young and many features can be improved, including new device models, new noise models and integration with the existing general framework for quantum circuits (`qutip.qip.circuit`). There are also possible applications such as error mitigation techniques [1-3]. The tutorial notebooks can be found at http://qutip.org/tutorials.html#nisq. A recent presentation on the FOSDEM conference may help you get an overview (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github Project page for a collection of related issues and ongoing Pull Requests. ### Expected outcomes; - More devices defined in the `qutip.qip.device` module. At the moment, we have two models: spin chain and cavity QED. We would like to include some other commonly used planform such as Superconducting system, Ion trap system or silicon system. Each model will need a new set of control hamiltonian and a compiler that find the control pulse of a quantum gate. This part is gonna involve some physics and study of commonly used hardware platforms. The related code can be found in `qutip.qip.device` and `qutip.qip.compiler`; - Refactoring the circuit compiler to allow simple pulse scheduling, e.g. Restriction one pulses that can be turned on at the same time.; - Features to perform error mitigation techniques in QuTiP, such as zero-error extrapolation.; - APIs to allow import quantum circuits from other software packages or commonly used language e.g. through quantum assembly language (qasm); ----------------------------------------------------------------. Also, the last outcomes have some overlap with the last project. Although I also find this circuit importation very important, I guess two projects should not have overlap if they are both selected.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1184
https://github.com/qutip/qutip/issues/1184:2264,Availability,error,error,2264,"g. They can transfer a quantum circuit into the corresponding control sequence and simulate the dynamics with QuTiP solvers. Different noise models can be added to `qutip.qip.noise` to simulate noise in a quantum device. . This module is still young and many features can be improved, including new device models, new noise models and integration with the existing general framework for quantum circuits (`qutip.qip.circuit`). There are also possible applications such as error mitigation techniques [1-3]. The tutorial notebooks can be found at http://qutip.org/tutorials.html#nisq. A recent presentation on the FOSDEM conference may help you get an overview (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github Project page for a collection of related issues and ongoing Pull Requests. ### Expected outcomes; - More devices defined in the `qutip.qip.device` module. At the moment, we have two models: spin chain and cavity QED. We would like to include some other commonly used planform such as Superconducting system, Ion trap system or silicon system. Each model will need a new set of control hamiltonian and a compiler that find the control pulse of a quantum gate. This part is gonna involve some physics and study of commonly used hardware platforms. The related code can be found in `qutip.qip.device` and `qutip.qip.compiler`; - Refactoring the circuit compiler to allow simple pulse scheduling, e.g. Restriction one pulses that can be turned on at the same time.; - Features to perform error mitigation techniques in QuTiP, such as zero-error extrapolation.; - APIs to allow import quantum circuits from other software packages or commonly used language e.g. through quantum assembly language (qasm); ----------------------------------------------------------------. Also, the last outcomes have some overlap with the last project. Although I also find this circuit importation very important, I guess two projects should not have overlap if they are both selected.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1184
https://github.com/qutip/qutip/issues/1184:380,Deployability,release,release,380,"I have some detail information for the GSoC 2020 project ""Error mitigation in QuTiP"". Unfortunately, I don't have writing access to the QuTiP GitHub Wiki page. I post it here so if anyone finding it nice could copy it to the Wiki page. I add some details based on the original description:. -----------------------------------; ## 1. Error mitigation in QuTiP; From the QuTiP 4.5 release, the qutip.qip module now contains the noisy quantum circuit simulator (which was a GSoC project) providing enhanced features for a pulse-level description of quantum circuits and noise models. A new class `Processor` and several subclasses are added to represent different platforms for quantum computing. They can transfer a quantum circuit into the corresponding control sequence and simulate the dynamics with QuTiP solvers. Different noise models can be added to `qutip.qip.noise` to simulate noise in a quantum device. . This module is still young and many features can be improved, including new device models, new noise models and integration with the existing general framework for quantum circuits (`qutip.qip.circuit`). There are also possible applications such as error mitigation techniques [1-3]. The tutorial notebooks can be found at http://qutip.org/tutorials.html#nisq. A recent presentation on the FOSDEM conference may help you get an overview (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github Project page for a collection of related issues and ongoing Pull Requests. ### Expected outcomes; - More devices defined in the `qutip.qip.device` module. At the moment, we have two models: spin chain and cavity QED. We would like to include some other commonly used planform such as Superconducting system, Ion trap system or silicon system. Each model will need a new set of control hamiltonian and a compiler that find the control pulse of a quantum gate. This part is gonna involve some physics and study of commonly used hardware platforms. The related code can be fo",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1184
https://github.com/qutip/qutip/issues/1184:1027,Deployability,integrat,integration,1027,"me detail information for the GSoC 2020 project ""Error mitigation in QuTiP"". Unfortunately, I don't have writing access to the QuTiP GitHub Wiki page. I post it here so if anyone finding it nice could copy it to the Wiki page. I add some details based on the original description:. -----------------------------------; ## 1. Error mitigation in QuTiP; From the QuTiP 4.5 release, the qutip.qip module now contains the noisy quantum circuit simulator (which was a GSoC project) providing enhanced features for a pulse-level description of quantum circuits and noise models. A new class `Processor` and several subclasses are added to represent different platforms for quantum computing. They can transfer a quantum circuit into the corresponding control sequence and simulate the dynamics with QuTiP solvers. Different noise models can be added to `qutip.qip.noise` to simulate noise in a quantum device. . This module is still young and many features can be improved, including new device models, new noise models and integration with the existing general framework for quantum circuits (`qutip.qip.circuit`). There are also possible applications such as error mitigation techniques [1-3]. The tutorial notebooks can be found at http://qutip.org/tutorials.html#nisq. A recent presentation on the FOSDEM conference may help you get an overview (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github Project page for a collection of related issues and ongoing Pull Requests. ### Expected outcomes; - More devices defined in the `qutip.qip.device` module. At the moment, we have two models: spin chain and cavity QED. We would like to include some other commonly used planform such as Superconducting system, Ion trap system or silicon system. Each model will need a new set of control hamiltonian and a compiler that find the control pulse of a quantum gate. This part is gonna involve some physics and study of commonly used hardware platforms. The related code can be found in `",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1184
https://github.com/qutip/qutip/issues/1184:1377,Energy Efficiency,schedul,schedule,1377," the qutip.qip module now contains the noisy quantum circuit simulator (which was a GSoC project) providing enhanced features for a pulse-level description of quantum circuits and noise models. A new class `Processor` and several subclasses are added to represent different platforms for quantum computing. They can transfer a quantum circuit into the corresponding control sequence and simulate the dynamics with QuTiP solvers. Different noise models can be added to `qutip.qip.noise` to simulate noise in a quantum device. . This module is still young and many features can be improved, including new device models, new noise models and integration with the existing general framework for quantum circuits (`qutip.qip.circuit`). There are also possible applications such as error mitigation techniques [1-3]. The tutorial notebooks can be found at http://qutip.org/tutorials.html#nisq. A recent presentation on the FOSDEM conference may help you get an overview (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github Project page for a collection of related issues and ongoing Pull Requests. ### Expected outcomes; - More devices defined in the `qutip.qip.device` module. At the moment, we have two models: spin chain and cavity QED. We would like to include some other commonly used planform such as Superconducting system, Ion trap system or silicon system. Each model will need a new set of control hamiltonian and a compiler that find the control pulse of a quantum gate. This part is gonna involve some physics and study of commonly used hardware platforms. The related code can be found in `qutip.qip.device` and `qutip.qip.compiler`; - Refactoring the circuit compiler to allow simple pulse scheduling, e.g. Restriction one pulses that can be turned on at the same time.; - Features to perform error mitigation techniques in QuTiP, such as zero-error extrapolation.; - APIs to allow import quantum circuits from other software packages or commonly used language e.g. th",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1184
https://github.com/qutip/qutip/issues/1184:2110,Energy Efficiency,schedul,scheduling,2110,"g. They can transfer a quantum circuit into the corresponding control sequence and simulate the dynamics with QuTiP solvers. Different noise models can be added to `qutip.qip.noise` to simulate noise in a quantum device. . This module is still young and many features can be improved, including new device models, new noise models and integration with the existing general framework for quantum circuits (`qutip.qip.circuit`). There are also possible applications such as error mitigation techniques [1-3]. The tutorial notebooks can be found at http://qutip.org/tutorials.html#nisq. A recent presentation on the FOSDEM conference may help you get an overview (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github Project page for a collection of related issues and ongoing Pull Requests. ### Expected outcomes; - More devices defined in the `qutip.qip.device` module. At the moment, we have two models: spin chain and cavity QED. We would like to include some other commonly used planform such as Superconducting system, Ion trap system or silicon system. Each model will need a new set of control hamiltonian and a compiler that find the control pulse of a quantum gate. This part is gonna involve some physics and study of commonly used hardware platforms. The related code can be found in `qutip.qip.device` and `qutip.qip.compiler`; - Refactoring the circuit compiler to allow simple pulse scheduling, e.g. Restriction one pulses that can be turned on at the same time.; - Features to perform error mitigation techniques in QuTiP, such as zero-error extrapolation.; - APIs to allow import quantum circuits from other software packages or commonly used language e.g. through quantum assembly language (qasm); ----------------------------------------------------------------. Also, the last outcomes have some overlap with the last project. Although I also find this circuit importation very important, I guess two projects should not have overlap if they are both selected.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1184
https://github.com/qutip/qutip/issues/1184:1027,Integrability,integrat,integration,1027,"me detail information for the GSoC 2020 project ""Error mitigation in QuTiP"". Unfortunately, I don't have writing access to the QuTiP GitHub Wiki page. I post it here so if anyone finding it nice could copy it to the Wiki page. I add some details based on the original description:. -----------------------------------; ## 1. Error mitigation in QuTiP; From the QuTiP 4.5 release, the qutip.qip module now contains the noisy quantum circuit simulator (which was a GSoC project) providing enhanced features for a pulse-level description of quantum circuits and noise models. A new class `Processor` and several subclasses are added to represent different platforms for quantum computing. They can transfer a quantum circuit into the corresponding control sequence and simulate the dynamics with QuTiP solvers. Different noise models can be added to `qutip.qip.noise` to simulate noise in a quantum device. . This module is still young and many features can be improved, including new device models, new noise models and integration with the existing general framework for quantum circuits (`qutip.qip.circuit`). There are also possible applications such as error mitigation techniques [1-3]. The tutorial notebooks can be found at http://qutip.org/tutorials.html#nisq. A recent presentation on the FOSDEM conference may help you get an overview (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github Project page for a collection of related issues and ongoing Pull Requests. ### Expected outcomes; - More devices defined in the `qutip.qip.device` module. At the moment, we have two models: spin chain and cavity QED. We would like to include some other commonly used planform such as Superconducting system, Ion trap system or silicon system. Each model will need a new set of control hamiltonian and a compiler that find the control pulse of a quantum gate. This part is gonna involve some physics and study of commonly used hardware platforms. The related code can be found in `",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1184
https://github.com/qutip/qutip/issues/1184:496,Modifiability,enhance,enhanced,496,"I have some detail information for the GSoC 2020 project ""Error mitigation in QuTiP"". Unfortunately, I don't have writing access to the QuTiP GitHub Wiki page. I post it here so if anyone finding it nice could copy it to the Wiki page. I add some details based on the original description:. -----------------------------------; ## 1. Error mitigation in QuTiP; From the QuTiP 4.5 release, the qutip.qip module now contains the noisy quantum circuit simulator (which was a GSoC project) providing enhanced features for a pulse-level description of quantum circuits and noise models. A new class `Processor` and several subclasses are added to represent different platforms for quantum computing. They can transfer a quantum circuit into the corresponding control sequence and simulate the dynamics with QuTiP solvers. Different noise models can be added to `qutip.qip.noise` to simulate noise in a quantum device. . This module is still young and many features can be improved, including new device models, new noise models and integration with the existing general framework for quantum circuits (`qutip.qip.circuit`). There are also possible applications such as error mitigation techniques [1-3]. The tutorial notebooks can be found at http://qutip.org/tutorials.html#nisq. A recent presentation on the FOSDEM conference may help you get an overview (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github Project page for a collection of related issues and ongoing Pull Requests. ### Expected outcomes; - More devices defined in the `qutip.qip.device` module. At the moment, we have two models: spin chain and cavity QED. We would like to include some other commonly used planform such as Superconducting system, Ion trap system or silicon system. Each model will need a new set of control hamiltonian and a compiler that find the control pulse of a quantum gate. This part is gonna involve some physics and study of commonly used hardware platforms. The related code can be fo",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1184
https://github.com/qutip/qutip/issues/1184:2055,Modifiability,Refactor,Refactoring,2055,"g. They can transfer a quantum circuit into the corresponding control sequence and simulate the dynamics with QuTiP solvers. Different noise models can be added to `qutip.qip.noise` to simulate noise in a quantum device. . This module is still young and many features can be improved, including new device models, new noise models and integration with the existing general framework for quantum circuits (`qutip.qip.circuit`). There are also possible applications such as error mitigation techniques [1-3]. The tutorial notebooks can be found at http://qutip.org/tutorials.html#nisq. A recent presentation on the FOSDEM conference may help you get an overview (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github Project page for a collection of related issues and ongoing Pull Requests. ### Expected outcomes; - More devices defined in the `qutip.qip.device` module. At the moment, we have two models: spin chain and cavity QED. We would like to include some other commonly used planform such as Superconducting system, Ion trap system or silicon system. Each model will need a new set of control hamiltonian and a compiler that find the control pulse of a quantum gate. This part is gonna involve some physics and study of commonly used hardware platforms. The related code can be found in `qutip.qip.device` and `qutip.qip.compiler`; - Refactoring the circuit compiler to allow simple pulse scheduling, e.g. Restriction one pulses that can be turned on at the same time.; - Features to perform error mitigation techniques in QuTiP, such as zero-error extrapolation.; - APIs to allow import quantum circuits from other software packages or commonly used language e.g. through quantum assembly language (qasm); ----------------------------------------------------------------. Also, the last outcomes have some overlap with the last project. Although I also find this circuit importation very important, I guess two projects should not have overlap if they are both selected.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1184
https://github.com/qutip/qutip/issues/1184:2205,Performance,perform,perform,2205,"g. They can transfer a quantum circuit into the corresponding control sequence and simulate the dynamics with QuTiP solvers. Different noise models can be added to `qutip.qip.noise` to simulate noise in a quantum device. . This module is still young and many features can be improved, including new device models, new noise models and integration with the existing general framework for quantum circuits (`qutip.qip.circuit`). There are also possible applications such as error mitigation techniques [1-3]. The tutorial notebooks can be found at http://qutip.org/tutorials.html#nisq. A recent presentation on the FOSDEM conference may help you get an overview (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github Project page for a collection of related issues and ongoing Pull Requests. ### Expected outcomes; - More devices defined in the `qutip.qip.device` module. At the moment, we have two models: spin chain and cavity QED. We would like to include some other commonly used planform such as Superconducting system, Ion trap system or silicon system. Each model will need a new set of control hamiltonian and a compiler that find the control pulse of a quantum gate. This part is gonna involve some physics and study of commonly used hardware platforms. The related code can be found in `qutip.qip.device` and `qutip.qip.compiler`; - Refactoring the circuit compiler to allow simple pulse scheduling, e.g. Restriction one pulses that can be turned on at the same time.; - Features to perform error mitigation techniques in QuTiP, such as zero-error extrapolation.; - APIs to allow import quantum circuits from other software packages or commonly used language e.g. through quantum assembly language (qasm); ----------------------------------------------------------------. Also, the last outcomes have some overlap with the last project. Although I also find this circuit importation very important, I guess two projects should not have overlap if they are both selected.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1184
https://github.com/qutip/qutip/issues/1184:122,Security,access,access,122,"I have some detail information for the GSoC 2020 project ""Error mitigation in QuTiP"". Unfortunately, I don't have writing access to the QuTiP GitHub Wiki page. I post it here so if anyone finding it nice could copy it to the Wiki page. I add some details based on the original description:. -----------------------------------; ## 1. Error mitigation in QuTiP; From the QuTiP 4.5 release, the qutip.qip module now contains the noisy quantum circuit simulator (which was a GSoC project) providing enhanced features for a pulse-level description of quantum circuits and noise models. A new class `Processor` and several subclasses are added to represent different platforms for quantum computing. They can transfer a quantum circuit into the corresponding control sequence and simulate the dynamics with QuTiP solvers. Different noise models can be added to `qutip.qip.noise` to simulate noise in a quantum device. . This module is still young and many features can be improved, including new device models, new noise models and integration with the existing general framework for quantum circuits (`qutip.qip.circuit`). There are also possible applications such as error mitigation techniques [1-3]. The tutorial notebooks can be found at http://qutip.org/tutorials.html#nisq. A recent presentation on the FOSDEM conference may help you get an overview (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github Project page for a collection of related issues and ongoing Pull Requests. ### Expected outcomes; - More devices defined in the `qutip.qip.device` module. At the moment, we have two models: spin chain and cavity QED. We would like to include some other commonly used planform such as Superconducting system, Ion trap system or silicon system. Each model will need a new set of control hamiltonian and a compiler that find the control pulse of a quantum gate. This part is gonna involve some physics and study of commonly used hardware platforms. The related code can be fo",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1184
https://github.com/qutip/qutip/issues/1184:2097,Usability,simpl,simple,2097,"g. They can transfer a quantum circuit into the corresponding control sequence and simulate the dynamics with QuTiP solvers. Different noise models can be added to `qutip.qip.noise` to simulate noise in a quantum device. . This module is still young and many features can be improved, including new device models, new noise models and integration with the existing general framework for quantum circuits (`qutip.qip.circuit`). There are also possible applications such as error mitigation techniques [1-3]. The tutorial notebooks can be found at http://qutip.org/tutorials.html#nisq. A recent presentation on the FOSDEM conference may help you get an overview (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github Project page for a collection of related issues and ongoing Pull Requests. ### Expected outcomes; - More devices defined in the `qutip.qip.device` module. At the moment, we have two models: spin chain and cavity QED. We would like to include some other commonly used planform such as Superconducting system, Ion trap system or silicon system. Each model will need a new set of control hamiltonian and a compiler that find the control pulse of a quantum gate. This part is gonna involve some physics and study of commonly used hardware platforms. The related code can be found in `qutip.qip.device` and `qutip.qip.compiler`; - Refactoring the circuit compiler to allow simple pulse scheduling, e.g. Restriction one pulses that can be turned on at the same time.; - Features to perform error mitigation techniques in QuTiP, such as zero-error extrapolation.; - APIs to allow import quantum circuits from other software packages or commonly used language e.g. through quantum assembly language (qasm); ----------------------------------------------------------------. Also, the last outcomes have some overlap with the last project. Although I also find this circuit importation very important, I guess two projects should not have overlap if they are both selected.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1184
https://github.com/qutip/qutip/issues/1185:46,Availability,error,error,46,"In QuTiP 4.5.0 conda release on Mac, I get an error if I call a quantum circuit to print in jupyter notebook. However, the circuit is printed after the message. . This did not happen with QuTiP 4.4.1. Imagemagick is installed. This issue may be related to the closed issues #1179 and #702. ```; ---------------------------------------------------------------------------; FileNotFoundError Traceback (most recent call last); /miniconda3/lib/python3.7/site-packages/IPython/core/formatters.py in __call__(self, obj); 343 method = get_real_method(obj, self.print_method); 344 if method is not None:; --> 345 return method(); 346 return None; 347 else:. /miniconda3/lib/python3.7/site-packages/qutip/qip/circuit.py in _repr_svg_(self); 1117 ; 1118 def _repr_svg_(self):; -> 1119 return _latex_compile(self.latex_code(), format=""svg""); 1120 ; 1121 @property. /miniconda3/lib/python3.7/site-packages/qutip/qip/circuit_latex.py in _latex_compile(code, filename, format); 64 else:; 65 os.system(""pdf2svg %s.pdf %s.svg"" % (filename, filename)); ---> 66 with open(""%s.svg"" % filename) as f:; 67 result = f.read(); 68 . FileNotFoundError: [Errno 2] No such file or directory: 'qcirc.svg'; ```; <img width=""1137"" alt=""Screenshot 2020-02-26 17 44 05"" src=""https://user-images.githubusercontent.com/14573436/75327357-9af58180-58bf-11ea-9989-6892f5b7af41.png"">",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1185
https://github.com/qutip/qutip/issues/1185:21,Deployability,release,release,21,"In QuTiP 4.5.0 conda release on Mac, I get an error if I call a quantum circuit to print in jupyter notebook. However, the circuit is printed after the message. . This did not happen with QuTiP 4.4.1. Imagemagick is installed. This issue may be related to the closed issues #1179 and #702. ```; ---------------------------------------------------------------------------; FileNotFoundError Traceback (most recent call last); /miniconda3/lib/python3.7/site-packages/IPython/core/formatters.py in __call__(self, obj); 343 method = get_real_method(obj, self.print_method); 344 if method is not None:; --> 345 return method(); 346 return None; 347 else:. /miniconda3/lib/python3.7/site-packages/qutip/qip/circuit.py in _repr_svg_(self); 1117 ; 1118 def _repr_svg_(self):; -> 1119 return _latex_compile(self.latex_code(), format=""svg""); 1120 ; 1121 @property. /miniconda3/lib/python3.7/site-packages/qutip/qip/circuit_latex.py in _latex_compile(code, filename, format); 64 else:; 65 os.system(""pdf2svg %s.pdf %s.svg"" % (filename, filename)); ---> 66 with open(""%s.svg"" % filename) as f:; 67 result = f.read(); 68 . FileNotFoundError: [Errno 2] No such file or directory: 'qcirc.svg'; ```; <img width=""1137"" alt=""Screenshot 2020-02-26 17 44 05"" src=""https://user-images.githubusercontent.com/14573436/75327357-9af58180-58bf-11ea-9989-6892f5b7af41.png"">",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1185
https://github.com/qutip/qutip/issues/1185:216,Deployability,install,installed,216,"In QuTiP 4.5.0 conda release on Mac, I get an error if I call a quantum circuit to print in jupyter notebook. However, the circuit is printed after the message. . This did not happen with QuTiP 4.4.1. Imagemagick is installed. This issue may be related to the closed issues #1179 and #702. ```; ---------------------------------------------------------------------------; FileNotFoundError Traceback (most recent call last); /miniconda3/lib/python3.7/site-packages/IPython/core/formatters.py in __call__(self, obj); 343 method = get_real_method(obj, self.print_method); 344 if method is not None:; --> 345 return method(); 346 return None; 347 else:. /miniconda3/lib/python3.7/site-packages/qutip/qip/circuit.py in _repr_svg_(self); 1117 ; 1118 def _repr_svg_(self):; -> 1119 return _latex_compile(self.latex_code(), format=""svg""); 1120 ; 1121 @property. /miniconda3/lib/python3.7/site-packages/qutip/qip/circuit_latex.py in _latex_compile(code, filename, format); 64 else:; 65 os.system(""pdf2svg %s.pdf %s.svg"" % (filename, filename)); ---> 66 with open(""%s.svg"" % filename) as f:; 67 result = f.read(); 68 . FileNotFoundError: [Errno 2] No such file or directory: 'qcirc.svg'; ```; <img width=""1137"" alt=""Screenshot 2020-02-26 17 44 05"" src=""https://user-images.githubusercontent.com/14573436/75327357-9af58180-58bf-11ea-9989-6892f5b7af41.png"">",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1185
https://github.com/qutip/qutip/issues/1185:152,Integrability,message,message,152,"In QuTiP 4.5.0 conda release on Mac, I get an error if I call a quantum circuit to print in jupyter notebook. However, the circuit is printed after the message. . This did not happen with QuTiP 4.4.1. Imagemagick is installed. This issue may be related to the closed issues #1179 and #702. ```; ---------------------------------------------------------------------------; FileNotFoundError Traceback (most recent call last); /miniconda3/lib/python3.7/site-packages/IPython/core/formatters.py in __call__(self, obj); 343 method = get_real_method(obj, self.print_method); 344 if method is not None:; --> 345 return method(); 346 return None; 347 else:. /miniconda3/lib/python3.7/site-packages/qutip/qip/circuit.py in _repr_svg_(self); 1117 ; 1118 def _repr_svg_(self):; -> 1119 return _latex_compile(self.latex_code(), format=""svg""); 1120 ; 1121 @property. /miniconda3/lib/python3.7/site-packages/qutip/qip/circuit_latex.py in _latex_compile(code, filename, format); 64 else:; 65 os.system(""pdf2svg %s.pdf %s.svg"" % (filename, filename)); ---> 66 with open(""%s.svg"" % filename) as f:; 67 result = f.read(); 68 . FileNotFoundError: [Errno 2] No such file or directory: 'qcirc.svg'; ```; <img width=""1137"" alt=""Screenshot 2020-02-26 17 44 05"" src=""https://user-images.githubusercontent.com/14573436/75327357-9af58180-58bf-11ea-9989-6892f5b7af41.png"">",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1185
https://github.com/qutip/qutip/pull/1186:434,Availability,avail,available,434,"Solver object for `sesolve`, `mesolve` and `mcsolve`: `SeSolver`, `MeSolver` and `McSolver`:; - Removed all `rhs_reuse` (except in `brmesolve`). Still work but there is deprecation warning.; - steper for `Sesolver` and `MeSolver` as proposed by Michael.; - Variable output type (`Qobj`, `dense` or `sparse`) input must still be `Qobj`.; - Intermediate object to change the solver used: scipy `zvode`, `solve_ivp`, `dorpri853` are all available for `SeSolver`, `MeSolver`. More could be added in the future, @tehruhn 's GPU solver could probably fit here. I will work on an Adaptative Hilbert Space one eventually. . The objects do not do much more than the original functions if the system is not used more than once. Still to-do:; - Other algorithm for `McSolver`: diagonalized solver (suggested by Fabio?) and one using scipy ivp.; - Inline documentation; - Notebooks; - Cleaning options management. (Unique options object is getting limited for multiple low level solver and both all se,me,mc solve, I would appreciate opinions on how to make this better).; - Add to `__init__.py`; - Add tests. Build on the QobjEvoFunc Pr, with some bug fixed.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1186
https://github.com/qutip/qutip/pull/1186:573,Energy Efficiency,Adapt,Adaptative,573,"Solver object for `sesolve`, `mesolve` and `mcsolve`: `SeSolver`, `MeSolver` and `McSolver`:; - Removed all `rhs_reuse` (except in `brmesolve`). Still work but there is deprecation warning.; - steper for `Sesolver` and `MeSolver` as proposed by Michael.; - Variable output type (`Qobj`, `dense` or `sparse`) input must still be `Qobj`.; - Intermediate object to change the solver used: scipy `zvode`, `solve_ivp`, `dorpri853` are all available for `SeSolver`, `MeSolver`. More could be added in the future, @tehruhn 's GPU solver could probably fit here. I will work on an Adaptative Hilbert Space one eventually. . The objects do not do much more than the original functions if the system is not used more than once. Still to-do:; - Other algorithm for `McSolver`: diagonalized solver (suggested by Fabio?) and one using scipy ivp.; - Inline documentation; - Notebooks; - Cleaning options management. (Unique options object is getting limited for multiple low level solver and both all se,me,mc solve, I would appreciate opinions on how to make this better).; - Add to `__init__.py`; - Add tests. Build on the QobjEvoFunc Pr, with some bug fixed.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1186
https://github.com/qutip/qutip/pull/1186:257,Modifiability,Variab,Variable,257,"Solver object for `sesolve`, `mesolve` and `mcsolve`: `SeSolver`, `MeSolver` and `McSolver`:; - Removed all `rhs_reuse` (except in `brmesolve`). Still work but there is deprecation warning.; - steper for `Sesolver` and `MeSolver` as proposed by Michael.; - Variable output type (`Qobj`, `dense` or `sparse`) input must still be `Qobj`.; - Intermediate object to change the solver used: scipy `zvode`, `solve_ivp`, `dorpri853` are all available for `SeSolver`, `MeSolver`. More could be added in the future, @tehruhn 's GPU solver could probably fit here. I will work on an Adaptative Hilbert Space one eventually. . The objects do not do much more than the original functions if the system is not used more than once. Still to-do:; - Other algorithm for `McSolver`: diagonalized solver (suggested by Fabio?) and one using scipy ivp.; - Inline documentation; - Notebooks; - Cleaning options management. (Unique options object is getting limited for multiple low level solver and both all se,me,mc solve, I would appreciate opinions on how to make this better).; - Add to `__init__.py`; - Add tests. Build on the QobjEvoFunc Pr, with some bug fixed.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1186
https://github.com/qutip/qutip/pull/1186:573,Modifiability,Adapt,Adaptative,573,"Solver object for `sesolve`, `mesolve` and `mcsolve`: `SeSolver`, `MeSolver` and `McSolver`:; - Removed all `rhs_reuse` (except in `brmesolve`). Still work but there is deprecation warning.; - steper for `Sesolver` and `MeSolver` as proposed by Michael.; - Variable output type (`Qobj`, `dense` or `sparse`) input must still be `Qobj`.; - Intermediate object to change the solver used: scipy `zvode`, `solve_ivp`, `dorpri853` are all available for `SeSolver`, `MeSolver`. More could be added in the future, @tehruhn 's GPU solver could probably fit here. I will work on an Adaptative Hilbert Space one eventually. . The objects do not do much more than the original functions if the system is not used more than once. Still to-do:; - Other algorithm for `McSolver`: diagonalized solver (suggested by Fabio?) and one using scipy ivp.; - Inline documentation; - Notebooks; - Cleaning options management. (Unique options object is getting limited for multiple low level solver and both all se,me,mc solve, I would appreciate opinions on how to make this better).; - Add to `__init__.py`; - Add tests. Build on the QobjEvoFunc Pr, with some bug fixed.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1186
https://github.com/qutip/qutip/pull/1186:1091,Testability,test,tests,1091,"Solver object for `sesolve`, `mesolve` and `mcsolve`: `SeSolver`, `MeSolver` and `McSolver`:; - Removed all `rhs_reuse` (except in `brmesolve`). Still work but there is deprecation warning.; - steper for `Sesolver` and `MeSolver` as proposed by Michael.; - Variable output type (`Qobj`, `dense` or `sparse`) input must still be `Qobj`.; - Intermediate object to change the solver used: scipy `zvode`, `solve_ivp`, `dorpri853` are all available for `SeSolver`, `MeSolver`. More could be added in the future, @tehruhn 's GPU solver could probably fit here. I will work on an Adaptative Hilbert Space one eventually. . The objects do not do much more than the original functions if the system is not used more than once. Still to-do:; - Other algorithm for `McSolver`: diagonalized solver (suggested by Fabio?) and one using scipy ivp.; - Inline documentation; - Notebooks; - Cleaning options management. (Unique options object is getting limited for multiple low level solver and both all se,me,mc solve, I would appreciate opinions on how to make this better).; - Add to `__init__.py`; - Add tests. Build on the QobjEvoFunc Pr, with some bug fixed.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1186
https://github.com/qutip/qutip/pull/1187:8,Deployability,update,updates,8,This PR updates the version of QCircuit used for plotting circuits.; LaTeX code was taken from the [QCircuit repository](https://github.com/CQuIC/qcircuit) and small modifications were done to change from .sty file to .tex file.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1187
https://github.com/qutip/qutip/issues/1189:115,Availability,error,error,115,"I need mcsolve result in row and column matrix as mentioned below. How can i got this because this code is showing error.; ```python; fieldfield_list = []; atomfield_list = []; tlist = np.linspace(0,20,2000); gM_list = np.linspace(0,3,200); for g_M in gM_list:; H = omega_M*b.dag()*b + Y*(a + a.dag())+ g*((a*sig_plus) + (a.dag()*sig_plus.dag())); + g_M*a.dag()*a*(b + b.dag()); evalues = mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=None, args={}, options=None, progress_bar=True, map_func=None, map_kwargs=None, _safe_mode=True); fieldfield_list.append(evalues[0][-1]/(evalues[2][-1]**2)); atomfield_list.append(evalues[1][-1]/(evalues[2][-1]*evalues[3][-1])); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1189
https://github.com/qutip/qutip/issues/1190:1019,Deployability,Release,Release,1019,"String-based QobjEvo generates several warning messages when it is compiled. The terminal is overwhelmed by those messages when using string-based solvers. Is it possible to suppress/correct them?. Example:; ```python; import numpy as np; from qutip import *; tlist = np.array([0., 1., 2., 3.]); H = [[sigmaz(), 'exp(-t)']]; qu = QobjEvo(H, tlist=tlist); qu.compile(); ```. Terminal output:; ```; cl : Command line warning D9025 : overriding '/W3' with '/w'; cl : Command line warning D9025 : overriding '/Ox' with '/O1'; cqobjevo_compiled_coeff_4851660043300.cpp; c:\users\boxi\miniconda3\envs\qutip-dev-py3\lib\site-packages\numpy\core\include\numpy\npy_1_7_deprecated_api.h(14) : Warning Msg: Using deprecated NumPy API, disable it with #define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION; cqobjevo_compiled_coeff_4851660043300.obj : warning ; LNK4197: export 'PyInit_cqobjevo_compiled_coeff_4851660043300' specified multiple times; using first specification; Creating library C:\Users\Boxi\.pyxbld\temp.win-amd64-3.6\Release\Users\Boxi\.pyxbld\temp.win-amd64-3.6\Release\pyrex\cqobjevo_compiled_coeff_4851660043300.cp36-win_amd64.lib and object C:\Users\Boxi\.pyxbld\temp.win-amd64-3.6\Release\Users\Boxi\.pyxbld\temp.win-amd64-3.6\Release\pyrex\cqobjevo_compiled_coeff_4851660043300.cp36-win_amd64.exp; Generating code; Finished generating code; ```. Environment:; ```; QuTiP Version: 4.5.0.dev0+0f412cd4; Numpy Version: 1.17.5; Scipy Version: 1.2.1; Cython Version: 0.29.14; Matplotlib Version: 2.2.4; Python Version: 3.6.7; Number of CPUs: 12; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1190
https://github.com/qutip/qutip/issues/1190:1065,Deployability,Release,Release,1065,"String-based QobjEvo generates several warning messages when it is compiled. The terminal is overwhelmed by those messages when using string-based solvers. Is it possible to suppress/correct them?. Example:; ```python; import numpy as np; from qutip import *; tlist = np.array([0., 1., 2., 3.]); H = [[sigmaz(), 'exp(-t)']]; qu = QobjEvo(H, tlist=tlist); qu.compile(); ```. Terminal output:; ```; cl : Command line warning D9025 : overriding '/W3' with '/w'; cl : Command line warning D9025 : overriding '/Ox' with '/O1'; cqobjevo_compiled_coeff_4851660043300.cpp; c:\users\boxi\miniconda3\envs\qutip-dev-py3\lib\site-packages\numpy\core\include\numpy\npy_1_7_deprecated_api.h(14) : Warning Msg: Using deprecated NumPy API, disable it with #define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION; cqobjevo_compiled_coeff_4851660043300.obj : warning ; LNK4197: export 'PyInit_cqobjevo_compiled_coeff_4851660043300' specified multiple times; using first specification; Creating library C:\Users\Boxi\.pyxbld\temp.win-amd64-3.6\Release\Users\Boxi\.pyxbld\temp.win-amd64-3.6\Release\pyrex\cqobjevo_compiled_coeff_4851660043300.cp36-win_amd64.lib and object C:\Users\Boxi\.pyxbld\temp.win-amd64-3.6\Release\Users\Boxi\.pyxbld\temp.win-amd64-3.6\Release\pyrex\cqobjevo_compiled_coeff_4851660043300.cp36-win_amd64.exp; Generating code; Finished generating code; ```. Environment:; ```; QuTiP Version: 4.5.0.dev0+0f412cd4; Numpy Version: 1.17.5; Scipy Version: 1.2.1; Cython Version: 0.29.14; Matplotlib Version: 2.2.4; Python Version: 3.6.7; Number of CPUs: 12; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1190
https://github.com/qutip/qutip/issues/1190:1188,Deployability,Release,Release,1188,"String-based QobjEvo generates several warning messages when it is compiled. The terminal is overwhelmed by those messages when using string-based solvers. Is it possible to suppress/correct them?. Example:; ```python; import numpy as np; from qutip import *; tlist = np.array([0., 1., 2., 3.]); H = [[sigmaz(), 'exp(-t)']]; qu = QobjEvo(H, tlist=tlist); qu.compile(); ```. Terminal output:; ```; cl : Command line warning D9025 : overriding '/W3' with '/w'; cl : Command line warning D9025 : overriding '/Ox' with '/O1'; cqobjevo_compiled_coeff_4851660043300.cpp; c:\users\boxi\miniconda3\envs\qutip-dev-py3\lib\site-packages\numpy\core\include\numpy\npy_1_7_deprecated_api.h(14) : Warning Msg: Using deprecated NumPy API, disable it with #define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION; cqobjevo_compiled_coeff_4851660043300.obj : warning ; LNK4197: export 'PyInit_cqobjevo_compiled_coeff_4851660043300' specified multiple times; using first specification; Creating library C:\Users\Boxi\.pyxbld\temp.win-amd64-3.6\Release\Users\Boxi\.pyxbld\temp.win-amd64-3.6\Release\pyrex\cqobjevo_compiled_coeff_4851660043300.cp36-win_amd64.lib and object C:\Users\Boxi\.pyxbld\temp.win-amd64-3.6\Release\Users\Boxi\.pyxbld\temp.win-amd64-3.6\Release\pyrex\cqobjevo_compiled_coeff_4851660043300.cp36-win_amd64.exp; Generating code; Finished generating code; ```. Environment:; ```; QuTiP Version: 4.5.0.dev0+0f412cd4; Numpy Version: 1.17.5; Scipy Version: 1.2.1; Cython Version: 0.29.14; Matplotlib Version: 2.2.4; Python Version: 3.6.7; Number of CPUs: 12; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1190
https://github.com/qutip/qutip/issues/1190:1234,Deployability,Release,Release,1234,"String-based QobjEvo generates several warning messages when it is compiled. The terminal is overwhelmed by those messages when using string-based solvers. Is it possible to suppress/correct them?. Example:; ```python; import numpy as np; from qutip import *; tlist = np.array([0., 1., 2., 3.]); H = [[sigmaz(), 'exp(-t)']]; qu = QobjEvo(H, tlist=tlist); qu.compile(); ```. Terminal output:; ```; cl : Command line warning D9025 : overriding '/W3' with '/w'; cl : Command line warning D9025 : overriding '/Ox' with '/O1'; cqobjevo_compiled_coeff_4851660043300.cpp; c:\users\boxi\miniconda3\envs\qutip-dev-py3\lib\site-packages\numpy\core\include\numpy\npy_1_7_deprecated_api.h(14) : Warning Msg: Using deprecated NumPy API, disable it with #define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION; cqobjevo_compiled_coeff_4851660043300.obj : warning ; LNK4197: export 'PyInit_cqobjevo_compiled_coeff_4851660043300' specified multiple times; using first specification; Creating library C:\Users\Boxi\.pyxbld\temp.win-amd64-3.6\Release\Users\Boxi\.pyxbld\temp.win-amd64-3.6\Release\pyrex\cqobjevo_compiled_coeff_4851660043300.cp36-win_amd64.lib and object C:\Users\Boxi\.pyxbld\temp.win-amd64-3.6\Release\Users\Boxi\.pyxbld\temp.win-amd64-3.6\Release\pyrex\cqobjevo_compiled_coeff_4851660043300.cp36-win_amd64.exp; Generating code; Finished generating code; ```. Environment:; ```; QuTiP Version: 4.5.0.dev0+0f412cd4; Numpy Version: 1.17.5; Scipy Version: 1.2.1; Cython Version: 0.29.14; Matplotlib Version: 2.2.4; Python Version: 3.6.7; Number of CPUs: 12; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1190
https://github.com/qutip/qutip/issues/1190:1576,Deployability,Install,Installed,1576,"String-based QobjEvo generates several warning messages when it is compiled. The terminal is overwhelmed by those messages when using string-based solvers. Is it possible to suppress/correct them?. Example:; ```python; import numpy as np; from qutip import *; tlist = np.array([0., 1., 2., 3.]); H = [[sigmaz(), 'exp(-t)']]; qu = QobjEvo(H, tlist=tlist); qu.compile(); ```. Terminal output:; ```; cl : Command line warning D9025 : overriding '/W3' with '/w'; cl : Command line warning D9025 : overriding '/Ox' with '/O1'; cqobjevo_compiled_coeff_4851660043300.cpp; c:\users\boxi\miniconda3\envs\qutip-dev-py3\lib\site-packages\numpy\core\include\numpy\npy_1_7_deprecated_api.h(14) : Warning Msg: Using deprecated NumPy API, disable it with #define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION; cqobjevo_compiled_coeff_4851660043300.obj : warning ; LNK4197: export 'PyInit_cqobjevo_compiled_coeff_4851660043300' specified multiple times; using first specification; Creating library C:\Users\Boxi\.pyxbld\temp.win-amd64-3.6\Release\Users\Boxi\.pyxbld\temp.win-amd64-3.6\Release\pyrex\cqobjevo_compiled_coeff_4851660043300.cp36-win_amd64.lib and object C:\Users\Boxi\.pyxbld\temp.win-amd64-3.6\Release\Users\Boxi\.pyxbld\temp.win-amd64-3.6\Release\pyrex\cqobjevo_compiled_coeff_4851660043300.cp36-win_amd64.exp; Generating code; Finished generating code; ```. Environment:; ```; QuTiP Version: 4.5.0.dev0+0f412cd4; Numpy Version: 1.17.5; Scipy Version: 1.2.1; Cython Version: 0.29.14; Matplotlib Version: 2.2.4; Python Version: 3.6.7; Number of CPUs: 12; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1190
https://github.com/qutip/qutip/issues/1190:47,Integrability,message,messages,47,"String-based QobjEvo generates several warning messages when it is compiled. The terminal is overwhelmed by those messages when using string-based solvers. Is it possible to suppress/correct them?. Example:; ```python; import numpy as np; from qutip import *; tlist = np.array([0., 1., 2., 3.]); H = [[sigmaz(), 'exp(-t)']]; qu = QobjEvo(H, tlist=tlist); qu.compile(); ```. Terminal output:; ```; cl : Command line warning D9025 : overriding '/W3' with '/w'; cl : Command line warning D9025 : overriding '/Ox' with '/O1'; cqobjevo_compiled_coeff_4851660043300.cpp; c:\users\boxi\miniconda3\envs\qutip-dev-py3\lib\site-packages\numpy\core\include\numpy\npy_1_7_deprecated_api.h(14) : Warning Msg: Using deprecated NumPy API, disable it with #define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION; cqobjevo_compiled_coeff_4851660043300.obj : warning ; LNK4197: export 'PyInit_cqobjevo_compiled_coeff_4851660043300' specified multiple times; using first specification; Creating library C:\Users\Boxi\.pyxbld\temp.win-amd64-3.6\Release\Users\Boxi\.pyxbld\temp.win-amd64-3.6\Release\pyrex\cqobjevo_compiled_coeff_4851660043300.cp36-win_amd64.lib and object C:\Users\Boxi\.pyxbld\temp.win-amd64-3.6\Release\Users\Boxi\.pyxbld\temp.win-amd64-3.6\Release\pyrex\cqobjevo_compiled_coeff_4851660043300.cp36-win_amd64.exp; Generating code; Finished generating code; ```. Environment:; ```; QuTiP Version: 4.5.0.dev0+0f412cd4; Numpy Version: 1.17.5; Scipy Version: 1.2.1; Cython Version: 0.29.14; Matplotlib Version: 2.2.4; Python Version: 3.6.7; Number of CPUs: 12; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1190
https://github.com/qutip/qutip/issues/1190:114,Integrability,message,messages,114,"String-based QobjEvo generates several warning messages when it is compiled. The terminal is overwhelmed by those messages when using string-based solvers. Is it possible to suppress/correct them?. Example:; ```python; import numpy as np; from qutip import *; tlist = np.array([0., 1., 2., 3.]); H = [[sigmaz(), 'exp(-t)']]; qu = QobjEvo(H, tlist=tlist); qu.compile(); ```. Terminal output:; ```; cl : Command line warning D9025 : overriding '/W3' with '/w'; cl : Command line warning D9025 : overriding '/Ox' with '/O1'; cqobjevo_compiled_coeff_4851660043300.cpp; c:\users\boxi\miniconda3\envs\qutip-dev-py3\lib\site-packages\numpy\core\include\numpy\npy_1_7_deprecated_api.h(14) : Warning Msg: Using deprecated NumPy API, disable it with #define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION; cqobjevo_compiled_coeff_4851660043300.obj : warning ; LNK4197: export 'PyInit_cqobjevo_compiled_coeff_4851660043300' specified multiple times; using first specification; Creating library C:\Users\Boxi\.pyxbld\temp.win-amd64-3.6\Release\Users\Boxi\.pyxbld\temp.win-amd64-3.6\Release\pyrex\cqobjevo_compiled_coeff_4851660043300.cp36-win_amd64.lib and object C:\Users\Boxi\.pyxbld\temp.win-amd64-3.6\Release\Users\Boxi\.pyxbld\temp.win-amd64-3.6\Release\pyrex\cqobjevo_compiled_coeff_4851660043300.cp36-win_amd64.exp; Generating code; Finished generating code; ```. Environment:; ```; QuTiP Version: 4.5.0.dev0+0f412cd4; Numpy Version: 1.17.5; Scipy Version: 1.2.1; Cython Version: 0.29.14; Matplotlib Version: 2.2.4; Python Version: 3.6.7; Number of CPUs: 12; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1190
https://github.com/qutip/qutip/pull/1191:32,Testability,test,tests,32,Adding a commit that should fix tests in 4.5.1.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1191
https://github.com/qutip/qutip/pull/1193:90,Deployability,release,release,90,@nathanshammah please can you merge this and redo the sdist after before making the 4.5.1 release.; Thanks. Alex,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1193
https://github.com/qutip/qutip/pull/1194:965,Availability,error,error,965,"Notionally fixes #1179, #1185. Converts the `os.system` calls to `subprocess.run` because they're now the recommended way of doing things. I check for existence of the dependencies at import time, and emit a warning (`ImportWarning`) if they don't exist. This is ignored by the typical warning filters, so it won't actually show up for most users. If a dependency doesn't exist, then we don't define the relevant methods on the `QubitCircuit` class to avoid IPython introspecting the class object and thinking that it can make a PNG/SVG. This may not be the best way of doing things, but in this delocalised setting I think it's easier to talk/discuss around a problem with an example in front of us. In particular, I think raising `NotImplementedError` on failing to find `pdflatex` might not be the right call: if it doesn't exist, then the PNG and SVG methods of `QubitCircuit` are currently still created, and then IPython would try to call them and produce an error that isn't the fault of the user. Also, maybe there's a nicer way to make sure that the user sees the ""not found"" warnings the first time that they do something which involves a conversion? At the moment, the class just doesn't get the methods defined.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1194
https://github.com/qutip/qutip/pull/1194:986,Availability,fault,fault,986,"Notionally fixes #1179, #1185. Converts the `os.system` calls to `subprocess.run` because they're now the recommended way of doing things. I check for existence of the dependencies at import time, and emit a warning (`ImportWarning`) if they don't exist. This is ignored by the typical warning filters, so it won't actually show up for most users. If a dependency doesn't exist, then we don't define the relevant methods on the `QubitCircuit` class to avoid IPython introspecting the class object and thinking that it can make a PNG/SVG. This may not be the best way of doing things, but in this delocalised setting I think it's easier to talk/discuss around a problem with an example in front of us. In particular, I think raising `NotImplementedError` on failing to find `pdflatex` might not be the right call: if it doesn't exist, then the PNG and SVG methods of `QubitCircuit` are currently still created, and then IPython would try to call them and produce an error that isn't the fault of the user. Also, maybe there's a nicer way to make sure that the user sees the ""not found"" warnings the first time that they do something which involves a conversion? At the moment, the class just doesn't get the methods defined.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1194
https://github.com/qutip/qutip/pull/1194:168,Integrability,depend,dependencies,168,"Notionally fixes #1179, #1185. Converts the `os.system` calls to `subprocess.run` because they're now the recommended way of doing things. I check for existence of the dependencies at import time, and emit a warning (`ImportWarning`) if they don't exist. This is ignored by the typical warning filters, so it won't actually show up for most users. If a dependency doesn't exist, then we don't define the relevant methods on the `QubitCircuit` class to avoid IPython introspecting the class object and thinking that it can make a PNG/SVG. This may not be the best way of doing things, but in this delocalised setting I think it's easier to talk/discuss around a problem with an example in front of us. In particular, I think raising `NotImplementedError` on failing to find `pdflatex` might not be the right call: if it doesn't exist, then the PNG and SVG methods of `QubitCircuit` are currently still created, and then IPython would try to call them and produce an error that isn't the fault of the user. Also, maybe there's a nicer way to make sure that the user sees the ""not found"" warnings the first time that they do something which involves a conversion? At the moment, the class just doesn't get the methods defined.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1194
https://github.com/qutip/qutip/pull/1194:353,Integrability,depend,dependency,353,"Notionally fixes #1179, #1185. Converts the `os.system` calls to `subprocess.run` because they're now the recommended way of doing things. I check for existence of the dependencies at import time, and emit a warning (`ImportWarning`) if they don't exist. This is ignored by the typical warning filters, so it won't actually show up for most users. If a dependency doesn't exist, then we don't define the relevant methods on the `QubitCircuit` class to avoid IPython introspecting the class object and thinking that it can make a PNG/SVG. This may not be the best way of doing things, but in this delocalised setting I think it's easier to talk/discuss around a problem with an example in front of us. In particular, I think raising `NotImplementedError` on failing to find `pdflatex` might not be the right call: if it doesn't exist, then the PNG and SVG methods of `QubitCircuit` are currently still created, and then IPython would try to call them and produce an error that isn't the fault of the user. Also, maybe there's a nicer way to make sure that the user sees the ""not found"" warnings the first time that they do something which involves a conversion? At the moment, the class just doesn't get the methods defined.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1194
https://github.com/qutip/qutip/pull/1194:452,Safety,avoid,avoid,452,"Notionally fixes #1179, #1185. Converts the `os.system` calls to `subprocess.run` because they're now the recommended way of doing things. I check for existence of the dependencies at import time, and emit a warning (`ImportWarning`) if they don't exist. This is ignored by the typical warning filters, so it won't actually show up for most users. If a dependency doesn't exist, then we don't define the relevant methods on the `QubitCircuit` class to avoid IPython introspecting the class object and thinking that it can make a PNG/SVG. This may not be the best way of doing things, but in this delocalised setting I think it's easier to talk/discuss around a problem with an example in front of us. In particular, I think raising `NotImplementedError` on failing to find `pdflatex` might not be the right call: if it doesn't exist, then the PNG and SVG methods of `QubitCircuit` are currently still created, and then IPython would try to call them and produce an error that isn't the fault of the user. Also, maybe there's a nicer way to make sure that the user sees the ""not found"" warnings the first time that they do something which involves a conversion? At the moment, the class just doesn't get the methods defined.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1194
https://github.com/qutip/qutip/issues/1196:20,Availability,error,error,20,"I get the following error message. My code runs fine on the first try, but gives the error if I try to run it again. I can restart the kernel every time, but would like to know if there's a fix. Could someone help please?. ---------------------------------------------------------------------------; UnboundLocalError Traceback (most recent call last); <ipython-input-7-becee6304ad3> in <module>; 60 ; 61 ; ---> 62 output3 = mesolve(HDGRnew, tpss.states[i], tlist_reg, c_opsn, [Xp], args=param); 63 ; 64 Xppt = output3.expect[0]*np.exp(1j*wlo*(tlist_reg)). /opt/anaconda3/envs/qutip-env/lib/python3.8/site-packages/qutip/mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 252 ss = H; 253 elif isinstance(H, (list, Qobj, QobjEvo)):; --> 254 ss = _mesolve_QobjEvo(H, c_ops, tlist, args, options); 255 elif callable(H):; 256 ss = _mesolve_func_td(H, c_ops, rho0, tlist, args, options). /opt/anaconda3/envs/qutip-env/lib/python3.8/site-packages/qutip/mesolve.py in _mesolve_QobjEvo(H, c_ops, tlist, args, opt); 298 ; 299 nthread = opt.openmp_threads if opt.use_openmp else 0; --> 300 L_td.compile(omp=nthread); 301 ; 302 ss = SolverSystem(). /opt/anaconda3/envs/qutip-env/lib/python3.8/site-packages/qutip/qobjevo.py in compile(self, code, matched, dense, omp); 1553 if self.use_cython:; 1554 # All factor can be compiled; -> 1555 self.coeff_get, Code, file_ = _compiled_coeffs(; 1556 self.ops,; 1557 self.args,. /opt/anaconda3/envs/qutip-env/lib/python3.8/site-packages/qutip/qobjevo_codegen.py in _compiled_coeffs(ops, args, dyn_args, tlist); 121 """"""; 122 code = _make_code_4_cimport(ops, args, dyn_args, tlist); --> 123 coeff_obj, filename = _import_str(code, ""cqobjevo_compiled_coeff_"",; 124 ""CompiledStrCoeff"", True); 125 return coeff_obj(ops, args, tlist, dyn_args), code, filename. /opt/anaconda3/envs/qutip-env/lib/python3.8/site-packages/qutip/qobjevo_codegen.py in _import_str(code, basefilename, obj_name, cythonfile); 80 if not import_list:; 81 raise",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1196
https://github.com/qutip/qutip/issues/1196:85,Availability,error,error,85,"I get the following error message. My code runs fine on the first try, but gives the error if I try to run it again. I can restart the kernel every time, but would like to know if there's a fix. Could someone help please?. ---------------------------------------------------------------------------; UnboundLocalError Traceback (most recent call last); <ipython-input-7-becee6304ad3> in <module>; 60 ; 61 ; ---> 62 output3 = mesolve(HDGRnew, tpss.states[i], tlist_reg, c_opsn, [Xp], args=param); 63 ; 64 Xppt = output3.expect[0]*np.exp(1j*wlo*(tlist_reg)). /opt/anaconda3/envs/qutip-env/lib/python3.8/site-packages/qutip/mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 252 ss = H; 253 elif isinstance(H, (list, Qobj, QobjEvo)):; --> 254 ss = _mesolve_QobjEvo(H, c_ops, tlist, args, options); 255 elif callable(H):; 256 ss = _mesolve_func_td(H, c_ops, rho0, tlist, args, options). /opt/anaconda3/envs/qutip-env/lib/python3.8/site-packages/qutip/mesolve.py in _mesolve_QobjEvo(H, c_ops, tlist, args, opt); 298 ; 299 nthread = opt.openmp_threads if opt.use_openmp else 0; --> 300 L_td.compile(omp=nthread); 301 ; 302 ss = SolverSystem(). /opt/anaconda3/envs/qutip-env/lib/python3.8/site-packages/qutip/qobjevo.py in compile(self, code, matched, dense, omp); 1553 if self.use_cython:; 1554 # All factor can be compiled; -> 1555 self.coeff_get, Code, file_ = _compiled_coeffs(; 1556 self.ops,; 1557 self.args,. /opt/anaconda3/envs/qutip-env/lib/python3.8/site-packages/qutip/qobjevo_codegen.py in _compiled_coeffs(ops, args, dyn_args, tlist); 121 """"""; 122 code = _make_code_4_cimport(ops, args, dyn_args, tlist); --> 123 coeff_obj, filename = _import_str(code, ""cqobjevo_compiled_coeff_"",; 124 ""CompiledStrCoeff"", True); 125 return coeff_obj(ops, args, tlist, dyn_args), code, filename. /opt/anaconda3/envs/qutip-env/lib/python3.8/site-packages/qutip/qobjevo_codegen.py in _import_str(code, basefilename, obj_name, cythonfile); 80 if not import_list:; 81 raise",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1196
https://github.com/qutip/qutip/issues/1196:2454,Deployability,Install,Installed,2454,"ackages/qutip/mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 252 ss = H; 253 elif isinstance(H, (list, Qobj, QobjEvo)):; --> 254 ss = _mesolve_QobjEvo(H, c_ops, tlist, args, options); 255 elif callable(H):; 256 ss = _mesolve_func_td(H, c_ops, rho0, tlist, args, options). /opt/anaconda3/envs/qutip-env/lib/python3.8/site-packages/qutip/mesolve.py in _mesolve_QobjEvo(H, c_ops, tlist, args, opt); 298 ; 299 nthread = opt.openmp_threads if opt.use_openmp else 0; --> 300 L_td.compile(omp=nthread); 301 ; 302 ss = SolverSystem(). /opt/anaconda3/envs/qutip-env/lib/python3.8/site-packages/qutip/qobjevo.py in compile(self, code, matched, dense, omp); 1553 if self.use_cython:; 1554 # All factor can be compiled; -> 1555 self.coeff_get, Code, file_ = _compiled_coeffs(; 1556 self.ops,; 1557 self.args,. /opt/anaconda3/envs/qutip-env/lib/python3.8/site-packages/qutip/qobjevo_codegen.py in _compiled_coeffs(ops, args, dyn_args, tlist); 121 """"""; 122 code = _make_code_4_cimport(ops, args, dyn_args, tlist); --> 123 coeff_obj, filename = _import_str(code, ""cqobjevo_compiled_coeff_"",; 124 ""CompiledStrCoeff"", True); 125 return coeff_obj(ops, args, tlist, dyn_args), code, filename. /opt/anaconda3/envs/qutip-env/lib/python3.8/site-packages/qutip/qobjevo_codegen.py in _import_str(code, basefilename, obj_name, cythonfile); 80 if not import_list:; 81 raise Exception(""Could not convert string to importable function, ""; ---> 82 ""tmpfile:"" + try_file + ext) from e; 83 coeff_obj = import_list[0]; 84 return coeff_obj, try_file + ext. UnboundLocalError: local variable 'e' referenced before assignment. Version details.; QuTiP Version: 4.5.0; Numpy Version: 1.18.1; Scipy Version: 1.3.1; Cython Version: 0.29.15; Matplotlib Version: 3.1.3; Python Version: 3.8.1; Number of CPUs: 4; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Darwin (x86_64); Installation path: /opt/anaconda3/envs/qutip-env/lib/python3.8/site-packages/qutip",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1196
https://github.com/qutip/qutip/issues/1196:2525,Deployability,Install,Installation,2525,"ackages/qutip/mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 252 ss = H; 253 elif isinstance(H, (list, Qobj, QobjEvo)):; --> 254 ss = _mesolve_QobjEvo(H, c_ops, tlist, args, options); 255 elif callable(H):; 256 ss = _mesolve_func_td(H, c_ops, rho0, tlist, args, options). /opt/anaconda3/envs/qutip-env/lib/python3.8/site-packages/qutip/mesolve.py in _mesolve_QobjEvo(H, c_ops, tlist, args, opt); 298 ; 299 nthread = opt.openmp_threads if opt.use_openmp else 0; --> 300 L_td.compile(omp=nthread); 301 ; 302 ss = SolverSystem(). /opt/anaconda3/envs/qutip-env/lib/python3.8/site-packages/qutip/qobjevo.py in compile(self, code, matched, dense, omp); 1553 if self.use_cython:; 1554 # All factor can be compiled; -> 1555 self.coeff_get, Code, file_ = _compiled_coeffs(; 1556 self.ops,; 1557 self.args,. /opt/anaconda3/envs/qutip-env/lib/python3.8/site-packages/qutip/qobjevo_codegen.py in _compiled_coeffs(ops, args, dyn_args, tlist); 121 """"""; 122 code = _make_code_4_cimport(ops, args, dyn_args, tlist); --> 123 coeff_obj, filename = _import_str(code, ""cqobjevo_compiled_coeff_"",; 124 ""CompiledStrCoeff"", True); 125 return coeff_obj(ops, args, tlist, dyn_args), code, filename. /opt/anaconda3/envs/qutip-env/lib/python3.8/site-packages/qutip/qobjevo_codegen.py in _import_str(code, basefilename, obj_name, cythonfile); 80 if not import_list:; 81 raise Exception(""Could not convert string to importable function, ""; ---> 82 ""tmpfile:"" + try_file + ext) from e; 83 coeff_obj = import_list[0]; 84 return coeff_obj, try_file + ext. UnboundLocalError: local variable 'e' referenced before assignment. Version details.; QuTiP Version: 4.5.0; Numpy Version: 1.18.1; Scipy Version: 1.3.1; Cython Version: 0.29.15; Matplotlib Version: 3.1.3; Python Version: 3.8.1; Number of CPUs: 4; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Darwin (x86_64); Installation path: /opt/anaconda3/envs/qutip-env/lib/python3.8/site-packages/qutip",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1196
https://github.com/qutip/qutip/issues/1196:26,Integrability,message,message,26,"I get the following error message. My code runs fine on the first try, but gives the error if I try to run it again. I can restart the kernel every time, but would like to know if there's a fix. Could someone help please?. ---------------------------------------------------------------------------; UnboundLocalError Traceback (most recent call last); <ipython-input-7-becee6304ad3> in <module>; 60 ; 61 ; ---> 62 output3 = mesolve(HDGRnew, tpss.states[i], tlist_reg, c_opsn, [Xp], args=param); 63 ; 64 Xppt = output3.expect[0]*np.exp(1j*wlo*(tlist_reg)). /opt/anaconda3/envs/qutip-env/lib/python3.8/site-packages/qutip/mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 252 ss = H; 253 elif isinstance(H, (list, Qobj, QobjEvo)):; --> 254 ss = _mesolve_QobjEvo(H, c_ops, tlist, args, options); 255 elif callable(H):; 256 ss = _mesolve_func_td(H, c_ops, rho0, tlist, args, options). /opt/anaconda3/envs/qutip-env/lib/python3.8/site-packages/qutip/mesolve.py in _mesolve_QobjEvo(H, c_ops, tlist, args, opt); 298 ; 299 nthread = opt.openmp_threads if opt.use_openmp else 0; --> 300 L_td.compile(omp=nthread); 301 ; 302 ss = SolverSystem(). /opt/anaconda3/envs/qutip-env/lib/python3.8/site-packages/qutip/qobjevo.py in compile(self, code, matched, dense, omp); 1553 if self.use_cython:; 1554 # All factor can be compiled; -> 1555 self.coeff_get, Code, file_ = _compiled_coeffs(; 1556 self.ops,; 1557 self.args,. /opt/anaconda3/envs/qutip-env/lib/python3.8/site-packages/qutip/qobjevo_codegen.py in _compiled_coeffs(ops, args, dyn_args, tlist); 121 """"""; 122 code = _make_code_4_cimport(ops, args, dyn_args, tlist); --> 123 coeff_obj, filename = _import_str(code, ""cqobjevo_compiled_coeff_"",; 124 ""CompiledStrCoeff"", True); 125 return coeff_obj(ops, args, tlist, dyn_args), code, filename. /opt/anaconda3/envs/qutip-env/lib/python3.8/site-packages/qutip/qobjevo_codegen.py in _import_str(code, basefilename, obj_name, cythonfile); 80 if not import_list:; 81 raise",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1196
https://github.com/qutip/qutip/issues/1196:2203,Modifiability,variab,variable,2203,"ackages/qutip/mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 252 ss = H; 253 elif isinstance(H, (list, Qobj, QobjEvo)):; --> 254 ss = _mesolve_QobjEvo(H, c_ops, tlist, args, options); 255 elif callable(H):; 256 ss = _mesolve_func_td(H, c_ops, rho0, tlist, args, options). /opt/anaconda3/envs/qutip-env/lib/python3.8/site-packages/qutip/mesolve.py in _mesolve_QobjEvo(H, c_ops, tlist, args, opt); 298 ; 299 nthread = opt.openmp_threads if opt.use_openmp else 0; --> 300 L_td.compile(omp=nthread); 301 ; 302 ss = SolverSystem(). /opt/anaconda3/envs/qutip-env/lib/python3.8/site-packages/qutip/qobjevo.py in compile(self, code, matched, dense, omp); 1553 if self.use_cython:; 1554 # All factor can be compiled; -> 1555 self.coeff_get, Code, file_ = _compiled_coeffs(; 1556 self.ops,; 1557 self.args,. /opt/anaconda3/envs/qutip-env/lib/python3.8/site-packages/qutip/qobjevo_codegen.py in _compiled_coeffs(ops, args, dyn_args, tlist); 121 """"""; 122 code = _make_code_4_cimport(ops, args, dyn_args, tlist); --> 123 coeff_obj, filename = _import_str(code, ""cqobjevo_compiled_coeff_"",; 124 ""CompiledStrCoeff"", True); 125 return coeff_obj(ops, args, tlist, dyn_args), code, filename. /opt/anaconda3/envs/qutip-env/lib/python3.8/site-packages/qutip/qobjevo_codegen.py in _import_str(code, basefilename, obj_name, cythonfile); 80 if not import_list:; 81 raise Exception(""Could not convert string to importable function, ""; ---> 82 ""tmpfile:"" + try_file + ext) from e; 83 coeff_obj = import_list[0]; 84 return coeff_obj, try_file + ext. UnboundLocalError: local variable 'e' referenced before assignment. Version details.; QuTiP Version: 4.5.0; Numpy Version: 1.18.1; Scipy Version: 1.3.1; Cython Version: 0.29.15; Matplotlib Version: 3.1.3; Python Version: 3.8.1; Number of CPUs: 4; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Darwin (x86_64); Installation path: /opt/anaconda3/envs/qutip-env/lib/python3.8/site-packages/qutip",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1196
https://github.com/qutip/qutip/issues/1197:956,Availability,ERROR,ERROR,956,"Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmesolve: harmonic oscillator, finite temperature, states ... ok; brmesolve: Jaynes-Cummings model, zero temperature ... ok; brmesolve: Check for #572 bug. ... ok; brmesolve: input list of Qobj ... ok; td_brmesolve: passes all brmesolve tests ... ERROR; td_brmesolve: time-dependent a_ops ... ERROR; td_brmesolve: time-dependent a_ops tuple of strings ... ERROR; td_brmesolve: time-dependent a_ops tuple interp ... ERROR; td_brmesolve: time-dependent a_ops & c_ops interp ... ERROR; td_brmesolve: non-Hermitian e_ops check ... ERROR; td_brmesolve: states check ... ERROR; td_brmesolve: split ops #1 ... ERROR; td_brmesolve: split ops #2 ... ERROR; td_brmesolve: split ops, Cubic_Spline td-terms ... ERROR; td_brmesolve: split ops, multiple ... ERROR; td_brmesolve: Hamiltonian args ... ERROR; BR Tools : zheevr ...",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1197
https://github.com/qutip/qutip/issues/1197:1002,Availability,ERROR,ERROR,1002,"Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmesolve: harmonic oscillator, finite temperature, states ... ok; brmesolve: Jaynes-Cummings model, zero temperature ... ok; brmesolve: Check for #572 bug. ... ok; brmesolve: input list of Qobj ... ok; td_brmesolve: passes all brmesolve tests ... ERROR; td_brmesolve: time-dependent a_ops ... ERROR; td_brmesolve: time-dependent a_ops tuple of strings ... ERROR; td_brmesolve: time-dependent a_ops tuple interp ... ERROR; td_brmesolve: time-dependent a_ops & c_ops interp ... ERROR; td_brmesolve: non-Hermitian e_ops check ... ERROR; td_brmesolve: states check ... ERROR; td_brmesolve: split ops #1 ... ERROR; td_brmesolve: split ops #2 ... ERROR; td_brmesolve: split ops, Cubic_Spline td-terms ... ERROR; td_brmesolve: split ops, multiple ... ERROR; td_brmesolve: Hamiltonian args ... ERROR; BR Tools : zheevr ...",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1197
https://github.com/qutip/qutip/issues/1197:1065,Availability,ERROR,ERROR,1065,"Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmesolve: harmonic oscillator, finite temperature, states ... ok; brmesolve: Jaynes-Cummings model, zero temperature ... ok; brmesolve: Check for #572 bug. ... ok; brmesolve: input list of Qobj ... ok; td_brmesolve: passes all brmesolve tests ... ERROR; td_brmesolve: time-dependent a_ops ... ERROR; td_brmesolve: time-dependent a_ops tuple of strings ... ERROR; td_brmesolve: time-dependent a_ops tuple interp ... ERROR; td_brmesolve: time-dependent a_ops & c_ops interp ... ERROR; td_brmesolve: non-Hermitian e_ops check ... ERROR; td_brmesolve: states check ... ERROR; td_brmesolve: split ops #1 ... ERROR; td_brmesolve: split ops #2 ... ERROR; td_brmesolve: split ops, Cubic_Spline td-terms ... ERROR; td_brmesolve: split ops, multiple ... ERROR; td_brmesolve: Hamiltonian args ... ERROR; BR Tools : zheevr ...",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1197
https://github.com/qutip/qutip/issues/1197:1124,Availability,ERROR,ERROR,1124,"Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmesolve: harmonic oscillator, finite temperature, states ... ok; brmesolve: Jaynes-Cummings model, zero temperature ... ok; brmesolve: Check for #572 bug. ... ok; brmesolve: input list of Qobj ... ok; td_brmesolve: passes all brmesolve tests ... ERROR; td_brmesolve: time-dependent a_ops ... ERROR; td_brmesolve: time-dependent a_ops tuple of strings ... ERROR; td_brmesolve: time-dependent a_ops tuple interp ... ERROR; td_brmesolve: time-dependent a_ops & c_ops interp ... ERROR; td_brmesolve: non-Hermitian e_ops check ... ERROR; td_brmesolve: states check ... ERROR; td_brmesolve: split ops #1 ... ERROR; td_brmesolve: split ops #2 ... ERROR; td_brmesolve: split ops, Cubic_Spline td-terms ... ERROR; td_brmesolve: split ops, multiple ... ERROR; td_brmesolve: Hamiltonian args ... ERROR; BR Tools : zheevr ...",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1197
https://github.com/qutip/qutip/issues/1197:1185,Availability,ERROR,ERROR,1185,"Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmesolve: harmonic oscillator, finite temperature, states ... ok; brmesolve: Jaynes-Cummings model, zero temperature ... ok; brmesolve: Check for #572 bug. ... ok; brmesolve: input list of Qobj ... ok; td_brmesolve: passes all brmesolve tests ... ERROR; td_brmesolve: time-dependent a_ops ... ERROR; td_brmesolve: time-dependent a_ops tuple of strings ... ERROR; td_brmesolve: time-dependent a_ops tuple interp ... ERROR; td_brmesolve: time-dependent a_ops & c_ops interp ... ERROR; td_brmesolve: non-Hermitian e_ops check ... ERROR; td_brmesolve: states check ... ERROR; td_brmesolve: split ops #1 ... ERROR; td_brmesolve: split ops #2 ... ERROR; td_brmesolve: split ops, Cubic_Spline td-terms ... ERROR; td_brmesolve: split ops, multiple ... ERROR; td_brmesolve: Hamiltonian args ... ERROR; BR Tools : zheevr ...",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1197
https://github.com/qutip/qutip/issues/1197:1236,Availability,ERROR,ERROR,1236,"Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmesolve: harmonic oscillator, finite temperature, states ... ok; brmesolve: Jaynes-Cummings model, zero temperature ... ok; brmesolve: Check for #572 bug. ... ok; brmesolve: input list of Qobj ... ok; td_brmesolve: passes all brmesolve tests ... ERROR; td_brmesolve: time-dependent a_ops ... ERROR; td_brmesolve: time-dependent a_ops tuple of strings ... ERROR; td_brmesolve: time-dependent a_ops tuple interp ... ERROR; td_brmesolve: time-dependent a_ops & c_ops interp ... ERROR; td_brmesolve: non-Hermitian e_ops check ... ERROR; td_brmesolve: states check ... ERROR; td_brmesolve: split ops #1 ... ERROR; td_brmesolve: split ops #2 ... ERROR; td_brmesolve: split ops, Cubic_Spline td-terms ... ERROR; td_brmesolve: split ops, multiple ... ERROR; td_brmesolve: Hamiltonian args ... ERROR; BR Tools : zheevr ...",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1197
https://github.com/qutip/qutip/issues/1197:1274,Availability,ERROR,ERROR,1274,"Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmesolve: harmonic oscillator, finite temperature, states ... ok; brmesolve: Jaynes-Cummings model, zero temperature ... ok; brmesolve: Check for #572 bug. ... ok; brmesolve: input list of Qobj ... ok; td_brmesolve: passes all brmesolve tests ... ERROR; td_brmesolve: time-dependent a_ops ... ERROR; td_brmesolve: time-dependent a_ops tuple of strings ... ERROR; td_brmesolve: time-dependent a_ops tuple interp ... ERROR; td_brmesolve: time-dependent a_ops & c_ops interp ... ERROR; td_brmesolve: non-Hermitian e_ops check ... ERROR; td_brmesolve: states check ... ERROR; td_brmesolve: split ops #1 ... ERROR; td_brmesolve: split ops #2 ... ERROR; td_brmesolve: split ops, Cubic_Spline td-terms ... ERROR; td_brmesolve: split ops, multiple ... ERROR; td_brmesolve: Hamiltonian args ... ERROR; BR Tools : zheevr ...",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1197
https://github.com/qutip/qutip/issues/1197:1312,Availability,ERROR,ERROR,1312,"Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmesolve: harmonic oscillator, finite temperature, states ... ok; brmesolve: Jaynes-Cummings model, zero temperature ... ok; brmesolve: Check for #572 bug. ... ok; brmesolve: input list of Qobj ... ok; td_brmesolve: passes all brmesolve tests ... ERROR; td_brmesolve: time-dependent a_ops ... ERROR; td_brmesolve: time-dependent a_ops tuple of strings ... ERROR; td_brmesolve: time-dependent a_ops tuple interp ... ERROR; td_brmesolve: time-dependent a_ops & c_ops interp ... ERROR; td_brmesolve: non-Hermitian e_ops check ... ERROR; td_brmesolve: states check ... ERROR; td_brmesolve: split ops #1 ... ERROR; td_brmesolve: split ops #2 ... ERROR; td_brmesolve: split ops, Cubic_Spline td-terms ... ERROR; td_brmesolve: split ops, multiple ... ERROR; td_brmesolve: Hamiltonian args ... ERROR; BR Tools : zheevr ...",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1197
https://github.com/qutip/qutip/issues/1197:1350,Availability,ERROR,ERROR,1350,"Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmesolve: harmonic oscillator, finite temperature, states ... ok; brmesolve: Jaynes-Cummings model, zero temperature ... ok; brmesolve: Check for #572 bug. ... ok; brmesolve: input list of Qobj ... ok; td_brmesolve: passes all brmesolve tests ... ERROR; td_brmesolve: time-dependent a_ops ... ERROR; td_brmesolve: time-dependent a_ops tuple of strings ... ERROR; td_brmesolve: time-dependent a_ops tuple interp ... ERROR; td_brmesolve: time-dependent a_ops & c_ops interp ... ERROR; td_brmesolve: non-Hermitian e_ops check ... ERROR; td_brmesolve: states check ... ERROR; td_brmesolve: split ops #1 ... ERROR; td_brmesolve: split ops #2 ... ERROR; td_brmesolve: split ops, Cubic_Spline td-terms ... ERROR; td_brmesolve: split ops, multiple ... ERROR; td_brmesolve: Hamiltonian args ... ERROR; BR Tools : zheevr ...",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1197
https://github.com/qutip/qutip/issues/1197:1408,Availability,ERROR,ERROR,1408,"Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmesolve: harmonic oscillator, finite temperature, states ... ok; brmesolve: Jaynes-Cummings model, zero temperature ... ok; brmesolve: Check for #572 bug. ... ok; brmesolve: input list of Qobj ... ok; td_brmesolve: passes all brmesolve tests ... ERROR; td_brmesolve: time-dependent a_ops ... ERROR; td_brmesolve: time-dependent a_ops tuple of strings ... ERROR; td_brmesolve: time-dependent a_ops tuple interp ... ERROR; td_brmesolve: time-dependent a_ops & c_ops interp ... ERROR; td_brmesolve: non-Hermitian e_ops check ... ERROR; td_brmesolve: states check ... ERROR; td_brmesolve: split ops #1 ... ERROR; td_brmesolve: split ops #2 ... ERROR; td_brmesolve: split ops, Cubic_Spline td-terms ... ERROR; td_brmesolve: split ops, multiple ... ERROR; td_brmesolve: Hamiltonian args ... ERROR; BR Tools : zheevr ...",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1197
https://github.com/qutip/qutip/issues/1197:1453,Availability,ERROR,ERROR,1453,"Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmesolve: harmonic oscillator, finite temperature, states ... ok; brmesolve: Jaynes-Cummings model, zero temperature ... ok; brmesolve: Check for #572 bug. ... ok; brmesolve: input list of Qobj ... ok; td_brmesolve: passes all brmesolve tests ... ERROR; td_brmesolve: time-dependent a_ops ... ERROR; td_brmesolve: time-dependent a_ops tuple of strings ... ERROR; td_brmesolve: time-dependent a_ops tuple interp ... ERROR; td_brmesolve: time-dependent a_ops & c_ops interp ... ERROR; td_brmesolve: non-Hermitian e_ops check ... ERROR; td_brmesolve: states check ... ERROR; td_brmesolve: split ops #1 ... ERROR; td_brmesolve: split ops #2 ... ERROR; td_brmesolve: split ops, Cubic_Spline td-terms ... ERROR; td_brmesolve: split ops, multiple ... ERROR; td_brmesolve: Hamiltonian args ... ERROR; BR Tools : zheevr ...",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1197
https://github.com/qutip/qutip/issues/1197:1495,Availability,ERROR,ERROR,1495,"Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmesolve: harmonic oscillator, finite temperature, states ... ok; brmesolve: Jaynes-Cummings model, zero temperature ... ok; brmesolve: Check for #572 bug. ... ok; brmesolve: input list of Qobj ... ok; td_brmesolve: passes all brmesolve tests ... ERROR; td_brmesolve: time-dependent a_ops ... ERROR; td_brmesolve: time-dependent a_ops tuple of strings ... ERROR; td_brmesolve: time-dependent a_ops tuple interp ... ERROR; td_brmesolve: time-dependent a_ops & c_ops interp ... ERROR; td_brmesolve: non-Hermitian e_ops check ... ERROR; td_brmesolve: states check ... ERROR; td_brmesolve: split ops #1 ... ERROR; td_brmesolve: split ops #2 ... ERROR; td_brmesolve: split ops, Cubic_Spline td-terms ... ERROR; td_brmesolve: split ops, multiple ... ERROR; td_brmesolve: Hamiltonian args ... ERROR; BR Tools : zheevr ...",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1197
https://github.com/qutip/qutip/issues/1197:982,Integrability,depend,dependent,982,"Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmesolve: harmonic oscillator, finite temperature, states ... ok; brmesolve: Jaynes-Cummings model, zero temperature ... ok; brmesolve: Check for #572 bug. ... ok; brmesolve: input list of Qobj ... ok; td_brmesolve: passes all brmesolve tests ... ERROR; td_brmesolve: time-dependent a_ops ... ERROR; td_brmesolve: time-dependent a_ops tuple of strings ... ERROR; td_brmesolve: time-dependent a_ops tuple interp ... ERROR; td_brmesolve: time-dependent a_ops & c_ops interp ... ERROR; td_brmesolve: non-Hermitian e_ops check ... ERROR; td_brmesolve: states check ... ERROR; td_brmesolve: split ops #1 ... ERROR; td_brmesolve: split ops #2 ... ERROR; td_brmesolve: split ops, Cubic_Spline td-terms ... ERROR; td_brmesolve: split ops, multiple ... ERROR; td_brmesolve: Hamiltonian args ... ERROR; BR Tools : zheevr ...",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1197
https://github.com/qutip/qutip/issues/1197:1028,Integrability,depend,dependent,1028,"Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmesolve: harmonic oscillator, finite temperature, states ... ok; brmesolve: Jaynes-Cummings model, zero temperature ... ok; brmesolve: Check for #572 bug. ... ok; brmesolve: input list of Qobj ... ok; td_brmesolve: passes all brmesolve tests ... ERROR; td_brmesolve: time-dependent a_ops ... ERROR; td_brmesolve: time-dependent a_ops tuple of strings ... ERROR; td_brmesolve: time-dependent a_ops tuple interp ... ERROR; td_brmesolve: time-dependent a_ops & c_ops interp ... ERROR; td_brmesolve: non-Hermitian e_ops check ... ERROR; td_brmesolve: states check ... ERROR; td_brmesolve: split ops #1 ... ERROR; td_brmesolve: split ops #2 ... ERROR; td_brmesolve: split ops, Cubic_Spline td-terms ... ERROR; td_brmesolve: split ops, multiple ... ERROR; td_brmesolve: Hamiltonian args ... ERROR; BR Tools : zheevr ...",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1197
https://github.com/qutip/qutip/issues/1197:1091,Integrability,depend,dependent,1091,"Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmesolve: harmonic oscillator, finite temperature, states ... ok; brmesolve: Jaynes-Cummings model, zero temperature ... ok; brmesolve: Check for #572 bug. ... ok; brmesolve: input list of Qobj ... ok; td_brmesolve: passes all brmesolve tests ... ERROR; td_brmesolve: time-dependent a_ops ... ERROR; td_brmesolve: time-dependent a_ops tuple of strings ... ERROR; td_brmesolve: time-dependent a_ops tuple interp ... ERROR; td_brmesolve: time-dependent a_ops & c_ops interp ... ERROR; td_brmesolve: non-Hermitian e_ops check ... ERROR; td_brmesolve: states check ... ERROR; td_brmesolve: split ops #1 ... ERROR; td_brmesolve: split ops #2 ... ERROR; td_brmesolve: split ops, Cubic_Spline td-terms ... ERROR; td_brmesolve: split ops, multiple ... ERROR; td_brmesolve: Hamiltonian args ... ERROR; BR Tools : zheevr ...",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1197
https://github.com/qutip/qutip/issues/1197:1150,Integrability,depend,dependent,1150,"Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmesolve: harmonic oscillator, finite temperature, states ... ok; brmesolve: Jaynes-Cummings model, zero temperature ... ok; brmesolve: Check for #572 bug. ... ok; brmesolve: input list of Qobj ... ok; td_brmesolve: passes all brmesolve tests ... ERROR; td_brmesolve: time-dependent a_ops ... ERROR; td_brmesolve: time-dependent a_ops tuple of strings ... ERROR; td_brmesolve: time-dependent a_ops tuple interp ... ERROR; td_brmesolve: time-dependent a_ops & c_ops interp ... ERROR; td_brmesolve: non-Hermitian e_ops check ... ERROR; td_brmesolve: states check ... ERROR; td_brmesolve: split ops #1 ... ERROR; td_brmesolve: split ops #2 ... ERROR; td_brmesolve: split ops, Cubic_Spline td-terms ... ERROR; td_brmesolve: split ops, multiple ... ERROR; td_brmesolve: Hamiltonian args ... ERROR; BR Tools : zheevr ...",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1197
https://github.com/qutip/qutip/issues/1197:946,Testability,test,tests,946,"Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmesolve: harmonic oscillator, finite temperature, states ... ok; brmesolve: Jaynes-Cummings model, zero temperature ... ok; brmesolve: Check for #572 bug. ... ok; brmesolve: input list of Qobj ... ok; td_brmesolve: passes all brmesolve tests ... ERROR; td_brmesolve: time-dependent a_ops ... ERROR; td_brmesolve: time-dependent a_ops tuple of strings ... ERROR; td_brmesolve: time-dependent a_ops tuple interp ... ERROR; td_brmesolve: time-dependent a_ops & c_ops interp ... ERROR; td_brmesolve: non-Hermitian e_ops check ... ERROR; td_brmesolve: states check ... ERROR; td_brmesolve: split ops #1 ... ERROR; td_brmesolve: split ops #2 ... ERROR; td_brmesolve: split ops, Cubic_Spline td-terms ... ERROR; td_brmesolve: split ops, multiple ... ERROR; td_brmesolve: Hamiltonian args ... ERROR; BR Tools : zheevr ...",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1197
https://github.com/qutip/qutip/issues/1197:504,Usability,simpl,simple,504,"Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmesolve: harmonic oscillator, finite temperature, states ... ok; brmesolve: Jaynes-Cummings model, zero temperature ... ok; brmesolve: Check for #572 bug. ... ok; brmesolve: input list of Qobj ... ok; td_brmesolve: passes all brmesolve tests ... ERROR; td_brmesolve: time-dependent a_ops ... ERROR; td_brmesolve: time-dependent a_ops tuple of strings ... ERROR; td_brmesolve: time-dependent a_ops tuple interp ... ERROR; td_brmesolve: time-dependent a_ops & c_ops interp ... ERROR; td_brmesolve: non-Hermitian e_ops check ... ERROR; td_brmesolve: states check ... ERROR; td_brmesolve: split ops #1 ... ERROR; td_brmesolve: split ops #2 ... ERROR; td_brmesolve: split ops, Cubic_Spline td-terms ... ERROR; td_brmesolve: split ops, multiple ... ERROR; td_brmesolve: Hamiltonian args ... ERROR; BR Tools : zheevr ...",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1197
https://github.com/qutip/qutip/pull/1198:73,Testability,test,tested,73,"**Description**; I created three issue templates and one PR template and tested on my own fork. You can have a look and also test it at https://github.com/BoxiLi/qutip. Try to open a PR or issue there, you should see how the template works. As an example, I opened this PR following the template. The bug report issue will automatically get a label BUG, while the feature request issue will get a label ENH. Free feel to give suggestions. **Related issues or PRs**; This PR addresses #1172 #1108 but does not totally solve the issues. It is a replacement of #1188, and therefore closes #1188. **change log**; Added PR and issue templates",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1198
https://github.com/qutip/qutip/pull/1198:125,Testability,test,test,125,"**Description**; I created three issue templates and one PR template and tested on my own fork. You can have a look and also test it at https://github.com/BoxiLi/qutip. Try to open a PR or issue there, you should see how the template works. As an example, I opened this PR following the template. The bug report issue will automatically get a label BUG, while the feature request issue will get a label ENH. Free feel to give suggestions. **Related issues or PRs**; This PR addresses #1172 #1108 but does not totally solve the issues. It is a replacement of #1188, and therefore closes #1188. **change log**; Added PR and issue templates",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1198
https://github.com/qutip/qutip/pull/1198:602,Testability,log,log,602,"**Description**; I created three issue templates and one PR template and tested on my own fork. You can have a look and also test it at https://github.com/BoxiLi/qutip. Try to open a PR or issue there, you should see how the template works. As an example, I opened this PR following the template. The bug report issue will automatically get a label BUG, while the feature request issue will get a label ENH. Free feel to give suggestions. **Related issues or PRs**; This PR addresses #1172 #1108 but does not totally solve the issues. It is a replacement of #1188, and therefore closes #1188. **change log**; Added PR and issue templates",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1198
https://github.com/qutip/qutip/pull/1199:16,Availability,error,error,16,"1- (#1196 ) The error caused another one and the original message was lost, should work properly.; 2- (#1081 ) Added some check to catch keyboard interrupt in some cython functions: `mcsolve`, `stochastic` and `qobjevo`'s cython functions.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1199
https://github.com/qutip/qutip/pull/1199:58,Integrability,message,message,58,"1- (#1196 ) The error caused another one and the original message was lost, should work properly.; 2- (#1081 ) Added some check to catch keyboard interrupt in some cython functions: `mcsolve`, `stochastic` and `qobjevo`'s cython functions.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1199
https://github.com/qutip/qutip/issues/1202:456,Integrability,inject,injected,456,"Different platforms have some subtle differences in how multiprocessing works: On linux, processes ""fork"". My basic understanding is that sub-processes are created as copies of the parent process, thus inheriting their entire state (global variables/functions). Windows, and [macOS with Python >= 3.8](https://twitter.com/raymondh/status/1180209729609420800) uses ""spawn"". There, I believe subprocesses start from blank slate, and relevant global state is injected via IPC. Sadly, limitations of the pickle protocol can cause ""spawn""-based multiprocessing to have problems. Jupyter notebooks are affected by this: you cannot use multiprocessing-map using functions defined within the notebook. . Within qutip, this definitely affects the `parallel_map` function: It currently will cause freezes on Windows (See https://qucontrol.github.io/krotov/v1.0.0/notebooks/08_example_ensemble.html). With Python 3.8, macOS is also affected by this. See https://github.com/qutip/qutip-notebooks/issues/100. One possible workaround is to use a third-party replacement for multiprocessing. An work-in-progress implementation of this is in https://github.com/qutip/qutip/pull/1092, using [loky](https://loky.readthedocs.io). In #1197, we also identified a freeze in `mcsolve` when running tests on macOS/Python 3.8. This is suspected to be an issue with spawn-based multiprocessing, although we haven't been able to determine this with complete confidence. If the freeze is indeed caused by spawn-multiprocessing, the problem *should* also show up on Windows. Is anyone running Windows able to reproduce this?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1202
https://github.com/qutip/qutip/issues/1202:507,Integrability,protocol,protocol,507,"Different platforms have some subtle differences in how multiprocessing works: On linux, processes ""fork"". My basic understanding is that sub-processes are created as copies of the parent process, thus inheriting their entire state (global variables/functions). Windows, and [macOS with Python >= 3.8](https://twitter.com/raymondh/status/1180209729609420800) uses ""spawn"". There, I believe subprocesses start from blank slate, and relevant global state is injected via IPC. Sadly, limitations of the pickle protocol can cause ""spawn""-based multiprocessing to have problems. Jupyter notebooks are affected by this: you cannot use multiprocessing-map using functions defined within the notebook. . Within qutip, this definitely affects the `parallel_map` function: It currently will cause freezes on Windows (See https://qucontrol.github.io/krotov/v1.0.0/notebooks/08_example_ensemble.html). With Python 3.8, macOS is also affected by this. See https://github.com/qutip/qutip-notebooks/issues/100. One possible workaround is to use a third-party replacement for multiprocessing. An work-in-progress implementation of this is in https://github.com/qutip/qutip/pull/1092, using [loky](https://loky.readthedocs.io). In #1197, we also identified a freeze in `mcsolve` when running tests on macOS/Python 3.8. This is suspected to be an issue with spawn-based multiprocessing, although we haven't been able to determine this with complete confidence. If the freeze is indeed caused by spawn-multiprocessing, the problem *should* also show up on Windows. Is anyone running Windows able to reproduce this?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1202
https://github.com/qutip/qutip/issues/1202:202,Modifiability,inherit,inheriting,202,"Different platforms have some subtle differences in how multiprocessing works: On linux, processes ""fork"". My basic understanding is that sub-processes are created as copies of the parent process, thus inheriting their entire state (global variables/functions). Windows, and [macOS with Python >= 3.8](https://twitter.com/raymondh/status/1180209729609420800) uses ""spawn"". There, I believe subprocesses start from blank slate, and relevant global state is injected via IPC. Sadly, limitations of the pickle protocol can cause ""spawn""-based multiprocessing to have problems. Jupyter notebooks are affected by this: you cannot use multiprocessing-map using functions defined within the notebook. . Within qutip, this definitely affects the `parallel_map` function: It currently will cause freezes on Windows (See https://qucontrol.github.io/krotov/v1.0.0/notebooks/08_example_ensemble.html). With Python 3.8, macOS is also affected by this. See https://github.com/qutip/qutip-notebooks/issues/100. One possible workaround is to use a third-party replacement for multiprocessing. An work-in-progress implementation of this is in https://github.com/qutip/qutip/pull/1092, using [loky](https://loky.readthedocs.io). In #1197, we also identified a freeze in `mcsolve` when running tests on macOS/Python 3.8. This is suspected to be an issue with spawn-based multiprocessing, although we haven't been able to determine this with complete confidence. If the freeze is indeed caused by spawn-multiprocessing, the problem *should* also show up on Windows. Is anyone running Windows able to reproduce this?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1202
https://github.com/qutip/qutip/issues/1202:240,Modifiability,variab,variables,240,"Different platforms have some subtle differences in how multiprocessing works: On linux, processes ""fork"". My basic understanding is that sub-processes are created as copies of the parent process, thus inheriting their entire state (global variables/functions). Windows, and [macOS with Python >= 3.8](https://twitter.com/raymondh/status/1180209729609420800) uses ""spawn"". There, I believe subprocesses start from blank slate, and relevant global state is injected via IPC. Sadly, limitations of the pickle protocol can cause ""spawn""-based multiprocessing to have problems. Jupyter notebooks are affected by this: you cannot use multiprocessing-map using functions defined within the notebook. . Within qutip, this definitely affects the `parallel_map` function: It currently will cause freezes on Windows (See https://qucontrol.github.io/krotov/v1.0.0/notebooks/08_example_ensemble.html). With Python 3.8, macOS is also affected by this. See https://github.com/qutip/qutip-notebooks/issues/100. One possible workaround is to use a third-party replacement for multiprocessing. An work-in-progress implementation of this is in https://github.com/qutip/qutip/pull/1092, using [loky](https://loky.readthedocs.io). In #1197, we also identified a freeze in `mcsolve` when running tests on macOS/Python 3.8. This is suspected to be an issue with spawn-based multiprocessing, although we haven't been able to determine this with complete confidence. If the freeze is indeed caused by spawn-multiprocessing, the problem *should* also show up on Windows. Is anyone running Windows able to reproduce this?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1202
https://github.com/qutip/qutip/issues/1202:456,Security,inject,injected,456,"Different platforms have some subtle differences in how multiprocessing works: On linux, processes ""fork"". My basic understanding is that sub-processes are created as copies of the parent process, thus inheriting their entire state (global variables/functions). Windows, and [macOS with Python >= 3.8](https://twitter.com/raymondh/status/1180209729609420800) uses ""spawn"". There, I believe subprocesses start from blank slate, and relevant global state is injected via IPC. Sadly, limitations of the pickle protocol can cause ""spawn""-based multiprocessing to have problems. Jupyter notebooks are affected by this: you cannot use multiprocessing-map using functions defined within the notebook. . Within qutip, this definitely affects the `parallel_map` function: It currently will cause freezes on Windows (See https://qucontrol.github.io/krotov/v1.0.0/notebooks/08_example_ensemble.html). With Python 3.8, macOS is also affected by this. See https://github.com/qutip/qutip-notebooks/issues/100. One possible workaround is to use a third-party replacement for multiprocessing. An work-in-progress implementation of this is in https://github.com/qutip/qutip/pull/1092, using [loky](https://loky.readthedocs.io). In #1197, we also identified a freeze in `mcsolve` when running tests on macOS/Python 3.8. This is suspected to be an issue with spawn-based multiprocessing, although we haven't been able to determine this with complete confidence. If the freeze is indeed caused by spawn-multiprocessing, the problem *should* also show up on Windows. Is anyone running Windows able to reproduce this?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1202
https://github.com/qutip/qutip/issues/1202:1275,Testability,test,tests,1275,"Different platforms have some subtle differences in how multiprocessing works: On linux, processes ""fork"". My basic understanding is that sub-processes are created as copies of the parent process, thus inheriting their entire state (global variables/functions). Windows, and [macOS with Python >= 3.8](https://twitter.com/raymondh/status/1180209729609420800) uses ""spawn"". There, I believe subprocesses start from blank slate, and relevant global state is injected via IPC. Sadly, limitations of the pickle protocol can cause ""spawn""-based multiprocessing to have problems. Jupyter notebooks are affected by this: you cannot use multiprocessing-map using functions defined within the notebook. . Within qutip, this definitely affects the `parallel_map` function: It currently will cause freezes on Windows (See https://qucontrol.github.io/krotov/v1.0.0/notebooks/08_example_ensemble.html). With Python 3.8, macOS is also affected by this. See https://github.com/qutip/qutip-notebooks/issues/100. One possible workaround is to use a third-party replacement for multiprocessing. An work-in-progress implementation of this is in https://github.com/qutip/qutip/pull/1092, using [loky](https://loky.readthedocs.io). In #1197, we also identified a freeze in `mcsolve` when running tests on macOS/Python 3.8. This is suspected to be an issue with spawn-based multiprocessing, although we haven't been able to determine this with complete confidence. If the freeze is indeed caused by spawn-multiprocessing, the problem *should* also show up on Windows. Is anyone running Windows able to reproduce this?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1202
https://github.com/qutip/qutip/issues/1203:1223,Availability,error,error,1223," I suggest we consider dropping most of them, and consequently their surrounding `Cython` code to ease maintainability and reduce code bloat of the repository. First, a couple of arguments against doing so:; - the versions in `scipy` and `qutip` did subsequently diverge in some form, because they no longer universally give the same results, possibly as a result of #654.; - the `qutip` version of `reverse_cuthill_mckee` is about 10% faster than the `scipy` version; - people may be using them. I think the main argument in favour of removal is that they're now also in `scipy` as `scipy.sparse.csgraph`. For the speed argument, for 1000 by 1000 matrices we're talking 780us vs 850us per matrix difference, so it's unlikely to be a limiting factor, and I think the ability to remove a large chunk of Cython code and maintainability cost outweighs this. I began investigating this because I was looking at `qutip.graph.reverse_cuthill_mckee`, since some of its tests are incorrect. The error is here:; https://github.com/qutip/qutip/blob/01132789581821517986fad1a14ab3feec7d2de2/qutip/tests/test_graph.py#L91-L108; Line 105 is broken: it should read; ```python; assert np.all(ans_perm == perm); ```; to test if _all_ the elements match. As it stands, it currently tests that _not all are different_, or in other words, it would only fail if not a single element in the two arrays matched. On fixing this line, we then learn that the test is actually a failing test, because the expected and actual results do not match (though they do however have equal bandwidths). I also note that `qutip` and `matlab` are in disagreement for the test case there: for the matrix; ```python; np.array([[0, 0, 0, 1, 0, 1, 0, 0, 0, 0],; [0, 0, 1, 0, 1, 0, 1, 0, 0, 1],; [0, 1, 0, 1, 1, 0, 0, 0, 0, 0],; [1, 0, 1, 0, 0, 1, 0, 0, 1, 0],; [0, 1, 1, 0, 0, 0, 1, 0, 0, 0],; [1, 0, 0, 1, 0, 0, 1, 1, 0, 0],; [0, 1, 0, 0, 1, 1, 0, 1, 0, 0],; [0, 0, 0, 0, 0, 1, 1, 0, 0, 0],; [0, 0, 0, 1, 0, 0, 0, 0, 0, 0],; [0, 1, 0, 0, 0,",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1203
https://github.com/qutip/qutip/issues/1203:4107,Availability,down,down,4107,"3, 8]; matlab: [0, 8, 5, 7, 3, 6, 4, 2, 1, 9]; ```; (where I converted the `matlab` indexing into 0-based), however they both have the same ""bandwidth"" of 5, so I assume they are all equivalent. I don't really know anything about the theory here, and just went with what the `matlab` documentation said: https://uk.mathworks.com/help/matlab/ref/symrcm.html. In commit 0ce36d00 it is clear that the functions in `qutip.graph` were meant to be distinct from `Qobj`, so ideally they would be beyond our purview in this package. This actually has already lead to problems with the documentation, since the docstrings in; https://github.com/qutip/qutip/blob/01132789581821517986fad1a14ab3feec7d2de2/qutip/graph.py#L50-L53; and; https://github.com/qutip/qutip/blob/01132789581821517986fad1a14ab3feec7d2de2/qutip/graph.py#L71-L74; are out-of-date. I find that the only uses of `qutip.graph` are in `qutip.steadystate`, which uses `reverse_cuthill_mckee` and `weighted_bipartite_matching`. The former can be replaced directly with the `scipy` version, at the cost of ~10% speed. The latter is not yet in `scipy`, so we ought to perhaps keep it, since it is used and documented for `qutip.steadystate.steadystate`. All other functions in `qutip.graph` are not used, and not documented (and in `scipy` anyway). While obviously I don't want to trample on anybody's code, I think it might be worth considering how we can reduce the package complexity of `qutip`, especially while significant new complexity is frequently being added in the interests of speed. We only have a finite amount of resources to maintain the codebase, and it's already quite difficult to get a handle on bug reports, documentation, testing (what I'm working on in #1181), and keeping old features up-to-date with the new. In the tracking down of these points, I can also strongly advocate for a stricter policy on `git` commit messages and keeping the commit history tidy and descriptive, but I'll live to fight another day on that one!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1203
https://github.com/qutip/qutip/issues/1203:359,Energy Efficiency,reduce,reduce,359,"Looking through the commit history, @nonhermitian wrote the graph functions back in 2013: see fd4920d. Since then, he contributed a lot of the same code to `scipy` in `scipy.sparse.csgraph`: see https://github.com/scipy/scipy/pull/3751. I suggest we consider dropping most of them, and consequently their surrounding `Cython` code to ease maintainability and reduce code bloat of the repository. First, a couple of arguments against doing so:; - the versions in `scipy` and `qutip` did subsequently diverge in some form, because they no longer universally give the same results, possibly as a result of #654.; - the `qutip` version of `reverse_cuthill_mckee` is about 10% faster than the `scipy` version; - people may be using them. I think the main argument in favour of removal is that they're now also in `scipy` as `scipy.sparse.csgraph`. For the speed argument, for 1000 by 1000 matrices we're talking 780us vs 850us per matrix difference, so it's unlikely to be a limiting factor, and I think the ability to remove a large chunk of Cython code and maintainability cost outweighs this. I began investigating this because I was looking at `qutip.graph.reverse_cuthill_mckee`, since some of its tests are incorrect. The error is here:; https://github.com/qutip/qutip/blob/01132789581821517986fad1a14ab3feec7d2de2/qutip/tests/test_graph.py#L91-L108; Line 105 is broken: it should read; ```python; assert np.all(ans_perm == perm); ```; to test if _all_ the elements match. As it stands, it currently tests that _not all are different_, or in other words, it would only fail if not a single element in the two arrays matched. On fixing this line, we then learn that the test is actually a failing test, because the expected and actual results do not match (though they do however have equal bandwidths). I also note that `qutip` and `matlab` are in disagreement for the test case there: for the matrix; ```python; np.array([[0, 0, 0, 1, 0, 1, 0, 0, 0, 0],; [0, 0, 1, 0, 1, 0, 1, 0, 0, 1],; [0, 1, 0, 1",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1203
https://github.com/qutip/qutip/issues/1203:3714,Energy Efficiency,reduce,reduce,3714,"3, 8]; matlab: [0, 8, 5, 7, 3, 6, 4, 2, 1, 9]; ```; (where I converted the `matlab` indexing into 0-based), however they both have the same ""bandwidth"" of 5, so I assume they are all equivalent. I don't really know anything about the theory here, and just went with what the `matlab` documentation said: https://uk.mathworks.com/help/matlab/ref/symrcm.html. In commit 0ce36d00 it is clear that the functions in `qutip.graph` were meant to be distinct from `Qobj`, so ideally they would be beyond our purview in this package. This actually has already lead to problems with the documentation, since the docstrings in; https://github.com/qutip/qutip/blob/01132789581821517986fad1a14ab3feec7d2de2/qutip/graph.py#L50-L53; and; https://github.com/qutip/qutip/blob/01132789581821517986fad1a14ab3feec7d2de2/qutip/graph.py#L71-L74; are out-of-date. I find that the only uses of `qutip.graph` are in `qutip.steadystate`, which uses `reverse_cuthill_mckee` and `weighted_bipartite_matching`. The former can be replaced directly with the `scipy` version, at the cost of ~10% speed. The latter is not yet in `scipy`, so we ought to perhaps keep it, since it is used and documented for `qutip.steadystate.steadystate`. All other functions in `qutip.graph` are not used, and not documented (and in `scipy` anyway). While obviously I don't want to trample on anybody's code, I think it might be worth considering how we can reduce the package complexity of `qutip`, especially while significant new complexity is frequently being added in the interests of speed. We only have a finite amount of resources to maintain the codebase, and it's already quite difficult to get a handle on bug reports, documentation, testing (what I'm working on in #1181), and keeping old features up-to-date with the new. In the tracking down of these points, I can also strongly advocate for a stricter policy on `git` commit messages and keeping the commit history tidy and descriptive, but I'll live to fight another day on that one!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1203
https://github.com/qutip/qutip/issues/1203:4196,Integrability,message,messages,4196,"3, 8]; matlab: [0, 8, 5, 7, 3, 6, 4, 2, 1, 9]; ```; (where I converted the `matlab` indexing into 0-based), however they both have the same ""bandwidth"" of 5, so I assume they are all equivalent. I don't really know anything about the theory here, and just went with what the `matlab` documentation said: https://uk.mathworks.com/help/matlab/ref/symrcm.html. In commit 0ce36d00 it is clear that the functions in `qutip.graph` were meant to be distinct from `Qobj`, so ideally they would be beyond our purview in this package. This actually has already lead to problems with the documentation, since the docstrings in; https://github.com/qutip/qutip/blob/01132789581821517986fad1a14ab3feec7d2de2/qutip/graph.py#L50-L53; and; https://github.com/qutip/qutip/blob/01132789581821517986fad1a14ab3feec7d2de2/qutip/graph.py#L71-L74; are out-of-date. I find that the only uses of `qutip.graph` are in `qutip.steadystate`, which uses `reverse_cuthill_mckee` and `weighted_bipartite_matching`. The former can be replaced directly with the `scipy` version, at the cost of ~10% speed. The latter is not yet in `scipy`, so we ought to perhaps keep it, since it is used and documented for `qutip.steadystate.steadystate`. All other functions in `qutip.graph` are not used, and not documented (and in `scipy` anyway). While obviously I don't want to trample on anybody's code, I think it might be worth considering how we can reduce the package complexity of `qutip`, especially while significant new complexity is frequently being added in the interests of speed. We only have a finite amount of resources to maintain the codebase, and it's already quite difficult to get a handle on bug reports, documentation, testing (what I'm working on in #1181), and keeping old features up-to-date with the new. In the tracking down of these points, I can also strongly advocate for a stricter policy on `git` commit messages and keeping the commit history tidy and descriptive, but I'll live to fight another day on that one!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1203
https://github.com/qutip/qutip/issues/1203:339,Modifiability,maintainab,maintainability,339,"Looking through the commit history, @nonhermitian wrote the graph functions back in 2013: see fd4920d. Since then, he contributed a lot of the same code to `scipy` in `scipy.sparse.csgraph`: see https://github.com/scipy/scipy/pull/3751. I suggest we consider dropping most of them, and consequently their surrounding `Cython` code to ease maintainability and reduce code bloat of the repository. First, a couple of arguments against doing so:; - the versions in `scipy` and `qutip` did subsequently diverge in some form, because they no longer universally give the same results, possibly as a result of #654.; - the `qutip` version of `reverse_cuthill_mckee` is about 10% faster than the `scipy` version; - people may be using them. I think the main argument in favour of removal is that they're now also in `scipy` as `scipy.sparse.csgraph`. For the speed argument, for 1000 by 1000 matrices we're talking 780us vs 850us per matrix difference, so it's unlikely to be a limiting factor, and I think the ability to remove a large chunk of Cython code and maintainability cost outweighs this. I began investigating this because I was looking at `qutip.graph.reverse_cuthill_mckee`, since some of its tests are incorrect. The error is here:; https://github.com/qutip/qutip/blob/01132789581821517986fad1a14ab3feec7d2de2/qutip/tests/test_graph.py#L91-L108; Line 105 is broken: it should read; ```python; assert np.all(ans_perm == perm); ```; to test if _all_ the elements match. As it stands, it currently tests that _not all are different_, or in other words, it would only fail if not a single element in the two arrays matched. On fixing this line, we then learn that the test is actually a failing test, because the expected and actual results do not match (though they do however have equal bandwidths). I also note that `qutip` and `matlab` are in disagreement for the test case there: for the matrix; ```python; np.array([[0, 0, 0, 1, 0, 1, 0, 0, 0, 0],; [0, 0, 1, 0, 1, 0, 1, 0, 0, 1],; [0, 1, 0, 1",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1203
https://github.com/qutip/qutip/issues/1203:1054,Modifiability,maintainab,maintainability,1054,"Looking through the commit history, @nonhermitian wrote the graph functions back in 2013: see fd4920d. Since then, he contributed a lot of the same code to `scipy` in `scipy.sparse.csgraph`: see https://github.com/scipy/scipy/pull/3751. I suggest we consider dropping most of them, and consequently their surrounding `Cython` code to ease maintainability and reduce code bloat of the repository. First, a couple of arguments against doing so:; - the versions in `scipy` and `qutip` did subsequently diverge in some form, because they no longer universally give the same results, possibly as a result of #654.; - the `qutip` version of `reverse_cuthill_mckee` is about 10% faster than the `scipy` version; - people may be using them. I think the main argument in favour of removal is that they're now also in `scipy` as `scipy.sparse.csgraph`. For the speed argument, for 1000 by 1000 matrices we're talking 780us vs 850us per matrix difference, so it's unlikely to be a limiting factor, and I think the ability to remove a large chunk of Cython code and maintainability cost outweighs this. I began investigating this because I was looking at `qutip.graph.reverse_cuthill_mckee`, since some of its tests are incorrect. The error is here:; https://github.com/qutip/qutip/blob/01132789581821517986fad1a14ab3feec7d2de2/qutip/tests/test_graph.py#L91-L108; Line 105 is broken: it should read; ```python; assert np.all(ans_perm == perm); ```; to test if _all_ the elements match. As it stands, it currently tests that _not all are different_, or in other words, it would only fail if not a single element in the two arrays matched. On fixing this line, we then learn that the test is actually a failing test, because the expected and actual results do not match (though they do however have equal bandwidths). I also note that `qutip` and `matlab` are in disagreement for the test case there: for the matrix; ```python; np.array([[0, 0, 0, 1, 0, 1, 0, 0, 0, 0],; [0, 0, 1, 0, 1, 0, 1, 0, 0, 1],; [0, 1, 0, 1",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1203
https://github.com/qutip/qutip/issues/1203:1198,Testability,test,tests,1198,"h`: see https://github.com/scipy/scipy/pull/3751. I suggest we consider dropping most of them, and consequently their surrounding `Cython` code to ease maintainability and reduce code bloat of the repository. First, a couple of arguments against doing so:; - the versions in `scipy` and `qutip` did subsequently diverge in some form, because they no longer universally give the same results, possibly as a result of #654.; - the `qutip` version of `reverse_cuthill_mckee` is about 10% faster than the `scipy` version; - people may be using them. I think the main argument in favour of removal is that they're now also in `scipy` as `scipy.sparse.csgraph`. For the speed argument, for 1000 by 1000 matrices we're talking 780us vs 850us per matrix difference, so it's unlikely to be a limiting factor, and I think the ability to remove a large chunk of Cython code and maintainability cost outweighs this. I began investigating this because I was looking at `qutip.graph.reverse_cuthill_mckee`, since some of its tests are incorrect. The error is here:; https://github.com/qutip/qutip/blob/01132789581821517986fad1a14ab3feec7d2de2/qutip/tests/test_graph.py#L91-L108; Line 105 is broken: it should read; ```python; assert np.all(ans_perm == perm); ```; to test if _all_ the elements match. As it stands, it currently tests that _not all are different_, or in other words, it would only fail if not a single element in the two arrays matched. On fixing this line, we then learn that the test is actually a failing test, because the expected and actual results do not match (though they do however have equal bandwidths). I also note that `qutip` and `matlab` are in disagreement for the test case there: for the matrix; ```python; np.array([[0, 0, 0, 1, 0, 1, 0, 0, 0, 0],; [0, 0, 1, 0, 1, 0, 1, 0, 0, 1],; [0, 1, 0, 1, 1, 0, 0, 0, 0, 0],; [1, 0, 1, 0, 0, 1, 0, 0, 1, 0],; [0, 1, 1, 0, 0, 0, 1, 0, 0, 0],; [1, 0, 0, 1, 0, 0, 1, 1, 0, 0],; [0, 1, 0, 0, 1, 1, 0, 1, 0, 0],; [0, 0, 0, 0, 0, 1, 1, 0, 0, 0],;",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1203
https://github.com/qutip/qutip/issues/1203:1322,Testability,test,tests,1322,"ly their surrounding `Cython` code to ease maintainability and reduce code bloat of the repository. First, a couple of arguments against doing so:; - the versions in `scipy` and `qutip` did subsequently diverge in some form, because they no longer universally give the same results, possibly as a result of #654.; - the `qutip` version of `reverse_cuthill_mckee` is about 10% faster than the `scipy` version; - people may be using them. I think the main argument in favour of removal is that they're now also in `scipy` as `scipy.sparse.csgraph`. For the speed argument, for 1000 by 1000 matrices we're talking 780us vs 850us per matrix difference, so it's unlikely to be a limiting factor, and I think the ability to remove a large chunk of Cython code and maintainability cost outweighs this. I began investigating this because I was looking at `qutip.graph.reverse_cuthill_mckee`, since some of its tests are incorrect. The error is here:; https://github.com/qutip/qutip/blob/01132789581821517986fad1a14ab3feec7d2de2/qutip/tests/test_graph.py#L91-L108; Line 105 is broken: it should read; ```python; assert np.all(ans_perm == perm); ```; to test if _all_ the elements match. As it stands, it currently tests that _not all are different_, or in other words, it would only fail if not a single element in the two arrays matched. On fixing this line, we then learn that the test is actually a failing test, because the expected and actual results do not match (though they do however have equal bandwidths). I also note that `qutip` and `matlab` are in disagreement for the test case there: for the matrix; ```python; np.array([[0, 0, 0, 1, 0, 1, 0, 0, 0, 0],; [0, 0, 1, 0, 1, 0, 1, 0, 0, 1],; [0, 1, 0, 1, 1, 0, 0, 0, 0, 0],; [1, 0, 1, 0, 0, 1, 0, 0, 1, 0],; [0, 1, 1, 0, 0, 0, 1, 0, 0, 0],; [1, 0, 0, 1, 0, 0, 1, 1, 0, 0],; [0, 1, 0, 0, 1, 1, 0, 1, 0, 0],; [0, 0, 0, 0, 0, 1, 1, 0, 0, 0],; [0, 0, 0, 1, 0, 0, 0, 0, 0, 0],; [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]]); ```; we get; ```; qutip: [9, 6, 7, 1, 4, 5",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1203
https://github.com/qutip/qutip/issues/1203:1399,Testability,assert,assert,1399,"at of the repository. First, a couple of arguments against doing so:; - the versions in `scipy` and `qutip` did subsequently diverge in some form, because they no longer universally give the same results, possibly as a result of #654.; - the `qutip` version of `reverse_cuthill_mckee` is about 10% faster than the `scipy` version; - people may be using them. I think the main argument in favour of removal is that they're now also in `scipy` as `scipy.sparse.csgraph`. For the speed argument, for 1000 by 1000 matrices we're talking 780us vs 850us per matrix difference, so it's unlikely to be a limiting factor, and I think the ability to remove a large chunk of Cython code and maintainability cost outweighs this. I began investigating this because I was looking at `qutip.graph.reverse_cuthill_mckee`, since some of its tests are incorrect. The error is here:; https://github.com/qutip/qutip/blob/01132789581821517986fad1a14ab3feec7d2de2/qutip/tests/test_graph.py#L91-L108; Line 105 is broken: it should read; ```python; assert np.all(ans_perm == perm); ```; to test if _all_ the elements match. As it stands, it currently tests that _not all are different_, or in other words, it would only fail if not a single element in the two arrays matched. On fixing this line, we then learn that the test is actually a failing test, because the expected and actual results do not match (though they do however have equal bandwidths). I also note that `qutip` and `matlab` are in disagreement for the test case there: for the matrix; ```python; np.array([[0, 0, 0, 1, 0, 1, 0, 0, 0, 0],; [0, 0, 1, 0, 1, 0, 1, 0, 0, 1],; [0, 1, 0, 1, 1, 0, 0, 0, 0, 0],; [1, 0, 1, 0, 0, 1, 0, 0, 1, 0],; [0, 1, 1, 0, 0, 0, 1, 0, 0, 0],; [1, 0, 0, 1, 0, 0, 1, 1, 0, 0],; [0, 1, 0, 0, 1, 1, 0, 1, 0, 0],; [0, 0, 0, 0, 0, 1, 1, 0, 0, 0],; [0, 0, 0, 1, 0, 0, 0, 0, 0, 0],; [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]]); ```; we get; ```; qutip: [9, 6, 7, 1, 4, 5, 2, 0, 3, 8]; matlab: [0, 8, 5, 7, 3, 6, 4, 2, 1, 9]; ```; (where I converte",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1203
https://github.com/qutip/qutip/issues/1203:1440,Testability,test,test,1440,":; - the versions in `scipy` and `qutip` did subsequently diverge in some form, because they no longer universally give the same results, possibly as a result of #654.; - the `qutip` version of `reverse_cuthill_mckee` is about 10% faster than the `scipy` version; - people may be using them. I think the main argument in favour of removal is that they're now also in `scipy` as `scipy.sparse.csgraph`. For the speed argument, for 1000 by 1000 matrices we're talking 780us vs 850us per matrix difference, so it's unlikely to be a limiting factor, and I think the ability to remove a large chunk of Cython code and maintainability cost outweighs this. I began investigating this because I was looking at `qutip.graph.reverse_cuthill_mckee`, since some of its tests are incorrect. The error is here:; https://github.com/qutip/qutip/blob/01132789581821517986fad1a14ab3feec7d2de2/qutip/tests/test_graph.py#L91-L108; Line 105 is broken: it should read; ```python; assert np.all(ans_perm == perm); ```; to test if _all_ the elements match. As it stands, it currently tests that _not all are different_, or in other words, it would only fail if not a single element in the two arrays matched. On fixing this line, we then learn that the test is actually a failing test, because the expected and actual results do not match (though they do however have equal bandwidths). I also note that `qutip` and `matlab` are in disagreement for the test case there: for the matrix; ```python; np.array([[0, 0, 0, 1, 0, 1, 0, 0, 0, 0],; [0, 0, 1, 0, 1, 0, 1, 0, 0, 1],; [0, 1, 0, 1, 1, 0, 0, 0, 0, 0],; [1, 0, 1, 0, 0, 1, 0, 0, 1, 0],; [0, 1, 1, 0, 0, 0, 1, 0, 0, 0],; [1, 0, 0, 1, 0, 0, 1, 1, 0, 0],; [0, 1, 0, 0, 1, 1, 0, 1, 0, 0],; [0, 0, 0, 0, 0, 1, 1, 0, 0, 0],; [0, 0, 0, 1, 0, 0, 0, 0, 0, 0],; [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]]); ```; we get; ```; qutip: [9, 6, 7, 1, 4, 5, 2, 0, 3, 8]; matlab: [0, 8, 5, 7, 3, 6, 4, 2, 1, 9]; ```; (where I converted the `matlab` indexing into 0-based), however they both have the s",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1203
https://github.com/qutip/qutip/issues/1203:1501,Testability,test,tests,1501,"rsally give the same results, possibly as a result of #654.; - the `qutip` version of `reverse_cuthill_mckee` is about 10% faster than the `scipy` version; - people may be using them. I think the main argument in favour of removal is that they're now also in `scipy` as `scipy.sparse.csgraph`. For the speed argument, for 1000 by 1000 matrices we're talking 780us vs 850us per matrix difference, so it's unlikely to be a limiting factor, and I think the ability to remove a large chunk of Cython code and maintainability cost outweighs this. I began investigating this because I was looking at `qutip.graph.reverse_cuthill_mckee`, since some of its tests are incorrect. The error is here:; https://github.com/qutip/qutip/blob/01132789581821517986fad1a14ab3feec7d2de2/qutip/tests/test_graph.py#L91-L108; Line 105 is broken: it should read; ```python; assert np.all(ans_perm == perm); ```; to test if _all_ the elements match. As it stands, it currently tests that _not all are different_, or in other words, it would only fail if not a single element in the two arrays matched. On fixing this line, we then learn that the test is actually a failing test, because the expected and actual results do not match (though they do however have equal bandwidths). I also note that `qutip` and `matlab` are in disagreement for the test case there: for the matrix; ```python; np.array([[0, 0, 0, 1, 0, 1, 0, 0, 0, 0],; [0, 0, 1, 0, 1, 0, 1, 0, 0, 1],; [0, 1, 0, 1, 1, 0, 0, 0, 0, 0],; [1, 0, 1, 0, 0, 1, 0, 0, 1, 0],; [0, 1, 1, 0, 0, 0, 1, 0, 0, 0],; [1, 0, 0, 1, 0, 0, 1, 1, 0, 0],; [0, 1, 0, 0, 1, 1, 0, 1, 0, 0],; [0, 0, 0, 0, 0, 1, 1, 0, 0, 0],; [0, 0, 0, 1, 0, 0, 0, 0, 0, 0],; [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]]); ```; we get; ```; qutip: [9, 6, 7, 1, 4, 5, 2, 0, 3, 8]; matlab: [0, 8, 5, 7, 3, 6, 4, 2, 1, 9]; ```; (where I converted the `matlab` indexing into 0-based), however they both have the same ""bandwidth"" of 5, so I assume they are all equivalent. I don't really know anything about the theory her",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1203
https://github.com/qutip/qutip/issues/1203:1670,Testability,test,test,1670,"may be using them. I think the main argument in favour of removal is that they're now also in `scipy` as `scipy.sparse.csgraph`. For the speed argument, for 1000 by 1000 matrices we're talking 780us vs 850us per matrix difference, so it's unlikely to be a limiting factor, and I think the ability to remove a large chunk of Cython code and maintainability cost outweighs this. I began investigating this because I was looking at `qutip.graph.reverse_cuthill_mckee`, since some of its tests are incorrect. The error is here:; https://github.com/qutip/qutip/blob/01132789581821517986fad1a14ab3feec7d2de2/qutip/tests/test_graph.py#L91-L108; Line 105 is broken: it should read; ```python; assert np.all(ans_perm == perm); ```; to test if _all_ the elements match. As it stands, it currently tests that _not all are different_, or in other words, it would only fail if not a single element in the two arrays matched. On fixing this line, we then learn that the test is actually a failing test, because the expected and actual results do not match (though they do however have equal bandwidths). I also note that `qutip` and `matlab` are in disagreement for the test case there: for the matrix; ```python; np.array([[0, 0, 0, 1, 0, 1, 0, 0, 0, 0],; [0, 0, 1, 0, 1, 0, 1, 0, 0, 1],; [0, 1, 0, 1, 1, 0, 0, 0, 0, 0],; [1, 0, 1, 0, 0, 1, 0, 0, 1, 0],; [0, 1, 1, 0, 0, 0, 1, 0, 0, 0],; [1, 0, 0, 1, 0, 0, 1, 1, 0, 0],; [0, 1, 0, 0, 1, 1, 0, 1, 0, 0],; [0, 0, 0, 0, 0, 1, 1, 0, 0, 0],; [0, 0, 0, 1, 0, 0, 0, 0, 0, 0],; [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]]); ```; we get; ```; qutip: [9, 6, 7, 1, 4, 5, 2, 0, 3, 8]; matlab: [0, 8, 5, 7, 3, 6, 4, 2, 1, 9]; ```; (where I converted the `matlab` indexing into 0-based), however they both have the same ""bandwidth"" of 5, so I assume they are all equivalent. I don't really know anything about the theory here, and just went with what the `matlab` documentation said: https://uk.mathworks.com/help/matlab/ref/symrcm.html. In commit 0ce36d00 it is clear that the functions i",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1203
https://github.com/qutip/qutip/issues/1203:1697,Testability,test,test,1697,"may be using them. I think the main argument in favour of removal is that they're now also in `scipy` as `scipy.sparse.csgraph`. For the speed argument, for 1000 by 1000 matrices we're talking 780us vs 850us per matrix difference, so it's unlikely to be a limiting factor, and I think the ability to remove a large chunk of Cython code and maintainability cost outweighs this. I began investigating this because I was looking at `qutip.graph.reverse_cuthill_mckee`, since some of its tests are incorrect. The error is here:; https://github.com/qutip/qutip/blob/01132789581821517986fad1a14ab3feec7d2de2/qutip/tests/test_graph.py#L91-L108; Line 105 is broken: it should read; ```python; assert np.all(ans_perm == perm); ```; to test if _all_ the elements match. As it stands, it currently tests that _not all are different_, or in other words, it would only fail if not a single element in the two arrays matched. On fixing this line, we then learn that the test is actually a failing test, because the expected and actual results do not match (though they do however have equal bandwidths). I also note that `qutip` and `matlab` are in disagreement for the test case there: for the matrix; ```python; np.array([[0, 0, 0, 1, 0, 1, 0, 0, 0, 0],; [0, 0, 1, 0, 1, 0, 1, 0, 0, 1],; [0, 1, 0, 1, 1, 0, 0, 0, 0, 0],; [1, 0, 1, 0, 0, 1, 0, 0, 1, 0],; [0, 1, 1, 0, 0, 0, 1, 0, 0, 0],; [1, 0, 0, 1, 0, 0, 1, 1, 0, 0],; [0, 1, 0, 0, 1, 1, 0, 1, 0, 0],; [0, 0, 0, 0, 0, 1, 1, 0, 0, 0],; [0, 0, 0, 1, 0, 0, 0, 0, 0, 0],; [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]]); ```; we get; ```; qutip: [9, 6, 7, 1, 4, 5, 2, 0, 3, 8]; matlab: [0, 8, 5, 7, 3, 6, 4, 2, 1, 9]; ```; (where I converted the `matlab` indexing into 0-based), however they both have the same ""bandwidth"" of 5, so I assume they are all equivalent. I don't really know anything about the theory here, and just went with what the `matlab` documentation said: https://uk.mathworks.com/help/matlab/ref/symrcm.html. In commit 0ce36d00 it is clear that the functions i",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1203
https://github.com/qutip/qutip/issues/1203:1870,Testability,test,test,1870,"ument, for 1000 by 1000 matrices we're talking 780us vs 850us per matrix difference, so it's unlikely to be a limiting factor, and I think the ability to remove a large chunk of Cython code and maintainability cost outweighs this. I began investigating this because I was looking at `qutip.graph.reverse_cuthill_mckee`, since some of its tests are incorrect. The error is here:; https://github.com/qutip/qutip/blob/01132789581821517986fad1a14ab3feec7d2de2/qutip/tests/test_graph.py#L91-L108; Line 105 is broken: it should read; ```python; assert np.all(ans_perm == perm); ```; to test if _all_ the elements match. As it stands, it currently tests that _not all are different_, or in other words, it would only fail if not a single element in the two arrays matched. On fixing this line, we then learn that the test is actually a failing test, because the expected and actual results do not match (though they do however have equal bandwidths). I also note that `qutip` and `matlab` are in disagreement for the test case there: for the matrix; ```python; np.array([[0, 0, 0, 1, 0, 1, 0, 0, 0, 0],; [0, 0, 1, 0, 1, 0, 1, 0, 0, 1],; [0, 1, 0, 1, 1, 0, 0, 0, 0, 0],; [1, 0, 1, 0, 0, 1, 0, 0, 1, 0],; [0, 1, 1, 0, 0, 0, 1, 0, 0, 0],; [1, 0, 0, 1, 0, 0, 1, 1, 0, 0],; [0, 1, 0, 0, 1, 1, 0, 1, 0, 0],; [0, 0, 0, 0, 0, 1, 1, 0, 0, 0],; [0, 0, 0, 1, 0, 0, 0, 0, 0, 0],; [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]]); ```; we get; ```; qutip: [9, 6, 7, 1, 4, 5, 2, 0, 3, 8]; matlab: [0, 8, 5, 7, 3, 6, 4, 2, 1, 9]; ```; (where I converted the `matlab` indexing into 0-based), however they both have the same ""bandwidth"" of 5, so I assume they are all equivalent. I don't really know anything about the theory here, and just went with what the `matlab` documentation said: https://uk.mathworks.com/help/matlab/ref/symrcm.html. In commit 0ce36d00 it is clear that the functions in `qutip.graph` were meant to be distinct from `Qobj`, so ideally they would be beyond our purview in this package. This actually has already lead",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1203
https://github.com/qutip/qutip/issues/1203:4001,Testability,test,testing,4001,"3, 8]; matlab: [0, 8, 5, 7, 3, 6, 4, 2, 1, 9]; ```; (where I converted the `matlab` indexing into 0-based), however they both have the same ""bandwidth"" of 5, so I assume they are all equivalent. I don't really know anything about the theory here, and just went with what the `matlab` documentation said: https://uk.mathworks.com/help/matlab/ref/symrcm.html. In commit 0ce36d00 it is clear that the functions in `qutip.graph` were meant to be distinct from `Qobj`, so ideally they would be beyond our purview in this package. This actually has already lead to problems with the documentation, since the docstrings in; https://github.com/qutip/qutip/blob/01132789581821517986fad1a14ab3feec7d2de2/qutip/graph.py#L50-L53; and; https://github.com/qutip/qutip/blob/01132789581821517986fad1a14ab3feec7d2de2/qutip/graph.py#L71-L74; are out-of-date. I find that the only uses of `qutip.graph` are in `qutip.steadystate`, which uses `reverse_cuthill_mckee` and `weighted_bipartite_matching`. The former can be replaced directly with the `scipy` version, at the cost of ~10% speed. The latter is not yet in `scipy`, so we ought to perhaps keep it, since it is used and documented for `qutip.steadystate.steadystate`. All other functions in `qutip.graph` are not used, and not documented (and in `scipy` anyway). While obviously I don't want to trample on anybody's code, I think it might be worth considering how we can reduce the package complexity of `qutip`, especially while significant new complexity is frequently being added in the interests of speed. We only have a finite amount of resources to maintain the codebase, and it's already quite difficult to get a handle on bug reports, documentation, testing (what I'm working on in #1181), and keeping old features up-to-date with the new. In the tracking down of these points, I can also strongly advocate for a stricter policy on `git` commit messages and keeping the commit history tidy and descriptive, but I'll live to fight another day on that one!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1203
https://github.com/qutip/qutip/issues/1203:1655,Usability,learn,learn,1655,"may be using them. I think the main argument in favour of removal is that they're now also in `scipy` as `scipy.sparse.csgraph`. For the speed argument, for 1000 by 1000 matrices we're talking 780us vs 850us per matrix difference, so it's unlikely to be a limiting factor, and I think the ability to remove a large chunk of Cython code and maintainability cost outweighs this. I began investigating this because I was looking at `qutip.graph.reverse_cuthill_mckee`, since some of its tests are incorrect. The error is here:; https://github.com/qutip/qutip/blob/01132789581821517986fad1a14ab3feec7d2de2/qutip/tests/test_graph.py#L91-L108; Line 105 is broken: it should read; ```python; assert np.all(ans_perm == perm); ```; to test if _all_ the elements match. As it stands, it currently tests that _not all are different_, or in other words, it would only fail if not a single element in the two arrays matched. On fixing this line, we then learn that the test is actually a failing test, because the expected and actual results do not match (though they do however have equal bandwidths). I also note that `qutip` and `matlab` are in disagreement for the test case there: for the matrix; ```python; np.array([[0, 0, 0, 1, 0, 1, 0, 0, 0, 0],; [0, 0, 1, 0, 1, 0, 1, 0, 0, 1],; [0, 1, 0, 1, 1, 0, 0, 0, 0, 0],; [1, 0, 1, 0, 0, 1, 0, 0, 1, 0],; [0, 1, 1, 0, 0, 0, 1, 0, 0, 0],; [1, 0, 0, 1, 0, 0, 1, 1, 0, 0],; [0, 1, 0, 0, 1, 1, 0, 1, 0, 0],; [0, 0, 0, 0, 0, 1, 1, 0, 0, 0],; [0, 0, 0, 1, 0, 0, 0, 0, 0, 0],; [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]]); ```; we get; ```; qutip: [9, 6, 7, 1, 4, 5, 2, 0, 3, 8]; matlab: [0, 8, 5, 7, 3, 6, 4, 2, 1, 9]; ```; (where I converted the `matlab` indexing into 0-based), however they both have the same ""bandwidth"" of 5, so I assume they are all equivalent. I don't really know anything about the theory here, and just went with what the `matlab` documentation said: https://uk.mathworks.com/help/matlab/ref/symrcm.html. In commit 0ce36d00 it is clear that the functions i",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1203
https://github.com/qutip/qutip/issues/1203:2688,Usability,clear,clear,2688,"ling test, because the expected and actual results do not match (though they do however have equal bandwidths). I also note that `qutip` and `matlab` are in disagreement for the test case there: for the matrix; ```python; np.array([[0, 0, 0, 1, 0, 1, 0, 0, 0, 0],; [0, 0, 1, 0, 1, 0, 1, 0, 0, 1],; [0, 1, 0, 1, 1, 0, 0, 0, 0, 0],; [1, 0, 1, 0, 0, 1, 0, 0, 1, 0],; [0, 1, 1, 0, 0, 0, 1, 0, 0, 0],; [1, 0, 0, 1, 0, 0, 1, 1, 0, 0],; [0, 1, 0, 0, 1, 1, 0, 1, 0, 0],; [0, 0, 0, 0, 0, 1, 1, 0, 0, 0],; [0, 0, 0, 1, 0, 0, 0, 0, 0, 0],; [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]]); ```; we get; ```; qutip: [9, 6, 7, 1, 4, 5, 2, 0, 3, 8]; matlab: [0, 8, 5, 7, 3, 6, 4, 2, 1, 9]; ```; (where I converted the `matlab` indexing into 0-based), however they both have the same ""bandwidth"" of 5, so I assume they are all equivalent. I don't really know anything about the theory here, and just went with what the `matlab` documentation said: https://uk.mathworks.com/help/matlab/ref/symrcm.html. In commit 0ce36d00 it is clear that the functions in `qutip.graph` were meant to be distinct from `Qobj`, so ideally they would be beyond our purview in this package. This actually has already lead to problems with the documentation, since the docstrings in; https://github.com/qutip/qutip/blob/01132789581821517986fad1a14ab3feec7d2de2/qutip/graph.py#L50-L53; and; https://github.com/qutip/qutip/blob/01132789581821517986fad1a14ab3feec7d2de2/qutip/graph.py#L71-L74; are out-of-date. I find that the only uses of `qutip.graph` are in `qutip.steadystate`, which uses `reverse_cuthill_mckee` and `weighted_bipartite_matching`. The former can be replaced directly with the `scipy` version, at the cost of ~10% speed. The latter is not yet in `scipy`, so we ought to perhaps keep it, since it is used and documented for `qutip.steadystate.steadystate`. All other functions in `qutip.graph` are not used, and not documented (and in `scipy` anyway). While obviously I don't want to trample on anybody's code, I think it might be worth co",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1203
https://github.com/qutip/qutip/issues/1204:104,Availability,error,error,104,"Hello,; I noticed that vector_to_operator stopped working after updating to 4.5. Simple code that gives error:. ```; import qutip as qu. def zero_state_qutip(nb_qubits):; zero=qu.basis(2,0); if nb_qubits>1:; for i in range(1,nb_qubits):; zero=qu.tensor(zero,qu.basis(2,0)); return zero. nb_qubits=4. Psi=zero_state_qutip(nb_qubits). V=qu.vector_to_operator(Psi); ```. The code works fine with nb_qubits=2, but not with 4, 6 etc. The error is:. File ""qutip\superoperator.py"", line 279, in vector_to_operator; q.data = sp_reshape(op.data.T, shape[::-1]).T. File ""qutip\sparse.py"", line 135, in sp_reshape; return zcsr_reshape(A, shape[0], shape[1]). File ""qutip/cy/spconvert.pyx"", line 254, in qutip.cy.spconvert.zcsr_reshape. Exception: Total size of array must be unchanged.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1204
https://github.com/qutip/qutip/issues/1204:433,Availability,error,error,433,"Hello,; I noticed that vector_to_operator stopped working after updating to 4.5. Simple code that gives error:. ```; import qutip as qu. def zero_state_qutip(nb_qubits):; zero=qu.basis(2,0); if nb_qubits>1:; for i in range(1,nb_qubits):; zero=qu.tensor(zero,qu.basis(2,0)); return zero. nb_qubits=4. Psi=zero_state_qutip(nb_qubits). V=qu.vector_to_operator(Psi); ```. The code works fine with nb_qubits=2, but not with 4, 6 etc. The error is:. File ""qutip\superoperator.py"", line 279, in vector_to_operator; q.data = sp_reshape(op.data.T, shape[::-1]).T. File ""qutip\sparse.py"", line 135, in sp_reshape; return zcsr_reshape(A, shape[0], shape[1]). File ""qutip/cy/spconvert.pyx"", line 254, in qutip.cy.spconvert.zcsr_reshape. Exception: Total size of array must be unchanged.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1204
https://github.com/qutip/qutip/issues/1204:81,Usability,Simpl,Simple,81,"Hello,; I noticed that vector_to_operator stopped working after updating to 4.5. Simple code that gives error:. ```; import qutip as qu. def zero_state_qutip(nb_qubits):; zero=qu.basis(2,0); if nb_qubits>1:; for i in range(1,nb_qubits):; zero=qu.tensor(zero,qu.basis(2,0)); return zero. nb_qubits=4. Psi=zero_state_qutip(nb_qubits). V=qu.vector_to_operator(Psi); ```. The code works fine with nb_qubits=2, but not with 4, 6 etc. The error is:. File ""qutip\superoperator.py"", line 279, in vector_to_operator; q.data = sp_reshape(op.data.T, shape[::-1]).T. File ""qutip\sparse.py"", line 135, in sp_reshape; return zcsr_reshape(A, shape[0], shape[1]). File ""qutip/cy/spconvert.pyx"", line 254, in qutip.cy.spconvert.zcsr_reshape. Exception: Total size of array must be unchanged.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1204
https://github.com/qutip/qutip/issues/1205:245,Availability,error,error,245,"I want to install qutip on the linux (ubuntu 18.04 LTS), but I got the following issue. I wonder whether anyone has encountered this problem before. . ```; /home/abc/.pyxbld/temp.linux-x86_64-3.7/pyrex/qutip/cy/openmp/parfuncs.cpp:614:10: fatal error: src/zspmv_openmp.hpp: No such file or directory; #include ""src/zspmv_openmp.hpp""; ^~~~~~~~~~~~~~~~~~~~~~; compilation terminated.; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1205
https://github.com/qutip/qutip/issues/1205:10,Deployability,install,install,10,"I want to install qutip on the linux (ubuntu 18.04 LTS), but I got the following issue. I wonder whether anyone has encountered this problem before. . ```; /home/abc/.pyxbld/temp.linux-x86_64-3.7/pyrex/qutip/cy/openmp/parfuncs.cpp:614:10: fatal error: src/zspmv_openmp.hpp: No such file or directory; #include ""src/zspmv_openmp.hpp""; ^~~~~~~~~~~~~~~~~~~~~~; compilation terminated.; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1205
https://github.com/qutip/qutip/pull/1206:665,Availability,mainten,maintenance,665,"Implements the changes mentioned in #1203. The `qutip.graph` functions are pure mathematical functions which are beyond the purview of the package. Most of them have already been merged into `scipy.sparse.csgraph`, so we now move to using those and mark the functions as deprecated. Only two functions are actually used, and they're not even currently tested. `weighted_bipartite_matching` is not present in `scipy`, but is still marked as deprecated because we can move it into being an internal-only function, or simply remove the code that depends on it since those paths are not tested. This will allow the removal of a good amount of Cython code, and simplify maintenance.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1206
https://github.com/qutip/qutip/pull/1206:543,Integrability,depend,depends,543,"Implements the changes mentioned in #1203. The `qutip.graph` functions are pure mathematical functions which are beyond the purview of the package. Most of them have already been merged into `scipy.sparse.csgraph`, so we now move to using those and mark the functions as deprecated. Only two functions are actually used, and they're not even currently tested. `weighted_bipartite_matching` is not present in `scipy`, but is still marked as deprecated because we can move it into being an internal-only function, or simply remove the code that depends on it since those paths are not tested. This will allow the removal of a good amount of Cython code, and simplify maintenance.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1206
https://github.com/qutip/qutip/pull/1206:352,Testability,test,tested,352,"Implements the changes mentioned in #1203. The `qutip.graph` functions are pure mathematical functions which are beyond the purview of the package. Most of them have already been merged into `scipy.sparse.csgraph`, so we now move to using those and mark the functions as deprecated. Only two functions are actually used, and they're not even currently tested. `weighted_bipartite_matching` is not present in `scipy`, but is still marked as deprecated because we can move it into being an internal-only function, or simply remove the code that depends on it since those paths are not tested. This will allow the removal of a good amount of Cython code, and simplify maintenance.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1206
https://github.com/qutip/qutip/pull/1206:583,Testability,test,tested,583,"Implements the changes mentioned in #1203. The `qutip.graph` functions are pure mathematical functions which are beyond the purview of the package. Most of them have already been merged into `scipy.sparse.csgraph`, so we now move to using those and mark the functions as deprecated. Only two functions are actually used, and they're not even currently tested. `weighted_bipartite_matching` is not present in `scipy`, but is still marked as deprecated because we can move it into being an internal-only function, or simply remove the code that depends on it since those paths are not tested. This will allow the removal of a good amount of Cython code, and simplify maintenance.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1206
https://github.com/qutip/qutip/pull/1206:515,Usability,simpl,simply,515,"Implements the changes mentioned in #1203. The `qutip.graph` functions are pure mathematical functions which are beyond the purview of the package. Most of them have already been merged into `scipy.sparse.csgraph`, so we now move to using those and mark the functions as deprecated. Only two functions are actually used, and they're not even currently tested. `weighted_bipartite_matching` is not present in `scipy`, but is still marked as deprecated because we can move it into being an internal-only function, or simply remove the code that depends on it since those paths are not tested. This will allow the removal of a good amount of Cython code, and simplify maintenance.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1206
https://github.com/qutip/qutip/pull/1206:656,Usability,simpl,simplify,656,"Implements the changes mentioned in #1203. The `qutip.graph` functions are pure mathematical functions which are beyond the purview of the package. Most of them have already been merged into `scipy.sparse.csgraph`, so we now move to using those and mark the functions as deprecated. Only two functions are actually used, and they're not even currently tested. `weighted_bipartite_matching` is not present in `scipy`, but is still marked as deprecated because we can move it into being an internal-only function, or simply remove the code that depends on it since those paths are not tested. This will allow the removal of a good amount of Cython code, and simplify maintenance.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1206
https://github.com/qutip/qutip/issues/1207:483,Availability,error,error,483,"I try to run the code for finding floquet energies from the qutip user guide. . ```python; import numpy as np; from qutip import *; import matplotlib.pyplot as plt. delta = 0.2 * 2*np.pi; eps0 = 1.0 * 2*np.pi; A = 2.5 * 2*np.pi; omega = 1.0 * 2*np.pi; H0 = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(); H1 = A/2.0 * sigmaz(); args = {'w': omega}; H = [H0, [H1, 'sin(w * t)']]; T = 2*pi / omega; f_modes_0, f_energies = floquet_modes(H, T, args); f_energies; ```. I got the following error . ```text; File ""<ipython-input-6-76f4206b44f0>"", line 1, in <module>; runfile('C:/Users/605912/OneDrive - BOOZ ALLEN HAMILTON/DARPA/John Burke/Quantum apertures/calculations/floquet.py', wdir='C:/Users/605912/OneDrive - BOOZ ALLEN HAMILTON/DARPA/John Burke/Quantum apertures/calculations'). File ""C:\Users\605912\AppData\Local\Continuum\anaconda3\lib\site-packages\spyder_kernels\customize\spydercustomize.py"", line 827, in runfile; execfile(filename, namespace). File ""C:\Users\605912\AppData\Local\Continuum\anaconda3\lib\site-packages\spyder_kernels\customize\spydercustomize.py"", line 110, in execfile; exec(compile(f.read(), filename, 'exec'), namespace). File ""C:/Users/605912/OneDrive - BOOZ ALLEN HAMILTON/DARPA/John Burke/Quantum apertures/calculations/floquet.py"", line 27, in <module>; f_modes_0, f_energies = floquet_modes(H, T, args). File ""C:\Users\605912\AppData\Local\Continuum\anaconda3\lib\site-packages\qutip\floquet.py"", line 102, in floquet_modes; U = propagator(H, T, [], args). File ""C:\Users\605912\AppData\Local\Continuum\anaconda3\lib\site-packages\qutip\propagator.py"", line 186, in propagator; _safe_mode=False). File ""C:\Users\605912\AppData\Local\Continuum\anaconda3\lib\site-packages\qutip\sesolve.py"", line 157, in sesolve; ss = _sesolve_QobjEvo(H, tlist, args, options). File ""C:\Users\605912\AppData\Local\Continuum\anaconda3\lib\site-packages\qutip\sesolve.py"", line 189, in _sesolve_QobjEvo; H_td.compile(omp=nthread). File ""C:\Users\605912\AppData\Local\Continuum\anaconda3\",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1207
https://github.com/qutip/qutip/issues/1207:2421,Modifiability,variab,variable,2421,"t the following error . ```text; File ""<ipython-input-6-76f4206b44f0>"", line 1, in <module>; runfile('C:/Users/605912/OneDrive - BOOZ ALLEN HAMILTON/DARPA/John Burke/Quantum apertures/calculations/floquet.py', wdir='C:/Users/605912/OneDrive - BOOZ ALLEN HAMILTON/DARPA/John Burke/Quantum apertures/calculations'). File ""C:\Users\605912\AppData\Local\Continuum\anaconda3\lib\site-packages\spyder_kernels\customize\spydercustomize.py"", line 827, in runfile; execfile(filename, namespace). File ""C:\Users\605912\AppData\Local\Continuum\anaconda3\lib\site-packages\spyder_kernels\customize\spydercustomize.py"", line 110, in execfile; exec(compile(f.read(), filename, 'exec'), namespace). File ""C:/Users/605912/OneDrive - BOOZ ALLEN HAMILTON/DARPA/John Burke/Quantum apertures/calculations/floquet.py"", line 27, in <module>; f_modes_0, f_energies = floquet_modes(H, T, args). File ""C:\Users\605912\AppData\Local\Continuum\anaconda3\lib\site-packages\qutip\floquet.py"", line 102, in floquet_modes; U = propagator(H, T, [], args). File ""C:\Users\605912\AppData\Local\Continuum\anaconda3\lib\site-packages\qutip\propagator.py"", line 186, in propagator; _safe_mode=False). File ""C:\Users\605912\AppData\Local\Continuum\anaconda3\lib\site-packages\qutip\sesolve.py"", line 157, in sesolve; ss = _sesolve_QobjEvo(H, tlist, args, options). File ""C:\Users\605912\AppData\Local\Continuum\anaconda3\lib\site-packages\qutip\sesolve.py"", line 189, in _sesolve_QobjEvo; H_td.compile(omp=nthread). File ""C:\Users\605912\AppData\Local\Continuum\anaconda3\lib\site-packages\qutip\qobjevo.py"", line 1559, in compile; self.tlist). File ""C:\Users\605912\AppData\Local\Continuum\anaconda3\lib\site-packages\qutip\qobjevo_codegen.py"", line 124, in _compiled_coeffs; ""CompiledStrCoeff"", True). File ""C:\Users\605912\AppData\Local\Continuum\anaconda3\lib\site-packages\qutip\qobjevo_codegen.py"", line 82, in _import_str; ""tmpfile:"" + try_file + ext) from e. UnboundLocalError: local variable 'e' referenced before assignment; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1207
https://github.com/qutip/qutip/issues/1207:71,Usability,guid,guide,71,"I try to run the code for finding floquet energies from the qutip user guide. . ```python; import numpy as np; from qutip import *; import matplotlib.pyplot as plt. delta = 0.2 * 2*np.pi; eps0 = 1.0 * 2*np.pi; A = 2.5 * 2*np.pi; omega = 1.0 * 2*np.pi; H0 = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(); H1 = A/2.0 * sigmaz(); args = {'w': omega}; H = [H0, [H1, 'sin(w * t)']]; T = 2*pi / omega; f_modes_0, f_energies = floquet_modes(H, T, args); f_energies; ```. I got the following error . ```text; File ""<ipython-input-6-76f4206b44f0>"", line 1, in <module>; runfile('C:/Users/605912/OneDrive - BOOZ ALLEN HAMILTON/DARPA/John Burke/Quantum apertures/calculations/floquet.py', wdir='C:/Users/605912/OneDrive - BOOZ ALLEN HAMILTON/DARPA/John Burke/Quantum apertures/calculations'). File ""C:\Users\605912\AppData\Local\Continuum\anaconda3\lib\site-packages\spyder_kernels\customize\spydercustomize.py"", line 827, in runfile; execfile(filename, namespace). File ""C:\Users\605912\AppData\Local\Continuum\anaconda3\lib\site-packages\spyder_kernels\customize\spydercustomize.py"", line 110, in execfile; exec(compile(f.read(), filename, 'exec'), namespace). File ""C:/Users/605912/OneDrive - BOOZ ALLEN HAMILTON/DARPA/John Burke/Quantum apertures/calculations/floquet.py"", line 27, in <module>; f_modes_0, f_energies = floquet_modes(H, T, args). File ""C:\Users\605912\AppData\Local\Continuum\anaconda3\lib\site-packages\qutip\floquet.py"", line 102, in floquet_modes; U = propagator(H, T, [], args). File ""C:\Users\605912\AppData\Local\Continuum\anaconda3\lib\site-packages\qutip\propagator.py"", line 186, in propagator; _safe_mode=False). File ""C:\Users\605912\AppData\Local\Continuum\anaconda3\lib\site-packages\qutip\sesolve.py"", line 157, in sesolve; ss = _sesolve_QobjEvo(H, tlist, args, options). File ""C:\Users\605912\AppData\Local\Continuum\anaconda3\lib\site-packages\qutip\sesolve.py"", line 189, in _sesolve_QobjEvo; H_td.compile(omp=nthread). File ""C:\Users\605912\AppData\Local\Continuum\anaconda3\",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1207
https://github.com/qutip/qutip/issues/1208:123,Usability,guid,guide,123,"QuTiP `qip` module currently supports six different single-qubits gate, including rx, ry, yz, http://qutip.org/docs/latest/guide/guide-qip.html. However, the commonly used Pauli X, Y, Z gates, T gate and S gate are not there. Although in principle they can all be realized by the existing gate set. It would still be good to have them supported in `qutip.qip.QubitCircuit`. - Define those gates in `qutip.qip.operation`. If they already exist in `qutip.operators`, import them as functions such as `x_gate`, `y_gate`, `z_gate`, `s_gate`, `t_gate`; - Add the gates to `quip.qip.QubitCircuit`; - Add them also to the LaTeX code if applicable.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1208
https://github.com/qutip/qutip/issues/1208:129,Usability,guid,guide-qip,129,"QuTiP `qip` module currently supports six different single-qubits gate, including rx, ry, yz, http://qutip.org/docs/latest/guide/guide-qip.html. However, the commonly used Pauli X, Y, Z gates, T gate and S gate are not there. Although in principle they can all be realized by the existing gate set. It would still be good to have them supported in `qutip.qip.QubitCircuit`. - Define those gates in `qutip.qip.operation`. If they already exist in `qutip.operators`, import them as functions such as `x_gate`, `y_gate`, `z_gate`, `s_gate`, `t_gate`; - Add the gates to `quip.qip.QubitCircuit`; - Add them also to the LaTeX code if applicable.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1208
https://github.com/qutip/qutip/pull/1209:191,Testability,test,tested,191,"1. Gate T and S were defined at qutip.qip.operation. Since Pauli-X, Pauli-Y and Pauli-Z exist in qutip.operators, they were imported as functions into qutip.qip.operation. All functions were tested. ; 2. Each of the new gates was added to the circuit.py file. ; 3. Not apply.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1209
https://github.com/qutip/qutip/pull/1211:156,Testability,test,test,156,"In response to issue #1210 , added a quick fix for the add_1q_gates so that it now includes the ""end"" qubit (specified by the end argument). I also added a test in test_add_gates in test_qubitcircuit.py to cover this issue. The function now applies the 1 qubit gate to every qubit in [start, end] (0-indexed), start and end inclusive. This should resolve #1210",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1211
https://github.com/qutip/qutip/pull/1213:9,Modifiability,variab,variable,9,"Prefixes variable names with ```_``` to clear the Travis CI warnings, as mentioned in #1133. Before the changes, the ```travis lint``` output was:. ```; Warnings for .travis.yml:; [x] [warn] on root: deprecated key: stage_generic_linux (anchor on a non-private key); [x] [warn] on root: deprecated key: stage_linux_36 (anchor on a non-private key); [x] [warn] on root: deprecated key: stage_linux_37 (anchor on a non-private key); [x] [warn] on root: deprecated key: stage_linux_38 (anchor on a non-private key); [x] [warn] on root: deprecated key: stage_linux_37_no_cython (anchor on a non-private key); [x] [warn] on root: deprecated key: stage_linux_37_openblas (anchor on a non-private key); [x] [warn] on root: deprecated key: stage_linux_37_omp (anchor on a non-private key); [x] [warn] on root: deprecated key: stage_osx (anchor on a non-private key); ```. After the changes, it is:. ```; Hooray, .travis.yml looks valid :); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1213
https://github.com/qutip/qutip/pull/1213:40,Usability,clear,clear,40,"Prefixes variable names with ```_``` to clear the Travis CI warnings, as mentioned in #1133. Before the changes, the ```travis lint``` output was:. ```; Warnings for .travis.yml:; [x] [warn] on root: deprecated key: stage_generic_linux (anchor on a non-private key); [x] [warn] on root: deprecated key: stage_linux_36 (anchor on a non-private key); [x] [warn] on root: deprecated key: stage_linux_37 (anchor on a non-private key); [x] [warn] on root: deprecated key: stage_linux_38 (anchor on a non-private key); [x] [warn] on root: deprecated key: stage_linux_37_no_cython (anchor on a non-private key); [x] [warn] on root: deprecated key: stage_linux_37_openblas (anchor on a non-private key); [x] [warn] on root: deprecated key: stage_linux_37_omp (anchor on a non-private key); [x] [warn] on root: deprecated key: stage_osx (anchor on a non-private key); ```. After the changes, it is:. ```; Hooray, .travis.yml looks valid :); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1213
https://github.com/qutip/qutip/pull/1214:33,Testability,test,tests,33,"Moved the openmp, mkl, no cython tests to python 3.8; Also added (temporaly?) a mac test on python 3.8.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1214
https://github.com/qutip/qutip/pull/1214:84,Testability,test,test,84,"Moved the openmp, mkl, no cython tests to python 3.8; Also added (temporaly?) a mac test on python 3.8.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1214
https://github.com/qutip/qutip/pull/1215:84,Availability,error,error,84,"Update to the original 4.5.1 which is already a month old. New inclusions: . Better error message for failed string coefficient compilation.; Run the python 3.8 test in travis. (by Simon Cross ); Fix clebsch function for half-integer (by Thomas Walker); Deprecate graph function (by Jake Lishman); Fix travis warning (by Ivan Carvalho); Fix spin husimi/wigner functions (by maij). I would like the mac stuff to be fixed and moving the mac test to 3.8, but that will take some time.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1215
https://github.com/qutip/qutip/pull/1215:0,Deployability,Update,Update,0,"Update to the original 4.5.1 which is already a month old. New inclusions: . Better error message for failed string coefficient compilation.; Run the python 3.8 test in travis. (by Simon Cross ); Fix clebsch function for half-integer (by Thomas Walker); Deprecate graph function (by Jake Lishman); Fix travis warning (by Ivan Carvalho); Fix spin husimi/wigner functions (by maij). I would like the mac stuff to be fixed and moving the mac test to 3.8, but that will take some time.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1215
https://github.com/qutip/qutip/pull/1215:90,Integrability,message,message,90,"Update to the original 4.5.1 which is already a month old. New inclusions: . Better error message for failed string coefficient compilation.; Run the python 3.8 test in travis. (by Simon Cross ); Fix clebsch function for half-integer (by Thomas Walker); Deprecate graph function (by Jake Lishman); Fix travis warning (by Ivan Carvalho); Fix spin husimi/wigner functions (by maij). I would like the mac stuff to be fixed and moving the mac test to 3.8, but that will take some time.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1215
https://github.com/qutip/qutip/pull/1215:161,Testability,test,test,161,"Update to the original 4.5.1 which is already a month old. New inclusions: . Better error message for failed string coefficient compilation.; Run the python 3.8 test in travis. (by Simon Cross ); Fix clebsch function for half-integer (by Thomas Walker); Deprecate graph function (by Jake Lishman); Fix travis warning (by Ivan Carvalho); Fix spin husimi/wigner functions (by maij). I would like the mac stuff to be fixed and moving the mac test to 3.8, but that will take some time.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1215
https://github.com/qutip/qutip/pull/1215:439,Testability,test,test,439,"Update to the original 4.5.1 which is already a month old. New inclusions: . Better error message for failed string coefficient compilation.; Run the python 3.8 test in travis. (by Simon Cross ); Fix clebsch function for half-integer (by Thomas Walker); Deprecate graph function (by Jake Lishman); Fix travis warning (by Ivan Carvalho); Fix spin husimi/wigner functions (by maij). I would like the mac stuff to be fixed and moving the mac test to 3.8, but that will take some time.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1215
https://github.com/qutip/qutip/pull/1216:121,Deployability,update,update,121,closes #1106 . Adds update_view method to change view variable. Thus abstracting from attribute naming. Also forces view update in render.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1216
https://github.com/qutip/qutip/pull/1216:54,Modifiability,variab,variable,54,closes #1106 . Adds update_view method to change view variable. Thus abstracting from attribute naming. Also forces view update in render.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1216
https://github.com/qutip/qutip/issues/1217:19,Testability,test,test,19,"Travis only runs 5 test suite in parallel. Each tested commit have 6 to 8 test suite (add 3.8 and 3.8 for mac) and each test take 20 to 30min. So if many of us are working at the same time, automated test can take a few hours to run (like today).; I propose:; 1) Run the short suite for older python version (3.6 and 3.7), keeping the full test for only the latest for each os (linux + mac).; 2) For the specialised test (mkl, openmp, no cython) only run test affected by it. While this will probably not speed up for when only one PR is done, it should help when many are lined up. (2) could be done by adding new marks for the tests. @jakelishman, will this cause conflict with your unmerged PRs.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1217
https://github.com/qutip/qutip/issues/1217:48,Testability,test,tested,48,"Travis only runs 5 test suite in parallel. Each tested commit have 6 to 8 test suite (add 3.8 and 3.8 for mac) and each test take 20 to 30min. So if many of us are working at the same time, automated test can take a few hours to run (like today).; I propose:; 1) Run the short suite for older python version (3.6 and 3.7), keeping the full test for only the latest for each os (linux + mac).; 2) For the specialised test (mkl, openmp, no cython) only run test affected by it. While this will probably not speed up for when only one PR is done, it should help when many are lined up. (2) could be done by adding new marks for the tests. @jakelishman, will this cause conflict with your unmerged PRs.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1217
https://github.com/qutip/qutip/issues/1217:74,Testability,test,test,74,"Travis only runs 5 test suite in parallel. Each tested commit have 6 to 8 test suite (add 3.8 and 3.8 for mac) and each test take 20 to 30min. So if many of us are working at the same time, automated test can take a few hours to run (like today).; I propose:; 1) Run the short suite for older python version (3.6 and 3.7), keeping the full test for only the latest for each os (linux + mac).; 2) For the specialised test (mkl, openmp, no cython) only run test affected by it. While this will probably not speed up for when only one PR is done, it should help when many are lined up. (2) could be done by adding new marks for the tests. @jakelishman, will this cause conflict with your unmerged PRs.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1217
https://github.com/qutip/qutip/issues/1217:120,Testability,test,test,120,"Travis only runs 5 test suite in parallel. Each tested commit have 6 to 8 test suite (add 3.8 and 3.8 for mac) and each test take 20 to 30min. So if many of us are working at the same time, automated test can take a few hours to run (like today).; I propose:; 1) Run the short suite for older python version (3.6 and 3.7), keeping the full test for only the latest for each os (linux + mac).; 2) For the specialised test (mkl, openmp, no cython) only run test affected by it. While this will probably not speed up for when only one PR is done, it should help when many are lined up. (2) could be done by adding new marks for the tests. @jakelishman, will this cause conflict with your unmerged PRs.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1217
https://github.com/qutip/qutip/issues/1217:200,Testability,test,test,200,"Travis only runs 5 test suite in parallel. Each tested commit have 6 to 8 test suite (add 3.8 and 3.8 for mac) and each test take 20 to 30min. So if many of us are working at the same time, automated test can take a few hours to run (like today).; I propose:; 1) Run the short suite for older python version (3.6 and 3.7), keeping the full test for only the latest for each os (linux + mac).; 2) For the specialised test (mkl, openmp, no cython) only run test affected by it. While this will probably not speed up for when only one PR is done, it should help when many are lined up. (2) could be done by adding new marks for the tests. @jakelishman, will this cause conflict with your unmerged PRs.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1217
https://github.com/qutip/qutip/issues/1217:340,Testability,test,test,340,"Travis only runs 5 test suite in parallel. Each tested commit have 6 to 8 test suite (add 3.8 and 3.8 for mac) and each test take 20 to 30min. So if many of us are working at the same time, automated test can take a few hours to run (like today).; I propose:; 1) Run the short suite for older python version (3.6 and 3.7), keeping the full test for only the latest for each os (linux + mac).; 2) For the specialised test (mkl, openmp, no cython) only run test affected by it. While this will probably not speed up for when only one PR is done, it should help when many are lined up. (2) could be done by adding new marks for the tests. @jakelishman, will this cause conflict with your unmerged PRs.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1217
https://github.com/qutip/qutip/issues/1217:416,Testability,test,test,416,"Travis only runs 5 test suite in parallel. Each tested commit have 6 to 8 test suite (add 3.8 and 3.8 for mac) and each test take 20 to 30min. So if many of us are working at the same time, automated test can take a few hours to run (like today).; I propose:; 1) Run the short suite for older python version (3.6 and 3.7), keeping the full test for only the latest for each os (linux + mac).; 2) For the specialised test (mkl, openmp, no cython) only run test affected by it. While this will probably not speed up for when only one PR is done, it should help when many are lined up. (2) could be done by adding new marks for the tests. @jakelishman, will this cause conflict with your unmerged PRs.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1217
https://github.com/qutip/qutip/issues/1217:455,Testability,test,test,455,"Travis only runs 5 test suite in parallel. Each tested commit have 6 to 8 test suite (add 3.8 and 3.8 for mac) and each test take 20 to 30min. So if many of us are working at the same time, automated test can take a few hours to run (like today).; I propose:; 1) Run the short suite for older python version (3.6 and 3.7), keeping the full test for only the latest for each os (linux + mac).; 2) For the specialised test (mkl, openmp, no cython) only run test affected by it. While this will probably not speed up for when only one PR is done, it should help when many are lined up. (2) could be done by adding new marks for the tests. @jakelishman, will this cause conflict with your unmerged PRs.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1217
https://github.com/qutip/qutip/issues/1217:629,Testability,test,tests,629,"Travis only runs 5 test suite in parallel. Each tested commit have 6 to 8 test suite (add 3.8 and 3.8 for mac) and each test take 20 to 30min. So if many of us are working at the same time, automated test can take a few hours to run (like today).; I propose:; 1) Run the short suite for older python version (3.6 and 3.7), keeping the full test for only the latest for each os (linux + mac).; 2) For the specialised test (mkl, openmp, no cython) only run test affected by it. While this will probably not speed up for when only one PR is done, it should help when many are lined up. (2) could be done by adding new marks for the tests. @jakelishman, will this cause conflict with your unmerged PRs.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1217
https://github.com/qutip/qutip/pull/1218:58,Testability,test,test,58,Merged the PR about non-int clebsch wihtout waiting for a test. Add one here,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1218
https://github.com/qutip/qutip/pull/1220:38,Testability,test,tests,38,"**Description**; Add a suggestion for tests in the PR template. **Related issues or PRs**; Improve #1198 . **Changelog**; Add a suggestion for tests, documentation and notebook in the PR template.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1220
https://github.com/qutip/qutip/pull/1220:143,Testability,test,tests,143,"**Description**; Add a suggestion for tests in the PR template. **Related issues or PRs**; Improve #1198 . **Changelog**; Add a suggestion for tests, documentation and notebook in the PR template.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1220
https://github.com/qutip/qutip/issues/1222:36,Deployability,install,install,36,Is Python Headers a package? How to install? It is required for the following reason.; Python Headers 2.7+ Linux only. Needed for compiling Cython files; http://qutip.org/docs/latest/installation.html; Thanks~,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1222
https://github.com/qutip/qutip/issues/1222:183,Deployability,install,installation,183,Is Python Headers a package? How to install? It is required for the following reason.; Python Headers 2.7+ Linux only. Needed for compiling Cython files; http://qutip.org/docs/latest/installation.html; Thanks~,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1222
https://github.com/qutip/qutip/issues/1223:194,Availability,error,error,194,"Hello, ; when trying to run the examples from the User Guides in the Bloch-Redfield master equation section; ( http://qutip.org/docs/4.0.2/guide/dynamics/dynamics-bloch-redfield.html ) I get an error . I'm running the code in a conda environment using ipython on Windows 10, the details of the packages installed at the end of the post. To reproduce the error:; ```; import numpy as np; import matplotlib.pyplot as plt; from qutip import *. delta = 0.2 * 2*np.pi; eps0 = 1.0 * 2*np.pi; gamma1 = 0.5; H = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(); def ohmic_spectrum(w):; 	if w == 0.0: # dephasing inducing noise; 		return gamma1; 	else: # relaxation inducing noise; 		return gamma1 / 2 * (w / (2 * np.pi)) * (w > 0.0). R, ekets = bloch_redfield_tensor(H, [sigmax()], [ohmic_spectrum]). np.real(R.full()). tlist = np.linspace(0, 15.0, 1000). psi0 = rand_ket(2). e_ops = [sigmax(), sigmay(), sigmaz()]. expt_list = bloch_redfield_solve(R, ekets, psi0, tlist, e_ops). sphere = Bloch(). sphere.add_points([expt_list[0], expt_list[1], expt_list[2]]). sphere.vector_color = ['r']. sphere.add_vectors(np.array([delta, 0, eps0]) / np.sqrt(delta ** 2 + eps0 ** 2)). sphere.make_sphere(). plt.show(). output = brmesolve(H, psi0, tlist, [sigmax()], e_ops, [ohmic_spectrum]); ```. The code runs fine until the last line which gives the following response:; ```; ---------------------------------------------------------------------------; Exception Traceback (most recent call last); <ipython-input-1-79f7f2013969> in <module>; 35 plt.show(); 36; ---> 37 output = brmesolve(H, psi0, tlist, [sigmax()], e_ops, [ohmic_spectrum]). ~\Anaconda3\envs\qutip-env\lib\site-packages\qutip\bloch_redfield.py in brmesolve(H, psi0, tlist, a_ops, e_ops, c_ops, args, use_secular, sec_cutoff, tol, spectra_cb, options, progress_bar, _safe_mode, verbose); 196; 197 if _safe_mode:; --> 198 _solver_safety_check(H, psi0, a_ops+c_ops, e_ops, args); 199; 200 # check for type (if any) of time-dependent inputs. ~\Anaconda3\envs\qu",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1223
https://github.com/qutip/qutip/issues/1223:354,Availability,error,error,354,"Hello, ; when trying to run the examples from the User Guides in the Bloch-Redfield master equation section; ( http://qutip.org/docs/4.0.2/guide/dynamics/dynamics-bloch-redfield.html ) I get an error . I'm running the code in a conda environment using ipython on Windows 10, the details of the packages installed at the end of the post. To reproduce the error:; ```; import numpy as np; import matplotlib.pyplot as plt; from qutip import *. delta = 0.2 * 2*np.pi; eps0 = 1.0 * 2*np.pi; gamma1 = 0.5; H = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(); def ohmic_spectrum(w):; 	if w == 0.0: # dephasing inducing noise; 		return gamma1; 	else: # relaxation inducing noise; 		return gamma1 / 2 * (w / (2 * np.pi)) * (w > 0.0). R, ekets = bloch_redfield_tensor(H, [sigmax()], [ohmic_spectrum]). np.real(R.full()). tlist = np.linspace(0, 15.0, 1000). psi0 = rand_ket(2). e_ops = [sigmax(), sigmay(), sigmaz()]. expt_list = bloch_redfield_solve(R, ekets, psi0, tlist, e_ops). sphere = Bloch(). sphere.add_points([expt_list[0], expt_list[1], expt_list[2]]). sphere.vector_color = ['r']. sphere.add_vectors(np.array([delta, 0, eps0]) / np.sqrt(delta ** 2 + eps0 ** 2)). sphere.make_sphere(). plt.show(). output = brmesolve(H, psi0, tlist, [sigmax()], e_ops, [ohmic_spectrum]); ```. The code runs fine until the last line which gives the following response:; ```; ---------------------------------------------------------------------------; Exception Traceback (most recent call last); <ipython-input-1-79f7f2013969> in <module>; 35 plt.show(); 36; ---> 37 output = brmesolve(H, psi0, tlist, [sigmax()], e_ops, [ohmic_spectrum]). ~\Anaconda3\envs\qutip-env\lib\site-packages\qutip\bloch_redfield.py in brmesolve(H, psi0, tlist, a_ops, e_ops, c_ops, args, use_secular, sec_cutoff, tol, spectra_cb, options, progress_bar, _safe_mode, verbose); 196; 197 if _safe_mode:; --> 198 _solver_safety_check(H, psi0, a_ops+c_ops, e_ops, args); 199; 200 # check for type (if any) of time-dependent inputs. ~\Anaconda3\envs\qu",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1223
https://github.com/qutip/qutip/issues/1223:2776,Availability,error,errors,2776,"um]). np.real(R.full()). tlist = np.linspace(0, 15.0, 1000). psi0 = rand_ket(2). e_ops = [sigmax(), sigmay(), sigmaz()]. expt_list = bloch_redfield_solve(R, ekets, psi0, tlist, e_ops). sphere = Bloch(). sphere.add_points([expt_list[0], expt_list[1], expt_list[2]]). sphere.vector_color = ['r']. sphere.add_vectors(np.array([delta, 0, eps0]) / np.sqrt(delta ** 2 + eps0 ** 2)). sphere.make_sphere(). plt.show(). output = brmesolve(H, psi0, tlist, [sigmax()], e_ops, [ohmic_spectrum]); ```. The code runs fine until the last line which gives the following response:; ```; ---------------------------------------------------------------------------; Exception Traceback (most recent call last); <ipython-input-1-79f7f2013969> in <module>; 35 plt.show(); 36; ---> 37 output = brmesolve(H, psi0, tlist, [sigmax()], e_ops, [ohmic_spectrum]). ~\Anaconda3\envs\qutip-env\lib\site-packages\qutip\bloch_redfield.py in brmesolve(H, psi0, tlist, a_ops, e_ops, c_ops, args, use_secular, sec_cutoff, tol, spectra_cb, options, progress_bar, _safe_mode, verbose); 196; 197 if _safe_mode:; --> 198 _solver_safety_check(H, psi0, a_ops+c_ops, e_ops, args); 199; 200 # check for type (if any) of time-dependent inputs. ~\Anaconda3\envs\qutip-env\lib\site-packages\qutip\solver.py in _solver_safety_check(H, state, c_ops, e_ops, args); 945 _structure_check(Hdims, Htype, _temp_state); 946 else:; --> 947 raise Exception('Invalid td-list element.'); 948 if do_tests:; 949 _structure_check(Hdims, Htype, _temp_state). Exception: Invalid td-list element.; ```. Output of version_table(); ```; Software	Version; QuTiP	4.5.0; Numpy	1.18.1; SciPy	1.4.1; matplotlib	3.1.3; Cython	0.29.15; Number of CPUs	4; BLAS Info	INTEL MKL; IPython	7.13.0; Python	3.8.1 (default, Mar 2 2020, 13:06:26) [MSC v.1916 64 bit (AMD64)]; OS	nt [win32]; Sun Mar 29 21:11:12 2020 GMT Daylight Time; ```. Other examples (like this one https://nbviewer.jupyter.org/github/qutip/qutip-notebooks/blob/master/examples/brmesolve.ipynb ) run without errors.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1223
https://github.com/qutip/qutip/issues/1223:303,Deployability,install,installed,303,"Hello, ; when trying to run the examples from the User Guides in the Bloch-Redfield master equation section; ( http://qutip.org/docs/4.0.2/guide/dynamics/dynamics-bloch-redfield.html ) I get an error . I'm running the code in a conda environment using ipython on Windows 10, the details of the packages installed at the end of the post. To reproduce the error:; ```; import numpy as np; import matplotlib.pyplot as plt; from qutip import *. delta = 0.2 * 2*np.pi; eps0 = 1.0 * 2*np.pi; gamma1 = 0.5; H = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(); def ohmic_spectrum(w):; 	if w == 0.0: # dephasing inducing noise; 		return gamma1; 	else: # relaxation inducing noise; 		return gamma1 / 2 * (w / (2 * np.pi)) * (w > 0.0). R, ekets = bloch_redfield_tensor(H, [sigmax()], [ohmic_spectrum]). np.real(R.full()). tlist = np.linspace(0, 15.0, 1000). psi0 = rand_ket(2). e_ops = [sigmax(), sigmay(), sigmaz()]. expt_list = bloch_redfield_solve(R, ekets, psi0, tlist, e_ops). sphere = Bloch(). sphere.add_points([expt_list[0], expt_list[1], expt_list[2]]). sphere.vector_color = ['r']. sphere.add_vectors(np.array([delta, 0, eps0]) / np.sqrt(delta ** 2 + eps0 ** 2)). sphere.make_sphere(). plt.show(). output = brmesolve(H, psi0, tlist, [sigmax()], e_ops, [ohmic_spectrum]); ```. The code runs fine until the last line which gives the following response:; ```; ---------------------------------------------------------------------------; Exception Traceback (most recent call last); <ipython-input-1-79f7f2013969> in <module>; 35 plt.show(); 36; ---> 37 output = brmesolve(H, psi0, tlist, [sigmax()], e_ops, [ohmic_spectrum]). ~\Anaconda3\envs\qutip-env\lib\site-packages\qutip\bloch_redfield.py in brmesolve(H, psi0, tlist, a_ops, e_ops, c_ops, args, use_secular, sec_cutoff, tol, spectra_cb, options, progress_bar, _safe_mode, verbose); 196; 197 if _safe_mode:; --> 198 _solver_safety_check(H, psi0, a_ops+c_ops, e_ops, args); 199; 200 # check for type (if any) of time-dependent inputs. ~\Anaconda3\envs\qu",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1223
https://github.com/qutip/qutip/issues/1223:1964,Integrability,depend,dependent,1964,"um]). np.real(R.full()). tlist = np.linspace(0, 15.0, 1000). psi0 = rand_ket(2). e_ops = [sigmax(), sigmay(), sigmaz()]. expt_list = bloch_redfield_solve(R, ekets, psi0, tlist, e_ops). sphere = Bloch(). sphere.add_points([expt_list[0], expt_list[1], expt_list[2]]). sphere.vector_color = ['r']. sphere.add_vectors(np.array([delta, 0, eps0]) / np.sqrt(delta ** 2 + eps0 ** 2)). sphere.make_sphere(). plt.show(). output = brmesolve(H, psi0, tlist, [sigmax()], e_ops, [ohmic_spectrum]); ```. The code runs fine until the last line which gives the following response:; ```; ---------------------------------------------------------------------------; Exception Traceback (most recent call last); <ipython-input-1-79f7f2013969> in <module>; 35 plt.show(); 36; ---> 37 output = brmesolve(H, psi0, tlist, [sigmax()], e_ops, [ohmic_spectrum]). ~\Anaconda3\envs\qutip-env\lib\site-packages\qutip\bloch_redfield.py in brmesolve(H, psi0, tlist, a_ops, e_ops, c_ops, args, use_secular, sec_cutoff, tol, spectra_cb, options, progress_bar, _safe_mode, verbose); 196; 197 if _safe_mode:; --> 198 _solver_safety_check(H, psi0, a_ops+c_ops, e_ops, args); 199; 200 # check for type (if any) of time-dependent inputs. ~\Anaconda3\envs\qutip-env\lib\site-packages\qutip\solver.py in _solver_safety_check(H, state, c_ops, e_ops, args); 945 _structure_check(Hdims, Htype, _temp_state); 946 else:; --> 947 raise Exception('Invalid td-list element.'); 948 if do_tests:; 949 _structure_check(Hdims, Htype, _temp_state). Exception: Invalid td-list element.; ```. Output of version_table(); ```; Software	Version; QuTiP	4.5.0; Numpy	1.18.1; SciPy	1.4.1; matplotlib	3.1.3; Cython	0.29.15; Number of CPUs	4; BLAS Info	INTEL MKL; IPython	7.13.0; Python	3.8.1 (default, Mar 2 2020, 13:06:26) [MSC v.1916 64 bit (AMD64)]; OS	nt [win32]; Sun Mar 29 21:11:12 2020 GMT Daylight Time; ```. Other examples (like this one https://nbviewer.jupyter.org/github/qutip/qutip-notebooks/blob/master/examples/brmesolve.ipynb ) run without errors.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1223
https://github.com/qutip/qutip/issues/1223:55,Usability,Guid,Guides,55,"Hello, ; when trying to run the examples from the User Guides in the Bloch-Redfield master equation section; ( http://qutip.org/docs/4.0.2/guide/dynamics/dynamics-bloch-redfield.html ) I get an error . I'm running the code in a conda environment using ipython on Windows 10, the details of the packages installed at the end of the post. To reproduce the error:; ```; import numpy as np; import matplotlib.pyplot as plt; from qutip import *. delta = 0.2 * 2*np.pi; eps0 = 1.0 * 2*np.pi; gamma1 = 0.5; H = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(); def ohmic_spectrum(w):; 	if w == 0.0: # dephasing inducing noise; 		return gamma1; 	else: # relaxation inducing noise; 		return gamma1 / 2 * (w / (2 * np.pi)) * (w > 0.0). R, ekets = bloch_redfield_tensor(H, [sigmax()], [ohmic_spectrum]). np.real(R.full()). tlist = np.linspace(0, 15.0, 1000). psi0 = rand_ket(2). e_ops = [sigmax(), sigmay(), sigmaz()]. expt_list = bloch_redfield_solve(R, ekets, psi0, tlist, e_ops). sphere = Bloch(). sphere.add_points([expt_list[0], expt_list[1], expt_list[2]]). sphere.vector_color = ['r']. sphere.add_vectors(np.array([delta, 0, eps0]) / np.sqrt(delta ** 2 + eps0 ** 2)). sphere.make_sphere(). plt.show(). output = brmesolve(H, psi0, tlist, [sigmax()], e_ops, [ohmic_spectrum]); ```. The code runs fine until the last line which gives the following response:; ```; ---------------------------------------------------------------------------; Exception Traceback (most recent call last); <ipython-input-1-79f7f2013969> in <module>; 35 plt.show(); 36; ---> 37 output = brmesolve(H, psi0, tlist, [sigmax()], e_ops, [ohmic_spectrum]). ~\Anaconda3\envs\qutip-env\lib\site-packages\qutip\bloch_redfield.py in brmesolve(H, psi0, tlist, a_ops, e_ops, c_ops, args, use_secular, sec_cutoff, tol, spectra_cb, options, progress_bar, _safe_mode, verbose); 196; 197 if _safe_mode:; --> 198 _solver_safety_check(H, psi0, a_ops+c_ops, e_ops, args); 199; 200 # check for type (if any) of time-dependent inputs. ~\Anaconda3\envs\qu",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1223
https://github.com/qutip/qutip/issues/1223:139,Usability,guid,guide,139,"Hello, ; when trying to run the examples from the User Guides in the Bloch-Redfield master equation section; ( http://qutip.org/docs/4.0.2/guide/dynamics/dynamics-bloch-redfield.html ) I get an error . I'm running the code in a conda environment using ipython on Windows 10, the details of the packages installed at the end of the post. To reproduce the error:; ```; import numpy as np; import matplotlib.pyplot as plt; from qutip import *. delta = 0.2 * 2*np.pi; eps0 = 1.0 * 2*np.pi; gamma1 = 0.5; H = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(); def ohmic_spectrum(w):; 	if w == 0.0: # dephasing inducing noise; 		return gamma1; 	else: # relaxation inducing noise; 		return gamma1 / 2 * (w / (2 * np.pi)) * (w > 0.0). R, ekets = bloch_redfield_tensor(H, [sigmax()], [ohmic_spectrum]). np.real(R.full()). tlist = np.linspace(0, 15.0, 1000). psi0 = rand_ket(2). e_ops = [sigmax(), sigmay(), sigmaz()]. expt_list = bloch_redfield_solve(R, ekets, psi0, tlist, e_ops). sphere = Bloch(). sphere.add_points([expt_list[0], expt_list[1], expt_list[2]]). sphere.vector_color = ['r']. sphere.add_vectors(np.array([delta, 0, eps0]) / np.sqrt(delta ** 2 + eps0 ** 2)). sphere.make_sphere(). plt.show(). output = brmesolve(H, psi0, tlist, [sigmax()], e_ops, [ohmic_spectrum]); ```. The code runs fine until the last line which gives the following response:; ```; ---------------------------------------------------------------------------; Exception Traceback (most recent call last); <ipython-input-1-79f7f2013969> in <module>; 35 plt.show(); 36; ---> 37 output = brmesolve(H, psi0, tlist, [sigmax()], e_ops, [ohmic_spectrum]). ~\Anaconda3\envs\qutip-env\lib\site-packages\qutip\bloch_redfield.py in brmesolve(H, psi0, tlist, a_ops, e_ops, c_ops, args, use_secular, sec_cutoff, tol, spectra_cb, options, progress_bar, _safe_mode, verbose); 196; 197 if _safe_mode:; --> 198 _solver_safety_check(H, psi0, a_ops+c_ops, e_ops, args); 199; 200 # check for type (if any) of time-dependent inputs. ~\Anaconda3\envs\qu",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1223
https://github.com/qutip/qutip/pull/1224:375,Testability,test,tests,375,**Description**; - Added controlled version of the single-qubit gates; - Added controlled single-qubit gates to Qubit.Qip.Circuit.resolve_gates(); - Added controlled single-qubit gates to Qubit.Qip.Circuit.propagator(); - Added controlled single-qubit gates to Qubit.Qip.Circuit.latex_code(); - Added controlled single-qubit gates to Qubit.Qip.Circuit.add_1q_gate(); - Added tests for controlled single-qubit gates in Qubit.Qip.Operations.Gates and Qubit.Qip.Circuit. **Related issues or PRs**; fixes #1225 . **Changelog**; The controlled version of the single-qubit gates and tests,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1224
https://github.com/qutip/qutip/pull/1224:577,Testability,test,tests,577,**Description**; - Added controlled version of the single-qubit gates; - Added controlled single-qubit gates to Qubit.Qip.Circuit.resolve_gates(); - Added controlled single-qubit gates to Qubit.Qip.Circuit.propagator(); - Added controlled single-qubit gates to Qubit.Qip.Circuit.latex_code(); - Added controlled single-qubit gates to Qubit.Qip.Circuit.add_1q_gate(); - Added tests for controlled single-qubit gates in Qubit.Qip.Operations.Gates and Qubit.Qip.Circuit. **Related issues or PRs**; fixes #1225 . **Changelog**; The controlled version of the single-qubit gates and tests,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1224
https://github.com/qutip/qutip/issues/1225:164,Testability,Test,Tests,164,Include the improvements made on #1208. These changes base from #1209 and #1212: ; - The controlled version of the gates; - Changes in QubitCircuit.propagator(); - Tests,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1225
https://github.com/qutip/qutip/pull/1226:200,Availability,mainten,maintenance,200,**Description**; Refactor Qutip.Qip.Circuit.solve_gates as a dispatch-like method for assigning different functions and make the QubitCircuit module more commutable.; These changes make it easier for maintenance and provide a clearer workflow. **Changelog**; Refactor Qutip.Qip.Circuit.solve_gates,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1226
https://github.com/qutip/qutip/pull/1226:17,Modifiability,Refactor,Refactor,17,**Description**; Refactor Qutip.Qip.Circuit.solve_gates as a dispatch-like method for assigning different functions and make the QubitCircuit module more commutable.; These changes make it easier for maintenance and provide a clearer workflow. **Changelog**; Refactor Qutip.Qip.Circuit.solve_gates,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1226
https://github.com/qutip/qutip/pull/1226:259,Modifiability,Refactor,Refactor,259,**Description**; Refactor Qutip.Qip.Circuit.solve_gates as a dispatch-like method for assigning different functions and make the QubitCircuit module more commutable.; These changes make it easier for maintenance and provide a clearer workflow. **Changelog**; Refactor Qutip.Qip.Circuit.solve_gates,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1226
https://github.com/qutip/qutip/pull/1226:226,Usability,clear,clearer,226,**Description**; Refactor Qutip.Qip.Circuit.solve_gates as a dispatch-like method for assigning different functions and make the QubitCircuit module more commutable.; These changes make it easier for maintenance and provide a clearer workflow. **Changelog**; Refactor Qutip.Qip.Circuit.solve_gates,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1226
https://github.com/qutip/qutip/pull/1228:15,Deployability,Update,Update,15,**Changelog**; Update readme adding Boxi Li to authors and badges of NumFOUCS and Unitary Fund.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1228
https://github.com/qutip/qutip/issues/1229:39,Modifiability,Enhance,EnhancedTextProgressBar,39,"**Describe the issue**; I am using the EnhancedTextProgressBar to track progress of an mesolve calculation in a jupyter notebook. Sometimes it works as expected; occasionally (it doesn't seem to be deterministic), I get an extra progress after the updating progress bar that does not delete, so that when the mesolve is complete, I see this: ; > [Total run time: 2.55s] Elapsed 2.55s / Remaining 00:00:00:00[*********70%**** ] Elapsed 1.79s / Remaining 00:00:00:00. Instead of just ; > [Total run time: 2.55s] Elapsed 2.55s / Remaining 00:00:00:00. If I run the same thing repeatedly, sometimes I'll get the extra status (at different elapsed times), sometimes I'll get two extras, sometimes I'll get none. The longer the calculation takes, the more likely it is that I'll get one or more of these, it seems. . This is not a super huge problem, but just curious if there's any way to fix it! . Thanks,; Emma",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1229
https://github.com/qutip/qutip/issues/1229:257,Usability,progress bar,progress bar,257,"**Describe the issue**; I am using the EnhancedTextProgressBar to track progress of an mesolve calculation in a jupyter notebook. Sometimes it works as expected; occasionally (it doesn't seem to be deterministic), I get an extra progress after the updating progress bar that does not delete, so that when the mesolve is complete, I see this: ; > [Total run time: 2.55s] Elapsed 2.55s / Remaining 00:00:00:00[*********70%**** ] Elapsed 1.79s / Remaining 00:00:00:00. Instead of just ; > [Total run time: 2.55s] Elapsed 2.55s / Remaining 00:00:00:00. If I run the same thing repeatedly, sometimes I'll get the extra status (at different elapsed times), sometimes I'll get two extras, sometimes I'll get none. The longer the calculation takes, the more likely it is that I'll get one or more of these, it seems. . This is not a super huge problem, but just curious if there's any way to fix it! . Thanks,; Emma",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1229
https://github.com/qutip/qutip/issues/1230:140,Availability,error,error,140,"I am installing on Mac OS Catalina using the following command:. python setup.py develop --with-openmp. However, I am getting the following error:. clang: error: unsupported option '-fopenmp'; error: command 'g++' failed with exit status 1. could you please elaborate?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1230
https://github.com/qutip/qutip/issues/1230:155,Availability,error,error,155,"I am installing on Mac OS Catalina using the following command:. python setup.py develop --with-openmp. However, I am getting the following error:. clang: error: unsupported option '-fopenmp'; error: command 'g++' failed with exit status 1. could you please elaborate?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1230
https://github.com/qutip/qutip/issues/1230:193,Availability,error,error,193,"I am installing on Mac OS Catalina using the following command:. python setup.py develop --with-openmp. However, I am getting the following error:. clang: error: unsupported option '-fopenmp'; error: command 'g++' failed with exit status 1. could you please elaborate?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1230
https://github.com/qutip/qutip/issues/1230:5,Deployability,install,installing,5,"I am installing on Mac OS Catalina using the following command:. python setup.py develop --with-openmp. However, I am getting the following error:. clang: error: unsupported option '-fopenmp'; error: command 'g++' failed with exit status 1. could you please elaborate?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1230
https://github.com/qutip/qutip/pull/1231:332,Availability,avail,available,332,"**Description**; There are presently 8 variations of `CQobjEvo`. There are `Cte` and `Td` variants, Dense and csr sparse and serial vs openmp versions. Adding a feature, (ex. AHS support) result in the need to modify all of them and QobjEvoFunc and AHS PRs will add new one. So as a first step, I am merging them the ones presently available.; Cte (no coefficient) are now limit case of Td (time-dependant). omp ones have been removed in favor of a `spmvpy` variant that switch between the serial and omp version at compilation. . Also reworked the compilation of `QobjEvo`:; - Simpler with only 3 variants instead of 8.; - Compilation of the coefficient and object are separated. (`H *= -1j` does not force recompiling the coefficients.); - But have the side effect of making temp file cleanup harder. File are erased at python close instead of object deletion.; - Moved the location of temp file to ~/.qutip/temp for now, but does this work on windows?; - Auto-cleanup on importing qutip, for files older than 7 days for now. But should be set by user, the temp file location also. Other to-do:; Dense versions of CQobjEvo could be more optimized and is not parallel. One option would be to use blas and hope the user's blas is parallel. (probably other PR). ps. Running tests for now. Do not merge.; **Changelog**; Cleaned CObjEvo",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1231
https://github.com/qutip/qutip/pull/1231:396,Integrability,depend,dependant,396,"**Description**; There are presently 8 variations of `CQobjEvo`. There are `Cte` and `Td` variants, Dense and csr sparse and serial vs openmp versions. Adding a feature, (ex. AHS support) result in the need to modify all of them and QobjEvoFunc and AHS PRs will add new one. So as a first step, I am merging them the ones presently available.; Cte (no coefficient) are now limit case of Td (time-dependant). omp ones have been removed in favor of a `spmvpy` variant that switch between the serial and omp version at compilation. . Also reworked the compilation of `QobjEvo`:; - Simpler with only 3 variants instead of 8.; - Compilation of the coefficient and object are separated. (`H *= -1j` does not force recompiling the coefficients.); - But have the side effect of making temp file cleanup harder. File are erased at python close instead of object deletion.; - Moved the location of temp file to ~/.qutip/temp for now, but does this work on windows?; - Auto-cleanup on importing qutip, for files older than 7 days for now. But should be set by user, the temp file location also. Other to-do:; Dense versions of CQobjEvo could be more optimized and is not parallel. One option would be to use blas and hope the user's blas is parallel. (probably other PR). ps. Running tests for now. Do not merge.; **Changelog**; Cleaned CObjEvo",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1231
https://github.com/qutip/qutip/pull/1231:1139,Performance,optimiz,optimized,1139,"**Description**; There are presently 8 variations of `CQobjEvo`. There are `Cte` and `Td` variants, Dense and csr sparse and serial vs openmp versions. Adding a feature, (ex. AHS support) result in the need to modify all of them and QobjEvoFunc and AHS PRs will add new one. So as a first step, I am merging them the ones presently available.; Cte (no coefficient) are now limit case of Td (time-dependant). omp ones have been removed in favor of a `spmvpy` variant that switch between the serial and omp version at compilation. . Also reworked the compilation of `QobjEvo`:; - Simpler with only 3 variants instead of 8.; - Compilation of the coefficient and object are separated. (`H *= -1j` does not force recompiling the coefficients.); - But have the side effect of making temp file cleanup harder. File are erased at python close instead of object deletion.; - Moved the location of temp file to ~/.qutip/temp for now, but does this work on windows?; - Auto-cleanup on importing qutip, for files older than 7 days for now. But should be set by user, the temp file location also. Other to-do:; Dense versions of CQobjEvo could be more optimized and is not parallel. One option would be to use blas and hope the user's blas is parallel. (probably other PR). ps. Running tests for now. Do not merge.; **Changelog**; Cleaned CObjEvo",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1231
https://github.com/qutip/qutip/pull/1231:1273,Testability,test,tests,1273,"**Description**; There are presently 8 variations of `CQobjEvo`. There are `Cte` and `Td` variants, Dense and csr sparse and serial vs openmp versions. Adding a feature, (ex. AHS support) result in the need to modify all of them and QobjEvoFunc and AHS PRs will add new one. So as a first step, I am merging them the ones presently available.; Cte (no coefficient) are now limit case of Td (time-dependant). omp ones have been removed in favor of a `spmvpy` variant that switch between the serial and omp version at compilation. . Also reworked the compilation of `QobjEvo`:; - Simpler with only 3 variants instead of 8.; - Compilation of the coefficient and object are separated. (`H *= -1j` does not force recompiling the coefficients.); - But have the side effect of making temp file cleanup harder. File are erased at python close instead of object deletion.; - Moved the location of temp file to ~/.qutip/temp for now, but does this work on windows?; - Auto-cleanup on importing qutip, for files older than 7 days for now. But should be set by user, the temp file location also. Other to-do:; Dense versions of CQobjEvo could be more optimized and is not parallel. One option would be to use blas and hope the user's blas is parallel. (probably other PR). ps. Running tests for now. Do not merge.; **Changelog**; Cleaned CObjEvo",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1231
https://github.com/qutip/qutip/pull/1231:578,Usability,Simpl,Simpler,578,"**Description**; There are presently 8 variations of `CQobjEvo`. There are `Cte` and `Td` variants, Dense and csr sparse and serial vs openmp versions. Adding a feature, (ex. AHS support) result in the need to modify all of them and QobjEvoFunc and AHS PRs will add new one. So as a first step, I am merging them the ones presently available.; Cte (no coefficient) are now limit case of Td (time-dependant). omp ones have been removed in favor of a `spmvpy` variant that switch between the serial and omp version at compilation. . Also reworked the compilation of `QobjEvo`:; - Simpler with only 3 variants instead of 8.; - Compilation of the coefficient and object are separated. (`H *= -1j` does not force recompiling the coefficients.); - But have the side effect of making temp file cleanup harder. File are erased at python close instead of object deletion.; - Moved the location of temp file to ~/.qutip/temp for now, but does this work on windows?; - Auto-cleanup on importing qutip, for files older than 7 days for now. But should be set by user, the temp file location also. Other to-do:; Dense versions of CQobjEvo could be more optimized and is not parallel. One option would be to use blas and hope the user's blas is parallel. (probably other PR). ps. Running tests for now. Do not merge.; **Changelog**; Cleaned CObjEvo",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1231
https://github.com/qutip/qutip/pull/1232:249,Availability,error,error,249,"**Description**; The `purity` method in `qobj` is supposed to give purity no more than 1. However, at the moment, it can give values greater than 1 as well because it does not verify if `Qobj` is a valid quantum state. Minimal code to reproduce the error would be: . ```; not_dm = Qobj(np.random.rand(5,5)); not_dm.purity(); ```; To solve this, I have modified `purity()` primarily by adding `check_isdensity()` (with accompanying test method in `tests`) . **Changelog** ; Added density matrix check for purity calculation",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1232
https://github.com/qutip/qutip/pull/1232:431,Testability,test,test,431,"**Description**; The `purity` method in `qobj` is supposed to give purity no more than 1. However, at the moment, it can give values greater than 1 as well because it does not verify if `Qobj` is a valid quantum state. Minimal code to reproduce the error would be: . ```; not_dm = Qobj(np.random.rand(5,5)); not_dm.purity(); ```; To solve this, I have modified `purity()` primarily by adding `check_isdensity()` (with accompanying test method in `tests`) . **Changelog** ; Added density matrix check for purity calculation",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1232
https://github.com/qutip/qutip/pull/1232:447,Testability,test,tests,447,"**Description**; The `purity` method in `qobj` is supposed to give purity no more than 1. However, at the moment, it can give values greater than 1 as well because it does not verify if `Qobj` is a valid quantum state. Minimal code to reproduce the error would be: . ```; not_dm = Qobj(np.random.rand(5,5)); not_dm.purity(); ```; To solve this, I have modified `purity()` primarily by adding `check_isdensity()` (with accompanying test method in `tests`) . **Changelog** ; Added density matrix check for purity calculation",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1232
https://github.com/qutip/qutip/issues/1234:805,Deployability,install,installation,805,"@ajgpitch @jakelishman,; Moving the discussion we had last week here. #### The `Options` object.; It contains the options used by the solvers:; - Scipy's solver options (`atol`, `method`, ...); - Output (`store_states`, `average_states`, ...); - To deprecate (`rhs_reuse`, `ntraj`, ...). But making the solver objects, I added new base solver (`solve_ivp`, `dop853`) which require new options. Eventually, using `dense` vs `sparse` matrix should also be added somewhere.; So I have a few issues about it:; 1. Increasing number of options being confusing.; 2. Some options are no longer used, or used only in specific solver. `seeds` is used by mcsolve, but the stochastic solver use a `noise` keyword arguments, not the options' value.; 3. No way to change the default. #### `qutip.settings`; It has some installation settings: `has_mkl`, `has_openmp` and some Qobj options, `auto_herm`, `auto_tidyup_atol`.; I am adding a new value: `path`, which set the path to where the compiled string code are saved. Here also there is no easy way to change the default. If it was possible, I would have the default matrix data type set here. #### `qutiprc`; File saved in the users home ""~/.qutip/qutiprc"". If qutip is installed with openmp, it contains the matrix size over which it is worth to use the openmp version of spmv.; Under used. I would propose:; - A function in settings that save a new default to qutiprc.; - Something similar for options.; - Splitting the options object into a few ones: output options, solver options, mcsolver options?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1234
https://github.com/qutip/qutip/issues/1234:1209,Deployability,install,installed,1209,"@ajgpitch @jakelishman,; Moving the discussion we had last week here. #### The `Options` object.; It contains the options used by the solvers:; - Scipy's solver options (`atol`, `method`, ...); - Output (`store_states`, `average_states`, ...); - To deprecate (`rhs_reuse`, `ntraj`, ...). But making the solver objects, I added new base solver (`solve_ivp`, `dop853`) which require new options. Eventually, using `dense` vs `sparse` matrix should also be added somewhere.; So I have a few issues about it:; 1. Increasing number of options being confusing.; 2. Some options are no longer used, or used only in specific solver. `seeds` is used by mcsolve, but the stochastic solver use a `noise` keyword arguments, not the options' value.; 3. No way to change the default. #### `qutip.settings`; It has some installation settings: `has_mkl`, `has_openmp` and some Qobj options, `auto_herm`, `auto_tidyup_atol`.; I am adding a new value: `path`, which set the path to where the compiled string code are saved. Here also there is no easy way to change the default. If it was possible, I would have the default matrix data type set here. #### `qutiprc`; File saved in the users home ""~/.qutip/qutiprc"". If qutip is installed with openmp, it contains the matrix size over which it is worth to use the openmp version of spmv.; Under used. I would propose:; - A function in settings that save a new default to qutiprc.; - Something similar for options.; - Splitting the options object into a few ones: output options, solver options, mcsolver options?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1234
https://github.com/qutip/qutip/issues/1236:113,Energy Efficiency,power,powerful,113,"I propose opening a discussion on migrating from Travis CI to Github Actions workflow. It is a quite general and powerful framework, that allows to specify many [trigger events](https://help.github.com/en/actions/configuring-and-managing-workflows/configuring-a-workflow) and actions. . I have no intention of taking any action, but I think it may be a good thing to discuss. Happy to hear pros and cons.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1236
https://github.com/qutip/qutip/issues/1236:213,Modifiability,config,configuring-and-managing-workflows,213,"I propose opening a discussion on migrating from Travis CI to Github Actions workflow. It is a quite general and powerful framework, that allows to specify many [trigger events](https://help.github.com/en/actions/configuring-and-managing-workflows/configuring-a-workflow) and actions. . I have no intention of taking any action, but I think it may be a good thing to discuss. Happy to hear pros and cons.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1236
https://github.com/qutip/qutip/issues/1236:248,Modifiability,config,configuring-a-workflow,248,"I propose opening a discussion on migrating from Travis CI to Github Actions workflow. It is a quite general and powerful framework, that allows to specify many [trigger events](https://help.github.com/en/actions/configuring-and-managing-workflows/configuring-a-workflow) and actions. . I have no intention of taking any action, but I think it may be a good thing to discuss. Happy to hear pros and cons.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1236
https://github.com/qutip/qutip/pull/1237:30,Availability,error,error,30,**Description**; There was an error in line 613 of qutip/stochastic.py as the measurement operators for heterodyne detection in the implemented stochastic master equation should be `c + c.dag()` and `1j (c - c.dag())` as explicitely presented in equation (5.64) and the following 2 paragraphs in https://arxiv.org/abs/1710.09523. The same measurement operators can also be drawn from equation (4.108) of Milburn & Wiseman _Quantum Measurement and Control_. **Changelog**; Fixed error in m_ops definition for heterodyne detection in smesolve.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1237
https://github.com/qutip/qutip/pull/1237:478,Availability,error,error,478,**Description**; There was an error in line 613 of qutip/stochastic.py as the measurement operators for heterodyne detection in the implemented stochastic master equation should be `c + c.dag()` and `1j (c - c.dag())` as explicitely presented in equation (5.64) and the following 2 paragraphs in https://arxiv.org/abs/1710.09523. The same measurement operators can also be drawn from equation (4.108) of Milburn & Wiseman _Quantum Measurement and Control_. **Changelog**; Fixed error in m_ops definition for heterodyne detection in smesolve.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1237
https://github.com/qutip/qutip/pull/1237:115,Safety,detect,detection,115,**Description**; There was an error in line 613 of qutip/stochastic.py as the measurement operators for heterodyne detection in the implemented stochastic master equation should be `c + c.dag()` and `1j (c - c.dag())` as explicitely presented in equation (5.64) and the following 2 paragraphs in https://arxiv.org/abs/1710.09523. The same measurement operators can also be drawn from equation (4.108) of Milburn & Wiseman _Quantum Measurement and Control_. **Changelog**; Fixed error in m_ops definition for heterodyne detection in smesolve.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1237
https://github.com/qutip/qutip/pull/1237:519,Safety,detect,detection,519,**Description**; There was an error in line 613 of qutip/stochastic.py as the measurement operators for heterodyne detection in the implemented stochastic master equation should be `c + c.dag()` and `1j (c - c.dag())` as explicitely presented in equation (5.64) and the following 2 paragraphs in https://arxiv.org/abs/1710.09523. The same measurement operators can also be drawn from equation (4.108) of Milburn & Wiseman _Quantum Measurement and Control_. **Changelog**; Fixed error in m_ops definition for heterodyne detection in smesolve.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1237
https://github.com/qutip/qutip/issues/1238:1682,Energy Efficiency,energy,energy,1682,"ains either an array result.expect of expectation values for the times specified by tlist, (...), or nothing if a callback function was given in place of operators for which to calculate the expectation values. So to work with callback function, we need to manage the storage by ourselves, for example by defining a global list, as it is done in [this example](https://nbviewer.jupyter.org/github/jrjohansson/qutip-lectures/blob/master/Lecture-8-Adiabatic-quantum-computing.ipynb#Evolve-the-system-in-time). **Describe the solution you'd like**. Currently when we pass a list of operators such as. ```python; e_ops = [sigmax(), sigmay(), sigmaz()]; result = mesolve(H, rho0, e_ops=e_ops); ```. We will be able to access expectation value of `sigmax()` in `result.expect[0]`, of `sigmay()` in `result.expect[1]` and of course `sigmaz()` in `result.expect[2]`. Why not capture the custom measurement in similar way?. ```; def customMeasurement(tau, psi):; exp_x = expect(sigmax(), psi); exp_y = expect(sigmaz(), psi); exp_z = expect(sigmay(), psi); energy = expect(H, psi); fidelity = np.abs(psi_ref.overlap(psi))**2.; return [exp_x, exp_y, exp_z, energy, fidelity]; ```. Now it is possible to still get expectation values as before, but in addition we can take more custom measurements (in this example energy and fidelity of state) and access them in exactly the same way for the convenience. The only thing user needs to keep track of is order of operators returned from the callback function. So now it is as before but in addition `result.expect[3]` contains energy and `result.expect[4]` contains fidelity and no custom managed global external lists required as it was in the [example](https://nbviewer.jupyter.org/github/jrjohansson/qutip-lectures/blob/master/Lecture-8-Adiabatic-quantum-computing.ipynb#Evolve-the-system-in-time). **Describe alternatives you've considered**. Alternatively we could establish that custom measurement callback function must return only single value and user woul",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1238
https://github.com/qutip/qutip/issues/1238:1781,Energy Efficiency,energy,energy,1781,"in place of operators for which to calculate the expectation values. So to work with callback function, we need to manage the storage by ourselves, for example by defining a global list, as it is done in [this example](https://nbviewer.jupyter.org/github/jrjohansson/qutip-lectures/blob/master/Lecture-8-Adiabatic-quantum-computing.ipynb#Evolve-the-system-in-time). **Describe the solution you'd like**. Currently when we pass a list of operators such as. ```python; e_ops = [sigmax(), sigmay(), sigmaz()]; result = mesolve(H, rho0, e_ops=e_ops); ```. We will be able to access expectation value of `sigmax()` in `result.expect[0]`, of `sigmay()` in `result.expect[1]` and of course `sigmaz()` in `result.expect[2]`. Why not capture the custom measurement in similar way?. ```; def customMeasurement(tau, psi):; exp_x = expect(sigmax(), psi); exp_y = expect(sigmaz(), psi); exp_z = expect(sigmay(), psi); energy = expect(H, psi); fidelity = np.abs(psi_ref.overlap(psi))**2.; return [exp_x, exp_y, exp_z, energy, fidelity]; ```. Now it is possible to still get expectation values as before, but in addition we can take more custom measurements (in this example energy and fidelity of state) and access them in exactly the same way for the convenience. The only thing user needs to keep track of is order of operators returned from the callback function. So now it is as before but in addition `result.expect[3]` contains energy and `result.expect[4]` contains fidelity and no custom managed global external lists required as it was in the [example](https://nbviewer.jupyter.org/github/jrjohansson/qutip-lectures/blob/master/Lecture-8-Adiabatic-quantum-computing.ipynb#Evolve-the-system-in-time). **Describe alternatives you've considered**. Alternatively we could establish that custom measurement callback function must return only single value and user would be able to pass mixed list of operators and functions in the `e_ops`. **Additional context**. Correct me if I'm wrong, based on the docs and",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1238
https://github.com/qutip/qutip/issues/1238:1937,Energy Efficiency,energy,energy,1937,"urselves, for example by defining a global list, as it is done in [this example](https://nbviewer.jupyter.org/github/jrjohansson/qutip-lectures/blob/master/Lecture-8-Adiabatic-quantum-computing.ipynb#Evolve-the-system-in-time). **Describe the solution you'd like**. Currently when we pass a list of operators such as. ```python; e_ops = [sigmax(), sigmay(), sigmaz()]; result = mesolve(H, rho0, e_ops=e_ops); ```. We will be able to access expectation value of `sigmax()` in `result.expect[0]`, of `sigmay()` in `result.expect[1]` and of course `sigmaz()` in `result.expect[2]`. Why not capture the custom measurement in similar way?. ```; def customMeasurement(tau, psi):; exp_x = expect(sigmax(), psi); exp_y = expect(sigmaz(), psi); exp_z = expect(sigmay(), psi); energy = expect(H, psi); fidelity = np.abs(psi_ref.overlap(psi))**2.; return [exp_x, exp_y, exp_z, energy, fidelity]; ```. Now it is possible to still get expectation values as before, but in addition we can take more custom measurements (in this example energy and fidelity of state) and access them in exactly the same way for the convenience. The only thing user needs to keep track of is order of operators returned from the callback function. So now it is as before but in addition `result.expect[3]` contains energy and `result.expect[4]` contains fidelity and no custom managed global external lists required as it was in the [example](https://nbviewer.jupyter.org/github/jrjohansson/qutip-lectures/blob/master/Lecture-8-Adiabatic-quantum-computing.ipynb#Evolve-the-system-in-time). **Describe alternatives you've considered**. Alternatively we could establish that custom measurement callback function must return only single value and user would be able to pass mixed list of operators and functions in the `e_ops`. **Additional context**. Correct me if I'm wrong, based on the docs and examples I referenced above I have impression there is no better way to do it, but maybe I just missed it? Please regard this issue as ope",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1238
https://github.com/qutip/qutip/issues/1238:2197,Energy Efficiency,energy,energy,2197,"r.jupyter.org/github/jrjohansson/qutip-lectures/blob/master/Lecture-8-Adiabatic-quantum-computing.ipynb#Evolve-the-system-in-time). **Describe the solution you'd like**. Currently when we pass a list of operators such as. ```python; e_ops = [sigmax(), sigmay(), sigmaz()]; result = mesolve(H, rho0, e_ops=e_ops); ```. We will be able to access expectation value of `sigmax()` in `result.expect[0]`, of `sigmay()` in `result.expect[1]` and of course `sigmaz()` in `result.expect[2]`. Why not capture the custom measurement in similar way?. ```; def customMeasurement(tau, psi):; exp_x = expect(sigmax(), psi); exp_y = expect(sigmaz(), psi); exp_z = expect(sigmay(), psi); energy = expect(H, psi); fidelity = np.abs(psi_ref.overlap(psi))**2.; return [exp_x, exp_y, exp_z, energy, fidelity]; ```. Now it is possible to still get expectation values as before, but in addition we can take more custom measurements (in this example energy and fidelity of state) and access them in exactly the same way for the convenience. The only thing user needs to keep track of is order of operators returned from the callback function. So now it is as before but in addition `result.expect[3]` contains energy and `result.expect[4]` contains fidelity and no custom managed global external lists required as it was in the [example](https://nbviewer.jupyter.org/github/jrjohansson/qutip-lectures/blob/master/Lecture-8-Adiabatic-quantum-computing.ipynb#Evolve-the-system-in-time). **Describe alternatives you've considered**. Alternatively we could establish that custom measurement callback function must return only single value and user would be able to pass mixed list of operators and functions in the `e_ops`. **Additional context**. Correct me if I'm wrong, based on the docs and examples I referenced above I have impression there is no better way to do it, but maybe I just missed it? Please regard this issue as opening a discussion, I'll be happy to participate and of course, implement the changes I suggest.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1238
https://github.com/qutip/qutip/issues/1238:451,Integrability,depend,dependent,451,"**Is your feature request related to a problem? Please describe.**. It is very convenient to take measurements in QuTip by passing list of observables in the `e_ops` argument of `mesolve` or `sesolve`, a list of expectation values at each time step of all those operators will be provided in returned `qutip.Result` object. It becomes much less elegant once we implement custom measurements and pass a callback function (for example to work with time-dependent Hamiltonians etc). According to the [documentation](http://qutip.org/docs/4.1/apidoc/functions.html#module-qutip.mesolve). > An instance of the class qutip.Result, which contains either an array result.expect of expectation values for the times specified by tlist, (...), or nothing if a callback function was given in place of operators for which to calculate the expectation values. So to work with callback function, we need to manage the storage by ourselves, for example by defining a global list, as it is done in [this example](https://nbviewer.jupyter.org/github/jrjohansson/qutip-lectures/blob/master/Lecture-8-Adiabatic-quantum-computing.ipynb#Evolve-the-system-in-time). **Describe the solution you'd like**. Currently when we pass a list of operators such as. ```python; e_ops = [sigmax(), sigmay(), sigmaz()]; result = mesolve(H, rho0, e_ops=e_ops); ```. We will be able to access expectation value of `sigmax()` in `result.expect[0]`, of `sigmay()` in `result.expect[1]` and of course `sigmaz()` in `result.expect[2]`. Why not capture the custom measurement in similar way?. ```; def customMeasurement(tau, psi):; exp_x = expect(sigmax(), psi); exp_y = expect(sigmaz(), psi); exp_z = expect(sigmay(), psi); energy = expect(H, psi); fidelity = np.abs(psi_ref.overlap(psi))**2.; return [exp_x, exp_y, exp_z, energy, fidelity]; ```. Now it is possible to still get expectation values as before, but in addition we can take more custom measurements (in this example energy and fidelity of state) and access them in exactly the sam",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1238
https://github.com/qutip/qutip/issues/1238:1115,Modifiability,Evolve,Evolve-the-system-in-time,1115,"ssing list of observables in the `e_ops` argument of `mesolve` or `sesolve`, a list of expectation values at each time step of all those operators will be provided in returned `qutip.Result` object. It becomes much less elegant once we implement custom measurements and pass a callback function (for example to work with time-dependent Hamiltonians etc). According to the [documentation](http://qutip.org/docs/4.1/apidoc/functions.html#module-qutip.mesolve). > An instance of the class qutip.Result, which contains either an array result.expect of expectation values for the times specified by tlist, (...), or nothing if a callback function was given in place of operators for which to calculate the expectation values. So to work with callback function, we need to manage the storage by ourselves, for example by defining a global list, as it is done in [this example](https://nbviewer.jupyter.org/github/jrjohansson/qutip-lectures/blob/master/Lecture-8-Adiabatic-quantum-computing.ipynb#Evolve-the-system-in-time). **Describe the solution you'd like**. Currently when we pass a list of operators such as. ```python; e_ops = [sigmax(), sigmay(), sigmaz()]; result = mesolve(H, rho0, e_ops=e_ops); ```. We will be able to access expectation value of `sigmax()` in `result.expect[0]`, of `sigmay()` in `result.expect[1]` and of course `sigmaz()` in `result.expect[2]`. Why not capture the custom measurement in similar way?. ```; def customMeasurement(tau, psi):; exp_x = expect(sigmax(), psi); exp_y = expect(sigmaz(), psi); exp_z = expect(sigmay(), psi); energy = expect(H, psi); fidelity = np.abs(psi_ref.overlap(psi))**2.; return [exp_x, exp_y, exp_z, energy, fidelity]; ```. Now it is possible to still get expectation values as before, but in addition we can take more custom measurements (in this example energy and fidelity of state) and access them in exactly the same way for the convenience. The only thing user needs to keep track of is order of operators returned from the callback functi",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1238
https://github.com/qutip/qutip/issues/1238:2444,Modifiability,Evolve,Evolve-the-system-in-time,2444,"r.jupyter.org/github/jrjohansson/qutip-lectures/blob/master/Lecture-8-Adiabatic-quantum-computing.ipynb#Evolve-the-system-in-time). **Describe the solution you'd like**. Currently when we pass a list of operators such as. ```python; e_ops = [sigmax(), sigmay(), sigmaz()]; result = mesolve(H, rho0, e_ops=e_ops); ```. We will be able to access expectation value of `sigmax()` in `result.expect[0]`, of `sigmay()` in `result.expect[1]` and of course `sigmaz()` in `result.expect[2]`. Why not capture the custom measurement in similar way?. ```; def customMeasurement(tau, psi):; exp_x = expect(sigmax(), psi); exp_y = expect(sigmaz(), psi); exp_z = expect(sigmay(), psi); energy = expect(H, psi); fidelity = np.abs(psi_ref.overlap(psi))**2.; return [exp_x, exp_y, exp_z, energy, fidelity]; ```. Now it is possible to still get expectation values as before, but in addition we can take more custom measurements (in this example energy and fidelity of state) and access them in exactly the same way for the convenience. The only thing user needs to keep track of is order of operators returned from the callback function. So now it is as before but in addition `result.expect[3]` contains energy and `result.expect[4]` contains fidelity and no custom managed global external lists required as it was in the [example](https://nbviewer.jupyter.org/github/jrjohansson/qutip-lectures/blob/master/Lecture-8-Adiabatic-quantum-computing.ipynb#Evolve-the-system-in-time). **Describe alternatives you've considered**. Alternatively we could establish that custom measurement callback function must return only single value and user would be able to pass mixed list of operators and functions in the `e_ops`. **Additional context**. Correct me if I'm wrong, based on the docs and examples I referenced above I have impression there is no better way to do it, but maybe I just missed it? Please regard this issue as opening a discussion, I'll be happy to participate and of course, implement the changes I suggest.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1238
https://github.com/qutip/qutip/issues/1238:1348,Security,access,access,1348,"plement custom measurements and pass a callback function (for example to work with time-dependent Hamiltonians etc). According to the [documentation](http://qutip.org/docs/4.1/apidoc/functions.html#module-qutip.mesolve). > An instance of the class qutip.Result, which contains either an array result.expect of expectation values for the times specified by tlist, (...), or nothing if a callback function was given in place of operators for which to calculate the expectation values. So to work with callback function, we need to manage the storage by ourselves, for example by defining a global list, as it is done in [this example](https://nbviewer.jupyter.org/github/jrjohansson/qutip-lectures/blob/master/Lecture-8-Adiabatic-quantum-computing.ipynb#Evolve-the-system-in-time). **Describe the solution you'd like**. Currently when we pass a list of operators such as. ```python; e_ops = [sigmax(), sigmay(), sigmaz()]; result = mesolve(H, rho0, e_ops=e_ops); ```. We will be able to access expectation value of `sigmax()` in `result.expect[0]`, of `sigmay()` in `result.expect[1]` and of course `sigmaz()` in `result.expect[2]`. Why not capture the custom measurement in similar way?. ```; def customMeasurement(tau, psi):; exp_x = expect(sigmax(), psi); exp_y = expect(sigmaz(), psi); exp_z = expect(sigmay(), psi); energy = expect(H, psi); fidelity = np.abs(psi_ref.overlap(psi))**2.; return [exp_x, exp_y, exp_z, energy, fidelity]; ```. Now it is possible to still get expectation values as before, but in addition we can take more custom measurements (in this example energy and fidelity of state) and access them in exactly the same way for the convenience. The only thing user needs to keep track of is order of operators returned from the callback function. So now it is as before but in addition `result.expect[3]` contains energy and `result.expect[4]` contains fidelity and no custom managed global external lists required as it was in the [example](https://nbviewer.jupyter.org/github/jr",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1238
https://github.com/qutip/qutip/issues/1238:1971,Security,access,access,1971,"urselves, for example by defining a global list, as it is done in [this example](https://nbviewer.jupyter.org/github/jrjohansson/qutip-lectures/blob/master/Lecture-8-Adiabatic-quantum-computing.ipynb#Evolve-the-system-in-time). **Describe the solution you'd like**. Currently when we pass a list of operators such as. ```python; e_ops = [sigmax(), sigmay(), sigmaz()]; result = mesolve(H, rho0, e_ops=e_ops); ```. We will be able to access expectation value of `sigmax()` in `result.expect[0]`, of `sigmay()` in `result.expect[1]` and of course `sigmaz()` in `result.expect[2]`. Why not capture the custom measurement in similar way?. ```; def customMeasurement(tau, psi):; exp_x = expect(sigmax(), psi); exp_y = expect(sigmaz(), psi); exp_z = expect(sigmay(), psi); energy = expect(H, psi); fidelity = np.abs(psi_ref.overlap(psi))**2.; return [exp_x, exp_y, exp_z, energy, fidelity]; ```. Now it is possible to still get expectation values as before, but in addition we can take more custom measurements (in this example energy and fidelity of state) and access them in exactly the same way for the convenience. The only thing user needs to keep track of is order of operators returned from the callback function. So now it is as before but in addition `result.expect[3]` contains energy and `result.expect[4]` contains fidelity and no custom managed global external lists required as it was in the [example](https://nbviewer.jupyter.org/github/jrjohansson/qutip-lectures/blob/master/Lecture-8-Adiabatic-quantum-computing.ipynb#Evolve-the-system-in-time). **Describe alternatives you've considered**. Alternatively we could establish that custom measurement callback function must return only single value and user would be able to pass mixed list of operators and functions in the `e_ops`. **Additional context**. Correct me if I'm wrong, based on the docs and examples I referenced above I have impression there is no better way to do it, but maybe I just missed it? Please regard this issue as ope",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1238
https://github.com/qutip/qutip/issues/1239:98,Availability,error,error,98,**Describe the bug**; calling ptrace(0) should simply return the object. Instead it fails with an error. **To Reproduce**; import qutip as qp; qp.sigmax().ptrace(0). **Expected behavior**; expect it to return the existing object. **Your Environment**; QuTiP Version: 4.5.0; Numpy Version: 1.18.1; Scipy Version: 1.4.1; Cython Version: 0.29.16; Matplotlib Version: 3.2.1; Python Version: 3.7.6; Number of CPUs: 8; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64); Installation path: C:\Users\Lior Ella\scoop\apps\miniconda3\4.5.12\envs\tfenv\lib\site-packages\qutip,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1239
https://github.com/qutip/qutip/issues/1239:440,Deployability,Install,Installed,440,**Describe the bug**; calling ptrace(0) should simply return the object. Instead it fails with an error. **To Reproduce**; import qutip as qp; qp.sigmax().ptrace(0). **Expected behavior**; expect it to return the existing object. **Your Environment**; QuTiP Version: 4.5.0; Numpy Version: 1.18.1; Scipy Version: 1.4.1; Cython Version: 0.29.16; Matplotlib Version: 3.2.1; Python Version: 3.7.6; Number of CPUs: 8; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64); Installation path: C:\Users\Lior Ella\scoop\apps\miniconda3\4.5.12\envs\tfenv\lib\site-packages\qutip,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1239
https://github.com/qutip/qutip/issues/1239:512,Deployability,Install,Installation,512,**Describe the bug**; calling ptrace(0) should simply return the object. Instead it fails with an error. **To Reproduce**; import qutip as qp; qp.sigmax().ptrace(0). **Expected behavior**; expect it to return the existing object. **Your Environment**; QuTiP Version: 4.5.0; Numpy Version: 1.18.1; Scipy Version: 1.4.1; Cython Version: 0.29.16; Matplotlib Version: 3.2.1; Python Version: 3.7.6; Number of CPUs: 8; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64); Installation path: C:\Users\Lior Ella\scoop\apps\miniconda3\4.5.12\envs\tfenv\lib\site-packages\qutip,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1239
https://github.com/qutip/qutip/issues/1239:47,Usability,simpl,simply,47,**Describe the bug**; calling ptrace(0) should simply return the object. Instead it fails with an error. **To Reproduce**; import qutip as qp; qp.sigmax().ptrace(0). **Expected behavior**; expect it to return the existing object. **Your Environment**; QuTiP Version: 4.5.0; Numpy Version: 1.18.1; Scipy Version: 1.4.1; Cython Version: 0.29.16; Matplotlib Version: 3.2.1; Python Version: 3.7.6; Number of CPUs: 8; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64); Installation path: C:\Users\Lior Ella\scoop\apps\miniconda3\4.5.12\envs\tfenv\lib\site-packages\qutip,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1239
https://github.com/qutip/qutip/pull/1241:55,Deployability,release,release,55,**Description**; Making 4.5.1 up-to-date for next week release. **Changelog**; Moved test to 3.8; `randint`'s dtype fixed for seed generation; Mac pool use spawn; corrected heterodyne's m_ops (by eliegenois),MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1241
https://github.com/qutip/qutip/pull/1241:85,Testability,test,test,85,**Description**; Making 4.5.1 up-to-date for next week release. **Changelog**; Moved test to 3.8; `randint`'s dtype fixed for seed generation; Mac pool use spawn; corrected heterodyne's m_ops (by eliegenois),MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1241
https://github.com/qutip/qutip/pull/1242:91,Availability,error,error,91,1. `self.N` in `QubitCircuit` is not the number of gates but the number of qubits.; 2. The error of index excesses number of gates was not captured.; 3. `self.gates.remove(self.gates[self.N - i])` removes the first match but not the last.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1242
https://github.com/qutip/qutip/issues/1243:246,Availability,avail,available,246,"**Is your feature request related to a problem? Please describe.**; In the device simulator of QuTiP (`qutip.qip.device`), a quantum computing device is characterized by the class `Processor` and its subclasses. It contains information about the available control pulses. In addition, a compiler is used to compile a set of universal quantum gates (e.g. RX, RY and ISWAP) into the corresponding control pulses. Together, they can automatically compiler an arbitrary quantum circuit into control pulses, create the time-dependent Hamiltonian representation and run the simulation using QuTiP solvers. However, in the current version, this compilation is done for each gate sequentially. At each time step, there is only one control pulse active. In practice, it is inefficient because usually several gates can be performed parallelly (e.g. X gate on qubit 0 and qubit 1). To make the compilation more practical, it is necessary to introduce a scheduler that schedules the control pulses. A similar example is https://qiskit.org/documentation/apidoc/pulse.html#schedules. **Describe the solution you'd like**; There is existing research (https://arxiv.org/pdf/1708.00023.pdf) on gate-level scheduling. It studies which gates can be performed at the same time. In the most general case, however, gate-level scheduling is not enough, since different gates often have different runtime (.e.g. CNOT usually takes longer time than X gate). Despite the difference, pulse-level scheduling can be done in a similar way as gate-level scheduling by generating a graph (see the reference above). The difference is that each pulse will have its own duration. The possible implementation in `qutip.qip` could be in two steps:; - Modernize the current compiler and create an `Instruction` class representing each compiled control instruction (pulse, qubit index, amplitude, duration).; - Implement the scheduling algorithm similar as in the above reference.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1243
https://github.com/qutip/qutip/issues/1243:943,Energy Efficiency,schedul,scheduler,943,"**Is your feature request related to a problem? Please describe.**; In the device simulator of QuTiP (`qutip.qip.device`), a quantum computing device is characterized by the class `Processor` and its subclasses. It contains information about the available control pulses. In addition, a compiler is used to compile a set of universal quantum gates (e.g. RX, RY and ISWAP) into the corresponding control pulses. Together, they can automatically compiler an arbitrary quantum circuit into control pulses, create the time-dependent Hamiltonian representation and run the simulation using QuTiP solvers. However, in the current version, this compilation is done for each gate sequentially. At each time step, there is only one control pulse active. In practice, it is inefficient because usually several gates can be performed parallelly (e.g. X gate on qubit 0 and qubit 1). To make the compilation more practical, it is necessary to introduce a scheduler that schedules the control pulses. A similar example is https://qiskit.org/documentation/apidoc/pulse.html#schedules. **Describe the solution you'd like**; There is existing research (https://arxiv.org/pdf/1708.00023.pdf) on gate-level scheduling. It studies which gates can be performed at the same time. In the most general case, however, gate-level scheduling is not enough, since different gates often have different runtime (.e.g. CNOT usually takes longer time than X gate). Despite the difference, pulse-level scheduling can be done in a similar way as gate-level scheduling by generating a graph (see the reference above). The difference is that each pulse will have its own duration. The possible implementation in `qutip.qip` could be in two steps:; - Modernize the current compiler and create an `Instruction` class representing each compiled control instruction (pulse, qubit index, amplitude, duration).; - Implement the scheduling algorithm similar as in the above reference.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1243
https://github.com/qutip/qutip/issues/1243:958,Energy Efficiency,schedul,schedules,958,"**Is your feature request related to a problem? Please describe.**; In the device simulator of QuTiP (`qutip.qip.device`), a quantum computing device is characterized by the class `Processor` and its subclasses. It contains information about the available control pulses. In addition, a compiler is used to compile a set of universal quantum gates (e.g. RX, RY and ISWAP) into the corresponding control pulses. Together, they can automatically compiler an arbitrary quantum circuit into control pulses, create the time-dependent Hamiltonian representation and run the simulation using QuTiP solvers. However, in the current version, this compilation is done for each gate sequentially. At each time step, there is only one control pulse active. In practice, it is inefficient because usually several gates can be performed parallelly (e.g. X gate on qubit 0 and qubit 1). To make the compilation more practical, it is necessary to introduce a scheduler that schedules the control pulses. A similar example is https://qiskit.org/documentation/apidoc/pulse.html#schedules. **Describe the solution you'd like**; There is existing research (https://arxiv.org/pdf/1708.00023.pdf) on gate-level scheduling. It studies which gates can be performed at the same time. In the most general case, however, gate-level scheduling is not enough, since different gates often have different runtime (.e.g. CNOT usually takes longer time than X gate). Despite the difference, pulse-level scheduling can be done in a similar way as gate-level scheduling by generating a graph (see the reference above). The difference is that each pulse will have its own duration. The possible implementation in `qutip.qip` could be in two steps:; - Modernize the current compiler and create an `Instruction` class representing each compiled control instruction (pulse, qubit index, amplitude, duration).; - Implement the scheduling algorithm similar as in the above reference.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1243
https://github.com/qutip/qutip/issues/1243:1060,Energy Efficiency,schedul,schedules,1060,"**Is your feature request related to a problem? Please describe.**; In the device simulator of QuTiP (`qutip.qip.device`), a quantum computing device is characterized by the class `Processor` and its subclasses. It contains information about the available control pulses. In addition, a compiler is used to compile a set of universal quantum gates (e.g. RX, RY and ISWAP) into the corresponding control pulses. Together, they can automatically compiler an arbitrary quantum circuit into control pulses, create the time-dependent Hamiltonian representation and run the simulation using QuTiP solvers. However, in the current version, this compilation is done for each gate sequentially. At each time step, there is only one control pulse active. In practice, it is inefficient because usually several gates can be performed parallelly (e.g. X gate on qubit 0 and qubit 1). To make the compilation more practical, it is necessary to introduce a scheduler that schedules the control pulses. A similar example is https://qiskit.org/documentation/apidoc/pulse.html#schedules. **Describe the solution you'd like**; There is existing research (https://arxiv.org/pdf/1708.00023.pdf) on gate-level scheduling. It studies which gates can be performed at the same time. In the most general case, however, gate-level scheduling is not enough, since different gates often have different runtime (.e.g. CNOT usually takes longer time than X gate). Despite the difference, pulse-level scheduling can be done in a similar way as gate-level scheduling by generating a graph (see the reference above). The difference is that each pulse will have its own duration. The possible implementation in `qutip.qip` could be in two steps:; - Modernize the current compiler and create an `Instruction` class representing each compiled control instruction (pulse, qubit index, amplitude, duration).; - Implement the scheduling algorithm similar as in the above reference.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1243
https://github.com/qutip/qutip/issues/1243:1189,Energy Efficiency,schedul,scheduling,1189,"**Is your feature request related to a problem? Please describe.**; In the device simulator of QuTiP (`qutip.qip.device`), a quantum computing device is characterized by the class `Processor` and its subclasses. It contains information about the available control pulses. In addition, a compiler is used to compile a set of universal quantum gates (e.g. RX, RY and ISWAP) into the corresponding control pulses. Together, they can automatically compiler an arbitrary quantum circuit into control pulses, create the time-dependent Hamiltonian representation and run the simulation using QuTiP solvers. However, in the current version, this compilation is done for each gate sequentially. At each time step, there is only one control pulse active. In practice, it is inefficient because usually several gates can be performed parallelly (e.g. X gate on qubit 0 and qubit 1). To make the compilation more practical, it is necessary to introduce a scheduler that schedules the control pulses. A similar example is https://qiskit.org/documentation/apidoc/pulse.html#schedules. **Describe the solution you'd like**; There is existing research (https://arxiv.org/pdf/1708.00023.pdf) on gate-level scheduling. It studies which gates can be performed at the same time. In the most general case, however, gate-level scheduling is not enough, since different gates often have different runtime (.e.g. CNOT usually takes longer time than X gate). Despite the difference, pulse-level scheduling can be done in a similar way as gate-level scheduling by generating a graph (see the reference above). The difference is that each pulse will have its own duration. The possible implementation in `qutip.qip` could be in two steps:; - Modernize the current compiler and create an `Instruction` class representing each compiled control instruction (pulse, qubit index, amplitude, duration).; - Implement the scheduling algorithm similar as in the above reference.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1243
https://github.com/qutip/qutip/issues/1243:1305,Energy Efficiency,schedul,scheduling,1305,"**Is your feature request related to a problem? Please describe.**; In the device simulator of QuTiP (`qutip.qip.device`), a quantum computing device is characterized by the class `Processor` and its subclasses. It contains information about the available control pulses. In addition, a compiler is used to compile a set of universal quantum gates (e.g. RX, RY and ISWAP) into the corresponding control pulses. Together, they can automatically compiler an arbitrary quantum circuit into control pulses, create the time-dependent Hamiltonian representation and run the simulation using QuTiP solvers. However, in the current version, this compilation is done for each gate sequentially. At each time step, there is only one control pulse active. In practice, it is inefficient because usually several gates can be performed parallelly (e.g. X gate on qubit 0 and qubit 1). To make the compilation more practical, it is necessary to introduce a scheduler that schedules the control pulses. A similar example is https://qiskit.org/documentation/apidoc/pulse.html#schedules. **Describe the solution you'd like**; There is existing research (https://arxiv.org/pdf/1708.00023.pdf) on gate-level scheduling. It studies which gates can be performed at the same time. In the most general case, however, gate-level scheduling is not enough, since different gates often have different runtime (.e.g. CNOT usually takes longer time than X gate). Despite the difference, pulse-level scheduling can be done in a similar way as gate-level scheduling by generating a graph (see the reference above). The difference is that each pulse will have its own duration. The possible implementation in `qutip.qip` could be in two steps:; - Modernize the current compiler and create an `Instruction` class representing each compiled control instruction (pulse, qubit index, amplitude, duration).; - Implement the scheduling algorithm similar as in the above reference.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1243
https://github.com/qutip/qutip/issues/1243:1470,Energy Efficiency,schedul,scheduling,1470,"**Is your feature request related to a problem? Please describe.**; In the device simulator of QuTiP (`qutip.qip.device`), a quantum computing device is characterized by the class `Processor` and its subclasses. It contains information about the available control pulses. In addition, a compiler is used to compile a set of universal quantum gates (e.g. RX, RY and ISWAP) into the corresponding control pulses. Together, they can automatically compiler an arbitrary quantum circuit into control pulses, create the time-dependent Hamiltonian representation and run the simulation using QuTiP solvers. However, in the current version, this compilation is done for each gate sequentially. At each time step, there is only one control pulse active. In practice, it is inefficient because usually several gates can be performed parallelly (e.g. X gate on qubit 0 and qubit 1). To make the compilation more practical, it is necessary to introduce a scheduler that schedules the control pulses. A similar example is https://qiskit.org/documentation/apidoc/pulse.html#schedules. **Describe the solution you'd like**; There is existing research (https://arxiv.org/pdf/1708.00023.pdf) on gate-level scheduling. It studies which gates can be performed at the same time. In the most general case, however, gate-level scheduling is not enough, since different gates often have different runtime (.e.g. CNOT usually takes longer time than X gate). Despite the difference, pulse-level scheduling can be done in a similar way as gate-level scheduling by generating a graph (see the reference above). The difference is that each pulse will have its own duration. The possible implementation in `qutip.qip` could be in two steps:; - Modernize the current compiler and create an `Instruction` class representing each compiled control instruction (pulse, qubit index, amplitude, duration).; - Implement the scheduling algorithm similar as in the above reference.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1243
https://github.com/qutip/qutip/issues/1243:1524,Energy Efficiency,schedul,scheduling,1524,"**Is your feature request related to a problem? Please describe.**; In the device simulator of QuTiP (`qutip.qip.device`), a quantum computing device is characterized by the class `Processor` and its subclasses. It contains information about the available control pulses. In addition, a compiler is used to compile a set of universal quantum gates (e.g. RX, RY and ISWAP) into the corresponding control pulses. Together, they can automatically compiler an arbitrary quantum circuit into control pulses, create the time-dependent Hamiltonian representation and run the simulation using QuTiP solvers. However, in the current version, this compilation is done for each gate sequentially. At each time step, there is only one control pulse active. In practice, it is inefficient because usually several gates can be performed parallelly (e.g. X gate on qubit 0 and qubit 1). To make the compilation more practical, it is necessary to introduce a scheduler that schedules the control pulses. A similar example is https://qiskit.org/documentation/apidoc/pulse.html#schedules. **Describe the solution you'd like**; There is existing research (https://arxiv.org/pdf/1708.00023.pdf) on gate-level scheduling. It studies which gates can be performed at the same time. In the most general case, however, gate-level scheduling is not enough, since different gates often have different runtime (.e.g. CNOT usually takes longer time than X gate). Despite the difference, pulse-level scheduling can be done in a similar way as gate-level scheduling by generating a graph (see the reference above). The difference is that each pulse will have its own duration. The possible implementation in `qutip.qip` could be in two steps:; - Modernize the current compiler and create an `Instruction` class representing each compiled control instruction (pulse, qubit index, amplitude, duration).; - Implement the scheduling algorithm similar as in the above reference.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1243
https://github.com/qutip/qutip/issues/1243:1887,Energy Efficiency,schedul,scheduling,1887,"**Is your feature request related to a problem? Please describe.**; In the device simulator of QuTiP (`qutip.qip.device`), a quantum computing device is characterized by the class `Processor` and its subclasses. It contains information about the available control pulses. In addition, a compiler is used to compile a set of universal quantum gates (e.g. RX, RY and ISWAP) into the corresponding control pulses. Together, they can automatically compiler an arbitrary quantum circuit into control pulses, create the time-dependent Hamiltonian representation and run the simulation using QuTiP solvers. However, in the current version, this compilation is done for each gate sequentially. At each time step, there is only one control pulse active. In practice, it is inefficient because usually several gates can be performed parallelly (e.g. X gate on qubit 0 and qubit 1). To make the compilation more practical, it is necessary to introduce a scheduler that schedules the control pulses. A similar example is https://qiskit.org/documentation/apidoc/pulse.html#schedules. **Describe the solution you'd like**; There is existing research (https://arxiv.org/pdf/1708.00023.pdf) on gate-level scheduling. It studies which gates can be performed at the same time. In the most general case, however, gate-level scheduling is not enough, since different gates often have different runtime (.e.g. CNOT usually takes longer time than X gate). Despite the difference, pulse-level scheduling can be done in a similar way as gate-level scheduling by generating a graph (see the reference above). The difference is that each pulse will have its own duration. The possible implementation in `qutip.qip` could be in two steps:; - Modernize the current compiler and create an `Instruction` class representing each compiled control instruction (pulse, qubit index, amplitude, duration).; - Implement the scheduling algorithm similar as in the above reference.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1243
https://github.com/qutip/qutip/issues/1243:519,Integrability,depend,dependent,519,"**Is your feature request related to a problem? Please describe.**; In the device simulator of QuTiP (`qutip.qip.device`), a quantum computing device is characterized by the class `Processor` and its subclasses. It contains information about the available control pulses. In addition, a compiler is used to compile a set of universal quantum gates (e.g. RX, RY and ISWAP) into the corresponding control pulses. Together, they can automatically compiler an arbitrary quantum circuit into control pulses, create the time-dependent Hamiltonian representation and run the simulation using QuTiP solvers. However, in the current version, this compilation is done for each gate sequentially. At each time step, there is only one control pulse active. In practice, it is inefficient because usually several gates can be performed parallelly (e.g. X gate on qubit 0 and qubit 1). To make the compilation more practical, it is necessary to introduce a scheduler that schedules the control pulses. A similar example is https://qiskit.org/documentation/apidoc/pulse.html#schedules. **Describe the solution you'd like**; There is existing research (https://arxiv.org/pdf/1708.00023.pdf) on gate-level scheduling. It studies which gates can be performed at the same time. In the most general case, however, gate-level scheduling is not enough, since different gates often have different runtime (.e.g. CNOT usually takes longer time than X gate). Despite the difference, pulse-level scheduling can be done in a similar way as gate-level scheduling by generating a graph (see the reference above). The difference is that each pulse will have its own duration. The possible implementation in `qutip.qip` could be in two steps:; - Modernize the current compiler and create an `Instruction` class representing each compiled control instruction (pulse, qubit index, amplitude, duration).; - Implement the scheduling algorithm similar as in the above reference.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1243
https://github.com/qutip/qutip/issues/1243:813,Performance,perform,performed,813,"**Is your feature request related to a problem? Please describe.**; In the device simulator of QuTiP (`qutip.qip.device`), a quantum computing device is characterized by the class `Processor` and its subclasses. It contains information about the available control pulses. In addition, a compiler is used to compile a set of universal quantum gates (e.g. RX, RY and ISWAP) into the corresponding control pulses. Together, they can automatically compiler an arbitrary quantum circuit into control pulses, create the time-dependent Hamiltonian representation and run the simulation using QuTiP solvers. However, in the current version, this compilation is done for each gate sequentially. At each time step, there is only one control pulse active. In practice, it is inefficient because usually several gates can be performed parallelly (e.g. X gate on qubit 0 and qubit 1). To make the compilation more practical, it is necessary to introduce a scheduler that schedules the control pulses. A similar example is https://qiskit.org/documentation/apidoc/pulse.html#schedules. **Describe the solution you'd like**; There is existing research (https://arxiv.org/pdf/1708.00023.pdf) on gate-level scheduling. It studies which gates can be performed at the same time. In the most general case, however, gate-level scheduling is not enough, since different gates often have different runtime (.e.g. CNOT usually takes longer time than X gate). Despite the difference, pulse-level scheduling can be done in a similar way as gate-level scheduling by generating a graph (see the reference above). The difference is that each pulse will have its own duration. The possible implementation in `qutip.qip` could be in two steps:; - Modernize the current compiler and create an `Instruction` class representing each compiled control instruction (pulse, qubit index, amplitude, duration).; - Implement the scheduling algorithm similar as in the above reference.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1243
https://github.com/qutip/qutip/issues/1243:1231,Performance,perform,performed,1231,"**Is your feature request related to a problem? Please describe.**; In the device simulator of QuTiP (`qutip.qip.device`), a quantum computing device is characterized by the class `Processor` and its subclasses. It contains information about the available control pulses. In addition, a compiler is used to compile a set of universal quantum gates (e.g. RX, RY and ISWAP) into the corresponding control pulses. Together, they can automatically compiler an arbitrary quantum circuit into control pulses, create the time-dependent Hamiltonian representation and run the simulation using QuTiP solvers. However, in the current version, this compilation is done for each gate sequentially. At each time step, there is only one control pulse active. In practice, it is inefficient because usually several gates can be performed parallelly (e.g. X gate on qubit 0 and qubit 1). To make the compilation more practical, it is necessary to introduce a scheduler that schedules the control pulses. A similar example is https://qiskit.org/documentation/apidoc/pulse.html#schedules. **Describe the solution you'd like**; There is existing research (https://arxiv.org/pdf/1708.00023.pdf) on gate-level scheduling. It studies which gates can be performed at the same time. In the most general case, however, gate-level scheduling is not enough, since different gates often have different runtime (.e.g. CNOT usually takes longer time than X gate). Despite the difference, pulse-level scheduling can be done in a similar way as gate-level scheduling by generating a graph (see the reference above). The difference is that each pulse will have its own duration. The possible implementation in `qutip.qip` could be in two steps:; - Modernize the current compiler and create an `Instruction` class representing each compiled control instruction (pulse, qubit index, amplitude, duration).; - Implement the scheduling algorithm similar as in the above reference.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1243
https://github.com/qutip/qutip/issues/1244:266,Availability,error,error,266,"**Describe the issue**; I tried to Execute the code ""Time-dependent master equation: Landau-Zener transitions"" in QuTiP HP's Example notebooks(http://nbviewer.ipython.org/github/qutip/qutip-notebooks/blob/master/examples/landau-zener.ipynb) ,and I get the following error message. ; Could someone help please?. Error message:; ---------------------------------------------------------------------------; UnboundLocalError Traceback (most recent call last); <ipython-input-7-f9c1fc837f05> in <module>; 1 start_time = time.time(); ----> 2 p_ex = qubit_integrate(delta, eps0, A, omega, gamma1, gamma2, psi0, tlist, ""dynamics""); 3 print('dynamics: time elapsed = ' + str(time.time() - start_time)). <ipython-input-5-8172adafcb2d> in qubit_integrate(delta, eps0, A, omega, gamma1, gamma2, psi0, tlist, option); 33 if option == ""dynamics"":; 34 # evolve and calculate expectation values; ---> 35 output = mesolve(H, psi0, tlist, c_op_list, [sm.dag() * sm], H_args); 36 ; 37 return output.expect[0]. ~\Anaconda3\lib\site-packages\qutip\mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 252 ss = H; 253 elif isinstance(H, (list, Qobj, QobjEvo)):; --> 254 ss = _mesolve_QobjEvo(H, c_ops, tlist, args, options); 255 elif callable(H):; 256 ss = _mesolve_func_td(H, c_ops, rho0, tlist, args, options). ~\Anaconda3\lib\site-packages\qutip\mesolve.py in _mesolve_QobjEvo(H, c_ops, tlist, args, opt); 298 ; 299 nthread = opt.openmp_threads if opt.use_openmp else 0; --> 300 L_td.compile(omp=nthread); 301 ; 302 ss = SolverSystem(). ~\Anaconda3\lib\site-packages\qutip\qobjevo.py in compile(self, code, matched, dense, omp); 1557 self.args,; 1558 self.dynamics_args,; -> 1559 self.tlist); 1560 coeff_files.add(file_); 1561 self.coeff_files.append(file_). ~\Anaconda3\lib\site-packages\qutip\qobjevo_codegen.py in _compiled_coeffs(ops, args, dyn_args, tlist); 122 code = _make_code_4_cimport(ops, args, dyn_args, tlist); 123 coeff_obj, filename = _import_str(code, ""cqobjevo_",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1244
https://github.com/qutip/qutip/issues/1244:311,Availability,Error,Error,311,"**Describe the issue**; I tried to Execute the code ""Time-dependent master equation: Landau-Zener transitions"" in QuTiP HP's Example notebooks(http://nbviewer.ipython.org/github/qutip/qutip-notebooks/blob/master/examples/landau-zener.ipynb) ,and I get the following error message. ; Could someone help please?. Error message:; ---------------------------------------------------------------------------; UnboundLocalError Traceback (most recent call last); <ipython-input-7-f9c1fc837f05> in <module>; 1 start_time = time.time(); ----> 2 p_ex = qubit_integrate(delta, eps0, A, omega, gamma1, gamma2, psi0, tlist, ""dynamics""); 3 print('dynamics: time elapsed = ' + str(time.time() - start_time)). <ipython-input-5-8172adafcb2d> in qubit_integrate(delta, eps0, A, omega, gamma1, gamma2, psi0, tlist, option); 33 if option == ""dynamics"":; 34 # evolve and calculate expectation values; ---> 35 output = mesolve(H, psi0, tlist, c_op_list, [sm.dag() * sm], H_args); 36 ; 37 return output.expect[0]. ~\Anaconda3\lib\site-packages\qutip\mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 252 ss = H; 253 elif isinstance(H, (list, Qobj, QobjEvo)):; --> 254 ss = _mesolve_QobjEvo(H, c_ops, tlist, args, options); 255 elif callable(H):; 256 ss = _mesolve_func_td(H, c_ops, rho0, tlist, args, options). ~\Anaconda3\lib\site-packages\qutip\mesolve.py in _mesolve_QobjEvo(H, c_ops, tlist, args, opt); 298 ; 299 nthread = opt.openmp_threads if opt.use_openmp else 0; --> 300 L_td.compile(omp=nthread); 301 ; 302 ss = SolverSystem(). ~\Anaconda3\lib\site-packages\qutip\qobjevo.py in compile(self, code, matched, dense, omp); 1557 self.args,; 1558 self.dynamics_args,; -> 1559 self.tlist); 1560 coeff_files.add(file_); 1561 self.coeff_files.append(file_). ~\Anaconda3\lib\site-packages\qutip\qobjevo_codegen.py in _compiled_coeffs(ops, args, dyn_args, tlist); 122 code = _make_code_4_cimport(ops, args, dyn_args, tlist); 123 coeff_obj, filename = _import_str(code, ""cqobjevo_",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1244
https://github.com/qutip/qutip/issues/1244:58,Integrability,depend,dependent,58,"**Describe the issue**; I tried to Execute the code ""Time-dependent master equation: Landau-Zener transitions"" in QuTiP HP's Example notebooks(http://nbviewer.ipython.org/github/qutip/qutip-notebooks/blob/master/examples/landau-zener.ipynb) ,and I get the following error message. ; Could someone help please?. Error message:; ---------------------------------------------------------------------------; UnboundLocalError Traceback (most recent call last); <ipython-input-7-f9c1fc837f05> in <module>; 1 start_time = time.time(); ----> 2 p_ex = qubit_integrate(delta, eps0, A, omega, gamma1, gamma2, psi0, tlist, ""dynamics""); 3 print('dynamics: time elapsed = ' + str(time.time() - start_time)). <ipython-input-5-8172adafcb2d> in qubit_integrate(delta, eps0, A, omega, gamma1, gamma2, psi0, tlist, option); 33 if option == ""dynamics"":; 34 # evolve and calculate expectation values; ---> 35 output = mesolve(H, psi0, tlist, c_op_list, [sm.dag() * sm], H_args); 36 ; 37 return output.expect[0]. ~\Anaconda3\lib\site-packages\qutip\mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 252 ss = H; 253 elif isinstance(H, (list, Qobj, QobjEvo)):; --> 254 ss = _mesolve_QobjEvo(H, c_ops, tlist, args, options); 255 elif callable(H):; 256 ss = _mesolve_func_td(H, c_ops, rho0, tlist, args, options). ~\Anaconda3\lib\site-packages\qutip\mesolve.py in _mesolve_QobjEvo(H, c_ops, tlist, args, opt); 298 ; 299 nthread = opt.openmp_threads if opt.use_openmp else 0; --> 300 L_td.compile(omp=nthread); 301 ; 302 ss = SolverSystem(). ~\Anaconda3\lib\site-packages\qutip\qobjevo.py in compile(self, code, matched, dense, omp); 1557 self.args,; 1558 self.dynamics_args,; -> 1559 self.tlist); 1560 coeff_files.add(file_); 1561 self.coeff_files.append(file_). ~\Anaconda3\lib\site-packages\qutip\qobjevo_codegen.py in _compiled_coeffs(ops, args, dyn_args, tlist); 122 code = _make_code_4_cimport(ops, args, dyn_args, tlist); 123 coeff_obj, filename = _import_str(code, ""cqobjevo_",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1244
https://github.com/qutip/qutip/issues/1244:272,Integrability,message,message,272,"**Describe the issue**; I tried to Execute the code ""Time-dependent master equation: Landau-Zener transitions"" in QuTiP HP's Example notebooks(http://nbviewer.ipython.org/github/qutip/qutip-notebooks/blob/master/examples/landau-zener.ipynb) ,and I get the following error message. ; Could someone help please?. Error message:; ---------------------------------------------------------------------------; UnboundLocalError Traceback (most recent call last); <ipython-input-7-f9c1fc837f05> in <module>; 1 start_time = time.time(); ----> 2 p_ex = qubit_integrate(delta, eps0, A, omega, gamma1, gamma2, psi0, tlist, ""dynamics""); 3 print('dynamics: time elapsed = ' + str(time.time() - start_time)). <ipython-input-5-8172adafcb2d> in qubit_integrate(delta, eps0, A, omega, gamma1, gamma2, psi0, tlist, option); 33 if option == ""dynamics"":; 34 # evolve and calculate expectation values; ---> 35 output = mesolve(H, psi0, tlist, c_op_list, [sm.dag() * sm], H_args); 36 ; 37 return output.expect[0]. ~\Anaconda3\lib\site-packages\qutip\mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 252 ss = H; 253 elif isinstance(H, (list, Qobj, QobjEvo)):; --> 254 ss = _mesolve_QobjEvo(H, c_ops, tlist, args, options); 255 elif callable(H):; 256 ss = _mesolve_func_td(H, c_ops, rho0, tlist, args, options). ~\Anaconda3\lib\site-packages\qutip\mesolve.py in _mesolve_QobjEvo(H, c_ops, tlist, args, opt); 298 ; 299 nthread = opt.openmp_threads if opt.use_openmp else 0; --> 300 L_td.compile(omp=nthread); 301 ; 302 ss = SolverSystem(). ~\Anaconda3\lib\site-packages\qutip\qobjevo.py in compile(self, code, matched, dense, omp); 1557 self.args,; 1558 self.dynamics_args,; -> 1559 self.tlist); 1560 coeff_files.add(file_); 1561 self.coeff_files.append(file_). ~\Anaconda3\lib\site-packages\qutip\qobjevo_codegen.py in _compiled_coeffs(ops, args, dyn_args, tlist); 122 code = _make_code_4_cimport(ops, args, dyn_args, tlist); 123 coeff_obj, filename = _import_str(code, ""cqobjevo_",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1244
https://github.com/qutip/qutip/issues/1244:317,Integrability,message,message,317,"**Describe the issue**; I tried to Execute the code ""Time-dependent master equation: Landau-Zener transitions"" in QuTiP HP's Example notebooks(http://nbviewer.ipython.org/github/qutip/qutip-notebooks/blob/master/examples/landau-zener.ipynb) ,and I get the following error message. ; Could someone help please?. Error message:; ---------------------------------------------------------------------------; UnboundLocalError Traceback (most recent call last); <ipython-input-7-f9c1fc837f05> in <module>; 1 start_time = time.time(); ----> 2 p_ex = qubit_integrate(delta, eps0, A, omega, gamma1, gamma2, psi0, tlist, ""dynamics""); 3 print('dynamics: time elapsed = ' + str(time.time() - start_time)). <ipython-input-5-8172adafcb2d> in qubit_integrate(delta, eps0, A, omega, gamma1, gamma2, psi0, tlist, option); 33 if option == ""dynamics"":; 34 # evolve and calculate expectation values; ---> 35 output = mesolve(H, psi0, tlist, c_op_list, [sm.dag() * sm], H_args); 36 ; 37 return output.expect[0]. ~\Anaconda3\lib\site-packages\qutip\mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 252 ss = H; 253 elif isinstance(H, (list, Qobj, QobjEvo)):; --> 254 ss = _mesolve_QobjEvo(H, c_ops, tlist, args, options); 255 elif callable(H):; 256 ss = _mesolve_func_td(H, c_ops, rho0, tlist, args, options). ~\Anaconda3\lib\site-packages\qutip\mesolve.py in _mesolve_QobjEvo(H, c_ops, tlist, args, opt); 298 ; 299 nthread = opt.openmp_threads if opt.use_openmp else 0; --> 300 L_td.compile(omp=nthread); 301 ; 302 ss = SolverSystem(). ~\Anaconda3\lib\site-packages\qutip\qobjevo.py in compile(self, code, matched, dense, omp); 1557 self.args,; 1558 self.dynamics_args,; -> 1559 self.tlist); 1560 coeff_files.add(file_); 1561 self.coeff_files.append(file_). ~\Anaconda3\lib\site-packages\qutip\qobjevo_codegen.py in _compiled_coeffs(ops, args, dyn_args, tlist); 122 code = _make_code_4_cimport(ops, args, dyn_args, tlist); 123 coeff_obj, filename = _import_str(code, ""cqobjevo_",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1244
https://github.com/qutip/qutip/issues/1244:840,Modifiability,evolve,evolve,840,"**Describe the issue**; I tried to Execute the code ""Time-dependent master equation: Landau-Zener transitions"" in QuTiP HP's Example notebooks(http://nbviewer.ipython.org/github/qutip/qutip-notebooks/blob/master/examples/landau-zener.ipynb) ,and I get the following error message. ; Could someone help please?. Error message:; ---------------------------------------------------------------------------; UnboundLocalError Traceback (most recent call last); <ipython-input-7-f9c1fc837f05> in <module>; 1 start_time = time.time(); ----> 2 p_ex = qubit_integrate(delta, eps0, A, omega, gamma1, gamma2, psi0, tlist, ""dynamics""); 3 print('dynamics: time elapsed = ' + str(time.time() - start_time)). <ipython-input-5-8172adafcb2d> in qubit_integrate(delta, eps0, A, omega, gamma1, gamma2, psi0, tlist, option); 33 if option == ""dynamics"":; 34 # evolve and calculate expectation values; ---> 35 output = mesolve(H, psi0, tlist, c_op_list, [sm.dag() * sm], H_args); 36 ; 37 return output.expect[0]. ~\Anaconda3\lib\site-packages\qutip\mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 252 ss = H; 253 elif isinstance(H, (list, Qobj, QobjEvo)):; --> 254 ss = _mesolve_QobjEvo(H, c_ops, tlist, args, options); 255 elif callable(H):; 256 ss = _mesolve_func_td(H, c_ops, rho0, tlist, args, options). ~\Anaconda3\lib\site-packages\qutip\mesolve.py in _mesolve_QobjEvo(H, c_ops, tlist, args, opt); 298 ; 299 nthread = opt.openmp_threads if opt.use_openmp else 0; --> 300 L_td.compile(omp=nthread); 301 ; 302 ss = SolverSystem(). ~\Anaconda3\lib\site-packages\qutip\qobjevo.py in compile(self, code, matched, dense, omp); 1557 self.args,; 1558 self.dynamics_args,; -> 1559 self.tlist); 1560 coeff_files.add(file_); 1561 self.coeff_files.append(file_). ~\Anaconda3\lib\site-packages\qutip\qobjevo_codegen.py in _compiled_coeffs(ops, args, dyn_args, tlist); 122 code = _make_code_4_cimport(ops, args, dyn_args, tlist); 123 coeff_obj, filename = _import_str(code, ""cqobjevo_",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1244
https://github.com/qutip/qutip/issues/1244:2474,Modifiability,variab,variable,2474,"(H, psi0, tlist, c_op_list, [sm.dag() * sm], H_args); 36 ; 37 return output.expect[0]. ~\Anaconda3\lib\site-packages\qutip\mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 252 ss = H; 253 elif isinstance(H, (list, Qobj, QobjEvo)):; --> 254 ss = _mesolve_QobjEvo(H, c_ops, tlist, args, options); 255 elif callable(H):; 256 ss = _mesolve_func_td(H, c_ops, rho0, tlist, args, options). ~\Anaconda3\lib\site-packages\qutip\mesolve.py in _mesolve_QobjEvo(H, c_ops, tlist, args, opt); 298 ; 299 nthread = opt.openmp_threads if opt.use_openmp else 0; --> 300 L_td.compile(omp=nthread); 301 ; 302 ss = SolverSystem(). ~\Anaconda3\lib\site-packages\qutip\qobjevo.py in compile(self, code, matched, dense, omp); 1557 self.args,; 1558 self.dynamics_args,; -> 1559 self.tlist); 1560 coeff_files.add(file_); 1561 self.coeff_files.append(file_). ~\Anaconda3\lib\site-packages\qutip\qobjevo_codegen.py in _compiled_coeffs(ops, args, dyn_args, tlist); 122 code = _make_code_4_cimport(ops, args, dyn_args, tlist); 123 coeff_obj, filename = _import_str(code, ""cqobjevo_compiled_coeff_"",; --> 124 ""CompiledStrCoeff"", True); 125 return coeff_obj(ops, args, tlist, dyn_args), code, filename; 126 . ~\Anaconda3\lib\site-packages\qutip\qobjevo_codegen.py in _import_str(code, basefilename, obj_name, cythonfile); 80 if not import_list:; 81 raise Exception(""Could not convert string to importable function, ""; ---> 82 ""tmpfile:"" + try_file + ext) from e; 83 coeff_obj = import_list[0]; 84 return coeff_obj, try_file + ext. UnboundLocalError: local variable 'e' referenced before assignment. ------------------------------------------------------; Software	Version:; QuTiP	4.5.0; Numpy	1.18.1; SciPy	1.4.1; matplotlib	3.1.3; Cython	0.29.15; Number of CPUs	4; BLAS Info	INTEL MKL; IPython	7.12.0; Python	3.7.6 (default, Jan 8 2020, 20:23:39) [MSC v.1916 64 bit (AMD64)]; OS	nt [win32]; Sat May 02 19:27:58 2020 ???? (?W???); -------------------------------------------------------",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1244
https://github.com/qutip/qutip/pull/1245:351,Deployability,update,updates,351,**Description**; - Improve the documentation and use more understandable variable names.; - Add mcsolve as an optional solver for `Processor`; - The figure plotted by ``Processor.plot_pulse`` now has a better look; ![Figure_1](https://user-images.githubusercontent.com/12125783/80918476-7efdd880-8d65-11ea-8ff1-8e573cd1b3e6.png). **Changelog**; A few updates to the device simulator,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1245
https://github.com/qutip/qutip/pull/1245:73,Modifiability,variab,variable,73,**Description**; - Improve the documentation and use more understandable variable names.; - Add mcsolve as an optional solver for `Processor`; - The figure plotted by ``Processor.plot_pulse`` now has a better look; ![Figure_1](https://user-images.githubusercontent.com/12125783/80918476-7efdd880-8d65-11ea-8ff1-8e573cd1b3e6.png). **Changelog**; A few updates to the device simulator,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1245
https://github.com/qutip/qutip/issues/1246:303,Availability,Down,Downloading,303,"**Describe the bug**; It looks like the pypi package doesn't have cython as a dependency?. **To Reproduce**; Do a ""pip3 install cython"" on a fresh ubuntu 20.04 install (i had already installed numpy and scipy). ** This is what happens when I try it**; jevon@bb8:~$ pip3 install qutip; Collecting qutip; Downloading qutip-4.5.0.tar.gz (3.5 MB); |████████████████████████████████| 3.5 MB 509 kB/s ; ERROR: Command errored out with exit status 1:; command: /usr/bin/python3 -c 'import sys, setuptools, tokenize; sys.argv[0] = '""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""'; __file__='""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""';f=getattr(tokenize, '""'""'open'""'""', open)(__file__);code=f.read().replace('""'""'\r\n'""'""', '""'""'\n'""'""');f.close();exec(compile(code, __file__, '""'""'exec'""'""'))' egg_info --egg-base /tmp/pip-install-69anjthq/qutip/pip-egg-info; cwd: /tmp/pip-install-69anjthq/qutip/; Complete output (5 lines):; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/tmp/pip-install-69anjthq/qutip/setup.py"", line 52, in <module>; from Cython.Build import cythonize; ModuleNotFoundError: No module named 'Cython'; ----------------------------------------; ERROR: Command errored out with exit status 1: python setup.py egg_info Check the logs for full command output. ** Installing cython fixes it **. jevon@bb8:~$ pip3 install cython; Collecting cython; Downloading Cython-0.29.17-cp38-cp38-manylinux1_x86_64.whl (2.0 MB); |████████████████████████████████| 2.0 MB 721 kB/s ; Installing collected packages: cython; Successfully installed cython-0.29.17; jevon@bb8:~$ pip3 install qutip; Collecting qutip; Using cached qutip-4.5.0.tar.gz (3.5 MB); Requirement already satisfied: cython>=0.21 in ./.local/lib/python3.8/site-packages (from qutip) (0.29.17); Requirement already satisfied: numpy>=1.12 in ./.local/lib/python3.8/site-packages (from qutip) (1.18.3); Requirement already satisfied: scipy>=1.0 in ./.local/lib/python3.8/site-packages (from qutip) (",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1246
https://github.com/qutip/qutip/issues/1246:397,Availability,ERROR,ERROR,397,"**Describe the bug**; It looks like the pypi package doesn't have cython as a dependency?. **To Reproduce**; Do a ""pip3 install cython"" on a fresh ubuntu 20.04 install (i had already installed numpy and scipy). ** This is what happens when I try it**; jevon@bb8:~$ pip3 install qutip; Collecting qutip; Downloading qutip-4.5.0.tar.gz (3.5 MB); |████████████████████████████████| 3.5 MB 509 kB/s ; ERROR: Command errored out with exit status 1:; command: /usr/bin/python3 -c 'import sys, setuptools, tokenize; sys.argv[0] = '""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""'; __file__='""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""';f=getattr(tokenize, '""'""'open'""'""', open)(__file__);code=f.read().replace('""'""'\r\n'""'""', '""'""'\n'""'""');f.close();exec(compile(code, __file__, '""'""'exec'""'""'))' egg_info --egg-base /tmp/pip-install-69anjthq/qutip/pip-egg-info; cwd: /tmp/pip-install-69anjthq/qutip/; Complete output (5 lines):; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/tmp/pip-install-69anjthq/qutip/setup.py"", line 52, in <module>; from Cython.Build import cythonize; ModuleNotFoundError: No module named 'Cython'; ----------------------------------------; ERROR: Command errored out with exit status 1: python setup.py egg_info Check the logs for full command output. ** Installing cython fixes it **. jevon@bb8:~$ pip3 install cython; Collecting cython; Downloading Cython-0.29.17-cp38-cp38-manylinux1_x86_64.whl (2.0 MB); |████████████████████████████████| 2.0 MB 721 kB/s ; Installing collected packages: cython; Successfully installed cython-0.29.17; jevon@bb8:~$ pip3 install qutip; Collecting qutip; Using cached qutip-4.5.0.tar.gz (3.5 MB); Requirement already satisfied: cython>=0.21 in ./.local/lib/python3.8/site-packages (from qutip) (0.29.17); Requirement already satisfied: numpy>=1.12 in ./.local/lib/python3.8/site-packages (from qutip) (1.18.3); Requirement already satisfied: scipy>=1.0 in ./.local/lib/python3.8/site-packages (from qutip) (",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1246
https://github.com/qutip/qutip/issues/1246:412,Availability,error,errored,412,"**Describe the bug**; It looks like the pypi package doesn't have cython as a dependency?. **To Reproduce**; Do a ""pip3 install cython"" on a fresh ubuntu 20.04 install (i had already installed numpy and scipy). ** This is what happens when I try it**; jevon@bb8:~$ pip3 install qutip; Collecting qutip; Downloading qutip-4.5.0.tar.gz (3.5 MB); |████████████████████████████████| 3.5 MB 509 kB/s ; ERROR: Command errored out with exit status 1:; command: /usr/bin/python3 -c 'import sys, setuptools, tokenize; sys.argv[0] = '""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""'; __file__='""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""';f=getattr(tokenize, '""'""'open'""'""', open)(__file__);code=f.read().replace('""'""'\r\n'""'""', '""'""'\n'""'""');f.close();exec(compile(code, __file__, '""'""'exec'""'""'))' egg_info --egg-base /tmp/pip-install-69anjthq/qutip/pip-egg-info; cwd: /tmp/pip-install-69anjthq/qutip/; Complete output (5 lines):; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/tmp/pip-install-69anjthq/qutip/setup.py"", line 52, in <module>; from Cython.Build import cythonize; ModuleNotFoundError: No module named 'Cython'; ----------------------------------------; ERROR: Command errored out with exit status 1: python setup.py egg_info Check the logs for full command output. ** Installing cython fixes it **. jevon@bb8:~$ pip3 install cython; Collecting cython; Downloading Cython-0.29.17-cp38-cp38-manylinux1_x86_64.whl (2.0 MB); |████████████████████████████████| 2.0 MB 721 kB/s ; Installing collected packages: cython; Successfully installed cython-0.29.17; jevon@bb8:~$ pip3 install qutip; Collecting qutip; Using cached qutip-4.5.0.tar.gz (3.5 MB); Requirement already satisfied: cython>=0.21 in ./.local/lib/python3.8/site-packages (from qutip) (0.29.17); Requirement already satisfied: numpy>=1.12 in ./.local/lib/python3.8/site-packages (from qutip) (1.18.3); Requirement already satisfied: scipy>=1.0 in ./.local/lib/python3.8/site-packages (from qutip) (",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1246
https://github.com/qutip/qutip/issues/1246:1199,Availability,ERROR,ERROR,1199,"ad already installed numpy and scipy). ** This is what happens when I try it**; jevon@bb8:~$ pip3 install qutip; Collecting qutip; Downloading qutip-4.5.0.tar.gz (3.5 MB); |████████████████████████████████| 3.5 MB 509 kB/s ; ERROR: Command errored out with exit status 1:; command: /usr/bin/python3 -c 'import sys, setuptools, tokenize; sys.argv[0] = '""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""'; __file__='""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""';f=getattr(tokenize, '""'""'open'""'""', open)(__file__);code=f.read().replace('""'""'\r\n'""'""', '""'""'\n'""'""');f.close();exec(compile(code, __file__, '""'""'exec'""'""'))' egg_info --egg-base /tmp/pip-install-69anjthq/qutip/pip-egg-info; cwd: /tmp/pip-install-69anjthq/qutip/; Complete output (5 lines):; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/tmp/pip-install-69anjthq/qutip/setup.py"", line 52, in <module>; from Cython.Build import cythonize; ModuleNotFoundError: No module named 'Cython'; ----------------------------------------; ERROR: Command errored out with exit status 1: python setup.py egg_info Check the logs for full command output. ** Installing cython fixes it **. jevon@bb8:~$ pip3 install cython; Collecting cython; Downloading Cython-0.29.17-cp38-cp38-manylinux1_x86_64.whl (2.0 MB); |████████████████████████████████| 2.0 MB 721 kB/s ; Installing collected packages: cython; Successfully installed cython-0.29.17; jevon@bb8:~$ pip3 install qutip; Collecting qutip; Using cached qutip-4.5.0.tar.gz (3.5 MB); Requirement already satisfied: cython>=0.21 in ./.local/lib/python3.8/site-packages (from qutip) (0.29.17); Requirement already satisfied: numpy>=1.12 in ./.local/lib/python3.8/site-packages (from qutip) (1.18.3); Requirement already satisfied: scipy>=1.0 in ./.local/lib/python3.8/site-packages (from qutip) (1.4.1); Building wheels for collected packages: qutip; Building wheel for qutip (setup.py) ... done; Created wheel for qutip: filename=qutip-4.5.0-cp38-cp38-linux_x86_64.wh",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1246
https://github.com/qutip/qutip/issues/1246:1214,Availability,error,errored,1214,"ad already installed numpy and scipy). ** This is what happens when I try it**; jevon@bb8:~$ pip3 install qutip; Collecting qutip; Downloading qutip-4.5.0.tar.gz (3.5 MB); |████████████████████████████████| 3.5 MB 509 kB/s ; ERROR: Command errored out with exit status 1:; command: /usr/bin/python3 -c 'import sys, setuptools, tokenize; sys.argv[0] = '""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""'; __file__='""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""';f=getattr(tokenize, '""'""'open'""'""', open)(__file__);code=f.read().replace('""'""'\r\n'""'""', '""'""'\n'""'""');f.close();exec(compile(code, __file__, '""'""'exec'""'""'))' egg_info --egg-base /tmp/pip-install-69anjthq/qutip/pip-egg-info; cwd: /tmp/pip-install-69anjthq/qutip/; Complete output (5 lines):; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/tmp/pip-install-69anjthq/qutip/setup.py"", line 52, in <module>; from Cython.Build import cythonize; ModuleNotFoundError: No module named 'Cython'; ----------------------------------------; ERROR: Command errored out with exit status 1: python setup.py egg_info Check the logs for full command output. ** Installing cython fixes it **. jevon@bb8:~$ pip3 install cython; Collecting cython; Downloading Cython-0.29.17-cp38-cp38-manylinux1_x86_64.whl (2.0 MB); |████████████████████████████████| 2.0 MB 721 kB/s ; Installing collected packages: cython; Successfully installed cython-0.29.17; jevon@bb8:~$ pip3 install qutip; Collecting qutip; Using cached qutip-4.5.0.tar.gz (3.5 MB); Requirement already satisfied: cython>=0.21 in ./.local/lib/python3.8/site-packages (from qutip) (0.29.17); Requirement already satisfied: numpy>=1.12 in ./.local/lib/python3.8/site-packages (from qutip) (1.18.3); Requirement already satisfied: scipy>=1.0 in ./.local/lib/python3.8/site-packages (from qutip) (1.4.1); Building wheels for collected packages: qutip; Building wheel for qutip (setup.py) ... done; Created wheel for qutip: filename=qutip-4.5.0-cp38-cp38-linux_x86_64.wh",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1246
https://github.com/qutip/qutip/issues/1246:1398,Availability,Down,Downloading,1398,"5 MB 509 kB/s ; ERROR: Command errored out with exit status 1:; command: /usr/bin/python3 -c 'import sys, setuptools, tokenize; sys.argv[0] = '""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""'; __file__='""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""';f=getattr(tokenize, '""'""'open'""'""', open)(__file__);code=f.read().replace('""'""'\r\n'""'""', '""'""'\n'""'""');f.close();exec(compile(code, __file__, '""'""'exec'""'""'))' egg_info --egg-base /tmp/pip-install-69anjthq/qutip/pip-egg-info; cwd: /tmp/pip-install-69anjthq/qutip/; Complete output (5 lines):; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/tmp/pip-install-69anjthq/qutip/setup.py"", line 52, in <module>; from Cython.Build import cythonize; ModuleNotFoundError: No module named 'Cython'; ----------------------------------------; ERROR: Command errored out with exit status 1: python setup.py egg_info Check the logs for full command output. ** Installing cython fixes it **. jevon@bb8:~$ pip3 install cython; Collecting cython; Downloading Cython-0.29.17-cp38-cp38-manylinux1_x86_64.whl (2.0 MB); |████████████████████████████████| 2.0 MB 721 kB/s ; Installing collected packages: cython; Successfully installed cython-0.29.17; jevon@bb8:~$ pip3 install qutip; Collecting qutip; Using cached qutip-4.5.0.tar.gz (3.5 MB); Requirement already satisfied: cython>=0.21 in ./.local/lib/python3.8/site-packages (from qutip) (0.29.17); Requirement already satisfied: numpy>=1.12 in ./.local/lib/python3.8/site-packages (from qutip) (1.18.3); Requirement already satisfied: scipy>=1.0 in ./.local/lib/python3.8/site-packages (from qutip) (1.4.1); Building wheels for collected packages: qutip; Building wheel for qutip (setup.py) ... done; Created wheel for qutip: filename=qutip-4.5.0-cp38-cp38-linux_x86_64.whl size=17905114 sha256=3f461cbc07b40c0de96b709ea20bca495c7ffe1b6060a533a1ab733107c161ab; Stored in directory: /home/jevon/.cache/pip/wheels/3a/4d/bf/1c8e9f7874f26a6510d78790d3ba518c98e674e5771110fe1e; Successf",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1246
https://github.com/qutip/qutip/issues/1246:120,Deployability,install,install,120,"**Describe the bug**; It looks like the pypi package doesn't have cython as a dependency?. **To Reproduce**; Do a ""pip3 install cython"" on a fresh ubuntu 20.04 install (i had already installed numpy and scipy). ** This is what happens when I try it**; jevon@bb8:~$ pip3 install qutip; Collecting qutip; Downloading qutip-4.5.0.tar.gz (3.5 MB); |████████████████████████████████| 3.5 MB 509 kB/s ; ERROR: Command errored out with exit status 1:; command: /usr/bin/python3 -c 'import sys, setuptools, tokenize; sys.argv[0] = '""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""'; __file__='""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""';f=getattr(tokenize, '""'""'open'""'""', open)(__file__);code=f.read().replace('""'""'\r\n'""'""', '""'""'\n'""'""');f.close();exec(compile(code, __file__, '""'""'exec'""'""'))' egg_info --egg-base /tmp/pip-install-69anjthq/qutip/pip-egg-info; cwd: /tmp/pip-install-69anjthq/qutip/; Complete output (5 lines):; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/tmp/pip-install-69anjthq/qutip/setup.py"", line 52, in <module>; from Cython.Build import cythonize; ModuleNotFoundError: No module named 'Cython'; ----------------------------------------; ERROR: Command errored out with exit status 1: python setup.py egg_info Check the logs for full command output. ** Installing cython fixes it **. jevon@bb8:~$ pip3 install cython; Collecting cython; Downloading Cython-0.29.17-cp38-cp38-manylinux1_x86_64.whl (2.0 MB); |████████████████████████████████| 2.0 MB 721 kB/s ; Installing collected packages: cython; Successfully installed cython-0.29.17; jevon@bb8:~$ pip3 install qutip; Collecting qutip; Using cached qutip-4.5.0.tar.gz (3.5 MB); Requirement already satisfied: cython>=0.21 in ./.local/lib/python3.8/site-packages (from qutip) (0.29.17); Requirement already satisfied: numpy>=1.12 in ./.local/lib/python3.8/site-packages (from qutip) (1.18.3); Requirement already satisfied: scipy>=1.0 in ./.local/lib/python3.8/site-packages (from qutip) (",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1246
https://github.com/qutip/qutip/issues/1246:160,Deployability,install,install,160,"**Describe the bug**; It looks like the pypi package doesn't have cython as a dependency?. **To Reproduce**; Do a ""pip3 install cython"" on a fresh ubuntu 20.04 install (i had already installed numpy and scipy). ** This is what happens when I try it**; jevon@bb8:~$ pip3 install qutip; Collecting qutip; Downloading qutip-4.5.0.tar.gz (3.5 MB); |████████████████████████████████| 3.5 MB 509 kB/s ; ERROR: Command errored out with exit status 1:; command: /usr/bin/python3 -c 'import sys, setuptools, tokenize; sys.argv[0] = '""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""'; __file__='""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""';f=getattr(tokenize, '""'""'open'""'""', open)(__file__);code=f.read().replace('""'""'\r\n'""'""', '""'""'\n'""'""');f.close();exec(compile(code, __file__, '""'""'exec'""'""'))' egg_info --egg-base /tmp/pip-install-69anjthq/qutip/pip-egg-info; cwd: /tmp/pip-install-69anjthq/qutip/; Complete output (5 lines):; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/tmp/pip-install-69anjthq/qutip/setup.py"", line 52, in <module>; from Cython.Build import cythonize; ModuleNotFoundError: No module named 'Cython'; ----------------------------------------; ERROR: Command errored out with exit status 1: python setup.py egg_info Check the logs for full command output. ** Installing cython fixes it **. jevon@bb8:~$ pip3 install cython; Collecting cython; Downloading Cython-0.29.17-cp38-cp38-manylinux1_x86_64.whl (2.0 MB); |████████████████████████████████| 2.0 MB 721 kB/s ; Installing collected packages: cython; Successfully installed cython-0.29.17; jevon@bb8:~$ pip3 install qutip; Collecting qutip; Using cached qutip-4.5.0.tar.gz (3.5 MB); Requirement already satisfied: cython>=0.21 in ./.local/lib/python3.8/site-packages (from qutip) (0.29.17); Requirement already satisfied: numpy>=1.12 in ./.local/lib/python3.8/site-packages (from qutip) (1.18.3); Requirement already satisfied: scipy>=1.0 in ./.local/lib/python3.8/site-packages (from qutip) (",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1246
https://github.com/qutip/qutip/issues/1246:183,Deployability,install,installed,183,"**Describe the bug**; It looks like the pypi package doesn't have cython as a dependency?. **To Reproduce**; Do a ""pip3 install cython"" on a fresh ubuntu 20.04 install (i had already installed numpy and scipy). ** This is what happens when I try it**; jevon@bb8:~$ pip3 install qutip; Collecting qutip; Downloading qutip-4.5.0.tar.gz (3.5 MB); |████████████████████████████████| 3.5 MB 509 kB/s ; ERROR: Command errored out with exit status 1:; command: /usr/bin/python3 -c 'import sys, setuptools, tokenize; sys.argv[0] = '""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""'; __file__='""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""';f=getattr(tokenize, '""'""'open'""'""', open)(__file__);code=f.read().replace('""'""'\r\n'""'""', '""'""'\n'""'""');f.close();exec(compile(code, __file__, '""'""'exec'""'""'))' egg_info --egg-base /tmp/pip-install-69anjthq/qutip/pip-egg-info; cwd: /tmp/pip-install-69anjthq/qutip/; Complete output (5 lines):; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/tmp/pip-install-69anjthq/qutip/setup.py"", line 52, in <module>; from Cython.Build import cythonize; ModuleNotFoundError: No module named 'Cython'; ----------------------------------------; ERROR: Command errored out with exit status 1: python setup.py egg_info Check the logs for full command output. ** Installing cython fixes it **. jevon@bb8:~$ pip3 install cython; Collecting cython; Downloading Cython-0.29.17-cp38-cp38-manylinux1_x86_64.whl (2.0 MB); |████████████████████████████████| 2.0 MB 721 kB/s ; Installing collected packages: cython; Successfully installed cython-0.29.17; jevon@bb8:~$ pip3 install qutip; Collecting qutip; Using cached qutip-4.5.0.tar.gz (3.5 MB); Requirement already satisfied: cython>=0.21 in ./.local/lib/python3.8/site-packages (from qutip) (0.29.17); Requirement already satisfied: numpy>=1.12 in ./.local/lib/python3.8/site-packages (from qutip) (1.18.3); Requirement already satisfied: scipy>=1.0 in ./.local/lib/python3.8/site-packages (from qutip) (",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1246
https://github.com/qutip/qutip/issues/1246:270,Deployability,install,install,270,"**Describe the bug**; It looks like the pypi package doesn't have cython as a dependency?. **To Reproduce**; Do a ""pip3 install cython"" on a fresh ubuntu 20.04 install (i had already installed numpy and scipy). ** This is what happens when I try it**; jevon@bb8:~$ pip3 install qutip; Collecting qutip; Downloading qutip-4.5.0.tar.gz (3.5 MB); |████████████████████████████████| 3.5 MB 509 kB/s ; ERROR: Command errored out with exit status 1:; command: /usr/bin/python3 -c 'import sys, setuptools, tokenize; sys.argv[0] = '""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""'; __file__='""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""';f=getattr(tokenize, '""'""'open'""'""', open)(__file__);code=f.read().replace('""'""'\r\n'""'""', '""'""'\n'""'""');f.close();exec(compile(code, __file__, '""'""'exec'""'""'))' egg_info --egg-base /tmp/pip-install-69anjthq/qutip/pip-egg-info; cwd: /tmp/pip-install-69anjthq/qutip/; Complete output (5 lines):; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/tmp/pip-install-69anjthq/qutip/setup.py"", line 52, in <module>; from Cython.Build import cythonize; ModuleNotFoundError: No module named 'Cython'; ----------------------------------------; ERROR: Command errored out with exit status 1: python setup.py egg_info Check the logs for full command output. ** Installing cython fixes it **. jevon@bb8:~$ pip3 install cython; Collecting cython; Downloading Cython-0.29.17-cp38-cp38-manylinux1_x86_64.whl (2.0 MB); |████████████████████████████████| 2.0 MB 721 kB/s ; Installing collected packages: cython; Successfully installed cython-0.29.17; jevon@bb8:~$ pip3 install qutip; Collecting qutip; Using cached qutip-4.5.0.tar.gz (3.5 MB); Requirement already satisfied: cython>=0.21 in ./.local/lib/python3.8/site-packages (from qutip) (0.29.17); Requirement already satisfied: numpy>=1.12 in ./.local/lib/python3.8/site-packages (from qutip) (1.18.3); Requirement already satisfied: scipy>=1.0 in ./.local/lib/python3.8/site-packages (from qutip) (",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1246
https://github.com/qutip/qutip/issues/1246:537,Deployability,install,install-,537,"**Describe the bug**; It looks like the pypi package doesn't have cython as a dependency?. **To Reproduce**; Do a ""pip3 install cython"" on a fresh ubuntu 20.04 install (i had already installed numpy and scipy). ** This is what happens when I try it**; jevon@bb8:~$ pip3 install qutip; Collecting qutip; Downloading qutip-4.5.0.tar.gz (3.5 MB); |████████████████████████████████| 3.5 MB 509 kB/s ; ERROR: Command errored out with exit status 1:; command: /usr/bin/python3 -c 'import sys, setuptools, tokenize; sys.argv[0] = '""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""'; __file__='""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""';f=getattr(tokenize, '""'""'open'""'""', open)(__file__);code=f.read().replace('""'""'\r\n'""'""', '""'""'\n'""'""');f.close();exec(compile(code, __file__, '""'""'exec'""'""'))' egg_info --egg-base /tmp/pip-install-69anjthq/qutip/pip-egg-info; cwd: /tmp/pip-install-69anjthq/qutip/; Complete output (5 lines):; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/tmp/pip-install-69anjthq/qutip/setup.py"", line 52, in <module>; from Cython.Build import cythonize; ModuleNotFoundError: No module named 'Cython'; ----------------------------------------; ERROR: Command errored out with exit status 1: python setup.py egg_info Check the logs for full command output. ** Installing cython fixes it **. jevon@bb8:~$ pip3 install cython; Collecting cython; Downloading Cython-0.29.17-cp38-cp38-manylinux1_x86_64.whl (2.0 MB); |████████████████████████████████| 2.0 MB 721 kB/s ; Installing collected packages: cython; Successfully installed cython-0.29.17; jevon@bb8:~$ pip3 install qutip; Collecting qutip; Using cached qutip-4.5.0.tar.gz (3.5 MB); Requirement already satisfied: cython>=0.21 in ./.local/lib/python3.8/site-packages (from qutip) (0.29.17); Requirement already satisfied: numpy>=1.12 in ./.local/lib/python3.8/site-packages (from qutip) (1.18.3); Requirement already satisfied: scipy>=1.0 in ./.local/lib/python3.8/site-packages (from qutip) (",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1246
https://github.com/qutip/qutip/issues/1246:598,Deployability,install,install-,598,"**Describe the bug**; It looks like the pypi package doesn't have cython as a dependency?. **To Reproduce**; Do a ""pip3 install cython"" on a fresh ubuntu 20.04 install (i had already installed numpy and scipy). ** This is what happens when I try it**; jevon@bb8:~$ pip3 install qutip; Collecting qutip; Downloading qutip-4.5.0.tar.gz (3.5 MB); |████████████████████████████████| 3.5 MB 509 kB/s ; ERROR: Command errored out with exit status 1:; command: /usr/bin/python3 -c 'import sys, setuptools, tokenize; sys.argv[0] = '""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""'; __file__='""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""';f=getattr(tokenize, '""'""'open'""'""', open)(__file__);code=f.read().replace('""'""'\r\n'""'""', '""'""'\n'""'""');f.close();exec(compile(code, __file__, '""'""'exec'""'""'))' egg_info --egg-base /tmp/pip-install-69anjthq/qutip/pip-egg-info; cwd: /tmp/pip-install-69anjthq/qutip/; Complete output (5 lines):; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/tmp/pip-install-69anjthq/qutip/setup.py"", line 52, in <module>; from Cython.Build import cythonize; ModuleNotFoundError: No module named 'Cython'; ----------------------------------------; ERROR: Command errored out with exit status 1: python setup.py egg_info Check the logs for full command output. ** Installing cython fixes it **. jevon@bb8:~$ pip3 install cython; Collecting cython; Downloading Cython-0.29.17-cp38-cp38-manylinux1_x86_64.whl (2.0 MB); |████████████████████████████████| 2.0 MB 721 kB/s ; Installing collected packages: cython; Successfully installed cython-0.29.17; jevon@bb8:~$ pip3 install qutip; Collecting qutip; Using cached qutip-4.5.0.tar.gz (3.5 MB); Requirement already satisfied: cython>=0.21 in ./.local/lib/python3.8/site-packages (from qutip) (0.29.17); Requirement already satisfied: numpy>=1.12 in ./.local/lib/python3.8/site-packages (from qutip) (1.18.3); Requirement already satisfied: scipy>=1.0 in ./.local/lib/python3.8/site-packages (from qutip) (",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1246
https://github.com/qutip/qutip/issues/1246:825,Deployability,install,install-,825,"**Describe the bug**; It looks like the pypi package doesn't have cython as a dependency?. **To Reproduce**; Do a ""pip3 install cython"" on a fresh ubuntu 20.04 install (i had already installed numpy and scipy). ** This is what happens when I try it**; jevon@bb8:~$ pip3 install qutip; Collecting qutip; Downloading qutip-4.5.0.tar.gz (3.5 MB); |████████████████████████████████| 3.5 MB 509 kB/s ; ERROR: Command errored out with exit status 1:; command: /usr/bin/python3 -c 'import sys, setuptools, tokenize; sys.argv[0] = '""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""'; __file__='""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""';f=getattr(tokenize, '""'""'open'""'""', open)(__file__);code=f.read().replace('""'""'\r\n'""'""', '""'""'\n'""'""');f.close();exec(compile(code, __file__, '""'""'exec'""'""'))' egg_info --egg-base /tmp/pip-install-69anjthq/qutip/pip-egg-info; cwd: /tmp/pip-install-69anjthq/qutip/; Complete output (5 lines):; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/tmp/pip-install-69anjthq/qutip/setup.py"", line 52, in <module>; from Cython.Build import cythonize; ModuleNotFoundError: No module named 'Cython'; ----------------------------------------; ERROR: Command errored out with exit status 1: python setup.py egg_info Check the logs for full command output. ** Installing cython fixes it **. jevon@bb8:~$ pip3 install cython; Collecting cython; Downloading Cython-0.29.17-cp38-cp38-manylinux1_x86_64.whl (2.0 MB); |████████████████████████████████| 2.0 MB 721 kB/s ; Installing collected packages: cython; Successfully installed cython-0.29.17; jevon@bb8:~$ pip3 install qutip; Collecting qutip; Using cached qutip-4.5.0.tar.gz (3.5 MB); Requirement already satisfied: cython>=0.21 in ./.local/lib/python3.8/site-packages (from qutip) (0.29.17); Requirement already satisfied: numpy>=1.12 in ./.local/lib/python3.8/site-packages (from qutip) (1.18.3); Requirement already satisfied: scipy>=1.0 in ./.local/lib/python3.8/site-packages (from qutip) (",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1246
https://github.com/qutip/qutip/issues/1246:876,Deployability,install,install-,876,"**Describe the bug**; It looks like the pypi package doesn't have cython as a dependency?. **To Reproduce**; Do a ""pip3 install cython"" on a fresh ubuntu 20.04 install (i had already installed numpy and scipy). ** This is what happens when I try it**; jevon@bb8:~$ pip3 install qutip; Collecting qutip; Downloading qutip-4.5.0.tar.gz (3.5 MB); |████████████████████████████████| 3.5 MB 509 kB/s ; ERROR: Command errored out with exit status 1:; command: /usr/bin/python3 -c 'import sys, setuptools, tokenize; sys.argv[0] = '""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""'; __file__='""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""';f=getattr(tokenize, '""'""'open'""'""', open)(__file__);code=f.read().replace('""'""'\r\n'""'""', '""'""'\n'""'""');f.close();exec(compile(code, __file__, '""'""'exec'""'""'))' egg_info --egg-base /tmp/pip-install-69anjthq/qutip/pip-egg-info; cwd: /tmp/pip-install-69anjthq/qutip/; Complete output (5 lines):; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/tmp/pip-install-69anjthq/qutip/setup.py"", line 52, in <module>; from Cython.Build import cythonize; ModuleNotFoundError: No module named 'Cython'; ----------------------------------------; ERROR: Command errored out with exit status 1: python setup.py egg_info Check the logs for full command output. ** Installing cython fixes it **. jevon@bb8:~$ pip3 install cython; Collecting cython; Downloading Cython-0.29.17-cp38-cp38-manylinux1_x86_64.whl (2.0 MB); |████████████████████████████████| 2.0 MB 721 kB/s ; Installing collected packages: cython; Successfully installed cython-0.29.17; jevon@bb8:~$ pip3 install qutip; Collecting qutip; Using cached qutip-4.5.0.tar.gz (3.5 MB); Requirement already satisfied: cython>=0.21 in ./.local/lib/python3.8/site-packages (from qutip) (0.29.17); Requirement already satisfied: numpy>=1.12 in ./.local/lib/python3.8/site-packages (from qutip) (1.18.3); Requirement already satisfied: scipy>=1.0 in ./.local/lib/python3.8/site-packages (from qutip) (",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1246
https://github.com/qutip/qutip/issues/1246:1018,Deployability,install,install-,1018,"**Describe the bug**; It looks like the pypi package doesn't have cython as a dependency?. **To Reproduce**; Do a ""pip3 install cython"" on a fresh ubuntu 20.04 install (i had already installed numpy and scipy). ** This is what happens when I try it**; jevon@bb8:~$ pip3 install qutip; Collecting qutip; Downloading qutip-4.5.0.tar.gz (3.5 MB); |████████████████████████████████| 3.5 MB 509 kB/s ; ERROR: Command errored out with exit status 1:; command: /usr/bin/python3 -c 'import sys, setuptools, tokenize; sys.argv[0] = '""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""'; __file__='""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""';f=getattr(tokenize, '""'""'open'""'""', open)(__file__);code=f.read().replace('""'""'\r\n'""'""', '""'""'\n'""'""');f.close();exec(compile(code, __file__, '""'""'exec'""'""'))' egg_info --egg-base /tmp/pip-install-69anjthq/qutip/pip-egg-info; cwd: /tmp/pip-install-69anjthq/qutip/; Complete output (5 lines):; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/tmp/pip-install-69anjthq/qutip/setup.py"", line 52, in <module>; from Cython.Build import cythonize; ModuleNotFoundError: No module named 'Cython'; ----------------------------------------; ERROR: Command errored out with exit status 1: python setup.py egg_info Check the logs for full command output. ** Installing cython fixes it **. jevon@bb8:~$ pip3 install cython; Collecting cython; Downloading Cython-0.29.17-cp38-cp38-manylinux1_x86_64.whl (2.0 MB); |████████████████████████████████| 2.0 MB 721 kB/s ; Installing collected packages: cython; Successfully installed cython-0.29.17; jevon@bb8:~$ pip3 install qutip; Collecting qutip; Using cached qutip-4.5.0.tar.gz (3.5 MB); Requirement already satisfied: cython>=0.21 in ./.local/lib/python3.8/site-packages (from qutip) (0.29.17); Requirement already satisfied: numpy>=1.12 in ./.local/lib/python3.8/site-packages (from qutip) (1.18.3); Requirement already satisfied: scipy>=1.0 in ./.local/lib/python3.8/site-packages (from qutip) (",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1246
https://github.com/qutip/qutip/issues/1246:1314,Deployability,Install,Installing,1314,"tar.gz (3.5 MB); |████████████████████████████████| 3.5 MB 509 kB/s ; ERROR: Command errored out with exit status 1:; command: /usr/bin/python3 -c 'import sys, setuptools, tokenize; sys.argv[0] = '""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""'; __file__='""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""';f=getattr(tokenize, '""'""'open'""'""', open)(__file__);code=f.read().replace('""'""'\r\n'""'""', '""'""'\n'""'""');f.close();exec(compile(code, __file__, '""'""'exec'""'""'))' egg_info --egg-base /tmp/pip-install-69anjthq/qutip/pip-egg-info; cwd: /tmp/pip-install-69anjthq/qutip/; Complete output (5 lines):; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/tmp/pip-install-69anjthq/qutip/setup.py"", line 52, in <module>; from Cython.Build import cythonize; ModuleNotFoundError: No module named 'Cython'; ----------------------------------------; ERROR: Command errored out with exit status 1: python setup.py egg_info Check the logs for full command output. ** Installing cython fixes it **. jevon@bb8:~$ pip3 install cython; Collecting cython; Downloading Cython-0.29.17-cp38-cp38-manylinux1_x86_64.whl (2.0 MB); |████████████████████████████████| 2.0 MB 721 kB/s ; Installing collected packages: cython; Successfully installed cython-0.29.17; jevon@bb8:~$ pip3 install qutip; Collecting qutip; Using cached qutip-4.5.0.tar.gz (3.5 MB); Requirement already satisfied: cython>=0.21 in ./.local/lib/python3.8/site-packages (from qutip) (0.29.17); Requirement already satisfied: numpy>=1.12 in ./.local/lib/python3.8/site-packages (from qutip) (1.18.3); Requirement already satisfied: scipy>=1.0 in ./.local/lib/python3.8/site-packages (from qutip) (1.4.1); Building wheels for collected packages: qutip; Building wheel for qutip (setup.py) ... done; Created wheel for qutip: filename=qutip-4.5.0-cp38-cp38-linux_x86_64.whl size=17905114 sha256=3f461cbc07b40c0de96b709ea20bca495c7ffe1b6060a533a1ab733107c161ab; Stored in directory: /home/jevon/.cache/pip/wheels/3a/4d/bf/1c8e9",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1246
https://github.com/qutip/qutip/issues/1246:1363,Deployability,install,install,1363,"5 MB 509 kB/s ; ERROR: Command errored out with exit status 1:; command: /usr/bin/python3 -c 'import sys, setuptools, tokenize; sys.argv[0] = '""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""'; __file__='""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""';f=getattr(tokenize, '""'""'open'""'""', open)(__file__);code=f.read().replace('""'""'\r\n'""'""', '""'""'\n'""'""');f.close();exec(compile(code, __file__, '""'""'exec'""'""'))' egg_info --egg-base /tmp/pip-install-69anjthq/qutip/pip-egg-info; cwd: /tmp/pip-install-69anjthq/qutip/; Complete output (5 lines):; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/tmp/pip-install-69anjthq/qutip/setup.py"", line 52, in <module>; from Cython.Build import cythonize; ModuleNotFoundError: No module named 'Cython'; ----------------------------------------; ERROR: Command errored out with exit status 1: python setup.py egg_info Check the logs for full command output. ** Installing cython fixes it **. jevon@bb8:~$ pip3 install cython; Collecting cython; Downloading Cython-0.29.17-cp38-cp38-manylinux1_x86_64.whl (2.0 MB); |████████████████████████████████| 2.0 MB 721 kB/s ; Installing collected packages: cython; Successfully installed cython-0.29.17; jevon@bb8:~$ pip3 install qutip; Collecting qutip; Using cached qutip-4.5.0.tar.gz (3.5 MB); Requirement already satisfied: cython>=0.21 in ./.local/lib/python3.8/site-packages (from qutip) (0.29.17); Requirement already satisfied: numpy>=1.12 in ./.local/lib/python3.8/site-packages (from qutip) (1.18.3); Requirement already satisfied: scipy>=1.0 in ./.local/lib/python3.8/site-packages (from qutip) (1.4.1); Building wheels for collected packages: qutip; Building wheel for qutip (setup.py) ... done; Created wheel for qutip: filename=qutip-4.5.0-cp38-cp38-linux_x86_64.whl size=17905114 sha256=3f461cbc07b40c0de96b709ea20bca495c7ffe1b6060a533a1ab733107c161ab; Stored in directory: /home/jevon/.cache/pip/wheels/3a/4d/bf/1c8e9f7874f26a6510d78790d3ba518c98e674e5771110fe1e; Successf",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1246
https://github.com/qutip/qutip/issues/1246:1520,Deployability,Install,Installing,1520,"c 'import sys, setuptools, tokenize; sys.argv[0] = '""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""'; __file__='""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""';f=getattr(tokenize, '""'""'open'""'""', open)(__file__);code=f.read().replace('""'""'\r\n'""'""', '""'""'\n'""'""');f.close();exec(compile(code, __file__, '""'""'exec'""'""'))' egg_info --egg-base /tmp/pip-install-69anjthq/qutip/pip-egg-info; cwd: /tmp/pip-install-69anjthq/qutip/; Complete output (5 lines):; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/tmp/pip-install-69anjthq/qutip/setup.py"", line 52, in <module>; from Cython.Build import cythonize; ModuleNotFoundError: No module named 'Cython'; ----------------------------------------; ERROR: Command errored out with exit status 1: python setup.py egg_info Check the logs for full command output. ** Installing cython fixes it **. jevon@bb8:~$ pip3 install cython; Collecting cython; Downloading Cython-0.29.17-cp38-cp38-manylinux1_x86_64.whl (2.0 MB); |████████████████████████████████| 2.0 MB 721 kB/s ; Installing collected packages: cython; Successfully installed cython-0.29.17; jevon@bb8:~$ pip3 install qutip; Collecting qutip; Using cached qutip-4.5.0.tar.gz (3.5 MB); Requirement already satisfied: cython>=0.21 in ./.local/lib/python3.8/site-packages (from qutip) (0.29.17); Requirement already satisfied: numpy>=1.12 in ./.local/lib/python3.8/site-packages (from qutip) (1.18.3); Requirement already satisfied: scipy>=1.0 in ./.local/lib/python3.8/site-packages (from qutip) (1.4.1); Building wheels for collected packages: qutip; Building wheel for qutip (setup.py) ... done; Created wheel for qutip: filename=qutip-4.5.0-cp38-cp38-linux_x86_64.whl size=17905114 sha256=3f461cbc07b40c0de96b709ea20bca495c7ffe1b6060a533a1ab733107c161ab; Stored in directory: /home/jevon/.cache/pip/wheels/3a/4d/bf/1c8e9f7874f26a6510d78790d3ba518c98e674e5771110fe1e; Successfully built qutip; Installing collected packages: qutip; Successfully installed qutip-4.5.0",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1246
https://github.com/qutip/qutip/issues/1246:1572,Deployability,install,installed,1572,"c 'import sys, setuptools, tokenize; sys.argv[0] = '""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""'; __file__='""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""';f=getattr(tokenize, '""'""'open'""'""', open)(__file__);code=f.read().replace('""'""'\r\n'""'""', '""'""'\n'""'""');f.close();exec(compile(code, __file__, '""'""'exec'""'""'))' egg_info --egg-base /tmp/pip-install-69anjthq/qutip/pip-egg-info; cwd: /tmp/pip-install-69anjthq/qutip/; Complete output (5 lines):; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/tmp/pip-install-69anjthq/qutip/setup.py"", line 52, in <module>; from Cython.Build import cythonize; ModuleNotFoundError: No module named 'Cython'; ----------------------------------------; ERROR: Command errored out with exit status 1: python setup.py egg_info Check the logs for full command output. ** Installing cython fixes it **. jevon@bb8:~$ pip3 install cython; Collecting cython; Downloading Cython-0.29.17-cp38-cp38-manylinux1_x86_64.whl (2.0 MB); |████████████████████████████████| 2.0 MB 721 kB/s ; Installing collected packages: cython; Successfully installed cython-0.29.17; jevon@bb8:~$ pip3 install qutip; Collecting qutip; Using cached qutip-4.5.0.tar.gz (3.5 MB); Requirement already satisfied: cython>=0.21 in ./.local/lib/python3.8/site-packages (from qutip) (0.29.17); Requirement already satisfied: numpy>=1.12 in ./.local/lib/python3.8/site-packages (from qutip) (1.18.3); Requirement already satisfied: scipy>=1.0 in ./.local/lib/python3.8/site-packages (from qutip) (1.4.1); Building wheels for collected packages: qutip; Building wheel for qutip (setup.py) ... done; Created wheel for qutip: filename=qutip-4.5.0-cp38-cp38-linux_x86_64.whl size=17905114 sha256=3f461cbc07b40c0de96b709ea20bca495c7ffe1b6060a533a1ab733107c161ab; Stored in directory: /home/jevon/.cache/pip/wheels/3a/4d/bf/1c8e9f7874f26a6510d78790d3ba518c98e674e5771110fe1e; Successfully built qutip; Installing collected packages: qutip; Successfully installed qutip-4.5.0",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1246
https://github.com/qutip/qutip/issues/1246:1616,Deployability,install,install,1616,"c 'import sys, setuptools, tokenize; sys.argv[0] = '""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""'; __file__='""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""';f=getattr(tokenize, '""'""'open'""'""', open)(__file__);code=f.read().replace('""'""'\r\n'""'""', '""'""'\n'""'""');f.close();exec(compile(code, __file__, '""'""'exec'""'""'))' egg_info --egg-base /tmp/pip-install-69anjthq/qutip/pip-egg-info; cwd: /tmp/pip-install-69anjthq/qutip/; Complete output (5 lines):; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/tmp/pip-install-69anjthq/qutip/setup.py"", line 52, in <module>; from Cython.Build import cythonize; ModuleNotFoundError: No module named 'Cython'; ----------------------------------------; ERROR: Command errored out with exit status 1: python setup.py egg_info Check the logs for full command output. ** Installing cython fixes it **. jevon@bb8:~$ pip3 install cython; Collecting cython; Downloading Cython-0.29.17-cp38-cp38-manylinux1_x86_64.whl (2.0 MB); |████████████████████████████████| 2.0 MB 721 kB/s ; Installing collected packages: cython; Successfully installed cython-0.29.17; jevon@bb8:~$ pip3 install qutip; Collecting qutip; Using cached qutip-4.5.0.tar.gz (3.5 MB); Requirement already satisfied: cython>=0.21 in ./.local/lib/python3.8/site-packages (from qutip) (0.29.17); Requirement already satisfied: numpy>=1.12 in ./.local/lib/python3.8/site-packages (from qutip) (1.18.3); Requirement already satisfied: scipy>=1.0 in ./.local/lib/python3.8/site-packages (from qutip) (1.4.1); Building wheels for collected packages: qutip; Building wheel for qutip (setup.py) ... done; Created wheel for qutip: filename=qutip-4.5.0-cp38-cp38-linux_x86_64.whl size=17905114 sha256=3f461cbc07b40c0de96b709ea20bca495c7ffe1b6060a533a1ab733107c161ab; Stored in directory: /home/jevon/.cache/pip/wheels/3a/4d/bf/1c8e9f7874f26a6510d78790d3ba518c98e674e5771110fe1e; Successfully built qutip; Installing collected packages: qutip; Successfully installed qutip-4.5.0",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1246
https://github.com/qutip/qutip/issues/1246:2400,Deployability,Install,Installing,2400,"c 'import sys, setuptools, tokenize; sys.argv[0] = '""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""'; __file__='""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""';f=getattr(tokenize, '""'""'open'""'""', open)(__file__);code=f.read().replace('""'""'\r\n'""'""', '""'""'\n'""'""');f.close();exec(compile(code, __file__, '""'""'exec'""'""'))' egg_info --egg-base /tmp/pip-install-69anjthq/qutip/pip-egg-info; cwd: /tmp/pip-install-69anjthq/qutip/; Complete output (5 lines):; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/tmp/pip-install-69anjthq/qutip/setup.py"", line 52, in <module>; from Cython.Build import cythonize; ModuleNotFoundError: No module named 'Cython'; ----------------------------------------; ERROR: Command errored out with exit status 1: python setup.py egg_info Check the logs for full command output. ** Installing cython fixes it **. jevon@bb8:~$ pip3 install cython; Collecting cython; Downloading Cython-0.29.17-cp38-cp38-manylinux1_x86_64.whl (2.0 MB); |████████████████████████████████| 2.0 MB 721 kB/s ; Installing collected packages: cython; Successfully installed cython-0.29.17; jevon@bb8:~$ pip3 install qutip; Collecting qutip; Using cached qutip-4.5.0.tar.gz (3.5 MB); Requirement already satisfied: cython>=0.21 in ./.local/lib/python3.8/site-packages (from qutip) (0.29.17); Requirement already satisfied: numpy>=1.12 in ./.local/lib/python3.8/site-packages (from qutip) (1.18.3); Requirement already satisfied: scipy>=1.0 in ./.local/lib/python3.8/site-packages (from qutip) (1.4.1); Building wheels for collected packages: qutip; Building wheel for qutip (setup.py) ... done; Created wheel for qutip: filename=qutip-4.5.0-cp38-cp38-linux_x86_64.whl size=17905114 sha256=3f461cbc07b40c0de96b709ea20bca495c7ffe1b6060a533a1ab733107c161ab; Stored in directory: /home/jevon/.cache/pip/wheels/3a/4d/bf/1c8e9f7874f26a6510d78790d3ba518c98e674e5771110fe1e; Successfully built qutip; Installing collected packages: qutip; Successfully installed qutip-4.5.0",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1246
https://github.com/qutip/qutip/issues/1246:2451,Deployability,install,installed,2451,"c 'import sys, setuptools, tokenize; sys.argv[0] = '""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""'; __file__='""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""';f=getattr(tokenize, '""'""'open'""'""', open)(__file__);code=f.read().replace('""'""'\r\n'""'""', '""'""'\n'""'""');f.close();exec(compile(code, __file__, '""'""'exec'""'""'))' egg_info --egg-base /tmp/pip-install-69anjthq/qutip/pip-egg-info; cwd: /tmp/pip-install-69anjthq/qutip/; Complete output (5 lines):; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/tmp/pip-install-69anjthq/qutip/setup.py"", line 52, in <module>; from Cython.Build import cythonize; ModuleNotFoundError: No module named 'Cython'; ----------------------------------------; ERROR: Command errored out with exit status 1: python setup.py egg_info Check the logs for full command output. ** Installing cython fixes it **. jevon@bb8:~$ pip3 install cython; Collecting cython; Downloading Cython-0.29.17-cp38-cp38-manylinux1_x86_64.whl (2.0 MB); |████████████████████████████████| 2.0 MB 721 kB/s ; Installing collected packages: cython; Successfully installed cython-0.29.17; jevon@bb8:~$ pip3 install qutip; Collecting qutip; Using cached qutip-4.5.0.tar.gz (3.5 MB); Requirement already satisfied: cython>=0.21 in ./.local/lib/python3.8/site-packages (from qutip) (0.29.17); Requirement already satisfied: numpy>=1.12 in ./.local/lib/python3.8/site-packages (from qutip) (1.18.3); Requirement already satisfied: scipy>=1.0 in ./.local/lib/python3.8/site-packages (from qutip) (1.4.1); Building wheels for collected packages: qutip; Building wheel for qutip (setup.py) ... done; Created wheel for qutip: filename=qutip-4.5.0-cp38-cp38-linux_x86_64.whl size=17905114 sha256=3f461cbc07b40c0de96b709ea20bca495c7ffe1b6060a533a1ab733107c161ab; Stored in directory: /home/jevon/.cache/pip/wheels/3a/4d/bf/1c8e9f7874f26a6510d78790d3ba518c98e674e5771110fe1e; Successfully built qutip; Installing collected packages: qutip; Successfully installed qutip-4.5.0",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1246
https://github.com/qutip/qutip/issues/1246:78,Integrability,depend,dependency,78,"**Describe the bug**; It looks like the pypi package doesn't have cython as a dependency?. **To Reproduce**; Do a ""pip3 install cython"" on a fresh ubuntu 20.04 install (i had already installed numpy and scipy). ** This is what happens when I try it**; jevon@bb8:~$ pip3 install qutip; Collecting qutip; Downloading qutip-4.5.0.tar.gz (3.5 MB); |████████████████████████████████| 3.5 MB 509 kB/s ; ERROR: Command errored out with exit status 1:; command: /usr/bin/python3 -c 'import sys, setuptools, tokenize; sys.argv[0] = '""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""'; __file__='""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""';f=getattr(tokenize, '""'""'open'""'""', open)(__file__);code=f.read().replace('""'""'\r\n'""'""', '""'""'\n'""'""');f.close();exec(compile(code, __file__, '""'""'exec'""'""'))' egg_info --egg-base /tmp/pip-install-69anjthq/qutip/pip-egg-info; cwd: /tmp/pip-install-69anjthq/qutip/; Complete output (5 lines):; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/tmp/pip-install-69anjthq/qutip/setup.py"", line 52, in <module>; from Cython.Build import cythonize; ModuleNotFoundError: No module named 'Cython'; ----------------------------------------; ERROR: Command errored out with exit status 1: python setup.py egg_info Check the logs for full command output. ** Installing cython fixes it **. jevon@bb8:~$ pip3 install cython; Collecting cython; Downloading Cython-0.29.17-cp38-cp38-manylinux1_x86_64.whl (2.0 MB); |████████████████████████████████| 2.0 MB 721 kB/s ; Installing collected packages: cython; Successfully installed cython-0.29.17; jevon@bb8:~$ pip3 install qutip; Collecting qutip; Using cached qutip-4.5.0.tar.gz (3.5 MB); Requirement already satisfied: cython>=0.21 in ./.local/lib/python3.8/site-packages (from qutip) (0.29.17); Requirement already satisfied: numpy>=1.12 in ./.local/lib/python3.8/site-packages (from qutip) (1.18.3); Requirement already satisfied: scipy>=1.0 in ./.local/lib/python3.8/site-packages (from qutip) (",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1246
https://github.com/qutip/qutip/issues/1246:1655,Performance,cache,cached,1655,"c 'import sys, setuptools, tokenize; sys.argv[0] = '""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""'; __file__='""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""';f=getattr(tokenize, '""'""'open'""'""', open)(__file__);code=f.read().replace('""'""'\r\n'""'""', '""'""'\n'""'""');f.close();exec(compile(code, __file__, '""'""'exec'""'""'))' egg_info --egg-base /tmp/pip-install-69anjthq/qutip/pip-egg-info; cwd: /tmp/pip-install-69anjthq/qutip/; Complete output (5 lines):; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/tmp/pip-install-69anjthq/qutip/setup.py"", line 52, in <module>; from Cython.Build import cythonize; ModuleNotFoundError: No module named 'Cython'; ----------------------------------------; ERROR: Command errored out with exit status 1: python setup.py egg_info Check the logs for full command output. ** Installing cython fixes it **. jevon@bb8:~$ pip3 install cython; Collecting cython; Downloading Cython-0.29.17-cp38-cp38-manylinux1_x86_64.whl (2.0 MB); |████████████████████████████████| 2.0 MB 721 kB/s ; Installing collected packages: cython; Successfully installed cython-0.29.17; jevon@bb8:~$ pip3 install qutip; Collecting qutip; Using cached qutip-4.5.0.tar.gz (3.5 MB); Requirement already satisfied: cython>=0.21 in ./.local/lib/python3.8/site-packages (from qutip) (0.29.17); Requirement already satisfied: numpy>=1.12 in ./.local/lib/python3.8/site-packages (from qutip) (1.18.3); Requirement already satisfied: scipy>=1.0 in ./.local/lib/python3.8/site-packages (from qutip) (1.4.1); Building wheels for collected packages: qutip; Building wheel for qutip (setup.py) ... done; Created wheel for qutip: filename=qutip-4.5.0-cp38-cp38-linux_x86_64.whl size=17905114 sha256=3f461cbc07b40c0de96b709ea20bca495c7ffe1b6060a533a1ab733107c161ab; Stored in directory: /home/jevon/.cache/pip/wheels/3a/4d/bf/1c8e9f7874f26a6510d78790d3ba518c98e674e5771110fe1e; Successfully built qutip; Installing collected packages: qutip; Successfully installed qutip-4.5.0",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1246
https://github.com/qutip/qutip/issues/1246:2296,Performance,cache,cache,2296,"c 'import sys, setuptools, tokenize; sys.argv[0] = '""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""'; __file__='""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""';f=getattr(tokenize, '""'""'open'""'""', open)(__file__);code=f.read().replace('""'""'\r\n'""'""', '""'""'\n'""'""');f.close();exec(compile(code, __file__, '""'""'exec'""'""'))' egg_info --egg-base /tmp/pip-install-69anjthq/qutip/pip-egg-info; cwd: /tmp/pip-install-69anjthq/qutip/; Complete output (5 lines):; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/tmp/pip-install-69anjthq/qutip/setup.py"", line 52, in <module>; from Cython.Build import cythonize; ModuleNotFoundError: No module named 'Cython'; ----------------------------------------; ERROR: Command errored out with exit status 1: python setup.py egg_info Check the logs for full command output. ** Installing cython fixes it **. jevon@bb8:~$ pip3 install cython; Collecting cython; Downloading Cython-0.29.17-cp38-cp38-manylinux1_x86_64.whl (2.0 MB); |████████████████████████████████| 2.0 MB 721 kB/s ; Installing collected packages: cython; Successfully installed cython-0.29.17; jevon@bb8:~$ pip3 install qutip; Collecting qutip; Using cached qutip-4.5.0.tar.gz (3.5 MB); Requirement already satisfied: cython>=0.21 in ./.local/lib/python3.8/site-packages (from qutip) (0.29.17); Requirement already satisfied: numpy>=1.12 in ./.local/lib/python3.8/site-packages (from qutip) (1.18.3); Requirement already satisfied: scipy>=1.0 in ./.local/lib/python3.8/site-packages (from qutip) (1.4.1); Building wheels for collected packages: qutip; Building wheel for qutip (setup.py) ... done; Created wheel for qutip: filename=qutip-4.5.0-cp38-cp38-linux_x86_64.whl size=17905114 sha256=3f461cbc07b40c0de96b709ea20bca495c7ffe1b6060a533a1ab733107c161ab; Stored in directory: /home/jevon/.cache/pip/wheels/3a/4d/bf/1c8e9f7874f26a6510d78790d3ba518c98e674e5771110fe1e; Successfully built qutip; Installing collected packages: qutip; Successfully installed qutip-4.5.0",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1246
https://github.com/qutip/qutip/issues/1246:1281,Testability,log,logs,1281," Collecting qutip; Downloading qutip-4.5.0.tar.gz (3.5 MB); |████████████████████████████████| 3.5 MB 509 kB/s ; ERROR: Command errored out with exit status 1:; command: /usr/bin/python3 -c 'import sys, setuptools, tokenize; sys.argv[0] = '""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""'; __file__='""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""';f=getattr(tokenize, '""'""'open'""'""', open)(__file__);code=f.read().replace('""'""'\r\n'""'""', '""'""'\n'""'""');f.close();exec(compile(code, __file__, '""'""'exec'""'""'))' egg_info --egg-base /tmp/pip-install-69anjthq/qutip/pip-egg-info; cwd: /tmp/pip-install-69anjthq/qutip/; Complete output (5 lines):; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/tmp/pip-install-69anjthq/qutip/setup.py"", line 52, in <module>; from Cython.Build import cythonize; ModuleNotFoundError: No module named 'Cython'; ----------------------------------------; ERROR: Command errored out with exit status 1: python setup.py egg_info Check the logs for full command output. ** Installing cython fixes it **. jevon@bb8:~$ pip3 install cython; Collecting cython; Downloading Cython-0.29.17-cp38-cp38-manylinux1_x86_64.whl (2.0 MB); |████████████████████████████████| 2.0 MB 721 kB/s ; Installing collected packages: cython; Successfully installed cython-0.29.17; jevon@bb8:~$ pip3 install qutip; Collecting qutip; Using cached qutip-4.5.0.tar.gz (3.5 MB); Requirement already satisfied: cython>=0.21 in ./.local/lib/python3.8/site-packages (from qutip) (0.29.17); Requirement already satisfied: numpy>=1.12 in ./.local/lib/python3.8/site-packages (from qutip) (1.18.3); Requirement already satisfied: scipy>=1.0 in ./.local/lib/python3.8/site-packages (from qutip) (1.4.1); Building wheels for collected packages: qutip; Building wheel for qutip (setup.py) ... done; Created wheel for qutip: filename=qutip-4.5.0-cp38-cp38-linux_x86_64.whl size=17905114 sha256=3f461cbc07b40c0de96b709ea20bca495c7ffe1b6060a533a1ab733107c161ab; Stored in directory: /h",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1246
https://github.com/qutip/qutip/issues/1247:1541,Deployability,Install,Installed,1541,"**Describe the bug**; Qutip can't handle number smaller than about 1e-15 in its operators?. **To Reproduce**; Please provide a minimal working example. For instance:. ```; import qutip. hbar = 1.05e-34. #this one makes sense; print(qutip.sigmaz()); #Result; # Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; # Qobj data =; # [[ 1. 0.]; # [ 0. -1.]]. # this is zero?; Sz = hbar*qutip.sigmaz(); print(Sz); # Result; # Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; # Qobj data =; # [[ 0. 0.]; # [ 0. 0.]]. # looks like it really is zero; print(1e34*Sz); # Result; # Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; # Qobj data =; # [[ 0. 0.]; # [ 0. 0.]]; ```; **Expected behavior**; I would have thought that you could store any double precision number in qutip array. **Your Environment**; ```; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.0; Numpy Version: 1.18.3; Scipy Version: 1.4.1; Cython Version: 0.29.17; Matplotlib Version: 3.2.1; Python Version: 3.8.2; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64); Installation path: /home/jevon/.local/lib/python3.8/site-packages/qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1247
https://github.com/qutip/qutip/issues/1247:1612,Deployability,Install,Installation,1612,"**Describe the bug**; Qutip can't handle number smaller than about 1e-15 in its operators?. **To Reproduce**; Please provide a minimal working example. For instance:. ```; import qutip. hbar = 1.05e-34. #this one makes sense; print(qutip.sigmaz()); #Result; # Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; # Qobj data =; # [[ 1. 0.]; # [ 0. -1.]]. # this is zero?; Sz = hbar*qutip.sigmaz(); print(Sz); # Result; # Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; # Qobj data =; # [[ 0. 0.]; # [ 0. 0.]]. # looks like it really is zero; print(1e34*Sz); # Result; # Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; # Qobj data =; # [[ 0. 0.]; # [ 0. 0.]]; ```; **Expected behavior**; I would have thought that you could store any double precision number in qutip array. **Your Environment**; ```; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.0; Numpy Version: 1.18.3; Scipy Version: 1.4.1; Cython Version: 0.29.17; Matplotlib Version: 3.2.1; Python Version: 3.8.2; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64); Installation path: /home/jevon/.local/lib/python3.8/site-packages/qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1247
https://github.com/qutip/qutip/pull/1248:109,Availability,error,errors,109,**Description**; 1) Changes in floquet_master_equation_rates to make it faster.; 2) Correction transposition errors in floquet_master_equation_tensor and changes to make it faster. NB: This version works only for 1 rate matrix but could be generalized easily.; 3) Correction in floquet_markov_mesolve. The basis change that returns the results in the computational had errors. NB: Results are still given in the interaction picture. **Related issues or PRs**. **Changelog**; Fixed transposition error in floquet_master_equation_tensor; Fixed basis change error in floquet_markov_mesolve; Made floquet_master_equation_rates faster; Made floquet_master_equation_tensor faster,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1248
https://github.com/qutip/qutip/pull/1248:369,Availability,error,errors,369,**Description**; 1) Changes in floquet_master_equation_rates to make it faster.; 2) Correction transposition errors in floquet_master_equation_tensor and changes to make it faster. NB: This version works only for 1 rate matrix but could be generalized easily.; 3) Correction in floquet_markov_mesolve. The basis change that returns the results in the computational had errors. NB: Results are still given in the interaction picture. **Related issues or PRs**. **Changelog**; Fixed transposition error in floquet_master_equation_tensor; Fixed basis change error in floquet_markov_mesolve; Made floquet_master_equation_rates faster; Made floquet_master_equation_tensor faster,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1248
https://github.com/qutip/qutip/pull/1248:495,Availability,error,error,495,**Description**; 1) Changes in floquet_master_equation_rates to make it faster.; 2) Correction transposition errors in floquet_master_equation_tensor and changes to make it faster. NB: This version works only for 1 rate matrix but could be generalized easily.; 3) Correction in floquet_markov_mesolve. The basis change that returns the results in the computational had errors. NB: Results are still given in the interaction picture. **Related issues or PRs**. **Changelog**; Fixed transposition error in floquet_master_equation_tensor; Fixed basis change error in floquet_markov_mesolve; Made floquet_master_equation_rates faster; Made floquet_master_equation_tensor faster,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1248
https://github.com/qutip/qutip/pull/1248:555,Availability,error,error,555,**Description**; 1) Changes in floquet_master_equation_rates to make it faster.; 2) Correction transposition errors in floquet_master_equation_tensor and changes to make it faster. NB: This version works only for 1 rate matrix but could be generalized easily.; 3) Correction in floquet_markov_mesolve. The basis change that returns the results in the computational had errors. NB: Results are still given in the interaction picture. **Related issues or PRs**. **Changelog**; Fixed transposition error in floquet_master_equation_tensor; Fixed basis change error in floquet_markov_mesolve; Made floquet_master_equation_rates faster; Made floquet_master_equation_tensor faster,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1248
https://github.com/qutip/qutip/pull/1249:93,Deployability,update,updates,93,"This is the base PR for the split-up of #1181. This one puts in all the helper functions and updates to previously converted files that are present in that PR, and needs to be merged first before any of the others can be merged. The commits are tidied up and rebased onto `master`. This is the base PR for #1250, #1251 and #1252. **Changelog**; Add pytest helper functions for large-scale test refactoring",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1249
https://github.com/qutip/qutip/pull/1249:394,Modifiability,refactor,refactoring,394,"This is the base PR for the split-up of #1181. This one puts in all the helper functions and updates to previously converted files that are present in that PR, and needs to be merged first before any of the others can be merged. The commits are tidied up and rebased onto `master`. This is the base PR for #1250, #1251 and #1252. **Changelog**; Add pytest helper functions for large-scale test refactoring",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1249
https://github.com/qutip/qutip/pull/1249:389,Testability,test,test,389,"This is the base PR for the split-up of #1181. This one puts in all the helper functions and updates to previously converted files that are present in that PR, and needs to be merged first before any of the others can be merged. The commits are tidied up and rebased onto `master`. This is the base PR for #1250, #1251 and #1252. **Changelog**; Add pytest helper functions for large-scale test refactoring",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1249
https://github.com/qutip/qutip/pull/1250:350,Modifiability,refactor,refactor,350,"These are the files that Eric (@Ericgig) was checking in #1181, but the commits are tidied up and rebased onto `master`. I'll copy over the review comments in that PR that haven't been actioned yet. The potential merge conflict with `test_mcsolve.py` is fixed. This is based on #1249, and that one needs to be merged first. **Changelog**; Major test refactor into a pytest style.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1250
https://github.com/qutip/qutip/pull/1250:345,Testability,test,test,345,"These are the files that Eric (@Ericgig) was checking in #1181, but the commits are tidied up and rebased onto `master`. I'll copy over the review comments in that PR that haven't been actioned yet. The potential merge conflict with `test_mcsolve.py` is fixed. This is based on #1249, and that one needs to be merged first. **Changelog**; Major test refactor into a pytest style.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1250
https://github.com/qutip/qutip/pull/1251:320,Modifiability,refactor,refactor,320,"These are the files that Boxi (@BoxiLi) was checking in #1181, but the commits are tidied up and rebased onto `master`. The merge conflict in `test_gates.py` that's present in #1181 is fixed (with all the tests safely maintained). This is based on #1249, and that one needs to be merged first. **Changelog**; Major test refactor into a pytest style.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1251
https://github.com/qutip/qutip/pull/1251:211,Safety,safe,safely,211,"These are the files that Boxi (@BoxiLi) was checking in #1181, but the commits are tidied up and rebased onto `master`. The merge conflict in `test_gates.py` that's present in #1181 is fixed (with all the tests safely maintained). This is based on #1249, and that one needs to be merged first. **Changelog**; Major test refactor into a pytest style.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1251
https://github.com/qutip/qutip/pull/1251:205,Testability,test,tests,205,"These are the files that Boxi (@BoxiLi) was checking in #1181, but the commits are tidied up and rebased onto `master`. The merge conflict in `test_gates.py` that's present in #1181 is fixed (with all the tests safely maintained). This is based on #1249, and that one needs to be merged first. **Changelog**; Major test refactor into a pytest style.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1251
https://github.com/qutip/qutip/pull/1251:315,Testability,test,test,315,"These are the files that Boxi (@BoxiLi) was checking in #1181, but the commits are tidied up and rebased onto `master`. The merge conflict in `test_gates.py` that's present in #1181 is fixed (with all the tests safely maintained). This is based on #1249, and that one needs to be merged first. **Changelog**; Major test refactor into a pytest style.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1251
https://github.com/qutip/qutip/pull/1252:259,Modifiability,refactor,refactor,259,"These are all the remaining files from #1181 that neither Eric nor Boxi had explicitly said they were checking, with the commits all tidied up and rebased onto `master`. This is based on #1249, and that one needs to be merged first. **Changelog**; Major test refactor into a pytest style.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1252
https://github.com/qutip/qutip/pull/1252:254,Testability,test,test,254,"These are all the remaining files from #1181 that neither Eric nor Boxi had explicitly said they were checking, with the commits all tidied up and rebased onto `master`. This is based on #1249, and that one needs to be merged first. **Changelog**; Major test refactor into a pytest style.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1252
https://github.com/qutip/qutip/issues/1253:275,Performance,perform,performing,275,"I have recently started to use QuTiP to compute unitary and Hamiltonian evolutions. Most of the calculations involved Hamiltonians (or circuits) defined on separate regions of the Hilbert space plus some other Hamiltonians used to couple the different systems together. When performing the simulations I have found that the requirement that Qobjs must have the same dims attribute to be summed or multiplied tends to make the code quite convoluted (the convolution might also come from my inexperience with QuTiP). For example (I will use circuits but the same issues applies to Hamiltonians). Let |psi> be a random 4-qubit state and C a random unitary on the first two qubits. In order to compute C|psi> one must specify the tensor structure of the random objects and not use qeye(8) but the tensor product of three qeye(2):. `C = tensor(rand_unitary_haar(4, dims = [[2,2],[2,2]]), tensor(qeye(2),qeye(2),qeye(2)))`; `psi = rand_ket(32, dims = [[2,2,2,2,2], [1,1,1,1,1]])`. I understand that the tensor product structure in the Qobj class might yield lots of advantages but it might be interesting to consider if in some cases it is possible to allow the summation or multiplication of Qobs of different dims but with the same shape. In this case, the above example would simplify to:. `C = tensor(rand_unitary_haar(4), qeye(8))`; `psi = rand_ket(32)`",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1253
https://github.com/qutip/qutip/issues/1253:1273,Usability,simpl,simplify,1273,"I have recently started to use QuTiP to compute unitary and Hamiltonian evolutions. Most of the calculations involved Hamiltonians (or circuits) defined on separate regions of the Hilbert space plus some other Hamiltonians used to couple the different systems together. When performing the simulations I have found that the requirement that Qobjs must have the same dims attribute to be summed or multiplied tends to make the code quite convoluted (the convolution might also come from my inexperience with QuTiP). For example (I will use circuits but the same issues applies to Hamiltonians). Let |psi> be a random 4-qubit state and C a random unitary on the first two qubits. In order to compute C|psi> one must specify the tensor structure of the random objects and not use qeye(8) but the tensor product of three qeye(2):. `C = tensor(rand_unitary_haar(4, dims = [[2,2],[2,2]]), tensor(qeye(2),qeye(2),qeye(2)))`; `psi = rand_ket(32, dims = [[2,2,2,2,2], [1,1,1,1,1]])`. I understand that the tensor product structure in the Qobj class might yield lots of advantages but it might be interesting to consider if in some cases it is possible to allow the summation or multiplication of Qobs of different dims but with the same shape. In this case, the above example would simplify to:. `C = tensor(rand_unitary_haar(4), qeye(8))`; `psi = rand_ket(32)`",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1253
https://github.com/qutip/qutip/issues/1254:990,Deployability,patch,patch,990,"Dear qutip developers,. In the documentation of version 4.5 the c_ops argument is said to support callback functions, however they are not implemented in that version and as far as I can tell neither in the current branch. It would be nice to have this feature added to allow for arbitrary time-dependent Lindbladians to be implemented. There are cases where Lindbladians cannot simply be described as the product of a time-dependent scalar and a time-independent Lindbladian, this is where the callback becomes useful. I envisage a single callback passed to c_ops as being useful, where the user has to manually add multiple decoherence channels. This way, arbitrary data can be passed through the args parameter of the callback to build the operators at a given time step. I believe this would also allow channel cross-correlations to be implemented too. I have hacked my local copy of qutip 4.5 to check this can in principle be done with mesolve, and it has worked. Here is a link to a patch file that shows the changes I made to get this working:; https://pastebin.com/iZCgBbNQ. I am happy to add this functionality properly to a clone and make a pull request.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1254
https://github.com/qutip/qutip/issues/1254:295,Integrability,depend,dependent,295,"Dear qutip developers,. In the documentation of version 4.5 the c_ops argument is said to support callback functions, however they are not implemented in that version and as far as I can tell neither in the current branch. It would be nice to have this feature added to allow for arbitrary time-dependent Lindbladians to be implemented. There are cases where Lindbladians cannot simply be described as the product of a time-dependent scalar and a time-independent Lindbladian, this is where the callback becomes useful. I envisage a single callback passed to c_ops as being useful, where the user has to manually add multiple decoherence channels. This way, arbitrary data can be passed through the args parameter of the callback to build the operators at a given time step. I believe this would also allow channel cross-correlations to be implemented too. I have hacked my local copy of qutip 4.5 to check this can in principle be done with mesolve, and it has worked. Here is a link to a patch file that shows the changes I made to get this working:; https://pastebin.com/iZCgBbNQ. I am happy to add this functionality properly to a clone and make a pull request.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1254
https://github.com/qutip/qutip/issues/1254:424,Integrability,depend,dependent,424,"Dear qutip developers,. In the documentation of version 4.5 the c_ops argument is said to support callback functions, however they are not implemented in that version and as far as I can tell neither in the current branch. It would be nice to have this feature added to allow for arbitrary time-dependent Lindbladians to be implemented. There are cases where Lindbladians cannot simply be described as the product of a time-dependent scalar and a time-independent Lindbladian, this is where the callback becomes useful. I envisage a single callback passed to c_ops as being useful, where the user has to manually add multiple decoherence channels. This way, arbitrary data can be passed through the args parameter of the callback to build the operators at a given time step. I believe this would also allow channel cross-correlations to be implemented too. I have hacked my local copy of qutip 4.5 to check this can in principle be done with mesolve, and it has worked. Here is a link to a patch file that shows the changes I made to get this working:; https://pastebin.com/iZCgBbNQ. I am happy to add this functionality properly to a clone and make a pull request.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1254
https://github.com/qutip/qutip/issues/1254:379,Usability,simpl,simply,379,"Dear qutip developers,. In the documentation of version 4.5 the c_ops argument is said to support callback functions, however they are not implemented in that version and as far as I can tell neither in the current branch. It would be nice to have this feature added to allow for arbitrary time-dependent Lindbladians to be implemented. There are cases where Lindbladians cannot simply be described as the product of a time-dependent scalar and a time-independent Lindbladian, this is where the callback becomes useful. I envisage a single callback passed to c_ops as being useful, where the user has to manually add multiple decoherence channels. This way, arbitrary data can be passed through the args parameter of the callback to build the operators at a given time step. I believe this would also allow channel cross-correlations to be implemented too. I have hacked my local copy of qutip 4.5 to check this can in principle be done with mesolve, and it has worked. Here is a link to a patch file that shows the changes I made to get this working:; https://pastebin.com/iZCgBbNQ. I am happy to add this functionality properly to a clone and make a pull request.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1254
https://github.com/qutip/qutip/pull/1255:83,Availability,fault,faults,83,"**Description**; Add some `skipif` to bypass tests that were failing (segmentation faults) during the local testing of `qutip.testing.run()` that was failing in the zip version of #1241. I am on Mac with generic BLAS and no MKL. ; I have been installing it on a fresh conda environment with; ```; pip install -e .[development]; ```; which I think is better than ; ```; python setup.py develop; ```; and by the way maybe this is something that can be updated in the readme and docs.; ; My qutip.about reads:; ```; QuTiP Version: 4.5.1; Numpy Version: 1.15.4; Scipy Version: 1.4.1; Cython Version: 0.29.8; Matplotlib Version: 3.1.2; Python Version: 3.7.3; Number of CPUs: 2; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /Users/nathanshammah/github/qutip-4.5.1/qutip; ```; This PR could be included in the 4.5.1 version @Ericgig. . **Related issues or PRs**; This PR is related to #1241. **Changelog**; Add `skipif`in `pytest` on Mac with generic BLAS, avoiding segmentation fault during `qutip.testing.run()`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1255
https://github.com/qutip/qutip/pull/1255:1045,Availability,fault,fault,1045,"**Description**; Add some `skipif` to bypass tests that were failing (segmentation faults) during the local testing of `qutip.testing.run()` that was failing in the zip version of #1241. I am on Mac with generic BLAS and no MKL. ; I have been installing it on a fresh conda environment with; ```; pip install -e .[development]; ```; which I think is better than ; ```; python setup.py develop; ```; and by the way maybe this is something that can be updated in the readme and docs.; ; My qutip.about reads:; ```; QuTiP Version: 4.5.1; Numpy Version: 1.15.4; Scipy Version: 1.4.1; Cython Version: 0.29.8; Matplotlib Version: 3.1.2; Python Version: 3.7.3; Number of CPUs: 2; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /Users/nathanshammah/github/qutip-4.5.1/qutip; ```; This PR could be included in the 4.5.1 version @Ericgig. . **Related issues or PRs**; This PR is related to #1241. **Changelog**; Add `skipif`in `pytest` on Mac with generic BLAS, avoiding segmentation fault during `qutip.testing.run()`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1255
https://github.com/qutip/qutip/pull/1255:243,Deployability,install,installing,243,"**Description**; Add some `skipif` to bypass tests that were failing (segmentation faults) during the local testing of `qutip.testing.run()` that was failing in the zip version of #1241. I am on Mac with generic BLAS and no MKL. ; I have been installing it on a fresh conda environment with; ```; pip install -e .[development]; ```; which I think is better than ; ```; python setup.py develop; ```; and by the way maybe this is something that can be updated in the readme and docs.; ; My qutip.about reads:; ```; QuTiP Version: 4.5.1; Numpy Version: 1.15.4; Scipy Version: 1.4.1; Cython Version: 0.29.8; Matplotlib Version: 3.1.2; Python Version: 3.7.3; Number of CPUs: 2; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /Users/nathanshammah/github/qutip-4.5.1/qutip; ```; This PR could be included in the 4.5.1 version @Ericgig. . **Related issues or PRs**; This PR is related to #1241. **Changelog**; Add `skipif`in `pytest` on Mac with generic BLAS, avoiding segmentation fault during `qutip.testing.run()`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1255
https://github.com/qutip/qutip/pull/1255:301,Deployability,install,install,301,"**Description**; Add some `skipif` to bypass tests that were failing (segmentation faults) during the local testing of `qutip.testing.run()` that was failing in the zip version of #1241. I am on Mac with generic BLAS and no MKL. ; I have been installing it on a fresh conda environment with; ```; pip install -e .[development]; ```; which I think is better than ; ```; python setup.py develop; ```; and by the way maybe this is something that can be updated in the readme and docs.; ; My qutip.about reads:; ```; QuTiP Version: 4.5.1; Numpy Version: 1.15.4; Scipy Version: 1.4.1; Cython Version: 0.29.8; Matplotlib Version: 3.1.2; Python Version: 3.7.3; Number of CPUs: 2; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /Users/nathanshammah/github/qutip-4.5.1/qutip; ```; This PR could be included in the 4.5.1 version @Ericgig. . **Related issues or PRs**; This PR is related to #1241. **Changelog**; Add `skipif`in `pytest` on Mac with generic BLAS, avoiding segmentation fault during `qutip.testing.run()`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1255
https://github.com/qutip/qutip/pull/1255:450,Deployability,update,updated,450,"**Description**; Add some `skipif` to bypass tests that were failing (segmentation faults) during the local testing of `qutip.testing.run()` that was failing in the zip version of #1241. I am on Mac with generic BLAS and no MKL. ; I have been installing it on a fresh conda environment with; ```; pip install -e .[development]; ```; which I think is better than ; ```; python setup.py develop; ```; and by the way maybe this is something that can be updated in the readme and docs.; ; My qutip.about reads:; ```; QuTiP Version: 4.5.1; Numpy Version: 1.15.4; Scipy Version: 1.4.1; Cython Version: 0.29.8; Matplotlib Version: 3.1.2; Python Version: 3.7.3; Number of CPUs: 2; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /Users/nathanshammah/github/qutip-4.5.1/qutip; ```; This PR could be included in the 4.5.1 version @Ericgig. . **Related issues or PRs**; This PR is related to #1241. **Changelog**; Add `skipif`in `pytest` on Mac with generic BLAS, avoiding segmentation fault during `qutip.testing.run()`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1255
https://github.com/qutip/qutip/pull/1255:700,Deployability,Install,Installed,700,"**Description**; Add some `skipif` to bypass tests that were failing (segmentation faults) during the local testing of `qutip.testing.run()` that was failing in the zip version of #1241. I am on Mac with generic BLAS and no MKL. ; I have been installing it on a fresh conda environment with; ```; pip install -e .[development]; ```; which I think is better than ; ```; python setup.py develop; ```; and by the way maybe this is something that can be updated in the readme and docs.; ; My qutip.about reads:; ```; QuTiP Version: 4.5.1; Numpy Version: 1.15.4; Scipy Version: 1.4.1; Cython Version: 0.29.8; Matplotlib Version: 3.1.2; Python Version: 3.7.3; Number of CPUs: 2; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /Users/nathanshammah/github/qutip-4.5.1/qutip; ```; This PR could be included in the 4.5.1 version @Ericgig. . **Related issues or PRs**; This PR is related to #1241. **Changelog**; Add `skipif`in `pytest` on Mac with generic BLAS, avoiding segmentation fault during `qutip.testing.run()`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1255
https://github.com/qutip/qutip/pull/1255:772,Deployability,Install,Installation,772,"**Description**; Add some `skipif` to bypass tests that were failing (segmentation faults) during the local testing of `qutip.testing.run()` that was failing in the zip version of #1241. I am on Mac with generic BLAS and no MKL. ; I have been installing it on a fresh conda environment with; ```; pip install -e .[development]; ```; which I think is better than ; ```; python setup.py develop; ```; and by the way maybe this is something that can be updated in the readme and docs.; ; My qutip.about reads:; ```; QuTiP Version: 4.5.1; Numpy Version: 1.15.4; Scipy Version: 1.4.1; Cython Version: 0.29.8; Matplotlib Version: 3.1.2; Python Version: 3.7.3; Number of CPUs: 2; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /Users/nathanshammah/github/qutip-4.5.1/qutip; ```; This PR could be included in the 4.5.1 version @Ericgig. . **Related issues or PRs**; This PR is related to #1241. **Changelog**; Add `skipif`in `pytest` on Mac with generic BLAS, avoiding segmentation fault during `qutip.testing.run()`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1255
https://github.com/qutip/qutip/pull/1255:1023,Safety,avoid,avoiding,1023,"**Description**; Add some `skipif` to bypass tests that were failing (segmentation faults) during the local testing of `qutip.testing.run()` that was failing in the zip version of #1241. I am on Mac with generic BLAS and no MKL. ; I have been installing it on a fresh conda environment with; ```; pip install -e .[development]; ```; which I think is better than ; ```; python setup.py develop; ```; and by the way maybe this is something that can be updated in the readme and docs.; ; My qutip.about reads:; ```; QuTiP Version: 4.5.1; Numpy Version: 1.15.4; Scipy Version: 1.4.1; Cython Version: 0.29.8; Matplotlib Version: 3.1.2; Python Version: 3.7.3; Number of CPUs: 2; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /Users/nathanshammah/github/qutip-4.5.1/qutip; ```; This PR could be included in the 4.5.1 version @Ericgig. . **Related issues or PRs**; This PR is related to #1241. **Changelog**; Add `skipif`in `pytest` on Mac with generic BLAS, avoiding segmentation fault during `qutip.testing.run()`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1255
https://github.com/qutip/qutip/pull/1255:45,Testability,test,tests,45,"**Description**; Add some `skipif` to bypass tests that were failing (segmentation faults) during the local testing of `qutip.testing.run()` that was failing in the zip version of #1241. I am on Mac with generic BLAS and no MKL. ; I have been installing it on a fresh conda environment with; ```; pip install -e .[development]; ```; which I think is better than ; ```; python setup.py develop; ```; and by the way maybe this is something that can be updated in the readme and docs.; ; My qutip.about reads:; ```; QuTiP Version: 4.5.1; Numpy Version: 1.15.4; Scipy Version: 1.4.1; Cython Version: 0.29.8; Matplotlib Version: 3.1.2; Python Version: 3.7.3; Number of CPUs: 2; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /Users/nathanshammah/github/qutip-4.5.1/qutip; ```; This PR could be included in the 4.5.1 version @Ericgig. . **Related issues or PRs**; This PR is related to #1241. **Changelog**; Add `skipif`in `pytest` on Mac with generic BLAS, avoiding segmentation fault during `qutip.testing.run()`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1255
https://github.com/qutip/qutip/pull/1255:108,Testability,test,testing,108,"**Description**; Add some `skipif` to bypass tests that were failing (segmentation faults) during the local testing of `qutip.testing.run()` that was failing in the zip version of #1241. I am on Mac with generic BLAS and no MKL. ; I have been installing it on a fresh conda environment with; ```; pip install -e .[development]; ```; which I think is better than ; ```; python setup.py develop; ```; and by the way maybe this is something that can be updated in the readme and docs.; ; My qutip.about reads:; ```; QuTiP Version: 4.5.1; Numpy Version: 1.15.4; Scipy Version: 1.4.1; Cython Version: 0.29.8; Matplotlib Version: 3.1.2; Python Version: 3.7.3; Number of CPUs: 2; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /Users/nathanshammah/github/qutip-4.5.1/qutip; ```; This PR could be included in the 4.5.1 version @Ericgig. . **Related issues or PRs**; This PR is related to #1241. **Changelog**; Add `skipif`in `pytest` on Mac with generic BLAS, avoiding segmentation fault during `qutip.testing.run()`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1255
https://github.com/qutip/qutip/pull/1255:126,Testability,test,testing,126,"**Description**; Add some `skipif` to bypass tests that were failing (segmentation faults) during the local testing of `qutip.testing.run()` that was failing in the zip version of #1241. I am on Mac with generic BLAS and no MKL. ; I have been installing it on a fresh conda environment with; ```; pip install -e .[development]; ```; which I think is better than ; ```; python setup.py develop; ```; and by the way maybe this is something that can be updated in the readme and docs.; ; My qutip.about reads:; ```; QuTiP Version: 4.5.1; Numpy Version: 1.15.4; Scipy Version: 1.4.1; Cython Version: 0.29.8; Matplotlib Version: 3.1.2; Python Version: 3.7.3; Number of CPUs: 2; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /Users/nathanshammah/github/qutip-4.5.1/qutip; ```; This PR could be included in the 4.5.1 version @Ericgig. . **Related issues or PRs**; This PR is related to #1241. **Changelog**; Add `skipif`in `pytest` on Mac with generic BLAS, avoiding segmentation fault during `qutip.testing.run()`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1255
https://github.com/qutip/qutip/pull/1255:1065,Testability,test,testing,1065,"**Description**; Add some `skipif` to bypass tests that were failing (segmentation faults) during the local testing of `qutip.testing.run()` that was failing in the zip version of #1241. I am on Mac with generic BLAS and no MKL. ; I have been installing it on a fresh conda environment with; ```; pip install -e .[development]; ```; which I think is better than ; ```; python setup.py develop; ```; and by the way maybe this is something that can be updated in the readme and docs.; ; My qutip.about reads:; ```; QuTiP Version: 4.5.1; Numpy Version: 1.15.4; Scipy Version: 1.4.1; Cython Version: 0.29.8; Matplotlib Version: 3.1.2; Python Version: 3.7.3; Number of CPUs: 2; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /Users/nathanshammah/github/qutip-4.5.1/qutip; ```; This PR could be included in the 4.5.1 version @Ericgig. . **Related issues or PRs**; This PR is related to #1241. **Changelog**; Add `skipif`in `pytest` on Mac with generic BLAS, avoiding segmentation fault during `qutip.testing.run()`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1255
https://github.com/qutip/qutip/pull/1256:83,Availability,fault,faults,83,"**Description**; Add some `skipif` to bypass tests that were failing (segmentation faults) during the local testing of `qutip.testing.run()` that was failing in the zip version of #1241. I am on Mac with generic BLAS and no MKL. ; I have been installing it on a fresh conda environment with; ```; pip install -e .[development]; ```; which I think is better than ; ```; python setup.py develop; ```; and by the way maybe this is something that can be updated in the readme and docs.; ; My qutip.about reads:; ```; QuTiP Version: 4.5.1; Numpy Version: 1.15.4; Scipy Version: 1.4.1; Cython Version: 0.29.8; Matplotlib Version: 3.1.2; Python Version: 3.7.3; Number of CPUs: 2; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /Users/nathanshammah/github/qutip-4.5.1/qutip; ```; This PR could be included in the 4.5.1 version @Ericgig. . **Related issues or PRs**; This PR is related to #1241. **Changelog**; Add `skipif`in `pytest` on Mac with generic BLAS, avoiding segmentation fault during `qutip.testing.run()`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1256
https://github.com/qutip/qutip/pull/1256:1045,Availability,fault,fault,1045,"**Description**; Add some `skipif` to bypass tests that were failing (segmentation faults) during the local testing of `qutip.testing.run()` that was failing in the zip version of #1241. I am on Mac with generic BLAS and no MKL. ; I have been installing it on a fresh conda environment with; ```; pip install -e .[development]; ```; which I think is better than ; ```; python setup.py develop; ```; and by the way maybe this is something that can be updated in the readme and docs.; ; My qutip.about reads:; ```; QuTiP Version: 4.5.1; Numpy Version: 1.15.4; Scipy Version: 1.4.1; Cython Version: 0.29.8; Matplotlib Version: 3.1.2; Python Version: 3.7.3; Number of CPUs: 2; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /Users/nathanshammah/github/qutip-4.5.1/qutip; ```; This PR could be included in the 4.5.1 version @Ericgig. . **Related issues or PRs**; This PR is related to #1241. **Changelog**; Add `skipif`in `pytest` on Mac with generic BLAS, avoiding segmentation fault during `qutip.testing.run()`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1256
https://github.com/qutip/qutip/pull/1256:243,Deployability,install,installing,243,"**Description**; Add some `skipif` to bypass tests that were failing (segmentation faults) during the local testing of `qutip.testing.run()` that was failing in the zip version of #1241. I am on Mac with generic BLAS and no MKL. ; I have been installing it on a fresh conda environment with; ```; pip install -e .[development]; ```; which I think is better than ; ```; python setup.py develop; ```; and by the way maybe this is something that can be updated in the readme and docs.; ; My qutip.about reads:; ```; QuTiP Version: 4.5.1; Numpy Version: 1.15.4; Scipy Version: 1.4.1; Cython Version: 0.29.8; Matplotlib Version: 3.1.2; Python Version: 3.7.3; Number of CPUs: 2; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /Users/nathanshammah/github/qutip-4.5.1/qutip; ```; This PR could be included in the 4.5.1 version @Ericgig. . **Related issues or PRs**; This PR is related to #1241. **Changelog**; Add `skipif`in `pytest` on Mac with generic BLAS, avoiding segmentation fault during `qutip.testing.run()`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1256
https://github.com/qutip/qutip/pull/1256:301,Deployability,install,install,301,"**Description**; Add some `skipif` to bypass tests that were failing (segmentation faults) during the local testing of `qutip.testing.run()` that was failing in the zip version of #1241. I am on Mac with generic BLAS and no MKL. ; I have been installing it on a fresh conda environment with; ```; pip install -e .[development]; ```; which I think is better than ; ```; python setup.py develop; ```; and by the way maybe this is something that can be updated in the readme and docs.; ; My qutip.about reads:; ```; QuTiP Version: 4.5.1; Numpy Version: 1.15.4; Scipy Version: 1.4.1; Cython Version: 0.29.8; Matplotlib Version: 3.1.2; Python Version: 3.7.3; Number of CPUs: 2; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /Users/nathanshammah/github/qutip-4.5.1/qutip; ```; This PR could be included in the 4.5.1 version @Ericgig. . **Related issues or PRs**; This PR is related to #1241. **Changelog**; Add `skipif`in `pytest` on Mac with generic BLAS, avoiding segmentation fault during `qutip.testing.run()`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1256
https://github.com/qutip/qutip/pull/1256:450,Deployability,update,updated,450,"**Description**; Add some `skipif` to bypass tests that were failing (segmentation faults) during the local testing of `qutip.testing.run()` that was failing in the zip version of #1241. I am on Mac with generic BLAS and no MKL. ; I have been installing it on a fresh conda environment with; ```; pip install -e .[development]; ```; which I think is better than ; ```; python setup.py develop; ```; and by the way maybe this is something that can be updated in the readme and docs.; ; My qutip.about reads:; ```; QuTiP Version: 4.5.1; Numpy Version: 1.15.4; Scipy Version: 1.4.1; Cython Version: 0.29.8; Matplotlib Version: 3.1.2; Python Version: 3.7.3; Number of CPUs: 2; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /Users/nathanshammah/github/qutip-4.5.1/qutip; ```; This PR could be included in the 4.5.1 version @Ericgig. . **Related issues or PRs**; This PR is related to #1241. **Changelog**; Add `skipif`in `pytest` on Mac with generic BLAS, avoiding segmentation fault during `qutip.testing.run()`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1256
https://github.com/qutip/qutip/pull/1256:700,Deployability,Install,Installed,700,"**Description**; Add some `skipif` to bypass tests that were failing (segmentation faults) during the local testing of `qutip.testing.run()` that was failing in the zip version of #1241. I am on Mac with generic BLAS and no MKL. ; I have been installing it on a fresh conda environment with; ```; pip install -e .[development]; ```; which I think is better than ; ```; python setup.py develop; ```; and by the way maybe this is something that can be updated in the readme and docs.; ; My qutip.about reads:; ```; QuTiP Version: 4.5.1; Numpy Version: 1.15.4; Scipy Version: 1.4.1; Cython Version: 0.29.8; Matplotlib Version: 3.1.2; Python Version: 3.7.3; Number of CPUs: 2; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /Users/nathanshammah/github/qutip-4.5.1/qutip; ```; This PR could be included in the 4.5.1 version @Ericgig. . **Related issues or PRs**; This PR is related to #1241. **Changelog**; Add `skipif`in `pytest` on Mac with generic BLAS, avoiding segmentation fault during `qutip.testing.run()`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1256
https://github.com/qutip/qutip/pull/1256:772,Deployability,Install,Installation,772,"**Description**; Add some `skipif` to bypass tests that were failing (segmentation faults) during the local testing of `qutip.testing.run()` that was failing in the zip version of #1241. I am on Mac with generic BLAS and no MKL. ; I have been installing it on a fresh conda environment with; ```; pip install -e .[development]; ```; which I think is better than ; ```; python setup.py develop; ```; and by the way maybe this is something that can be updated in the readme and docs.; ; My qutip.about reads:; ```; QuTiP Version: 4.5.1; Numpy Version: 1.15.4; Scipy Version: 1.4.1; Cython Version: 0.29.8; Matplotlib Version: 3.1.2; Python Version: 3.7.3; Number of CPUs: 2; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /Users/nathanshammah/github/qutip-4.5.1/qutip; ```; This PR could be included in the 4.5.1 version @Ericgig. . **Related issues or PRs**; This PR is related to #1241. **Changelog**; Add `skipif`in `pytest` on Mac with generic BLAS, avoiding segmentation fault during `qutip.testing.run()`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1256
https://github.com/qutip/qutip/pull/1256:1023,Safety,avoid,avoiding,1023,"**Description**; Add some `skipif` to bypass tests that were failing (segmentation faults) during the local testing of `qutip.testing.run()` that was failing in the zip version of #1241. I am on Mac with generic BLAS and no MKL. ; I have been installing it on a fresh conda environment with; ```; pip install -e .[development]; ```; which I think is better than ; ```; python setup.py develop; ```; and by the way maybe this is something that can be updated in the readme and docs.; ; My qutip.about reads:; ```; QuTiP Version: 4.5.1; Numpy Version: 1.15.4; Scipy Version: 1.4.1; Cython Version: 0.29.8; Matplotlib Version: 3.1.2; Python Version: 3.7.3; Number of CPUs: 2; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /Users/nathanshammah/github/qutip-4.5.1/qutip; ```; This PR could be included in the 4.5.1 version @Ericgig. . **Related issues or PRs**; This PR is related to #1241. **Changelog**; Add `skipif`in `pytest` on Mac with generic BLAS, avoiding segmentation fault during `qutip.testing.run()`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1256
https://github.com/qutip/qutip/pull/1256:45,Testability,test,tests,45,"**Description**; Add some `skipif` to bypass tests that were failing (segmentation faults) during the local testing of `qutip.testing.run()` that was failing in the zip version of #1241. I am on Mac with generic BLAS and no MKL. ; I have been installing it on a fresh conda environment with; ```; pip install -e .[development]; ```; which I think is better than ; ```; python setup.py develop; ```; and by the way maybe this is something that can be updated in the readme and docs.; ; My qutip.about reads:; ```; QuTiP Version: 4.5.1; Numpy Version: 1.15.4; Scipy Version: 1.4.1; Cython Version: 0.29.8; Matplotlib Version: 3.1.2; Python Version: 3.7.3; Number of CPUs: 2; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /Users/nathanshammah/github/qutip-4.5.1/qutip; ```; This PR could be included in the 4.5.1 version @Ericgig. . **Related issues or PRs**; This PR is related to #1241. **Changelog**; Add `skipif`in `pytest` on Mac with generic BLAS, avoiding segmentation fault during `qutip.testing.run()`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1256
https://github.com/qutip/qutip/pull/1256:108,Testability,test,testing,108,"**Description**; Add some `skipif` to bypass tests that were failing (segmentation faults) during the local testing of `qutip.testing.run()` that was failing in the zip version of #1241. I am on Mac with generic BLAS and no MKL. ; I have been installing it on a fresh conda environment with; ```; pip install -e .[development]; ```; which I think is better than ; ```; python setup.py develop; ```; and by the way maybe this is something that can be updated in the readme and docs.; ; My qutip.about reads:; ```; QuTiP Version: 4.5.1; Numpy Version: 1.15.4; Scipy Version: 1.4.1; Cython Version: 0.29.8; Matplotlib Version: 3.1.2; Python Version: 3.7.3; Number of CPUs: 2; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /Users/nathanshammah/github/qutip-4.5.1/qutip; ```; This PR could be included in the 4.5.1 version @Ericgig. . **Related issues or PRs**; This PR is related to #1241. **Changelog**; Add `skipif`in `pytest` on Mac with generic BLAS, avoiding segmentation fault during `qutip.testing.run()`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1256
https://github.com/qutip/qutip/pull/1256:126,Testability,test,testing,126,"**Description**; Add some `skipif` to bypass tests that were failing (segmentation faults) during the local testing of `qutip.testing.run()` that was failing in the zip version of #1241. I am on Mac with generic BLAS and no MKL. ; I have been installing it on a fresh conda environment with; ```; pip install -e .[development]; ```; which I think is better than ; ```; python setup.py develop; ```; and by the way maybe this is something that can be updated in the readme and docs.; ; My qutip.about reads:; ```; QuTiP Version: 4.5.1; Numpy Version: 1.15.4; Scipy Version: 1.4.1; Cython Version: 0.29.8; Matplotlib Version: 3.1.2; Python Version: 3.7.3; Number of CPUs: 2; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /Users/nathanshammah/github/qutip-4.5.1/qutip; ```; This PR could be included in the 4.5.1 version @Ericgig. . **Related issues or PRs**; This PR is related to #1241. **Changelog**; Add `skipif`in `pytest` on Mac with generic BLAS, avoiding segmentation fault during `qutip.testing.run()`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1256
https://github.com/qutip/qutip/pull/1256:1065,Testability,test,testing,1065,"**Description**; Add some `skipif` to bypass tests that were failing (segmentation faults) during the local testing of `qutip.testing.run()` that was failing in the zip version of #1241. I am on Mac with generic BLAS and no MKL. ; I have been installing it on a fresh conda environment with; ```; pip install -e .[development]; ```; which I think is better than ; ```; python setup.py develop; ```; and by the way maybe this is something that can be updated in the readme and docs.; ; My qutip.about reads:; ```; QuTiP Version: 4.5.1; Numpy Version: 1.15.4; Scipy Version: 1.4.1; Cython Version: 0.29.8; Matplotlib Version: 3.1.2; Python Version: 3.7.3; Number of CPUs: 2; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /Users/nathanshammah/github/qutip-4.5.1/qutip; ```; This PR could be included in the 4.5.1 version @Ericgig. . **Related issues or PRs**; This PR is related to #1241. **Changelog**; Add `skipif`in `pytest` on Mac with generic BLAS, avoiding segmentation fault during `qutip.testing.run()`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1256
https://github.com/qutip/qutip/pull/1257:197,Availability,error,error,197,"The segfault on mac is not fixed yet. @nathanshammah found 3 tests that fails because of it.; Since we don't have a solution comming soon, we are simply skipping these tests for 4.5.1. This is the error in #1197. In common with these 3 test is the computation of eigenvalues, 2 of them do it directly with scipy, the last one compare the cython version to the scipy one.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1257
https://github.com/qutip/qutip/pull/1257:61,Testability,test,tests,61,"The segfault on mac is not fixed yet. @nathanshammah found 3 tests that fails because of it.; Since we don't have a solution comming soon, we are simply skipping these tests for 4.5.1. This is the error in #1197. In common with these 3 test is the computation of eigenvalues, 2 of them do it directly with scipy, the last one compare the cython version to the scipy one.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1257
https://github.com/qutip/qutip/pull/1257:168,Testability,test,tests,168,"The segfault on mac is not fixed yet. @nathanshammah found 3 tests that fails because of it.; Since we don't have a solution comming soon, we are simply skipping these tests for 4.5.1. This is the error in #1197. In common with these 3 test is the computation of eigenvalues, 2 of them do it directly with scipy, the last one compare the cython version to the scipy one.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1257
https://github.com/qutip/qutip/pull/1257:236,Testability,test,test,236,"The segfault on mac is not fixed yet. @nathanshammah found 3 tests that fails because of it.; Since we don't have a solution comming soon, we are simply skipping these tests for 4.5.1. This is the error in #1197. In common with these 3 test is the computation of eigenvalues, 2 of them do it directly with scipy, the last one compare the cython version to the scipy one.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1257
https://github.com/qutip/qutip/pull/1257:146,Usability,simpl,simply,146,"The segfault on mac is not fixed yet. @nathanshammah found 3 tests that fails because of it.; Since we don't have a solution comming soon, we are simply skipping these tests for 4.5.1. This is the error in #1197. In common with these 3 test is the computation of eigenvalues, 2 of them do it directly with scipy, the last one compare the cython version to the scipy one.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1257
https://github.com/qutip/qutip/issues/1259:637,Modifiability,variab,variable,637,"It would be great if it were possible to specify where the temporary pyx (and other?) files are stored during a cython build. At the moment when one runs mesolve, the pyx files (and maybe others?) get written in the current working folder. Therefore running mesolve with some parameter scan (say with multiprocessing), results in *many* temp files that something like dropbox has to struggle in the background to process. . I can tell from those around me this happens to be an extremely common use case; i.e. most people are using dropbox or the like to backup their files. I would think the easiest thing to do might be to have an ENV variable, like, say QUTIP_BUILD_FOLDER that could dictate where this happens. Alternatively setting the default to system's tmp folder would be a good alternative. . I've looked in docs, and can't see anything like that; please let me know if i missed it.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1259
https://github.com/qutip/qutip/issues/1260:304,Integrability,depend,dependent,304,"This issue is on behalf of [a post in the forums by Louis Fry](https://groups.google.com/forum/#!topic/qutip/93uSuJGK_Jk) who is trying to implement Lindblad operators which cannot be written in the form of a known `f(t) * A`, because the operators are related to the instantaneous eigenstates of a time-dependent Hamiltonian. The documentation in the docstring of `mesolve` says that `c_ops` may be a callback function of the signature `f(t, args) -> Qobj`, similarly to the Hamiltonian. This is not the case, and as best as I can tell, has never been the case. Basic reproduction (though the functionality is just completely missing, so this won't ever succeed).; ```python; import qutip; def c_ops(t, args):; return qutip.create(3); qutip.mesolve(qutip.num(3), qutip.basis(3, 1).proj(), [0, 1], c_ops); ```. ## History. - @jrjohansson originally wrote the docstring saying that `c_ops` could be a callback function in 2012 (pre-QuTiP 1.1.4) in commit 1bf006d4, although the code did not support it at this time; - in issue #40 (2013), he commented that this functionality should be implemented, and this issue was closed without further action in 2018.; - in issue #223 (2014) there is some further discussion, but nothing is done until @Ericgig closes it in 2019, saying it is addressed by QuTiP 4.4.0 (the big swap to QobjEvo), but this doesn't appear to be the case. As of tag `v4.4.0`, the code does not support it. The failing line of code would be https://github.com/qutip/qutip/blob/fc9d9915d0f6242587828ce716ff3cd444edf82a/qutip/mesolve.py#L227-L236; as a function type is truth-y but has no length, but the underlying problem is more just that there's no support for it at all - there's no check for `callable(c_ops)`. At the current `master` at the time of writing (QuTiP ~4.5.1, 4102b99), we're in the same place as at tag `v4.4.0`. ## Solution. In previous issues, people have been told to rewrite the Liouvillian in the supported form, however that's not reasonably possible here. Tech",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1260
https://github.com/qutip/qutip/issues/1260:2111,Integrability,depend,dependent,2111,"re `f(t, args) -> Qobj`, similarly to the Hamiltonian. This is not the case, and as best as I can tell, has never been the case. Basic reproduction (though the functionality is just completely missing, so this won't ever succeed).; ```python; import qutip; def c_ops(t, args):; return qutip.create(3); qutip.mesolve(qutip.num(3), qutip.basis(3, 1).proj(), [0, 1], c_ops); ```. ## History. - @jrjohansson originally wrote the docstring saying that `c_ops` could be a callback function in 2012 (pre-QuTiP 1.1.4) in commit 1bf006d4, although the code did not support it at this time; - in issue #40 (2013), he commented that this functionality should be implemented, and this issue was closed without further action in 2018.; - in issue #223 (2014) there is some further discussion, but nothing is done until @Ericgig closes it in 2019, saying it is addressed by QuTiP 4.4.0 (the big swap to QobjEvo), but this doesn't appear to be the case. As of tag `v4.4.0`, the code does not support it. The failing line of code would be https://github.com/qutip/qutip/blob/fc9d9915d0f6242587828ce716ff3cd444edf82a/qutip/mesolve.py#L227-L236; as a function type is truth-y but has no length, but the underlying problem is more just that there's no support for it at all - there's no check for `callable(c_ops)`. At the current `master` at the time of writing (QuTiP ~4.5.1, 4102b99), we're in the same place as at tag `v4.4.0`. ## Solution. In previous issues, people have been told to rewrite the Liouvillian in the supported form, however that's not reasonably possible here. Technically it can be well-approximated by using an interpolation for each individual matrix element, as the time-dependent Hamiltonian can be solved ahead of time, but that's not at all sensible. Most pressingly, the documentation is currently wrong and should be changed to reflect reality. Secondly, we have to decide whether we're going to implement this functionality at all, perhaps as a part of @Ericgig's refactor of the solvers?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1260
https://github.com/qutip/qutip/issues/1260:1905,Modifiability,rewrite,rewrite,1905,"re `f(t, args) -> Qobj`, similarly to the Hamiltonian. This is not the case, and as best as I can tell, has never been the case. Basic reproduction (though the functionality is just completely missing, so this won't ever succeed).; ```python; import qutip; def c_ops(t, args):; return qutip.create(3); qutip.mesolve(qutip.num(3), qutip.basis(3, 1).proj(), [0, 1], c_ops); ```. ## History. - @jrjohansson originally wrote the docstring saying that `c_ops` could be a callback function in 2012 (pre-QuTiP 1.1.4) in commit 1bf006d4, although the code did not support it at this time; - in issue #40 (2013), he commented that this functionality should be implemented, and this issue was closed without further action in 2018.; - in issue #223 (2014) there is some further discussion, but nothing is done until @Ericgig closes it in 2019, saying it is addressed by QuTiP 4.4.0 (the big swap to QobjEvo), but this doesn't appear to be the case. As of tag `v4.4.0`, the code does not support it. The failing line of code would be https://github.com/qutip/qutip/blob/fc9d9915d0f6242587828ce716ff3cd444edf82a/qutip/mesolve.py#L227-L236; as a function type is truth-y but has no length, but the underlying problem is more just that there's no support for it at all - there's no check for `callable(c_ops)`. At the current `master` at the time of writing (QuTiP ~4.5.1, 4102b99), we're in the same place as at tag `v4.4.0`. ## Solution. In previous issues, people have been told to rewrite the Liouvillian in the supported form, however that's not reasonably possible here. Technically it can be well-approximated by using an interpolation for each individual matrix element, as the time-dependent Hamiltonian can be solved ahead of time, but that's not at all sensible. Most pressingly, the documentation is currently wrong and should be changed to reflect reality. Secondly, we have to decide whether we're going to implement this functionality at all, perhaps as a part of @Ericgig's refactor of the solvers?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1260
https://github.com/qutip/qutip/issues/1260:2410,Modifiability,refactor,refactor,2410,"re `f(t, args) -> Qobj`, similarly to the Hamiltonian. This is not the case, and as best as I can tell, has never been the case. Basic reproduction (though the functionality is just completely missing, so this won't ever succeed).; ```python; import qutip; def c_ops(t, args):; return qutip.create(3); qutip.mesolve(qutip.num(3), qutip.basis(3, 1).proj(), [0, 1], c_ops); ```. ## History. - @jrjohansson originally wrote the docstring saying that `c_ops` could be a callback function in 2012 (pre-QuTiP 1.1.4) in commit 1bf006d4, although the code did not support it at this time; - in issue #40 (2013), he commented that this functionality should be implemented, and this issue was closed without further action in 2018.; - in issue #223 (2014) there is some further discussion, but nothing is done until @Ericgig closes it in 2019, saying it is addressed by QuTiP 4.4.0 (the big swap to QobjEvo), but this doesn't appear to be the case. As of tag `v4.4.0`, the code does not support it. The failing line of code would be https://github.com/qutip/qutip/blob/fc9d9915d0f6242587828ce716ff3cd444edf82a/qutip/mesolve.py#L227-L236; as a function type is truth-y but has no length, but the underlying problem is more just that there's no support for it at all - there's no check for `callable(c_ops)`. At the current `master` at the time of writing (QuTiP ~4.5.1, 4102b99), we're in the same place as at tag `v4.4.0`. ## Solution. In previous issues, people have been told to rewrite the Liouvillian in the supported form, however that's not reasonably possible here. Technically it can be well-approximated by using an interpolation for each individual matrix element, as the time-dependent Hamiltonian can be solved ahead of time, but that's not at all sensible. Most pressingly, the documentation is currently wrong and should be changed to reflect reality. Secondly, we have to decide whether we're going to implement this functionality at all, perhaps as a part of @Ericgig's refactor of the solvers?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1260
https://github.com/qutip/qutip/pull/1261:236,Integrability,depend,dependent,236,"Fix misleading documentation which said that `c_ops` could be a callback function. It currently cannot, though all functionality that could be achieved through that can be emulated by passing a callback function returning the full time-dependent Liouvillian as the `H` parameter. See #1254, fixes #1260.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1261
https://github.com/qutip/qutip/issues/1262:897,Deployability,Install,Installed,897,"I am unable to find the list of states returned by the essolve function. For example:. ```python; import qutip as qt; test = qt.essolve(qt.qeye(2), qt.ket2dm(qt.basis(2, 0)), [1,2,3], c_op_list=[], e_ops=[]); ```; Returns the message; ```; Result object with essolve data.; --------------------------------; states = True, expect = True; num_expect = 0, num_collapse = 0; ```; but if I try to access the states; ```; test.states; >>> []; ```; Should this contain a list of states like mesolve()? It seems a similar issue has been raised before: https://groups.google.com/forum/#!topic/qutip/st3i6STPrQY. Here's my environment details:. ```; QuTiP: Quantum Toolbox in Python; ================================; QuTiP Version: 4.5.0; Numpy Version: 1.16.4; Scipy Version: 1.1.0; Cython Version: 0.27.3; Matplotlib Version: 2.1.2; Python Version: 3.6.4; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64); Installation path: C:\Users\chris\Anaconda3\lib\site-packages\qutip; ============================================; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1262
https://github.com/qutip/qutip/issues/1262:969,Deployability,Install,Installation,969,"I am unable to find the list of states returned by the essolve function. For example:. ```python; import qutip as qt; test = qt.essolve(qt.qeye(2), qt.ket2dm(qt.basis(2, 0)), [1,2,3], c_op_list=[], e_ops=[]); ```; Returns the message; ```; Result object with essolve data.; --------------------------------; states = True, expect = True; num_expect = 0, num_collapse = 0; ```; but if I try to access the states; ```; test.states; >>> []; ```; Should this contain a list of states like mesolve()? It seems a similar issue has been raised before: https://groups.google.com/forum/#!topic/qutip/st3i6STPrQY. Here's my environment details:. ```; QuTiP: Quantum Toolbox in Python; ================================; QuTiP Version: 4.5.0; Numpy Version: 1.16.4; Scipy Version: 1.1.0; Cython Version: 0.27.3; Matplotlib Version: 2.1.2; Python Version: 3.6.4; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64); Installation path: C:\Users\chris\Anaconda3\lib\site-packages\qutip; ============================================; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1262
https://github.com/qutip/qutip/issues/1262:226,Integrability,message,message,226,"I am unable to find the list of states returned by the essolve function. For example:. ```python; import qutip as qt; test = qt.essolve(qt.qeye(2), qt.ket2dm(qt.basis(2, 0)), [1,2,3], c_op_list=[], e_ops=[]); ```; Returns the message; ```; Result object with essolve data.; --------------------------------; states = True, expect = True; num_expect = 0, num_collapse = 0; ```; but if I try to access the states; ```; test.states; >>> []; ```; Should this contain a list of states like mesolve()? It seems a similar issue has been raised before: https://groups.google.com/forum/#!topic/qutip/st3i6STPrQY. Here's my environment details:. ```; QuTiP: Quantum Toolbox in Python; ================================; QuTiP Version: 4.5.0; Numpy Version: 1.16.4; Scipy Version: 1.1.0; Cython Version: 0.27.3; Matplotlib Version: 2.1.2; Python Version: 3.6.4; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64); Installation path: C:\Users\chris\Anaconda3\lib\site-packages\qutip; ============================================; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1262
https://github.com/qutip/qutip/issues/1262:393,Security,access,access,393,"I am unable to find the list of states returned by the essolve function. For example:. ```python; import qutip as qt; test = qt.essolve(qt.qeye(2), qt.ket2dm(qt.basis(2, 0)), [1,2,3], c_op_list=[], e_ops=[]); ```; Returns the message; ```; Result object with essolve data.; --------------------------------; states = True, expect = True; num_expect = 0, num_collapse = 0; ```; but if I try to access the states; ```; test.states; >>> []; ```; Should this contain a list of states like mesolve()? It seems a similar issue has been raised before: https://groups.google.com/forum/#!topic/qutip/st3i6STPrQY. Here's my environment details:. ```; QuTiP: Quantum Toolbox in Python; ================================; QuTiP Version: 4.5.0; Numpy Version: 1.16.4; Scipy Version: 1.1.0; Cython Version: 0.27.3; Matplotlib Version: 2.1.2; Python Version: 3.6.4; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64); Installation path: C:\Users\chris\Anaconda3\lib\site-packages\qutip; ============================================; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1262
https://github.com/qutip/qutip/issues/1262:118,Testability,test,test,118,"I am unable to find the list of states returned by the essolve function. For example:. ```python; import qutip as qt; test = qt.essolve(qt.qeye(2), qt.ket2dm(qt.basis(2, 0)), [1,2,3], c_op_list=[], e_ops=[]); ```; Returns the message; ```; Result object with essolve data.; --------------------------------; states = True, expect = True; num_expect = 0, num_collapse = 0; ```; but if I try to access the states; ```; test.states; >>> []; ```; Should this contain a list of states like mesolve()? It seems a similar issue has been raised before: https://groups.google.com/forum/#!topic/qutip/st3i6STPrQY. Here's my environment details:. ```; QuTiP: Quantum Toolbox in Python; ================================; QuTiP Version: 4.5.0; Numpy Version: 1.16.4; Scipy Version: 1.1.0; Cython Version: 0.27.3; Matplotlib Version: 2.1.2; Python Version: 3.6.4; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64); Installation path: C:\Users\chris\Anaconda3\lib\site-packages\qutip; ============================================; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1262
https://github.com/qutip/qutip/issues/1262:417,Testability,test,test,417,"I am unable to find the list of states returned by the essolve function. For example:. ```python; import qutip as qt; test = qt.essolve(qt.qeye(2), qt.ket2dm(qt.basis(2, 0)), [1,2,3], c_op_list=[], e_ops=[]); ```; Returns the message; ```; Result object with essolve data.; --------------------------------; states = True, expect = True; num_expect = 0, num_collapse = 0; ```; but if I try to access the states; ```; test.states; >>> []; ```; Should this contain a list of states like mesolve()? It seems a similar issue has been raised before: https://groups.google.com/forum/#!topic/qutip/st3i6STPrQY. Here's my environment details:. ```; QuTiP: Quantum Toolbox in Python; ================================; QuTiP Version: 4.5.0; Numpy Version: 1.16.4; Scipy Version: 1.1.0; Cython Version: 0.27.3; Matplotlib Version: 2.1.2; Python Version: 3.6.4; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64); Installation path: C:\Users\chris\Anaconda3\lib\site-packages\qutip; ============================================; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1262
https://github.com/qutip/qutip/issues/1263:58,Deployability,install,installing,58,"**Issue**; Currently, to develop qutip from source (e.g., installing from)the installation guide says to do ; ```; python setup.py develop; ```; However, it is [suggested](https://stackoverflow.com/questions/30306099/pip-install-editable-vs-python-setup-py-develop) to use the command; ```; pip -e .[development]; ```; This currently is not supported as there is no `development_requirements.txt` file. Also, in dev mode, one needs to install pytest, otherwise the `qt.run()` fails. If pytest as well as cython numpy and scipy were specified in such file, this should be done automatically. . Additionally, it may be ideal to pin only minor versions with tilde, stuff like `numpy~=1.18.1`, which should update micro releases but not minor. . **Describe the solution you'd like**; Add a `development_requirements.txt` file and in setup add; ```; extras_require={; 'development': set(dev_requirements),; 'test': dev_requirements,; ```; the set option should be needed for how pypi wants it given. . Add tildes pinning.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1263
https://github.com/qutip/qutip/issues/1263:78,Deployability,install,installation,78,"**Issue**; Currently, to develop qutip from source (e.g., installing from)the installation guide says to do ; ```; python setup.py develop; ```; However, it is [suggested](https://stackoverflow.com/questions/30306099/pip-install-editable-vs-python-setup-py-develop) to use the command; ```; pip -e .[development]; ```; This currently is not supported as there is no `development_requirements.txt` file. Also, in dev mode, one needs to install pytest, otherwise the `qt.run()` fails. If pytest as well as cython numpy and scipy were specified in such file, this should be done automatically. . Additionally, it may be ideal to pin only minor versions with tilde, stuff like `numpy~=1.18.1`, which should update micro releases but not minor. . **Describe the solution you'd like**; Add a `development_requirements.txt` file and in setup add; ```; extras_require={; 'development': set(dev_requirements),; 'test': dev_requirements,; ```; the set option should be needed for how pypi wants it given. . Add tildes pinning.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1263
https://github.com/qutip/qutip/issues/1263:221,Deployability,install,install-editable-vs-python-setup-py-develop,221,"**Issue**; Currently, to develop qutip from source (e.g., installing from)the installation guide says to do ; ```; python setup.py develop; ```; However, it is [suggested](https://stackoverflow.com/questions/30306099/pip-install-editable-vs-python-setup-py-develop) to use the command; ```; pip -e .[development]; ```; This currently is not supported as there is no `development_requirements.txt` file. Also, in dev mode, one needs to install pytest, otherwise the `qt.run()` fails. If pytest as well as cython numpy and scipy were specified in such file, this should be done automatically. . Additionally, it may be ideal to pin only minor versions with tilde, stuff like `numpy~=1.18.1`, which should update micro releases but not minor. . **Describe the solution you'd like**; Add a `development_requirements.txt` file and in setup add; ```; extras_require={; 'development': set(dev_requirements),; 'test': dev_requirements,; ```; the set option should be needed for how pypi wants it given. . Add tildes pinning.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1263
https://github.com/qutip/qutip/issues/1263:435,Deployability,install,install,435,"**Issue**; Currently, to develop qutip from source (e.g., installing from)the installation guide says to do ; ```; python setup.py develop; ```; However, it is [suggested](https://stackoverflow.com/questions/30306099/pip-install-editable-vs-python-setup-py-develop) to use the command; ```; pip -e .[development]; ```; This currently is not supported as there is no `development_requirements.txt` file. Also, in dev mode, one needs to install pytest, otherwise the `qt.run()` fails. If pytest as well as cython numpy and scipy were specified in such file, this should be done automatically. . Additionally, it may be ideal to pin only minor versions with tilde, stuff like `numpy~=1.18.1`, which should update micro releases but not minor. . **Describe the solution you'd like**; Add a `development_requirements.txt` file and in setup add; ```; extras_require={; 'development': set(dev_requirements),; 'test': dev_requirements,; ```; the set option should be needed for how pypi wants it given. . Add tildes pinning.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1263
https://github.com/qutip/qutip/issues/1263:703,Deployability,update,update,703,"**Issue**; Currently, to develop qutip from source (e.g., installing from)the installation guide says to do ; ```; python setup.py develop; ```; However, it is [suggested](https://stackoverflow.com/questions/30306099/pip-install-editable-vs-python-setup-py-develop) to use the command; ```; pip -e .[development]; ```; This currently is not supported as there is no `development_requirements.txt` file. Also, in dev mode, one needs to install pytest, otherwise the `qt.run()` fails. If pytest as well as cython numpy and scipy were specified in such file, this should be done automatically. . Additionally, it may be ideal to pin only minor versions with tilde, stuff like `numpy~=1.18.1`, which should update micro releases but not minor. . **Describe the solution you'd like**; Add a `development_requirements.txt` file and in setup add; ```; extras_require={; 'development': set(dev_requirements),; 'test': dev_requirements,; ```; the set option should be needed for how pypi wants it given. . Add tildes pinning.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1263
https://github.com/qutip/qutip/issues/1263:716,Deployability,release,releases,716,"**Issue**; Currently, to develop qutip from source (e.g., installing from)the installation guide says to do ; ```; python setup.py develop; ```; However, it is [suggested](https://stackoverflow.com/questions/30306099/pip-install-editable-vs-python-setup-py-develop) to use the command; ```; pip -e .[development]; ```; This currently is not supported as there is no `development_requirements.txt` file. Also, in dev mode, one needs to install pytest, otherwise the `qt.run()` fails. If pytest as well as cython numpy and scipy were specified in such file, this should be done automatically. . Additionally, it may be ideal to pin only minor versions with tilde, stuff like `numpy~=1.18.1`, which should update micro releases but not minor. . **Describe the solution you'd like**; Add a `development_requirements.txt` file and in setup add; ```; extras_require={; 'development': set(dev_requirements),; 'test': dev_requirements,; ```; the set option should be needed for how pypi wants it given. . Add tildes pinning.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1263
https://github.com/qutip/qutip/issues/1263:903,Testability,test,test,903,"**Issue**; Currently, to develop qutip from source (e.g., installing from)the installation guide says to do ; ```; python setup.py develop; ```; However, it is [suggested](https://stackoverflow.com/questions/30306099/pip-install-editable-vs-python-setup-py-develop) to use the command; ```; pip -e .[development]; ```; This currently is not supported as there is no `development_requirements.txt` file. Also, in dev mode, one needs to install pytest, otherwise the `qt.run()` fails. If pytest as well as cython numpy and scipy were specified in such file, this should be done automatically. . Additionally, it may be ideal to pin only minor versions with tilde, stuff like `numpy~=1.18.1`, which should update micro releases but not minor. . **Describe the solution you'd like**; Add a `development_requirements.txt` file and in setup add; ```; extras_require={; 'development': set(dev_requirements),; 'test': dev_requirements,; ```; the set option should be needed for how pypi wants it given. . Add tildes pinning.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1263
https://github.com/qutip/qutip/issues/1263:91,Usability,guid,guide,91,"**Issue**; Currently, to develop qutip from source (e.g., installing from)the installation guide says to do ; ```; python setup.py develop; ```; However, it is [suggested](https://stackoverflow.com/questions/30306099/pip-install-editable-vs-python-setup-py-develop) to use the command; ```; pip -e .[development]; ```; This currently is not supported as there is no `development_requirements.txt` file. Also, in dev mode, one needs to install pytest, otherwise the `qt.run()` fails. If pytest as well as cython numpy and scipy were specified in such file, this should be done automatically. . Additionally, it may be ideal to pin only minor versions with tilde, stuff like `numpy~=1.18.1`, which should update micro releases but not minor. . **Describe the solution you'd like**; Add a `development_requirements.txt` file and in setup add; ```; extras_require={; 'development': set(dev_requirements),; 'test': dev_requirements,; ```; the set option should be needed for how pypi wants it given. . Add tildes pinning.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1263
https://github.com/qutip/qutip/issues/1265:3616,Availability,error,error,3616,"en(pulse_set)), ['c_x', 'c_x_bug']):; plt.subplot(len(pulse_set),1,idx+1); plt.plot(time_test,pulse_set[idx](time_test,None),label=name); plt.legend(loc=1); plt.xlabel('time'); plt.show(). for idx, name in zip(range(len(pulse_set)), ['c_x', 'c_x_bug']):; H = [Hsys['Hq'],[Hsys['Hc_x'], pulse_set[idx]]]; result = qu.mesolve(H, psi0, time_test, Hsys['Hlbld'],; [qu.sigmax(), qu.sigmay(), qu.sigmaz()],; progress_bar=None, options=None); b = qu.Bloch(); b.clear(); Pg, Pe = [], []; qu_blochs = result.expect; plt.title('probability of excited state'); for i,j,k in zip(qu_blochs[0],qu_blochs[1],qu_blochs[2]):; points = [i,j,k]; b.add_points(points); P0, P1 = (1+k)/2.0, (1-k)/2.0; Pg.append(P0); Pe.append(P1); plt.subplot(len(pulse_set),1,idx+1); plt.plot(time_test, Pe, label=name); plt.legend(loc=1); bloch_set.append(b); plt.xlabel('time'); plt.show(); if bloch:; bloch_set[0].show(); bloch_set[1].show(); return result. # to run the test:; test_mesolve(time_test=np.arange(0,100,0.5), show_seq=True, bloch=False); ```. The terminal out put is; ```; ![sequence](https://user-images.githubusercontent.com/41005903/82047831-11976380-96e6-11ea-869d-7278ba1cbeaa.png); ![probability](https://user-images.githubusercontent.com/41005903/82047837-12c89080-96e6-11ea-98d6-0ba6528a50ad.png); ```. **Expected behavior**; As discussed above. **Your Environment**. QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; A. J. Pitchford, P. D. Nation, R. J. Johansson, A. Grimsmo, and C. Granade. QuTiP Version: 4.3.1; Numpy Version: 1.15.2; Scipy Version: 1.1.0; Cython Version: 0.28.4; Matplotlib Version: 3.0.3; Python Version: 3.5.5; Number of CPUs: 8; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Windows (AMD64); Installation path: D:\anaconda\envs\py3.5\lib\site-packages\qutip. **Additional context**; This issue is the same bug mention by @xlelephant at #1038 , but after trying the tweaking option mentioned by @nwlambert , we still get the same error.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1265
https://github.com/qutip/qutip/issues/1265:3308,Deployability,Install,Installed,3308,"en(pulse_set)), ['c_x', 'c_x_bug']):; plt.subplot(len(pulse_set),1,idx+1); plt.plot(time_test,pulse_set[idx](time_test,None),label=name); plt.legend(loc=1); plt.xlabel('time'); plt.show(). for idx, name in zip(range(len(pulse_set)), ['c_x', 'c_x_bug']):; H = [Hsys['Hq'],[Hsys['Hc_x'], pulse_set[idx]]]; result = qu.mesolve(H, psi0, time_test, Hsys['Hlbld'],; [qu.sigmax(), qu.sigmay(), qu.sigmaz()],; progress_bar=None, options=None); b = qu.Bloch(); b.clear(); Pg, Pe = [], []; qu_blochs = result.expect; plt.title('probability of excited state'); for i,j,k in zip(qu_blochs[0],qu_blochs[1],qu_blochs[2]):; points = [i,j,k]; b.add_points(points); P0, P1 = (1+k)/2.0, (1-k)/2.0; Pg.append(P0); Pe.append(P1); plt.subplot(len(pulse_set),1,idx+1); plt.plot(time_test, Pe, label=name); plt.legend(loc=1); bloch_set.append(b); plt.xlabel('time'); plt.show(); if bloch:; bloch_set[0].show(); bloch_set[1].show(); return result. # to run the test:; test_mesolve(time_test=np.arange(0,100,0.5), show_seq=True, bloch=False); ```. The terminal out put is; ```; ![sequence](https://user-images.githubusercontent.com/41005903/82047831-11976380-96e6-11ea-869d-7278ba1cbeaa.png); ![probability](https://user-images.githubusercontent.com/41005903/82047837-12c89080-96e6-11ea-98d6-0ba6528a50ad.png); ```. **Expected behavior**; As discussed above. **Your Environment**. QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; A. J. Pitchford, P. D. Nation, R. J. Johansson, A. Grimsmo, and C. Granade. QuTiP Version: 4.3.1; Numpy Version: 1.15.2; Scipy Version: 1.1.0; Cython Version: 0.28.4; Matplotlib Version: 3.0.3; Python Version: 3.5.5; Number of CPUs: 8; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Windows (AMD64); Installation path: D:\anaconda\envs\py3.5\lib\site-packages\qutip. **Additional context**; This issue is the same bug mention by @xlelephant at #1038 , but after trying the tweaking option mentioned by @nwlambert , we still get the same error.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1265
https://github.com/qutip/qutip/issues/1265:3379,Deployability,Install,Installation,3379,"en(pulse_set)), ['c_x', 'c_x_bug']):; plt.subplot(len(pulse_set),1,idx+1); plt.plot(time_test,pulse_set[idx](time_test,None),label=name); plt.legend(loc=1); plt.xlabel('time'); plt.show(). for idx, name in zip(range(len(pulse_set)), ['c_x', 'c_x_bug']):; H = [Hsys['Hq'],[Hsys['Hc_x'], pulse_set[idx]]]; result = qu.mesolve(H, psi0, time_test, Hsys['Hlbld'],; [qu.sigmax(), qu.sigmay(), qu.sigmaz()],; progress_bar=None, options=None); b = qu.Bloch(); b.clear(); Pg, Pe = [], []; qu_blochs = result.expect; plt.title('probability of excited state'); for i,j,k in zip(qu_blochs[0],qu_blochs[1],qu_blochs[2]):; points = [i,j,k]; b.add_points(points); P0, P1 = (1+k)/2.0, (1-k)/2.0; Pg.append(P0); Pe.append(P1); plt.subplot(len(pulse_set),1,idx+1); plt.plot(time_test, Pe, label=name); plt.legend(loc=1); bloch_set.append(b); plt.xlabel('time'); plt.show(); if bloch:; bloch_set[0].show(); bloch_set[1].show(); return result. # to run the test:; test_mesolve(time_test=np.arange(0,100,0.5), show_seq=True, bloch=False); ```. The terminal out put is; ```; ![sequence](https://user-images.githubusercontent.com/41005903/82047831-11976380-96e6-11ea-869d-7278ba1cbeaa.png); ![probability](https://user-images.githubusercontent.com/41005903/82047837-12c89080-96e6-11ea-98d6-0ba6528a50ad.png); ```. **Expected behavior**; As discussed above. **Your Environment**. QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; A. J. Pitchford, P. D. Nation, R. J. Johansson, A. Grimsmo, and C. Granade. QuTiP Version: 4.3.1; Numpy Version: 1.15.2; Scipy Version: 1.1.0; Cython Version: 0.28.4; Matplotlib Version: 3.0.3; Python Version: 3.5.5; Number of CPUs: 8; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Windows (AMD64); Installation path: D:\anaconda\envs\py3.5\lib\site-packages\qutip. **Additional context**; This issue is the same bug mention by @xlelephant at #1038 , but after trying the tweaking option mentioned by @nwlambert , we still get the same error.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1265
https://github.com/qutip/qutip/issues/1265:2559,Testability,test,test,2559,"t.figure(figsize=(10,5)); for idx, name in zip(range(len(pulse_set)), ['c_x', 'c_x_bug']):; plt.subplot(len(pulse_set),1,idx+1); plt.plot(time_test,pulse_set[idx](time_test,None),label=name); plt.legend(loc=1); plt.xlabel('time'); plt.show(). for idx, name in zip(range(len(pulse_set)), ['c_x', 'c_x_bug']):; H = [Hsys['Hq'],[Hsys['Hc_x'], pulse_set[idx]]]; result = qu.mesolve(H, psi0, time_test, Hsys['Hlbld'],; [qu.sigmax(), qu.sigmay(), qu.sigmaz()],; progress_bar=None, options=None); b = qu.Bloch(); b.clear(); Pg, Pe = [], []; qu_blochs = result.expect; plt.title('probability of excited state'); for i,j,k in zip(qu_blochs[0],qu_blochs[1],qu_blochs[2]):; points = [i,j,k]; b.add_points(points); P0, P1 = (1+k)/2.0, (1-k)/2.0; Pg.append(P0); Pe.append(P1); plt.subplot(len(pulse_set),1,idx+1); plt.plot(time_test, Pe, label=name); plt.legend(loc=1); bloch_set.append(b); plt.xlabel('time'); plt.show(); if bloch:; bloch_set[0].show(); bloch_set[1].show(); return result. # to run the test:; test_mesolve(time_test=np.arange(0,100,0.5), show_seq=True, bloch=False); ```. The terminal out put is; ```; ![sequence](https://user-images.githubusercontent.com/41005903/82047831-11976380-96e6-11ea-869d-7278ba1cbeaa.png); ![probability](https://user-images.githubusercontent.com/41005903/82047837-12c89080-96e6-11ea-98d6-0ba6528a50ad.png); ```. **Expected behavior**; As discussed above. **Your Environment**. QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; A. J. Pitchford, P. D. Nation, R. J. Johansson, A. Grimsmo, and C. Granade. QuTiP Version: 4.3.1; Numpy Version: 1.15.2; Scipy Version: 1.1.0; Cython Version: 0.28.4; Matplotlib Version: 3.0.3; Python Version: 3.5.5; Number of CPUs: 8; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Windows (AMD64); Installation path: D:\anaconda\envs\py3.5\lib\site-packages\qutip. **Additional context**; This issue is the same bug mention by @xlelephant at #1038 , but after trying the tweaking option m",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1265
https://github.com/qutip/qutip/issues/1265:2076,Usability,clear,clear,2076,"pi*x/w)) * ((x+w/2.)>0) * ((-x+w/2.)>0) * \; np.exp(1j*phase- 2j*np.pi*df*x). c_x = lambda t, arg: cosine_pulse(t, t0=piLen/2.0, amp=0.5*piAmp)+\; cosine_pulse(t, t0=1.0*piLen+piLen/2.0, amp=0.5*piAmp). c_x_bug = lambda t, arg: cosine_pulse(t, t0=piLen/2.0, amp=0.5*piAmp)+\; cosine_pulse(t, t0=3.0*piLen+piLen/2.0, amp=0.5*piAmp). pulse_set = [c_x, c_x_bug]; bloch_set = []. def test_mesolve(time_test=np.arange(0,100,0.5), show_seq=True, bloch=True):; if show_seq:; plt.figure(figsize=(10,5)); for idx, name in zip(range(len(pulse_set)), ['c_x', 'c_x_bug']):; plt.subplot(len(pulse_set),1,idx+1); plt.plot(time_test,pulse_set[idx](time_test,None),label=name); plt.legend(loc=1); plt.xlabel('time'); plt.show(). for idx, name in zip(range(len(pulse_set)), ['c_x', 'c_x_bug']):; H = [Hsys['Hq'],[Hsys['Hc_x'], pulse_set[idx]]]; result = qu.mesolve(H, psi0, time_test, Hsys['Hlbld'],; [qu.sigmax(), qu.sigmay(), qu.sigmaz()],; progress_bar=None, options=None); b = qu.Bloch(); b.clear(); Pg, Pe = [], []; qu_blochs = result.expect; plt.title('probability of excited state'); for i,j,k in zip(qu_blochs[0],qu_blochs[1],qu_blochs[2]):; points = [i,j,k]; b.add_points(points); P0, P1 = (1+k)/2.0, (1-k)/2.0; Pg.append(P0); Pe.append(P1); plt.subplot(len(pulse_set),1,idx+1); plt.plot(time_test, Pe, label=name); plt.legend(loc=1); bloch_set.append(b); plt.xlabel('time'); plt.show(); if bloch:; bloch_set[0].show(); bloch_set[1].show(); return result. # to run the test:; test_mesolve(time_test=np.arange(0,100,0.5), show_seq=True, bloch=False); ```. The terminal out put is; ```; ![sequence](https://user-images.githubusercontent.com/41005903/82047831-11976380-96e6-11ea-869d-7278ba1cbeaa.png); ![probability](https://user-images.githubusercontent.com/41005903/82047837-12c89080-96e6-11ea-98d6-0ba6528a50ad.png); ```. **Expected behavior**; As discussed above. **Your Environment**. QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; A. J. Pitchford, P. D. Nation, R. J. Johansson, A. Grims",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1265
https://github.com/qutip/qutip/issues/1266:131,Usability,clear,clear,131,"Currently, the issue template reads (for fearure requests):. **Is your feature request related to a problem? Please describe.**; A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]. **Describe the solution you'd like**; A clear and concise description of what you want to happen. **Describe alternatives you've considered**; A clear and concise description of any alternative solutions or features you've considered. **Additional context**; Add any other context or screenshots about the feature request here. Similarly, for bug reports, one finds:. **Describe the bug**; A clear and concise description of what the bug is. **To Reproduce**; Please provide a minimal working example. For instance:. ```python; from qutip import identity; print(identity(2)); ```; The terminal out put is; ```; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 1.]]; ```. **Expected behavior**; A clear and concise description of what you expected to happen. **Your Environment**; Please use `qutip.about()` to get the information about your environment and paste it here. **Additional context**; Add any other context about the problem here. -------------; The slight hiccup I find with these great templates introduced by @BoxiLi, especially in the first case above, is that many sub-titles need to be deleted by the user and are not uniform in the end. Something more standard could be achieved by clearly stating what lines should be removed by the user and are just explanations, and what are to be kept in the structure. Sometimes simply rewording the titles could help. For example:; From; ```; **Describe the solution you'd like**; A clear and concise description of what you want to happen.; ```; To something like; ```; **Feature Request Description**; +++ remove this line and the text example below; **Describe the solution you'd like**; A clear and concise description of what you want to happen.; +++ remove ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1266
https://github.com/qutip/qutip/issues/1266:263,Usability,clear,clear,263,"Currently, the issue template reads (for fearure requests):. **Is your feature request related to a problem? Please describe.**; A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]. **Describe the solution you'd like**; A clear and concise description of what you want to happen. **Describe alternatives you've considered**; A clear and concise description of any alternative solutions or features you've considered. **Additional context**; Add any other context or screenshots about the feature request here. Similarly, for bug reports, one finds:. **Describe the bug**; A clear and concise description of what the bug is. **To Reproduce**; Please provide a minimal working example. For instance:. ```python; from qutip import identity; print(identity(2)); ```; The terminal out put is; ```; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 1.]]; ```. **Expected behavior**; A clear and concise description of what you expected to happen. **Your Environment**; Please use `qutip.about()` to get the information about your environment and paste it here. **Additional context**; Add any other context about the problem here. -------------; The slight hiccup I find with these great templates introduced by @BoxiLi, especially in the first case above, is that many sub-titles need to be deleted by the user and are not uniform in the end. Something more standard could be achieved by clearly stating what lines should be removed by the user and are just explanations, and what are to be kept in the structure. Sometimes simply rewording the titles could help. For example:; From; ```; **Describe the solution you'd like**; A clear and concise description of what you want to happen.; ```; To something like; ```; **Feature Request Description**; +++ remove this line and the text example below; **Describe the solution you'd like**; A clear and concise description of what you want to happen.; +++ remove ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1266
https://github.com/qutip/qutip/issues/1266:368,Usability,clear,clear,368,"Currently, the issue template reads (for fearure requests):. **Is your feature request related to a problem? Please describe.**; A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]. **Describe the solution you'd like**; A clear and concise description of what you want to happen. **Describe alternatives you've considered**; A clear and concise description of any alternative solutions or features you've considered. **Additional context**; Add any other context or screenshots about the feature request here. Similarly, for bug reports, one finds:. **Describe the bug**; A clear and concise description of what the bug is. **To Reproduce**; Please provide a minimal working example. For instance:. ```python; from qutip import identity; print(identity(2)); ```; The terminal out put is; ```; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 1.]]; ```. **Expected behavior**; A clear and concise description of what you expected to happen. **Your Environment**; Please use `qutip.about()` to get the information about your environment and paste it here. **Additional context**; Add any other context about the problem here. -------------; The slight hiccup I find with these great templates introduced by @BoxiLi, especially in the first case above, is that many sub-titles need to be deleted by the user and are not uniform in the end. Something more standard could be achieved by clearly stating what lines should be removed by the user and are just explanations, and what are to be kept in the structure. Sometimes simply rewording the titles could help. For example:; From; ```; **Describe the solution you'd like**; A clear and concise description of what you want to happen.; ```; To something like; ```; **Feature Request Description**; +++ remove this line and the text example below; **Describe the solution you'd like**; A clear and concise description of what you want to happen.; +++ remove ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1266
https://github.com/qutip/qutip/issues/1266:615,Usability,clear,clear,615,"Currently, the issue template reads (for fearure requests):. **Is your feature request related to a problem? Please describe.**; A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]. **Describe the solution you'd like**; A clear and concise description of what you want to happen. **Describe alternatives you've considered**; A clear and concise description of any alternative solutions or features you've considered. **Additional context**; Add any other context or screenshots about the feature request here. Similarly, for bug reports, one finds:. **Describe the bug**; A clear and concise description of what the bug is. **To Reproduce**; Please provide a minimal working example. For instance:. ```python; from qutip import identity; print(identity(2)); ```; The terminal out put is; ```; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 1.]]; ```. **Expected behavior**; A clear and concise description of what you expected to happen. **Your Environment**; Please use `qutip.about()` to get the information about your environment and paste it here. **Additional context**; Add any other context about the problem here. -------------; The slight hiccup I find with these great templates introduced by @BoxiLi, especially in the first case above, is that many sub-titles need to be deleted by the user and are not uniform in the end. Something more standard could be achieved by clearly stating what lines should be removed by the user and are just explanations, and what are to be kept in the structure. Sometimes simply rewording the titles could help. For example:; From; ```; **Describe the solution you'd like**; A clear and concise description of what you want to happen.; ```; To something like; ```; **Feature Request Description**; +++ remove this line and the text example below; **Describe the solution you'd like**; A clear and concise description of what you want to happen.; +++ remove ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1266
https://github.com/qutip/qutip/issues/1266:976,Usability,clear,clear,976,"Currently, the issue template reads (for fearure requests):. **Is your feature request related to a problem? Please describe.**; A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]. **Describe the solution you'd like**; A clear and concise description of what you want to happen. **Describe alternatives you've considered**; A clear and concise description of any alternative solutions or features you've considered. **Additional context**; Add any other context or screenshots about the feature request here. Similarly, for bug reports, one finds:. **Describe the bug**; A clear and concise description of what the bug is. **To Reproduce**; Please provide a minimal working example. For instance:. ```python; from qutip import identity; print(identity(2)); ```; The terminal out put is; ```; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 1.]]; ```. **Expected behavior**; A clear and concise description of what you expected to happen. **Your Environment**; Please use `qutip.about()` to get the information about your environment and paste it here. **Additional context**; Add any other context about the problem here. -------------; The slight hiccup I find with these great templates introduced by @BoxiLi, especially in the first case above, is that many sub-titles need to be deleted by the user and are not uniform in the end. Something more standard could be achieved by clearly stating what lines should be removed by the user and are just explanations, and what are to be kept in the structure. Sometimes simply rewording the titles could help. For example:; From; ```; **Describe the solution you'd like**; A clear and concise description of what you want to happen.; ```; To something like; ```; **Feature Request Description**; +++ remove this line and the text example below; **Describe the solution you'd like**; A clear and concise description of what you want to happen.; +++ remove ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1266
https://github.com/qutip/qutip/issues/1266:1480,Usability,clear,clearly,1480,"he problem is. Ex. I'm always frustrated when [...]. **Describe the solution you'd like**; A clear and concise description of what you want to happen. **Describe alternatives you've considered**; A clear and concise description of any alternative solutions or features you've considered. **Additional context**; Add any other context or screenshots about the feature request here. Similarly, for bug reports, one finds:. **Describe the bug**; A clear and concise description of what the bug is. **To Reproduce**; Please provide a minimal working example. For instance:. ```python; from qutip import identity; print(identity(2)); ```; The terminal out put is; ```; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 1.]]; ```. **Expected behavior**; A clear and concise description of what you expected to happen. **Your Environment**; Please use `qutip.about()` to get the information about your environment and paste it here. **Additional context**; Add any other context about the problem here. -------------; The slight hiccup I find with these great templates introduced by @BoxiLi, especially in the first case above, is that many sub-titles need to be deleted by the user and are not uniform in the end. Something more standard could be achieved by clearly stating what lines should be removed by the user and are just explanations, and what are to be kept in the structure. Sometimes simply rewording the titles could help. For example:; From; ```; **Describe the solution you'd like**; A clear and concise description of what you want to happen.; ```; To something like; ```; **Feature Request Description**; +++ remove this line and the text example below; **Describe the solution you'd like**; A clear and concise description of what you want to happen.; +++ remove this line and the text example above; ```; or something like that. Similarly, ; ```; **Describe the bug** ; ```; could become; ```; **Bug description** ; ```; and so on.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1266
https://github.com/qutip/qutip/issues/1266:1616,Usability,simpl,simply,1616,"he problem is. Ex. I'm always frustrated when [...]. **Describe the solution you'd like**; A clear and concise description of what you want to happen. **Describe alternatives you've considered**; A clear and concise description of any alternative solutions or features you've considered. **Additional context**; Add any other context or screenshots about the feature request here. Similarly, for bug reports, one finds:. **Describe the bug**; A clear and concise description of what the bug is. **To Reproduce**; Please provide a minimal working example. For instance:. ```python; from qutip import identity; print(identity(2)); ```; The terminal out put is; ```; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 1.]]; ```. **Expected behavior**; A clear and concise description of what you expected to happen. **Your Environment**; Please use `qutip.about()` to get the information about your environment and paste it here. **Additional context**; Add any other context about the problem here. -------------; The slight hiccup I find with these great templates introduced by @BoxiLi, especially in the first case above, is that many sub-titles need to be deleted by the user and are not uniform in the end. Something more standard could be achieved by clearly stating what lines should be removed by the user and are just explanations, and what are to be kept in the structure. Sometimes simply rewording the titles could help. For example:; From; ```; **Describe the solution you'd like**; A clear and concise description of what you want to happen.; ```; To something like; ```; **Feature Request Description**; +++ remove this line and the text example below; **Describe the solution you'd like**; A clear and concise description of what you want to happen.; +++ remove this line and the text example above; ```; or something like that. Similarly, ; ```; **Describe the bug** ; ```; could become; ```; **Bug description** ; ```; and so on.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1266
https://github.com/qutip/qutip/issues/1266:1721,Usability,clear,clear,1721,"he problem is. Ex. I'm always frustrated when [...]. **Describe the solution you'd like**; A clear and concise description of what you want to happen. **Describe alternatives you've considered**; A clear and concise description of any alternative solutions or features you've considered. **Additional context**; Add any other context or screenshots about the feature request here. Similarly, for bug reports, one finds:. **Describe the bug**; A clear and concise description of what the bug is. **To Reproduce**; Please provide a minimal working example. For instance:. ```python; from qutip import identity; print(identity(2)); ```; The terminal out put is; ```; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 1.]]; ```. **Expected behavior**; A clear and concise description of what you expected to happen. **Your Environment**; Please use `qutip.about()` to get the information about your environment and paste it here. **Additional context**; Add any other context about the problem here. -------------; The slight hiccup I find with these great templates introduced by @BoxiLi, especially in the first case above, is that many sub-titles need to be deleted by the user and are not uniform in the end. Something more standard could be achieved by clearly stating what lines should be removed by the user and are just explanations, and what are to be kept in the structure. Sometimes simply rewording the titles could help. For example:; From; ```; **Describe the solution you'd like**; A clear and concise description of what you want to happen.; ```; To something like; ```; **Feature Request Description**; +++ remove this line and the text example below; **Describe the solution you'd like**; A clear and concise description of what you want to happen.; +++ remove this line and the text example above; ```; or something like that. Similarly, ; ```; **Describe the bug** ; ```; could become; ```; **Bug description** ; ```; and so on.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1266
https://github.com/qutip/qutip/issues/1266:1931,Usability,clear,clear,1931,"he problem is. Ex. I'm always frustrated when [...]. **Describe the solution you'd like**; A clear and concise description of what you want to happen. **Describe alternatives you've considered**; A clear and concise description of any alternative solutions or features you've considered. **Additional context**; Add any other context or screenshots about the feature request here. Similarly, for bug reports, one finds:. **Describe the bug**; A clear and concise description of what the bug is. **To Reproduce**; Please provide a minimal working example. For instance:. ```python; from qutip import identity; print(identity(2)); ```; The terminal out put is; ```; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 1.]]; ```. **Expected behavior**; A clear and concise description of what you expected to happen. **Your Environment**; Please use `qutip.about()` to get the information about your environment and paste it here. **Additional context**; Add any other context about the problem here. -------------; The slight hiccup I find with these great templates introduced by @BoxiLi, especially in the first case above, is that many sub-titles need to be deleted by the user and are not uniform in the end. Something more standard could be achieved by clearly stating what lines should be removed by the user and are just explanations, and what are to be kept in the structure. Sometimes simply rewording the titles could help. For example:; From; ```; **Describe the solution you'd like**; A clear and concise description of what you want to happen.; ```; To something like; ```; **Feature Request Description**; +++ remove this line and the text example below; **Describe the solution you'd like**; A clear and concise description of what you want to happen.; +++ remove this line and the text example above; ```; or something like that. Similarly, ; ```; **Describe the bug** ; ```; could become; ```; **Bug description** ; ```; and so on.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1266
https://github.com/qutip/qutip/issues/1267:166,Availability,robust,robust,166,"**Testing fails on several platforms**; In QuTiP 4.5.1, several `skipif`have been introduced to avoid build fail on Mac. Similarly, there are other issues related to robust random objects testing. . **Describe the solution you'd like**; An option could be using [`xdist`](https://docs.pytest.org/en/3.0.1/xdist.html) to allow specifics of certain tests, as it seems to have, beyond parallelization, some potentially interesting multi-platform coverage.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1267
https://github.com/qutip/qutip/issues/1267:96,Safety,avoid,avoid,96,"**Testing fails on several platforms**; In QuTiP 4.5.1, several `skipif`have been introduced to avoid build fail on Mac. Similarly, there are other issues related to robust random objects testing. . **Describe the solution you'd like**; An option could be using [`xdist`](https://docs.pytest.org/en/3.0.1/xdist.html) to allow specifics of certain tests, as it seems to have, beyond parallelization, some potentially interesting multi-platform coverage.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1267
https://github.com/qutip/qutip/issues/1267:2,Testability,Test,Testing,2,"**Testing fails on several platforms**; In QuTiP 4.5.1, several `skipif`have been introduced to avoid build fail on Mac. Similarly, there are other issues related to robust random objects testing. . **Describe the solution you'd like**; An option could be using [`xdist`](https://docs.pytest.org/en/3.0.1/xdist.html) to allow specifics of certain tests, as it seems to have, beyond parallelization, some potentially interesting multi-platform coverage.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1267
https://github.com/qutip/qutip/issues/1267:188,Testability,test,testing,188,"**Testing fails on several platforms**; In QuTiP 4.5.1, several `skipif`have been introduced to avoid build fail on Mac. Similarly, there are other issues related to robust random objects testing. . **Describe the solution you'd like**; An option could be using [`xdist`](https://docs.pytest.org/en/3.0.1/xdist.html) to allow specifics of certain tests, as it seems to have, beyond parallelization, some potentially interesting multi-platform coverage.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1267
https://github.com/qutip/qutip/issues/1267:347,Testability,test,tests,347,"**Testing fails on several platforms**; In QuTiP 4.5.1, several `skipif`have been introduced to avoid build fail on Mac. Similarly, there are other issues related to robust random objects testing. . **Describe the solution you'd like**; An option could be using [`xdist`](https://docs.pytest.org/en/3.0.1/xdist.html) to allow specifics of certain tests, as it seems to have, beyond parallelization, some potentially interesting multi-platform coverage.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1267
https://github.com/qutip/qutip/issues/1268:1328,Availability,robust,robust,1328,"**Is your feature request related to a problem? Please describe.**; A lot of issues in test fail seem to arise from random objects (as well as low-level math in MKL and/or cython issues). . **Describe the solution you'd like**; There are several options at hand. . ### stick to pytest and be creative; A possible fix in testing may be to add randomly generated data that then is pointed at or fix seeds.; **Pros**: fast (?); **Cons**: technical debt. ### pytest-randomly plugin; [pytest-randomly](https://github.com/pytest-dev/pytest-randomly) is a pytest plugin that addresses this kind of issues. It allows to control `random.seed`, rather than `numpy.random.seed`. ; **Pros**: pytest plugin, supports doctest. ; **Cons**: not super popular, not designed for numpy; ; ### property-based testing with Hypothesis; Hypothesis is a library that aims at changing the way tests are designed, allegedly: it should go from testing an instance to designing a test that applies to a domain of instances ([property-based testing](https://hypothesis.works/)). It is not super clear to me right now. ; It contains various randomness-related features, including a [seed function](https://hypothesis.readthedocs.io/en/latest/reproducing.html#hypothesis.seed). **Pros**: sounds powerful and clever, popular and growing, well documented, more robust even beyond this randomness problems.; **Cons**: radical change of testing framework (?), steep learning curve (?), overkill (?). I also admit I used nose until recently / used with pytest tests thought for nose, without taking advantage of pytest full power.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1268
https://github.com/qutip/qutip/issues/1268:1264,Energy Efficiency,power,powerful,1264,"**Is your feature request related to a problem? Please describe.**; A lot of issues in test fail seem to arise from random objects (as well as low-level math in MKL and/or cython issues). . **Describe the solution you'd like**; There are several options at hand. . ### stick to pytest and be creative; A possible fix in testing may be to add randomly generated data that then is pointed at or fix seeds.; **Pros**: fast (?); **Cons**: technical debt. ### pytest-randomly plugin; [pytest-randomly](https://github.com/pytest-dev/pytest-randomly) is a pytest plugin that addresses this kind of issues. It allows to control `random.seed`, rather than `numpy.random.seed`. ; **Pros**: pytest plugin, supports doctest. ; **Cons**: not super popular, not designed for numpy; ; ### property-based testing with Hypothesis; Hypothesis is a library that aims at changing the way tests are designed, allegedly: it should go from testing an instance to designing a test that applies to a domain of instances ([property-based testing](https://hypothesis.works/)). It is not super clear to me right now. ; It contains various randomness-related features, including a [seed function](https://hypothesis.readthedocs.io/en/latest/reproducing.html#hypothesis.seed). **Pros**: sounds powerful and clever, popular and growing, well documented, more robust even beyond this randomness problems.; **Cons**: radical change of testing framework (?), steep learning curve (?), overkill (?). I also admit I used nose until recently / used with pytest tests thought for nose, without taking advantage of pytest full power.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1268
https://github.com/qutip/qutip/issues/1268:1588,Energy Efficiency,power,power,1588,"**Is your feature request related to a problem? Please describe.**; A lot of issues in test fail seem to arise from random objects (as well as low-level math in MKL and/or cython issues). . **Describe the solution you'd like**; There are several options at hand. . ### stick to pytest and be creative; A possible fix in testing may be to add randomly generated data that then is pointed at or fix seeds.; **Pros**: fast (?); **Cons**: technical debt. ### pytest-randomly plugin; [pytest-randomly](https://github.com/pytest-dev/pytest-randomly) is a pytest plugin that addresses this kind of issues. It allows to control `random.seed`, rather than `numpy.random.seed`. ; **Pros**: pytest plugin, supports doctest. ; **Cons**: not super popular, not designed for numpy; ; ### property-based testing with Hypothesis; Hypothesis is a library that aims at changing the way tests are designed, allegedly: it should go from testing an instance to designing a test that applies to a domain of instances ([property-based testing](https://hypothesis.works/)). It is not super clear to me right now. ; It contains various randomness-related features, including a [seed function](https://hypothesis.readthedocs.io/en/latest/reproducing.html#hypothesis.seed). **Pros**: sounds powerful and clever, popular and growing, well documented, more robust even beyond this randomness problems.; **Cons**: radical change of testing framework (?), steep learning curve (?), overkill (?). I also admit I used nose until recently / used with pytest tests thought for nose, without taking advantage of pytest full power.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1268
https://github.com/qutip/qutip/issues/1268:471,Modifiability,plugin,plugin,471,"**Is your feature request related to a problem? Please describe.**; A lot of issues in test fail seem to arise from random objects (as well as low-level math in MKL and/or cython issues). . **Describe the solution you'd like**; There are several options at hand. . ### stick to pytest and be creative; A possible fix in testing may be to add randomly generated data that then is pointed at or fix seeds.; **Pros**: fast (?); **Cons**: technical debt. ### pytest-randomly plugin; [pytest-randomly](https://github.com/pytest-dev/pytest-randomly) is a pytest plugin that addresses this kind of issues. It allows to control `random.seed`, rather than `numpy.random.seed`. ; **Pros**: pytest plugin, supports doctest. ; **Cons**: not super popular, not designed for numpy; ; ### property-based testing with Hypothesis; Hypothesis is a library that aims at changing the way tests are designed, allegedly: it should go from testing an instance to designing a test that applies to a domain of instances ([property-based testing](https://hypothesis.works/)). It is not super clear to me right now. ; It contains various randomness-related features, including a [seed function](https://hypothesis.readthedocs.io/en/latest/reproducing.html#hypothesis.seed). **Pros**: sounds powerful and clever, popular and growing, well documented, more robust even beyond this randomness problems.; **Cons**: radical change of testing framework (?), steep learning curve (?), overkill (?). I also admit I used nose until recently / used with pytest tests thought for nose, without taking advantage of pytest full power.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1268
https://github.com/qutip/qutip/issues/1268:556,Modifiability,plugin,plugin,556,"**Is your feature request related to a problem? Please describe.**; A lot of issues in test fail seem to arise from random objects (as well as low-level math in MKL and/or cython issues). . **Describe the solution you'd like**; There are several options at hand. . ### stick to pytest and be creative; A possible fix in testing may be to add randomly generated data that then is pointed at or fix seeds.; **Pros**: fast (?); **Cons**: technical debt. ### pytest-randomly plugin; [pytest-randomly](https://github.com/pytest-dev/pytest-randomly) is a pytest plugin that addresses this kind of issues. It allows to control `random.seed`, rather than `numpy.random.seed`. ; **Pros**: pytest plugin, supports doctest. ; **Cons**: not super popular, not designed for numpy; ; ### property-based testing with Hypothesis; Hypothesis is a library that aims at changing the way tests are designed, allegedly: it should go from testing an instance to designing a test that applies to a domain of instances ([property-based testing](https://hypothesis.works/)). It is not super clear to me right now. ; It contains various randomness-related features, including a [seed function](https://hypothesis.readthedocs.io/en/latest/reproducing.html#hypothesis.seed). **Pros**: sounds powerful and clever, popular and growing, well documented, more robust even beyond this randomness problems.; **Cons**: radical change of testing framework (?), steep learning curve (?), overkill (?). I also admit I used nose until recently / used with pytest tests thought for nose, without taking advantage of pytest full power.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1268
https://github.com/qutip/qutip/issues/1268:687,Modifiability,plugin,plugin,687,"**Is your feature request related to a problem? Please describe.**; A lot of issues in test fail seem to arise from random objects (as well as low-level math in MKL and/or cython issues). . **Describe the solution you'd like**; There are several options at hand. . ### stick to pytest and be creative; A possible fix in testing may be to add randomly generated data that then is pointed at or fix seeds.; **Pros**: fast (?); **Cons**: technical debt. ### pytest-randomly plugin; [pytest-randomly](https://github.com/pytest-dev/pytest-randomly) is a pytest plugin that addresses this kind of issues. It allows to control `random.seed`, rather than `numpy.random.seed`. ; **Pros**: pytest plugin, supports doctest. ; **Cons**: not super popular, not designed for numpy; ; ### property-based testing with Hypothesis; Hypothesis is a library that aims at changing the way tests are designed, allegedly: it should go from testing an instance to designing a test that applies to a domain of instances ([property-based testing](https://hypothesis.works/)). It is not super clear to me right now. ; It contains various randomness-related features, including a [seed function](https://hypothesis.readthedocs.io/en/latest/reproducing.html#hypothesis.seed). **Pros**: sounds powerful and clever, popular and growing, well documented, more robust even beyond this randomness problems.; **Cons**: radical change of testing framework (?), steep learning curve (?), overkill (?). I also admit I used nose until recently / used with pytest tests thought for nose, without taking advantage of pytest full power.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1268
https://github.com/qutip/qutip/issues/1268:87,Testability,test,test,87,"**Is your feature request related to a problem? Please describe.**; A lot of issues in test fail seem to arise from random objects (as well as low-level math in MKL and/or cython issues). . **Describe the solution you'd like**; There are several options at hand. . ### stick to pytest and be creative; A possible fix in testing may be to add randomly generated data that then is pointed at or fix seeds.; **Pros**: fast (?); **Cons**: technical debt. ### pytest-randomly plugin; [pytest-randomly](https://github.com/pytest-dev/pytest-randomly) is a pytest plugin that addresses this kind of issues. It allows to control `random.seed`, rather than `numpy.random.seed`. ; **Pros**: pytest plugin, supports doctest. ; **Cons**: not super popular, not designed for numpy; ; ### property-based testing with Hypothesis; Hypothesis is a library that aims at changing the way tests are designed, allegedly: it should go from testing an instance to designing a test that applies to a domain of instances ([property-based testing](https://hypothesis.works/)). It is not super clear to me right now. ; It contains various randomness-related features, including a [seed function](https://hypothesis.readthedocs.io/en/latest/reproducing.html#hypothesis.seed). **Pros**: sounds powerful and clever, popular and growing, well documented, more robust even beyond this randomness problems.; **Cons**: radical change of testing framework (?), steep learning curve (?), overkill (?). I also admit I used nose until recently / used with pytest tests thought for nose, without taking advantage of pytest full power.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1268
https://github.com/qutip/qutip/issues/1268:320,Testability,test,testing,320,"**Is your feature request related to a problem? Please describe.**; A lot of issues in test fail seem to arise from random objects (as well as low-level math in MKL and/or cython issues). . **Describe the solution you'd like**; There are several options at hand. . ### stick to pytest and be creative; A possible fix in testing may be to add randomly generated data that then is pointed at or fix seeds.; **Pros**: fast (?); **Cons**: technical debt. ### pytest-randomly plugin; [pytest-randomly](https://github.com/pytest-dev/pytest-randomly) is a pytest plugin that addresses this kind of issues. It allows to control `random.seed`, rather than `numpy.random.seed`. ; **Pros**: pytest plugin, supports doctest. ; **Cons**: not super popular, not designed for numpy; ; ### property-based testing with Hypothesis; Hypothesis is a library that aims at changing the way tests are designed, allegedly: it should go from testing an instance to designing a test that applies to a domain of instances ([property-based testing](https://hypothesis.works/)). It is not super clear to me right now. ; It contains various randomness-related features, including a [seed function](https://hypothesis.readthedocs.io/en/latest/reproducing.html#hypothesis.seed). **Pros**: sounds powerful and clever, popular and growing, well documented, more robust even beyond this randomness problems.; **Cons**: radical change of testing framework (?), steep learning curve (?), overkill (?). I also admit I used nose until recently / used with pytest tests thought for nose, without taking advantage of pytest full power.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1268
https://github.com/qutip/qutip/issues/1268:789,Testability,test,testing,789,"**Is your feature request related to a problem? Please describe.**; A lot of issues in test fail seem to arise from random objects (as well as low-level math in MKL and/or cython issues). . **Describe the solution you'd like**; There are several options at hand. . ### stick to pytest and be creative; A possible fix in testing may be to add randomly generated data that then is pointed at or fix seeds.; **Pros**: fast (?); **Cons**: technical debt. ### pytest-randomly plugin; [pytest-randomly](https://github.com/pytest-dev/pytest-randomly) is a pytest plugin that addresses this kind of issues. It allows to control `random.seed`, rather than `numpy.random.seed`. ; **Pros**: pytest plugin, supports doctest. ; **Cons**: not super popular, not designed for numpy; ; ### property-based testing with Hypothesis; Hypothesis is a library that aims at changing the way tests are designed, allegedly: it should go from testing an instance to designing a test that applies to a domain of instances ([property-based testing](https://hypothesis.works/)). It is not super clear to me right now. ; It contains various randomness-related features, including a [seed function](https://hypothesis.readthedocs.io/en/latest/reproducing.html#hypothesis.seed). **Pros**: sounds powerful and clever, popular and growing, well documented, more robust even beyond this randomness problems.; **Cons**: radical change of testing framework (?), steep learning curve (?), overkill (?). I also admit I used nose until recently / used with pytest tests thought for nose, without taking advantage of pytest full power.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1268
https://github.com/qutip/qutip/issues/1268:868,Testability,test,tests,868,"**Is your feature request related to a problem? Please describe.**; A lot of issues in test fail seem to arise from random objects (as well as low-level math in MKL and/or cython issues). . **Describe the solution you'd like**; There are several options at hand. . ### stick to pytest and be creative; A possible fix in testing may be to add randomly generated data that then is pointed at or fix seeds.; **Pros**: fast (?); **Cons**: technical debt. ### pytest-randomly plugin; [pytest-randomly](https://github.com/pytest-dev/pytest-randomly) is a pytest plugin that addresses this kind of issues. It allows to control `random.seed`, rather than `numpy.random.seed`. ; **Pros**: pytest plugin, supports doctest. ; **Cons**: not super popular, not designed for numpy; ; ### property-based testing with Hypothesis; Hypothesis is a library that aims at changing the way tests are designed, allegedly: it should go from testing an instance to designing a test that applies to a domain of instances ([property-based testing](https://hypothesis.works/)). It is not super clear to me right now. ; It contains various randomness-related features, including a [seed function](https://hypothesis.readthedocs.io/en/latest/reproducing.html#hypothesis.seed). **Pros**: sounds powerful and clever, popular and growing, well documented, more robust even beyond this randomness problems.; **Cons**: radical change of testing framework (?), steep learning curve (?), overkill (?). I also admit I used nose until recently / used with pytest tests thought for nose, without taking advantage of pytest full power.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1268
https://github.com/qutip/qutip/issues/1268:917,Testability,test,testing,917,"**Is your feature request related to a problem? Please describe.**; A lot of issues in test fail seem to arise from random objects (as well as low-level math in MKL and/or cython issues). . **Describe the solution you'd like**; There are several options at hand. . ### stick to pytest and be creative; A possible fix in testing may be to add randomly generated data that then is pointed at or fix seeds.; **Pros**: fast (?); **Cons**: technical debt. ### pytest-randomly plugin; [pytest-randomly](https://github.com/pytest-dev/pytest-randomly) is a pytest plugin that addresses this kind of issues. It allows to control `random.seed`, rather than `numpy.random.seed`. ; **Pros**: pytest plugin, supports doctest. ; **Cons**: not super popular, not designed for numpy; ; ### property-based testing with Hypothesis; Hypothesis is a library that aims at changing the way tests are designed, allegedly: it should go from testing an instance to designing a test that applies to a domain of instances ([property-based testing](https://hypothesis.works/)). It is not super clear to me right now. ; It contains various randomness-related features, including a [seed function](https://hypothesis.readthedocs.io/en/latest/reproducing.html#hypothesis.seed). **Pros**: sounds powerful and clever, popular and growing, well documented, more robust even beyond this randomness problems.; **Cons**: radical change of testing framework (?), steep learning curve (?), overkill (?). I also admit I used nose until recently / used with pytest tests thought for nose, without taking advantage of pytest full power.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1268
https://github.com/qutip/qutip/issues/1268:952,Testability,test,test,952,"**Is your feature request related to a problem? Please describe.**; A lot of issues in test fail seem to arise from random objects (as well as low-level math in MKL and/or cython issues). . **Describe the solution you'd like**; There are several options at hand. . ### stick to pytest and be creative; A possible fix in testing may be to add randomly generated data that then is pointed at or fix seeds.; **Pros**: fast (?); **Cons**: technical debt. ### pytest-randomly plugin; [pytest-randomly](https://github.com/pytest-dev/pytest-randomly) is a pytest plugin that addresses this kind of issues. It allows to control `random.seed`, rather than `numpy.random.seed`. ; **Pros**: pytest plugin, supports doctest. ; **Cons**: not super popular, not designed for numpy; ; ### property-based testing with Hypothesis; Hypothesis is a library that aims at changing the way tests are designed, allegedly: it should go from testing an instance to designing a test that applies to a domain of instances ([property-based testing](https://hypothesis.works/)). It is not super clear to me right now. ; It contains various randomness-related features, including a [seed function](https://hypothesis.readthedocs.io/en/latest/reproducing.html#hypothesis.seed). **Pros**: sounds powerful and clever, popular and growing, well documented, more robust even beyond this randomness problems.; **Cons**: radical change of testing framework (?), steep learning curve (?), overkill (?). I also admit I used nose until recently / used with pytest tests thought for nose, without taking advantage of pytest full power.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1268
https://github.com/qutip/qutip/issues/1268:1012,Testability,test,testing,1012,"**Is your feature request related to a problem? Please describe.**; A lot of issues in test fail seem to arise from random objects (as well as low-level math in MKL and/or cython issues). . **Describe the solution you'd like**; There are several options at hand. . ### stick to pytest and be creative; A possible fix in testing may be to add randomly generated data that then is pointed at or fix seeds.; **Pros**: fast (?); **Cons**: technical debt. ### pytest-randomly plugin; [pytest-randomly](https://github.com/pytest-dev/pytest-randomly) is a pytest plugin that addresses this kind of issues. It allows to control `random.seed`, rather than `numpy.random.seed`. ; **Pros**: pytest plugin, supports doctest. ; **Cons**: not super popular, not designed for numpy; ; ### property-based testing with Hypothesis; Hypothesis is a library that aims at changing the way tests are designed, allegedly: it should go from testing an instance to designing a test that applies to a domain of instances ([property-based testing](https://hypothesis.works/)). It is not super clear to me right now. ; It contains various randomness-related features, including a [seed function](https://hypothesis.readthedocs.io/en/latest/reproducing.html#hypothesis.seed). **Pros**: sounds powerful and clever, popular and growing, well documented, more robust even beyond this randomness problems.; **Cons**: radical change of testing framework (?), steep learning curve (?), overkill (?). I also admit I used nose until recently / used with pytest tests thought for nose, without taking advantage of pytest full power.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1268
https://github.com/qutip/qutip/issues/1268:1402,Testability,test,testing,1402,"**Is your feature request related to a problem? Please describe.**; A lot of issues in test fail seem to arise from random objects (as well as low-level math in MKL and/or cython issues). . **Describe the solution you'd like**; There are several options at hand. . ### stick to pytest and be creative; A possible fix in testing may be to add randomly generated data that then is pointed at or fix seeds.; **Pros**: fast (?); **Cons**: technical debt. ### pytest-randomly plugin; [pytest-randomly](https://github.com/pytest-dev/pytest-randomly) is a pytest plugin that addresses this kind of issues. It allows to control `random.seed`, rather than `numpy.random.seed`. ; **Pros**: pytest plugin, supports doctest. ; **Cons**: not super popular, not designed for numpy; ; ### property-based testing with Hypothesis; Hypothesis is a library that aims at changing the way tests are designed, allegedly: it should go from testing an instance to designing a test that applies to a domain of instances ([property-based testing](https://hypothesis.works/)). It is not super clear to me right now. ; It contains various randomness-related features, including a [seed function](https://hypothesis.readthedocs.io/en/latest/reproducing.html#hypothesis.seed). **Pros**: sounds powerful and clever, popular and growing, well documented, more robust even beyond this randomness problems.; **Cons**: radical change of testing framework (?), steep learning curve (?), overkill (?). I also admit I used nose until recently / used with pytest tests thought for nose, without taking advantage of pytest full power.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1268
https://github.com/qutip/qutip/issues/1268:1524,Testability,test,tests,1524,"**Is your feature request related to a problem? Please describe.**; A lot of issues in test fail seem to arise from random objects (as well as low-level math in MKL and/or cython issues). . **Describe the solution you'd like**; There are several options at hand. . ### stick to pytest and be creative; A possible fix in testing may be to add randomly generated data that then is pointed at or fix seeds.; **Pros**: fast (?); **Cons**: technical debt. ### pytest-randomly plugin; [pytest-randomly](https://github.com/pytest-dev/pytest-randomly) is a pytest plugin that addresses this kind of issues. It allows to control `random.seed`, rather than `numpy.random.seed`. ; **Pros**: pytest plugin, supports doctest. ; **Cons**: not super popular, not designed for numpy; ; ### property-based testing with Hypothesis; Hypothesis is a library that aims at changing the way tests are designed, allegedly: it should go from testing an instance to designing a test that applies to a domain of instances ([property-based testing](https://hypothesis.works/)). It is not super clear to me right now. ; It contains various randomness-related features, including a [seed function](https://hypothesis.readthedocs.io/en/latest/reproducing.html#hypothesis.seed). **Pros**: sounds powerful and clever, popular and growing, well documented, more robust even beyond this randomness problems.; **Cons**: radical change of testing framework (?), steep learning curve (?), overkill (?). I also admit I used nose until recently / used with pytest tests thought for nose, without taking advantage of pytest full power.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1268
https://github.com/qutip/qutip/issues/1268:1066,Usability,clear,clear,1066,"**Is your feature request related to a problem? Please describe.**; A lot of issues in test fail seem to arise from random objects (as well as low-level math in MKL and/or cython issues). . **Describe the solution you'd like**; There are several options at hand. . ### stick to pytest and be creative; A possible fix in testing may be to add randomly generated data that then is pointed at or fix seeds.; **Pros**: fast (?); **Cons**: technical debt. ### pytest-randomly plugin; [pytest-randomly](https://github.com/pytest-dev/pytest-randomly) is a pytest plugin that addresses this kind of issues. It allows to control `random.seed`, rather than `numpy.random.seed`. ; **Pros**: pytest plugin, supports doctest. ; **Cons**: not super popular, not designed for numpy; ; ### property-based testing with Hypothesis; Hypothesis is a library that aims at changing the way tests are designed, allegedly: it should go from testing an instance to designing a test that applies to a domain of instances ([property-based testing](https://hypothesis.works/)). It is not super clear to me right now. ; It contains various randomness-related features, including a [seed function](https://hypothesis.readthedocs.io/en/latest/reproducing.html#hypothesis.seed). **Pros**: sounds powerful and clever, popular and growing, well documented, more robust even beyond this randomness problems.; **Cons**: radical change of testing framework (?), steep learning curve (?), overkill (?). I also admit I used nose until recently / used with pytest tests thought for nose, without taking advantage of pytest full power.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1268
https://github.com/qutip/qutip/issues/1268:1431,Usability,learn,learning,1431,"**Is your feature request related to a problem? Please describe.**; A lot of issues in test fail seem to arise from random objects (as well as low-level math in MKL and/or cython issues). . **Describe the solution you'd like**; There are several options at hand. . ### stick to pytest and be creative; A possible fix in testing may be to add randomly generated data that then is pointed at or fix seeds.; **Pros**: fast (?); **Cons**: technical debt. ### pytest-randomly plugin; [pytest-randomly](https://github.com/pytest-dev/pytest-randomly) is a pytest plugin that addresses this kind of issues. It allows to control `random.seed`, rather than `numpy.random.seed`. ; **Pros**: pytest plugin, supports doctest. ; **Cons**: not super popular, not designed for numpy; ; ### property-based testing with Hypothesis; Hypothesis is a library that aims at changing the way tests are designed, allegedly: it should go from testing an instance to designing a test that applies to a domain of instances ([property-based testing](https://hypothesis.works/)). It is not super clear to me right now. ; It contains various randomness-related features, including a [seed function](https://hypothesis.readthedocs.io/en/latest/reproducing.html#hypothesis.seed). **Pros**: sounds powerful and clever, popular and growing, well documented, more robust even beyond this randomness problems.; **Cons**: radical change of testing framework (?), steep learning curve (?), overkill (?). I also admit I used nose until recently / used with pytest tests thought for nose, without taking advantage of pytest full power.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1268
https://github.com/qutip/qutip/pull/1270:1458,Availability,error,error,1458,"**Checklist**; Thank you for contributing to QuTiP! Please make sure you have finished the following tasks before opening the PR. - [ ] Please read [Contributing to QuTiP Development](https://github.com/qutip/qutip-doc/blob/master/qutip_dev_contrib.md); - [ ] Contributions to qutip should follow the [pep8 style](https://www.python.org/dev/peps/pep-0008/).; You can use [pycodestyle](http://pycodestyle.pycqa.org/en/latest/index.html) to check your code automatically; - [ ] Please add tests to cover your changes if applicable.; - [ ] If the behavior of the code has changed or new feature has been added, please also update the [documentation](https://github.com/qutip/qutip-doc) and the [notebook](https://github.com/qutip/qutip-notebooks). Feel free to ask if you are not sure. Delete this checklist after you have completed all the tasks. If you have not finished them all, you can also open a [Draft Pull Request](https://github.blog/2019-02-14-introducing-draft-pull-requests/) to let the others know this on-going work and keep this checklist in the PR description. **Description**; Describe here the proposed change. **Related issues or PRs**; Please mention the related issues or PRs here. If the PR fixes an issue, use the keyword fix/fixes/fixed followed by the issue id, e.g. fix #1184. **Changelog**; Give a short description of the PR in a few words. This will be shown in the QuTiP change log after the PR gets merged.; For example: ; Fixed error checking for null matrix in essolve.; Added option for specifying resolution in Bloch.save function.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1270
https://github.com/qutip/qutip/pull/1270:620,Deployability,update,update,620,"**Checklist**; Thank you for contributing to QuTiP! Please make sure you have finished the following tasks before opening the PR. - [ ] Please read [Contributing to QuTiP Development](https://github.com/qutip/qutip-doc/blob/master/qutip_dev_contrib.md); - [ ] Contributions to qutip should follow the [pep8 style](https://www.python.org/dev/peps/pep-0008/).; You can use [pycodestyle](http://pycodestyle.pycqa.org/en/latest/index.html) to check your code automatically; - [ ] Please add tests to cover your changes if applicable.; - [ ] If the behavior of the code has changed or new feature has been added, please also update the [documentation](https://github.com/qutip/qutip-doc) and the [notebook](https://github.com/qutip/qutip-notebooks). Feel free to ask if you are not sure. Delete this checklist after you have completed all the tasks. If you have not finished them all, you can also open a [Draft Pull Request](https://github.blog/2019-02-14-introducing-draft-pull-requests/) to let the others know this on-going work and keep this checklist in the PR description. **Description**; Describe here the proposed change. **Related issues or PRs**; Please mention the related issues or PRs here. If the PR fixes an issue, use the keyword fix/fixes/fixed followed by the issue id, e.g. fix #1184. **Changelog**; Give a short description of the PR in a few words. This will be shown in the QuTiP change log after the PR gets merged.; For example: ; Fixed error checking for null matrix in essolve.; Added option for specifying resolution in Bloch.save function.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1270
https://github.com/qutip/qutip/pull/1270:487,Testability,test,tests,487,"**Checklist**; Thank you for contributing to QuTiP! Please make sure you have finished the following tasks before opening the PR. - [ ] Please read [Contributing to QuTiP Development](https://github.com/qutip/qutip-doc/blob/master/qutip_dev_contrib.md); - [ ] Contributions to qutip should follow the [pep8 style](https://www.python.org/dev/peps/pep-0008/).; You can use [pycodestyle](http://pycodestyle.pycqa.org/en/latest/index.html) to check your code automatically; - [ ] Please add tests to cover your changes if applicable.; - [ ] If the behavior of the code has changed or new feature has been added, please also update the [documentation](https://github.com/qutip/qutip-doc) and the [notebook](https://github.com/qutip/qutip-notebooks). Feel free to ask if you are not sure. Delete this checklist after you have completed all the tasks. If you have not finished them all, you can also open a [Draft Pull Request](https://github.blog/2019-02-14-introducing-draft-pull-requests/) to let the others know this on-going work and keep this checklist in the PR description. **Description**; Describe here the proposed change. **Related issues or PRs**; Please mention the related issues or PRs here. If the PR fixes an issue, use the keyword fix/fixes/fixed followed by the issue id, e.g. fix #1184. **Changelog**; Give a short description of the PR in a few words. This will be shown in the QuTiP change log after the PR gets merged.; For example: ; Fixed error checking for null matrix in essolve.; Added option for specifying resolution in Bloch.save function.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1270
https://github.com/qutip/qutip/pull/1270:1406,Testability,log,log,1406,"**Checklist**; Thank you for contributing to QuTiP! Please make sure you have finished the following tasks before opening the PR. - [ ] Please read [Contributing to QuTiP Development](https://github.com/qutip/qutip-doc/blob/master/qutip_dev_contrib.md); - [ ] Contributions to qutip should follow the [pep8 style](https://www.python.org/dev/peps/pep-0008/).; You can use [pycodestyle](http://pycodestyle.pycqa.org/en/latest/index.html) to check your code automatically; - [ ] Please add tests to cover your changes if applicable.; - [ ] If the behavior of the code has changed or new feature has been added, please also update the [documentation](https://github.com/qutip/qutip-doc) and the [notebook](https://github.com/qutip/qutip-notebooks). Feel free to ask if you are not sure. Delete this checklist after you have completed all the tasks. If you have not finished them all, you can also open a [Draft Pull Request](https://github.blog/2019-02-14-introducing-draft-pull-requests/) to let the others know this on-going work and keep this checklist in the PR description. **Description**; Describe here the proposed change. **Related issues or PRs**; Please mention the related issues or PRs here. If the PR fixes an issue, use the keyword fix/fixes/fixed followed by the issue id, e.g. fix #1184. **Changelog**; Give a short description of the PR in a few words. This will be shown in the QuTiP change log after the PR gets merged.; For example: ; Fixed error checking for null matrix in essolve.; Added option for specifying resolution in Bloch.save function.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1270
https://github.com/qutip/qutip/issues/1272:354,Availability,down,down,354,"**Describe the bug**; I'm trying to run some example projects but consistently run into an issue with numpy. I'm quite new to numpy so I couldn't figure out a suitable fix. The following is taken from J. R. Johansson's tutorial 1 (Jaynes Cumming Model), which ran on numpy 1.81. I am currently running numpy 1.16.5. I also tested lower versions of numpy down to 1.14.0; **To Reproduce**; Here is the code to reproduce it:. ```python; output = mesolve(H, psi0, tlist, c_ops, []). # find the indices of the density matrices for the times we are interested in; t_idx = where([tlist == t for t in [0.0, 5.0, 15.0, 25.0]])[1]; tlist[t_idx]. rho_list = array(output.states)[t_idx]; ```; The terminal out put is; ```; ---------------------------------------------------------------------------; TypeError Traceback (most recent call last); <ipython-input-44-f8edfb054c33> in <module>; 1 # get a list density matrices; ----> 2 rho_list = array(output.states)[t_idx]. TypeError: must be real number, not Qobj; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1272
https://github.com/qutip/qutip/issues/1272:323,Testability,test,tested,323,"**Describe the bug**; I'm trying to run some example projects but consistently run into an issue with numpy. I'm quite new to numpy so I couldn't figure out a suitable fix. The following is taken from J. R. Johansson's tutorial 1 (Jaynes Cumming Model), which ran on numpy 1.81. I am currently running numpy 1.16.5. I also tested lower versions of numpy down to 1.14.0; **To Reproduce**; Here is the code to reproduce it:. ```python; output = mesolve(H, psi0, tlist, c_ops, []). # find the indices of the density matrices for the times we are interested in; t_idx = where([tlist == t for t in [0.0, 5.0, 15.0, 25.0]])[1]; tlist[t_idx]. rho_list = array(output.states)[t_idx]; ```; The terminal out put is; ```; ---------------------------------------------------------------------------; TypeError Traceback (most recent call last); <ipython-input-44-f8edfb054c33> in <module>; 1 # get a list density matrices; ----> 2 rho_list = array(output.states)[t_idx]. TypeError: must be real number, not Qobj; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1272
https://github.com/qutip/qutip/pull/1273:3655,Availability,ping,pinging,3655,"t gates might differ, an additional step is required to compute the scheduled start time of each instruction.; It adds the additional dependency caused by hardware constraint to the graph and recomputes the distance of each node to the start and end node. This distance is then converted to the start time of each instruction. **Example**; ```python; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7) ; >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True) ; [0, 1, 3, 2, 2, 3, 4]; ```; The result list is the cycle indices for each gate. It means that the circuit can be executed in 5 gate cycles:; ```; gate0; gate1; gate3, gate4; gate2, gate5; gate6; ```; Notice that gate3 and gate4 commute with gate2, therefore, the order is changed to reduce the number of cycles. **Related issues or PRs**; Solve #1243 . **Changelog**; Add a gate(pulse) scheduler for quantum circuit. **Others**; @sarsid Maybe you will be interested in it. It can be used to determine which gates can be executed at the same time. So maybe we can improve the efficiency of the QubitCircuit by combining several gates together and generate the full matrix using `qutip.qip.expand_operation`. However, writing such scheduler in Python is usually not the most efficient choice and there will be some overhead. I'm not sure if it will bring any real improvement in circuit simulation and where is the threshold. I'm also pinging @tehruhn because I remember you mentioned something similar before (apologize if not). More tests are on the way, but you are very welcome to play with it a bit and see if there is any bug!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1273
https://github.com/qutip/qutip/pull/1273:32,Energy Efficiency,schedul,scheduler,32,"**Description**; A gate (pulse) scheduler for quantum circuits (instructions). It schedules a `QubitCircuit` or a list of instructions to reduce the total execution time by exciting them parallelly. It uses heuristic methods mainly from https://doi.org/10.1117/12.666419. The scheduler aims at pulse schedule and therefore does not consider merging gates to reduce the gates number. It assumes that the input circuit is optimized at the gate level (e.g. has a minimal number of CNOT gates) and matches the hardware topology. The scheduler includes two methods, ""ASAP"", as soon as possible, and ""ALAP"", as late as possible. The later is commonly used in quantum computation because of the finite lifetime of qubits. **Methods**. - The scheduler first generates a quantum gates dependency graph, containing information about which gates have to be executed before some other gates because they do not commute. The graph preserves the mobility of the gates, i.e. commuting gates are not dependent on each other, even if they use the same qubits. ; - Next, it computes the longest distance of each node to the start and end nodes. The distance for each dependency arrow is defined by the execution time of the instruction (By default, it is 1 for all gates). This is used as a priority measure in the next step. The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; - In the last step, it uses a list-schedule algorithm with hardware constraint (e.g. gates using the same qubits) and priority and returns a list of cycles for gates.; - Since it's heuristics, sometimes it does not find the optimal. It offers an option that randomly shuffles the gates (if commuting) and repeats the scheduling a few times to get a better result. For scheduling quantum instructions, of which the runtime of different gates might differ, an additional step is required to compute the scheduled start time of each instruction.; It adds the additional dependency caus",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1273
https://github.com/qutip/qutip/pull/1273:82,Energy Efficiency,schedul,schedules,82,"**Description**; A gate (pulse) scheduler for quantum circuits (instructions). It schedules a `QubitCircuit` or a list of instructions to reduce the total execution time by exciting them parallelly. It uses heuristic methods mainly from https://doi.org/10.1117/12.666419. The scheduler aims at pulse schedule and therefore does not consider merging gates to reduce the gates number. It assumes that the input circuit is optimized at the gate level (e.g. has a minimal number of CNOT gates) and matches the hardware topology. The scheduler includes two methods, ""ASAP"", as soon as possible, and ""ALAP"", as late as possible. The later is commonly used in quantum computation because of the finite lifetime of qubits. **Methods**. - The scheduler first generates a quantum gates dependency graph, containing information about which gates have to be executed before some other gates because they do not commute. The graph preserves the mobility of the gates, i.e. commuting gates are not dependent on each other, even if they use the same qubits. ; - Next, it computes the longest distance of each node to the start and end nodes. The distance for each dependency arrow is defined by the execution time of the instruction (By default, it is 1 for all gates). This is used as a priority measure in the next step. The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; - In the last step, it uses a list-schedule algorithm with hardware constraint (e.g. gates using the same qubits) and priority and returns a list of cycles for gates.; - Since it's heuristics, sometimes it does not find the optimal. It offers an option that randomly shuffles the gates (if commuting) and repeats the scheduling a few times to get a better result. For scheduling quantum instructions, of which the runtime of different gates might differ, an additional step is required to compute the scheduled start time of each instruction.; It adds the additional dependency caus",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1273
https://github.com/qutip/qutip/pull/1273:138,Energy Efficiency,reduce,reduce,138,"**Description**; A gate (pulse) scheduler for quantum circuits (instructions). It schedules a `QubitCircuit` or a list of instructions to reduce the total execution time by exciting them parallelly. It uses heuristic methods mainly from https://doi.org/10.1117/12.666419. The scheduler aims at pulse schedule and therefore does not consider merging gates to reduce the gates number. It assumes that the input circuit is optimized at the gate level (e.g. has a minimal number of CNOT gates) and matches the hardware topology. The scheduler includes two methods, ""ASAP"", as soon as possible, and ""ALAP"", as late as possible. The later is commonly used in quantum computation because of the finite lifetime of qubits. **Methods**. - The scheduler first generates a quantum gates dependency graph, containing information about which gates have to be executed before some other gates because they do not commute. The graph preserves the mobility of the gates, i.e. commuting gates are not dependent on each other, even if they use the same qubits. ; - Next, it computes the longest distance of each node to the start and end nodes. The distance for each dependency arrow is defined by the execution time of the instruction (By default, it is 1 for all gates). This is used as a priority measure in the next step. The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; - In the last step, it uses a list-schedule algorithm with hardware constraint (e.g. gates using the same qubits) and priority and returns a list of cycles for gates.; - Since it's heuristics, sometimes it does not find the optimal. It offers an option that randomly shuffles the gates (if commuting) and repeats the scheduling a few times to get a better result. For scheduling quantum instructions, of which the runtime of different gates might differ, an additional step is required to compute the scheduled start time of each instruction.; It adds the additional dependency caus",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1273
https://github.com/qutip/qutip/pull/1273:276,Energy Efficiency,schedul,scheduler,276,"**Description**; A gate (pulse) scheduler for quantum circuits (instructions). It schedules a `QubitCircuit` or a list of instructions to reduce the total execution time by exciting them parallelly. It uses heuristic methods mainly from https://doi.org/10.1117/12.666419. The scheduler aims at pulse schedule and therefore does not consider merging gates to reduce the gates number. It assumes that the input circuit is optimized at the gate level (e.g. has a minimal number of CNOT gates) and matches the hardware topology. The scheduler includes two methods, ""ASAP"", as soon as possible, and ""ALAP"", as late as possible. The later is commonly used in quantum computation because of the finite lifetime of qubits. **Methods**. - The scheduler first generates a quantum gates dependency graph, containing information about which gates have to be executed before some other gates because they do not commute. The graph preserves the mobility of the gates, i.e. commuting gates are not dependent on each other, even if they use the same qubits. ; - Next, it computes the longest distance of each node to the start and end nodes. The distance for each dependency arrow is defined by the execution time of the instruction (By default, it is 1 for all gates). This is used as a priority measure in the next step. The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; - In the last step, it uses a list-schedule algorithm with hardware constraint (e.g. gates using the same qubits) and priority and returns a list of cycles for gates.; - Since it's heuristics, sometimes it does not find the optimal. It offers an option that randomly shuffles the gates (if commuting) and repeats the scheduling a few times to get a better result. For scheduling quantum instructions, of which the runtime of different gates might differ, an additional step is required to compute the scheduled start time of each instruction.; It adds the additional dependency caus",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1273
https://github.com/qutip/qutip/pull/1273:300,Energy Efficiency,schedul,schedule,300,"**Description**; A gate (pulse) scheduler for quantum circuits (instructions). It schedules a `QubitCircuit` or a list of instructions to reduce the total execution time by exciting them parallelly. It uses heuristic methods mainly from https://doi.org/10.1117/12.666419. The scheduler aims at pulse schedule and therefore does not consider merging gates to reduce the gates number. It assumes that the input circuit is optimized at the gate level (e.g. has a minimal number of CNOT gates) and matches the hardware topology. The scheduler includes two methods, ""ASAP"", as soon as possible, and ""ALAP"", as late as possible. The later is commonly used in quantum computation because of the finite lifetime of qubits. **Methods**. - The scheduler first generates a quantum gates dependency graph, containing information about which gates have to be executed before some other gates because they do not commute. The graph preserves the mobility of the gates, i.e. commuting gates are not dependent on each other, even if they use the same qubits. ; - Next, it computes the longest distance of each node to the start and end nodes. The distance for each dependency arrow is defined by the execution time of the instruction (By default, it is 1 for all gates). This is used as a priority measure in the next step. The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; - In the last step, it uses a list-schedule algorithm with hardware constraint (e.g. gates using the same qubits) and priority and returns a list of cycles for gates.; - Since it's heuristics, sometimes it does not find the optimal. It offers an option that randomly shuffles the gates (if commuting) and repeats the scheduling a few times to get a better result. For scheduling quantum instructions, of which the runtime of different gates might differ, an additional step is required to compute the scheduled start time of each instruction.; It adds the additional dependency caus",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1273
https://github.com/qutip/qutip/pull/1273:358,Energy Efficiency,reduce,reduce,358,"**Description**; A gate (pulse) scheduler for quantum circuits (instructions). It schedules a `QubitCircuit` or a list of instructions to reduce the total execution time by exciting them parallelly. It uses heuristic methods mainly from https://doi.org/10.1117/12.666419. The scheduler aims at pulse schedule and therefore does not consider merging gates to reduce the gates number. It assumes that the input circuit is optimized at the gate level (e.g. has a minimal number of CNOT gates) and matches the hardware topology. The scheduler includes two methods, ""ASAP"", as soon as possible, and ""ALAP"", as late as possible. The later is commonly used in quantum computation because of the finite lifetime of qubits. **Methods**. - The scheduler first generates a quantum gates dependency graph, containing information about which gates have to be executed before some other gates because they do not commute. The graph preserves the mobility of the gates, i.e. commuting gates are not dependent on each other, even if they use the same qubits. ; - Next, it computes the longest distance of each node to the start and end nodes. The distance for each dependency arrow is defined by the execution time of the instruction (By default, it is 1 for all gates). This is used as a priority measure in the next step. The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; - In the last step, it uses a list-schedule algorithm with hardware constraint (e.g. gates using the same qubits) and priority and returns a list of cycles for gates.; - Since it's heuristics, sometimes it does not find the optimal. It offers an option that randomly shuffles the gates (if commuting) and repeats the scheduling a few times to get a better result. For scheduling quantum instructions, of which the runtime of different gates might differ, an additional step is required to compute the scheduled start time of each instruction.; It adds the additional dependency caus",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1273
https://github.com/qutip/qutip/pull/1273:529,Energy Efficiency,schedul,scheduler,529,"**Description**; A gate (pulse) scheduler for quantum circuits (instructions). It schedules a `QubitCircuit` or a list of instructions to reduce the total execution time by exciting them parallelly. It uses heuristic methods mainly from https://doi.org/10.1117/12.666419. The scheduler aims at pulse schedule and therefore does not consider merging gates to reduce the gates number. It assumes that the input circuit is optimized at the gate level (e.g. has a minimal number of CNOT gates) and matches the hardware topology. The scheduler includes two methods, ""ASAP"", as soon as possible, and ""ALAP"", as late as possible. The later is commonly used in quantum computation because of the finite lifetime of qubits. **Methods**. - The scheduler first generates a quantum gates dependency graph, containing information about which gates have to be executed before some other gates because they do not commute. The graph preserves the mobility of the gates, i.e. commuting gates are not dependent on each other, even if they use the same qubits. ; - Next, it computes the longest distance of each node to the start and end nodes. The distance for each dependency arrow is defined by the execution time of the instruction (By default, it is 1 for all gates). This is used as a priority measure in the next step. The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; - In the last step, it uses a list-schedule algorithm with hardware constraint (e.g. gates using the same qubits) and priority and returns a list of cycles for gates.; - Since it's heuristics, sometimes it does not find the optimal. It offers an option that randomly shuffles the gates (if commuting) and repeats the scheduling a few times to get a better result. For scheduling quantum instructions, of which the runtime of different gates might differ, an additional step is required to compute the scheduled start time of each instruction.; It adds the additional dependency caus",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1273
https://github.com/qutip/qutip/pull/1273:734,Energy Efficiency,schedul,scheduler,734,"**Description**; A gate (pulse) scheduler for quantum circuits (instructions). It schedules a `QubitCircuit` or a list of instructions to reduce the total execution time by exciting them parallelly. It uses heuristic methods mainly from https://doi.org/10.1117/12.666419. The scheduler aims at pulse schedule and therefore does not consider merging gates to reduce the gates number. It assumes that the input circuit is optimized at the gate level (e.g. has a minimal number of CNOT gates) and matches the hardware topology. The scheduler includes two methods, ""ASAP"", as soon as possible, and ""ALAP"", as late as possible. The later is commonly used in quantum computation because of the finite lifetime of qubits. **Methods**. - The scheduler first generates a quantum gates dependency graph, containing information about which gates have to be executed before some other gates because they do not commute. The graph preserves the mobility of the gates, i.e. commuting gates are not dependent on each other, even if they use the same qubits. ; - Next, it computes the longest distance of each node to the start and end nodes. The distance for each dependency arrow is defined by the execution time of the instruction (By default, it is 1 for all gates). This is used as a priority measure in the next step. The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; - In the last step, it uses a list-schedule algorithm with hardware constraint (e.g. gates using the same qubits) and priority and returns a list of cycles for gates.; - Since it's heuristics, sometimes it does not find the optimal. It offers an option that randomly shuffles the gates (if commuting) and repeats the scheduling a few times to get a better result. For scheduling quantum instructions, of which the runtime of different gates might differ, an additional step is required to compute the scheduled start time of each instruction.; It adds the additional dependency caus",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1273
https://github.com/qutip/qutip/pull/1273:1454,Energy Efficiency,schedul,schedule,1454," minimal number of CNOT gates) and matches the hardware topology. The scheduler includes two methods, ""ASAP"", as soon as possible, and ""ALAP"", as late as possible. The later is commonly used in quantum computation because of the finite lifetime of qubits. **Methods**. - The scheduler first generates a quantum gates dependency graph, containing information about which gates have to be executed before some other gates because they do not commute. The graph preserves the mobility of the gates, i.e. commuting gates are not dependent on each other, even if they use the same qubits. ; - Next, it computes the longest distance of each node to the start and end nodes. The distance for each dependency arrow is defined by the execution time of the instruction (By default, it is 1 for all gates). This is used as a priority measure in the next step. The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; - In the last step, it uses a list-schedule algorithm with hardware constraint (e.g. gates using the same qubits) and priority and returns a list of cycles for gates.; - Since it's heuristics, sometimes it does not find the optimal. It offers an option that randomly shuffles the gates (if commuting) and repeats the scheduling a few times to get a better result. For scheduling quantum instructions, of which the runtime of different gates might differ, an additional step is required to compute the scheduled start time of each instruction.; It adds the additional dependency caused by hardware constraint to the graph and recomputes the distance of each node to the start and end node. This distance is then converted to the start time of each instruction. **Example**; ```python; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7) ; >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1273
https://github.com/qutip/qutip/pull/1273:1736,Energy Efficiency,schedul,scheduling,1736,"*Methods**. - The scheduler first generates a quantum gates dependency graph, containing information about which gates have to be executed before some other gates because they do not commute. The graph preserves the mobility of the gates, i.e. commuting gates are not dependent on each other, even if they use the same qubits. ; - Next, it computes the longest distance of each node to the start and end nodes. The distance for each dependency arrow is defined by the execution time of the instruction (By default, it is 1 for all gates). This is used as a priority measure in the next step. The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; - In the last step, it uses a list-schedule algorithm with hardware constraint (e.g. gates using the same qubits) and priority and returns a list of cycles for gates.; - Since it's heuristics, sometimes it does not find the optimal. It offers an option that randomly shuffles the gates (if commuting) and repeats the scheduling a few times to get a better result. For scheduling quantum instructions, of which the runtime of different gates might differ, an additional step is required to compute the scheduled start time of each instruction.; It adds the additional dependency caused by hardware constraint to the graph and recomputes the distance of each node to the start and end node. This distance is then converted to the start time of each instruction. **Example**; ```python; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7) ; >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=Tru",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1273
https://github.com/qutip/qutip/pull/1273:1787,Energy Efficiency,schedul,scheduling,1787,"r gates because they do not commute. The graph preserves the mobility of the gates, i.e. commuting gates are not dependent on each other, even if they use the same qubits. ; - Next, it computes the longest distance of each node to the start and end nodes. The distance for each dependency arrow is defined by the execution time of the instruction (By default, it is 1 for all gates). This is used as a priority measure in the next step. The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; - In the last step, it uses a list-schedule algorithm with hardware constraint (e.g. gates using the same qubits) and priority and returns a list of cycles for gates.; - Since it's heuristics, sometimes it does not find the optimal. It offers an option that randomly shuffles the gates (if commuting) and repeats the scheduling a few times to get a better result. For scheduling quantum instructions, of which the runtime of different gates might differ, an additional step is required to compute the scheduled start time of each instruction.; It adds the additional dependency caused by hardware constraint to the graph and recomputes the distance of each node to the start and end node. This distance is then converted to the start time of each instruction. **Example**; ```python; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7) ; >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True) ; [0, 1, 3, 2, 2, 3, 4]; ```; The result list is the cycle indices for each gate. It means that the circuit can be executed in 5 gate cycles:; ```; gate",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1273
https://github.com/qutip/qutip/pull/1273:1920,Energy Efficiency,schedul,scheduled,1920,"r gates because they do not commute. The graph preserves the mobility of the gates, i.e. commuting gates are not dependent on each other, even if they use the same qubits. ; - Next, it computes the longest distance of each node to the start and end nodes. The distance for each dependency arrow is defined by the execution time of the instruction (By default, it is 1 for all gates). This is used as a priority measure in the next step. The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; - In the last step, it uses a list-schedule algorithm with hardware constraint (e.g. gates using the same qubits) and priority and returns a list of cycles for gates.; - Since it's heuristics, sometimes it does not find the optimal. It offers an option that randomly shuffles the gates (if commuting) and repeats the scheduling a few times to get a better result. For scheduling quantum instructions, of which the runtime of different gates might differ, an additional step is required to compute the scheduled start time of each instruction.; It adds the additional dependency caused by hardware constraint to the graph and recomputes the distance of each node to the start and end node. This distance is then converted to the start time of each instruction. **Example**; ```python; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7) ; >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True) ; [0, 1, 3, 2, 2, 3, 4]; ```; The result list is the cycle indices for each gate. It means that the circuit can be executed in 5 gate cycles:; ```; gate",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1273
https://github.com/qutip/qutip/pull/1273:2270,Energy Efficiency,schedul,scheduler,2270,". The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; - In the last step, it uses a list-schedule algorithm with hardware constraint (e.g. gates using the same qubits) and priority and returns a list of cycles for gates.; - Since it's heuristics, sometimes it does not find the optimal. It offers an option that randomly shuffles the gates (if commuting) and repeats the scheduling a few times to get a better result. For scheduling quantum instructions, of which the runtime of different gates might differ, an additional step is required to compute the scheduled start time of each instruction.; It adds the additional dependency caused by hardware constraint to the graph and recomputes the distance of each node to the start and end node. This distance is then converted to the start time of each instruction. **Example**; ```python; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7) ; >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True) ; [0, 1, 3, 2, 2, 3, 4]; ```; The result list is the cycle indices for each gate. It means that the circuit can be executed in 5 gate cycles:; ```; gate0; gate1; gate3, gate4; gate2, gate5; gate6; ```; Notice that gate3 and gate4 commute with gate2, therefore, the order is changed to reduce the number of cycles. **Related issues or PRs**; Solve #1243 . **Changelog**; Add a gate(pulse) scheduler for quantum circuit. **Others**; @sarsid Maybe you will be interested in it. It can be used to determine which gates can be executed at the same time. So maybe we can improve the efficienc",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1273
https://github.com/qutip/qutip/pull/1273:2287,Energy Efficiency,Schedul,Scheduler,2287,". The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; - In the last step, it uses a list-schedule algorithm with hardware constraint (e.g. gates using the same qubits) and priority and returns a list of cycles for gates.; - Since it's heuristics, sometimes it does not find the optimal. It offers an option that randomly shuffles the gates (if commuting) and repeats the scheduling a few times to get a better result. For scheduling quantum instructions, of which the runtime of different gates might differ, an additional step is required to compute the scheduled start time of each instruction.; It adds the additional dependency caused by hardware constraint to the graph and recomputes the distance of each node to the start and end node. This distance is then converted to the start time of each instruction. **Example**; ```python; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7) ; >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True) ; [0, 1, 3, 2, 2, 3, 4]; ```; The result list is the cycle indices for each gate. It means that the circuit can be executed in 5 gate cycles:; ```; gate0; gate1; gate3, gate4; gate2, gate5; gate6; ```; Notice that gate3 and gate4 commute with gate2, therefore, the order is changed to reduce the number of cycles. **Related issues or PRs**; Solve #1243 . **Changelog**; Add a gate(pulse) scheduler for quantum circuit. **Others**; @sarsid Maybe you will be interested in it. It can be used to determine which gates can be executed at the same time. So maybe we can improve the efficienc",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1273
https://github.com/qutip/qutip/pull/1273:2636,Energy Efficiency,schedul,scheduler,2636,"d the optimal. It offers an option that randomly shuffles the gates (if commuting) and repeats the scheduling a few times to get a better result. For scheduling quantum instructions, of which the runtime of different gates might differ, an additional step is required to compute the scheduled start time of each instruction.; It adds the additional dependency caused by hardware constraint to the graph and recomputes the distance of each node to the start and end node. This distance is then converted to the start time of each instruction. **Example**; ```python; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7) ; >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True) ; [0, 1, 3, 2, 2, 3, 4]; ```; The result list is the cycle indices for each gate. It means that the circuit can be executed in 5 gate cycles:; ```; gate0; gate1; gate3, gate4; gate2, gate5; gate6; ```; Notice that gate3 and gate4 commute with gate2, therefore, the order is changed to reduce the number of cycles. **Related issues or PRs**; Solve #1243 . **Changelog**; Add a gate(pulse) scheduler for quantum circuit. **Others**; @sarsid Maybe you will be interested in it. It can be used to determine which gates can be executed at the same time. So maybe we can improve the efficiency of the QubitCircuit by combining several gates together and generate the full matrix using `qutip.qip.expand_operation`. However, writing such scheduler in Python is usually not the most efficient choice and there will be some overhead. I'm not sure if it will bring any real improvement in circuit simulation and where is the th",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1273
https://github.com/qutip/qutip/pull/1273:2648,Energy Efficiency,Schedul,Scheduler,2648,"d the optimal. It offers an option that randomly shuffles the gates (if commuting) and repeats the scheduling a few times to get a better result. For scheduling quantum instructions, of which the runtime of different gates might differ, an additional step is required to compute the scheduled start time of each instruction.; It adds the additional dependency caused by hardware constraint to the graph and recomputes the distance of each node to the start and end node. This distance is then converted to the start time of each instruction. **Example**; ```python; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7) ; >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True) ; [0, 1, 3, 2, 2, 3, 4]; ```; The result list is the cycle indices for each gate. It means that the circuit can be executed in 5 gate cycles:; ```; gate0; gate1; gate3, gate4; gate2, gate5; gate6; ```; Notice that gate3 and gate4 commute with gate2, therefore, the order is changed to reduce the number of cycles. **Related issues or PRs**; Solve #1243 . **Changelog**; Add a gate(pulse) scheduler for quantum circuit. **Others**; @sarsid Maybe you will be interested in it. It can be used to determine which gates can be executed at the same time. So maybe we can improve the efficiency of the QubitCircuit by combining several gates together and generate the full matrix using `qutip.qip.expand_operation`. However, writing such scheduler in Python is usually not the most efficient choice and there will be some overhead. I'm not sure if it will bring any real improvement in circuit simulation and where is the th",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1273
https://github.com/qutip/qutip/pull/1273:2671,Energy Efficiency,schedul,scheduler,2671,"d the optimal. It offers an option that randomly shuffles the gates (if commuting) and repeats the scheduling a few times to get a better result. For scheduling quantum instructions, of which the runtime of different gates might differ, an additional step is required to compute the scheduled start time of each instruction.; It adds the additional dependency caused by hardware constraint to the graph and recomputes the distance of each node to the start and end node. This distance is then converted to the start time of each instruction. **Example**; ```python; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7) ; >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True) ; [0, 1, 3, 2, 2, 3, 4]; ```; The result list is the cycle indices for each gate. It means that the circuit can be executed in 5 gate cycles:; ```; gate0; gate1; gate3, gate4; gate2, gate5; gate6; ```; Notice that gate3 and gate4 commute with gate2, therefore, the order is changed to reduce the number of cycles. **Related issues or PRs**; Solve #1243 . **Changelog**; Add a gate(pulse) scheduler for quantum circuit. **Others**; @sarsid Maybe you will be interested in it. It can be used to determine which gates can be executed at the same time. So maybe we can improve the efficiency of the QubitCircuit by combining several gates together and generate the full matrix using `qutip.qip.expand_operation`. However, writing such scheduler in Python is usually not the most efficient choice and there will be some overhead. I'm not sure if it will bring any real improvement in circuit simulation and where is the th",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1273
https://github.com/qutip/qutip/pull/1273:2681,Energy Efficiency,schedul,schedule,2681,"uling a few times to get a better result. For scheduling quantum instructions, of which the runtime of different gates might differ, an additional step is required to compute the scheduled start time of each instruction.; It adds the additional dependency caused by hardware constraint to the graph and recomputes the distance of each node to the start and end node. This distance is then converted to the start time of each instruction. **Example**; ```python; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7) ; >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True) ; [0, 1, 3, 2, 2, 3, 4]; ```; The result list is the cycle indices for each gate. It means that the circuit can be executed in 5 gate cycles:; ```; gate0; gate1; gate3, gate4; gate2, gate5; gate6; ```; Notice that gate3 and gate4 commute with gate2, therefore, the order is changed to reduce the number of cycles. **Related issues or PRs**; Solve #1243 . **Changelog**; Add a gate(pulse) scheduler for quantum circuit. **Others**; @sarsid Maybe you will be interested in it. It can be used to determine which gates can be executed at the same time. So maybe we can improve the efficiency of the QubitCircuit by combining several gates together and generate the full matrix using `qutip.qip.expand_operation`. However, writing such scheduler in Python is usually not the most efficient choice and there will be some overhead. I'm not sure if it will bring any real improvement in circuit simulation and where is the threshold. I'm also pinging @tehruhn because I remember you mentioned something similar before (apologize ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1273
https://github.com/qutip/qutip/pull/1273:3005,Energy Efficiency,reduce,reduce,3005,"t gates might differ, an additional step is required to compute the scheduled start time of each instruction.; It adds the additional dependency caused by hardware constraint to the graph and recomputes the distance of each node to the start and end node. This distance is then converted to the start time of each instruction. **Example**; ```python; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7) ; >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True) ; [0, 1, 3, 2, 2, 3, 4]; ```; The result list is the cycle indices for each gate. It means that the circuit can be executed in 5 gate cycles:; ```; gate0; gate1; gate3, gate4; gate2, gate5; gate6; ```; Notice that gate3 and gate4 commute with gate2, therefore, the order is changed to reduce the number of cycles. **Related issues or PRs**; Solve #1243 . **Changelog**; Add a gate(pulse) scheduler for quantum circuit. **Others**; @sarsid Maybe you will be interested in it. It can be used to determine which gates can be executed at the same time. So maybe we can improve the efficiency of the QubitCircuit by combining several gates together and generate the full matrix using `qutip.qip.expand_operation`. However, writing such scheduler in Python is usually not the most efficient choice and there will be some overhead. I'm not sure if it will bring any real improvement in circuit simulation and where is the threshold. I'm also pinging @tehruhn because I remember you mentioned something similar before (apologize if not). More tests are on the way, but you are very welcome to play with it a bit and see if there is any bug!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1273
https://github.com/qutip/qutip/pull/1273:3108,Energy Efficiency,schedul,scheduler,3108,"t gates might differ, an additional step is required to compute the scheduled start time of each instruction.; It adds the additional dependency caused by hardware constraint to the graph and recomputes the distance of each node to the start and end node. This distance is then converted to the start time of each instruction. **Example**; ```python; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7) ; >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True) ; [0, 1, 3, 2, 2, 3, 4]; ```; The result list is the cycle indices for each gate. It means that the circuit can be executed in 5 gate cycles:; ```; gate0; gate1; gate3, gate4; gate2, gate5; gate6; ```; Notice that gate3 and gate4 commute with gate2, therefore, the order is changed to reduce the number of cycles. **Related issues or PRs**; Solve #1243 . **Changelog**; Add a gate(pulse) scheduler for quantum circuit. **Others**; @sarsid Maybe you will be interested in it. It can be used to determine which gates can be executed at the same time. So maybe we can improve the efficiency of the QubitCircuit by combining several gates together and generate the full matrix using `qutip.qip.expand_operation`. However, writing such scheduler in Python is usually not the most efficient choice and there will be some overhead. I'm not sure if it will bring any real improvement in circuit simulation and where is the threshold. I'm also pinging @tehruhn because I remember you mentioned something similar before (apologize if not). More tests are on the way, but you are very welcome to play with it a bit and see if there is any bug!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1273
https://github.com/qutip/qutip/pull/1273:3451,Energy Efficiency,schedul,scheduler,3451,"t gates might differ, an additional step is required to compute the scheduled start time of each instruction.; It adds the additional dependency caused by hardware constraint to the graph and recomputes the distance of each node to the start and end node. This distance is then converted to the start time of each instruction. **Example**; ```python; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7) ; >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True) ; [0, 1, 3, 2, 2, 3, 4]; ```; The result list is the cycle indices for each gate. It means that the circuit can be executed in 5 gate cycles:; ```; gate0; gate1; gate3, gate4; gate2, gate5; gate6; ```; Notice that gate3 and gate4 commute with gate2, therefore, the order is changed to reduce the number of cycles. **Related issues or PRs**; Solve #1243 . **Changelog**; Add a gate(pulse) scheduler for quantum circuit. **Others**; @sarsid Maybe you will be interested in it. It can be used to determine which gates can be executed at the same time. So maybe we can improve the efficiency of the QubitCircuit by combining several gates together and generate the full matrix using `qutip.qip.expand_operation`. However, writing such scheduler in Python is usually not the most efficient choice and there will be some overhead. I'm not sure if it will bring any real improvement in circuit simulation and where is the threshold. I'm also pinging @tehruhn because I remember you mentioned something similar before (apologize if not). More tests are on the way, but you are very welcome to play with it a bit and see if there is any bug!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1273
https://github.com/qutip/qutip/pull/1273:3495,Energy Efficiency,efficient,efficient,3495,"t gates might differ, an additional step is required to compute the scheduled start time of each instruction.; It adds the additional dependency caused by hardware constraint to the graph and recomputes the distance of each node to the start and end node. This distance is then converted to the start time of each instruction. **Example**; ```python; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7) ; >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True) ; [0, 1, 3, 2, 2, 3, 4]; ```; The result list is the cycle indices for each gate. It means that the circuit can be executed in 5 gate cycles:; ```; gate0; gate1; gate3, gate4; gate2, gate5; gate6; ```; Notice that gate3 and gate4 commute with gate2, therefore, the order is changed to reduce the number of cycles. **Related issues or PRs**; Solve #1243 . **Changelog**; Add a gate(pulse) scheduler for quantum circuit. **Others**; @sarsid Maybe you will be interested in it. It can be used to determine which gates can be executed at the same time. So maybe we can improve the efficiency of the QubitCircuit by combining several gates together and generate the full matrix using `qutip.qip.expand_operation`. However, writing such scheduler in Python is usually not the most efficient choice and there will be some overhead. I'm not sure if it will bring any real improvement in circuit simulation and where is the threshold. I'm also pinging @tehruhn because I remember you mentioned something similar before (apologize if not). More tests are on the way, but you are very welcome to play with it a bit and see if there is any bug!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1273
https://github.com/qutip/qutip/pull/1273:776,Integrability,depend,dependency,776,"**Description**; A gate (pulse) scheduler for quantum circuits (instructions). It schedules a `QubitCircuit` or a list of instructions to reduce the total execution time by exciting them parallelly. It uses heuristic methods mainly from https://doi.org/10.1117/12.666419. The scheduler aims at pulse schedule and therefore does not consider merging gates to reduce the gates number. It assumes that the input circuit is optimized at the gate level (e.g. has a minimal number of CNOT gates) and matches the hardware topology. The scheduler includes two methods, ""ASAP"", as soon as possible, and ""ALAP"", as late as possible. The later is commonly used in quantum computation because of the finite lifetime of qubits. **Methods**. - The scheduler first generates a quantum gates dependency graph, containing information about which gates have to be executed before some other gates because they do not commute. The graph preserves the mobility of the gates, i.e. commuting gates are not dependent on each other, even if they use the same qubits. ; - Next, it computes the longest distance of each node to the start and end nodes. The distance for each dependency arrow is defined by the execution time of the instruction (By default, it is 1 for all gates). This is used as a priority measure in the next step. The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; - In the last step, it uses a list-schedule algorithm with hardware constraint (e.g. gates using the same qubits) and priority and returns a list of cycles for gates.; - Since it's heuristics, sometimes it does not find the optimal. It offers an option that randomly shuffles the gates (if commuting) and repeats the scheduling a few times to get a better result. For scheduling quantum instructions, of which the runtime of different gates might differ, an additional step is required to compute the scheduled start time of each instruction.; It adds the additional dependency caus",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1273
https://github.com/qutip/qutip/pull/1273:984,Integrability,depend,dependent,984,"**Description**; A gate (pulse) scheduler for quantum circuits (instructions). It schedules a `QubitCircuit` or a list of instructions to reduce the total execution time by exciting them parallelly. It uses heuristic methods mainly from https://doi.org/10.1117/12.666419. The scheduler aims at pulse schedule and therefore does not consider merging gates to reduce the gates number. It assumes that the input circuit is optimized at the gate level (e.g. has a minimal number of CNOT gates) and matches the hardware topology. The scheduler includes two methods, ""ASAP"", as soon as possible, and ""ALAP"", as late as possible. The later is commonly used in quantum computation because of the finite lifetime of qubits. **Methods**. - The scheduler first generates a quantum gates dependency graph, containing information about which gates have to be executed before some other gates because they do not commute. The graph preserves the mobility of the gates, i.e. commuting gates are not dependent on each other, even if they use the same qubits. ; - Next, it computes the longest distance of each node to the start and end nodes. The distance for each dependency arrow is defined by the execution time of the instruction (By default, it is 1 for all gates). This is used as a priority measure in the next step. The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; - In the last step, it uses a list-schedule algorithm with hardware constraint (e.g. gates using the same qubits) and priority and returns a list of cycles for gates.; - Since it's heuristics, sometimes it does not find the optimal. It offers an option that randomly shuffles the gates (if commuting) and repeats the scheduling a few times to get a better result. For scheduling quantum instructions, of which the runtime of different gates might differ, an additional step is required to compute the scheduled start time of each instruction.; It adds the additional dependency caus",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1273
https://github.com/qutip/qutip/pull/1273:1149,Integrability,depend,dependency,1149,"allelly. It uses heuristic methods mainly from https://doi.org/10.1117/12.666419. The scheduler aims at pulse schedule and therefore does not consider merging gates to reduce the gates number. It assumes that the input circuit is optimized at the gate level (e.g. has a minimal number of CNOT gates) and matches the hardware topology. The scheduler includes two methods, ""ASAP"", as soon as possible, and ""ALAP"", as late as possible. The later is commonly used in quantum computation because of the finite lifetime of qubits. **Methods**. - The scheduler first generates a quantum gates dependency graph, containing information about which gates have to be executed before some other gates because they do not commute. The graph preserves the mobility of the gates, i.e. commuting gates are not dependent on each other, even if they use the same qubits. ; - Next, it computes the longest distance of each node to the start and end nodes. The distance for each dependency arrow is defined by the execution time of the instruction (By default, it is 1 for all gates). This is used as a priority measure in the next step. The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; - In the last step, it uses a list-schedule algorithm with hardware constraint (e.g. gates using the same qubits) and priority and returns a list of cycles for gates.; - Since it's heuristics, sometimes it does not find the optimal. It offers an option that randomly shuffles the gates (if commuting) and repeats the scheduling a few times to get a better result. For scheduling quantum instructions, of which the runtime of different gates might differ, an additional step is required to compute the scheduled start time of each instruction.; It adds the additional dependency caused by hardware constraint to the graph and recomputes the distance of each node to the start and end node. This distance is then converted to the start time of each instruction. **Example**",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1273
https://github.com/qutip/qutip/pull/1273:1986,Integrability,depend,dependency,1986," qubits. ; - Next, it computes the longest distance of each node to the start and end nodes. The distance for each dependency arrow is defined by the execution time of the instruction (By default, it is 1 for all gates). This is used as a priority measure in the next step. The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; - In the last step, it uses a list-schedule algorithm with hardware constraint (e.g. gates using the same qubits) and priority and returns a list of cycles for gates.; - Since it's heuristics, sometimes it does not find the optimal. It offers an option that randomly shuffles the gates (if commuting) and repeats the scheduling a few times to get a better result. For scheduling quantum instructions, of which the runtime of different gates might differ, an additional step is required to compute the scheduled start time of each instruction.; It adds the additional dependency caused by hardware constraint to the graph and recomputes the distance of each node to the start and end node. This distance is then converted to the start time of each instruction. **Example**; ```python; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7) ; >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True) ; [0, 1, 3, 2, 2, 3, 4]; ```; The result list is the cycle indices for each gate. It means that the circuit can be executed in 5 gate cycles:; ```; gate0; gate1; gate3, gate4; gate2, gate5; gate6; ```; Notice that gate3 and gate4 commute with gate2, therefore, the order is changed to reduce the number of cycles. ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1273
https://github.com/qutip/qutip/pull/1273:420,Performance,optimiz,optimized,420,"**Description**; A gate (pulse) scheduler for quantum circuits (instructions). It schedules a `QubitCircuit` or a list of instructions to reduce the total execution time by exciting them parallelly. It uses heuristic methods mainly from https://doi.org/10.1117/12.666419. The scheduler aims at pulse schedule and therefore does not consider merging gates to reduce the gates number. It assumes that the input circuit is optimized at the gate level (e.g. has a minimal number of CNOT gates) and matches the hardware topology. The scheduler includes two methods, ""ASAP"", as soon as possible, and ""ALAP"", as late as possible. The later is commonly used in quantum computation because of the finite lifetime of qubits. **Methods**. - The scheduler first generates a quantum gates dependency graph, containing information about which gates have to be executed before some other gates because they do not commute. The graph preserves the mobility of the gates, i.e. commuting gates are not dependent on each other, even if they use the same qubits. ; - Next, it computes the longest distance of each node to the start and end nodes. The distance for each dependency arrow is defined by the execution time of the instruction (By default, it is 1 for all gates). This is used as a priority measure in the next step. The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; - In the last step, it uses a list-schedule algorithm with hardware constraint (e.g. gates using the same qubits) and priority and returns a list of cycles for gates.; - Since it's heuristics, sometimes it does not find the optimal. It offers an option that randomly shuffles the gates (if commuting) and repeats the scheduling a few times to get a better result. For scheduling quantum instructions, of which the runtime of different gates might differ, an additional step is required to compute the scheduled start time of each instruction.; It adds the additional dependency caus",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1273
https://github.com/qutip/qutip/pull/1273:3755,Testability,test,tests,3755,"t gates might differ, an additional step is required to compute the scheduled start time of each instruction.; It adds the additional dependency caused by hardware constraint to the graph and recomputes the distance of each node to the start and end node. This distance is then converted to the start time of each instruction. **Example**; ```python; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7) ; >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True) ; [0, 1, 3, 2, 2, 3, 4]; ```; The result list is the cycle indices for each gate. It means that the circuit can be executed in 5 gate cycles:; ```; gate0; gate1; gate3, gate4; gate2, gate5; gate6; ```; Notice that gate3 and gate4 commute with gate2, therefore, the order is changed to reduce the number of cycles. **Related issues or PRs**; Solve #1243 . **Changelog**; Add a gate(pulse) scheduler for quantum circuit. **Others**; @sarsid Maybe you will be interested in it. It can be used to determine which gates can be executed at the same time. So maybe we can improve the efficiency of the QubitCircuit by combining several gates together and generate the full matrix using `qutip.qip.expand_operation`. However, writing such scheduler in Python is usually not the most efficient choice and there will be some overhead. I'm not sure if it will bring any real improvement in circuit simulation and where is the threshold. I'm also pinging @tehruhn because I remember you mentioned something similar before (apologize if not). More tests are on the way, but you are very welcome to play with it a bit and see if there is any bug!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1273
https://github.com/qutip/qutip/pull/1274:496,Deployability,update,update,496,"**Checklist**; Thank you for contributing to QuTiP! Please make sure you have finished the following tasks before opening the PR. - [ ] Contributions to qutip should follow the [pep8 style](https://www.python.org/dev/peps/pep-0008/).; You can use [pycodestyle](http://pycodestyle.pycqa.org/en/latest/index.html) to check your code automatically; - [ ] Please add tests to cover your changes if applicable.; - [ ] If the behavior of the code has changed or new feature has been added, please also update the [documentation](https://github.com/qutip/qutip-doc) and the [notebook](https://github.com/qutip/qutip-notebooks). Feel free to ask if you are not sure. Delete this checklist after you have completed all the tasks. If you have not finished them all, you can also open a [Draft Pull Request](https://github.blog/2019-02-14-introducing-draft-pull-requests/) to let the others know this on-going work and keep this checklist in the PR description. **Description**; This PR is supposed to mark on-going additions to a new class `qutip.qip.circuit.Measurement` as well as an elementary `qutip.qip.circuit.Measurement.QubitCircuit.run()` function to exactly simulate quantum circuits. The major functions added right now are:. - `Measurement.density_measurement(self, measurement_ops, state)` : This adds generalized state/density matrix measurements given a list of observables. Still needs addition of checks to see if the list of observables is valid ; - `Measurement.measurement_comp_basis(self, state)` : This adds measurement statistics for specific qubit measurements in the computational basis and also returns the collapsed states (without changing the dimensions). ; - `QubitCircuit.run(self, state, cbits)`: Given a ket input to the circuit, applies gates and measurements from the circuit and returns the resultant ket. . Right now, the measurement module is very bare-bones and splintered between the previous code ; from @hodgestar and the new code added by me. The eigenstate based meas",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1274
https://github.com/qutip/qutip/pull/1274:2626,Deployability,Update,Update,2626,"o see if the list of observables is valid ; - `Measurement.measurement_comp_basis(self, state)` : This adds measurement statistics for specific qubit measurements in the computational basis and also returns the collapsed states (without changing the dimensions). ; - `QubitCircuit.run(self, state, cbits)`: Given a ket input to the circuit, applies gates and measurements from the circuit and returns the resultant ket. . Right now, the measurement module is very bare-bones and splintered between the previous code ; from @hodgestar and the new code added by me. The eigenstate based measurements are slightly different than the measurements usually used on circuits (or I might be missing something). Ofc, in the case of measurements on all qubits, they amount to the same result. I have not added tests yet but I have added a basic quantum teleportation notebook. It will be nice to get feedback on testing methods as well as what kind of notebooks the community is interested in. Also, any other feature requests on this module would also be appreciated. . PS: I have also added measurement code from Simon's PR here so maybe we can either add him as a contributor to this PR or figure out something else. ; ; Update: . 1. Addressing some concerns about the PR containing multiple diverging pieces of code, I think classical registers, measurement on the circuit and the classically-controlled gates are best grouped together as they all rely on each other in some ways. The valid concern is that of the Measurement class encapsulating all projective style measurements. I also want to point out that it was raised by @BoxiLi that we may want to move the Gate class and Measurement class completely to qutip.qip.operations to which I agree but I believe that should be addressed in a clean-up PR with naming changes suggested by @ajgpitch. . **Related issues or PRs**; Adds to #1090. **Changelog**; Adds partial and complete measurements to state vectors/density matrices and a basic run function",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1274
https://github.com/qutip/qutip/pull/1274:363,Testability,test,tests,363,"**Checklist**; Thank you for contributing to QuTiP! Please make sure you have finished the following tasks before opening the PR. - [ ] Contributions to qutip should follow the [pep8 style](https://www.python.org/dev/peps/pep-0008/).; You can use [pycodestyle](http://pycodestyle.pycqa.org/en/latest/index.html) to check your code automatically; - [ ] Please add tests to cover your changes if applicable.; - [ ] If the behavior of the code has changed or new feature has been added, please also update the [documentation](https://github.com/qutip/qutip-doc) and the [notebook](https://github.com/qutip/qutip-notebooks). Feel free to ask if you are not sure. Delete this checklist after you have completed all the tasks. If you have not finished them all, you can also open a [Draft Pull Request](https://github.blog/2019-02-14-introducing-draft-pull-requests/) to let the others know this on-going work and keep this checklist in the PR description. **Description**; This PR is supposed to mark on-going additions to a new class `qutip.qip.circuit.Measurement` as well as an elementary `qutip.qip.circuit.Measurement.QubitCircuit.run()` function to exactly simulate quantum circuits. The major functions added right now are:. - `Measurement.density_measurement(self, measurement_ops, state)` : This adds generalized state/density matrix measurements given a list of observables. Still needs addition of checks to see if the list of observables is valid ; - `Measurement.measurement_comp_basis(self, state)` : This adds measurement statistics for specific qubit measurements in the computational basis and also returns the collapsed states (without changing the dimensions). ; - `QubitCircuit.run(self, state, cbits)`: Given a ket input to the circuit, applies gates and measurements from the circuit and returns the resultant ket. . Right now, the measurement module is very bare-bones and splintered between the previous code ; from @hodgestar and the new code added by me. The eigenstate based meas",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1274
https://github.com/qutip/qutip/pull/1274:2212,Testability,test,tests,2212,"ement.density_measurement(self, measurement_ops, state)` : This adds generalized state/density matrix measurements given a list of observables. Still needs addition of checks to see if the list of observables is valid ; - `Measurement.measurement_comp_basis(self, state)` : This adds measurement statistics for specific qubit measurements in the computational basis and also returns the collapsed states (without changing the dimensions). ; - `QubitCircuit.run(self, state, cbits)`: Given a ket input to the circuit, applies gates and measurements from the circuit and returns the resultant ket. . Right now, the measurement module is very bare-bones and splintered between the previous code ; from @hodgestar and the new code added by me. The eigenstate based measurements are slightly different than the measurements usually used on circuits (or I might be missing something). Ofc, in the case of measurements on all qubits, they amount to the same result. I have not added tests yet but I have added a basic quantum teleportation notebook. It will be nice to get feedback on testing methods as well as what kind of notebooks the community is interested in. Also, any other feature requests on this module would also be appreciated. . PS: I have also added measurement code from Simon's PR here so maybe we can either add him as a contributor to this PR or figure out something else. ; ; Update: . 1. Addressing some concerns about the PR containing multiple diverging pieces of code, I think classical registers, measurement on the circuit and the classically-controlled gates are best grouped together as they all rely on each other in some ways. The valid concern is that of the Measurement class encapsulating all projective style measurements. I also want to point out that it was raised by @BoxiLi that we may want to move the Gate class and Measurement class completely to qutip.qip.operations to which I agree but I believe that should be addressed in a clean-up PR with naming changes sugg",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1274
https://github.com/qutip/qutip/pull/1274:2314,Testability,test,testing,2314,"x measurements given a list of observables. Still needs addition of checks to see if the list of observables is valid ; - `Measurement.measurement_comp_basis(self, state)` : This adds measurement statistics for specific qubit measurements in the computational basis and also returns the collapsed states (without changing the dimensions). ; - `QubitCircuit.run(self, state, cbits)`: Given a ket input to the circuit, applies gates and measurements from the circuit and returns the resultant ket. . Right now, the measurement module is very bare-bones and splintered between the previous code ; from @hodgestar and the new code added by me. The eigenstate based measurements are slightly different than the measurements usually used on circuits (or I might be missing something). Ofc, in the case of measurements on all qubits, they amount to the same result. I have not added tests yet but I have added a basic quantum teleportation notebook. It will be nice to get feedback on testing methods as well as what kind of notebooks the community is interested in. Also, any other feature requests on this module would also be appreciated. . PS: I have also added measurement code from Simon's PR here so maybe we can either add him as a contributor to this PR or figure out something else. ; ; Update: . 1. Addressing some concerns about the PR containing multiple diverging pieces of code, I think classical registers, measurement on the circuit and the classically-controlled gates are best grouped together as they all rely on each other in some ways. The valid concern is that of the Measurement class encapsulating all projective style measurements. I also want to point out that it was raised by @BoxiLi that we may want to move the Gate class and Measurement class completely to qutip.qip.operations to which I agree but I believe that should be addressed in a clean-up PR with naming changes suggested by @ajgpitch. . **Related issues or PRs**; Adds to #1090. **Changelog**; Adds partial and compl",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1274
https://github.com/qutip/qutip/pull/1274:2302,Usability,feedback,feedback,2302,"x measurements given a list of observables. Still needs addition of checks to see if the list of observables is valid ; - `Measurement.measurement_comp_basis(self, state)` : This adds measurement statistics for specific qubit measurements in the computational basis and also returns the collapsed states (without changing the dimensions). ; - `QubitCircuit.run(self, state, cbits)`: Given a ket input to the circuit, applies gates and measurements from the circuit and returns the resultant ket. . Right now, the measurement module is very bare-bones and splintered between the previous code ; from @hodgestar and the new code added by me. The eigenstate based measurements are slightly different than the measurements usually used on circuits (or I might be missing something). Ofc, in the case of measurements on all qubits, they amount to the same result. I have not added tests yet but I have added a basic quantum teleportation notebook. It will be nice to get feedback on testing methods as well as what kind of notebooks the community is interested in. Also, any other feature requests on this module would also be appreciated. . PS: I have also added measurement code from Simon's PR here so maybe we can either add him as a contributor to this PR or figure out something else. ; ; Update: . 1. Addressing some concerns about the PR containing multiple diverging pieces of code, I think classical registers, measurement on the circuit and the classically-controlled gates are best grouped together as they all rely on each other in some ways. The valid concern is that of the Measurement class encapsulating all projective style measurements. I also want to point out that it was raised by @BoxiLi that we may want to move the Gate class and Measurement class completely to qutip.qip.operations to which I agree but I believe that should be addressed in a clean-up PR with naming changes suggested by @ajgpitch. . **Related issues or PRs**; Adds to #1090. **Changelog**; Adds partial and compl",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1274
https://github.com/qutip/qutip/issues/1276:190,Deployability,integrat,integration,190,"Would the use of [plotly](https://plotly.com/) to make the 3d plots better looking and reactive? I'm no expert but it seems very nice especially for 3D visualization in the browser that got integration with [Jupyter notebooks](https://github.com/plotly/plotly.py) (Another app that natively runs in the browser is Bokeh, but that may be more oriented toward data science visualization, while plotly seems more general). It also seems that plotly surpassed [mayavi](https://docs.enthought.com/mayavi/mayavi/) in recent times, with more users, features and more actively developed. This could be relevant for notebooks especially when on My Binder, etc.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1276
https://github.com/qutip/qutip/issues/1276:190,Integrability,integrat,integration,190,"Would the use of [plotly](https://plotly.com/) to make the 3d plots better looking and reactive? I'm no expert but it seems very nice especially for 3D visualization in the browser that got integration with [Jupyter notebooks](https://github.com/plotly/plotly.py) (Another app that natively runs in the browser is Bokeh, but that may be more oriented toward data science visualization, while plotly seems more general). It also seems that plotly surpassed [mayavi](https://docs.enthought.com/mayavi/mayavi/) in recent times, with more users, features and more actively developed. This could be relevant for notebooks especially when on My Binder, etc.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1276
https://github.com/qutip/qutip/issues/1536:15,Usability,simpl,simplifies,15,This extension simplifies copying code blocks from examples in rst files then hosted on html page.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1536
https://github.com/qutip/qutip/pull/1277:154,Usability,simpl,simpler,154,"**Description**; Splitting the coefficient from the data in QobjEvo,; This clean qobjevo a lot, no more type management, product between QobjEvo is a lot simpler.; I removed the `apply_decorator` method, which was probably never used. Build on top of #1231, most changes are from that PR. In this one, ; I will probably cancel this PR and 1231 and re-post them in more manageable steps. Documentation is not corrected. **Related issues or PRs**; @jakelishman 's GSoC talks.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1277
https://github.com/qutip/qutip/issues/1278:6,Deployability,update,updated,6,"_Last updated: 2020-08-12_. This is an issue for tracking and publicising the development status of a separated data layer. This is a major breaking change to be introduced in QuTiP 5, and will change how library functions and users access the underlying data structures of `Qobj`. This document and issue will change over time. Development is taking place on the [`dev.major` branch](https://github.com/qutip/qutip/tree/dev.major) in `qutip/qutip`. Pull requests implementing new features:; - #1282 separating out the core QuTiP operations into a (logical but user-transparent) package `qutip.core`.; - #1296 implementing the first parts of the data multiple dispatch and new data types.; - #1332 replacing the `fast_csr_matrix` with the new Cython type `CSR` all across QuTiP; - #1338 implementing the data-layer creation, conversion and dispatcher routines. We are writing a new ""developers' guide"" to explain the logic behind the design decisions, and help new QuTiP developers work on the code. You can follow initial development hosted as [a repo in my user account](https://github.com/jakelishman/qutip-devguide) until we decide how this will be added to the main documentation. You can view a rendered version of the documentation at https://jakelishman.github.io/qutip-devguide. Some design documents:; - [data layer](https://github.com/jakelishman/qutip-doc/blob/design-data-layer/design/01-data-time-layer-separation.md); - [data structure implementation choices](https://github.com/jakelishman/qutip-doc/blob/design-data-layer/design/02-data-structures.md); - [original GSoC proposal (PDF)](https://www.binhbar.com/posts/2020/05/welcome-to-google-summer-of-code-2020/proposal.pdf). New design elements under consideration:; - [improved `'type'` and `'dims'` handling for tensor-product spaces](https://github.com/qutip/qutip/issues/1320). Major breaking changes to QuTiP:; - `Qobj.data` is no longer an instance of `scipy.sparse.spmatrix`, but the new abstract ""data-layer type"" `core.data",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1278
https://github.com/qutip/qutip/issues/1278:2884,Deployability,release,release,2884,"reaking changes to QuTiP:; - `Qobj.data` is no longer an instance of `scipy.sparse.spmatrix`, but the new abstract ""data-layer type"" `core.data.Data`; - `bra * ket` now returns a scalar, not a `Qobj` (no need to do `(bra * ket).data[0, 0]` or `(bra * ket).tr()`) any more; - 1D subspaces in `Qobj.dims` are now never contracted silently (they were, but inconsistently before), but the new function `Qobj.contract()` can be called to do this explicitly; - `Qobj` no longer defines `__array__`, and so cannot be treated as if it is a numpy array. Having this led to inconsistent behaviour when `Qobj` was used in arithmetic with numpy arrays from the left and right, and allowed simple code to become `Qobj.dims`-unsafe _implicitly_. To get the full array view now, you must be explicit and call `Qobj.full()` - it is not enough to do `np.array(qobj)`, and this behaviour is consistent with `scipy.sparse` matrices.; - `eseries` and `essolve` are removed; - OpenMP is temporarily removed (but should be added back in before the release); - most functions marked deprecated as of version 4.5.2 are removed (e.g. in `qutip.correlation`); - `vec2mat` and `mat2vec` are renamed away from the terse MATLAB-compatible syntax to the more QuTiP-consistent `vector_to_operator` and `operator_to_vector`. Non-breaking changes:; - the internal file layout of the code is more organised, with physical ""packages"" `qutip.core` and `qutip.solve` containing the core code and the solvers respectively, but these packages export all their names to the full `qutip` namespace, so there are no user-facing changes; - `Qobj` is a bit more strict about enforcing `Qobj.type`-safety with input types to arithmetic operations, particularly with 1D subspaces; - `Qobj` understands the `@` operator to mean matrix multiplication (it still understands `Qobj * Qobj` to be matrix multiplication as well); - `Qobj` instantiation is massively faster (lower-bounded by ~5µs compared to the previous ~70µs) in internal use and when ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1278
https://github.com/qutip/qutip/issues/1278:851,Integrability,rout,routines,851,"_Last updated: 2020-08-12_. This is an issue for tracking and publicising the development status of a separated data layer. This is a major breaking change to be introduced in QuTiP 5, and will change how library functions and users access the underlying data structures of `Qobj`. This document and issue will change over time. Development is taking place on the [`dev.major` branch](https://github.com/qutip/qutip/tree/dev.major) in `qutip/qutip`. Pull requests implementing new features:; - #1282 separating out the core QuTiP operations into a (logical but user-transparent) package `qutip.core`.; - #1296 implementing the first parts of the data multiple dispatch and new data types.; - #1332 replacing the `fast_csr_matrix` with the new Cython type `CSR` all across QuTiP; - #1338 implementing the data-layer creation, conversion and dispatcher routines. We are writing a new ""developers' guide"" to explain the logic behind the design decisions, and help new QuTiP developers work on the code. You can follow initial development hosted as [a repo in my user account](https://github.com/jakelishman/qutip-devguide) until we decide how this will be added to the main documentation. You can view a rendered version of the documentation at https://jakelishman.github.io/qutip-devguide. Some design documents:; - [data layer](https://github.com/jakelishman/qutip-doc/blob/design-data-layer/design/01-data-time-layer-separation.md); - [data structure implementation choices](https://github.com/jakelishman/qutip-doc/blob/design-data-layer/design/02-data-structures.md); - [original GSoC proposal (PDF)](https://www.binhbar.com/posts/2020/05/welcome-to-google-summer-of-code-2020/proposal.pdf). New design elements under consideration:; - [improved `'type'` and `'dims'` handling for tensor-product spaces](https://github.com/qutip/qutip/issues/1320). Major breaking changes to QuTiP:; - `Qobj.data` is no longer an instance of `scipy.sparse.spmatrix`, but the new abstract ""data-layer type"" `core.data",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1278
https://github.com/qutip/qutip/issues/1278:2175,Integrability,contract,contracted,2175,"d version of the documentation at https://jakelishman.github.io/qutip-devguide. Some design documents:; - [data layer](https://github.com/jakelishman/qutip-doc/blob/design-data-layer/design/01-data-time-layer-separation.md); - [data structure implementation choices](https://github.com/jakelishman/qutip-doc/blob/design-data-layer/design/02-data-structures.md); - [original GSoC proposal (PDF)](https://www.binhbar.com/posts/2020/05/welcome-to-google-summer-of-code-2020/proposal.pdf). New design elements under consideration:; - [improved `'type'` and `'dims'` handling for tensor-product spaces](https://github.com/qutip/qutip/issues/1320). Major breaking changes to QuTiP:; - `Qobj.data` is no longer an instance of `scipy.sparse.spmatrix`, but the new abstract ""data-layer type"" `core.data.Data`; - `bra * ket` now returns a scalar, not a `Qobj` (no need to do `(bra * ket).data[0, 0]` or `(bra * ket).tr()`) any more; - 1D subspaces in `Qobj.dims` are now never contracted silently (they were, but inconsistently before), but the new function `Qobj.contract()` can be called to do this explicitly; - `Qobj` no longer defines `__array__`, and so cannot be treated as if it is a numpy array. Having this led to inconsistent behaviour when `Qobj` was used in arithmetic with numpy arrays from the left and right, and allowed simple code to become `Qobj.dims`-unsafe _implicitly_. To get the full array view now, you must be explicit and call `Qobj.full()` - it is not enough to do `np.array(qobj)`, and this behaviour is consistent with `scipy.sparse` matrices.; - `eseries` and `essolve` are removed; - OpenMP is temporarily removed (but should be added back in before the release); - most functions marked deprecated as of version 4.5.2 are removed (e.g. in `qutip.correlation`); - `vec2mat` and `mat2vec` are renamed away from the terse MATLAB-compatible syntax to the more QuTiP-consistent `vector_to_operator` and `operator_to_vector`. Non-breaking changes:; - the internal file layout of the c",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1278
https://github.com/qutip/qutip/issues/1278:2262,Integrability,contract,contract,2262,"://github.com/jakelishman/qutip-doc/blob/design-data-layer/design/01-data-time-layer-separation.md); - [data structure implementation choices](https://github.com/jakelishman/qutip-doc/blob/design-data-layer/design/02-data-structures.md); - [original GSoC proposal (PDF)](https://www.binhbar.com/posts/2020/05/welcome-to-google-summer-of-code-2020/proposal.pdf). New design elements under consideration:; - [improved `'type'` and `'dims'` handling for tensor-product spaces](https://github.com/qutip/qutip/issues/1320). Major breaking changes to QuTiP:; - `Qobj.data` is no longer an instance of `scipy.sparse.spmatrix`, but the new abstract ""data-layer type"" `core.data.Data`; - `bra * ket` now returns a scalar, not a `Qobj` (no need to do `(bra * ket).data[0, 0]` or `(bra * ket).tr()`) any more; - 1D subspaces in `Qobj.dims` are now never contracted silently (they were, but inconsistently before), but the new function `Qobj.contract()` can be called to do this explicitly; - `Qobj` no longer defines `__array__`, and so cannot be treated as if it is a numpy array. Having this led to inconsistent behaviour when `Qobj` was used in arithmetic with numpy arrays from the left and right, and allowed simple code to become `Qobj.dims`-unsafe _implicitly_. To get the full array view now, you must be explicit and call `Qobj.full()` - it is not enough to do `np.array(qobj)`, and this behaviour is consistent with `scipy.sparse` matrices.; - `eseries` and `essolve` are removed; - OpenMP is temporarily removed (but should be added back in before the release); - most functions marked deprecated as of version 4.5.2 are removed (e.g. in `qutip.correlation`); - `vec2mat` and `mat2vec` are renamed away from the terse MATLAB-compatible syntax to the more QuTiP-consistent `vector_to_operator` and `operator_to_vector`. Non-breaking changes:; - the internal file layout of the code is more organised, with physical ""packages"" `qutip.core` and `qutip.solve` containing the core code and the solvers res",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1278
https://github.com/qutip/qutip/issues/1278:2569,Safety,unsafe,unsafe,2569,"ginal GSoC proposal (PDF)](https://www.binhbar.com/posts/2020/05/welcome-to-google-summer-of-code-2020/proposal.pdf). New design elements under consideration:; - [improved `'type'` and `'dims'` handling for tensor-product spaces](https://github.com/qutip/qutip/issues/1320). Major breaking changes to QuTiP:; - `Qobj.data` is no longer an instance of `scipy.sparse.spmatrix`, but the new abstract ""data-layer type"" `core.data.Data`; - `bra * ket` now returns a scalar, not a `Qobj` (no need to do `(bra * ket).data[0, 0]` or `(bra * ket).tr()`) any more; - 1D subspaces in `Qobj.dims` are now never contracted silently (they were, but inconsistently before), but the new function `Qobj.contract()` can be called to do this explicitly; - `Qobj` no longer defines `__array__`, and so cannot be treated as if it is a numpy array. Having this led to inconsistent behaviour when `Qobj` was used in arithmetic with numpy arrays from the left and right, and allowed simple code to become `Qobj.dims`-unsafe _implicitly_. To get the full array view now, you must be explicit and call `Qobj.full()` - it is not enough to do `np.array(qobj)`, and this behaviour is consistent with `scipy.sparse` matrices.; - `eseries` and `essolve` are removed; - OpenMP is temporarily removed (but should be added back in before the release); - most functions marked deprecated as of version 4.5.2 are removed (e.g. in `qutip.correlation`); - `vec2mat` and `mat2vec` are renamed away from the terse MATLAB-compatible syntax to the more QuTiP-consistent `vector_to_operator` and `operator_to_vector`. Non-breaking changes:; - the internal file layout of the code is more organised, with physical ""packages"" `qutip.core` and `qutip.solve` containing the core code and the solvers respectively, but these packages export all their names to the full `qutip` namespace, so there are no user-facing changes; - `Qobj` is a bit more strict about enforcing `Qobj.type`-safety with input types to arithmetic operations, particularly wi",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1278
https://github.com/qutip/qutip/issues/1278:3511,Safety,safe,safety,3511,"en `Qobj` was used in arithmetic with numpy arrays from the left and right, and allowed simple code to become `Qobj.dims`-unsafe _implicitly_. To get the full array view now, you must be explicit and call `Qobj.full()` - it is not enough to do `np.array(qobj)`, and this behaviour is consistent with `scipy.sparse` matrices.; - `eseries` and `essolve` are removed; - OpenMP is temporarily removed (but should be added back in before the release); - most functions marked deprecated as of version 4.5.2 are removed (e.g. in `qutip.correlation`); - `vec2mat` and `mat2vec` are renamed away from the terse MATLAB-compatible syntax to the more QuTiP-consistent `vector_to_operator` and `operator_to_vector`. Non-breaking changes:; - the internal file layout of the code is more organised, with physical ""packages"" `qutip.core` and `qutip.solve` containing the core code and the solvers respectively, but these packages export all their names to the full `qutip` namespace, so there are no user-facing changes; - `Qobj` is a bit more strict about enforcing `Qobj.type`-safety with input types to arithmetic operations, particularly with 1D subspaces; - `Qobj` understands the `@` operator to mean matrix multiplication (it still understands `Qobj * Qobj` to be matrix multiplication as well); - `Qobj` instantiation is massively faster (lower-bounded by ~5µs compared to the previous ~70µs) in internal use and when doing arithmetic. QuTiP internal functions are now much more aggressive at passing in the `type` and `copy=False` arguments, cutting out most type inference and unnecessary copying of data which were the largest time sinks. Discussions about the implementation of multiple-dispatch methods are on-going in the repository [jakelishman/qutip-dispatch](https://github.com/jakelishman/qutip-dispatch). See in particular some discussion in jakelishman/qutip-dispatch#1. Other discussions are also at the [`data-layer-devs` discussion board](https://github.com/orgs/qutip/teams/data-layer-devs).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1278
https://github.com/qutip/qutip/issues/1278:233,Security,access,access,233,"_Last updated: 2020-08-12_. This is an issue for tracking and publicising the development status of a separated data layer. This is a major breaking change to be introduced in QuTiP 5, and will change how library functions and users access the underlying data structures of `Qobj`. This document and issue will change over time. Development is taking place on the [`dev.major` branch](https://github.com/qutip/qutip/tree/dev.major) in `qutip/qutip`. Pull requests implementing new features:; - #1282 separating out the core QuTiP operations into a (logical but user-transparent) package `qutip.core`.; - #1296 implementing the first parts of the data multiple dispatch and new data types.; - #1332 replacing the `fast_csr_matrix` with the new Cython type `CSR` all across QuTiP; - #1338 implementing the data-layer creation, conversion and dispatcher routines. We are writing a new ""developers' guide"" to explain the logic behind the design decisions, and help new QuTiP developers work on the code. You can follow initial development hosted as [a repo in my user account](https://github.com/jakelishman/qutip-devguide) until we decide how this will be added to the main documentation. You can view a rendered version of the documentation at https://jakelishman.github.io/qutip-devguide. Some design documents:; - [data layer](https://github.com/jakelishman/qutip-doc/blob/design-data-layer/design/01-data-time-layer-separation.md); - [data structure implementation choices](https://github.com/jakelishman/qutip-doc/blob/design-data-layer/design/02-data-structures.md); - [original GSoC proposal (PDF)](https://www.binhbar.com/posts/2020/05/welcome-to-google-summer-of-code-2020/proposal.pdf). New design elements under consideration:; - [improved `'type'` and `'dims'` handling for tensor-product spaces](https://github.com/qutip/qutip/issues/1320). Major breaking changes to QuTiP:; - `Qobj.data` is no longer an instance of `scipy.sparse.spmatrix`, but the new abstract ""data-layer type"" `core.data",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1278
https://github.com/qutip/qutip/issues/1278:549,Testability,log,logical,549,"_Last updated: 2020-08-12_. This is an issue for tracking and publicising the development status of a separated data layer. This is a major breaking change to be introduced in QuTiP 5, and will change how library functions and users access the underlying data structures of `Qobj`. This document and issue will change over time. Development is taking place on the [`dev.major` branch](https://github.com/qutip/qutip/tree/dev.major) in `qutip/qutip`. Pull requests implementing new features:; - #1282 separating out the core QuTiP operations into a (logical but user-transparent) package `qutip.core`.; - #1296 implementing the first parts of the data multiple dispatch and new data types.; - #1332 replacing the `fast_csr_matrix` with the new Cython type `CSR` all across QuTiP; - #1338 implementing the data-layer creation, conversion and dispatcher routines. We are writing a new ""developers' guide"" to explain the logic behind the design decisions, and help new QuTiP developers work on the code. You can follow initial development hosted as [a repo in my user account](https://github.com/jakelishman/qutip-devguide) until we decide how this will be added to the main documentation. You can view a rendered version of the documentation at https://jakelishman.github.io/qutip-devguide. Some design documents:; - [data layer](https://github.com/jakelishman/qutip-doc/blob/design-data-layer/design/01-data-time-layer-separation.md); - [data structure implementation choices](https://github.com/jakelishman/qutip-doc/blob/design-data-layer/design/02-data-structures.md); - [original GSoC proposal (PDF)](https://www.binhbar.com/posts/2020/05/welcome-to-google-summer-of-code-2020/proposal.pdf). New design elements under consideration:; - [improved `'type'` and `'dims'` handling for tensor-product spaces](https://github.com/qutip/qutip/issues/1320). Major breaking changes to QuTiP:; - `Qobj.data` is no longer an instance of `scipy.sparse.spmatrix`, but the new abstract ""data-layer type"" `core.data",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1278
https://github.com/qutip/qutip/issues/1278:917,Testability,log,logic,917,"_Last updated: 2020-08-12_. This is an issue for tracking and publicising the development status of a separated data layer. This is a major breaking change to be introduced in QuTiP 5, and will change how library functions and users access the underlying data structures of `Qobj`. This document and issue will change over time. Development is taking place on the [`dev.major` branch](https://github.com/qutip/qutip/tree/dev.major) in `qutip/qutip`. Pull requests implementing new features:; - #1282 separating out the core QuTiP operations into a (logical but user-transparent) package `qutip.core`.; - #1296 implementing the first parts of the data multiple dispatch and new data types.; - #1332 replacing the `fast_csr_matrix` with the new Cython type `CSR` all across QuTiP; - #1338 implementing the data-layer creation, conversion and dispatcher routines. We are writing a new ""developers' guide"" to explain the logic behind the design decisions, and help new QuTiP developers work on the code. You can follow initial development hosted as [a repo in my user account](https://github.com/jakelishman/qutip-devguide) until we decide how this will be added to the main documentation. You can view a rendered version of the documentation at https://jakelishman.github.io/qutip-devguide. Some design documents:; - [data layer](https://github.com/jakelishman/qutip-doc/blob/design-data-layer/design/01-data-time-layer-separation.md); - [data structure implementation choices](https://github.com/jakelishman/qutip-doc/blob/design-data-layer/design/02-data-structures.md); - [original GSoC proposal (PDF)](https://www.binhbar.com/posts/2020/05/welcome-to-google-summer-of-code-2020/proposal.pdf). New design elements under consideration:; - [improved `'type'` and `'dims'` handling for tensor-product spaces](https://github.com/qutip/qutip/issues/1320). Major breaking changes to QuTiP:; - `Qobj.data` is no longer an instance of `scipy.sparse.spmatrix`, but the new abstract ""data-layer type"" `core.data",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1278
https://github.com/qutip/qutip/issues/1278:895,Usability,guid,guide,895,"_Last updated: 2020-08-12_. This is an issue for tracking and publicising the development status of a separated data layer. This is a major breaking change to be introduced in QuTiP 5, and will change how library functions and users access the underlying data structures of `Qobj`. This document and issue will change over time. Development is taking place on the [`dev.major` branch](https://github.com/qutip/qutip/tree/dev.major) in `qutip/qutip`. Pull requests implementing new features:; - #1282 separating out the core QuTiP operations into a (logical but user-transparent) package `qutip.core`.; - #1296 implementing the first parts of the data multiple dispatch and new data types.; - #1332 replacing the `fast_csr_matrix` with the new Cython type `CSR` all across QuTiP; - #1338 implementing the data-layer creation, conversion and dispatcher routines. We are writing a new ""developers' guide"" to explain the logic behind the design decisions, and help new QuTiP developers work on the code. You can follow initial development hosted as [a repo in my user account](https://github.com/jakelishman/qutip-devguide) until we decide how this will be added to the main documentation. You can view a rendered version of the documentation at https://jakelishman.github.io/qutip-devguide. Some design documents:; - [data layer](https://github.com/jakelishman/qutip-doc/blob/design-data-layer/design/01-data-time-layer-separation.md); - [data structure implementation choices](https://github.com/jakelishman/qutip-doc/blob/design-data-layer/design/02-data-structures.md); - [original GSoC proposal (PDF)](https://www.binhbar.com/posts/2020/05/welcome-to-google-summer-of-code-2020/proposal.pdf). New design elements under consideration:; - [improved `'type'` and `'dims'` handling for tensor-product spaces](https://github.com/qutip/qutip/issues/1320). Major breaking changes to QuTiP:; - `Qobj.data` is no longer an instance of `scipy.sparse.spmatrix`, but the new abstract ""data-layer type"" `core.data",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1278
https://github.com/qutip/qutip/issues/1278:2535,Usability,simpl,simple,2535,"/github.com/jakelishman/qutip-doc/blob/design-data-layer/design/02-data-structures.md); - [original GSoC proposal (PDF)](https://www.binhbar.com/posts/2020/05/welcome-to-google-summer-of-code-2020/proposal.pdf). New design elements under consideration:; - [improved `'type'` and `'dims'` handling for tensor-product spaces](https://github.com/qutip/qutip/issues/1320). Major breaking changes to QuTiP:; - `Qobj.data` is no longer an instance of `scipy.sparse.spmatrix`, but the new abstract ""data-layer type"" `core.data.Data`; - `bra * ket` now returns a scalar, not a `Qobj` (no need to do `(bra * ket).data[0, 0]` or `(bra * ket).tr()`) any more; - 1D subspaces in `Qobj.dims` are now never contracted silently (they were, but inconsistently before), but the new function `Qobj.contract()` can be called to do this explicitly; - `Qobj` no longer defines `__array__`, and so cannot be treated as if it is a numpy array. Having this led to inconsistent behaviour when `Qobj` was used in arithmetic with numpy arrays from the left and right, and allowed simple code to become `Qobj.dims`-unsafe _implicitly_. To get the full array view now, you must be explicit and call `Qobj.full()` - it is not enough to do `np.array(qobj)`, and this behaviour is consistent with `scipy.sparse` matrices.; - `eseries` and `essolve` are removed; - OpenMP is temporarily removed (but should be added back in before the release); - most functions marked deprecated as of version 4.5.2 are removed (e.g. in `qutip.correlation`); - `vec2mat` and `mat2vec` are renamed away from the terse MATLAB-compatible syntax to the more QuTiP-consistent `vector_to_operator` and `operator_to_vector`. Non-breaking changes:; - the internal file layout of the code is more organised, with physical ""packages"" `qutip.core` and `qutip.solve` containing the core code and the solvers respectively, but these packages export all their names to the full `qutip` namespace, so there are no user-facing changes; - `Qobj` is a bit more strict ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1278
https://github.com/qutip/qutip/issues/1279:2,Deployability,Update,Update,2,**Update My Binder link to indexipynb**; Update the my binder link like in qutip-notebooks. Maybe @IvanIsCoding can help. One needs just to copy the link there and substitute it in the Readme.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1279
https://github.com/qutip/qutip/issues/1279:41,Deployability,Update,Update,41,**Update My Binder link to indexipynb**; Update the my binder link like in qutip-notebooks. Maybe @IvanIsCoding can help. One needs just to copy the link there and substitute it in the Readme.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1279
https://github.com/qutip/qutip/pull/1282:1746,Safety,avoid,avoid,1746,"This took longer than anticipated because of a bunch of knock-on nasty Cython problems, and I struggled to get OpenMP running locally on macOS ([but I've got it now](https://www.binhbar.com/posts/2020/06/compiling-openmp-libraries-on-macos/)). Tag: @Ericgig, @ajgpitch. ---. Separate out what will become the ""core"" of qutip into its own subpackage. This package is intended to have most of its public symbols re-imported into the global package namespace. There should be no substantive changes to any actual worker code in this large commit, just what is necessary to carve out a major entangled part of the core library. Some files currently in core may be moved out in a future version (e.g. graph, metrics, semidefinite), but right now they are too entangled with `Qobj` or other true-core parts, and to remove them now would require too much substantive change to the code, which would be difficult to review in this commit. Major changes required as part of this:; - module-level imports (e.g. `from qutip.qobj import Qobj`) are replaced with simple ones from the namespace (e.g. `from qutip import Qobj`). While inside the `core` package, imports are kept as module-specific, largely to support the mess of circular imports present in qutip at the more.; - .pxi files are no longer recommended as the way to share code between Cython files, so these have been converted into proper Cython modules and added to the distribution.; - collection of Cython extension components in `setup.py` is consolidated to support them no longer all existing in the same place. As the data layer is fleshed out, likely there will be even more Cython locations present.; - the test for OpenMP in `__init__.py` had to be made more indirect via importlib to avoid causing a full import of `qutip.core`, which would in turn cause Qobj and other parts to be imported. These components required `__init__.py` to have discovered whether OpenMP existed already before they were imported, causing false negatives.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1282
https://github.com/qutip/qutip/pull/1282:1667,Testability,test,test,1667,"This took longer than anticipated because of a bunch of knock-on nasty Cython problems, and I struggled to get OpenMP running locally on macOS ([but I've got it now](https://www.binhbar.com/posts/2020/06/compiling-openmp-libraries-on-macos/)). Tag: @Ericgig, @ajgpitch. ---. Separate out what will become the ""core"" of qutip into its own subpackage. This package is intended to have most of its public symbols re-imported into the global package namespace. There should be no substantive changes to any actual worker code in this large commit, just what is necessary to carve out a major entangled part of the core library. Some files currently in core may be moved out in a future version (e.g. graph, metrics, semidefinite), but right now they are too entangled with `Qobj` or other true-core parts, and to remove them now would require too much substantive change to the code, which would be difficult to review in this commit. Major changes required as part of this:; - module-level imports (e.g. `from qutip.qobj import Qobj`) are replaced with simple ones from the namespace (e.g. `from qutip import Qobj`). While inside the `core` package, imports are kept as module-specific, largely to support the mess of circular imports present in qutip at the more.; - .pxi files are no longer recommended as the way to share code between Cython files, so these have been converted into proper Cython modules and added to the distribution.; - collection of Cython extension components in `setup.py` is consolidated to support them no longer all existing in the same place. As the data layer is fleshed out, likely there will be even more Cython locations present.; - the test for OpenMP in `__init__.py` had to be made more indirect via importlib to avoid causing a full import of `qutip.core`, which would in turn cause Qobj and other parts to be imported. These components required `__init__.py` to have discovered whether OpenMP existed already before they were imported, causing false negatives.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1282
https://github.com/qutip/qutip/pull/1282:1050,Usability,simpl,simple,1050,"This took longer than anticipated because of a bunch of knock-on nasty Cython problems, and I struggled to get OpenMP running locally on macOS ([but I've got it now](https://www.binhbar.com/posts/2020/06/compiling-openmp-libraries-on-macos/)). Tag: @Ericgig, @ajgpitch. ---. Separate out what will become the ""core"" of qutip into its own subpackage. This package is intended to have most of its public symbols re-imported into the global package namespace. There should be no substantive changes to any actual worker code in this large commit, just what is necessary to carve out a major entangled part of the core library. Some files currently in core may be moved out in a future version (e.g. graph, metrics, semidefinite), but right now they are too entangled with `Qobj` or other true-core parts, and to remove them now would require too much substantive change to the code, which would be difficult to review in this commit. Major changes required as part of this:; - module-level imports (e.g. `from qutip.qobj import Qobj`) are replaced with simple ones from the namespace (e.g. `from qutip import Qobj`). While inside the `core` package, imports are kept as module-specific, largely to support the mess of circular imports present in qutip at the more.; - .pxi files are no longer recommended as the way to share code between Cython files, so these have been converted into proper Cython modules and added to the distribution.; - collection of Cython extension components in `setup.py` is consolidated to support them no longer all existing in the same place. As the data layer is fleshed out, likely there will be even more Cython locations present.; - the test for OpenMP in `__init__.py` had to be made more indirect via importlib to avoid causing a full import of `qutip.core`, which would in turn cause Qobj and other parts to be imported. These components required `__init__.py` to have discovered whether OpenMP existed already before they were imported, causing false negatives.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1282
https://github.com/qutip/qutip/pull/1283:1105,Availability,error,error,1105,"<!--; **Checklist**; Thank you for contributing to QuTiP! Please make sure you have finished the following tasks before opening the PR. - [ ] Please read [Contributing to QuTiP Development](https://github.com/qutip/qutip-doc/blob/master/CONTRIBUTING.md); - [ ] Contributions to qutip should follow the [pep8 style](https://www.python.org/dev/peps/pep-0008/).; You can use [pycodestyle](http://pycodestyle.pycqa.org/en/latest/index.html) to check your code automatically; - [ ] Please add tests to cover your changes if applicable.; - [ ] If the behavior of the code has changed or new feature has been added, please also update the [documentation](https://github.com/qutip/qutip-doc) and the [notebook](https://github.com/qutip/qutip-notebooks). Feel free to ask if you are not sure. Delete this checklist after you have completed all the tasks. If you have not finished them all, you can also open a [Draft Pull Request](https://github.blog/2019-02-14-introducing-draft-pull-requests/) to let the others know this on-going work and keep this checklist in the PR description.; -->. **Description**; Index error in stochastic `smesolve` made `milstein` solver with `heterodyne` method converge only O(0.5) instead of the O(1) expected. This fix it. **Changelog**; Fixed typo in stochastic code affecting `heterodyne` detection efficiency.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1283
https://github.com/qutip/qutip/pull/1283:621,Deployability,update,update,621,"<!--; **Checklist**; Thank you for contributing to QuTiP! Please make sure you have finished the following tasks before opening the PR. - [ ] Please read [Contributing to QuTiP Development](https://github.com/qutip/qutip-doc/blob/master/CONTRIBUTING.md); - [ ] Contributions to qutip should follow the [pep8 style](https://www.python.org/dev/peps/pep-0008/).; You can use [pycodestyle](http://pycodestyle.pycqa.org/en/latest/index.html) to check your code automatically; - [ ] Please add tests to cover your changes if applicable.; - [ ] If the behavior of the code has changed or new feature has been added, please also update the [documentation](https://github.com/qutip/qutip-doc) and the [notebook](https://github.com/qutip/qutip-notebooks). Feel free to ask if you are not sure. Delete this checklist after you have completed all the tasks. If you have not finished them all, you can also open a [Draft Pull Request](https://github.blog/2019-02-14-introducing-draft-pull-requests/) to let the others know this on-going work and keep this checklist in the PR description.; -->. **Description**; Index error in stochastic `smesolve` made `milstein` solver with `heterodyne` method converge only O(0.5) instead of the O(1) expected. This fix it. **Changelog**; Fixed typo in stochastic code affecting `heterodyne` detection efficiency.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1283
https://github.com/qutip/qutip/pull/1283:1316,Safety,detect,detection,1316,"<!--; **Checklist**; Thank you for contributing to QuTiP! Please make sure you have finished the following tasks before opening the PR. - [ ] Please read [Contributing to QuTiP Development](https://github.com/qutip/qutip-doc/blob/master/CONTRIBUTING.md); - [ ] Contributions to qutip should follow the [pep8 style](https://www.python.org/dev/peps/pep-0008/).; You can use [pycodestyle](http://pycodestyle.pycqa.org/en/latest/index.html) to check your code automatically; - [ ] Please add tests to cover your changes if applicable.; - [ ] If the behavior of the code has changed or new feature has been added, please also update the [documentation](https://github.com/qutip/qutip-doc) and the [notebook](https://github.com/qutip/qutip-notebooks). Feel free to ask if you are not sure. Delete this checklist after you have completed all the tasks. If you have not finished them all, you can also open a [Draft Pull Request](https://github.blog/2019-02-14-introducing-draft-pull-requests/) to let the others know this on-going work and keep this checklist in the PR description.; -->. **Description**; Index error in stochastic `smesolve` made `milstein` solver with `heterodyne` method converge only O(0.5) instead of the O(1) expected. This fix it. **Changelog**; Fixed typo in stochastic code affecting `heterodyne` detection efficiency.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1283
https://github.com/qutip/qutip/pull/1283:488,Testability,test,tests,488,"<!--; **Checklist**; Thank you for contributing to QuTiP! Please make sure you have finished the following tasks before opening the PR. - [ ] Please read [Contributing to QuTiP Development](https://github.com/qutip/qutip-doc/blob/master/CONTRIBUTING.md); - [ ] Contributions to qutip should follow the [pep8 style](https://www.python.org/dev/peps/pep-0008/).; You can use [pycodestyle](http://pycodestyle.pycqa.org/en/latest/index.html) to check your code automatically; - [ ] Please add tests to cover your changes if applicable.; - [ ] If the behavior of the code has changed or new feature has been added, please also update the [documentation](https://github.com/qutip/qutip-doc) and the [notebook](https://github.com/qutip/qutip-notebooks). Feel free to ask if you are not sure. Delete this checklist after you have completed all the tasks. If you have not finished them all, you can also open a [Draft Pull Request](https://github.blog/2019-02-14-introducing-draft-pull-requests/) to let the others know this on-going work and keep this checklist in the PR description.; -->. **Description**; Index error in stochastic `smesolve` made `milstein` solver with `heterodyne` method converge only O(0.5) instead of the O(1) expected. This fix it. **Changelog**; Fixed typo in stochastic code affecting `heterodyne` detection efficiency.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1283
https://github.com/qutip/qutip/issues/1284:2005,Integrability,rout,routine,2005,"orly documented. For example, for the functions `optimize_pulse` and `optimize_pulse_unitary` there are 'params' arguments for many of the underlying classes, but it's not at all clear what count as valid key value pairs for each class.; ```python; Parameters; ----------; alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. . dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. init_pulse_params : dict; Parameters for the initial / guess pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ```. As a further example, `dyn_params` is passed to a `Dynamics` object which stores it locally in `self.params`, but there isn't any checking of valid keys and values, and I can't find a function which actually uses whatever these params are set to. It's really difficult to run a top-level routine that creates all these objects which you have no clear control over.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1284
https://github.com/qutip/qutip/issues/1284:34,Performance,optimiz,optimization,34,"Many of the features in the pulse optimization module are difficult to use, or poorly documented. For example, for the functions `optimize_pulse` and `optimize_pulse_unitary` there are 'params' arguments for many of the underlying classes, but it's not at all clear what count as valid key value pairs for each class.; ```python; Parameters; ----------; alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. . dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. init_pulse_params : dict; Parameters for the initial / guess pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ```. As a further example, `dyn_params` is passed to a `Dynamics` object which stores it locally in `self.params`, but there isn't any checking of valid keys and values, and I can't find a function which actually uses whatever these params are set to. It's really difficult to run a top-le",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1284
https://github.com/qutip/qutip/issues/1284:812,Performance,Optimiz,Optimizer,812,"Many of the features in the pulse optimization module are difficult to use, or poorly documented. For example, for the functions `optimize_pulse` and `optimize_pulse_unitary` there are 'params' arguments for many of the underlying classes, but it's not at all clear what count as valid key value pairs for each class.; ```python; Parameters; ----------; alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. . dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. init_pulse_params : dict; Parameters for the initial / guess pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ```. As a further example, `dyn_params` is passed to a `Dynamics` object which stores it locally in `self.params`, but there isn't any checking of valid keys and values, and I can't find a function which actually uses whatever these params are set to. It's really difficult to run a top-le",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1284
https://github.com/qutip/qutip/issues/1284:983,Performance,optimiz,optimize,983,"Many of the features in the pulse optimization module are difficult to use, or poorly documented. For example, for the functions `optimize_pulse` and `optimize_pulse_unitary` there are 'params' arguments for many of the underlying classes, but it's not at all clear what count as valid key value pairs for each class.; ```python; Parameters; ----------; alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. . dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. init_pulse_params : dict; Parameters for the initial / guess pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ```. As a further example, `dyn_params` is passed to a `Dynamics` object which stores it locally in `self.params`, but there isn't any checking of valid keys and values, and I can't find a function which actually uses whatever these params are set to. It's really difficult to run a top-le",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1284
https://github.com/qutip/qutip/issues/1284:260,Usability,clear,clear,260,"Many of the features in the pulse optimization module are difficult to use, or poorly documented. For example, for the functions `optimize_pulse` and `optimize_pulse_unitary` there are 'params' arguments for many of the underlying classes, but it's not at all clear what count as valid key value pairs for each class.; ```python; Parameters; ----------; alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. . dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. init_pulse_params : dict; Parameters for the initial / guess pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ```. As a further example, `dyn_params` is passed to a `Dynamics` object which stores it locally in `self.params`, but there isn't any checking of valid keys and values, and I can't find a function which actually uses whatever these params are set to. It's really difficult to run a top-le",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1284
https://github.com/qutip/qutip/issues/1284:2062,Usability,clear,clear,2062,"orly documented. For example, for the functions `optimize_pulse` and `optimize_pulse_unitary` there are 'params' arguments for many of the underlying classes, but it's not at all clear what count as valid key value pairs for each class.; ```python; Parameters; ----------; alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. . dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. init_pulse_params : dict; Parameters for the initial / guess pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ```. As a further example, `dyn_params` is passed to a `Dynamics` object which stores it locally in `self.params`, but there isn't any checking of valid keys and values, and I can't find a function which actually uses whatever these params are set to. It's really difficult to run a top-level routine that creates all these objects which you have no clear control over.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1284
https://github.com/qutip/qutip/issues/1285:1570,Deployability,Install,Installed,1570,"**Describe the bug**; I think there is a mistake in the Hamiltonian's part inside the `liouvillian` function:; https://github.com/qutip/qutip/blob/c62a8e99f503b864933cd6bb31e259d47770b95a/qutip/superoperator.py#L122-L127. However, according to [Linblad equation](https://en.wikipedia.org/wiki/Lindbladian#Definition) it should be:; ```python; data = -1j * zcsr_kron(H.data, spI); data += 1j * zcsr_kron(spI, Ht); ```. **To Reproduce**; Comparison of qutip vs. numpy:. ```python; import numpy as np; import qutip. n_H = 2 # the dimension of the Hilbert space. # qutip's liouvillian; H_qutip = qutip.sigmaz(); L_qutip = qutip.liouvillian(H_qutip, []). # numpy's liouvillian; H_np = np.diag([1, -1]); L_np = -1j * (np.kron(H_np, np.eye(n_H)) - np.kron(np.eye(n_H), H_np.T)). # comparison; print('1. H_qutip == H_np:', np.array_equal(H_qutip, H_np)); print('2. L_qutip == L_np:', np.array_equal(L_qutip, L_np)); print('3. L_qutip == -L_np:', np.array_equal(L_qutip, -L_np)); ```; The terminal out put is; ```; 1. H_qutip == H_np: True; 2. L_qutip == L_np: False; 3. L_qutip == -L_np: True; ```; (The construction of the Liouvillian with numpy is based on eq. (A6) in:; https://arxiv.org/pdf/1909.11619.pdf#page=16). **Expected behavior**; 1 is True as expected.; 2 should be True and 3 should be False, but the opposite happens because of the sign mistake. **Your Environment**; ```; QuTiP Version: 4.5.0; Numpy Version: 1.18.1; Scipy Version: 1.4.1; Cython Version: 0.29.15; Matplotlib Version: 3.1.3; Python Version: 3.7.6; Number of CPUs: 6; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Windows (AMD64); ```; (Probably irrelevant.). **Additional context**; Please let me know that you approve the change in the description and I will make a quick PR.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1285
https://github.com/qutip/qutip/pull/1288:70,Availability,fault,fault,70,"**Description**; On mac, with OpenBlas, `eigh` can cause segmentation fault, see #1197. For 4.5.1, we simply skipped the tests causing problems ( #1257). This replace the calls of `numpy.linalg.eigh` to `numpy.linalg.eig`, and lapack calls of `ZHEEVR` to `ZGEEV` when at risk of segfault. This will result in slower `Qobj.eigenstates` and `brmesolve`. . Tests where adapted, the issues were the phase of the eigenvectors and the lower numerical precision of `eig`. While the flag to use `eig` instead of `eigh` is `qutip.settings.eigh_unsafe`, it must be set before importing `qutip.sparse` to have any effect. Thus it is not a true settings, (like `has_openmp`). **Changelog**; Replace calls of `eigh` to `eig` when at risk of segfault.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1288
https://github.com/qutip/qutip/pull/1288:366,Energy Efficiency,adapt,adapted,366,"**Description**; On mac, with OpenBlas, `eigh` can cause segmentation fault, see #1197. For 4.5.1, we simply skipped the tests causing problems ( #1257). This replace the calls of `numpy.linalg.eigh` to `numpy.linalg.eig`, and lapack calls of `ZHEEVR` to `ZGEEV` when at risk of segfault. This will result in slower `Qobj.eigenstates` and `brmesolve`. . Tests where adapted, the issues were the phase of the eigenvectors and the lower numerical precision of `eig`. While the flag to use `eig` instead of `eigh` is `qutip.settings.eigh_unsafe`, it must be set before importing `qutip.sparse` to have any effect. Thus it is not a true settings, (like `has_openmp`). **Changelog**; Replace calls of `eigh` to `eig` when at risk of segfault.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1288
https://github.com/qutip/qutip/pull/1288:366,Modifiability,adapt,adapted,366,"**Description**; On mac, with OpenBlas, `eigh` can cause segmentation fault, see #1197. For 4.5.1, we simply skipped the tests causing problems ( #1257). This replace the calls of `numpy.linalg.eigh` to `numpy.linalg.eig`, and lapack calls of `ZHEEVR` to `ZGEEV` when at risk of segfault. This will result in slower `Qobj.eigenstates` and `brmesolve`. . Tests where adapted, the issues were the phase of the eigenvectors and the lower numerical precision of `eig`. While the flag to use `eig` instead of `eigh` is `qutip.settings.eigh_unsafe`, it must be set before importing `qutip.sparse` to have any effect. Thus it is not a true settings, (like `has_openmp`). **Changelog**; Replace calls of `eigh` to `eig` when at risk of segfault.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1288
https://github.com/qutip/qutip/pull/1288:271,Safety,risk,risk,271,"**Description**; On mac, with OpenBlas, `eigh` can cause segmentation fault, see #1197. For 4.5.1, we simply skipped the tests causing problems ( #1257). This replace the calls of `numpy.linalg.eigh` to `numpy.linalg.eig`, and lapack calls of `ZHEEVR` to `ZGEEV` when at risk of segfault. This will result in slower `Qobj.eigenstates` and `brmesolve`. . Tests where adapted, the issues were the phase of the eigenvectors and the lower numerical precision of `eig`. While the flag to use `eig` instead of `eigh` is `qutip.settings.eigh_unsafe`, it must be set before importing `qutip.sparse` to have any effect. Thus it is not a true settings, (like `has_openmp`). **Changelog**; Replace calls of `eigh` to `eig` when at risk of segfault.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1288
https://github.com/qutip/qutip/pull/1288:720,Safety,risk,risk,720,"**Description**; On mac, with OpenBlas, `eigh` can cause segmentation fault, see #1197. For 4.5.1, we simply skipped the tests causing problems ( #1257). This replace the calls of `numpy.linalg.eigh` to `numpy.linalg.eig`, and lapack calls of `ZHEEVR` to `ZGEEV` when at risk of segfault. This will result in slower `Qobj.eigenstates` and `brmesolve`. . Tests where adapted, the issues were the phase of the eigenvectors and the lower numerical precision of `eig`. While the flag to use `eig` instead of `eigh` is `qutip.settings.eigh_unsafe`, it must be set before importing `qutip.sparse` to have any effect. Thus it is not a true settings, (like `has_openmp`). **Changelog**; Replace calls of `eigh` to `eig` when at risk of segfault.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1288
https://github.com/qutip/qutip/pull/1288:121,Testability,test,tests,121,"**Description**; On mac, with OpenBlas, `eigh` can cause segmentation fault, see #1197. For 4.5.1, we simply skipped the tests causing problems ( #1257). This replace the calls of `numpy.linalg.eigh` to `numpy.linalg.eig`, and lapack calls of `ZHEEVR` to `ZGEEV` when at risk of segfault. This will result in slower `Qobj.eigenstates` and `brmesolve`. . Tests where adapted, the issues were the phase of the eigenvectors and the lower numerical precision of `eig`. While the flag to use `eig` instead of `eigh` is `qutip.settings.eigh_unsafe`, it must be set before importing `qutip.sparse` to have any effect. Thus it is not a true settings, (like `has_openmp`). **Changelog**; Replace calls of `eigh` to `eig` when at risk of segfault.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1288
https://github.com/qutip/qutip/pull/1288:354,Testability,Test,Tests,354,"**Description**; On mac, with OpenBlas, `eigh` can cause segmentation fault, see #1197. For 4.5.1, we simply skipped the tests causing problems ( #1257). This replace the calls of `numpy.linalg.eigh` to `numpy.linalg.eig`, and lapack calls of `ZHEEVR` to `ZGEEV` when at risk of segfault. This will result in slower `Qobj.eigenstates` and `brmesolve`. . Tests where adapted, the issues were the phase of the eigenvectors and the lower numerical precision of `eig`. While the flag to use `eig` instead of `eigh` is `qutip.settings.eigh_unsafe`, it must be set before importing `qutip.sparse` to have any effect. Thus it is not a true settings, (like `has_openmp`). **Changelog**; Replace calls of `eigh` to `eig` when at risk of segfault.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1288
https://github.com/qutip/qutip/pull/1288:102,Usability,simpl,simply,102,"**Description**; On mac, with OpenBlas, `eigh` can cause segmentation fault, see #1197. For 4.5.1, we simply skipped the tests causing problems ( #1257). This replace the calls of `numpy.linalg.eigh` to `numpy.linalg.eig`, and lapack calls of `ZHEEVR` to `ZGEEV` when at risk of segfault. This will result in slower `Qobj.eigenstates` and `brmesolve`. . Tests where adapted, the issues were the phase of the eigenvectors and the lower numerical precision of `eig`. While the flag to use `eig` instead of `eigh` is `qutip.settings.eigh_unsafe`, it must be set before importing `qutip.sparse` to have any effect. Thus it is not a true settings, (like `has_openmp`). **Changelog**; Replace calls of `eigh` to `eig` when at risk of segfault.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1288
https://github.com/qutip/qutip/pull/1289:490,Availability,error,errors,490,"**Description**. - Add the `reset` function to `qutip.settings` that is described in the documentation but was never implemented. ; - Add `save`, `load` to `qutip.settings`, allowing to save in alternate files.; - The list of configuration that can be saved in qutiprc is generated when loading the module.; - Ungraded the `configrc` functionalities to allow other filenames and support more than a few hard coded `qutip.settings`'s keys.; - Reading `qutiprc` will raise warning instead of errors when unknown keys. So if we remove keys in v5, old file will not cause crashes when importing qutip for the few that use qutiprc. . **Changelog**; Add `reset` to `qutip.settings`",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1289
https://github.com/qutip/qutip/pull/1289:226,Deployability,configurat,configuration,226,"**Description**. - Add the `reset` function to `qutip.settings` that is described in the documentation but was never implemented. ; - Add `save`, `load` to `qutip.settings`, allowing to save in alternate files.; - The list of configuration that can be saved in qutiprc is generated when loading the module.; - Ungraded the `configrc` functionalities to allow other filenames and support more than a few hard coded `qutip.settings`'s keys.; - Reading `qutiprc` will raise warning instead of errors when unknown keys. So if we remove keys in v5, old file will not cause crashes when importing qutip for the few that use qutiprc. . **Changelog**; Add `reset` to `qutip.settings`",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1289
https://github.com/qutip/qutip/pull/1289:226,Modifiability,config,configuration,226,"**Description**. - Add the `reset` function to `qutip.settings` that is described in the documentation but was never implemented. ; - Add `save`, `load` to `qutip.settings`, allowing to save in alternate files.; - The list of configuration that can be saved in qutiprc is generated when loading the module.; - Ungraded the `configrc` functionalities to allow other filenames and support more than a few hard coded `qutip.settings`'s keys.; - Reading `qutiprc` will raise warning instead of errors when unknown keys. So if we remove keys in v5, old file will not cause crashes when importing qutip for the few that use qutiprc. . **Changelog**; Add `reset` to `qutip.settings`",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1289
https://github.com/qutip/qutip/pull/1289:324,Modifiability,config,configrc,324,"**Description**. - Add the `reset` function to `qutip.settings` that is described in the documentation but was never implemented. ; - Add `save`, `load` to `qutip.settings`, allowing to save in alternate files.; - The list of configuration that can be saved in qutiprc is generated when loading the module.; - Ungraded the `configrc` functionalities to allow other filenames and support more than a few hard coded `qutip.settings`'s keys.; - Reading `qutiprc` will raise warning instead of errors when unknown keys. So if we remove keys in v5, old file will not cause crashes when importing qutip for the few that use qutiprc. . **Changelog**; Add `reset` to `qutip.settings`",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1289
https://github.com/qutip/qutip/pull/1289:147,Performance,load,load,147,"**Description**. - Add the `reset` function to `qutip.settings` that is described in the documentation but was never implemented. ; - Add `save`, `load` to `qutip.settings`, allowing to save in alternate files.; - The list of configuration that can be saved in qutiprc is generated when loading the module.; - Ungraded the `configrc` functionalities to allow other filenames and support more than a few hard coded `qutip.settings`'s keys.; - Reading `qutiprc` will raise warning instead of errors when unknown keys. So if we remove keys in v5, old file will not cause crashes when importing qutip for the few that use qutiprc. . **Changelog**; Add `reset` to `qutip.settings`",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1289
https://github.com/qutip/qutip/pull/1289:287,Performance,load,loading,287,"**Description**. - Add the `reset` function to `qutip.settings` that is described in the documentation but was never implemented. ; - Add `save`, `load` to `qutip.settings`, allowing to save in alternate files.; - The list of configuration that can be saved in qutiprc is generated when loading the module.; - Ungraded the `configrc` functionalities to allow other filenames and support more than a few hard coded `qutip.settings`'s keys.; - Reading `qutiprc` will raise warning instead of errors when unknown keys. So if we remove keys in v5, old file will not cause crashes when importing qutip for the few that use qutiprc. . **Changelog**; Add `reset` to `qutip.settings`",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1289
https://github.com/qutip/qutip/pull/1291:1080,Availability,robust,robust,1080,"**Description**; The OpenQASM 2.0 standard is described [here](https://github.com/Qiskit/openqasm/blob/master/spec/qasm2.rst). ; The purpose of this PR is to create a full implementation of a OpenQASM parser that reads ; a .qasm circuit into a QubitCircuit. This function lives in qutip/qip/qasm.py. There are a number of ; internal functions that enable this conversion but the only api-exposed function is supposed to be ; `read_qasm` which takes in a .qasm file and returns a fully-formed QubitCircuit object. Currently, the heft of the work is done with processing user-defined gates and adding them to the circuit (as well as measurements, but they need to have #1274 on measurements merged before I can enable that functionality). I still need to add features pertaining to initialization of qubits as well as classical control. . **Related issues or PRs**; There was a related PR #1140 which purportedly worked with OpenQASM 1.0 but this one deviates from it largely while adding additional features as well as the ability to process user-defined gates and a comparatively robust parser. ; **Changelog**; Added read_qasm function to read .qasm files into QubitCircuit",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1291
https://github.com/qutip/qutip/pull/1291:388,Security,expose,exposed,388,"**Description**; The OpenQASM 2.0 standard is described [here](https://github.com/Qiskit/openqasm/blob/master/spec/qasm2.rst). ; The purpose of this PR is to create a full implementation of a OpenQASM parser that reads ; a .qasm circuit into a QubitCircuit. This function lives in qutip/qip/qasm.py. There are a number of ; internal functions that enable this conversion but the only api-exposed function is supposed to be ; `read_qasm` which takes in a .qasm file and returns a fully-formed QubitCircuit object. Currently, the heft of the work is done with processing user-defined gates and adding them to the circuit (as well as measurements, but they need to have #1274 on measurements merged before I can enable that functionality). I still need to add features pertaining to initialization of qubits as well as classical control. . **Related issues or PRs**; There was a related PR #1140 which purportedly worked with OpenQASM 1.0 but this one deviates from it largely while adding additional features as well as the ability to process user-defined gates and a comparatively robust parser. ; **Changelog**; Added read_qasm function to read .qasm files into QubitCircuit",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1291
https://github.com/qutip/qutip/issues/1292:755,Energy Efficiency,green,green,755,"The Bloch sphere is an amazing tool for visualisations. In a project where I wanted to show the evolution of an initial quantum state to a final target, I wanted to put specific colours to the initial and final bloch vector. Right now, the function `[qutip.bloch.add_states](https://github.com/qutip/qutip/blob/master/qutip/bloch.py#L353)` or `[qutip.bloch.add_vectors](https://github.com/qutip/qutip/blob/master/qutip/bloch.py#L378)` cycles through a fixed list of colours here - https://github.com/qutip/qutip/blob/master/qutip/bloch.py#L563. It would be nice if the user could also add an optional color argument or list of colours when adding a new vector such as `bloch.add_vectors(vec, color=""r"")` or `bloch.add_vectors([vec1, vec2], color=[""red"", ""green""])`. In this case I would have liked to set the two colours in the vector myself. . ![image](https://user-images.githubusercontent.com/6968324/84878607-58340100-b08a-11ea-978a-03085378261f.png)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1292
https://github.com/qutip/qutip/issues/1293:419,Energy Efficiency,Efficient,Efficient,419,"Matrix exponentiation is a costly operation. See [1][Nineteen Dubious Ways to Compute the Exponential of a Matrix, Twenty-Five Years Later∗](https://www.cs.cornell.edu/cv/ResearchPDF/19ways%2B.pdf). In a quantum optics, the displacement operator is one of the most basic. It is used to create coherent states from vacuum and forms one of the two gates for universal control of a cavity (Displacement + SNAP gates) [2] [Efficient cavity control with SNAP gates](https://arxiv.org/abs/2004.14256). When we want to write an optimisation routine that finds best displacement parameters in a routine similar to the paper above [2], it would be nice if we can compute the operator faster without doing matrix exponentiation as qutip does now:; https://github.com/qutip/qutip/blob/master/qutip/operators.py#L732. I have some notes from a colleague who calculated an analytical formula to compute the matrix elements of the displacement operator without having to do matrix exponentiation [3]: ; [Displacement_operator.pdf](https://github.com/qutip/qutip/files/4791455/Displacement_operator.pdf). A PR to implement this in QuTiP would be great. We could first write a `_displace_analytical` function that calculates the displacement matrix using the [Scipy Laguerre polynomial](https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.genlaguerre.html) and have it as an option as `displace(N, alpha, offset, method=`analytical` )`. Could it also come in handy for optimal control? @ajgpitch . In the paper above [2], the authors use gradient descent to fine tune the parameters of a gate sequence containing displacement gates and SNAP gates to target some Bosonic quantum state. We wish to do similar things for @araza6 s GSoC project.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1293
https://github.com/qutip/qutip/issues/1293:534,Integrability,rout,routine,534,"Matrix exponentiation is a costly operation. See [1][Nineteen Dubious Ways to Compute the Exponential of a Matrix, Twenty-Five Years Later∗](https://www.cs.cornell.edu/cv/ResearchPDF/19ways%2B.pdf). In a quantum optics, the displacement operator is one of the most basic. It is used to create coherent states from vacuum and forms one of the two gates for universal control of a cavity (Displacement + SNAP gates) [2] [Efficient cavity control with SNAP gates](https://arxiv.org/abs/2004.14256). When we want to write an optimisation routine that finds best displacement parameters in a routine similar to the paper above [2], it would be nice if we can compute the operator faster without doing matrix exponentiation as qutip does now:; https://github.com/qutip/qutip/blob/master/qutip/operators.py#L732. I have some notes from a colleague who calculated an analytical formula to compute the matrix elements of the displacement operator without having to do matrix exponentiation [3]: ; [Displacement_operator.pdf](https://github.com/qutip/qutip/files/4791455/Displacement_operator.pdf). A PR to implement this in QuTiP would be great. We could first write a `_displace_analytical` function that calculates the displacement matrix using the [Scipy Laguerre polynomial](https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.genlaguerre.html) and have it as an option as `displace(N, alpha, offset, method=`analytical` )`. Could it also come in handy for optimal control? @ajgpitch . In the paper above [2], the authors use gradient descent to fine tune the parameters of a gate sequence containing displacement gates and SNAP gates to target some Bosonic quantum state. We wish to do similar things for @araza6 s GSoC project.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1293
https://github.com/qutip/qutip/issues/1293:587,Integrability,rout,routine,587,"Matrix exponentiation is a costly operation. See [1][Nineteen Dubious Ways to Compute the Exponential of a Matrix, Twenty-Five Years Later∗](https://www.cs.cornell.edu/cv/ResearchPDF/19ways%2B.pdf). In a quantum optics, the displacement operator is one of the most basic. It is used to create coherent states from vacuum and forms one of the two gates for universal control of a cavity (Displacement + SNAP gates) [2] [Efficient cavity control with SNAP gates](https://arxiv.org/abs/2004.14256). When we want to write an optimisation routine that finds best displacement parameters in a routine similar to the paper above [2], it would be nice if we can compute the operator faster without doing matrix exponentiation as qutip does now:; https://github.com/qutip/qutip/blob/master/qutip/operators.py#L732. I have some notes from a colleague who calculated an analytical formula to compute the matrix elements of the displacement operator without having to do matrix exponentiation [3]: ; [Displacement_operator.pdf](https://github.com/qutip/qutip/files/4791455/Displacement_operator.pdf). A PR to implement this in QuTiP would be great. We could first write a `_displace_analytical` function that calculates the displacement matrix using the [Scipy Laguerre polynomial](https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.genlaguerre.html) and have it as an option as `displace(N, alpha, offset, method=`analytical` )`. Could it also come in handy for optimal control? @ajgpitch . In the paper above [2], the authors use gradient descent to fine tune the parameters of a gate sequence containing displacement gates and SNAP gates to target some Bosonic quantum state. We wish to do similar things for @araza6 s GSoC project.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1293
https://github.com/qutip/qutip/issues/1293:1561,Performance,tune,tune,1561,"Matrix exponentiation is a costly operation. See [1][Nineteen Dubious Ways to Compute the Exponential of a Matrix, Twenty-Five Years Later∗](https://www.cs.cornell.edu/cv/ResearchPDF/19ways%2B.pdf). In a quantum optics, the displacement operator is one of the most basic. It is used to create coherent states from vacuum and forms one of the two gates for universal control of a cavity (Displacement + SNAP gates) [2] [Efficient cavity control with SNAP gates](https://arxiv.org/abs/2004.14256). When we want to write an optimisation routine that finds best displacement parameters in a routine similar to the paper above [2], it would be nice if we can compute the operator faster without doing matrix exponentiation as qutip does now:; https://github.com/qutip/qutip/blob/master/qutip/operators.py#L732. I have some notes from a colleague who calculated an analytical formula to compute the matrix elements of the displacement operator without having to do matrix exponentiation [3]: ; [Displacement_operator.pdf](https://github.com/qutip/qutip/files/4791455/Displacement_operator.pdf). A PR to implement this in QuTiP would be great. We could first write a `_displace_analytical` function that calculates the displacement matrix using the [Scipy Laguerre polynomial](https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.genlaguerre.html) and have it as an option as `displace(N, alpha, offset, method=`analytical` )`. Could it also come in handy for optimal control? @ajgpitch . In the paper above [2], the authors use gradient descent to fine tune the parameters of a gate sequence containing displacement gates and SNAP gates to target some Bosonic quantum state. We wish to do similar things for @araza6 s GSoC project.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1293
https://github.com/qutip/qutip/pull/1296:144,Usability,simpl,simple,144,"Add the `data.CSR` and `data.Dense` types, and begin the port of the current operations of a mixture of `fast_csr_matrix` and `CSR_Matrix` into simple ones on the new `CSR` type. This is significantly faster at initialisation and interaction between Python and Cython. Also add the base multiple dispatcher type which will be used in the future to implement data layer multiple dispatch. @qutip/data-layer-devs.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1296
https://github.com/qutip/qutip/pull/1297:1720,Availability,avail,available,1720,"ax_step = 1; qset.save(); print(Options().atol); >>> 1e-10; ```; `atol = 1e-10` and `max_step = 1` will be kept as default in future sessions. `qset.options.reset` to go back to qutip's default. I believe that loading custom settings when importing qutip will be appreciated with support of both `dense` and `sparse` most researchers will have a preference depending on their domain. This also brings all settings in one place: `qutip.settings...` even if we split the code in ""core"", ""solver"", ""qip?"", etc. Lastly, creating and moving around an `Options` object is no longer needed, changing the default before using the solver has the same effect. . For developers:; Principally @jakelishman as I expect you to add settings for core. ; I went with an implementation similar to python `dataclass`. To add `core`'s settings to `qutip.settings` you would do ""; ```; from qutip.settings import QtOptionClass. @QtOptionClass(""core""); class CoreOptions:; basetype = ""Dense""; auto_tidyup = True; ...; ```; And it would create the `__init__`, `__repr__`, `save`, `load` and `reset` methods, and create the default instance as `qutip.settings.core`. All attributes that do not start with ""_"" and are one of `bool`, `str`, `int`, `float`, `complex` will be in tagged to be saved and loaded. Those are the only types available now, but other can be added if needed. In `__init__` all these + properties with a setter can be initiated as keyword arguments. '__repr__' 'print' all the saved attributes and properties.; This is for the likes of `has_openmp`, I would make it a read only property. Another way of doing this would have been to use a parent class and a ""register"" functions. I went with this one because the signature of `__init__` in help was cleaner. I have both implemented so if qip of control want to use the base without registering to `qutip.settings`, I can change the PR. (@ajgpitch, @BoxiLi ). Build on top of #1289. . **Changelog**; Solver options can be set in `qutip.settings.options`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1297
https://github.com/qutip/qutip/pull/1297:277,Deployability,configurat,configuration,277,"**Description**; User-facing changes:; - Solver's `Options` defaults can be set `qutip.settings.options`.; - Add the `save`, `load`, `reset` method to Options.; - The default `Options` are read from ""qutiprc"" when loading qutip.; - Options object can be initiated from a saved configuration. Example:; ```; import qutip.setting as qset; from qutip.solver import Options; qset.options.atol = 1e-10; qset.options.max_step = 1; qset.save(); print(Options().atol); >>> 1e-10; ```; `atol = 1e-10` and `max_step = 1` will be kept as default in future sessions. `qset.options.reset` to go back to qutip's default. I believe that loading custom settings when importing qutip will be appreciated with support of both `dense` and `sparse` most researchers will have a preference depending on their domain. This also brings all settings in one place: `qutip.settings...` even if we split the code in ""core"", ""solver"", ""qip?"", etc. Lastly, creating and moving around an `Options` object is no longer needed, changing the default before using the solver has the same effect. . For developers:; Principally @jakelishman as I expect you to add settings for core. ; I went with an implementation similar to python `dataclass`. To add `core`'s settings to `qutip.settings` you would do ""; ```; from qutip.settings import QtOptionClass. @QtOptionClass(""core""); class CoreOptions:; basetype = ""Dense""; auto_tidyup = True; ...; ```; And it would create the `__init__`, `__repr__`, `save`, `load` and `reset` methods, and create the default instance as `qutip.settings.core`. All attributes that do not start with ""_"" and are one of `bool`, `str`, `int`, `float`, `complex` will be in tagged to be saved and loaded. Those are the only types available now, but other can be added if needed. In `__init__` all these + properties with a setter can be initiated as keyword arguments. '__repr__' 'print' all the saved attributes and properties.; This is for the likes of `has_openmp`, I would make it a read only property. Anot",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1297
https://github.com/qutip/qutip/pull/1297:769,Integrability,depend,depending,769,"**Description**; User-facing changes:; - Solver's `Options` defaults can be set `qutip.settings.options`.; - Add the `save`, `load`, `reset` method to Options.; - The default `Options` are read from ""qutiprc"" when loading qutip.; - Options object can be initiated from a saved configuration. Example:; ```; import qutip.setting as qset; from qutip.solver import Options; qset.options.atol = 1e-10; qset.options.max_step = 1; qset.save(); print(Options().atol); >>> 1e-10; ```; `atol = 1e-10` and `max_step = 1` will be kept as default in future sessions. `qset.options.reset` to go back to qutip's default. I believe that loading custom settings when importing qutip will be appreciated with support of both `dense` and `sparse` most researchers will have a preference depending on their domain. This also brings all settings in one place: `qutip.settings...` even if we split the code in ""core"", ""solver"", ""qip?"", etc. Lastly, creating and moving around an `Options` object is no longer needed, changing the default before using the solver has the same effect. . For developers:; Principally @jakelishman as I expect you to add settings for core. ; I went with an implementation similar to python `dataclass`. To add `core`'s settings to `qutip.settings` you would do ""; ```; from qutip.settings import QtOptionClass. @QtOptionClass(""core""); class CoreOptions:; basetype = ""Dense""; auto_tidyup = True; ...; ```; And it would create the `__init__`, `__repr__`, `save`, `load` and `reset` methods, and create the default instance as `qutip.settings.core`. All attributes that do not start with ""_"" and are one of `bool`, `str`, `int`, `float`, `complex` will be in tagged to be saved and loaded. Those are the only types available now, but other can be added if needed. In `__init__` all these + properties with a setter can be initiated as keyword arguments. '__repr__' 'print' all the saved attributes and properties.; This is for the likes of `has_openmp`, I would make it a read only property. Anot",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1297
https://github.com/qutip/qutip/pull/1297:277,Modifiability,config,configuration,277,"**Description**; User-facing changes:; - Solver's `Options` defaults can be set `qutip.settings.options`.; - Add the `save`, `load`, `reset` method to Options.; - The default `Options` are read from ""qutiprc"" when loading qutip.; - Options object can be initiated from a saved configuration. Example:; ```; import qutip.setting as qset; from qutip.solver import Options; qset.options.atol = 1e-10; qset.options.max_step = 1; qset.save(); print(Options().atol); >>> 1e-10; ```; `atol = 1e-10` and `max_step = 1` will be kept as default in future sessions. `qset.options.reset` to go back to qutip's default. I believe that loading custom settings when importing qutip will be appreciated with support of both `dense` and `sparse` most researchers will have a preference depending on their domain. This also brings all settings in one place: `qutip.settings...` even if we split the code in ""core"", ""solver"", ""qip?"", etc. Lastly, creating and moving around an `Options` object is no longer needed, changing the default before using the solver has the same effect. . For developers:; Principally @jakelishman as I expect you to add settings for core. ; I went with an implementation similar to python `dataclass`. To add `core`'s settings to `qutip.settings` you would do ""; ```; from qutip.settings import QtOptionClass. @QtOptionClass(""core""); class CoreOptions:; basetype = ""Dense""; auto_tidyup = True; ...; ```; And it would create the `__init__`, `__repr__`, `save`, `load` and `reset` methods, and create the default instance as `qutip.settings.core`. All attributes that do not start with ""_"" and are one of `bool`, `str`, `int`, `float`, `complex` will be in tagged to be saved and loaded. Those are the only types available now, but other can be added if needed. In `__init__` all these + properties with a setter can be initiated as keyword arguments. '__repr__' 'print' all the saved attributes and properties.; This is for the likes of `has_openmp`, I would make it a read only property. Anot",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1297
https://github.com/qutip/qutip/pull/1297:126,Performance,load,load,126,"**Description**; User-facing changes:; - Solver's `Options` defaults can be set `qutip.settings.options`.; - Add the `save`, `load`, `reset` method to Options.; - The default `Options` are read from ""qutiprc"" when loading qutip.; - Options object can be initiated from a saved configuration. Example:; ```; import qutip.setting as qset; from qutip.solver import Options; qset.options.atol = 1e-10; qset.options.max_step = 1; qset.save(); print(Options().atol); >>> 1e-10; ```; `atol = 1e-10` and `max_step = 1` will be kept as default in future sessions. `qset.options.reset` to go back to qutip's default. I believe that loading custom settings when importing qutip will be appreciated with support of both `dense` and `sparse` most researchers will have a preference depending on their domain. This also brings all settings in one place: `qutip.settings...` even if we split the code in ""core"", ""solver"", ""qip?"", etc. Lastly, creating and moving around an `Options` object is no longer needed, changing the default before using the solver has the same effect. . For developers:; Principally @jakelishman as I expect you to add settings for core. ; I went with an implementation similar to python `dataclass`. To add `core`'s settings to `qutip.settings` you would do ""; ```; from qutip.settings import QtOptionClass. @QtOptionClass(""core""); class CoreOptions:; basetype = ""Dense""; auto_tidyup = True; ...; ```; And it would create the `__init__`, `__repr__`, `save`, `load` and `reset` methods, and create the default instance as `qutip.settings.core`. All attributes that do not start with ""_"" and are one of `bool`, `str`, `int`, `float`, `complex` will be in tagged to be saved and loaded. Those are the only types available now, but other can be added if needed. In `__init__` all these + properties with a setter can be initiated as keyword arguments. '__repr__' 'print' all the saved attributes and properties.; This is for the likes of `has_openmp`, I would make it a read only property. Anot",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1297
https://github.com/qutip/qutip/pull/1297:214,Performance,load,loading,214,"**Description**; User-facing changes:; - Solver's `Options` defaults can be set `qutip.settings.options`.; - Add the `save`, `load`, `reset` method to Options.; - The default `Options` are read from ""qutiprc"" when loading qutip.; - Options object can be initiated from a saved configuration. Example:; ```; import qutip.setting as qset; from qutip.solver import Options; qset.options.atol = 1e-10; qset.options.max_step = 1; qset.save(); print(Options().atol); >>> 1e-10; ```; `atol = 1e-10` and `max_step = 1` will be kept as default in future sessions. `qset.options.reset` to go back to qutip's default. I believe that loading custom settings when importing qutip will be appreciated with support of both `dense` and `sparse` most researchers will have a preference depending on their domain. This also brings all settings in one place: `qutip.settings...` even if we split the code in ""core"", ""solver"", ""qip?"", etc. Lastly, creating and moving around an `Options` object is no longer needed, changing the default before using the solver has the same effect. . For developers:; Principally @jakelishman as I expect you to add settings for core. ; I went with an implementation similar to python `dataclass`. To add `core`'s settings to `qutip.settings` you would do ""; ```; from qutip.settings import QtOptionClass. @QtOptionClass(""core""); class CoreOptions:; basetype = ""Dense""; auto_tidyup = True; ...; ```; And it would create the `__init__`, `__repr__`, `save`, `load` and `reset` methods, and create the default instance as `qutip.settings.core`. All attributes that do not start with ""_"" and are one of `bool`, `str`, `int`, `float`, `complex` will be in tagged to be saved and loaded. Those are the only types available now, but other can be added if needed. In `__init__` all these + properties with a setter can be initiated as keyword arguments. '__repr__' 'print' all the saved attributes and properties.; This is for the likes of `has_openmp`, I would make it a read only property. Anot",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1297
https://github.com/qutip/qutip/pull/1297:622,Performance,load,loading,622,"**Description**; User-facing changes:; - Solver's `Options` defaults can be set `qutip.settings.options`.; - Add the `save`, `load`, `reset` method to Options.; - The default `Options` are read from ""qutiprc"" when loading qutip.; - Options object can be initiated from a saved configuration. Example:; ```; import qutip.setting as qset; from qutip.solver import Options; qset.options.atol = 1e-10; qset.options.max_step = 1; qset.save(); print(Options().atol); >>> 1e-10; ```; `atol = 1e-10` and `max_step = 1` will be kept as default in future sessions. `qset.options.reset` to go back to qutip's default. I believe that loading custom settings when importing qutip will be appreciated with support of both `dense` and `sparse` most researchers will have a preference depending on their domain. This also brings all settings in one place: `qutip.settings...` even if we split the code in ""core"", ""solver"", ""qip?"", etc. Lastly, creating and moving around an `Options` object is no longer needed, changing the default before using the solver has the same effect. . For developers:; Principally @jakelishman as I expect you to add settings for core. ; I went with an implementation similar to python `dataclass`. To add `core`'s settings to `qutip.settings` you would do ""; ```; from qutip.settings import QtOptionClass. @QtOptionClass(""core""); class CoreOptions:; basetype = ""Dense""; auto_tidyup = True; ...; ```; And it would create the `__init__`, `__repr__`, `save`, `load` and `reset` methods, and create the default instance as `qutip.settings.core`. All attributes that do not start with ""_"" and are one of `bool`, `str`, `int`, `float`, `complex` will be in tagged to be saved and loaded. Those are the only types available now, but other can be added if needed. In `__init__` all these + properties with a setter can be initiated as keyword arguments. '__repr__' 'print' all the saved attributes and properties.; This is for the likes of `has_openmp`, I would make it a read only property. Anot",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1297
https://github.com/qutip/qutip/pull/1297:1470,Performance,load,load,1470,"ax_step = 1; qset.save(); print(Options().atol); >>> 1e-10; ```; `atol = 1e-10` and `max_step = 1` will be kept as default in future sessions. `qset.options.reset` to go back to qutip's default. I believe that loading custom settings when importing qutip will be appreciated with support of both `dense` and `sparse` most researchers will have a preference depending on their domain. This also brings all settings in one place: `qutip.settings...` even if we split the code in ""core"", ""solver"", ""qip?"", etc. Lastly, creating and moving around an `Options` object is no longer needed, changing the default before using the solver has the same effect. . For developers:; Principally @jakelishman as I expect you to add settings for core. ; I went with an implementation similar to python `dataclass`. To add `core`'s settings to `qutip.settings` you would do ""; ```; from qutip.settings import QtOptionClass. @QtOptionClass(""core""); class CoreOptions:; basetype = ""Dense""; auto_tidyup = True; ...; ```; And it would create the `__init__`, `__repr__`, `save`, `load` and `reset` methods, and create the default instance as `qutip.settings.core`. All attributes that do not start with ""_"" and are one of `bool`, `str`, `int`, `float`, `complex` will be in tagged to be saved and loaded. Those are the only types available now, but other can be added if needed. In `__init__` all these + properties with a setter can be initiated as keyword arguments. '__repr__' 'print' all the saved attributes and properties.; This is for the likes of `has_openmp`, I would make it a read only property. Another way of doing this would have been to use a parent class and a ""register"" functions. I went with this one because the signature of `__init__` in help was cleaner. I have both implemented so if qip of control want to use the base without registering to `qutip.settings`, I can change the PR. (@ajgpitch, @BoxiLi ). Build on top of #1289. . **Changelog**; Solver options can be set in `qutip.settings.options`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1297
https://github.com/qutip/qutip/pull/1297:1687,Performance,load,loaded,1687,"ax_step = 1; qset.save(); print(Options().atol); >>> 1e-10; ```; `atol = 1e-10` and `max_step = 1` will be kept as default in future sessions. `qset.options.reset` to go back to qutip's default. I believe that loading custom settings when importing qutip will be appreciated with support of both `dense` and `sparse` most researchers will have a preference depending on their domain. This also brings all settings in one place: `qutip.settings...` even if we split the code in ""core"", ""solver"", ""qip?"", etc. Lastly, creating and moving around an `Options` object is no longer needed, changing the default before using the solver has the same effect. . For developers:; Principally @jakelishman as I expect you to add settings for core. ; I went with an implementation similar to python `dataclass`. To add `core`'s settings to `qutip.settings` you would do ""; ```; from qutip.settings import QtOptionClass. @QtOptionClass(""core""); class CoreOptions:; basetype = ""Dense""; auto_tidyup = True; ...; ```; And it would create the `__init__`, `__repr__`, `save`, `load` and `reset` methods, and create the default instance as `qutip.settings.core`. All attributes that do not start with ""_"" and are one of `bool`, `str`, `int`, `float`, `complex` will be in tagged to be saved and loaded. Those are the only types available now, but other can be added if needed. In `__init__` all these + properties with a setter can be initiated as keyword arguments. '__repr__' 'print' all the saved attributes and properties.; This is for the likes of `has_openmp`, I would make it a read only property. Another way of doing this would have been to use a parent class and a ""register"" functions. I went with this one because the signature of `__init__` in help was cleaner. I have both implemented so if qip of control want to use the base without registering to `qutip.settings`, I can change the PR. (@ajgpitch, @BoxiLi ). Build on top of #1289. . **Changelog**; Solver options can be set in `qutip.settings.options`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1297
https://github.com/qutip/qutip/pull/1298:646,Deployability,install,installed,646,"Scipy 1.5 changed the methods of performing the matrix multiplication to; avoid copying the `indptr` matrix multiple times. This is actually not an; issue at all for us, because we only allow int32 indices (so if the; indices were to upcast, we just throw and exception), but the underlying; private Cython call structure also changed, and our `fast_csr_matrix` was; a direct clone. We add try/catch blocks to switch on the correct types (the overhead; from a failed lookup is trivial compared to the matrix multiplication; time), because we have to support more than just the most recent version; of scipy. We could look up the version of scipy installed, but the; ""try it and see"" approach is more typical Python. This problem should be eliminated by the move to the new data types, as; we will stop relying on private scipy code. See: commit scipy/scipy@53fac7a",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1298
https://github.com/qutip/qutip/pull/1298:33,Performance,perform,performing,33,"Scipy 1.5 changed the methods of performing the matrix multiplication to; avoid copying the `indptr` matrix multiple times. This is actually not an; issue at all for us, because we only allow int32 indices (so if the; indices were to upcast, we just throw and exception), but the underlying; private Cython call structure also changed, and our `fast_csr_matrix` was; a direct clone. We add try/catch blocks to switch on the correct types (the overhead; from a failed lookup is trivial compared to the matrix multiplication; time), because we have to support more than just the most recent version; of scipy. We could look up the version of scipy installed, but the; ""try it and see"" approach is more typical Python. This problem should be eliminated by the move to the new data types, as; we will stop relying on private scipy code. See: commit scipy/scipy@53fac7a",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1298
https://github.com/qutip/qutip/pull/1298:74,Safety,avoid,avoid,74,"Scipy 1.5 changed the methods of performing the matrix multiplication to; avoid copying the `indptr` matrix multiple times. This is actually not an; issue at all for us, because we only allow int32 indices (so if the; indices were to upcast, we just throw and exception), but the underlying; private Cython call structure also changed, and our `fast_csr_matrix` was; a direct clone. We add try/catch blocks to switch on the correct types (the overhead; from a failed lookup is trivial compared to the matrix multiplication; time), because we have to support more than just the most recent version; of scipy. We could look up the version of scipy installed, but the; ""try it and see"" approach is more typical Python. This problem should be eliminated by the move to the new data types, as; we will stop relying on private scipy code. See: commit scipy/scipy@53fac7a",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1298
https://github.com/qutip/qutip/issues/1299:21,Availability,failure,failures,21,"This is causing test failures in all CI builds against scipy 1.5 currently. The other failing tests on scipy 1.5 are due to changes to the handling of `csr` matmul operations, which is fixed in patch #1298. As far as I can see, there is no way to recover the exact same behaviour as existed in scipy < 1.5 (there's optimisations of the `lwork` input to the LAPACK routine), and consequently we are not getting the exact same set of eigenvectors for problem dimensions > 32. This does not mean that `brtools` is suddenly doing something wrong. It just means that the test assumed we would have the exact same output as `scipy`, and we don't any more. . This is an annoying problem to fix, I think. Two possible methods:. 1. attempt to ""trick"" scipy into doing the same pre-1.5 behaviour. Possibly this would involve monkey-patching out the ability of `eigh` to optimise the `lwork` parameters (i.e. stubbing out `scipy.linalg.lapack._compute_lwork` to always return `lwork=18*nrows`, `lrwork=24*nrows` and `liwork=10*nrows` to match `qutip.cy.brtools.ZHEEVR`).; 2. do some linear algebra work to determine that the eigenvectors we have returned are equivalent to the ones scipy has returned. 2 is a better solution, but harder to implement, especially in the presence of degenerate or near-degenerate eigenvalues (of which there are likely a lot around 0). 1 is very unsatisfying, but might be enough. In general, this problem will hopefully be solved a bit more thoroughly when `brmesolve` is updated to use the new data layer types, and we standardise the calculation of eigenvalues and -vectors across QuTiP. Hopefully someone has a better idea than me? @Ericgig, @nonhermitian.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1299
https://github.com/qutip/qutip/issues/1299:247,Availability,recover,recover,247,"This is causing test failures in all CI builds against scipy 1.5 currently. The other failing tests on scipy 1.5 are due to changes to the handling of `csr` matmul operations, which is fixed in patch #1298. As far as I can see, there is no way to recover the exact same behaviour as existed in scipy < 1.5 (there's optimisations of the `lwork` input to the LAPACK routine), and consequently we are not getting the exact same set of eigenvectors for problem dimensions > 32. This does not mean that `brtools` is suddenly doing something wrong. It just means that the test assumed we would have the exact same output as `scipy`, and we don't any more. . This is an annoying problem to fix, I think. Two possible methods:. 1. attempt to ""trick"" scipy into doing the same pre-1.5 behaviour. Possibly this would involve monkey-patching out the ability of `eigh` to optimise the `lwork` parameters (i.e. stubbing out `scipy.linalg.lapack._compute_lwork` to always return `lwork=18*nrows`, `lrwork=24*nrows` and `liwork=10*nrows` to match `qutip.cy.brtools.ZHEEVR`).; 2. do some linear algebra work to determine that the eigenvectors we have returned are equivalent to the ones scipy has returned. 2 is a better solution, but harder to implement, especially in the presence of degenerate or near-degenerate eigenvalues (of which there are likely a lot around 0). 1 is very unsatisfying, but might be enough. In general, this problem will hopefully be solved a bit more thoroughly when `brmesolve` is updated to use the new data layer types, and we standardise the calculation of eigenvalues and -vectors across QuTiP. Hopefully someone has a better idea than me? @Ericgig, @nonhermitian.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1299
https://github.com/qutip/qutip/issues/1299:194,Deployability,patch,patch,194,"This is causing test failures in all CI builds against scipy 1.5 currently. The other failing tests on scipy 1.5 are due to changes to the handling of `csr` matmul operations, which is fixed in patch #1298. As far as I can see, there is no way to recover the exact same behaviour as existed in scipy < 1.5 (there's optimisations of the `lwork` input to the LAPACK routine), and consequently we are not getting the exact same set of eigenvectors for problem dimensions > 32. This does not mean that `brtools` is suddenly doing something wrong. It just means that the test assumed we would have the exact same output as `scipy`, and we don't any more. . This is an annoying problem to fix, I think. Two possible methods:. 1. attempt to ""trick"" scipy into doing the same pre-1.5 behaviour. Possibly this would involve monkey-patching out the ability of `eigh` to optimise the `lwork` parameters (i.e. stubbing out `scipy.linalg.lapack._compute_lwork` to always return `lwork=18*nrows`, `lrwork=24*nrows` and `liwork=10*nrows` to match `qutip.cy.brtools.ZHEEVR`).; 2. do some linear algebra work to determine that the eigenvectors we have returned are equivalent to the ones scipy has returned. 2 is a better solution, but harder to implement, especially in the presence of degenerate or near-degenerate eigenvalues (of which there are likely a lot around 0). 1 is very unsatisfying, but might be enough. In general, this problem will hopefully be solved a bit more thoroughly when `brmesolve` is updated to use the new data layer types, and we standardise the calculation of eigenvalues and -vectors across QuTiP. Hopefully someone has a better idea than me? @Ericgig, @nonhermitian.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1299
https://github.com/qutip/qutip/issues/1299:822,Deployability,patch,patching,822,"This is causing test failures in all CI builds against scipy 1.5 currently. The other failing tests on scipy 1.5 are due to changes to the handling of `csr` matmul operations, which is fixed in patch #1298. As far as I can see, there is no way to recover the exact same behaviour as existed in scipy < 1.5 (there's optimisations of the `lwork` input to the LAPACK routine), and consequently we are not getting the exact same set of eigenvectors for problem dimensions > 32. This does not mean that `brtools` is suddenly doing something wrong. It just means that the test assumed we would have the exact same output as `scipy`, and we don't any more. . This is an annoying problem to fix, I think. Two possible methods:. 1. attempt to ""trick"" scipy into doing the same pre-1.5 behaviour. Possibly this would involve monkey-patching out the ability of `eigh` to optimise the `lwork` parameters (i.e. stubbing out `scipy.linalg.lapack._compute_lwork` to always return `lwork=18*nrows`, `lrwork=24*nrows` and `liwork=10*nrows` to match `qutip.cy.brtools.ZHEEVR`).; 2. do some linear algebra work to determine that the eigenvectors we have returned are equivalent to the ones scipy has returned. 2 is a better solution, but harder to implement, especially in the presence of degenerate or near-degenerate eigenvalues (of which there are likely a lot around 0). 1 is very unsatisfying, but might be enough. In general, this problem will hopefully be solved a bit more thoroughly when `brmesolve` is updated to use the new data layer types, and we standardise the calculation of eigenvalues and -vectors across QuTiP. Hopefully someone has a better idea than me? @Ericgig, @nonhermitian.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1299
https://github.com/qutip/qutip/issues/1299:1493,Deployability,update,updated,1493,"This is causing test failures in all CI builds against scipy 1.5 currently. The other failing tests on scipy 1.5 are due to changes to the handling of `csr` matmul operations, which is fixed in patch #1298. As far as I can see, there is no way to recover the exact same behaviour as existed in scipy < 1.5 (there's optimisations of the `lwork` input to the LAPACK routine), and consequently we are not getting the exact same set of eigenvectors for problem dimensions > 32. This does not mean that `brtools` is suddenly doing something wrong. It just means that the test assumed we would have the exact same output as `scipy`, and we don't any more. . This is an annoying problem to fix, I think. Two possible methods:. 1. attempt to ""trick"" scipy into doing the same pre-1.5 behaviour. Possibly this would involve monkey-patching out the ability of `eigh` to optimise the `lwork` parameters (i.e. stubbing out `scipy.linalg.lapack._compute_lwork` to always return `lwork=18*nrows`, `lrwork=24*nrows` and `liwork=10*nrows` to match `qutip.cy.brtools.ZHEEVR`).; 2. do some linear algebra work to determine that the eigenvectors we have returned are equivalent to the ones scipy has returned. 2 is a better solution, but harder to implement, especially in the presence of degenerate or near-degenerate eigenvalues (of which there are likely a lot around 0). 1 is very unsatisfying, but might be enough. In general, this problem will hopefully be solved a bit more thoroughly when `brmesolve` is updated to use the new data layer types, and we standardise the calculation of eigenvalues and -vectors across QuTiP. Hopefully someone has a better idea than me? @Ericgig, @nonhermitian.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1299
https://github.com/qutip/qutip/issues/1299:364,Integrability,rout,routine,364,"This is causing test failures in all CI builds against scipy 1.5 currently. The other failing tests on scipy 1.5 are due to changes to the handling of `csr` matmul operations, which is fixed in patch #1298. As far as I can see, there is no way to recover the exact same behaviour as existed in scipy < 1.5 (there's optimisations of the `lwork` input to the LAPACK routine), and consequently we are not getting the exact same set of eigenvectors for problem dimensions > 32. This does not mean that `brtools` is suddenly doing something wrong. It just means that the test assumed we would have the exact same output as `scipy`, and we don't any more. . This is an annoying problem to fix, I think. Two possible methods:. 1. attempt to ""trick"" scipy into doing the same pre-1.5 behaviour. Possibly this would involve monkey-patching out the ability of `eigh` to optimise the `lwork` parameters (i.e. stubbing out `scipy.linalg.lapack._compute_lwork` to always return `lwork=18*nrows`, `lrwork=24*nrows` and `liwork=10*nrows` to match `qutip.cy.brtools.ZHEEVR`).; 2. do some linear algebra work to determine that the eigenvectors we have returned are equivalent to the ones scipy has returned. 2 is a better solution, but harder to implement, especially in the presence of degenerate or near-degenerate eigenvalues (of which there are likely a lot around 0). 1 is very unsatisfying, but might be enough. In general, this problem will hopefully be solved a bit more thoroughly when `brmesolve` is updated to use the new data layer types, and we standardise the calculation of eigenvalues and -vectors across QuTiP. Hopefully someone has a better idea than me? @Ericgig, @nonhermitian.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1299
https://github.com/qutip/qutip/issues/1299:247,Safety,recover,recover,247,"This is causing test failures in all CI builds against scipy 1.5 currently. The other failing tests on scipy 1.5 are due to changes to the handling of `csr` matmul operations, which is fixed in patch #1298. As far as I can see, there is no way to recover the exact same behaviour as existed in scipy < 1.5 (there's optimisations of the `lwork` input to the LAPACK routine), and consequently we are not getting the exact same set of eigenvectors for problem dimensions > 32. This does not mean that `brtools` is suddenly doing something wrong. It just means that the test assumed we would have the exact same output as `scipy`, and we don't any more. . This is an annoying problem to fix, I think. Two possible methods:. 1. attempt to ""trick"" scipy into doing the same pre-1.5 behaviour. Possibly this would involve monkey-patching out the ability of `eigh` to optimise the `lwork` parameters (i.e. stubbing out `scipy.linalg.lapack._compute_lwork` to always return `lwork=18*nrows`, `lrwork=24*nrows` and `liwork=10*nrows` to match `qutip.cy.brtools.ZHEEVR`).; 2. do some linear algebra work to determine that the eigenvectors we have returned are equivalent to the ones scipy has returned. 2 is a better solution, but harder to implement, especially in the presence of degenerate or near-degenerate eigenvalues (of which there are likely a lot around 0). 1 is very unsatisfying, but might be enough. In general, this problem will hopefully be solved a bit more thoroughly when `brmesolve` is updated to use the new data layer types, and we standardise the calculation of eigenvalues and -vectors across QuTiP. Hopefully someone has a better idea than me? @Ericgig, @nonhermitian.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1299
https://github.com/qutip/qutip/issues/1299:16,Testability,test,test,16,"This is causing test failures in all CI builds against scipy 1.5 currently. The other failing tests on scipy 1.5 are due to changes to the handling of `csr` matmul operations, which is fixed in patch #1298. As far as I can see, there is no way to recover the exact same behaviour as existed in scipy < 1.5 (there's optimisations of the `lwork` input to the LAPACK routine), and consequently we are not getting the exact same set of eigenvectors for problem dimensions > 32. This does not mean that `brtools` is suddenly doing something wrong. It just means that the test assumed we would have the exact same output as `scipy`, and we don't any more. . This is an annoying problem to fix, I think. Two possible methods:. 1. attempt to ""trick"" scipy into doing the same pre-1.5 behaviour. Possibly this would involve monkey-patching out the ability of `eigh` to optimise the `lwork` parameters (i.e. stubbing out `scipy.linalg.lapack._compute_lwork` to always return `lwork=18*nrows`, `lrwork=24*nrows` and `liwork=10*nrows` to match `qutip.cy.brtools.ZHEEVR`).; 2. do some linear algebra work to determine that the eigenvectors we have returned are equivalent to the ones scipy has returned. 2 is a better solution, but harder to implement, especially in the presence of degenerate or near-degenerate eigenvalues (of which there are likely a lot around 0). 1 is very unsatisfying, but might be enough. In general, this problem will hopefully be solved a bit more thoroughly when `brmesolve` is updated to use the new data layer types, and we standardise the calculation of eigenvalues and -vectors across QuTiP. Hopefully someone has a better idea than me? @Ericgig, @nonhermitian.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1299
https://github.com/qutip/qutip/issues/1299:94,Testability,test,tests,94,"This is causing test failures in all CI builds against scipy 1.5 currently. The other failing tests on scipy 1.5 are due to changes to the handling of `csr` matmul operations, which is fixed in patch #1298. As far as I can see, there is no way to recover the exact same behaviour as existed in scipy < 1.5 (there's optimisations of the `lwork` input to the LAPACK routine), and consequently we are not getting the exact same set of eigenvectors for problem dimensions > 32. This does not mean that `brtools` is suddenly doing something wrong. It just means that the test assumed we would have the exact same output as `scipy`, and we don't any more. . This is an annoying problem to fix, I think. Two possible methods:. 1. attempt to ""trick"" scipy into doing the same pre-1.5 behaviour. Possibly this would involve monkey-patching out the ability of `eigh` to optimise the `lwork` parameters (i.e. stubbing out `scipy.linalg.lapack._compute_lwork` to always return `lwork=18*nrows`, `lrwork=24*nrows` and `liwork=10*nrows` to match `qutip.cy.brtools.ZHEEVR`).; 2. do some linear algebra work to determine that the eigenvectors we have returned are equivalent to the ones scipy has returned. 2 is a better solution, but harder to implement, especially in the presence of degenerate or near-degenerate eigenvalues (of which there are likely a lot around 0). 1 is very unsatisfying, but might be enough. In general, this problem will hopefully be solved a bit more thoroughly when `brmesolve` is updated to use the new data layer types, and we standardise the calculation of eigenvalues and -vectors across QuTiP. Hopefully someone has a better idea than me? @Ericgig, @nonhermitian.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1299
https://github.com/qutip/qutip/issues/1299:566,Testability,test,test,566,"This is causing test failures in all CI builds against scipy 1.5 currently. The other failing tests on scipy 1.5 are due to changes to the handling of `csr` matmul operations, which is fixed in patch #1298. As far as I can see, there is no way to recover the exact same behaviour as existed in scipy < 1.5 (there's optimisations of the `lwork` input to the LAPACK routine), and consequently we are not getting the exact same set of eigenvectors for problem dimensions > 32. This does not mean that `brtools` is suddenly doing something wrong. It just means that the test assumed we would have the exact same output as `scipy`, and we don't any more. . This is an annoying problem to fix, I think. Two possible methods:. 1. attempt to ""trick"" scipy into doing the same pre-1.5 behaviour. Possibly this would involve monkey-patching out the ability of `eigh` to optimise the `lwork` parameters (i.e. stubbing out `scipy.linalg.lapack._compute_lwork` to always return `lwork=18*nrows`, `lrwork=24*nrows` and `liwork=10*nrows` to match `qutip.cy.brtools.ZHEEVR`).; 2. do some linear algebra work to determine that the eigenvectors we have returned are equivalent to the ones scipy has returned. 2 is a better solution, but harder to implement, especially in the presence of degenerate or near-degenerate eigenvalues (of which there are likely a lot around 0). 1 is very unsatisfying, but might be enough. In general, this problem will hopefully be solved a bit more thoroughly when `brmesolve` is updated to use the new data layer types, and we standardise the calculation of eigenvalues and -vectors across QuTiP. Hopefully someone has a better idea than me? @Ericgig, @nonhermitian.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1299
https://github.com/qutip/qutip/issues/1299:898,Testability,stub,stubbing,898,"This is causing test failures in all CI builds against scipy 1.5 currently. The other failing tests on scipy 1.5 are due to changes to the handling of `csr` matmul operations, which is fixed in patch #1298. As far as I can see, there is no way to recover the exact same behaviour as existed in scipy < 1.5 (there's optimisations of the `lwork` input to the LAPACK routine), and consequently we are not getting the exact same set of eigenvectors for problem dimensions > 32. This does not mean that `brtools` is suddenly doing something wrong. It just means that the test assumed we would have the exact same output as `scipy`, and we don't any more. . This is an annoying problem to fix, I think. Two possible methods:. 1. attempt to ""trick"" scipy into doing the same pre-1.5 behaviour. Possibly this would involve monkey-patching out the ability of `eigh` to optimise the `lwork` parameters (i.e. stubbing out `scipy.linalg.lapack._compute_lwork` to always return `lwork=18*nrows`, `lrwork=24*nrows` and `liwork=10*nrows` to match `qutip.cy.brtools.ZHEEVR`).; 2. do some linear algebra work to determine that the eigenvectors we have returned are equivalent to the ones scipy has returned. 2 is a better solution, but harder to implement, especially in the presence of degenerate or near-degenerate eigenvalues (of which there are likely a lot around 0). 1 is very unsatisfying, but might be enough. In general, this problem will hopefully be solved a bit more thoroughly when `brmesolve` is updated to use the new data layer types, and we standardise the calculation of eigenvalues and -vectors across QuTiP. Hopefully someone has a better idea than me? @Ericgig, @nonhermitian.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1299
https://github.com/qutip/qutip/pull/1300:35,Testability,test,test,35,"Temporarily disables the `brtools` test `test_zheevr` when using `scipy` version >= 1.5. See #1299 for more information and discussion. This does not _need_ to be merged if we solve the more general problem quickly, but will fix the problem in the interim if we need it. Build on top of #1298 just to show that taken together they ""fix"" all the tests.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1300
https://github.com/qutip/qutip/pull/1300:345,Testability,test,tests,345,"Temporarily disables the `brtools` test `test_zheevr` when using `scipy` version >= 1.5. See #1299 for more information and discussion. This does not _need_ to be merged if we solve the more general problem quickly, but will fix the problem in the interim if we need it. Build on top of #1298 just to show that taken together they ""fix"" all the tests.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1300
https://github.com/qutip/qutip/pull/1301:8,Testability,test,test,8,"The new test explicitly checks the eigenvalue equation for each generated eigenvalue/vector pair, and tests (via the determinant) that all eigenvectors are linearly independent, as they must be since they are eigenvectors of a Hermitian matrix. The previous test relied on the implementation of `zheevr` producing _exactly_ the same result as `scipy.linalg.eigh`, which was very fragile, and indeed broken by scipy 1.5. Fixes #1299.; Deprecates PR #1300, since this actually turned out to be a much easier fix than I had feared. Intermittent segfaults on Mac persist, unfortunately, so this still requires #1288.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1301
https://github.com/qutip/qutip/pull/1301:102,Testability,test,tests,102,"The new test explicitly checks the eigenvalue equation for each generated eigenvalue/vector pair, and tests (via the determinant) that all eigenvectors are linearly independent, as they must be since they are eigenvectors of a Hermitian matrix. The previous test relied on the implementation of `zheevr` producing _exactly_ the same result as `scipy.linalg.eigh`, which was very fragile, and indeed broken by scipy 1.5. Fixes #1299.; Deprecates PR #1300, since this actually turned out to be a much easier fix than I had feared. Intermittent segfaults on Mac persist, unfortunately, so this still requires #1288.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1301
https://github.com/qutip/qutip/pull/1301:258,Testability,test,test,258,"The new test explicitly checks the eigenvalue equation for each generated eigenvalue/vector pair, and tests (via the determinant) that all eigenvectors are linearly independent, as they must be since they are eigenvectors of a Hermitian matrix. The previous test relied on the implementation of `zheevr` producing _exactly_ the same result as `scipy.linalg.eigh`, which was very fragile, and indeed broken by scipy 1.5. Fixes #1299.; Deprecates PR #1300, since this actually turned out to be a much easier fix than I had feared. Intermittent segfaults on Mac persist, unfortunately, so this still requires #1288.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1301
https://github.com/qutip/qutip/pull/1302:502,Availability,avail,available,502,"There are ""breaking"" changes within the scipy private code which various parts of QuTiP depended on (see gh-1298, gh-1301 and commits 46e04a1, 6c85261 and 663d7d2). We ensure that at least one test on Travis uses a scipy version before 1.5 so that we always maintain support for it - the other tests will typically install scipy>=1.5. This particular test is chosen by elimination:; - we want the ""default"" case testing against the newest versions of Python to use the newest versions of the libraries available; - we want the Cython parts to be tested against both versions of scipy, since we link against their versions of LAPACK/BLAS.; - the Mac tests (at the time of writing) skip some tests which are problematic because of intermittent segfaults, including at least one which has issues with scipy 1.5. The MKL/OMP one skips some tests, but not any which use scipy.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1302
https://github.com/qutip/qutip/pull/1302:315,Deployability,install,install,315,"There are ""breaking"" changes within the scipy private code which various parts of QuTiP depended on (see gh-1298, gh-1301 and commits 46e04a1, 6c85261 and 663d7d2). We ensure that at least one test on Travis uses a scipy version before 1.5 so that we always maintain support for it - the other tests will typically install scipy>=1.5. This particular test is chosen by elimination:; - we want the ""default"" case testing against the newest versions of Python to use the newest versions of the libraries available; - we want the Cython parts to be tested against both versions of scipy, since we link against their versions of LAPACK/BLAS.; - the Mac tests (at the time of writing) skip some tests which are problematic because of intermittent segfaults, including at least one which has issues with scipy 1.5. The MKL/OMP one skips some tests, but not any which use scipy.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1302
https://github.com/qutip/qutip/pull/1302:88,Integrability,depend,depended,88,"There are ""breaking"" changes within the scipy private code which various parts of QuTiP depended on (see gh-1298, gh-1301 and commits 46e04a1, 6c85261 and 663d7d2). We ensure that at least one test on Travis uses a scipy version before 1.5 so that we always maintain support for it - the other tests will typically install scipy>=1.5. This particular test is chosen by elimination:; - we want the ""default"" case testing against the newest versions of Python to use the newest versions of the libraries available; - we want the Cython parts to be tested against both versions of scipy, since we link against their versions of LAPACK/BLAS.; - the Mac tests (at the time of writing) skip some tests which are problematic because of intermittent segfaults, including at least one which has issues with scipy 1.5. The MKL/OMP one skips some tests, but not any which use scipy.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1302
https://github.com/qutip/qutip/pull/1302:193,Testability,test,test,193,"There are ""breaking"" changes within the scipy private code which various parts of QuTiP depended on (see gh-1298, gh-1301 and commits 46e04a1, 6c85261 and 663d7d2). We ensure that at least one test on Travis uses a scipy version before 1.5 so that we always maintain support for it - the other tests will typically install scipy>=1.5. This particular test is chosen by elimination:; - we want the ""default"" case testing against the newest versions of Python to use the newest versions of the libraries available; - we want the Cython parts to be tested against both versions of scipy, since we link against their versions of LAPACK/BLAS.; - the Mac tests (at the time of writing) skip some tests which are problematic because of intermittent segfaults, including at least one which has issues with scipy 1.5. The MKL/OMP one skips some tests, but not any which use scipy.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1302
https://github.com/qutip/qutip/pull/1302:294,Testability,test,tests,294,"There are ""breaking"" changes within the scipy private code which various parts of QuTiP depended on (see gh-1298, gh-1301 and commits 46e04a1, 6c85261 and 663d7d2). We ensure that at least one test on Travis uses a scipy version before 1.5 so that we always maintain support for it - the other tests will typically install scipy>=1.5. This particular test is chosen by elimination:; - we want the ""default"" case testing against the newest versions of Python to use the newest versions of the libraries available; - we want the Cython parts to be tested against both versions of scipy, since we link against their versions of LAPACK/BLAS.; - the Mac tests (at the time of writing) skip some tests which are problematic because of intermittent segfaults, including at least one which has issues with scipy 1.5. The MKL/OMP one skips some tests, but not any which use scipy.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1302
https://github.com/qutip/qutip/pull/1302:351,Testability,test,test,351,"There are ""breaking"" changes within the scipy private code which various parts of QuTiP depended on (see gh-1298, gh-1301 and commits 46e04a1, 6c85261 and 663d7d2). We ensure that at least one test on Travis uses a scipy version before 1.5 so that we always maintain support for it - the other tests will typically install scipy>=1.5. This particular test is chosen by elimination:; - we want the ""default"" case testing against the newest versions of Python to use the newest versions of the libraries available; - we want the Cython parts to be tested against both versions of scipy, since we link against their versions of LAPACK/BLAS.; - the Mac tests (at the time of writing) skip some tests which are problematic because of intermittent segfaults, including at least one which has issues with scipy 1.5. The MKL/OMP one skips some tests, but not any which use scipy.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1302
https://github.com/qutip/qutip/pull/1302:412,Testability,test,testing,412,"There are ""breaking"" changes within the scipy private code which various parts of QuTiP depended on (see gh-1298, gh-1301 and commits 46e04a1, 6c85261 and 663d7d2). We ensure that at least one test on Travis uses a scipy version before 1.5 so that we always maintain support for it - the other tests will typically install scipy>=1.5. This particular test is chosen by elimination:; - we want the ""default"" case testing against the newest versions of Python to use the newest versions of the libraries available; - we want the Cython parts to be tested against both versions of scipy, since we link against their versions of LAPACK/BLAS.; - the Mac tests (at the time of writing) skip some tests which are problematic because of intermittent segfaults, including at least one which has issues with scipy 1.5. The MKL/OMP one skips some tests, but not any which use scipy.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1302
https://github.com/qutip/qutip/pull/1302:546,Testability,test,tested,546,"There are ""breaking"" changes within the scipy private code which various parts of QuTiP depended on (see gh-1298, gh-1301 and commits 46e04a1, 6c85261 and 663d7d2). We ensure that at least one test on Travis uses a scipy version before 1.5 so that we always maintain support for it - the other tests will typically install scipy>=1.5. This particular test is chosen by elimination:; - we want the ""default"" case testing against the newest versions of Python to use the newest versions of the libraries available; - we want the Cython parts to be tested against both versions of scipy, since we link against their versions of LAPACK/BLAS.; - the Mac tests (at the time of writing) skip some tests which are problematic because of intermittent segfaults, including at least one which has issues with scipy 1.5. The MKL/OMP one skips some tests, but not any which use scipy.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1302
https://github.com/qutip/qutip/pull/1302:649,Testability,test,tests,649,"There are ""breaking"" changes within the scipy private code which various parts of QuTiP depended on (see gh-1298, gh-1301 and commits 46e04a1, 6c85261 and 663d7d2). We ensure that at least one test on Travis uses a scipy version before 1.5 so that we always maintain support for it - the other tests will typically install scipy>=1.5. This particular test is chosen by elimination:; - we want the ""default"" case testing against the newest versions of Python to use the newest versions of the libraries available; - we want the Cython parts to be tested against both versions of scipy, since we link against their versions of LAPACK/BLAS.; - the Mac tests (at the time of writing) skip some tests which are problematic because of intermittent segfaults, including at least one which has issues with scipy 1.5. The MKL/OMP one skips some tests, but not any which use scipy.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1302
https://github.com/qutip/qutip/pull/1302:690,Testability,test,tests,690,"There are ""breaking"" changes within the scipy private code which various parts of QuTiP depended on (see gh-1298, gh-1301 and commits 46e04a1, 6c85261 and 663d7d2). We ensure that at least one test on Travis uses a scipy version before 1.5 so that we always maintain support for it - the other tests will typically install scipy>=1.5. This particular test is chosen by elimination:; - we want the ""default"" case testing against the newest versions of Python to use the newest versions of the libraries available; - we want the Cython parts to be tested against both versions of scipy, since we link against their versions of LAPACK/BLAS.; - the Mac tests (at the time of writing) skip some tests which are problematic because of intermittent segfaults, including at least one which has issues with scipy 1.5. The MKL/OMP one skips some tests, but not any which use scipy.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1302
https://github.com/qutip/qutip/pull/1302:836,Testability,test,tests,836,"There are ""breaking"" changes within the scipy private code which various parts of QuTiP depended on (see gh-1298, gh-1301 and commits 46e04a1, 6c85261 and 663d7d2). We ensure that at least one test on Travis uses a scipy version before 1.5 so that we always maintain support for it - the other tests will typically install scipy>=1.5. This particular test is chosen by elimination:; - we want the ""default"" case testing against the newest versions of Python to use the newest versions of the libraries available; - we want the Cython parts to be tested against both versions of scipy, since we link against their versions of LAPACK/BLAS.; - the Mac tests (at the time of writing) skip some tests which are problematic because of intermittent segfaults, including at least one which has issues with scipy 1.5. The MKL/OMP one skips some tests, but not any which use scipy.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1302
https://github.com/qutip/qutip/issues/1304:781,Availability,error,errors,781,"**Describe the bug**; AttributeError: module 'scipy.sparse._sparsetools' has no attribute 'csr_matmat_pass1' . **To Reproduce**; Install the latest version of scipy 1.5.0, install qutip, and run the tests. The following fail due to the AttributeError specified above:; - test_basis_transformation.py::test_transformations_from_qobj_and_direct_eigenbases_match[True-2-rand_bra]; - test_basis_transformation.py::test_transformations_from_qobj_and_direct_eigenbases_match[True-10-rand_bra]; - test_basis_transformation.py::test_transformations_from_qobj_and_direct_eigenbases_match[False-2-rand_bra]; - test_basis_transformation.py::test_transformations_from_qobj_and_direct_eigenbases_match[False-10-rand_bra]; - test_brtools.py::test_zheevr; I stopped running the tests after these errors appear, and I don't know if it causes other tests to fail as well.; The test_zheevr shows another error, but it fixes when using a previous version of scipy (e.g. 1.3). . The terminal out put is; ```; > fn = getattr(_sparsetools, self.format + '_matmat_pass1'); E AttributeError: module 'scipy.sparse._sparsetools' has no attribute 'csr_matmat_pass1'. /usr/local/lib/python3.6/dist-packages/qutip-4.5.0-py3.6-linux-x86_64.egg/qutip/fastsparse.py:197: AttributeError; ```. **Your Environment**; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.0; Numpy Version: 1.19.0; Scipy Version: 1.3.0 (error fixed); Scipy Version: 1.5.0 (error present); Cython Version: 0.29.20; Matplotlib Version: 3.2.2; Python Version: 3.6.9; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: Fal",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1304
https://github.com/qutip/qutip/issues/1304:886,Availability,error,error,886,"**Describe the bug**; AttributeError: module 'scipy.sparse._sparsetools' has no attribute 'csr_matmat_pass1' . **To Reproduce**; Install the latest version of scipy 1.5.0, install qutip, and run the tests. The following fail due to the AttributeError specified above:; - test_basis_transformation.py::test_transformations_from_qobj_and_direct_eigenbases_match[True-2-rand_bra]; - test_basis_transformation.py::test_transformations_from_qobj_and_direct_eigenbases_match[True-10-rand_bra]; - test_basis_transformation.py::test_transformations_from_qobj_and_direct_eigenbases_match[False-2-rand_bra]; - test_basis_transformation.py::test_transformations_from_qobj_and_direct_eigenbases_match[False-10-rand_bra]; - test_brtools.py::test_zheevr; I stopped running the tests after these errors appear, and I don't know if it causes other tests to fail as well.; The test_zheevr shows another error, but it fixes when using a previous version of scipy (e.g. 1.3). . The terminal out put is; ```; > fn = getattr(_sparsetools, self.format + '_matmat_pass1'); E AttributeError: module 'scipy.sparse._sparsetools' has no attribute 'csr_matmat_pass1'. /usr/local/lib/python3.6/dist-packages/qutip-4.5.0-py3.6-linux-x86_64.egg/qutip/fastsparse.py:197: AttributeError; ```. **Your Environment**; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.0; Numpy Version: 1.19.0; Scipy Version: 1.3.0 (error fixed); Scipy Version: 1.5.0 (error present); Cython Version: 0.29.20; Matplotlib Version: 3.2.2; Python Version: 3.6.9; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: Fal",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1304
https://github.com/qutip/qutip/issues/1304:1813,Availability,error,error,1813,"nd_direct_eigenbases_match[True-10-rand_bra]; - test_basis_transformation.py::test_transformations_from_qobj_and_direct_eigenbases_match[False-2-rand_bra]; - test_basis_transformation.py::test_transformations_from_qobj_and_direct_eigenbases_match[False-10-rand_bra]; - test_brtools.py::test_zheevr; I stopped running the tests after these errors appear, and I don't know if it causes other tests to fail as well.; The test_zheevr shows another error, but it fixes when using a previous version of scipy (e.g. 1.3). . The terminal out put is; ```; > fn = getattr(_sparsetools, self.format + '_matmat_pass1'); E AttributeError: module 'scipy.sparse._sparsetools' has no attribute 'csr_matmat_pass1'. /usr/local/lib/python3.6/dist-packages/qutip-4.5.0-py3.6-linux-x86_64.egg/qutip/fastsparse.py:197: AttributeError; ```. **Your Environment**; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.0; Numpy Version: 1.19.0; Scipy Version: 1.3.0 (error fixed); Scipy Version: 1.5.0 (error present); Cython Version: 0.29.20; Matplotlib Version: 3.2.2; Python Version: 3.6.9; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64); Installation path: /usr/local/lib/python3.6/dist-packages/qutip-4.5.0-py3.6-linux-x86_64.egg/qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1304
https://github.com/qutip/qutip/issues/1304:1849,Availability,error,error,1849,"nd_direct_eigenbases_match[True-10-rand_bra]; - test_basis_transformation.py::test_transformations_from_qobj_and_direct_eigenbases_match[False-2-rand_bra]; - test_basis_transformation.py::test_transformations_from_qobj_and_direct_eigenbases_match[False-10-rand_bra]; - test_brtools.py::test_zheevr; I stopped running the tests after these errors appear, and I don't know if it causes other tests to fail as well.; The test_zheevr shows another error, but it fixes when using a previous version of scipy (e.g. 1.3). . The terminal out put is; ```; > fn = getattr(_sparsetools, self.format + '_matmat_pass1'); E AttributeError: module 'scipy.sparse._sparsetools' has no attribute 'csr_matmat_pass1'. /usr/local/lib/python3.6/dist-packages/qutip-4.5.0-py3.6-linux-x86_64.egg/qutip/fastsparse.py:197: AttributeError; ```. **Your Environment**; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.0; Numpy Version: 1.19.0; Scipy Version: 1.3.0 (error fixed); Scipy Version: 1.5.0 (error present); Cython Version: 0.29.20; Matplotlib Version: 3.2.2; Python Version: 3.6.9; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64); Installation path: /usr/local/lib/python3.6/dist-packages/qutip-4.5.0-py3.6-linux-x86_64.egg/qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1304
https://github.com/qutip/qutip/issues/1304:129,Deployability,Install,Install,129,"**Describe the bug**; AttributeError: module 'scipy.sparse._sparsetools' has no attribute 'csr_matmat_pass1' . **To Reproduce**; Install the latest version of scipy 1.5.0, install qutip, and run the tests. The following fail due to the AttributeError specified above:; - test_basis_transformation.py::test_transformations_from_qobj_and_direct_eigenbases_match[True-2-rand_bra]; - test_basis_transformation.py::test_transformations_from_qobj_and_direct_eigenbases_match[True-10-rand_bra]; - test_basis_transformation.py::test_transformations_from_qobj_and_direct_eigenbases_match[False-2-rand_bra]; - test_basis_transformation.py::test_transformations_from_qobj_and_direct_eigenbases_match[False-10-rand_bra]; - test_brtools.py::test_zheevr; I stopped running the tests after these errors appear, and I don't know if it causes other tests to fail as well.; The test_zheevr shows another error, but it fixes when using a previous version of scipy (e.g. 1.3). . The terminal out put is; ```; > fn = getattr(_sparsetools, self.format + '_matmat_pass1'); E AttributeError: module 'scipy.sparse._sparsetools' has no attribute 'csr_matmat_pass1'. /usr/local/lib/python3.6/dist-packages/qutip-4.5.0-py3.6-linux-x86_64.egg/qutip/fastsparse.py:197: AttributeError; ```. **Your Environment**; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.0; Numpy Version: 1.19.0; Scipy Version: 1.3.0 (error fixed); Scipy Version: 1.5.0 (error present); Cython Version: 0.29.20; Matplotlib Version: 3.2.2; Python Version: 3.6.9; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: Fal",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1304
https://github.com/qutip/qutip/issues/1304:172,Deployability,install,install,172,"**Describe the bug**; AttributeError: module 'scipy.sparse._sparsetools' has no attribute 'csr_matmat_pass1' . **To Reproduce**; Install the latest version of scipy 1.5.0, install qutip, and run the tests. The following fail due to the AttributeError specified above:; - test_basis_transformation.py::test_transformations_from_qobj_and_direct_eigenbases_match[True-2-rand_bra]; - test_basis_transformation.py::test_transformations_from_qobj_and_direct_eigenbases_match[True-10-rand_bra]; - test_basis_transformation.py::test_transformations_from_qobj_and_direct_eigenbases_match[False-2-rand_bra]; - test_basis_transformation.py::test_transformations_from_qobj_and_direct_eigenbases_match[False-10-rand_bra]; - test_brtools.py::test_zheevr; I stopped running the tests after these errors appear, and I don't know if it causes other tests to fail as well.; The test_zheevr shows another error, but it fixes when using a previous version of scipy (e.g. 1.3). . The terminal out put is; ```; > fn = getattr(_sparsetools, self.format + '_matmat_pass1'); E AttributeError: module 'scipy.sparse._sparsetools' has no attribute 'csr_matmat_pass1'. /usr/local/lib/python3.6/dist-packages/qutip-4.5.0-py3.6-linux-x86_64.egg/qutip/fastsparse.py:197: AttributeError; ```. **Your Environment**; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.0; Numpy Version: 1.19.0; Scipy Version: 1.3.0 (error fixed); Scipy Version: 1.5.0 (error present); Cython Version: 0.29.20; Matplotlib Version: 3.2.2; Python Version: 3.6.9; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: Fal",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1304
https://github.com/qutip/qutip/issues/1304:1987,Deployability,Install,Installed,1987,"nd_direct_eigenbases_match[True-10-rand_bra]; - test_basis_transformation.py::test_transformations_from_qobj_and_direct_eigenbases_match[False-2-rand_bra]; - test_basis_transformation.py::test_transformations_from_qobj_and_direct_eigenbases_match[False-10-rand_bra]; - test_brtools.py::test_zheevr; I stopped running the tests after these errors appear, and I don't know if it causes other tests to fail as well.; The test_zheevr shows another error, but it fixes when using a previous version of scipy (e.g. 1.3). . The terminal out put is; ```; > fn = getattr(_sparsetools, self.format + '_matmat_pass1'); E AttributeError: module 'scipy.sparse._sparsetools' has no attribute 'csr_matmat_pass1'. /usr/local/lib/python3.6/dist-packages/qutip-4.5.0-py3.6-linux-x86_64.egg/qutip/fastsparse.py:197: AttributeError; ```. **Your Environment**; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.0; Numpy Version: 1.19.0; Scipy Version: 1.3.0 (error fixed); Scipy Version: 1.5.0 (error present); Cython Version: 0.29.20; Matplotlib Version: 3.2.2; Python Version: 3.6.9; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64); Installation path: /usr/local/lib/python3.6/dist-packages/qutip-4.5.0-py3.6-linux-x86_64.egg/qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1304
https://github.com/qutip/qutip/issues/1304:2058,Deployability,Install,Installation,2058,"nd_direct_eigenbases_match[True-10-rand_bra]; - test_basis_transformation.py::test_transformations_from_qobj_and_direct_eigenbases_match[False-2-rand_bra]; - test_basis_transformation.py::test_transformations_from_qobj_and_direct_eigenbases_match[False-10-rand_bra]; - test_brtools.py::test_zheevr; I stopped running the tests after these errors appear, and I don't know if it causes other tests to fail as well.; The test_zheevr shows another error, but it fixes when using a previous version of scipy (e.g. 1.3). . The terminal out put is; ```; > fn = getattr(_sparsetools, self.format + '_matmat_pass1'); E AttributeError: module 'scipy.sparse._sparsetools' has no attribute 'csr_matmat_pass1'. /usr/local/lib/python3.6/dist-packages/qutip-4.5.0-py3.6-linux-x86_64.egg/qutip/fastsparse.py:197: AttributeError; ```. **Your Environment**; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.0; Numpy Version: 1.19.0; Scipy Version: 1.3.0 (error fixed); Scipy Version: 1.5.0 (error present); Cython Version: 0.29.20; Matplotlib Version: 3.2.2; Python Version: 3.6.9; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64); Installation path: /usr/local/lib/python3.6/dist-packages/qutip-4.5.0-py3.6-linux-x86_64.egg/qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1304
https://github.com/qutip/qutip/issues/1304:199,Testability,test,tests,199,"**Describe the bug**; AttributeError: module 'scipy.sparse._sparsetools' has no attribute 'csr_matmat_pass1' . **To Reproduce**; Install the latest version of scipy 1.5.0, install qutip, and run the tests. The following fail due to the AttributeError specified above:; - test_basis_transformation.py::test_transformations_from_qobj_and_direct_eigenbases_match[True-2-rand_bra]; - test_basis_transformation.py::test_transformations_from_qobj_and_direct_eigenbases_match[True-10-rand_bra]; - test_basis_transformation.py::test_transformations_from_qobj_and_direct_eigenbases_match[False-2-rand_bra]; - test_basis_transformation.py::test_transformations_from_qobj_and_direct_eigenbases_match[False-10-rand_bra]; - test_brtools.py::test_zheevr; I stopped running the tests after these errors appear, and I don't know if it causes other tests to fail as well.; The test_zheevr shows another error, but it fixes when using a previous version of scipy (e.g. 1.3). . The terminal out put is; ```; > fn = getattr(_sparsetools, self.format + '_matmat_pass1'); E AttributeError: module 'scipy.sparse._sparsetools' has no attribute 'csr_matmat_pass1'. /usr/local/lib/python3.6/dist-packages/qutip-4.5.0-py3.6-linux-x86_64.egg/qutip/fastsparse.py:197: AttributeError; ```. **Your Environment**; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.0; Numpy Version: 1.19.0; Scipy Version: 1.3.0 (error fixed); Scipy Version: 1.5.0 (error present); Cython Version: 0.29.20; Matplotlib Version: 3.2.2; Python Version: 3.6.9; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: Fal",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1304
https://github.com/qutip/qutip/issues/1304:763,Testability,test,tests,763,"**Describe the bug**; AttributeError: module 'scipy.sparse._sparsetools' has no attribute 'csr_matmat_pass1' . **To Reproduce**; Install the latest version of scipy 1.5.0, install qutip, and run the tests. The following fail due to the AttributeError specified above:; - test_basis_transformation.py::test_transformations_from_qobj_and_direct_eigenbases_match[True-2-rand_bra]; - test_basis_transformation.py::test_transformations_from_qobj_and_direct_eigenbases_match[True-10-rand_bra]; - test_basis_transformation.py::test_transformations_from_qobj_and_direct_eigenbases_match[False-2-rand_bra]; - test_basis_transformation.py::test_transformations_from_qobj_and_direct_eigenbases_match[False-10-rand_bra]; - test_brtools.py::test_zheevr; I stopped running the tests after these errors appear, and I don't know if it causes other tests to fail as well.; The test_zheevr shows another error, but it fixes when using a previous version of scipy (e.g. 1.3). . The terminal out put is; ```; > fn = getattr(_sparsetools, self.format + '_matmat_pass1'); E AttributeError: module 'scipy.sparse._sparsetools' has no attribute 'csr_matmat_pass1'. /usr/local/lib/python3.6/dist-packages/qutip-4.5.0-py3.6-linux-x86_64.egg/qutip/fastsparse.py:197: AttributeError; ```. **Your Environment**; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.0; Numpy Version: 1.19.0; Scipy Version: 1.3.0 (error fixed); Scipy Version: 1.5.0 (error present); Cython Version: 0.29.20; Matplotlib Version: 3.2.2; Python Version: 3.6.9; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: Fal",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1304
https://github.com/qutip/qutip/issues/1304:832,Testability,test,tests,832,"**Describe the bug**; AttributeError: module 'scipy.sparse._sparsetools' has no attribute 'csr_matmat_pass1' . **To Reproduce**; Install the latest version of scipy 1.5.0, install qutip, and run the tests. The following fail due to the AttributeError specified above:; - test_basis_transformation.py::test_transformations_from_qobj_and_direct_eigenbases_match[True-2-rand_bra]; - test_basis_transformation.py::test_transformations_from_qobj_and_direct_eigenbases_match[True-10-rand_bra]; - test_basis_transformation.py::test_transformations_from_qobj_and_direct_eigenbases_match[False-2-rand_bra]; - test_basis_transformation.py::test_transformations_from_qobj_and_direct_eigenbases_match[False-10-rand_bra]; - test_brtools.py::test_zheevr; I stopped running the tests after these errors appear, and I don't know if it causes other tests to fail as well.; The test_zheevr shows another error, but it fixes when using a previous version of scipy (e.g. 1.3). . The terminal out put is; ```; > fn = getattr(_sparsetools, self.format + '_matmat_pass1'); E AttributeError: module 'scipy.sparse._sparsetools' has no attribute 'csr_matmat_pass1'. /usr/local/lib/python3.6/dist-packages/qutip-4.5.0-py3.6-linux-x86_64.egg/qutip/fastsparse.py:197: AttributeError; ```. **Your Environment**; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.0; Numpy Version: 1.19.0; Scipy Version: 1.3.0 (error fixed); Scipy Version: 1.5.0 (error present); Cython Version: 0.29.20; Matplotlib Version: 3.2.2; Python Version: 3.6.9; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: Fal",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1304
https://github.com/qutip/qutip/issues/1305:1158,Modifiability,variab,variables,1158,"Topic:. The `measure(state, ops)` and `measurement_statistics(state, ops)` functions in the measurement PR #1274 have different return types based on whether `ops` is a single observable or a list of POVMs. For e.g. the `measurement_statistics` returns; ; > eigenvalues: List of floats; The list of eigenvalues of the measurement operator.; eigenstates_or_projectors: List of Qobj; If the state was a ket, return the eigenstates of the measurement; operator. Otherwise return the projectors onto the eigenstates.; probabilities: List of floats; The probability of measuring the state as being in the; corresponding eigenstate (and the measurement result being; the corresponding eigenvalue). if `ops` is an observable and ; ; > collapsed_states : List of Qobjs; the collapsed states (density matrices) obtained after; measuring the qubits and obtaining the; qubit specified by the target in the state; specified by the index.; probabilities : List of floats; the probability of measuring a state in a the state; specified by the index. if `ops` is a list of POVMs/PVMs. Is there a good way to specify a numpy docstring for the function given that the return variables can vary !",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1305
https://github.com/qutip/qutip/pull/1306:1188,Integrability,depend,dependency,1188,"The bra--ket inner product had an unnecessary loop when looking up the row in the ket, where we already knew which element we needed to lookup. This function does not check the shapes of the inputs are valid and can therefore segfault on improper input, but it's a low-level Cython function, so that's expected behaviour. The previous version could segfault only in the ket--ket product, not the bra--ket product, but now it's both. This only affected `qutip.overlap` when neither input was a ket. Original timing:; ```python; In [1]: import qutip; ...: b, k = qutip.rand_ket(1000).dag(), qutip.rand_ket(1000); ...: %timeit b.overlap(k); 233 µs ± 214 ns per loop (mean ± std. dev. of 7 runs, 1000 loops each); ```; New timing:; ```python; In [1]: import qutip; ...: b, k = qutip.rand_ket(1000).dag(), qutip.rand_ket(1000); ...: %timeit b.overlap(k); 8.35 µs ± 47 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each); ```. Compare ket--ket timing (which is unchanged):; ```python; In [2]: k1, k2 = qutip.rand_ket(1000), qutip.rand_ket(1000); ...: %timeit k1.overlap(k2); 8.86 µs ± 119 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each); ```. **Changelog**; - Fix quadratic dependency affecting `Qobj.overlap` with bra inputs.; - Fix segfault in `Qobj.overlap` when passed `Qobj` of incompatible shapes.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1306
https://github.com/qutip/qutip/issues/1308:74,Integrability,depend,dependent,74,"I am trying to create an exponential of some operators multiplied by time-dependent functions. I am using the[ standard](http://qutip.org/docs/latest/guide/dynamics/dynamics-time.html) method to define the time-dependent operators. However, the expm method cannot exponentiate this list format. Is there another way to obtain the exponential of quantum operators multiplied by time-dependent coefficients in qutip?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1308
https://github.com/qutip/qutip/issues/1308:211,Integrability,depend,dependent,211,"I am trying to create an exponential of some operators multiplied by time-dependent functions. I am using the[ standard](http://qutip.org/docs/latest/guide/dynamics/dynamics-time.html) method to define the time-dependent operators. However, the expm method cannot exponentiate this list format. Is there another way to obtain the exponential of quantum operators multiplied by time-dependent coefficients in qutip?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1308
https://github.com/qutip/qutip/issues/1308:382,Integrability,depend,dependent,382,"I am trying to create an exponential of some operators multiplied by time-dependent functions. I am using the[ standard](http://qutip.org/docs/latest/guide/dynamics/dynamics-time.html) method to define the time-dependent operators. However, the expm method cannot exponentiate this list format. Is there another way to obtain the exponential of quantum operators multiplied by time-dependent coefficients in qutip?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1308
https://github.com/qutip/qutip/issues/1308:150,Usability,guid,guide,150,"I am trying to create an exponential of some operators multiplied by time-dependent functions. I am using the[ standard](http://qutip.org/docs/latest/guide/dynamics/dynamics-time.html) method to define the time-dependent operators. However, the expm method cannot exponentiate this list format. Is there another way to obtain the exponential of quantum operators multiplied by time-dependent coefficients in qutip?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1308
https://github.com/qutip/qutip/pull/1309:209,Deployability,install,installed,209,"**Description**; Add `pyproject.toml` to specify build-system as standardized in PEP 518. This enables building qutip in an emtpy environment i.e. without `setuptools`, `Cython`, `numpy` and `scipy` being pre-installed. If you have a new minimal debian install you sould be able to install this version with; ```; # apt-get install python3-pip; $ pip3 install $PATH_TO_QUTIP; ```; I only veryfied this in WSL so please test :). **Related issues or PRs**; This solves #1246 and #1174 and makes CI for packages that depend on qutip a lot easier. **Changelog**; Add `pyproject.toml` so qutip can be built without prerequisites",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1309
https://github.com/qutip/qutip/pull/1309:253,Deployability,install,install,253,"**Description**; Add `pyproject.toml` to specify build-system as standardized in PEP 518. This enables building qutip in an emtpy environment i.e. without `setuptools`, `Cython`, `numpy` and `scipy` being pre-installed. If you have a new minimal debian install you sould be able to install this version with; ```; # apt-get install python3-pip; $ pip3 install $PATH_TO_QUTIP; ```; I only veryfied this in WSL so please test :). **Related issues or PRs**; This solves #1246 and #1174 and makes CI for packages that depend on qutip a lot easier. **Changelog**; Add `pyproject.toml` so qutip can be built without prerequisites",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1309
https://github.com/qutip/qutip/pull/1309:282,Deployability,install,install,282,"**Description**; Add `pyproject.toml` to specify build-system as standardized in PEP 518. This enables building qutip in an emtpy environment i.e. without `setuptools`, `Cython`, `numpy` and `scipy` being pre-installed. If you have a new minimal debian install you sould be able to install this version with; ```; # apt-get install python3-pip; $ pip3 install $PATH_TO_QUTIP; ```; I only veryfied this in WSL so please test :). **Related issues or PRs**; This solves #1246 and #1174 and makes CI for packages that depend on qutip a lot easier. **Changelog**; Add `pyproject.toml` so qutip can be built without prerequisites",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1309
https://github.com/qutip/qutip/pull/1309:324,Deployability,install,install,324,"**Description**; Add `pyproject.toml` to specify build-system as standardized in PEP 518. This enables building qutip in an emtpy environment i.e. without `setuptools`, `Cython`, `numpy` and `scipy` being pre-installed. If you have a new minimal debian install you sould be able to install this version with; ```; # apt-get install python3-pip; $ pip3 install $PATH_TO_QUTIP; ```; I only veryfied this in WSL so please test :). **Related issues or PRs**; This solves #1246 and #1174 and makes CI for packages that depend on qutip a lot easier. **Changelog**; Add `pyproject.toml` so qutip can be built without prerequisites",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1309
https://github.com/qutip/qutip/pull/1309:352,Deployability,install,install,352,"**Description**; Add `pyproject.toml` to specify build-system as standardized in PEP 518. This enables building qutip in an emtpy environment i.e. without `setuptools`, `Cython`, `numpy` and `scipy` being pre-installed. If you have a new minimal debian install you sould be able to install this version with; ```; # apt-get install python3-pip; $ pip3 install $PATH_TO_QUTIP; ```; I only veryfied this in WSL so please test :). **Related issues or PRs**; This solves #1246 and #1174 and makes CI for packages that depend on qutip a lot easier. **Changelog**; Add `pyproject.toml` so qutip can be built without prerequisites",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1309
https://github.com/qutip/qutip/pull/1309:514,Integrability,depend,depend,514,"**Description**; Add `pyproject.toml` to specify build-system as standardized in PEP 518. This enables building qutip in an emtpy environment i.e. without `setuptools`, `Cython`, `numpy` and `scipy` being pre-installed. If you have a new minimal debian install you sould be able to install this version with; ```; # apt-get install python3-pip; $ pip3 install $PATH_TO_QUTIP; ```; I only veryfied this in WSL so please test :). **Related issues or PRs**; This solves #1246 and #1174 and makes CI for packages that depend on qutip a lot easier. **Changelog**; Add `pyproject.toml` so qutip can be built without prerequisites",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1309
https://github.com/qutip/qutip/pull/1309:419,Testability,test,test,419,"**Description**; Add `pyproject.toml` to specify build-system as standardized in PEP 518. This enables building qutip in an emtpy environment i.e. without `setuptools`, `Cython`, `numpy` and `scipy` being pre-installed. If you have a new minimal debian install you sould be able to install this version with; ```; # apt-get install python3-pip; $ pip3 install $PATH_TO_QUTIP; ```; I only veryfied this in WSL so please test :). **Related issues or PRs**; This solves #1246 and #1174 and makes CI for packages that depend on qutip a lot easier. **Changelog**; Add `pyproject.toml` so qutip can be built without prerequisites",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1309
https://github.com/qutip/qutip/pull/1310:842,Availability,error,errors,842,"**Description**; Upgrade from 4.5.1 to 4.5.2.; Include cherry picked commit from the following PR:. #1307 Fix zcsr_proj for bras with unsorted indices; #1306 Fix quadratic complexity in zcsr_inner; #1302 Enforce a CI test with scipy<1.5; #1301 Fix brtools zheevr test; #1298 Support scipy >= 1.5 in fast_csr_matrix matmul and legacy.ptrace; #1283 Milstein's heterodyne index fix; #1271 Remove duplicate line in setup.py; #1264 Remove incorrect use of 'is' in comparisons. Code from #1288 was added manually to evade conflict and related test were reinstalled. (removed in 4.5.1, not in master). #1269 and #1242 are not included since they depend on #1209 which is more that a bugfix and is not in 4.5.0. **Changelog**; Bug Fixes; -------; - `zcsr_proj` does not fail with unsorted indices (by **Jake Lishman**); - Fixed Milstein's heterodyne errors (by **Eric Giguère**); - Removed risky code (by **Jake Lishman**); <!-- - Fix `add_circuit` and `remove_gate` (by **Canoming**) -->. Improvements; -------; - Faster `zcsr_inner` (by **Jake Lishman**); - Support for Scipy 1.5 (by **Jake Lishman**)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1310
https://github.com/qutip/qutip/pull/1310:17,Deployability,Upgrade,Upgrade,17,"**Description**; Upgrade from 4.5.1 to 4.5.2.; Include cherry picked commit from the following PR:. #1307 Fix zcsr_proj for bras with unsorted indices; #1306 Fix quadratic complexity in zcsr_inner; #1302 Enforce a CI test with scipy<1.5; #1301 Fix brtools zheevr test; #1298 Support scipy >= 1.5 in fast_csr_matrix matmul and legacy.ptrace; #1283 Milstein's heterodyne index fix; #1271 Remove duplicate line in setup.py; #1264 Remove incorrect use of 'is' in comparisons. Code from #1288 was added manually to evade conflict and related test were reinstalled. (removed in 4.5.1, not in master). #1269 and #1242 are not included since they depend on #1209 which is more that a bugfix and is not in 4.5.0. **Changelog**; Bug Fixes; -------; - `zcsr_proj` does not fail with unsorted indices (by **Jake Lishman**); - Fixed Milstein's heterodyne errors (by **Eric Giguère**); - Removed risky code (by **Jake Lishman**); <!-- - Fix `add_circuit` and `remove_gate` (by **Canoming**) -->. Improvements; -------; - Faster `zcsr_inner` (by **Jake Lishman**); - Support for Scipy 1.5 (by **Jake Lishman**)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1310
https://github.com/qutip/qutip/pull/1310:639,Integrability,depend,depend,639,"**Description**; Upgrade from 4.5.1 to 4.5.2.; Include cherry picked commit from the following PR:. #1307 Fix zcsr_proj for bras with unsorted indices; #1306 Fix quadratic complexity in zcsr_inner; #1302 Enforce a CI test with scipy<1.5; #1301 Fix brtools zheevr test; #1298 Support scipy >= 1.5 in fast_csr_matrix matmul and legacy.ptrace; #1283 Milstein's heterodyne index fix; #1271 Remove duplicate line in setup.py; #1264 Remove incorrect use of 'is' in comparisons. Code from #1288 was added manually to evade conflict and related test were reinstalled. (removed in 4.5.1, not in master). #1269 and #1242 are not included since they depend on #1209 which is more that a bugfix and is not in 4.5.0. **Changelog**; Bug Fixes; -------; - `zcsr_proj` does not fail with unsorted indices (by **Jake Lishman**); - Fixed Milstein's heterodyne errors (by **Eric Giguère**); - Removed risky code (by **Jake Lishman**); <!-- - Fix `add_circuit` and `remove_gate` (by **Canoming**) -->. Improvements; -------; - Faster `zcsr_inner` (by **Jake Lishman**); - Support for Scipy 1.5 (by **Jake Lishman**)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1310
https://github.com/qutip/qutip/pull/1310:882,Safety,risk,risky,882,"**Description**; Upgrade from 4.5.1 to 4.5.2.; Include cherry picked commit from the following PR:. #1307 Fix zcsr_proj for bras with unsorted indices; #1306 Fix quadratic complexity in zcsr_inner; #1302 Enforce a CI test with scipy<1.5; #1301 Fix brtools zheevr test; #1298 Support scipy >= 1.5 in fast_csr_matrix matmul and legacy.ptrace; #1283 Milstein's heterodyne index fix; #1271 Remove duplicate line in setup.py; #1264 Remove incorrect use of 'is' in comparisons. Code from #1288 was added manually to evade conflict and related test were reinstalled. (removed in 4.5.1, not in master). #1269 and #1242 are not included since they depend on #1209 which is more that a bugfix and is not in 4.5.0. **Changelog**; Bug Fixes; -------; - `zcsr_proj` does not fail with unsorted indices (by **Jake Lishman**); - Fixed Milstein's heterodyne errors (by **Eric Giguère**); - Removed risky code (by **Jake Lishman**); <!-- - Fix `add_circuit` and `remove_gate` (by **Canoming**) -->. Improvements; -------; - Faster `zcsr_inner` (by **Jake Lishman**); - Support for Scipy 1.5 (by **Jake Lishman**)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1310
https://github.com/qutip/qutip/pull/1310:217,Testability,test,test,217,"**Description**; Upgrade from 4.5.1 to 4.5.2.; Include cherry picked commit from the following PR:. #1307 Fix zcsr_proj for bras with unsorted indices; #1306 Fix quadratic complexity in zcsr_inner; #1302 Enforce a CI test with scipy<1.5; #1301 Fix brtools zheevr test; #1298 Support scipy >= 1.5 in fast_csr_matrix matmul and legacy.ptrace; #1283 Milstein's heterodyne index fix; #1271 Remove duplicate line in setup.py; #1264 Remove incorrect use of 'is' in comparisons. Code from #1288 was added manually to evade conflict and related test were reinstalled. (removed in 4.5.1, not in master). #1269 and #1242 are not included since they depend on #1209 which is more that a bugfix and is not in 4.5.0. **Changelog**; Bug Fixes; -------; - `zcsr_proj` does not fail with unsorted indices (by **Jake Lishman**); - Fixed Milstein's heterodyne errors (by **Eric Giguère**); - Removed risky code (by **Jake Lishman**); <!-- - Fix `add_circuit` and `remove_gate` (by **Canoming**) -->. Improvements; -------; - Faster `zcsr_inner` (by **Jake Lishman**); - Support for Scipy 1.5 (by **Jake Lishman**)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1310
https://github.com/qutip/qutip/pull/1310:263,Testability,test,test,263,"**Description**; Upgrade from 4.5.1 to 4.5.2.; Include cherry picked commit from the following PR:. #1307 Fix zcsr_proj for bras with unsorted indices; #1306 Fix quadratic complexity in zcsr_inner; #1302 Enforce a CI test with scipy<1.5; #1301 Fix brtools zheevr test; #1298 Support scipy >= 1.5 in fast_csr_matrix matmul and legacy.ptrace; #1283 Milstein's heterodyne index fix; #1271 Remove duplicate line in setup.py; #1264 Remove incorrect use of 'is' in comparisons. Code from #1288 was added manually to evade conflict and related test were reinstalled. (removed in 4.5.1, not in master). #1269 and #1242 are not included since they depend on #1209 which is more that a bugfix and is not in 4.5.0. **Changelog**; Bug Fixes; -------; - `zcsr_proj` does not fail with unsorted indices (by **Jake Lishman**); - Fixed Milstein's heterodyne errors (by **Eric Giguère**); - Removed risky code (by **Jake Lishman**); <!-- - Fix `add_circuit` and `remove_gate` (by **Canoming**) -->. Improvements; -------; - Faster `zcsr_inner` (by **Jake Lishman**); - Support for Scipy 1.5 (by **Jake Lishman**)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1310
https://github.com/qutip/qutip/pull/1310:537,Testability,test,test,537,"**Description**; Upgrade from 4.5.1 to 4.5.2.; Include cherry picked commit from the following PR:. #1307 Fix zcsr_proj for bras with unsorted indices; #1306 Fix quadratic complexity in zcsr_inner; #1302 Enforce a CI test with scipy<1.5; #1301 Fix brtools zheevr test; #1298 Support scipy >= 1.5 in fast_csr_matrix matmul and legacy.ptrace; #1283 Milstein's heterodyne index fix; #1271 Remove duplicate line in setup.py; #1264 Remove incorrect use of 'is' in comparisons. Code from #1288 was added manually to evade conflict and related test were reinstalled. (removed in 4.5.1, not in master). #1269 and #1242 are not included since they depend on #1209 which is more that a bugfix and is not in 4.5.0. **Changelog**; Bug Fixes; -------; - `zcsr_proj` does not fail with unsorted indices (by **Jake Lishman**); - Fixed Milstein's heterodyne errors (by **Eric Giguère**); - Removed risky code (by **Jake Lishman**); <!-- - Fix `add_circuit` and `remove_gate` (by **Canoming**) -->. Improvements; -------; - Faster `zcsr_inner` (by **Jake Lishman**); - Support for Scipy 1.5 (by **Jake Lishman**)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1310
https://github.com/qutip/qutip/issues/1311:527,Availability,error,error,527,**Describe the bug**; `test_fileio` is failing on Windows because this use of `tempfile.NamedTemporaryFile` doesn't work on windows. The temporary files cannot be opened twice on Windows according to https://docs.python.org/3.8/library/tempfile.html#tempfile.NamedTemporaryFile.; https://github.com/qutip/qutip/blob/9e82f5b81955952833e25bb3eeff3fa24d36556b/qutip/tests/conftest.py#L194-L197; followed by; https://github.com/qutip/qutip/blob/9e82f5b81955952833e25bb3eeff3fa24d36556b/qutip/fileio.py#L70; results in a permission error. **To Reproduce**; Run `test_fileio.py` on windows. **Your Environment**; QuTiP Version: 4.6.0.dev0+6ad7f2b8; Numpy Version: 1.18.2; Scipy Version: 1.4.1; Cython Version: 0.29.20; Matplotlib Version: 3.2.1; Python Version: 3.7.2; Number of CPUs: 12; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64). Do you have any idea on a replacement @jakelishman ?,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1311
https://github.com/qutip/qutip/issues/1311:811,Deployability,Install,Installed,811,**Describe the bug**; `test_fileio` is failing on Windows because this use of `tempfile.NamedTemporaryFile` doesn't work on windows. The temporary files cannot be opened twice on Windows according to https://docs.python.org/3.8/library/tempfile.html#tempfile.NamedTemporaryFile.; https://github.com/qutip/qutip/blob/9e82f5b81955952833e25bb3eeff3fa24d36556b/qutip/tests/conftest.py#L194-L197; followed by; https://github.com/qutip/qutip/blob/9e82f5b81955952833e25bb3eeff3fa24d36556b/qutip/fileio.py#L70; results in a permission error. **To Reproduce**; Run `test_fileio.py` on windows. **Your Environment**; QuTiP Version: 4.6.0.dev0+6ad7f2b8; Numpy Version: 1.18.2; Scipy Version: 1.4.1; Cython Version: 0.29.20; Matplotlib Version: 3.2.1; Python Version: 3.7.2; Number of CPUs: 12; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64). Do you have any idea on a replacement @jakelishman ?,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1311
https://github.com/qutip/qutip/issues/1311:363,Testability,test,tests,363,**Describe the bug**; `test_fileio` is failing on Windows because this use of `tempfile.NamedTemporaryFile` doesn't work on windows. The temporary files cannot be opened twice on Windows according to https://docs.python.org/3.8/library/tempfile.html#tempfile.NamedTemporaryFile.; https://github.com/qutip/qutip/blob/9e82f5b81955952833e25bb3eeff3fa24d36556b/qutip/tests/conftest.py#L194-L197; followed by; https://github.com/qutip/qutip/blob/9e82f5b81955952833e25bb3eeff3fa24d36556b/qutip/fileio.py#L70; results in a permission error. **To Reproduce**; Run `test_fileio.py` on windows. **Your Environment**; QuTiP Version: 4.6.0.dev0+6ad7f2b8; Numpy Version: 1.18.2; Scipy Version: 1.4.1; Cython Version: 0.29.20; Matplotlib Version: 3.2.1; Python Version: 3.7.2; Number of CPUs: 12; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64). Do you have any idea on a replacement @jakelishman ?,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1311
https://github.com/qutip/qutip/pull/1312:232,Testability,test,tests,232,"Windows does not allow opening a tempfile.NamedTemporaryFile more than once, so it's not really suitable for a lot of uses. We just remove this fixture and use `in_temporary_directory` instead. Fix #1311 . **Changelog**; Fix fileio tests on Windows",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1312
https://github.com/qutip/qutip/pull/1313:345,Availability,error,error,345,"**Description**; `f16` does not exist on Windows. Use `np.longdouble` instead, which is `f16` on Mac/Linux and `f8` on Windows. On windows one gets; ```python; >>> np.dtype([('f', np.longdouble)]) ; dtype([('f', '<f8')]); ```; On Ubuntu; ```python; >>> np.dtype([('f', np.longdouble)]); dtype([('f', '<f16')]); ```. **Changelog**; fix the dtype error in the lattice module",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1313
https://github.com/qutip/qutip/pull/1314:121,Deployability,upgrade,upgrade,121,**Description**; Add the PR from @BoxiLi 's Lattice bug on windows. @jakelishman's #1312 is not be added since the tests upgrade to pytest are not in the release. (yet?). **Related issues or PRs**; apply #1313 to 4.5.2,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1314
https://github.com/qutip/qutip/pull/1314:154,Deployability,release,release,154,**Description**; Add the PR from @BoxiLi 's Lattice bug on windows. @jakelishman's #1312 is not be added since the tests upgrade to pytest are not in the release. (yet?). **Related issues or PRs**; apply #1313 to 4.5.2,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1314
https://github.com/qutip/qutip/pull/1314:115,Testability,test,tests,115,**Description**; Add the PR from @BoxiLi 's Lattice bug on windows. @jakelishman's #1312 is not be added since the tests upgrade to pytest are not in the release. (yet?). **Related issues or PRs**; apply #1313 to 4.5.2,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1314
https://github.com/qutip/qutip/pull/1315:284,Testability,Test,Tested,284,"**Description**; Added option to include colors to Bloch vectors and points instead of just cycling from a list . **Related issues or PRs**; fix #1292 . **Changelog**; Added an optional argument called colors for the Bloch.add_vectors, Bloch.add_points and Bloch.add_states method. ; Tested it here: https://github.com/rajathshetty20/misc/blob/master/qutip%20%231292.ipynb",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1315
https://github.com/qutip/qutip/pull/1316:69,Deployability,install,install,69,**Description**; Fail with a more descriptive message when trying to install from source without numpy. Hopefully will not be used with #1309. **Related issues or PRs**; Discussion in dev-core,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1316
https://github.com/qutip/qutip/pull/1316:46,Integrability,message,message,46,**Description**; Fail with a more descriptive message when trying to install from source without numpy. Hopefully will not be used with #1309. **Related issues or PRs**; Discussion in dev-core,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1316
https://github.com/qutip/qutip/pull/1317:38,Deployability,install,install,38,"**Description**; Add tools for easier install on pip with missing dependancies. **Related issues or PRs**; #1309, #1303, #1316",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1317
https://github.com/qutip/qutip/pull/1317:66,Integrability,depend,dependancies,66,"**Description**; Add tools for easier install on pip with missing dependancies. **Related issues or PRs**; #1309, #1303, #1316",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1317
https://github.com/qutip/qutip/pull/1318:615,Deployability,update,update,615,"**Checklist**; Thank you for contributing to QuTiP! Please make sure you have finished the following tasks before opening the PR. - [ ] Please read [Contributing to QuTiP Development](https://github.com/qutip/qutip-doc/blob/master/CONTRIBUTING.md); - [ ] Contributions to qutip should follow the [pep8 style](https://www.python.org/dev/peps/pep-0008/).; You can use [pycodestyle](http://pycodestyle.pycqa.org/en/latest/index.html) to check your code automatically; - [ ] Please add tests to cover your changes if applicable.; - [ ] If the behavior of the code has changed or new feature has been added, please also update the [documentation](https://github.com/qutip/qutip-doc) and the [notebook](https://github.com/qutip/qutip-notebooks). Feel free to ask if you are not sure. **Description**; This PR is supposed to address the OpenQASM output functionality. It introduces the class `QasmOutput` and the primary functions:. - `print_qasm(qc)` : prints the QASM output of `QubitCircuit`.; - `save_qasm(qc, file_loc)` : saves the QASM output of `QubitCircuit` to a file. Two [OpenQASM](https://github.com/Qiskit/openqasm) features are missing from this PR that might need to be addressed in a future PR, the possibility of exporting gates with classical control and exporting QuTiP's user-defined gates. . **Related issues or PRs**; This is a companion to PR #1291 and includes the code from it. **Changelog**; Added QASM output functions.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1318
https://github.com/qutip/qutip/pull/1318:482,Testability,test,tests,482,"**Checklist**; Thank you for contributing to QuTiP! Please make sure you have finished the following tasks before opening the PR. - [ ] Please read [Contributing to QuTiP Development](https://github.com/qutip/qutip-doc/blob/master/CONTRIBUTING.md); - [ ] Contributions to qutip should follow the [pep8 style](https://www.python.org/dev/peps/pep-0008/).; You can use [pycodestyle](http://pycodestyle.pycqa.org/en/latest/index.html) to check your code automatically; - [ ] Please add tests to cover your changes if applicable.; - [ ] If the behavior of the code has changed or new feature has been added, please also update the [documentation](https://github.com/qutip/qutip-doc) and the [notebook](https://github.com/qutip/qutip-notebooks). Feel free to ask if you are not sure. **Description**; This PR is supposed to address the OpenQASM output functionality. It introduces the class `QasmOutput` and the primary functions:. - `print_qasm(qc)` : prints the QASM output of `QubitCircuit`.; - `save_qasm(qc, file_loc)` : saves the QASM output of `QubitCircuit` to a file. Two [OpenQASM](https://github.com/Qiskit/openqasm) features are missing from this PR that might need to be addressed in a future PR, the possibility of exporting gates with classical control and exporting QuTiP's user-defined gates. . **Related issues or PRs**; This is a companion to PR #1291 and includes the code from it. **Changelog**; Added QASM output functions.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1318
https://github.com/qutip/qutip/issues/1320:1135,Integrability,contract,contracted,1135,"aces. I'm proposing one possible way to speed this up, while also gaining some additional safety and knowledge about mathematical operations on tensor-product spaces. The steps:; 1. rigourously define the ""grammar"" of `dims`, and allow all of `dimensions.py` to assume that this grammar is followed to speed up parsing; 2. maintain a private data structure type `dimensions._Parsed` inside `Qobj` which is constructed once, and keeps all details of the parsing so they need not be repeated. Determine `Qobj.type` from this data structure; 3. maintain knowledge of the individual `type` of every subspace in the full Hilbert space (e.g. with a list). There is still a ""global"" `Qobj.type`, but this can now be one in the set `{'bra', 'ket', 'oper', 'scalar', 'super', 'other'}`. `'other'` is for when the individual elements do not all match each other. Individual elements cannot be `'other'`. `'scalar'` is added to operations can keep track of tensor elements which have been contracted, say by a `bra-ket` product - operations will then broadcast scalar up to the correct dimensions on certain operations.; 4. dimension parsing is now sped up by using the operation-specific type knowledge. For example, `bra + bra -> bra`, and `ket.dag() -> bra`. Step 3 is necessary to allow matrix multiplication to work. These lookups could be done with enum values instead of string hashing. # Technical details. As of QuTiP 4.5 (and all previous versions), `Qobj` instantiation is slow and this permeates through to all operations on `Qobj`. Matrix multiplication, scalar multiplication, addition and so forth all need to instantiate new `Qobj` instances, and the time penalty for this is on the order of ~50µs per object. This results in more and more code than needs to bypass `Qobj` for speed, and in some cases (e.g. `qutip.control`) makes the use of `Qobj` prohibitively expensive. This obviously is not ideal, since `Qobj` is our primary data type. The majority of this time loss is due to inferring the",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1320
https://github.com/qutip/qutip/issues/1320:3629,Integrability,contract,contract,3629," the implicit promotion of scalars to operators in addition, taking over 500µs to execute `1 + qutip.qeye(2)`). A lot of this can be completely avoided, however, simply by instantiating the objects using _all_ known information, not relying on inference. In particular, various operations _know_ what the type of their outcome is by a simple lookup table: addition is only defined between operations of the same type and maintains that type, whereas the adjoint has the mapping; ```python; _ADJOINT_TYPE_LOOKUP = {; 'ket': 'bra',; 'bra': 'ket',; 'oper': 'oper',; 'super': 'super',; }; ```; If this information is supplied to `Qobj.__init__` (and the fact that it need not copy data we've created specially for it...), we can hugely slash the overhead of mathematical operations while maintaining their safety. The issues start to come once we look at matrix multiplication and tensor-product spaces. The tensor allows us to construct objects which are a mixture of several different types, and matrix multiplication wants to be able to contract scalar product spaces so that `bra * ket` gives a scalar. ## Problems with dimension handling. The current dimension handling in QuTiP is simple and intuitive until tensor-product structures are considered. At this point, it starts to become more complicated. In particular, the `type` of a `Qobj` is tied to its dimensions, but it becomes difficult to define this once there is tensor product structure. Some of this is because QuTiP allows us to construct objects which do not have a really rigourous mathematical backing to them, such as `I . |g>` - the tensor product of an operator and a ket. QuTiP assigns this a type `'oper'`, though the way it reaches this decision is more like:; 1. is it a ket? [no]; 2. is it a bra? [no]; 3. is it a super-operator? [no]; 4. if here, it must be an operator. Such objects do have a use. Let's say we have a system with two computational qubits and one ancillary qubit, we've performed a calculation on it and ende",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1320
https://github.com/qutip/qutip/issues/1320:8629,Integrability,contract,contract,8629,"we can sidestep some of these issues by improving library code which creates `Qobj` instances. Operations like `Qobj.__add__` already know exactly what the output dimensions are, what the the type must be, and other things like if Hermiticity has been preserved. We move away from the outdated style of; ```python; out = Qobj(); out.data = left.data + right.data; out.dims = left.dims; ...; ```; to one which passes _all_ the information in one go:; ```python; out = Qobj(left.data + right.data,; copy=False,; dims=left.dims,; type=left.type,; isherm=left._isherm and right._isherm); ```; This is more verbose, but significantly faster. With no other changes to the code, doing this can save around one-quarter of the overhead on several `Qobj` operations. Moving to the new data-layer types also gets large improvements in instantiation time. This is fine, except for matrix multiplication of tensor structures. In these, like in the example above, the matrix multiplication can cause tensor structures to contract, and so they then become incompatible with their previous Hilbert spaces. If we instead maintain a _list_ of `'type'` and introduce a `'scalar'` type, such objects can sensibly be broadcast back up to the correct size when needed, treating the spaces containing as identities of the correct dimension. I envisage that this may have some nice use-cases within `qip`, for example a gate on a single qubit could be represented by a two-by-two matrix with all other dimensions scalars, rather than requiring the whole Hilbert space to be represented all the time. Optimisations can be done using only the required elements of the subspace, and only broadcast up to the full representation once at the end. Further, we can ease the burden of parsing the dimensions in the first place. I haven't fully attempted this yet so I don't have full details on this, but I imagine there is some internal information we can keep after a single parsing pass that will make other operations simpler. Th",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1320
https://github.com/qutip/qutip/issues/1320:4556,Performance,perform,performed,4556,"a mixture of several different types, and matrix multiplication wants to be able to contract scalar product spaces so that `bra * ket` gives a scalar. ## Problems with dimension handling. The current dimension handling in QuTiP is simple and intuitive until tensor-product structures are considered. At this point, it starts to become more complicated. In particular, the `type` of a `Qobj` is tied to its dimensions, but it becomes difficult to define this once there is tensor product structure. Some of this is because QuTiP allows us to construct objects which do not have a really rigourous mathematical backing to them, such as `I . |g>` - the tensor product of an operator and a ket. QuTiP assigns this a type `'oper'`, though the way it reaches this decision is more like:; 1. is it a ket? [no]; 2. is it a bra? [no]; 3. is it a super-operator? [no]; 4. if here, it must be an operator. Such objects do have a use. Let's say we have a system with two computational qubits and one ancillary qubit, we've performed a calculation on it and ended up in some state `|x> = |a>.|b>.|c>`, and we want to extract the computational subspace when the ancilla bit is projected onto `|0>`. We can do this in a mathematically rigourous way with; ```python; >>> projector = qutip.tensor(qutip.qeye([2, 2]), qutip.basis(2, 0).proj()); >>> (projector * x).ptrace([0, 1]); Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; ...; ```; which will always return a density matrix. Alternatively, we can instead define the operator (note `proj()` to create `|g><g|` has become `dag()` to simply make `<g|`) as; ```python; >>> projector = qutip.tensor(qutip.qeye([2, 2]), qutip.basis(2, 0).dag()); >>> projector * x; Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; ...; ```; which gets us what we wanted. This is not necessarily _common_, but it is useful in some circumstances. ## Other problem discussions. There have been some cases of complaint about the han",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1320
https://github.com/qutip/qutip/issues/1320:247,Safety,safe,safety,247,"# Broad strokes. `Qobj` instantiation and mathematical operations have a large overhead, mostly because of handling the `dims` parameter in tensor-product spaces. I'm proposing one possible way to speed this up, while also gaining some additional safety and knowledge about mathematical operations on tensor-product spaces. The steps:; 1. rigourously define the ""grammar"" of `dims`, and allow all of `dimensions.py` to assume that this grammar is followed to speed up parsing; 2. maintain a private data structure type `dimensions._Parsed` inside `Qobj` which is constructed once, and keeps all details of the parsing so they need not be repeated. Determine `Qobj.type` from this data structure; 3. maintain knowledge of the individual `type` of every subspace in the full Hilbert space (e.g. with a list). There is still a ""global"" `Qobj.type`, but this can now be one in the set `{'bra', 'ket', 'oper', 'scalar', 'super', 'other'}`. `'other'` is for when the individual elements do not all match each other. Individual elements cannot be `'other'`. `'scalar'` is added to operations can keep track of tensor elements which have been contracted, say by a `bra-ket` product - operations will then broadcast scalar up to the correct dimensions on certain operations.; 4. dimension parsing is now sped up by using the operation-specific type knowledge. For example, `bra + bra -> bra`, and `ket.dag() -> bra`. Step 3 is necessary to allow matrix multiplication to work. These lookups could be done with enum values instead of string hashing. # Technical details. As of QuTiP 4.5 (and all previous versions), `Qobj` instantiation is slow and this permeates through to all operations on `Qobj`. Matrix multiplication, scalar multiplication, addition and so forth all need to instantiate new `Qobj` instances, and the time penalty for this is on the order of ~50µs per object. This results in more and more code than needs to bypass `Qobj` for speed, and in some cases (e.g. `qutip.control`) makes the use ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1320
https://github.com/qutip/qutip/issues/1320:2737,Safety,avoid,avoided,2737,"antiate new `Qobj` instances, and the time penalty for this is on the order of ~50µs per object. This results in more and more code than needs to bypass `Qobj` for speed, and in some cases (e.g. `qutip.control`) makes the use of `Qobj` prohibitively expensive. This obviously is not ideal, since `Qobj` is our primary data type. The majority of this time loss is due to inferring the type of an object from its dimensions, and on unnecessary copying of data at initialisation. This is exacerbated by operations often instantiating an `out` parameter as `out = Qobj()`, and then doing things like `out.dims = ...`, `out.data = ...`. This causes runtime checks to be done at every stage, so the penalty of initialisation can sometimes be paid several times over in simple operations (a particularly notable example is in the implicit promotion of scalars to operators in addition, taking over 500µs to execute `1 + qutip.qeye(2)`). A lot of this can be completely avoided, however, simply by instantiating the objects using _all_ known information, not relying on inference. In particular, various operations _know_ what the type of their outcome is by a simple lookup table: addition is only defined between operations of the same type and maintains that type, whereas the adjoint has the mapping; ```python; _ADJOINT_TYPE_LOOKUP = {; 'ket': 'bra',; 'bra': 'ket',; 'oper': 'oper',; 'super': 'super',; }; ```; If this information is supplied to `Qobj.__init__` (and the fact that it need not copy data we've created specially for it...), we can hugely slash the overhead of mathematical operations while maintaining their safety. The issues start to come once we look at matrix multiplication and tensor-product spaces. The tensor allows us to construct objects which are a mixture of several different types, and matrix multiplication wants to be able to contract scalar product spaces so that `bra * ket` gives a scalar. ## Problems with dimension handling. The current dimension handling in QuTiP is ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1320
https://github.com/qutip/qutip/issues/1320:3395,Safety,safe,safety,3395,"ing things like `out.dims = ...`, `out.data = ...`. This causes runtime checks to be done at every stage, so the penalty of initialisation can sometimes be paid several times over in simple operations (a particularly notable example is in the implicit promotion of scalars to operators in addition, taking over 500µs to execute `1 + qutip.qeye(2)`). A lot of this can be completely avoided, however, simply by instantiating the objects using _all_ known information, not relying on inference. In particular, various operations _know_ what the type of their outcome is by a simple lookup table: addition is only defined between operations of the same type and maintains that type, whereas the adjoint has the mapping; ```python; _ADJOINT_TYPE_LOOKUP = {; 'ket': 'bra',; 'bra': 'ket',; 'oper': 'oper',; 'super': 'super',; }; ```; If this information is supplied to `Qobj.__init__` (and the fact that it need not copy data we've created specially for it...), we can hugely slash the overhead of mathematical operations while maintaining their safety. The issues start to come once we look at matrix multiplication and tensor-product spaces. The tensor allows us to construct objects which are a mixture of several different types, and matrix multiplication wants to be able to contract scalar product spaces so that `bra * ket` gives a scalar. ## Problems with dimension handling. The current dimension handling in QuTiP is simple and intuitive until tensor-product structures are considered. At this point, it starts to become more complicated. In particular, the `type` of a `Qobj` is tied to its dimensions, but it becomes difficult to define this once there is tensor product structure. Some of this is because QuTiP allows us to construct objects which do not have a really rigourous mathematical backing to them, such as `I . |g>` - the tensor product of an operator and a ket. QuTiP assigns this a type `'oper'`, though the way it reaches this decision is more like:; 1. is it a ket? [no]; 2. is ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1320
https://github.com/qutip/qutip/issues/1320:1531,Security,hash,hashing,1531," structure type `dimensions._Parsed` inside `Qobj` which is constructed once, and keeps all details of the parsing so they need not be repeated. Determine `Qobj.type` from this data structure; 3. maintain knowledge of the individual `type` of every subspace in the full Hilbert space (e.g. with a list). There is still a ""global"" `Qobj.type`, but this can now be one in the set `{'bra', 'ket', 'oper', 'scalar', 'super', 'other'}`. `'other'` is for when the individual elements do not all match each other. Individual elements cannot be `'other'`. `'scalar'` is added to operations can keep track of tensor elements which have been contracted, say by a `bra-ket` product - operations will then broadcast scalar up to the correct dimensions on certain operations.; 4. dimension parsing is now sped up by using the operation-specific type knowledge. For example, `bra + bra -> bra`, and `ket.dag() -> bra`. Step 3 is necessary to allow matrix multiplication to work. These lookups could be done with enum values instead of string hashing. # Technical details. As of QuTiP 4.5 (and all previous versions), `Qobj` instantiation is slow and this permeates through to all operations on `Qobj`. Matrix multiplication, scalar multiplication, addition and so forth all need to instantiate new `Qobj` instances, and the time penalty for this is on the order of ~50µs per object. This results in more and more code than needs to bypass `Qobj` for speed, and in some cases (e.g. `qutip.control`) makes the use of `Qobj` prohibitively expensive. This obviously is not ideal, since `Qobj` is our primary data type. The majority of this time loss is due to inferring the type of an object from its dimensions, and on unnecessary copying of data at initialisation. This is exacerbated by operations often instantiating an `out` parameter as `out = Qobj()`, and then doing things like `out.dims = ...`, `out.data = ...`. This causes runtime checks to be done at every stage, so the penalty of initialisation can somet",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1320
https://github.com/qutip/qutip/issues/1320:2538,Usability,simpl,simple,2538,"l details. As of QuTiP 4.5 (and all previous versions), `Qobj` instantiation is slow and this permeates through to all operations on `Qobj`. Matrix multiplication, scalar multiplication, addition and so forth all need to instantiate new `Qobj` instances, and the time penalty for this is on the order of ~50µs per object. This results in more and more code than needs to bypass `Qobj` for speed, and in some cases (e.g. `qutip.control`) makes the use of `Qobj` prohibitively expensive. This obviously is not ideal, since `Qobj` is our primary data type. The majority of this time loss is due to inferring the type of an object from its dimensions, and on unnecessary copying of data at initialisation. This is exacerbated by operations often instantiating an `out` parameter as `out = Qobj()`, and then doing things like `out.dims = ...`, `out.data = ...`. This causes runtime checks to be done at every stage, so the penalty of initialisation can sometimes be paid several times over in simple operations (a particularly notable example is in the implicit promotion of scalars to operators in addition, taking over 500µs to execute `1 + qutip.qeye(2)`). A lot of this can be completely avoided, however, simply by instantiating the objects using _all_ known information, not relying on inference. In particular, various operations _know_ what the type of their outcome is by a simple lookup table: addition is only defined between operations of the same type and maintains that type, whereas the adjoint has the mapping; ```python; _ADJOINT_TYPE_LOOKUP = {; 'ket': 'bra',; 'bra': 'ket',; 'oper': 'oper',; 'super': 'super',; }; ```; If this information is supplied to `Qobj.__init__` (and the fact that it need not copy data we've created specially for it...), we can hugely slash the overhead of mathematical operations while maintaining their safety. The issues start to come once we look at matrix multiplication and tensor-product spaces. The tensor allows us to construct objects which are a mix",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1320
https://github.com/qutip/qutip/issues/1320:2755,Usability,simpl,simply,2755,"antiate new `Qobj` instances, and the time penalty for this is on the order of ~50µs per object. This results in more and more code than needs to bypass `Qobj` for speed, and in some cases (e.g. `qutip.control`) makes the use of `Qobj` prohibitively expensive. This obviously is not ideal, since `Qobj` is our primary data type. The majority of this time loss is due to inferring the type of an object from its dimensions, and on unnecessary copying of data at initialisation. This is exacerbated by operations often instantiating an `out` parameter as `out = Qobj()`, and then doing things like `out.dims = ...`, `out.data = ...`. This causes runtime checks to be done at every stage, so the penalty of initialisation can sometimes be paid several times over in simple operations (a particularly notable example is in the implicit promotion of scalars to operators in addition, taking over 500µs to execute `1 + qutip.qeye(2)`). A lot of this can be completely avoided, however, simply by instantiating the objects using _all_ known information, not relying on inference. In particular, various operations _know_ what the type of their outcome is by a simple lookup table: addition is only defined between operations of the same type and maintains that type, whereas the adjoint has the mapping; ```python; _ADJOINT_TYPE_LOOKUP = {; 'ket': 'bra',; 'bra': 'ket',; 'oper': 'oper',; 'super': 'super',; }; ```; If this information is supplied to `Qobj.__init__` (and the fact that it need not copy data we've created specially for it...), we can hugely slash the overhead of mathematical operations while maintaining their safety. The issues start to come once we look at matrix multiplication and tensor-product spaces. The tensor allows us to construct objects which are a mixture of several different types, and matrix multiplication wants to be able to contract scalar product spaces so that `bra * ket` gives a scalar. ## Problems with dimension handling. The current dimension handling in QuTiP is ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1320
https://github.com/qutip/qutip/issues/1320:2928,Usability,simpl,simple,2928," This obviously is not ideal, since `Qobj` is our primary data type. The majority of this time loss is due to inferring the type of an object from its dimensions, and on unnecessary copying of data at initialisation. This is exacerbated by operations often instantiating an `out` parameter as `out = Qobj()`, and then doing things like `out.dims = ...`, `out.data = ...`. This causes runtime checks to be done at every stage, so the penalty of initialisation can sometimes be paid several times over in simple operations (a particularly notable example is in the implicit promotion of scalars to operators in addition, taking over 500µs to execute `1 + qutip.qeye(2)`). A lot of this can be completely avoided, however, simply by instantiating the objects using _all_ known information, not relying on inference. In particular, various operations _know_ what the type of their outcome is by a simple lookup table: addition is only defined between operations of the same type and maintains that type, whereas the adjoint has the mapping; ```python; _ADJOINT_TYPE_LOOKUP = {; 'ket': 'bra',; 'bra': 'ket',; 'oper': 'oper',; 'super': 'super',; }; ```; If this information is supplied to `Qobj.__init__` (and the fact that it need not copy data we've created specially for it...), we can hugely slash the overhead of mathematical operations while maintaining their safety. The issues start to come once we look at matrix multiplication and tensor-product spaces. The tensor allows us to construct objects which are a mixture of several different types, and matrix multiplication wants to be able to contract scalar product spaces so that `bra * ket` gives a scalar. ## Problems with dimension handling. The current dimension handling in QuTiP is simple and intuitive until tensor-product structures are considered. At this point, it starts to become more complicated. In particular, the `type` of a `Qobj` is tied to its dimensions, but it becomes difficult to define this once there is tensor product stru",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1320
https://github.com/qutip/qutip/issues/1320:3776,Usability,simpl,simple,3776,"ts using _all_ known information, not relying on inference. In particular, various operations _know_ what the type of their outcome is by a simple lookup table: addition is only defined between operations of the same type and maintains that type, whereas the adjoint has the mapping; ```python; _ADJOINT_TYPE_LOOKUP = {; 'ket': 'bra',; 'bra': 'ket',; 'oper': 'oper',; 'super': 'super',; }; ```; If this information is supplied to `Qobj.__init__` (and the fact that it need not copy data we've created specially for it...), we can hugely slash the overhead of mathematical operations while maintaining their safety. The issues start to come once we look at matrix multiplication and tensor-product spaces. The tensor allows us to construct objects which are a mixture of several different types, and matrix multiplication wants to be able to contract scalar product spaces so that `bra * ket` gives a scalar. ## Problems with dimension handling. The current dimension handling in QuTiP is simple and intuitive until tensor-product structures are considered. At this point, it starts to become more complicated. In particular, the `type` of a `Qobj` is tied to its dimensions, but it becomes difficult to define this once there is tensor product structure. Some of this is because QuTiP allows us to construct objects which do not have a really rigourous mathematical backing to them, such as `I . |g>` - the tensor product of an operator and a ket. QuTiP assigns this a type `'oper'`, though the way it reaches this decision is more like:; 1. is it a ket? [no]; 2. is it a bra? [no]; 3. is it a super-operator? [no]; 4. if here, it must be an operator. Such objects do have a use. Let's say we have a system with two computational qubits and one ancillary qubit, we've performed a calculation on it and ended up in some state `|x> = |a>.|b>.|c>`, and we want to extract the computational subspace when the ancilla bit is projected onto `|0>`. We can do this in a mathematically rigourous way with; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1320
https://github.com/qutip/qutip/issues/1320:3787,Usability,intuit,intuitive,3787,"ts using _all_ known information, not relying on inference. In particular, various operations _know_ what the type of their outcome is by a simple lookup table: addition is only defined between operations of the same type and maintains that type, whereas the adjoint has the mapping; ```python; _ADJOINT_TYPE_LOOKUP = {; 'ket': 'bra',; 'bra': 'ket',; 'oper': 'oper',; 'super': 'super',; }; ```; If this information is supplied to `Qobj.__init__` (and the fact that it need not copy data we've created specially for it...), we can hugely slash the overhead of mathematical operations while maintaining their safety. The issues start to come once we look at matrix multiplication and tensor-product spaces. The tensor allows us to construct objects which are a mixture of several different types, and matrix multiplication wants to be able to contract scalar product spaces so that `bra * ket` gives a scalar. ## Problems with dimension handling. The current dimension handling in QuTiP is simple and intuitive until tensor-product structures are considered. At this point, it starts to become more complicated. In particular, the `type` of a `Qobj` is tied to its dimensions, but it becomes difficult to define this once there is tensor product structure. Some of this is because QuTiP allows us to construct objects which do not have a really rigourous mathematical backing to them, such as `I . |g>` - the tensor product of an operator and a ket. QuTiP assigns this a type `'oper'`, though the way it reaches this decision is more like:; 1. is it a ket? [no]; 2. is it a bra? [no]; 3. is it a super-operator? [no]; 4. if here, it must be an operator. Such objects do have a use. Let's say we have a system with two computational qubits and one ancillary qubit, we've performed a calculation on it and ended up in some state `|x> = |a>.|b>.|c>`, and we want to extract the computational subspace when the ancilla bit is projected onto `|0>`. We can do this in a mathematically rigourous way with; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1320
https://github.com/qutip/qutip/issues/1320:5152,Usability,simpl,simply,5152,"ally rigourous mathematical backing to them, such as `I . |g>` - the tensor product of an operator and a ket. QuTiP assigns this a type `'oper'`, though the way it reaches this decision is more like:; 1. is it a ket? [no]; 2. is it a bra? [no]; 3. is it a super-operator? [no]; 4. if here, it must be an operator. Such objects do have a use. Let's say we have a system with two computational qubits and one ancillary qubit, we've performed a calculation on it and ended up in some state `|x> = |a>.|b>.|c>`, and we want to extract the computational subspace when the ancilla bit is projected onto `|0>`. We can do this in a mathematically rigourous way with; ```python; >>> projector = qutip.tensor(qutip.qeye([2, 2]), qutip.basis(2, 0).proj()); >>> (projector * x).ptrace([0, 1]); Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; ...; ```; which will always return a density matrix. Alternatively, we can instead define the operator (note `proj()` to create `|g><g|` has become `dag()` to simply make `<g|`) as; ```python; >>> projector = qutip.tensor(qutip.qeye([2, 2]), qutip.basis(2, 0).dag()); >>> projector * x; Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; ...; ```; which gets us what we wanted. This is not necessarily _common_, but it is useful in some circumstances. ## Other problem discussions. There have been some cases of complaint about the handling of tensor-product spaces in QuTiP in the past (see [this discussion in the Google group](https://groups.google.com/forum/#!msg/qutip/NAGU4iKZNBY/NjqiFEkyDlkJ)), but these largely revolve around people not liking the idea that we enforce the tensor structure to be maintained at all. My reading of these issues is that some people would like to see `dims` removed, or make mathematical operations effectively ignore it. ## Solutions. ### Rejections. Personally, I think enforcing the tensor product structure catches a whole lot of potential issues in code when working with o",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1320
https://github.com/qutip/qutip/issues/1320:6782,Usability,Clear,Clearly,6782,"s is that some people would like to see `dims` removed, or make mathematical operations effectively ignore it. ## Solutions. ### Rejections. Personally, I think enforcing the tensor product structure catches a whole lot of potential issues in code when working with objects in different Hilbert spaces, and so far I've not actually seen any examples where I think frequent overriding of the `dims` is necessary. I'd argue that the `Qobj` constructor taking a `dims` parameter is sufficient for any use-case which needs to manually set the dimensions because they're passing in an object constructed outside of QuTiP functions. Removing `dims` also makes a lot of operations harder to do. Various places in the code permute the order of the tensored spaces, and dropping `dims` means that the user has to ""remember"" the tensor product structure themselves so that they can pass it in, and we can then know what to reorder. Clearly this is undesirable - the `dims` are a non-computable property of the object, and therefore should be carried around as a data attribute on the class. The alternative in the Google group that's sometimes suggested is to keep `dims` for these use-cases, but make it more of a suggestion, so that any two objects which satisfy `left.shape == right.shape` should be compatible for addition-like operations, and ones which satisfy `left.shape[1] == right.shape[0]` should be compatible for matrix-multiplication-like operations. Again, I personally would tend to reject this on the grounds that enforcing the tensor-product structure is respected is a core part of what `Qobj` does; it ensures that the operations are mathematically possible, and that operations between different Hilbert spaces are not mixed. ### Proposal. First off, we can sidestep some of these issues by improving library code which creates `Qobj` instances. Operations like `Qobj.__add__` already know exactly what the output dimensions are, what the the type must be, and other things like if Hermitic",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1320
https://github.com/qutip/qutip/issues/1320:9612,Usability,simpl,simpler,9612,"passes _all_ the information in one go:; ```python; out = Qobj(left.data + right.data,; copy=False,; dims=left.dims,; type=left.type,; isherm=left._isherm and right._isherm); ```; This is more verbose, but significantly faster. With no other changes to the code, doing this can save around one-quarter of the overhead on several `Qobj` operations. Moving to the new data-layer types also gets large improvements in instantiation time. This is fine, except for matrix multiplication of tensor structures. In these, like in the example above, the matrix multiplication can cause tensor structures to contract, and so they then become incompatible with their previous Hilbert spaces. If we instead maintain a _list_ of `'type'` and introduce a `'scalar'` type, such objects can sensibly be broadcast back up to the correct size when needed, treating the spaces containing as identities of the correct dimension. I envisage that this may have some nice use-cases within `qip`, for example a gate on a single qubit could be represented by a two-by-two matrix with all other dimensions scalars, rather than requiring the whole Hilbert space to be represented all the time. Optimisations can be done using only the required elements of the subspace, and only broadcast up to the full representation once at the end. Further, we can ease the burden of parsing the dimensions in the first place. I haven't fully attempted this yet so I don't have full details on this, but I imagine there is some internal information we can keep after a single parsing pass that will make other operations simpler. This is particularly true of super-operators, which often care about the input and output shapes of the spaces, necessitating several more calls to `np.prod`. Since this information _has_ to be computed at type-inference time, it's easy to save it and remove the overhead. I'd propose having this type be internal, something like `dimensions.Parsed` and storing it as a protected attribute on `Qobj` instances.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1320
https://github.com/qutip/qutip/issues/1321:367,Security,hash,hashable,367,"**Is your feature request related to a problem? Please describe.**; I would like to use a [``qutip.Qobj``](http://qutip.org/docs/latest/apidoc/classes.html#qobj) as a key for a [``functools.lru_cache``](https://docs.python.org/3/library/functools.html#functools.lru_cache), but since the [``qutip.Qobj``](http://qutip.org/docs/latest/apidoc/classes.html#qobj) is not hashable, I can't do this. **Describe the solution you'd like**; A clear and concise description of what you want to happen. I can implement ``qutip.Qobj.__hash__``, which would hash the dims and the data of the ``qutip.Qobj``. **Describe alternatives you've considered**; A clear and concise description of any alternative solutions or features you've considered. **Additional context**; Add any other context or screenshots about the feature request here.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1321
https://github.com/qutip/qutip/issues/1321:545,Security,hash,hash,545,"**Is your feature request related to a problem? Please describe.**; I would like to use a [``qutip.Qobj``](http://qutip.org/docs/latest/apidoc/classes.html#qobj) as a key for a [``functools.lru_cache``](https://docs.python.org/3/library/functools.html#functools.lru_cache), but since the [``qutip.Qobj``](http://qutip.org/docs/latest/apidoc/classes.html#qobj) is not hashable, I can't do this. **Describe the solution you'd like**; A clear and concise description of what you want to happen. I can implement ``qutip.Qobj.__hash__``, which would hash the dims and the data of the ``qutip.Qobj``. **Describe alternatives you've considered**; A clear and concise description of any alternative solutions or features you've considered. **Additional context**; Add any other context or screenshots about the feature request here.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1321
https://github.com/qutip/qutip/issues/1321:434,Usability,clear,clear,434,"**Is your feature request related to a problem? Please describe.**; I would like to use a [``qutip.Qobj``](http://qutip.org/docs/latest/apidoc/classes.html#qobj) as a key for a [``functools.lru_cache``](https://docs.python.org/3/library/functools.html#functools.lru_cache), but since the [``qutip.Qobj``](http://qutip.org/docs/latest/apidoc/classes.html#qobj) is not hashable, I can't do this. **Describe the solution you'd like**; A clear and concise description of what you want to happen. I can implement ``qutip.Qobj.__hash__``, which would hash the dims and the data of the ``qutip.Qobj``. **Describe alternatives you've considered**; A clear and concise description of any alternative solutions or features you've considered. **Additional context**; Add any other context or screenshots about the feature request here.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1321
https://github.com/qutip/qutip/issues/1321:642,Usability,clear,clear,642,"**Is your feature request related to a problem? Please describe.**; I would like to use a [``qutip.Qobj``](http://qutip.org/docs/latest/apidoc/classes.html#qobj) as a key for a [``functools.lru_cache``](https://docs.python.org/3/library/functools.html#functools.lru_cache), but since the [``qutip.Qobj``](http://qutip.org/docs/latest/apidoc/classes.html#qobj) is not hashable, I can't do this. **Describe the solution you'd like**; A clear and concise description of what you want to happen. I can implement ``qutip.Qobj.__hash__``, which would hash the dims and the data of the ``qutip.Qobj``. **Describe alternatives you've considered**; A clear and concise description of any alternative solutions or features you've considered. **Additional context**; Add any other context or screenshots about the feature request here.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1321
https://github.com/qutip/qutip/pull/1324:29,Deployability,release,release,29,"**Description**; For the new release, lattice support in lattice should be moved to it's own module.; This is removing these files from the next major version of qutip.; https://github.com/qutip/qutip-lattice replacing them and ready for a v0.1.0 release.; * The documentation is still inside qutip's documentation. @sbisw002 do you want to be a contributor on qutip/qutip-lattice, your commit history is lost by the move. @nathanshammah, I set the _authors_ of the new repository as Saumya, you, me and Clement, and I kept the same support (numfocus and unitaryfund). Are you fine with that?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1324
https://github.com/qutip/qutip/pull/1324:247,Deployability,release,release,247,"**Description**; For the new release, lattice support in lattice should be moved to it's own module.; This is removing these files from the next major version of qutip.; https://github.com/qutip/qutip-lattice replacing them and ready for a v0.1.0 release.; * The documentation is still inside qutip's documentation. @sbisw002 do you want to be a contributor on qutip/qutip-lattice, your commit history is lost by the move. @nathanshammah, I set the _authors_ of the new repository as Saumya, you, me and Clement, and I kept the same support (numfocus and unitaryfund). Are you fine with that?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1324
https://github.com/qutip/qutip/issues/1326:223,Availability,error,error,223,"https://github.com/qutip/qutip/blob/8244c7465a9567059574b883dc53838c6d5b7bf4/qutip/qobjevo_codegen.py#L64-L84. I am trying to use propagator in a for loop but after going through the loop 2-3 times, I get the the exception error (line 83). To make it run again I would have to restart the kernel which again would start giving me the same exception after iterating through the loop 2-3 times.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1326
https://github.com/qutip/qutip/pull/1328:214,Availability,down,down,214,"Not a complete switch-over to `CSR` from `fast_csr_matrix`, but this goes a really long way to achieving that. `Qobj` is done completely, but `QobjEvo` is pretty difficult to disentangle, and that really slowed me down a lot, and I'm not at all sure I've got it right there yet. OpenMP is ignored for now as low-priority. We'll need to get it working before a QuTiP 5.0 release, but I'm not working on it at the moment. `CQobjEvo` has been absolutely stripped bare. All its variants are gone, since the data layer types will handle this instead. `QobjEvo` is basically managed by shim at the moment, and needs a huge tidy up to bring it up to speed with the new data layer, and keep it maintainable. The data layer types have been taught to pickle themselves safely and automatically, and so consequently `QobjEvo` is magically pickle-able (aside from the OpenMP types). This PR includes all the commits from #1296 as well, but it's still a pretty giant PR as it stands right now. The tests won't pass yet, because I haven't finished converting everything.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1328
https://github.com/qutip/qutip/pull/1328:370,Deployability,release,release,370,"Not a complete switch-over to `CSR` from `fast_csr_matrix`, but this goes a really long way to achieving that. `Qobj` is done completely, but `QobjEvo` is pretty difficult to disentangle, and that really slowed me down a lot, and I'm not at all sure I've got it right there yet. OpenMP is ignored for now as low-priority. We'll need to get it working before a QuTiP 5.0 release, but I'm not working on it at the moment. `CQobjEvo` has been absolutely stripped bare. All its variants are gone, since the data layer types will handle this instead. `QobjEvo` is basically managed by shim at the moment, and needs a huge tidy up to bring it up to speed with the new data layer, and keep it maintainable. The data layer types have been taught to pickle themselves safely and automatically, and so consequently `QobjEvo` is magically pickle-able (aside from the OpenMP types). This PR includes all the commits from #1296 as well, but it's still a pretty giant PR as it stands right now. The tests won't pass yet, because I haven't finished converting everything.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1328
https://github.com/qutip/qutip/pull/1328:686,Modifiability,maintainab,maintainable,686,"Not a complete switch-over to `CSR` from `fast_csr_matrix`, but this goes a really long way to achieving that. `Qobj` is done completely, but `QobjEvo` is pretty difficult to disentangle, and that really slowed me down a lot, and I'm not at all sure I've got it right there yet. OpenMP is ignored for now as low-priority. We'll need to get it working before a QuTiP 5.0 release, but I'm not working on it at the moment. `CQobjEvo` has been absolutely stripped bare. All its variants are gone, since the data layer types will handle this instead. `QobjEvo` is basically managed by shim at the moment, and needs a huge tidy up to bring it up to speed with the new data layer, and keep it maintainable. The data layer types have been taught to pickle themselves safely and automatically, and so consequently `QobjEvo` is magically pickle-able (aside from the OpenMP types). This PR includes all the commits from #1296 as well, but it's still a pretty giant PR as it stands right now. The tests won't pass yet, because I haven't finished converting everything.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1328
https://github.com/qutip/qutip/pull/1328:759,Safety,safe,safely,759,"Not a complete switch-over to `CSR` from `fast_csr_matrix`, but this goes a really long way to achieving that. `Qobj` is done completely, but `QobjEvo` is pretty difficult to disentangle, and that really slowed me down a lot, and I'm not at all sure I've got it right there yet. OpenMP is ignored for now as low-priority. We'll need to get it working before a QuTiP 5.0 release, but I'm not working on it at the moment. `CQobjEvo` has been absolutely stripped bare. All its variants are gone, since the data layer types will handle this instead. `QobjEvo` is basically managed by shim at the moment, and needs a huge tidy up to bring it up to speed with the new data layer, and keep it maintainable. The data layer types have been taught to pickle themselves safely and automatically, and so consequently `QobjEvo` is magically pickle-able (aside from the OpenMP types). This PR includes all the commits from #1296 as well, but it's still a pretty giant PR as it stands right now. The tests won't pass yet, because I haven't finished converting everything.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1328
https://github.com/qutip/qutip/pull/1328:985,Testability,test,tests,985,"Not a complete switch-over to `CSR` from `fast_csr_matrix`, but this goes a really long way to achieving that. `Qobj` is done completely, but `QobjEvo` is pretty difficult to disentangle, and that really slowed me down a lot, and I'm not at all sure I've got it right there yet. OpenMP is ignored for now as low-priority. We'll need to get it working before a QuTiP 5.0 release, but I'm not working on it at the moment. `CQobjEvo` has been absolutely stripped bare. All its variants are gone, since the data layer types will handle this instead. `QobjEvo` is basically managed by shim at the moment, and needs a huge tidy up to bring it up to speed with the new data layer, and keep it maintainable. The data layer types have been taught to pickle themselves safely and automatically, and so consequently `QobjEvo` is magically pickle-able (aside from the OpenMP types). This PR includes all the commits from #1296 as well, but it's still a pretty giant PR as it stands right now. The tests won't pass yet, because I haven't finished converting everything.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1328
https://github.com/qutip/qutip/issues/1330:122,Availability,error,error,122,"**Describe the bug**; When applying `resolve_gates()` method to `QubitCircuit` containing the FREDKIN gate, the following error is produced: . ValueError: Gate RY requires one target. **To Reproduce**. ```python; from qutip.qip.circuit import QubitCircuit; A = QubitCircuit(3); A.add_gate(""FREDKIN"", targets=[0, 1], controls=[2]); A.resolve_gates(); ```. It might be a good idea to check this for other gates as well as look into the internal of `resolve_gates` to clean/modify it a bit. . Note: As requested by @BoxiLi, first mentioned by me in #1318",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1330
https://github.com/qutip/qutip/pull/1331:615,Deployability,update,update,615,"**Checklist**; Thank you for contributing to QuTiP! Please make sure you have finished the following tasks before opening the PR. - [x] Please read [Contributing to QuTiP Development](https://github.com/qutip/qutip-doc/blob/master/CONTRIBUTING.md); - [x] Contributions to qutip should follow the [pep8 style](https://www.python.org/dev/peps/pep-0008/).; You can use [pycodestyle](http://pycodestyle.pycqa.org/en/latest/index.html) to check your code automatically; - [x] Please add tests to cover your changes if applicable.; - [x] If the behavior of the code has changed or new feature has been added, please also update the [documentation](https://github.com/qutip/qutip-doc) and the [notebook](https://github.com/qutip/qutip-notebooks). Feel free to ask if you are not sure. **Description**; There are three major parts to this PR (more or less interlinked): . - Adds `Simulator` class to abstract away circuit run functionality. This enables future contributors to add to exact simulation (and potentially other ways of simulation) easily. It also has a `step` function which allows to go over the circuit step-by-step which could enable interesting visualisations.; - Adds `Result` class as a wrapper around results obtained from circuit simulations. ; - Adds a more efficient mode to `gate_sequence_product` function which allows for faster pre-computation of unitaries. **Changelog**; Added `Simulator`, `Result` class ; Added new mode to `gate_sequence_product`, `QubitCircuit.propagators`",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1331
https://github.com/qutip/qutip/pull/1331:1272,Energy Efficiency,efficient,efficient,1272,"**Checklist**; Thank you for contributing to QuTiP! Please make sure you have finished the following tasks before opening the PR. - [x] Please read [Contributing to QuTiP Development](https://github.com/qutip/qutip-doc/blob/master/CONTRIBUTING.md); - [x] Contributions to qutip should follow the [pep8 style](https://www.python.org/dev/peps/pep-0008/).; You can use [pycodestyle](http://pycodestyle.pycqa.org/en/latest/index.html) to check your code automatically; - [x] Please add tests to cover your changes if applicable.; - [x] If the behavior of the code has changed or new feature has been added, please also update the [documentation](https://github.com/qutip/qutip-doc) and the [notebook](https://github.com/qutip/qutip-notebooks). Feel free to ask if you are not sure. **Description**; There are three major parts to this PR (more or less interlinked): . - Adds `Simulator` class to abstract away circuit run functionality. This enables future contributors to add to exact simulation (and potentially other ways of simulation) easily. It also has a `step` function which allows to go over the circuit step-by-step which could enable interesting visualisations.; - Adds `Result` class as a wrapper around results obtained from circuit simulations. ; - Adds a more efficient mode to `gate_sequence_product` function which allows for faster pre-computation of unitaries. **Changelog**; Added `Simulator`, `Result` class ; Added new mode to `gate_sequence_product`, `QubitCircuit.propagators`",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1331
https://github.com/qutip/qutip/pull/1331:1198,Integrability,wrap,wrapper,1198,"**Checklist**; Thank you for contributing to QuTiP! Please make sure you have finished the following tasks before opening the PR. - [x] Please read [Contributing to QuTiP Development](https://github.com/qutip/qutip-doc/blob/master/CONTRIBUTING.md); - [x] Contributions to qutip should follow the [pep8 style](https://www.python.org/dev/peps/pep-0008/).; You can use [pycodestyle](http://pycodestyle.pycqa.org/en/latest/index.html) to check your code automatically; - [x] Please add tests to cover your changes if applicable.; - [x] If the behavior of the code has changed or new feature has been added, please also update the [documentation](https://github.com/qutip/qutip-doc) and the [notebook](https://github.com/qutip/qutip-notebooks). Feel free to ask if you are not sure. **Description**; There are three major parts to this PR (more or less interlinked): . - Adds `Simulator` class to abstract away circuit run functionality. This enables future contributors to add to exact simulation (and potentially other ways of simulation) easily. It also has a `step` function which allows to go over the circuit step-by-step which could enable interesting visualisations.; - Adds `Result` class as a wrapper around results obtained from circuit simulations. ; - Adds a more efficient mode to `gate_sequence_product` function which allows for faster pre-computation of unitaries. **Changelog**; Added `Simulator`, `Result` class ; Added new mode to `gate_sequence_product`, `QubitCircuit.propagators`",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1331
https://github.com/qutip/qutip/pull/1331:482,Testability,test,tests,482,"**Checklist**; Thank you for contributing to QuTiP! Please make sure you have finished the following tasks before opening the PR. - [x] Please read [Contributing to QuTiP Development](https://github.com/qutip/qutip-doc/blob/master/CONTRIBUTING.md); - [x] Contributions to qutip should follow the [pep8 style](https://www.python.org/dev/peps/pep-0008/).; You can use [pycodestyle](http://pycodestyle.pycqa.org/en/latest/index.html) to check your code automatically; - [x] Please add tests to cover your changes if applicable.; - [x] If the behavior of the code has changed or new feature has been added, please also update the [documentation](https://github.com/qutip/qutip-doc) and the [notebook](https://github.com/qutip/qutip-notebooks). Feel free to ask if you are not sure. **Description**; There are three major parts to this PR (more or less interlinked): . - Adds `Simulator` class to abstract away circuit run functionality. This enables future contributors to add to exact simulation (and potentially other ways of simulation) easily. It also has a `step` function which allows to go over the circuit step-by-step which could enable interesting visualisations.; - Adds `Result` class as a wrapper around results obtained from circuit simulations. ; - Adds a more efficient mode to `gate_sequence_product` function which allows for faster pre-computation of unitaries. **Changelog**; Added `Simulator`, `Result` class ; Added new mode to `gate_sequence_product`, `QubitCircuit.propagators`",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1331
https://github.com/qutip/qutip/pull/1332:454,Availability,down,down,454,"_Edited 2020-08-10_. This is now a complete switch-over to the new `CSR` type, from `fast_csr_matrix`. There are huge changes and knock-on effects all across QuTiP. Most notably for user code is that arithmetic on `Qobj` is now massively faster for small `Qobj`. The instantiation cost of `Qobj` is reduced an awful lot, and internal functions which return `Qobj` now supply `dims` and `type` information to the constructor so that instantiation time is down from ~50-100µs to about ~5µs. Notable removals:; - `eseries` and `essolve` are completely gone; - OpenMP is temporarily removed (though this will be added back in to the data layer later); - all functions in `correlation` and `qobj` which were marked ""deprecated"" are now actually removed; - `vec2mat` and `mat2vec` have been renamed to `vector_to_operator` and `operator_to_vector`; - all ""legacy"" files have been completely removed; - all previous scipy-CSR-like Cython code is completely gone (replaced by the data layer); - `Qobj` no longer defines `__array__`, and so will not automatically turn itself into one. Having this produced very inconsistent behaviour when multiplying by numpy arrays, or otherwise dealing with numpy functions. If you _need_ `Qobj` to be array, be explicit and call `Qobj.full()`. Notable changes in `Qobj`:; - matrix multiplication now contracts to a scalar if doing `bra @ ket`; - matrix multiplication no longer contracts 1D subspaces, but the new `Qobj.contract()` will do this; - arithmetic operations are much more strict about enforcing `Qobj.type`-safety; - `Qobj` understands the `@` operator to mean matrix multiplication, but also maintains the same behaviour of treating `Qobj * Qobj` as matrix multiplication. Package organisation:; - the solvers are now physically contained in `qutip.solve`, but are still logically available in the `qutip` namespace. This means that direct imports (like `from qutip.mesolve import mesolve`) will fail (it becomes `from qutip.solve.mesolve import mesolve`), bu",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1332
https://github.com/qutip/qutip/pull/1332:1823,Availability,avail,available,1823,"erator_to_vector`; - all ""legacy"" files have been completely removed; - all previous scipy-CSR-like Cython code is completely gone (replaced by the data layer); - `Qobj` no longer defines `__array__`, and so will not automatically turn itself into one. Having this produced very inconsistent behaviour when multiplying by numpy arrays, or otherwise dealing with numpy functions. If you _need_ `Qobj` to be array, be explicit and call `Qobj.full()`. Notable changes in `Qobj`:; - matrix multiplication now contracts to a scalar if doing `bra @ ket`; - matrix multiplication no longer contracts 1D subspaces, but the new `Qobj.contract()` will do this; - arithmetic operations are much more strict about enforcing `Qobj.type`-safety; - `Qobj` understands the `@` operator to mean matrix multiplication, but also maintains the same behaviour of treating `Qobj * Qobj` as matrix multiplication. Package organisation:; - the solvers are now physically contained in `qutip.solve`, but are still logically available in the `qutip` namespace. This means that direct imports (like `from qutip.mesolve import mesolve`) will fail (it becomes `from qutip.solve.mesolve import mesolve`), but the ""proper"" unqualified access `from qutip import mesolve` remains unchanged. This is for internal code organisation purposes. The integral type used as the indices in the `CSR` type is now done by simple typedef in the files `qutip/core/data/base.{pyx,pxd}`, so changes it in those two files at compile-time will allow you to switch between 32-bit and 64-bit. The C++ backing source file `zspmv.cpp` and its associated header are renamed to `matmul_csr_vector` to match the new data-layer naming conventions, but more importantly, the functions are now templated over integral types so they will ""magically"" work at either size. In general, `setuptools` likes to link dynamically (on Linux and Mac, but not Windows), and so the templates have to be made explicit, rather than allowing Cython to generate only the necessa",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1332
https://github.com/qutip/qutip/pull/1332:3274,Availability,down,down,3274,"tion purposes. The integral type used as the indices in the `CSR` type is now done by simple typedef in the files `qutip/core/data/base.{pyx,pxd}`, so changes it in those two files at compile-time will allow you to switch between 32-bit and 64-bit. The C++ backing source file `zspmv.cpp` and its associated header are renamed to `matmul_csr_vector` to match the new data-layer naming conventions, but more importantly, the functions are now templated over integral types so they will ""magically"" work at either size. In general, `setuptools` likes to link dynamically (on Linux and Mac, but not Windows), and so the templates have to be made explicit, rather than allowing Cython to generate only the necessary one. _Note:_ I'll make a PR to push deprecation warnings onto `eseries`, `essolve` and all other removals or renames that don't already have one in `master`, ready for when we drop QuTiP 4.6.0. -----------. _Original top comment:_. Not a complete switch-over to `CSR` from `fast_csr_matrix`, but this goes a really long way to achieving that. `Qobj` is done completely, but `QobjEvo` is pretty difficult to disentangle, and that really slowed me down a lot, and I'm not at all sure I've got it right there yet. OpenMP is ignored for now as low-priority. We'll need to get it working before a QuTiP 5.0 release, but I'm not working on it at the moment. `CQobjEvo` has been absolutely stripped bare. All its variants are gone, since the data layer types will handle this instead. `QobjEvo` is basically managed by shim at the moment, and needs a huge tidy up to bring it up to speed with the new data layer, and keep it maintainable. The data layer types have been taught to pickle themselves safely and automatically, and so consequently `QobjEvo` is magically pickle-able (aside from the OpenMP types). This PR includes all the commits from #1296 as well, but it's still a pretty giant PR as it stands right now. The tests won't pass yet, because I haven't finished converting everything.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1332
https://github.com/qutip/qutip/pull/1332:3430,Deployability,release,release,3430,"tion purposes. The integral type used as the indices in the `CSR` type is now done by simple typedef in the files `qutip/core/data/base.{pyx,pxd}`, so changes it in those two files at compile-time will allow you to switch between 32-bit and 64-bit. The C++ backing source file `zspmv.cpp` and its associated header are renamed to `matmul_csr_vector` to match the new data-layer naming conventions, but more importantly, the functions are now templated over integral types so they will ""magically"" work at either size. In general, `setuptools` likes to link dynamically (on Linux and Mac, but not Windows), and so the templates have to be made explicit, rather than allowing Cython to generate only the necessary one. _Note:_ I'll make a PR to push deprecation warnings onto `eseries`, `essolve` and all other removals or renames that don't already have one in `master`, ready for when we drop QuTiP 4.6.0. -----------. _Original top comment:_. Not a complete switch-over to `CSR` from `fast_csr_matrix`, but this goes a really long way to achieving that. `Qobj` is done completely, but `QobjEvo` is pretty difficult to disentangle, and that really slowed me down a lot, and I'm not at all sure I've got it right there yet. OpenMP is ignored for now as low-priority. We'll need to get it working before a QuTiP 5.0 release, but I'm not working on it at the moment. `CQobjEvo` has been absolutely stripped bare. All its variants are gone, since the data layer types will handle this instead. `QobjEvo` is basically managed by shim at the moment, and needs a huge tidy up to bring it up to speed with the new data layer, and keep it maintainable. The data layer types have been taught to pickle themselves safely and automatically, and so consequently `QobjEvo` is magically pickle-able (aside from the OpenMP types). This PR includes all the commits from #1296 as well, but it's still a pretty giant PR as it stands right now. The tests won't pass yet, because I haven't finished converting everything.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1332
https://github.com/qutip/qutip/pull/1332:299,Energy Efficiency,reduce,reduced,299,"_Edited 2020-08-10_. This is now a complete switch-over to the new `CSR` type, from `fast_csr_matrix`. There are huge changes and knock-on effects all across QuTiP. Most notably for user code is that arithmetic on `Qobj` is now massively faster for small `Qobj`. The instantiation cost of `Qobj` is reduced an awful lot, and internal functions which return `Qobj` now supply `dims` and `type` information to the constructor so that instantiation time is down from ~50-100µs to about ~5µs. Notable removals:; - `eseries` and `essolve` are completely gone; - OpenMP is temporarily removed (though this will be added back in to the data layer later); - all functions in `correlation` and `qobj` which were marked ""deprecated"" are now actually removed; - `vec2mat` and `mat2vec` have been renamed to `vector_to_operator` and `operator_to_vector`; - all ""legacy"" files have been completely removed; - all previous scipy-CSR-like Cython code is completely gone (replaced by the data layer); - `Qobj` no longer defines `__array__`, and so will not automatically turn itself into one. Having this produced very inconsistent behaviour when multiplying by numpy arrays, or otherwise dealing with numpy functions. If you _need_ `Qobj` to be array, be explicit and call `Qobj.full()`. Notable changes in `Qobj`:; - matrix multiplication now contracts to a scalar if doing `bra @ ket`; - matrix multiplication no longer contracts 1D subspaces, but the new `Qobj.contract()` will do this; - arithmetic operations are much more strict about enforcing `Qobj.type`-safety; - `Qobj` understands the `@` operator to mean matrix multiplication, but also maintains the same behaviour of treating `Qobj * Qobj` as matrix multiplication. Package organisation:; - the solvers are now physically contained in `qutip.solve`, but are still logically available in the `qutip` namespace. This means that direct imports (like `from qutip.mesolve import mesolve`) will fail (it becomes `from qutip.solve.mesolve import mesolve`), bu",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1332
https://github.com/qutip/qutip/pull/1332:1329,Integrability,contract,contracts,1329,"bj` now supply `dims` and `type` information to the constructor so that instantiation time is down from ~50-100µs to about ~5µs. Notable removals:; - `eseries` and `essolve` are completely gone; - OpenMP is temporarily removed (though this will be added back in to the data layer later); - all functions in `correlation` and `qobj` which were marked ""deprecated"" are now actually removed; - `vec2mat` and `mat2vec` have been renamed to `vector_to_operator` and `operator_to_vector`; - all ""legacy"" files have been completely removed; - all previous scipy-CSR-like Cython code is completely gone (replaced by the data layer); - `Qobj` no longer defines `__array__`, and so will not automatically turn itself into one. Having this produced very inconsistent behaviour when multiplying by numpy arrays, or otherwise dealing with numpy functions. If you _need_ `Qobj` to be array, be explicit and call `Qobj.full()`. Notable changes in `Qobj`:; - matrix multiplication now contracts to a scalar if doing `bra @ ket`; - matrix multiplication no longer contracts 1D subspaces, but the new `Qobj.contract()` will do this; - arithmetic operations are much more strict about enforcing `Qobj.type`-safety; - `Qobj` understands the `@` operator to mean matrix multiplication, but also maintains the same behaviour of treating `Qobj * Qobj` as matrix multiplication. Package organisation:; - the solvers are now physically contained in `qutip.solve`, but are still logically available in the `qutip` namespace. This means that direct imports (like `from qutip.mesolve import mesolve`) will fail (it becomes `from qutip.solve.mesolve import mesolve`), but the ""proper"" unqualified access `from qutip import mesolve` remains unchanged. This is for internal code organisation purposes. The integral type used as the indices in the `CSR` type is now done by simple typedef in the files `qutip/core/data/base.{pyx,pxd}`, so changes it in those two files at compile-time will allow you to switch between 32-bit and 64-b",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1332
https://github.com/qutip/qutip/pull/1332:1407,Integrability,contract,contracts,1407,"bj` now supply `dims` and `type` information to the constructor so that instantiation time is down from ~50-100µs to about ~5µs. Notable removals:; - `eseries` and `essolve` are completely gone; - OpenMP is temporarily removed (though this will be added back in to the data layer later); - all functions in `correlation` and `qobj` which were marked ""deprecated"" are now actually removed; - `vec2mat` and `mat2vec` have been renamed to `vector_to_operator` and `operator_to_vector`; - all ""legacy"" files have been completely removed; - all previous scipy-CSR-like Cython code is completely gone (replaced by the data layer); - `Qobj` no longer defines `__array__`, and so will not automatically turn itself into one. Having this produced very inconsistent behaviour when multiplying by numpy arrays, or otherwise dealing with numpy functions. If you _need_ `Qobj` to be array, be explicit and call `Qobj.full()`. Notable changes in `Qobj`:; - matrix multiplication now contracts to a scalar if doing `bra @ ket`; - matrix multiplication no longer contracts 1D subspaces, but the new `Qobj.contract()` will do this; - arithmetic operations are much more strict about enforcing `Qobj.type`-safety; - `Qobj` understands the `@` operator to mean matrix multiplication, but also maintains the same behaviour of treating `Qobj * Qobj` as matrix multiplication. Package organisation:; - the solvers are now physically contained in `qutip.solve`, but are still logically available in the `qutip` namespace. This means that direct imports (like `from qutip.mesolve import mesolve`) will fail (it becomes `from qutip.solve.mesolve import mesolve`), but the ""proper"" unqualified access `from qutip import mesolve` remains unchanged. This is for internal code organisation purposes. The integral type used as the indices in the `CSR` type is now done by simple typedef in the files `qutip/core/data/base.{pyx,pxd}`, so changes it in those two files at compile-time will allow you to switch between 32-bit and 64-b",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1332
https://github.com/qutip/qutip/pull/1332:1449,Integrability,contract,contract,1449,"e removals:; - `eseries` and `essolve` are completely gone; - OpenMP is temporarily removed (though this will be added back in to the data layer later); - all functions in `correlation` and `qobj` which were marked ""deprecated"" are now actually removed; - `vec2mat` and `mat2vec` have been renamed to `vector_to_operator` and `operator_to_vector`; - all ""legacy"" files have been completely removed; - all previous scipy-CSR-like Cython code is completely gone (replaced by the data layer); - `Qobj` no longer defines `__array__`, and so will not automatically turn itself into one. Having this produced very inconsistent behaviour when multiplying by numpy arrays, or otherwise dealing with numpy functions. If you _need_ `Qobj` to be array, be explicit and call `Qobj.full()`. Notable changes in `Qobj`:; - matrix multiplication now contracts to a scalar if doing `bra @ ket`; - matrix multiplication no longer contracts 1D subspaces, but the new `Qobj.contract()` will do this; - arithmetic operations are much more strict about enforcing `Qobj.type`-safety; - `Qobj` understands the `@` operator to mean matrix multiplication, but also maintains the same behaviour of treating `Qobj * Qobj` as matrix multiplication. Package organisation:; - the solvers are now physically contained in `qutip.solve`, but are still logically available in the `qutip` namespace. This means that direct imports (like `from qutip.mesolve import mesolve`) will fail (it becomes `from qutip.solve.mesolve import mesolve`), but the ""proper"" unqualified access `from qutip import mesolve` remains unchanged. This is for internal code organisation purposes. The integral type used as the indices in the `CSR` type is now done by simple typedef in the files `qutip/core/data/base.{pyx,pxd}`, so changes it in those two files at compile-time will allow you to switch between 32-bit and 64-bit. The C++ backing source file `zspmv.cpp` and its associated header are renamed to `matmul_csr_vector` to match the new data-layer na",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1332
https://github.com/qutip/qutip/pull/1332:3746,Modifiability,maintainab,maintainable,3746,"tion purposes. The integral type used as the indices in the `CSR` type is now done by simple typedef in the files `qutip/core/data/base.{pyx,pxd}`, so changes it in those two files at compile-time will allow you to switch between 32-bit and 64-bit. The C++ backing source file `zspmv.cpp` and its associated header are renamed to `matmul_csr_vector` to match the new data-layer naming conventions, but more importantly, the functions are now templated over integral types so they will ""magically"" work at either size. In general, `setuptools` likes to link dynamically (on Linux and Mac, but not Windows), and so the templates have to be made explicit, rather than allowing Cython to generate only the necessary one. _Note:_ I'll make a PR to push deprecation warnings onto `eseries`, `essolve` and all other removals or renames that don't already have one in `master`, ready for when we drop QuTiP 4.6.0. -----------. _Original top comment:_. Not a complete switch-over to `CSR` from `fast_csr_matrix`, but this goes a really long way to achieving that. `Qobj` is done completely, but `QobjEvo` is pretty difficult to disentangle, and that really slowed me down a lot, and I'm not at all sure I've got it right there yet. OpenMP is ignored for now as low-priority. We'll need to get it working before a QuTiP 5.0 release, but I'm not working on it at the moment. `CQobjEvo` has been absolutely stripped bare. All its variants are gone, since the data layer types will handle this instead. `QobjEvo` is basically managed by shim at the moment, and needs a huge tidy up to bring it up to speed with the new data layer, and keep it maintainable. The data layer types have been taught to pickle themselves safely and automatically, and so consequently `QobjEvo` is magically pickle-able (aside from the OpenMP types). This PR includes all the commits from #1296 as well, but it's still a pretty giant PR as it stands right now. The tests won't pass yet, because I haven't finished converting everything.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1332
https://github.com/qutip/qutip/pull/1332:1548,Safety,safe,safety,1548," data layer later); - all functions in `correlation` and `qobj` which were marked ""deprecated"" are now actually removed; - `vec2mat` and `mat2vec` have been renamed to `vector_to_operator` and `operator_to_vector`; - all ""legacy"" files have been completely removed; - all previous scipy-CSR-like Cython code is completely gone (replaced by the data layer); - `Qobj` no longer defines `__array__`, and so will not automatically turn itself into one. Having this produced very inconsistent behaviour when multiplying by numpy arrays, or otherwise dealing with numpy functions. If you _need_ `Qobj` to be array, be explicit and call `Qobj.full()`. Notable changes in `Qobj`:; - matrix multiplication now contracts to a scalar if doing `bra @ ket`; - matrix multiplication no longer contracts 1D subspaces, but the new `Qobj.contract()` will do this; - arithmetic operations are much more strict about enforcing `Qobj.type`-safety; - `Qobj` understands the `@` operator to mean matrix multiplication, but also maintains the same behaviour of treating `Qobj * Qobj` as matrix multiplication. Package organisation:; - the solvers are now physically contained in `qutip.solve`, but are still logically available in the `qutip` namespace. This means that direct imports (like `from qutip.mesolve import mesolve`) will fail (it becomes `from qutip.solve.mesolve import mesolve`), but the ""proper"" unqualified access `from qutip import mesolve` remains unchanged. This is for internal code organisation purposes. The integral type used as the indices in the `CSR` type is now done by simple typedef in the files `qutip/core/data/base.{pyx,pxd}`, so changes it in those two files at compile-time will allow you to switch between 32-bit and 64-bit. The C++ backing source file `zspmv.cpp` and its associated header are renamed to `matmul_csr_vector` to match the new data-layer naming conventions, but more importantly, the functions are now templated over integral types so they will ""magically"" work at either ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1332
https://github.com/qutip/qutip/pull/1332:3819,Safety,safe,safely,3819,"tion purposes. The integral type used as the indices in the `CSR` type is now done by simple typedef in the files `qutip/core/data/base.{pyx,pxd}`, so changes it in those two files at compile-time will allow you to switch between 32-bit and 64-bit. The C++ backing source file `zspmv.cpp` and its associated header are renamed to `matmul_csr_vector` to match the new data-layer naming conventions, but more importantly, the functions are now templated over integral types so they will ""magically"" work at either size. In general, `setuptools` likes to link dynamically (on Linux and Mac, but not Windows), and so the templates have to be made explicit, rather than allowing Cython to generate only the necessary one. _Note:_ I'll make a PR to push deprecation warnings onto `eseries`, `essolve` and all other removals or renames that don't already have one in `master`, ready for when we drop QuTiP 4.6.0. -----------. _Original top comment:_. Not a complete switch-over to `CSR` from `fast_csr_matrix`, but this goes a really long way to achieving that. `Qobj` is done completely, but `QobjEvo` is pretty difficult to disentangle, and that really slowed me down a lot, and I'm not at all sure I've got it right there yet. OpenMP is ignored for now as low-priority. We'll need to get it working before a QuTiP 5.0 release, but I'm not working on it at the moment. `CQobjEvo` has been absolutely stripped bare. All its variants are gone, since the data layer types will handle this instead. `QobjEvo` is basically managed by shim at the moment, and needs a huge tidy up to bring it up to speed with the new data layer, and keep it maintainable. The data layer types have been taught to pickle themselves safely and automatically, and so consequently `QobjEvo` is magically pickle-able (aside from the OpenMP types). This PR includes all the commits from #1296 as well, but it's still a pretty giant PR as it stands right now. The tests won't pass yet, because I haven't finished converting everything.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1332
https://github.com/qutip/qutip/pull/1332:2028,Security,access,access,2028,"d so will not automatically turn itself into one. Having this produced very inconsistent behaviour when multiplying by numpy arrays, or otherwise dealing with numpy functions. If you _need_ `Qobj` to be array, be explicit and call `Qobj.full()`. Notable changes in `Qobj`:; - matrix multiplication now contracts to a scalar if doing `bra @ ket`; - matrix multiplication no longer contracts 1D subspaces, but the new `Qobj.contract()` will do this; - arithmetic operations are much more strict about enforcing `Qobj.type`-safety; - `Qobj` understands the `@` operator to mean matrix multiplication, but also maintains the same behaviour of treating `Qobj * Qobj` as matrix multiplication. Package organisation:; - the solvers are now physically contained in `qutip.solve`, but are still logically available in the `qutip` namespace. This means that direct imports (like `from qutip.mesolve import mesolve`) will fail (it becomes `from qutip.solve.mesolve import mesolve`), but the ""proper"" unqualified access `from qutip import mesolve` remains unchanged. This is for internal code organisation purposes. The integral type used as the indices in the `CSR` type is now done by simple typedef in the files `qutip/core/data/base.{pyx,pxd}`, so changes it in those two files at compile-time will allow you to switch between 32-bit and 64-bit. The C++ backing source file `zspmv.cpp` and its associated header are renamed to `matmul_csr_vector` to match the new data-layer naming conventions, but more importantly, the functions are now templated over integral types so they will ""magically"" work at either size. In general, `setuptools` likes to link dynamically (on Linux and Mac, but not Windows), and so the templates have to be made explicit, rather than allowing Cython to generate only the necessary one. _Note:_ I'll make a PR to push deprecation warnings onto `eseries`, `essolve` and all other removals or renames that don't already have one in `master`, ready for when we drop QuTiP 4.6.0. -----",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1332
https://github.com/qutip/qutip/pull/1332:1813,Testability,log,logically,1813,"erator_to_vector`; - all ""legacy"" files have been completely removed; - all previous scipy-CSR-like Cython code is completely gone (replaced by the data layer); - `Qobj` no longer defines `__array__`, and so will not automatically turn itself into one. Having this produced very inconsistent behaviour when multiplying by numpy arrays, or otherwise dealing with numpy functions. If you _need_ `Qobj` to be array, be explicit and call `Qobj.full()`. Notable changes in `Qobj`:; - matrix multiplication now contracts to a scalar if doing `bra @ ket`; - matrix multiplication no longer contracts 1D subspaces, but the new `Qobj.contract()` will do this; - arithmetic operations are much more strict about enforcing `Qobj.type`-safety; - `Qobj` understands the `@` operator to mean matrix multiplication, but also maintains the same behaviour of treating `Qobj * Qobj` as matrix multiplication. Package organisation:; - the solvers are now physically contained in `qutip.solve`, but are still logically available in the `qutip` namespace. This means that direct imports (like `from qutip.mesolve import mesolve`) will fail (it becomes `from qutip.solve.mesolve import mesolve`), but the ""proper"" unqualified access `from qutip import mesolve` remains unchanged. This is for internal code organisation purposes. The integral type used as the indices in the `CSR` type is now done by simple typedef in the files `qutip/core/data/base.{pyx,pxd}`, so changes it in those two files at compile-time will allow you to switch between 32-bit and 64-bit. The C++ backing source file `zspmv.cpp` and its associated header are renamed to `matmul_csr_vector` to match the new data-layer naming conventions, but more importantly, the functions are now templated over integral types so they will ""magically"" work at either size. In general, `setuptools` likes to link dynamically (on Linux and Mac, but not Windows), and so the templates have to be made explicit, rather than allowing Cython to generate only the necessa",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1332
https://github.com/qutip/qutip/pull/1332:4045,Testability,test,tests,4045,"tion purposes. The integral type used as the indices in the `CSR` type is now done by simple typedef in the files `qutip/core/data/base.{pyx,pxd}`, so changes it in those two files at compile-time will allow you to switch between 32-bit and 64-bit. The C++ backing source file `zspmv.cpp` and its associated header are renamed to `matmul_csr_vector` to match the new data-layer naming conventions, but more importantly, the functions are now templated over integral types so they will ""magically"" work at either size. In general, `setuptools` likes to link dynamically (on Linux and Mac, but not Windows), and so the templates have to be made explicit, rather than allowing Cython to generate only the necessary one. _Note:_ I'll make a PR to push deprecation warnings onto `eseries`, `essolve` and all other removals or renames that don't already have one in `master`, ready for when we drop QuTiP 4.6.0. -----------. _Original top comment:_. Not a complete switch-over to `CSR` from `fast_csr_matrix`, but this goes a really long way to achieving that. `Qobj` is done completely, but `QobjEvo` is pretty difficult to disentangle, and that really slowed me down a lot, and I'm not at all sure I've got it right there yet. OpenMP is ignored for now as low-priority. We'll need to get it working before a QuTiP 5.0 release, but I'm not working on it at the moment. `CQobjEvo` has been absolutely stripped bare. All its variants are gone, since the data layer types will handle this instead. `QobjEvo` is basically managed by shim at the moment, and needs a huge tidy up to bring it up to speed with the new data layer, and keep it maintainable. The data layer types have been taught to pickle themselves safely and automatically, and so consequently `QobjEvo` is magically pickle-able (aside from the OpenMP types). This PR includes all the commits from #1296 as well, but it's still a pretty giant PR as it stands right now. The tests won't pass yet, because I haven't finished converting everything.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1332
https://github.com/qutip/qutip/pull/1332:2202,Usability,simpl,simple,2202," functions. If you _need_ `Qobj` to be array, be explicit and call `Qobj.full()`. Notable changes in `Qobj`:; - matrix multiplication now contracts to a scalar if doing `bra @ ket`; - matrix multiplication no longer contracts 1D subspaces, but the new `Qobj.contract()` will do this; - arithmetic operations are much more strict about enforcing `Qobj.type`-safety; - `Qobj` understands the `@` operator to mean matrix multiplication, but also maintains the same behaviour of treating `Qobj * Qobj` as matrix multiplication. Package organisation:; - the solvers are now physically contained in `qutip.solve`, but are still logically available in the `qutip` namespace. This means that direct imports (like `from qutip.mesolve import mesolve`) will fail (it becomes `from qutip.solve.mesolve import mesolve`), but the ""proper"" unqualified access `from qutip import mesolve` remains unchanged. This is for internal code organisation purposes. The integral type used as the indices in the `CSR` type is now done by simple typedef in the files `qutip/core/data/base.{pyx,pxd}`, so changes it in those two files at compile-time will allow you to switch between 32-bit and 64-bit. The C++ backing source file `zspmv.cpp` and its associated header are renamed to `matmul_csr_vector` to match the new data-layer naming conventions, but more importantly, the functions are now templated over integral types so they will ""magically"" work at either size. In general, `setuptools` likes to link dynamically (on Linux and Mac, but not Windows), and so the templates have to be made explicit, rather than allowing Cython to generate only the necessary one. _Note:_ I'll make a PR to push deprecation warnings onto `eseries`, `essolve` and all other removals or renames that don't already have one in `master`, ready for when we drop QuTiP 4.6.0. -----------. _Original top comment:_. Not a complete switch-over to `CSR` from `fast_csr_matrix`, but this goes a really long way to achieving that. `Qobj` is done compl",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1332
https://github.com/qutip/qutip/issues/1334:142,Availability,error,error,142,"Importing after conda install with lastest:. /Users/paul/.pyxbld/temp.macosx-10.9-x86_64-3.7/pyrex/qutip/cy/openmp/parfuncs.cpp:626:10: fatal error:; 'src/zspmv_openmp.hpp' file not found; #include ""src/zspmv_openmp.hpp""",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1334
https://github.com/qutip/qutip/issues/1334:22,Deployability,install,install,22,"Importing after conda install with lastest:. /Users/paul/.pyxbld/temp.macosx-10.9-x86_64-3.7/pyrex/qutip/cy/openmp/parfuncs.cpp:626:10: fatal error:; 'src/zspmv_openmp.hpp' file not found; #include ""src/zspmv_openmp.hpp""",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1334
https://github.com/qutip/qutip/pull/1335:295,Testability,Test,Tested,295,"Description; Modification of PR #1315 .Added option to include colors to Bloch vectors and points instead of just cycling from a list. Related issues or PRs; fix #1292. Changelog; Added an optional argument called colors for the Bloch.add_vectors, Bloch.add_points and Bloch.add_states method.; Tested it here: https://github.com/rajathshetty20/misc/blob/master/qutip%20%231292.ipynb",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1335
https://github.com/qutip/qutip/pull/1336:570,Deployability,patch,patched,570,"Add a `Coefficient` object to encapsulate the coefficients of the QobjEvo.; `Coefficient`s replace qobjevo's codegen. Their advantages are; - Coefficient are always 'compiled'. String are compiled to cython code at initialization.; - Have cython decorator: taking the conjugate does no longer require new compilation.; - String coefficient are saved to reuse with basic pattern matching: ""cos(a*t)"" and ""cos( w1 *t )"" will use the same compiled object. This object is compiled once and kept between session.; - Cleaner compilation using `setuptools` instead of a monkey patched `pyximport`.; - `QobjEvo` is always compiled.; - `ObjeEvo` does not need to keep track of type making the code simpler. There are shims to make `Pulse` and qip tests work since they used `QobjEvo.tlist` and `QobjEvo.ops.coeff`.; @BoxiLi, the new QobjEvo can be added even if coefficient's tlist are different, but you cannot get back the tlist and the array from them. Also for _step_func_coeff, before the first time, `Coefficient` return the first value of the array, not 0 as expected in pulse.py.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1336
https://github.com/qutip/qutip/pull/1336:738,Testability,test,tests,738,"Add a `Coefficient` object to encapsulate the coefficients of the QobjEvo.; `Coefficient`s replace qobjevo's codegen. Their advantages are; - Coefficient are always 'compiled'. String are compiled to cython code at initialization.; - Have cython decorator: taking the conjugate does no longer require new compilation.; - String coefficient are saved to reuse with basic pattern matching: ""cos(a*t)"" and ""cos( w1 *t )"" will use the same compiled object. This object is compiled once and kept between session.; - Cleaner compilation using `setuptools` instead of a monkey patched `pyximport`.; - `QobjEvo` is always compiled.; - `ObjeEvo` does not need to keep track of type making the code simpler. There are shims to make `Pulse` and qip tests work since they used `QobjEvo.tlist` and `QobjEvo.ops.coeff`.; @BoxiLi, the new QobjEvo can be added even if coefficient's tlist are different, but you cannot get back the tlist and the array from them. Also for _step_func_coeff, before the first time, `Coefficient` return the first value of the array, not 0 as expected in pulse.py.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1336
https://github.com/qutip/qutip/pull/1336:689,Usability,simpl,simpler,689,"Add a `Coefficient` object to encapsulate the coefficients of the QobjEvo.; `Coefficient`s replace qobjevo's codegen. Their advantages are; - Coefficient are always 'compiled'. String are compiled to cython code at initialization.; - Have cython decorator: taking the conjugate does no longer require new compilation.; - String coefficient are saved to reuse with basic pattern matching: ""cos(a*t)"" and ""cos( w1 *t )"" will use the same compiled object. This object is compiled once and kept between session.; - Cleaner compilation using `setuptools` instead of a monkey patched `pyximport`.; - `QobjEvo` is always compiled.; - `ObjeEvo` does not need to keep track of type making the code simpler. There are shims to make `Pulse` and qip tests work since they used `QobjEvo.tlist` and `QobjEvo.ops.coeff`.; @BoxiLi, the new QobjEvo can be added even if coefficient's tlist are different, but you cannot get back the tlist and the array from them. Also for _step_func_coeff, before the first time, `Coefficient` return the first value of the array, not 0 as expected in pulse.py.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1336
https://github.com/qutip/qutip/pull/1337:983,Availability,avail,available,983,"New schemes for the options. All options's default value can be set and seen in qutip.settings:; ```; >>> from qutip import settings; >>> settings.solver[""atol""] = 1e-10; >>> settings.core[""auto_tidyup""] = False; >>> settings.solver.mcsolve[""norm_tol""] = 1e-4; >>> settings.save(); >>> print(qutip.settings); qutip.settings.install:; debug : False; log_handler : 'default'; colorblind_safe : False; tmproot : '/home/eric/.qutip/coeffs'; mkl_lib : None; has_mkl : False; ipython : True; _logger : <Logger qutip.installsettings (WARNING)>; eigh_unsafe : False. qutip.settings.core:; auto_tidyup : False; auto_tidyup_dims : True; auto_herm : True; atol : 1e-12; auto_tidyup_atol : 1e-12; ...; ```. The main changes are; - `settings` is an object in `qutip/settings.py`.; - Actual options are accessed as dictionary values instead of attributes.; - `settings`'s values are read from qutiprc at import.; - Easy saving of settings; - `reset` function as described in documentation but not available yet.; - solver `Options` renamed and split, some options removed (`rhs_with_state`, ...). @jakelishman, I commented out most of the openmp stuff, I expect you to pass behind me and clean when you re-implement it.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1337
https://github.com/qutip/qutip/pull/1337:324,Deployability,install,install,324,"New schemes for the options. All options's default value can be set and seen in qutip.settings:; ```; >>> from qutip import settings; >>> settings.solver[""atol""] = 1e-10; >>> settings.core[""auto_tidyup""] = False; >>> settings.solver.mcsolve[""norm_tol""] = 1e-4; >>> settings.save(); >>> print(qutip.settings); qutip.settings.install:; debug : False; log_handler : 'default'; colorblind_safe : False; tmproot : '/home/eric/.qutip/coeffs'; mkl_lib : None; has_mkl : False; ipython : True; _logger : <Logger qutip.installsettings (WARNING)>; eigh_unsafe : False. qutip.settings.core:; auto_tidyup : False; auto_tidyup_dims : True; auto_herm : True; atol : 1e-12; auto_tidyup_atol : 1e-12; ...; ```. The main changes are; - `settings` is an object in `qutip/settings.py`.; - Actual options are accessed as dictionary values instead of attributes.; - `settings`'s values are read from qutiprc at import.; - Easy saving of settings; - `reset` function as described in documentation but not available yet.; - solver `Options` renamed and split, some options removed (`rhs_with_state`, ...). @jakelishman, I commented out most of the openmp stuff, I expect you to pass behind me and clean when you re-implement it.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1337
https://github.com/qutip/qutip/pull/1337:510,Deployability,install,installsettings,510,"New schemes for the options. All options's default value can be set and seen in qutip.settings:; ```; >>> from qutip import settings; >>> settings.solver[""atol""] = 1e-10; >>> settings.core[""auto_tidyup""] = False; >>> settings.solver.mcsolve[""norm_tol""] = 1e-4; >>> settings.save(); >>> print(qutip.settings); qutip.settings.install:; debug : False; log_handler : 'default'; colorblind_safe : False; tmproot : '/home/eric/.qutip/coeffs'; mkl_lib : None; has_mkl : False; ipython : True; _logger : <Logger qutip.installsettings (WARNING)>; eigh_unsafe : False. qutip.settings.core:; auto_tidyup : False; auto_tidyup_dims : True; auto_herm : True; atol : 1e-12; auto_tidyup_atol : 1e-12; ...; ```. The main changes are; - `settings` is an object in `qutip/settings.py`.; - Actual options are accessed as dictionary values instead of attributes.; - `settings`'s values are read from qutiprc at import.; - Easy saving of settings; - `reset` function as described in documentation but not available yet.; - solver `Options` renamed and split, some options removed (`rhs_with_state`, ...). @jakelishman, I commented out most of the openmp stuff, I expect you to pass behind me and clean when you re-implement it.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1337
https://github.com/qutip/qutip/pull/1337:789,Security,access,accessed,789,"New schemes for the options. All options's default value can be set and seen in qutip.settings:; ```; >>> from qutip import settings; >>> settings.solver[""atol""] = 1e-10; >>> settings.core[""auto_tidyup""] = False; >>> settings.solver.mcsolve[""norm_tol""] = 1e-4; >>> settings.save(); >>> print(qutip.settings); qutip.settings.install:; debug : False; log_handler : 'default'; colorblind_safe : False; tmproot : '/home/eric/.qutip/coeffs'; mkl_lib : None; has_mkl : False; ipython : True; _logger : <Logger qutip.installsettings (WARNING)>; eigh_unsafe : False. qutip.settings.core:; auto_tidyup : False; auto_tidyup_dims : True; auto_herm : True; atol : 1e-12; auto_tidyup_atol : 1e-12; ...; ```. The main changes are; - `settings` is an object in `qutip/settings.py`.; - Actual options are accessed as dictionary values instead of attributes.; - `settings`'s values are read from qutiprc at import.; - Easy saving of settings; - `reset` function as described in documentation but not available yet.; - solver `Options` renamed and split, some options removed (`rhs_with_state`, ...). @jakelishman, I commented out most of the openmp stuff, I expect you to pass behind me and clean when you re-implement it.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1337
https://github.com/qutip/qutip/pull/1337:497,Testability,Log,Logger,497,"New schemes for the options. All options's default value can be set and seen in qutip.settings:; ```; >>> from qutip import settings; >>> settings.solver[""atol""] = 1e-10; >>> settings.core[""auto_tidyup""] = False; >>> settings.solver.mcsolve[""norm_tol""] = 1e-4; >>> settings.save(); >>> print(qutip.settings); qutip.settings.install:; debug : False; log_handler : 'default'; colorblind_safe : False; tmproot : '/home/eric/.qutip/coeffs'; mkl_lib : None; has_mkl : False; ipython : True; _logger : <Logger qutip.installsettings (WARNING)>; eigh_unsafe : False. qutip.settings.core:; auto_tidyup : False; auto_tidyup_dims : True; auto_herm : True; atol : 1e-12; auto_tidyup_atol : 1e-12; ...; ```. The main changes are; - `settings` is an object in `qutip/settings.py`.; - Actual options are accessed as dictionary values instead of attributes.; - `settings`'s values are read from qutiprc at import.; - Easy saving of settings; - `reset` function as described in documentation but not available yet.; - solver `Options` renamed and split, some options removed (`rhs_with_state`, ...). @jakelishman, I commented out most of the openmp stuff, I expect you to pass behind me and clean when you re-implement it.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1337
https://github.com/qutip/qutip/pull/1338:1176,Energy Efficiency,efficient,efficient,1176,"csr_matrix` type was replaced by the new, custom `CSR` type as the data backing for `Qobj`, and all internal QuTiP data representations. This produced some speed-ups in some places due to improved algorithms and better cache usage in places, but its principle advantage was the massive reduction in overhead for function calls between Python and C space, which largely affected small objects. The full aim, however, is to have QuTiP 5 support many different data representations as the backing of `Qobj`, and use the most suitable representation for the given data. This will not require every single QuTiP function to have an exponential number of versions for every possible combination of inputs, but only to have specialisations for the most common data combinations. This concept is the ""data layer"". All code examples in this PR are prefixed with. ```python; >>> from qutip.core import data; ```. ## Specification. The core to achieving this is fast, fully specified inter-conversion between all known data types, and efficient multiple-dispatch for mathematical operations. There are then four principle components of the data-layer:. 1. a creation routine which returns an appropriate data-layer type given some arbitrary Python object (`data.create`); 2. a routine which can perform the conversion from any data-layer type to any other data-layer type (`data.to`); 3. completely specialised mathematical operations (e.g. `data.add_csr_dense_dense(CSR, Dense) -> Dense`); 4. an object which provides multiple dispatch operations on its input arguments to use an exact specialisation (defined in item 3) if known, or uses the conversion routine (item 2) to convert the inputs into ones matching a specialisation if not: `data.Dispatcher`. The exported mathematical functions will all be instances of this type. The minimum work needed to define a new data-layer type is to provide `data.to` with two conversion functions; one into the new type from a current data-layer type, and one which con",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1338
https://github.com/qutip/qutip/pull/1338:6724,Energy Efficiency,efficient,efficient,6724,"speed-efficiency here, since we expect there to be few data-layer types, but for the calls to happen millions of times. The converters returned by single-key access (e.g. `data.to[data.Dense]`) are constructed individually on a call to `__getitem__`, and are instances of the private type `data.convert._partial_converter`, which internally stores a reference to every ""full"" converter, and dispatches to the correct one when called. The entire `data.to` object and all subsidiary `_converter` and `_partial_converter` objects are `pickle`-able. . #### Efficiency notes. From an efficiency perspective, there is very little benefit to using the key-lookup syntax. Internally, `to(to_type, data)` effectively calls `to[to_type, type(data)]`, so storing the object elides the creation of a single tuple and a dict lookup, but the cost of this is generally less than 500ns. Using the one-argument lookup (e.g. `to[Dense]`) is no more efficient than the general call at all, but can be used in cases where a single callable is required and is more efficient, concise and descriptive than `functools.partial`. ### `data.Dispatcher`: arbitrary multiple-dispatch operations. ```python; >>> import scipy.sparse; >>> import numpy as np; >>> a = data.CSR(scipy.sparse.csr_matrix(np.random.rand(5, 5))); >>> b = data.Dense(np.random.rand(5, 5)); >>> data.add(a, b); Dense(shape=(5, 5), fortran=True); >>> data.add(a, b, out=data.CSR); CSR(shape=(5, 5), nnz=25); ```. ```python; >>> data.add[data.CSR, data.Dense]; <indirect specialisation (CSR, Dense, Dense) of add>; >>> data.add[data.CSR, data.CSR, data.CSR]; <direct specialisation (CSR, CSR, CSR) of add>; ```. #### Basic usage. A `Dispatcher` provides a single mathematical function for _all_ combinations of types known by `data.to`, regardless of whether the particular specialisation has been defined for the input data types. In the first example above, the operator `data.add` currently only knows two specialisations; it knows how to add `CSR + CSR ->",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1338
https://github.com/qutip/qutip/pull/1338:6837,Energy Efficiency,efficient,efficient,6837,"speed-efficiency here, since we expect there to be few data-layer types, but for the calls to happen millions of times. The converters returned by single-key access (e.g. `data.to[data.Dense]`) are constructed individually on a call to `__getitem__`, and are instances of the private type `data.convert._partial_converter`, which internally stores a reference to every ""full"" converter, and dispatches to the correct one when called. The entire `data.to` object and all subsidiary `_converter` and `_partial_converter` objects are `pickle`-able. . #### Efficiency notes. From an efficiency perspective, there is very little benefit to using the key-lookup syntax. Internally, `to(to_type, data)` effectively calls `to[to_type, type(data)]`, so storing the object elides the creation of a single tuple and a dict lookup, but the cost of this is generally less than 500ns. Using the one-argument lookup (e.g. `to[Dense]`) is no more efficient than the general call at all, but can be used in cases where a single callable is required and is more efficient, concise and descriptive than `functools.partial`. ### `data.Dispatcher`: arbitrary multiple-dispatch operations. ```python; >>> import scipy.sparse; >>> import numpy as np; >>> a = data.CSR(scipy.sparse.csr_matrix(np.random.rand(5, 5))); >>> b = data.Dense(np.random.rand(5, 5)); >>> data.add(a, b); Dense(shape=(5, 5), fortran=True); >>> data.add(a, b, out=data.CSR); CSR(shape=(5, 5), nnz=25); ```. ```python; >>> data.add[data.CSR, data.Dense]; <indirect specialisation (CSR, Dense, Dense) of add>; >>> data.add[data.CSR, data.CSR, data.CSR]; <direct specialisation (CSR, CSR, CSR) of add>; ```. #### Basic usage. A `Dispatcher` provides a single mathematical function for _all_ combinations of types known by `data.to`, regardless of whether the particular specialisation has been defined for the input data types. In the first example above, the operator `data.add` currently only knows two specialisations; it knows how to add `CSR + CSR ->",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1338
https://github.com/qutip/qutip/pull/1338:9947,Energy Efficiency,efficient,efficiently,9947,"ython; >>> data.pow[data.CSR]; <direct specialisation (CSR, CSR) of pow>; >>> data.pow[data.CSR].direct; True; >>> data.pow[data.CSR, data.Dense].direct; False; ```; The returned object is callable with the same signature as the dispatcher (except the `out` keyword argument is no longer there), and requires that the inputs match the types stated. #### Adding new specialisations. New specialisations can be added to a pre-existing dispatcher with the `Dispatcher.add_specialisations` method. This is very similar in form to `data.to.add_conversions`; it takes lists of tuples, where the first elements of the tuple define the types in the specialisation, and the last is the specialised function itself. For example, a user might need to multiply `Dense @ CSR` frequently and get a `Dense` output. Currently, there is no direct specialisation for this:; ```python; >>> data.matmul[Dense, CSR, Dense]; <indirect specialisation (Dense, CSR, Dense) of matmul>; ```; The user may then choose to define their own specialisation to handle this case efficiently:; ```python; >>> def matmul_1(left: Dense, right: CSR) -> Dense:; ... # [...]; ... return out; ```; They would give this to `data.matmul` by calling; ```python; >>> data.matmul.add_specialisations([; ... (Dense, CSR, Dense, matmul_1),; ... ]); ```; Now we find; ```python; >>> data.matmul[Dense, CSR, Dense]; <direct specialisation (Dense, CSR, Dense) of matmul>; ```. Additionally, the whole lookup table will be rebuilt taking this new specialisation into account, which means the indirect specialisation `matmul(Dense, CSR) -> CSR` will now make use of this new method, because it has a low conversion weight. #### Adding new types. Now let's say the user wants to add a new `NewDataType` type all across QuTiP. The only action they _must_ take is to tell `data.to` about this new type. Let's say they define it like this:; ```python; >>> class NewDataType:; ... # [...]; >>> def new_from_dense(matrix: data.Dense) -> NewDataType:; ... # [.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1338
https://github.com/qutip/qutip/pull/1338:1308,Integrability,rout,routine,1308,"algorithms and better cache usage in places, but its principle advantage was the massive reduction in overhead for function calls between Python and C space, which largely affected small objects. The full aim, however, is to have QuTiP 5 support many different data representations as the backing of `Qobj`, and use the most suitable representation for the given data. This will not require every single QuTiP function to have an exponential number of versions for every possible combination of inputs, but only to have specialisations for the most common data combinations. This concept is the ""data layer"". All code examples in this PR are prefixed with. ```python; >>> from qutip.core import data; ```. ## Specification. The core to achieving this is fast, fully specified inter-conversion between all known data types, and efficient multiple-dispatch for mathematical operations. There are then four principle components of the data-layer:. 1. a creation routine which returns an appropriate data-layer type given some arbitrary Python object (`data.create`); 2. a routine which can perform the conversion from any data-layer type to any other data-layer type (`data.to`); 3. completely specialised mathematical operations (e.g. `data.add_csr_dense_dense(CSR, Dense) -> Dense`); 4. an object which provides multiple dispatch operations on its input arguments to use an exact specialisation (defined in item 3) if known, or uses the conversion routine (item 2) to convert the inputs into ones matching a specialisation if not: `data.Dispatcher`. The exported mathematical functions will all be instances of this type. The minimum work needed to define a new data-layer type is to provide `data.to` with two conversion functions; one into the new type from a current data-layer type, and one which converts the new type _into_ a current data-layer type. Once this is done, every single QuTiP component will be able to use the new data-layer type, although until specialisations are given which use i",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1338
https://github.com/qutip/qutip/pull/1338:1418,Integrability,rout,routine,1418,"ction calls between Python and C space, which largely affected small objects. The full aim, however, is to have QuTiP 5 support many different data representations as the backing of `Qobj`, and use the most suitable representation for the given data. This will not require every single QuTiP function to have an exponential number of versions for every possible combination of inputs, but only to have specialisations for the most common data combinations. This concept is the ""data layer"". All code examples in this PR are prefixed with. ```python; >>> from qutip.core import data; ```. ## Specification. The core to achieving this is fast, fully specified inter-conversion between all known data types, and efficient multiple-dispatch for mathematical operations. There are then four principle components of the data-layer:. 1. a creation routine which returns an appropriate data-layer type given some arbitrary Python object (`data.create`); 2. a routine which can perform the conversion from any data-layer type to any other data-layer type (`data.to`); 3. completely specialised mathematical operations (e.g. `data.add_csr_dense_dense(CSR, Dense) -> Dense`); 4. an object which provides multiple dispatch operations on its input arguments to use an exact specialisation (defined in item 3) if known, or uses the conversion routine (item 2) to convert the inputs into ones matching a specialisation if not: `data.Dispatcher`. The exported mathematical functions will all be instances of this type. The minimum work needed to define a new data-layer type is to provide `data.to` with two conversion functions; one into the new type from a current data-layer type, and one which converts the new type _into_ a current data-layer type. Once this is done, every single QuTiP component will be able to use the new data-layer type, although until specialisations are given which use it, it will always be achieved by conversion to another type, and conversion back. In this way, a new type can be added",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1338
https://github.com/qutip/qutip/pull/1338:1796,Integrability,rout,routine,1796,"function to have an exponential number of versions for every possible combination of inputs, but only to have specialisations for the most common data combinations. This concept is the ""data layer"". All code examples in this PR are prefixed with. ```python; >>> from qutip.core import data; ```. ## Specification. The core to achieving this is fast, fully specified inter-conversion between all known data types, and efficient multiple-dispatch for mathematical operations. There are then four principle components of the data-layer:. 1. a creation routine which returns an appropriate data-layer type given some arbitrary Python object (`data.create`); 2. a routine which can perform the conversion from any data-layer type to any other data-layer type (`data.to`); 3. completely specialised mathematical operations (e.g. `data.add_csr_dense_dense(CSR, Dense) -> Dense`); 4. an object which provides multiple dispatch operations on its input arguments to use an exact specialisation (defined in item 3) if known, or uses the conversion routine (item 2) to convert the inputs into ones matching a specialisation if not: `data.Dispatcher`. The exported mathematical functions will all be instances of this type. The minimum work needed to define a new data-layer type is to provide `data.to` with two conversion functions; one into the new type from a current data-layer type, and one which converts the new type _into_ a current data-layer type. Once this is done, every single QuTiP component will be able to use the new data-layer type, although until specialisations are given which use it, it will always be achieved by conversion to another type, and conversion back. In this way, a new type can be added incrementally, with only the most common operations needing to be defined to get good efficiency. **Important caveat:** the data layer operates only on _exact_ types; subclasses of defined types will be treated as completely different types. This is to do with keeping the computational comp",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1338
https://github.com/qutip/qutip/pull/1338:16336,Integrability,depend,dependency,16336,"ure (except ones which use `*args` or `**kwargs`), even if not all of the arguments are data-layer types. At definition, the creator of the `Dispatcher` says which input arguments are meant to be dispatched on, and whether the output should be dispatched on, and all other arguments are passed through like normal. #### Implementation details. The backing specialisations can be found in `Dispatcher._specialisations`, and the complete lookup table is in `Dispatcher._lookup`. These are marked as private, because messing around with them will almost certainly cause the dispatcher to stop working. Only one specialisation needs to be defined for a dispatcher to work with _all_ data types known by `data.to`. We achieve this because `data.to` guarantees that all possible conversions between data types will exist, so `data.Dispatcher` can always convert its inputs into those which will match one of its known specialisations. Within the initialisation of the data layer, we use a ""magic"" `_defer` keyword argument to `add_specialisations` to break a circular dependency. This is because the ""type"" modules `data.csr` and `data.dense` depend on some mathematical modules (e.g. `add` and `matmul`) to provide the `__add__` and similar methods on the types. For ease of development we want the dispatchers to be defined in the same modules that all the specialisations are (though this is not at all necessary), but the dispatchers require `data.to` to be populated with the types before specialisations can be added. The `_defer` keyword here just defers the building of the lookup table until an explicit call to `Dispatcher.rebuild_lookup()`, breaking the cycle. The user will never need to do this, because by the time they receive the `Dispatcher` object, `data.to` is already initialised to a minimum degree. #### Efficiency notes. The specialisations returned by the `__getitem__` lookups are not significantly faster than just calling the dispatcher directly, because the bulk of the heavy lif",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1338
https://github.com/qutip/qutip/pull/1338:16411,Integrability,depend,depend,16411,"says which input arguments are meant to be dispatched on, and whether the output should be dispatched on, and all other arguments are passed through like normal. #### Implementation details. The backing specialisations can be found in `Dispatcher._specialisations`, and the complete lookup table is in `Dispatcher._lookup`. These are marked as private, because messing around with them will almost certainly cause the dispatcher to stop working. Only one specialisation needs to be defined for a dispatcher to work with _all_ data types known by `data.to`. We achieve this because `data.to` guarantees that all possible conversions between data types will exist, so `data.Dispatcher` can always convert its inputs into those which will match one of its known specialisations. Within the initialisation of the data layer, we use a ""magic"" `_defer` keyword argument to `add_specialisations` to break a circular dependency. This is because the ""type"" modules `data.csr` and `data.dense` depend on some mathematical modules (e.g. `add` and `matmul`) to provide the `__add__` and similar methods on the types. For ease of development we want the dispatchers to be defined in the same modules that all the specialisations are (though this is not at all necessary), but the dispatchers require `data.to` to be populated with the types before specialisations can be added. The `_defer` keyword here just defers the building of the lookup table until an explicit call to `Dispatcher.rebuild_lookup()`, breaking the cycle. The user will never need to do this, because by the time they receive the `Dispatcher` object, `data.to` is already initialised to a minimum degree. #### Efficiency notes. The specialisations returned by the `__getitem__` lookups are not significantly faster than just calling the dispatcher directly, because the bulk of the heavy lifting is done when `add_specialisations` or `rebuild_lookup` is called. On call, the generic signature `(*args, **kwargs)` has to be bound to the actual ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1338
https://github.com/qutip/qutip/pull/1338:2880,Modifiability,inherit,inheritance,2880,"g a specialisation if not: `data.Dispatcher`. The exported mathematical functions will all be instances of this type. The minimum work needed to define a new data-layer type is to provide `data.to` with two conversion functions; one into the new type from a current data-layer type, and one which converts the new type _into_ a current data-layer type. Once this is done, every single QuTiP component will be able to use the new data-layer type, although until specialisations are given which use it, it will always be achieved by conversion to another type, and conversion back. In this way, a new type can be added incrementally, with only the most common operations needing to be defined to get good efficiency. **Important caveat:** the data layer operates only on _exact_ types; subclasses of defined types will be treated as completely different types. This is to do with keeping the computational complexity of multiple-dispatch operations as O(1) (i.e. I don't know how to do multiple dispatch in constant time allowing inheritance). ### `data.to`: conversion between types. ```python; >>> matrix = data.dense.identity(5); >>> matrix; Dense(shape=(5, 5), fortran=True); >>> data.to(data.CSR, matrix); CSR(shape=(5, 5), nnz=5); ```. ```python; >>> data.to[data.CSR, data.Dense]; <converter to CSR from Dense>; ```. ```python; >>> data.to[data.Dense]; <converter to Dense>; ```. ```python; >>> class NewDataType:; ... # [...]; >>> def new_from_dense(matrix: data.Dense) -> NewDataType:; ... # [...]; >>> def dense_from_new(matrix: NewDataType) -> data.Dense:; ... # [...]; >>> data.to.add_conversions([; ... (NewDataType, data.Dense, new_from_dense),; ... (data.Dense, NewDataType, dense_from_new),; ... ]); >>> data.to[data.CSR, NewDataType]; <converter to CSR from NewDataType>; ```. #### Basic usage. Convert data into a different type. This object is the knowledge source for every allowable data-layer type in QuTiP, and provides the conversions between all of them. The base use is to call",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1338
https://github.com/qutip/qutip/pull/1338:371,Performance,cache,cache,371,"Data-layer type creation, conversion and dispatch; =================================================. ## Background. Previously in #1332, the old `fast_csr_matrix` type was replaced by the new, custom `CSR` type as the data backing for `Qobj`, and all internal QuTiP data representations. This produced some speed-ups in some places due to improved algorithms and better cache usage in places, but its principle advantage was the massive reduction in overhead for function calls between Python and C space, which largely affected small objects. The full aim, however, is to have QuTiP 5 support many different data representations as the backing of `Qobj`, and use the most suitable representation for the given data. This will not require every single QuTiP function to have an exponential number of versions for every possible combination of inputs, but only to have specialisations for the most common data combinations. This concept is the ""data layer"". All code examples in this PR are prefixed with. ```python; >>> from qutip.core import data; ```. ## Specification. The core to achieving this is fast, fully specified inter-conversion between all known data types, and efficient multiple-dispatch for mathematical operations. There are then four principle components of the data-layer:. 1. a creation routine which returns an appropriate data-layer type given some arbitrary Python object (`data.create`); 2. a routine which can perform the conversion from any data-layer type to any other data-layer type (`data.to`); 3. completely specialised mathematical operations (e.g. `data.add_csr_dense_dense(CSR, Dense) -> Dense`); 4. an object which provides multiple dispatch operations on its input arguments to use an exact specialisation (defined in item 3) if known, or uses the conversion routine (item 2) to convert the inputs into ones matching a specialisation if not: `data.Dispatcher`. The exported mathematical functions will all be instances of this type. The minimum work needed to defi",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1338
https://github.com/qutip/qutip/pull/1338:1436,Performance,perform,perform,1436,"ction calls between Python and C space, which largely affected small objects. The full aim, however, is to have QuTiP 5 support many different data representations as the backing of `Qobj`, and use the most suitable representation for the given data. This will not require every single QuTiP function to have an exponential number of versions for every possible combination of inputs, but only to have specialisations for the most common data combinations. This concept is the ""data layer"". All code examples in this PR are prefixed with. ```python; >>> from qutip.core import data; ```. ## Specification. The core to achieving this is fast, fully specified inter-conversion between all known data types, and efficient multiple-dispatch for mathematical operations. There are then four principle components of the data-layer:. 1. a creation routine which returns an appropriate data-layer type given some arbitrary Python object (`data.create`); 2. a routine which can perform the conversion from any data-layer type to any other data-layer type (`data.to`); 3. completely specialised mathematical operations (e.g. `data.add_csr_dense_dense(CSR, Dense) -> Dense`); 4. an object which provides multiple dispatch operations on its input arguments to use an exact specialisation (defined in item 3) if known, or uses the conversion routine (item 2) to convert the inputs into ones matching a specialisation if not: `data.Dispatcher`. The exported mathematical functions will all be instances of this type. The minimum work needed to define a new data-layer type is to provide `data.to` with two conversion functions; one into the new type from a current data-layer type, and one which converts the new type _into_ a current data-layer type. Once this is done, every single QuTiP component will be able to use the new data-layer type, although until specialisations are given which use it, it will always be achieved by conversion to another type, and conversion back. In this way, a new type can be added",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1338
https://github.com/qutip/qutip/pull/1338:17657,Safety,safe,safely,17657,"kup table is in `Dispatcher._lookup`. These are marked as private, because messing around with them will almost certainly cause the dispatcher to stop working. Only one specialisation needs to be defined for a dispatcher to work with _all_ data types known by `data.to`. We achieve this because `data.to` guarantees that all possible conversions between data types will exist, so `data.Dispatcher` can always convert its inputs into those which will match one of its known specialisations. Within the initialisation of the data layer, we use a ""magic"" `_defer` keyword argument to `add_specialisations` to break a circular dependency. This is because the ""type"" modules `data.csr` and `data.dense` depend on some mathematical modules (e.g. `add` and `matmul`) to provide the `__add__` and similar methods on the types. For ease of development we want the dispatchers to be defined in the same modules that all the specialisations are (though this is not at all necessary), but the dispatchers require `data.to` to be populated with the types before specialisations can be added. The `_defer` keyword here just defers the building of the lookup table until an explicit call to `Dispatcher.rebuild_lookup()`, breaking the cycle. The user will never need to do this, because by the time they receive the `Dispatcher` object, `data.to` is already initialised to a minimum degree. #### Efficiency notes. The specialisations returned by the `__getitem__` lookups are not significantly faster than just calling the dispatcher directly, because the bulk of the heavy lifting is done when `add_specialisations` or `rebuild_lookup` is called. On call, the generic signature `(*args, **kwargs)` has to be bound to the actual signature of the underlying operation, regardless of whether the specialisation has already been found. At the Cython level there is short-circuit access to the call machinery in the specialisations themselves, but this cannot be safely exposed outside of the `Dispatcher` class itself.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1338
https://github.com/qutip/qutip/pull/1338:5951,Security,access,access,5951,"ve the fastest connectivity. #### Adding new types. You can add new data-layer types by calling the `add_conversions` method of this object, and then rebuilding all of the mathematical dispatchers. See the docstring of that method for more information. #### Implementation details. Not all conversions have to be specified for a new type; it is enough to have just one to and from a known type to a new type. The rest of the conversion graph is built up by graph traversal over known types (the graph is reconstructed whenever `add_conversions` is called), where the approximate cost of each function is used as the weight of an ""edge"" joining two data-layer type ""vertices"". The shortest path conversion function is constructed and stored (as the interal type `data.convert._converter`) for each pair of types. We willingly sacrifice memory efficiency for speed-efficiency here, since we expect there to be few data-layer types, but for the calls to happen millions of times. The converters returned by single-key access (e.g. `data.to[data.Dense]`) are constructed individually on a call to `__getitem__`, and are instances of the private type `data.convert._partial_converter`, which internally stores a reference to every ""full"" converter, and dispatches to the correct one when called. The entire `data.to` object and all subsidiary `_converter` and `_partial_converter` objects are `pickle`-able. . #### Efficiency notes. From an efficiency perspective, there is very little benefit to using the key-lookup syntax. Internally, `to(to_type, data)` effectively calls `to[to_type, type(data)]`, so storing the object elides the creation of a single tuple and a dict lookup, but the cost of this is generally less than 500ns. Using the one-argument lookup (e.g. `to[Dense]`) is no more efficient than the general call at all, but can be used in cases where a single callable is required and is more efficient, concise and descriptive than `functools.partial`. ### `data.Dispatcher`: arbitrary multip",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1338
https://github.com/qutip/qutip/pull/1338:17574,Security,access,access,17574,"kup table is in `Dispatcher._lookup`. These are marked as private, because messing around with them will almost certainly cause the dispatcher to stop working. Only one specialisation needs to be defined for a dispatcher to work with _all_ data types known by `data.to`. We achieve this because `data.to` guarantees that all possible conversions between data types will exist, so `data.Dispatcher` can always convert its inputs into those which will match one of its known specialisations. Within the initialisation of the data layer, we use a ""magic"" `_defer` keyword argument to `add_specialisations` to break a circular dependency. This is because the ""type"" modules `data.csr` and `data.dense` depend on some mathematical modules (e.g. `add` and `matmul`) to provide the `__add__` and similar methods on the types. For ease of development we want the dispatchers to be defined in the same modules that all the specialisations are (though this is not at all necessary), but the dispatchers require `data.to` to be populated with the types before specialisations can be added. The `_defer` keyword here just defers the building of the lookup table until an explicit call to `Dispatcher.rebuild_lookup()`, breaking the cycle. The user will never need to do this, because by the time they receive the `Dispatcher` object, `data.to` is already initialised to a minimum degree. #### Efficiency notes. The specialisations returned by the `__getitem__` lookups are not significantly faster than just calling the dispatcher directly, because the bulk of the heavy lifting is done when `add_specialisations` or `rebuild_lookup` is called. On call, the generic signature `(*args, **kwargs)` has to be bound to the actual signature of the underlying operation, regardless of whether the specialisation has already been found. At the Cython level there is short-circuit access to the call machinery in the specialisations themselves, but this cannot be safely exposed outside of the `Dispatcher` class itself.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1338
https://github.com/qutip/qutip/pull/1338:17664,Security,expose,exposed,17664,"kup table is in `Dispatcher._lookup`. These are marked as private, because messing around with them will almost certainly cause the dispatcher to stop working. Only one specialisation needs to be defined for a dispatcher to work with _all_ data types known by `data.to`. We achieve this because `data.to` guarantees that all possible conversions between data types will exist, so `data.Dispatcher` can always convert its inputs into those which will match one of its known specialisations. Within the initialisation of the data layer, we use a ""magic"" `_defer` keyword argument to `add_specialisations` to break a circular dependency. This is because the ""type"" modules `data.csr` and `data.dense` depend on some mathematical modules (e.g. `add` and `matmul`) to provide the `__add__` and similar methods on the types. For ease of development we want the dispatchers to be defined in the same modules that all the specialisations are (though this is not at all necessary), but the dispatchers require `data.to` to be populated with the types before specialisations can be added. The `_defer` keyword here just defers the building of the lookup table until an explicit call to `Dispatcher.rebuild_lookup()`, breaking the cycle. The user will never need to do this, because by the time they receive the `Dispatcher` object, `data.to` is already initialised to a minimum degree. #### Efficiency notes. The specialisations returned by the `__getitem__` lookups are not significantly faster than just calling the dispatcher directly, because the bulk of the heavy lifting is done when `add_specialisations` or `rebuild_lookup` is called. On call, the generic signature `(*args, **kwargs)` has to be bound to the actual signature of the underlying operation, regardless of whether the specialisation has already been found. At the Cython level there is short-circuit access to the call machinery in the specialisations themselves, but this cannot be safely exposed outside of the `Dispatcher` class itself.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1338
https://github.com/qutip/qutip/pull/1338:12264,Usability,simpl,simply,12264," define all operations in the data layer as well:; ```python; >>> data.matmul[NewDataType, data.CSR]; <indirect specialisation (NewDataType, CSR, CSR) of matmul>; ```; All of the data layer will now work seamlessly with the new type, even though this is actually achieved by conversion to and from a known data type. There was no need to call anything other than `data.to.add_conversions`. Internally, this is achieved by `data.Dispatcher.__init__` storing a reference to itself in `data.to`, and `data.to` calling `rebuild_lookup` as part of `add_conversions`. Now the user only needs to add in the specialisations that they actually need for the bottle-neck parts of their application, and leave the dispatcher to handle all other minor components by automatic conversion. As in the previous subsection, they do this by calling `add_specialisations` on the relevant operations. #### Creating a new dispatcher. In most user-defined functions which operate on `Qobj.data` it will be completely sufficient for them to simply call `data.to(desired_type, input_data)` on entry to the function, and then they can guarantee that they are always working with the type of data they support. However, in some cases they may want to support dispatched operations in the same way that we do within the library code. For this reason, the data layer exports `Dispatcher` as a public symbol. The minimal amount of work that needs to be done is to call the initialiser, and then call `add_specialisations`. For example, let's say the user has defined two specialisations for their simple new function `add_square`:; ```python; >>> def add_square_csr(left, right):; ... return data.add_csr(left, data.matmul_csr(right, right)); ...; >>> def add_square_dense(left, right):; ... return data.add_dense(left, data.matmul_dense(right, right)); ...; ```; (Ignore for now that this would be better achieved by just using the dispatchers `data.add` and `data.matmul` directly.) Now they create the dispatcher simply by doing",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1338
https://github.com/qutip/qutip/pull/1338:12814,Usability,simpl,simple,12814,"er only needs to add in the specialisations that they actually need for the bottle-neck parts of their application, and leave the dispatcher to handle all other minor components by automatic conversion. As in the previous subsection, they do this by calling `add_specialisations` on the relevant operations. #### Creating a new dispatcher. In most user-defined functions which operate on `Qobj.data` it will be completely sufficient for them to simply call `data.to(desired_type, input_data)` on entry to the function, and then they can guarantee that they are always working with the type of data they support. However, in some cases they may want to support dispatched operations in the same way that we do within the library code. For this reason, the data layer exports `Dispatcher` as a public symbol. The minimal amount of work that needs to be done is to call the initialiser, and then call `add_specialisations`. For example, let's say the user has defined two specialisations for their simple new function `add_square`:; ```python; >>> def add_square_csr(left, right):; ... return data.add_csr(left, data.matmul_csr(right, right)); ...; >>> def add_square_dense(left, right):; ... return data.add_dense(left, data.matmul_dense(right, right)); ...; ```; (Ignore for now that this would be better achieved by just using the dispatchers `data.add` and `data.matmul` directly.) Now they create the dispatcher simply by doing; ```python; >>> add_square = data.Dispatcher(add_square_csr, inputs=('left', 'right'), name='add_square', out=True); >>> add_square.add_specialisations([; ... (data.CSR, data.CSR, data.CSR, add_square_csr),; ... (data.Dense, data.Dense, data.Dense, add_square_dense),; ... ]); ```; This is enough for `Dispatcher` to have extracted the signature and satisfied all of the specialisations. Note that the `inputs` argument does not provide the signature, it tells the dispatcher which arguments are data-layer types it should dispatch on, e.g. for `data.pow` as defined abo",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1338
https://github.com/qutip/qutip/pull/1338:13233,Usability,simpl,simply,13233,"sufficient for them to simply call `data.to(desired_type, input_data)` on entry to the function, and then they can guarantee that they are always working with the type of data they support. However, in some cases they may want to support dispatched operations in the same way that we do within the library code. For this reason, the data layer exports `Dispatcher` as a public symbol. The minimal amount of work that needs to be done is to call the initialiser, and then call `add_specialisations`. For example, let's say the user has defined two specialisations for their simple new function `add_square`:; ```python; >>> def add_square_csr(left, right):; ... return data.add_csr(left, data.matmul_csr(right, right)); ...; >>> def add_square_dense(left, right):; ... return data.add_dense(left, data.matmul_dense(right, right)); ...; ```; (Ignore for now that this would be better achieved by just using the dispatchers `data.add` and `data.matmul` directly.) Now they create the dispatcher simply by doing; ```python; >>> add_square = data.Dispatcher(add_square_csr, inputs=('left', 'right'), name='add_square', out=True); >>> add_square.add_specialisations([; ... (data.CSR, data.CSR, data.CSR, add_square_csr),; ... (data.Dense, data.Dense, data.Dense, add_square_dense),; ... ]); ```; This is enough for `Dispatcher` to have extracted the signature and satisfied all of the specialisations. Note that the `inputs` argument does not provide the signature, it tells the dispatcher which arguments are data-layer types it should dispatch on, e.g. for `data.pow` as defined above `inputs = ('matrix',)`, but the signature is `(matrix, n) -> out`. See that the specialisations are now complete:; ```python; >>> add_square; <dispatcher: add_square(left, right)>; >>> add_square[data.Dense, data.CSR, data.CSR]; <indirect specialisation (Dense, CSR, CSR) of add_square>; ```. In the initialisation, the function `add_square_csr` is passed as an example from which `Dispatcher` extracts the call signatur",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1338
https://github.com/qutip/qutip/issues/1339:152,Energy Efficiency,reduce,reduced,152,"In #1332 there is a huge drop in reported test coverage by Coveralls. This is because large tracts of the most-tested Python files were either severely reduced in length, or converted to Cython files, and it seems that Coveralls does not correctly handle Cython; it reports the existence of a `x.py` file for every `x.pyx` file that exists, with the `.py` file having 7 lines, all of which are apparently untested. The new data-layer types _are_ tested albeit not as completely as they will be once they're finished, but Coveralls has reported a huge drop in coverage. I don't know if any coverage estimators exist for Cython (I would expect not due to their compiled nature), but it's perhaps something we should consider. Also, Coveralls counts the test files as part of its coverage indicator. By my rough count, there are 42,223 SLOC in `qutip` (i.e. excluding comments and whitespace but unfortunately including docstrings), of which 11,259 are in `qutip/tests`. Aside from a couple of skipped tests, 100% of the lines in `qutip/tests` will be run, so if we produce a modified coverage report, having 61% of the SLOC covered in _all_ of `qutip` is equivalent to; ```python; >>> (0.61*42_223 - 1.00*11_259) / (42_223 - 11_259); 0.4681898; ```; **46.8% true coverage**. We probably could really do with a concerted effort to add more tests of all the little nuances of the code.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1339
https://github.com/qutip/qutip/issues/1339:42,Testability,test,test,42,"In #1332 there is a huge drop in reported test coverage by Coveralls. This is because large tracts of the most-tested Python files were either severely reduced in length, or converted to Cython files, and it seems that Coveralls does not correctly handle Cython; it reports the existence of a `x.py` file for every `x.pyx` file that exists, with the `.py` file having 7 lines, all of which are apparently untested. The new data-layer types _are_ tested albeit not as completely as they will be once they're finished, but Coveralls has reported a huge drop in coverage. I don't know if any coverage estimators exist for Cython (I would expect not due to their compiled nature), but it's perhaps something we should consider. Also, Coveralls counts the test files as part of its coverage indicator. By my rough count, there are 42,223 SLOC in `qutip` (i.e. excluding comments and whitespace but unfortunately including docstrings), of which 11,259 are in `qutip/tests`. Aside from a couple of skipped tests, 100% of the lines in `qutip/tests` will be run, so if we produce a modified coverage report, having 61% of the SLOC covered in _all_ of `qutip` is equivalent to; ```python; >>> (0.61*42_223 - 1.00*11_259) / (42_223 - 11_259); 0.4681898; ```; **46.8% true coverage**. We probably could really do with a concerted effort to add more tests of all the little nuances of the code.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1339
https://github.com/qutip/qutip/issues/1339:111,Testability,test,tested,111,"In #1332 there is a huge drop in reported test coverage by Coveralls. This is because large tracts of the most-tested Python files were either severely reduced in length, or converted to Cython files, and it seems that Coveralls does not correctly handle Cython; it reports the existence of a `x.py` file for every `x.pyx` file that exists, with the `.py` file having 7 lines, all of which are apparently untested. The new data-layer types _are_ tested albeit not as completely as they will be once they're finished, but Coveralls has reported a huge drop in coverage. I don't know if any coverage estimators exist for Cython (I would expect not due to their compiled nature), but it's perhaps something we should consider. Also, Coveralls counts the test files as part of its coverage indicator. By my rough count, there are 42,223 SLOC in `qutip` (i.e. excluding comments and whitespace but unfortunately including docstrings), of which 11,259 are in `qutip/tests`. Aside from a couple of skipped tests, 100% of the lines in `qutip/tests` will be run, so if we produce a modified coverage report, having 61% of the SLOC covered in _all_ of `qutip` is equivalent to; ```python; >>> (0.61*42_223 - 1.00*11_259) / (42_223 - 11_259); 0.4681898; ```; **46.8% true coverage**. We probably could really do with a concerted effort to add more tests of all the little nuances of the code.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1339
https://github.com/qutip/qutip/issues/1339:446,Testability,test,tested,446,"In #1332 there is a huge drop in reported test coverage by Coveralls. This is because large tracts of the most-tested Python files were either severely reduced in length, or converted to Cython files, and it seems that Coveralls does not correctly handle Cython; it reports the existence of a `x.py` file for every `x.pyx` file that exists, with the `.py` file having 7 lines, all of which are apparently untested. The new data-layer types _are_ tested albeit not as completely as they will be once they're finished, but Coveralls has reported a huge drop in coverage. I don't know if any coverage estimators exist for Cython (I would expect not due to their compiled nature), but it's perhaps something we should consider. Also, Coveralls counts the test files as part of its coverage indicator. By my rough count, there are 42,223 SLOC in `qutip` (i.e. excluding comments and whitespace but unfortunately including docstrings), of which 11,259 are in `qutip/tests`. Aside from a couple of skipped tests, 100% of the lines in `qutip/tests` will be run, so if we produce a modified coverage report, having 61% of the SLOC covered in _all_ of `qutip` is equivalent to; ```python; >>> (0.61*42_223 - 1.00*11_259) / (42_223 - 11_259); 0.4681898; ```; **46.8% true coverage**. We probably could really do with a concerted effort to add more tests of all the little nuances of the code.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1339
https://github.com/qutip/qutip/issues/1339:751,Testability,test,test,751,"In #1332 there is a huge drop in reported test coverage by Coveralls. This is because large tracts of the most-tested Python files were either severely reduced in length, or converted to Cython files, and it seems that Coveralls does not correctly handle Cython; it reports the existence of a `x.py` file for every `x.pyx` file that exists, with the `.py` file having 7 lines, all of which are apparently untested. The new data-layer types _are_ tested albeit not as completely as they will be once they're finished, but Coveralls has reported a huge drop in coverage. I don't know if any coverage estimators exist for Cython (I would expect not due to their compiled nature), but it's perhaps something we should consider. Also, Coveralls counts the test files as part of its coverage indicator. By my rough count, there are 42,223 SLOC in `qutip` (i.e. excluding comments and whitespace but unfortunately including docstrings), of which 11,259 are in `qutip/tests`. Aside from a couple of skipped tests, 100% of the lines in `qutip/tests` will be run, so if we produce a modified coverage report, having 61% of the SLOC covered in _all_ of `qutip` is equivalent to; ```python; >>> (0.61*42_223 - 1.00*11_259) / (42_223 - 11_259); 0.4681898; ```; **46.8% true coverage**. We probably could really do with a concerted effort to add more tests of all the little nuances of the code.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1339
https://github.com/qutip/qutip/issues/1339:960,Testability,test,tests,960,"In #1332 there is a huge drop in reported test coverage by Coveralls. This is because large tracts of the most-tested Python files were either severely reduced in length, or converted to Cython files, and it seems that Coveralls does not correctly handle Cython; it reports the existence of a `x.py` file for every `x.pyx` file that exists, with the `.py` file having 7 lines, all of which are apparently untested. The new data-layer types _are_ tested albeit not as completely as they will be once they're finished, but Coveralls has reported a huge drop in coverage. I don't know if any coverage estimators exist for Cython (I would expect not due to their compiled nature), but it's perhaps something we should consider. Also, Coveralls counts the test files as part of its coverage indicator. By my rough count, there are 42,223 SLOC in `qutip` (i.e. excluding comments and whitespace but unfortunately including docstrings), of which 11,259 are in `qutip/tests`. Aside from a couple of skipped tests, 100% of the lines in `qutip/tests` will be run, so if we produce a modified coverage report, having 61% of the SLOC covered in _all_ of `qutip` is equivalent to; ```python; >>> (0.61*42_223 - 1.00*11_259) / (42_223 - 11_259); 0.4681898; ```; **46.8% true coverage**. We probably could really do with a concerted effort to add more tests of all the little nuances of the code.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1339
https://github.com/qutip/qutip/issues/1339:999,Testability,test,tests,999,"In #1332 there is a huge drop in reported test coverage by Coveralls. This is because large tracts of the most-tested Python files were either severely reduced in length, or converted to Cython files, and it seems that Coveralls does not correctly handle Cython; it reports the existence of a `x.py` file for every `x.pyx` file that exists, with the `.py` file having 7 lines, all of which are apparently untested. The new data-layer types _are_ tested albeit not as completely as they will be once they're finished, but Coveralls has reported a huge drop in coverage. I don't know if any coverage estimators exist for Cython (I would expect not due to their compiled nature), but it's perhaps something we should consider. Also, Coveralls counts the test files as part of its coverage indicator. By my rough count, there are 42,223 SLOC in `qutip` (i.e. excluding comments and whitespace but unfortunately including docstrings), of which 11,259 are in `qutip/tests`. Aside from a couple of skipped tests, 100% of the lines in `qutip/tests` will be run, so if we produce a modified coverage report, having 61% of the SLOC covered in _all_ of `qutip` is equivalent to; ```python; >>> (0.61*42_223 - 1.00*11_259) / (42_223 - 11_259); 0.4681898; ```; **46.8% true coverage**. We probably could really do with a concerted effort to add more tests of all the little nuances of the code.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1339
https://github.com/qutip/qutip/issues/1339:1034,Testability,test,tests,1034,"In #1332 there is a huge drop in reported test coverage by Coveralls. This is because large tracts of the most-tested Python files were either severely reduced in length, or converted to Cython files, and it seems that Coveralls does not correctly handle Cython; it reports the existence of a `x.py` file for every `x.pyx` file that exists, with the `.py` file having 7 lines, all of which are apparently untested. The new data-layer types _are_ tested albeit not as completely as they will be once they're finished, but Coveralls has reported a huge drop in coverage. I don't know if any coverage estimators exist for Cython (I would expect not due to their compiled nature), but it's perhaps something we should consider. Also, Coveralls counts the test files as part of its coverage indicator. By my rough count, there are 42,223 SLOC in `qutip` (i.e. excluding comments and whitespace but unfortunately including docstrings), of which 11,259 are in `qutip/tests`. Aside from a couple of skipped tests, 100% of the lines in `qutip/tests` will be run, so if we produce a modified coverage report, having 61% of the SLOC covered in _all_ of `qutip` is equivalent to; ```python; >>> (0.61*42_223 - 1.00*11_259) / (42_223 - 11_259); 0.4681898; ```; **46.8% true coverage**. We probably could really do with a concerted effort to add more tests of all the little nuances of the code.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1339
https://github.com/qutip/qutip/issues/1339:1337,Testability,test,tests,1337,"In #1332 there is a huge drop in reported test coverage by Coveralls. This is because large tracts of the most-tested Python files were either severely reduced in length, or converted to Cython files, and it seems that Coveralls does not correctly handle Cython; it reports the existence of a `x.py` file for every `x.pyx` file that exists, with the `.py` file having 7 lines, all of which are apparently untested. The new data-layer types _are_ tested albeit not as completely as they will be once they're finished, but Coveralls has reported a huge drop in coverage. I don't know if any coverage estimators exist for Cython (I would expect not due to their compiled nature), but it's perhaps something we should consider. Also, Coveralls counts the test files as part of its coverage indicator. By my rough count, there are 42,223 SLOC in `qutip` (i.e. excluding comments and whitespace but unfortunately including docstrings), of which 11,259 are in `qutip/tests`. Aside from a couple of skipped tests, 100% of the lines in `qutip/tests` will be run, so if we produce a modified coverage report, having 61% of the SLOC covered in _all_ of `qutip` is equivalent to; ```python; >>> (0.61*42_223 - 1.00*11_259) / (42_223 - 11_259); 0.4681898; ```; **46.8% true coverage**. We probably could really do with a concerted effort to add more tests of all the little nuances of the code.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1339
https://github.com/qutip/qutip/pull/1342:438,Testability,test,tests,438,"**Description**; - Add product between `Qobj`, `QobjEvo` and `Coefficient`:; `QobjEvo([op, ""t""]) === op * coefficient(""t"")`; - `tensor` accept `QobjEvo`; - Overload `&` for tensor product for `Qobj` and `QobjEvo`:; `tensor(A, B) === A & B`; - Add `__matmul__` to `QobjEvo`.; - Remove call to `QobjEvo.compile` outside `qobjEvo.py`. (Always compiled); - Add `dims` and `shape` as read-only properties of `QobjEvo`.; - Reworked `QobjEvo`'s tests. ; - Found a bug in `liouvillian` with constant `QobjEvo` and `Qobj`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1342
https://github.com/qutip/qutip/pull/1347:469,Deployability,configurat,configuration,469,"In #1339 I pointed out that the test files were being incorrectly counted in the coverage statistics when running on Travis. This transpired to be because `coverage.py` wasn't able to find our `.coveragerc` file correctly when `pytest` was called in the manner it is on Travis. This PR then does a couple of things:; 1. correctly locates the `.coveragerc` file; 2. excludes the Cython bootstrapping code from being part of the coverage; 3. correctly locates the pytest configuration file `pytest.ini` (although now we have a `pyproject.toml`, we could move that configuration there); 4. completely reorganises `.travis.yml` to remove dead configs, properly share common setups, and generally make it a bit easier to read and see what's going on; 5. fixes file reporting in Coveralls (look at the ""tree"" tab in the Coveralls web report compared to the current `master`); you can now click on the files and get proper line-by-line detail on what was covered and what wasn't, e.g. [here's the report for `mcsolve.py`](https://coveralls.io/builds/32982136/source?filename=qutip/mcsolve.py). We _don't_ enable Cython line-tracing and coverage analysis. This is actually [quite easily possible](https://cython.readthedocs.io/en/latest/src/tutorial/profiling_tutorial.html#enabling-coverage-analysis), but enabling full tracing including on `nogil` functions absolutely tanks performance to the degree where the coverage Travis run would take well in excess of two hours to complete (I think Travis actually just kills things that run longer than 2 hours). I might return to the Cython elements to see how much of them when _can_ reasonably do coverage analysis on. My prediction about actual test coverage dropping once the test files are correctly omitted, which I mentioned in #1339, came true though not _quite_ as cataclysmically (`coverage.py` uses statements, not SLOC as its metric); coverage drops from ~71% to ~63%. Technically the true percentage is higher because the Cython code is generally ver",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1347
https://github.com/qutip/qutip/pull/1347:562,Deployability,configurat,configuration,562,"In #1339 I pointed out that the test files were being incorrectly counted in the coverage statistics when running on Travis. This transpired to be because `coverage.py` wasn't able to find our `.coveragerc` file correctly when `pytest` was called in the manner it is on Travis. This PR then does a couple of things:; 1. correctly locates the `.coveragerc` file; 2. excludes the Cython bootstrapping code from being part of the coverage; 3. correctly locates the pytest configuration file `pytest.ini` (although now we have a `pyproject.toml`, we could move that configuration there); 4. completely reorganises `.travis.yml` to remove dead configs, properly share common setups, and generally make it a bit easier to read and see what's going on; 5. fixes file reporting in Coveralls (look at the ""tree"" tab in the Coveralls web report compared to the current `master`); you can now click on the files and get proper line-by-line detail on what was covered and what wasn't, e.g. [here's the report for `mcsolve.py`](https://coveralls.io/builds/32982136/source?filename=qutip/mcsolve.py). We _don't_ enable Cython line-tracing and coverage analysis. This is actually [quite easily possible](https://cython.readthedocs.io/en/latest/src/tutorial/profiling_tutorial.html#enabling-coverage-analysis), but enabling full tracing including on `nogil` functions absolutely tanks performance to the degree where the coverage Travis run would take well in excess of two hours to complete (I think Travis actually just kills things that run longer than 2 hours). I might return to the Cython elements to see how much of them when _can_ reasonably do coverage analysis on. My prediction about actual test coverage dropping once the test files are correctly omitted, which I mentioned in #1339, came true though not _quite_ as cataclysmically (`coverage.py` uses statements, not SLOC as its metric); coverage drops from ~71% to ~63%. Technically the true percentage is higher because the Cython code is generally ver",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1347
https://github.com/qutip/qutip/pull/1347:469,Modifiability,config,configuration,469,"In #1339 I pointed out that the test files were being incorrectly counted in the coverage statistics when running on Travis. This transpired to be because `coverage.py` wasn't able to find our `.coveragerc` file correctly when `pytest` was called in the manner it is on Travis. This PR then does a couple of things:; 1. correctly locates the `.coveragerc` file; 2. excludes the Cython bootstrapping code from being part of the coverage; 3. correctly locates the pytest configuration file `pytest.ini` (although now we have a `pyproject.toml`, we could move that configuration there); 4. completely reorganises `.travis.yml` to remove dead configs, properly share common setups, and generally make it a bit easier to read and see what's going on; 5. fixes file reporting in Coveralls (look at the ""tree"" tab in the Coveralls web report compared to the current `master`); you can now click on the files and get proper line-by-line detail on what was covered and what wasn't, e.g. [here's the report for `mcsolve.py`](https://coveralls.io/builds/32982136/source?filename=qutip/mcsolve.py). We _don't_ enable Cython line-tracing and coverage analysis. This is actually [quite easily possible](https://cython.readthedocs.io/en/latest/src/tutorial/profiling_tutorial.html#enabling-coverage-analysis), but enabling full tracing including on `nogil` functions absolutely tanks performance to the degree where the coverage Travis run would take well in excess of two hours to complete (I think Travis actually just kills things that run longer than 2 hours). I might return to the Cython elements to see how much of them when _can_ reasonably do coverage analysis on. My prediction about actual test coverage dropping once the test files are correctly omitted, which I mentioned in #1339, came true though not _quite_ as cataclysmically (`coverage.py` uses statements, not SLOC as its metric); coverage drops from ~71% to ~63%. Technically the true percentage is higher because the Cython code is generally ver",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1347
https://github.com/qutip/qutip/pull/1347:562,Modifiability,config,configuration,562,"In #1339 I pointed out that the test files were being incorrectly counted in the coverage statistics when running on Travis. This transpired to be because `coverage.py` wasn't able to find our `.coveragerc` file correctly when `pytest` was called in the manner it is on Travis. This PR then does a couple of things:; 1. correctly locates the `.coveragerc` file; 2. excludes the Cython bootstrapping code from being part of the coverage; 3. correctly locates the pytest configuration file `pytest.ini` (although now we have a `pyproject.toml`, we could move that configuration there); 4. completely reorganises `.travis.yml` to remove dead configs, properly share common setups, and generally make it a bit easier to read and see what's going on; 5. fixes file reporting in Coveralls (look at the ""tree"" tab in the Coveralls web report compared to the current `master`); you can now click on the files and get proper line-by-line detail on what was covered and what wasn't, e.g. [here's the report for `mcsolve.py`](https://coveralls.io/builds/32982136/source?filename=qutip/mcsolve.py). We _don't_ enable Cython line-tracing and coverage analysis. This is actually [quite easily possible](https://cython.readthedocs.io/en/latest/src/tutorial/profiling_tutorial.html#enabling-coverage-analysis), but enabling full tracing including on `nogil` functions absolutely tanks performance to the degree where the coverage Travis run would take well in excess of two hours to complete (I think Travis actually just kills things that run longer than 2 hours). I might return to the Cython elements to see how much of them when _can_ reasonably do coverage analysis on. My prediction about actual test coverage dropping once the test files are correctly omitted, which I mentioned in #1339, came true though not _quite_ as cataclysmically (`coverage.py` uses statements, not SLOC as its metric); coverage drops from ~71% to ~63%. Technically the true percentage is higher because the Cython code is generally ver",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1347
https://github.com/qutip/qutip/pull/1347:639,Modifiability,config,configs,639,"In #1339 I pointed out that the test files were being incorrectly counted in the coverage statistics when running on Travis. This transpired to be because `coverage.py` wasn't able to find our `.coveragerc` file correctly when `pytest` was called in the manner it is on Travis. This PR then does a couple of things:; 1. correctly locates the `.coveragerc` file; 2. excludes the Cython bootstrapping code from being part of the coverage; 3. correctly locates the pytest configuration file `pytest.ini` (although now we have a `pyproject.toml`, we could move that configuration there); 4. completely reorganises `.travis.yml` to remove dead configs, properly share common setups, and generally make it a bit easier to read and see what's going on; 5. fixes file reporting in Coveralls (look at the ""tree"" tab in the Coveralls web report compared to the current `master`); you can now click on the files and get proper line-by-line detail on what was covered and what wasn't, e.g. [here's the report for `mcsolve.py`](https://coveralls.io/builds/32982136/source?filename=qutip/mcsolve.py). We _don't_ enable Cython line-tracing and coverage analysis. This is actually [quite easily possible](https://cython.readthedocs.io/en/latest/src/tutorial/profiling_tutorial.html#enabling-coverage-analysis), but enabling full tracing including on `nogil` functions absolutely tanks performance to the degree where the coverage Travis run would take well in excess of two hours to complete (I think Travis actually just kills things that run longer than 2 hours). I might return to the Cython elements to see how much of them when _can_ reasonably do coverage analysis on. My prediction about actual test coverage dropping once the test files are correctly omitted, which I mentioned in #1339, came true though not _quite_ as cataclysmically (`coverage.py` uses statements, not SLOC as its metric); coverage drops from ~71% to ~63%. Technically the true percentage is higher because the Cython code is generally ver",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1347
https://github.com/qutip/qutip/pull/1347:1369,Performance,perform,performance,1369,". This transpired to be because `coverage.py` wasn't able to find our `.coveragerc` file correctly when `pytest` was called in the manner it is on Travis. This PR then does a couple of things:; 1. correctly locates the `.coveragerc` file; 2. excludes the Cython bootstrapping code from being part of the coverage; 3. correctly locates the pytest configuration file `pytest.ini` (although now we have a `pyproject.toml`, we could move that configuration there); 4. completely reorganises `.travis.yml` to remove dead configs, properly share common setups, and generally make it a bit easier to read and see what's going on; 5. fixes file reporting in Coveralls (look at the ""tree"" tab in the Coveralls web report compared to the current `master`); you can now click on the files and get proper line-by-line detail on what was covered and what wasn't, e.g. [here's the report for `mcsolve.py`](https://coveralls.io/builds/32982136/source?filename=qutip/mcsolve.py). We _don't_ enable Cython line-tracing and coverage analysis. This is actually [quite easily possible](https://cython.readthedocs.io/en/latest/src/tutorial/profiling_tutorial.html#enabling-coverage-analysis), but enabling full tracing including on `nogil` functions absolutely tanks performance to the degree where the coverage Travis run would take well in excess of two hours to complete (I think Travis actually just kills things that run longer than 2 hours). I might return to the Cython elements to see how much of them when _can_ reasonably do coverage analysis on. My prediction about actual test coverage dropping once the test files are correctly omitted, which I mentioned in #1339, came true though not _quite_ as cataclysmically (`coverage.py` uses statements, not SLOC as its metric); coverage drops from ~71% to ~63%. Technically the true percentage is higher because the Cython code is generally very well covered, but arguing between 63% and 71% when we should be aiming to get to >95% is missing the point. Fixes #1339.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1347
https://github.com/qutip/qutip/pull/1347:1662,Safety,predict,prediction,1662,". This transpired to be because `coverage.py` wasn't able to find our `.coveragerc` file correctly when `pytest` was called in the manner it is on Travis. This PR then does a couple of things:; 1. correctly locates the `.coveragerc` file; 2. excludes the Cython bootstrapping code from being part of the coverage; 3. correctly locates the pytest configuration file `pytest.ini` (although now we have a `pyproject.toml`, we could move that configuration there); 4. completely reorganises `.travis.yml` to remove dead configs, properly share common setups, and generally make it a bit easier to read and see what's going on; 5. fixes file reporting in Coveralls (look at the ""tree"" tab in the Coveralls web report compared to the current `master`); you can now click on the files and get proper line-by-line detail on what was covered and what wasn't, e.g. [here's the report for `mcsolve.py`](https://coveralls.io/builds/32982136/source?filename=qutip/mcsolve.py). We _don't_ enable Cython line-tracing and coverage analysis. This is actually [quite easily possible](https://cython.readthedocs.io/en/latest/src/tutorial/profiling_tutorial.html#enabling-coverage-analysis), but enabling full tracing including on `nogil` functions absolutely tanks performance to the degree where the coverage Travis run would take well in excess of two hours to complete (I think Travis actually just kills things that run longer than 2 hours). I might return to the Cython elements to see how much of them when _can_ reasonably do coverage analysis on. My prediction about actual test coverage dropping once the test files are correctly omitted, which I mentioned in #1339, came true though not _quite_ as cataclysmically (`coverage.py` uses statements, not SLOC as its metric); coverage drops from ~71% to ~63%. Technically the true percentage is higher because the Cython code is generally very well covered, but arguing between 63% and 71% when we should be aiming to get to >95% is missing the point. Fixes #1339.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1347
https://github.com/qutip/qutip/pull/1347:32,Testability,test,test,32,"In #1339 I pointed out that the test files were being incorrectly counted in the coverage statistics when running on Travis. This transpired to be because `coverage.py` wasn't able to find our `.coveragerc` file correctly when `pytest` was called in the manner it is on Travis. This PR then does a couple of things:; 1. correctly locates the `.coveragerc` file; 2. excludes the Cython bootstrapping code from being part of the coverage; 3. correctly locates the pytest configuration file `pytest.ini` (although now we have a `pyproject.toml`, we could move that configuration there); 4. completely reorganises `.travis.yml` to remove dead configs, properly share common setups, and generally make it a bit easier to read and see what's going on; 5. fixes file reporting in Coveralls (look at the ""tree"" tab in the Coveralls web report compared to the current `master`); you can now click on the files and get proper line-by-line detail on what was covered and what wasn't, e.g. [here's the report for `mcsolve.py`](https://coveralls.io/builds/32982136/source?filename=qutip/mcsolve.py). We _don't_ enable Cython line-tracing and coverage analysis. This is actually [quite easily possible](https://cython.readthedocs.io/en/latest/src/tutorial/profiling_tutorial.html#enabling-coverage-analysis), but enabling full tracing including on `nogil` functions absolutely tanks performance to the degree where the coverage Travis run would take well in excess of two hours to complete (I think Travis actually just kills things that run longer than 2 hours). I might return to the Cython elements to see how much of them when _can_ reasonably do coverage analysis on. My prediction about actual test coverage dropping once the test files are correctly omitted, which I mentioned in #1339, came true though not _quite_ as cataclysmically (`coverage.py` uses statements, not SLOC as its metric); coverage drops from ~71% to ~63%. Technically the true percentage is higher because the Cython code is generally ver",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1347
https://github.com/qutip/qutip/pull/1347:1686,Testability,test,test,1686,". This transpired to be because `coverage.py` wasn't able to find our `.coveragerc` file correctly when `pytest` was called in the manner it is on Travis. This PR then does a couple of things:; 1. correctly locates the `.coveragerc` file; 2. excludes the Cython bootstrapping code from being part of the coverage; 3. correctly locates the pytest configuration file `pytest.ini` (although now we have a `pyproject.toml`, we could move that configuration there); 4. completely reorganises `.travis.yml` to remove dead configs, properly share common setups, and generally make it a bit easier to read and see what's going on; 5. fixes file reporting in Coveralls (look at the ""tree"" tab in the Coveralls web report compared to the current `master`); you can now click on the files and get proper line-by-line detail on what was covered and what wasn't, e.g. [here's the report for `mcsolve.py`](https://coveralls.io/builds/32982136/source?filename=qutip/mcsolve.py). We _don't_ enable Cython line-tracing and coverage analysis. This is actually [quite easily possible](https://cython.readthedocs.io/en/latest/src/tutorial/profiling_tutorial.html#enabling-coverage-analysis), but enabling full tracing including on `nogil` functions absolutely tanks performance to the degree where the coverage Travis run would take well in excess of two hours to complete (I think Travis actually just kills things that run longer than 2 hours). I might return to the Cython elements to see how much of them when _can_ reasonably do coverage analysis on. My prediction about actual test coverage dropping once the test files are correctly omitted, which I mentioned in #1339, came true though not _quite_ as cataclysmically (`coverage.py` uses statements, not SLOC as its metric); coverage drops from ~71% to ~63%. Technically the true percentage is higher because the Cython code is generally very well covered, but arguing between 63% and 71% when we should be aiming to get to >95% is missing the point. Fixes #1339.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1347
https://github.com/qutip/qutip/pull/1347:1718,Testability,test,test,1718,". This transpired to be because `coverage.py` wasn't able to find our `.coveragerc` file correctly when `pytest` was called in the manner it is on Travis. This PR then does a couple of things:; 1. correctly locates the `.coveragerc` file; 2. excludes the Cython bootstrapping code from being part of the coverage; 3. correctly locates the pytest configuration file `pytest.ini` (although now we have a `pyproject.toml`, we could move that configuration there); 4. completely reorganises `.travis.yml` to remove dead configs, properly share common setups, and generally make it a bit easier to read and see what's going on; 5. fixes file reporting in Coveralls (look at the ""tree"" tab in the Coveralls web report compared to the current `master`); you can now click on the files and get proper line-by-line detail on what was covered and what wasn't, e.g. [here's the report for `mcsolve.py`](https://coveralls.io/builds/32982136/source?filename=qutip/mcsolve.py). We _don't_ enable Cython line-tracing and coverage analysis. This is actually [quite easily possible](https://cython.readthedocs.io/en/latest/src/tutorial/profiling_tutorial.html#enabling-coverage-analysis), but enabling full tracing including on `nogil` functions absolutely tanks performance to the degree where the coverage Travis run would take well in excess of two hours to complete (I think Travis actually just kills things that run longer than 2 hours). I might return to the Cython elements to see how much of them when _can_ reasonably do coverage analysis on. My prediction about actual test coverage dropping once the test files are correctly omitted, which I mentioned in #1339, came true though not _quite_ as cataclysmically (`coverage.py` uses statements, not SLOC as its metric); coverage drops from ~71% to ~63%. Technically the true percentage is higher because the Cython code is generally very well covered, but arguing between 63% and 71% when we should be aiming to get to >95% is missing the point. Fixes #1339.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1347
https://github.com/qutip/qutip/issues/1349:1741,Availability,toler,tolerances,1741," means that if the global option `auto_tidyup` is set to `True` (its default), then small values (< 1e-15) are truncated from the output matrices. This generally ends up with ""neater"" looking matrices when output; there are far fewer numbers like `1 + 4.516584e-17j` reported, when that's basically just `1`. There are, however, a couple of problems because of this. The first is speed; after every (very simple)_ operation, such as `matmul` or `add`, the tidier runs on the matrix. This typically has `O(nnz)` complexity for sparse matrices, and `O(n * n)` complexity for a dense square matrix with `n` rows. This adds very significant overhead on to simple operations. Second is numerical precision. By dropping small terms, we are effectively turning numerical imprecision into a ""feature"" as opposed to a bug. Because QuTiP 5 uses the new data-layer to do most of its operations, rather than constructing intermediary `Qobj` instances, many mathematical operations will not give the same result if the data layer is used directly compared to if `Qobj` is used at every step. For example, let's say we have three random `Qobj`:; ```python; a, b, c = [qutip.rand_herm(5) for _ in [None]*3]; ```; Now, in general,; ```python; a + b + c != qutip.Qobj(a.data + b.data + c.data); ```; because `a + b + c` will invoke the `tidyup` code twice, whereas the right-hand side will not invoke it at all. This means that despite the fact that `Qobj.__add__` uses the data-layer addition underneath, there will be numerical differences using the QuTiP default settings. I suspect these sort of problems are behind the recent test instabilities on `dev.major` with regards to tolerances. ----. My vote is for a removal of `auto_tidyup`, or at the very least, changing the default value of the option to `False`. We still want nice values for display, so perhaps we could consider having an option to produce a tidied up copy when calling `__repr__`, instead?. Interested to hear what others think about this too.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1349
https://github.com/qutip/qutip/issues/1349:1691,Testability,test,test,1691," means that if the global option `auto_tidyup` is set to `True` (its default), then small values (< 1e-15) are truncated from the output matrices. This generally ends up with ""neater"" looking matrices when output; there are far fewer numbers like `1 + 4.516584e-17j` reported, when that's basically just `1`. There are, however, a couple of problems because of this. The first is speed; after every (very simple)_ operation, such as `matmul` or `add`, the tidier runs on the matrix. This typically has `O(nnz)` complexity for sparse matrices, and `O(n * n)` complexity for a dense square matrix with `n` rows. This adds very significant overhead on to simple operations. Second is numerical precision. By dropping small terms, we are effectively turning numerical imprecision into a ""feature"" as opposed to a bug. Because QuTiP 5 uses the new data-layer to do most of its operations, rather than constructing intermediary `Qobj` instances, many mathematical operations will not give the same result if the data layer is used directly compared to if `Qobj` is used at every step. For example, let's say we have three random `Qobj`:; ```python; a, b, c = [qutip.rand_herm(5) for _ in [None]*3]; ```; Now, in general,; ```python; a + b + c != qutip.Qobj(a.data + b.data + c.data); ```; because `a + b + c` will invoke the `tidyup` code twice, whereas the right-hand side will not invoke it at all. This means that despite the fact that `Qobj.__add__` uses the data-layer addition underneath, there will be numerical differences using the QuTiP default settings. I suspect these sort of problems are behind the recent test instabilities on `dev.major` with regards to tolerances. ----. My vote is for a removal of `auto_tidyup`, or at the very least, changing the default value of the option to `False`. We still want nice values for display, so perhaps we could consider having an option to produce a tidied up copy when calling `__repr__`, instead?. Interested to hear what others think about this too.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1349
https://github.com/qutip/qutip/issues/1349:482,Usability,simpl,simple,482,"Currently, many `Qobj` operations are tagged as ""tidied up"" operations, which means that if the global option `auto_tidyup` is set to `True` (its default), then small values (< 1e-15) are truncated from the output matrices. This generally ends up with ""neater"" looking matrices when output; there are far fewer numbers like `1 + 4.516584e-17j` reported, when that's basically just `1`. There are, however, a couple of problems because of this. The first is speed; after every (very simple)_ operation, such as `matmul` or `add`, the tidier runs on the matrix. This typically has `O(nnz)` complexity for sparse matrices, and `O(n * n)` complexity for a dense square matrix with `n` rows. This adds very significant overhead on to simple operations. Second is numerical precision. By dropping small terms, we are effectively turning numerical imprecision into a ""feature"" as opposed to a bug. Because QuTiP 5 uses the new data-layer to do most of its operations, rather than constructing intermediary `Qobj` instances, many mathematical operations will not give the same result if the data layer is used directly compared to if `Qobj` is used at every step. For example, let's say we have three random `Qobj`:; ```python; a, b, c = [qutip.rand_herm(5) for _ in [None]*3]; ```; Now, in general,; ```python; a + b + c != qutip.Qobj(a.data + b.data + c.data); ```; because `a + b + c` will invoke the `tidyup` code twice, whereas the right-hand side will not invoke it at all. This means that despite the fact that `Qobj.__add__` uses the data-layer addition underneath, there will be numerical differences using the QuTiP default settings. I suspect these sort of problems are behind the recent test instabilities on `dev.major` with regards to tolerances. ----. My vote is for a removal of `auto_tidyup`, or at the very least, changing the default value of the option to `False`. We still want nice values for display, so perhaps we could consider having an option to produce a tidied up copy when callin",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1349
https://github.com/qutip/qutip/issues/1349:729,Usability,simpl,simple,729,"Currently, many `Qobj` operations are tagged as ""tidied up"" operations, which means that if the global option `auto_tidyup` is set to `True` (its default), then small values (< 1e-15) are truncated from the output matrices. This generally ends up with ""neater"" looking matrices when output; there are far fewer numbers like `1 + 4.516584e-17j` reported, when that's basically just `1`. There are, however, a couple of problems because of this. The first is speed; after every (very simple)_ operation, such as `matmul` or `add`, the tidier runs on the matrix. This typically has `O(nnz)` complexity for sparse matrices, and `O(n * n)` complexity for a dense square matrix with `n` rows. This adds very significant overhead on to simple operations. Second is numerical precision. By dropping small terms, we are effectively turning numerical imprecision into a ""feature"" as opposed to a bug. Because QuTiP 5 uses the new data-layer to do most of its operations, rather than constructing intermediary `Qobj` instances, many mathematical operations will not give the same result if the data layer is used directly compared to if `Qobj` is used at every step. For example, let's say we have three random `Qobj`:; ```python; a, b, c = [qutip.rand_herm(5) for _ in [None]*3]; ```; Now, in general,; ```python; a + b + c != qutip.Qobj(a.data + b.data + c.data); ```; because `a + b + c` will invoke the `tidyup` code twice, whereas the right-hand side will not invoke it at all. This means that despite the fact that `Qobj.__add__` uses the data-layer addition underneath, there will be numerical differences using the QuTiP default settings. I suspect these sort of problems are behind the recent test instabilities on `dev.major` with regards to tolerances. ----. My vote is for a removal of `auto_tidyup`, or at the very least, changing the default value of the option to `False`. We still want nice values for display, so perhaps we could consider having an option to produce a tidied up copy when callin",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1349
https://github.com/qutip/qutip/issues/1350:85,Availability,mask,masked,85,"In certain circumstances, `zcsr_isherm` can give a `False` negative. This is usually masked by the `auto_tidyup` option being turned on. Reproduce:; ```python; >>> import numpy as np; >>> import scipy.sparse; >>> import qutip; >>> x = scipy.sparse.csr_matrix(np.array([[1, 1e-15j], [0, 1]])); >>> bool(qutip.cy.spmath.zcsr_isherm(x, 1e-12)); False; ```; Up to the tolerance specified (`1e-12`), the given matrix _is_ Hermitian, so it should return `True`. This happens when a small non-zero value (lower than the tolerance) is compared to a zero. This is because the structure test in `zcsr_isherm` assumes that for Hermicity to hold, there _must_ always be an explicitly stored corresponding element for each entry, however clearly this isn't always the case. It hasn't appeared before because we always have `auto_tidyup` turned on with a sufficiently large tolerance that these values would be removed by almost all operations which could have introduced this disparity (mostly matrix multiplication). (I'll fix this on both the `master` branch and on `dev.major`, this is just for posterity)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1350
https://github.com/qutip/qutip/issues/1350:364,Availability,toler,tolerance,364,"In certain circumstances, `zcsr_isherm` can give a `False` negative. This is usually masked by the `auto_tidyup` option being turned on. Reproduce:; ```python; >>> import numpy as np; >>> import scipy.sparse; >>> import qutip; >>> x = scipy.sparse.csr_matrix(np.array([[1, 1e-15j], [0, 1]])); >>> bool(qutip.cy.spmath.zcsr_isherm(x, 1e-12)); False; ```; Up to the tolerance specified (`1e-12`), the given matrix _is_ Hermitian, so it should return `True`. This happens when a small non-zero value (lower than the tolerance) is compared to a zero. This is because the structure test in `zcsr_isherm` assumes that for Hermicity to hold, there _must_ always be an explicitly stored corresponding element for each entry, however clearly this isn't always the case. It hasn't appeared before because we always have `auto_tidyup` turned on with a sufficiently large tolerance that these values would be removed by almost all operations which could have introduced this disparity (mostly matrix multiplication). (I'll fix this on both the `master` branch and on `dev.major`, this is just for posterity)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1350
https://github.com/qutip/qutip/issues/1350:513,Availability,toler,tolerance,513,"In certain circumstances, `zcsr_isherm` can give a `False` negative. This is usually masked by the `auto_tidyup` option being turned on. Reproduce:; ```python; >>> import numpy as np; >>> import scipy.sparse; >>> import qutip; >>> x = scipy.sparse.csr_matrix(np.array([[1, 1e-15j], [0, 1]])); >>> bool(qutip.cy.spmath.zcsr_isherm(x, 1e-12)); False; ```; Up to the tolerance specified (`1e-12`), the given matrix _is_ Hermitian, so it should return `True`. This happens when a small non-zero value (lower than the tolerance) is compared to a zero. This is because the structure test in `zcsr_isherm` assumes that for Hermicity to hold, there _must_ always be an explicitly stored corresponding element for each entry, however clearly this isn't always the case. It hasn't appeared before because we always have `auto_tidyup` turned on with a sufficiently large tolerance that these values would be removed by almost all operations which could have introduced this disparity (mostly matrix multiplication). (I'll fix this on both the `master` branch and on `dev.major`, this is just for posterity)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1350
https://github.com/qutip/qutip/issues/1350:860,Availability,toler,tolerance,860,"In certain circumstances, `zcsr_isherm` can give a `False` negative. This is usually masked by the `auto_tidyup` option being turned on. Reproduce:; ```python; >>> import numpy as np; >>> import scipy.sparse; >>> import qutip; >>> x = scipy.sparse.csr_matrix(np.array([[1, 1e-15j], [0, 1]])); >>> bool(qutip.cy.spmath.zcsr_isherm(x, 1e-12)); False; ```; Up to the tolerance specified (`1e-12`), the given matrix _is_ Hermitian, so it should return `True`. This happens when a small non-zero value (lower than the tolerance) is compared to a zero. This is because the structure test in `zcsr_isherm` assumes that for Hermicity to hold, there _must_ always be an explicitly stored corresponding element for each entry, however clearly this isn't always the case. It hasn't appeared before because we always have `auto_tidyup` turned on with a sufficiently large tolerance that these values would be removed by almost all operations which could have introduced this disparity (mostly matrix multiplication). (I'll fix this on both the `master` branch and on `dev.major`, this is just for posterity)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1350
https://github.com/qutip/qutip/issues/1350:577,Testability,test,test,577,"In certain circumstances, `zcsr_isherm` can give a `False` negative. This is usually masked by the `auto_tidyup` option being turned on. Reproduce:; ```python; >>> import numpy as np; >>> import scipy.sparse; >>> import qutip; >>> x = scipy.sparse.csr_matrix(np.array([[1, 1e-15j], [0, 1]])); >>> bool(qutip.cy.spmath.zcsr_isherm(x, 1e-12)); False; ```; Up to the tolerance specified (`1e-12`), the given matrix _is_ Hermitian, so it should return `True`. This happens when a small non-zero value (lower than the tolerance) is compared to a zero. This is because the structure test in `zcsr_isherm` assumes that for Hermicity to hold, there _must_ always be an explicitly stored corresponding element for each entry, however clearly this isn't always the case. It hasn't appeared before because we always have `auto_tidyup` turned on with a sufficiently large tolerance that these values would be removed by almost all operations which could have introduced this disparity (mostly matrix multiplication). (I'll fix this on both the `master` branch and on `dev.major`, this is just for posterity)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1350
https://github.com/qutip/qutip/issues/1350:725,Usability,clear,clearly,725,"In certain circumstances, `zcsr_isherm` can give a `False` negative. This is usually masked by the `auto_tidyup` option being turned on. Reproduce:; ```python; >>> import numpy as np; >>> import scipy.sparse; >>> import qutip; >>> x = scipy.sparse.csr_matrix(np.array([[1, 1e-15j], [0, 1]])); >>> bool(qutip.cy.spmath.zcsr_isherm(x, 1e-12)); False; ```; Up to the tolerance specified (`1e-12`), the given matrix _is_ Hermitian, so it should return `True`. This happens when a small non-zero value (lower than the tolerance) is compared to a zero. This is because the structure test in `zcsr_isherm` assumes that for Hermicity to hold, there _must_ always be an explicitly stored corresponding element for each entry, however clearly this isn't always the case. It hasn't appeared before because we always have `auto_tidyup` turned on with a sufficiently large tolerance that these values would be removed by almost all operations which could have introduced this disparity (mostly matrix multiplication). (I'll fix this on both the `master` branch and on `dev.major`, this is just for posterity)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1350
https://github.com/qutip/qutip/pull/1351:737,Integrability,rout,routines,737,"Finally, `Qobj` can use any backing data store. This fairly small and simple PR is effectively the culmination of all the work on `dev.major` over the last few months, and effectively is just like flicking a switch to turn on all the capabilities that we've built up through #1282, #1296, #1332, #1338 and #1341. There is still a lot of work to be done, but I'm trying to transition to smaller, easier-to-check PRs to make review easier. Possibly incomplete to do list:; - write a proper `data.create`; - possibly add the dispatchers in as `data.Data` mathematical methods (e.g. `__matmul__`); - add options for controlling default output types from the dispatchers; - tests for `Qobj` with both types; - tests for creation and property routines of the data layer; - tests for the dispatch operation; - tests for conversion operations; - more specialisations to be written for `Dense` and `CSR`/`Dense`; - more ergonomic selection of _method_, not just output type (for example, you should be able to specify you want the `Dense` specialisation of `eigs` even if you pass it a `CSR`); - more ergonomic dispatchers for matrix creation (e.g. how exactly will `qutip.basis` function, and how will users add specialisations?); - documentation, both user-facing and developer-facing; - fix algorithms in `add_csr` and `matmul_csr` to use `csr.Accumulator` (should provide a speedup and remove some sorts); - fix `isherm_csr` (see #1350 - `isherm_csr` uses the same algorithm, so has the same problem)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1351
https://github.com/qutip/qutip/pull/1351:669,Testability,test,tests,669,"Finally, `Qobj` can use any backing data store. This fairly small and simple PR is effectively the culmination of all the work on `dev.major` over the last few months, and effectively is just like flicking a switch to turn on all the capabilities that we've built up through #1282, #1296, #1332, #1338 and #1341. There is still a lot of work to be done, but I'm trying to transition to smaller, easier-to-check PRs to make review easier. Possibly incomplete to do list:; - write a proper `data.create`; - possibly add the dispatchers in as `data.Data` mathematical methods (e.g. `__matmul__`); - add options for controlling default output types from the dispatchers; - tests for `Qobj` with both types; - tests for creation and property routines of the data layer; - tests for the dispatch operation; - tests for conversion operations; - more specialisations to be written for `Dense` and `CSR`/`Dense`; - more ergonomic selection of _method_, not just output type (for example, you should be able to specify you want the `Dense` specialisation of `eigs` even if you pass it a `CSR`); - more ergonomic dispatchers for matrix creation (e.g. how exactly will `qutip.basis` function, and how will users add specialisations?); - documentation, both user-facing and developer-facing; - fix algorithms in `add_csr` and `matmul_csr` to use `csr.Accumulator` (should provide a speedup and remove some sorts); - fix `isherm_csr` (see #1350 - `isherm_csr` uses the same algorithm, so has the same problem)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1351
https://github.com/qutip/qutip/pull/1351:705,Testability,test,tests,705,"Finally, `Qobj` can use any backing data store. This fairly small and simple PR is effectively the culmination of all the work on `dev.major` over the last few months, and effectively is just like flicking a switch to turn on all the capabilities that we've built up through #1282, #1296, #1332, #1338 and #1341. There is still a lot of work to be done, but I'm trying to transition to smaller, easier-to-check PRs to make review easier. Possibly incomplete to do list:; - write a proper `data.create`; - possibly add the dispatchers in as `data.Data` mathematical methods (e.g. `__matmul__`); - add options for controlling default output types from the dispatchers; - tests for `Qobj` with both types; - tests for creation and property routines of the data layer; - tests for the dispatch operation; - tests for conversion operations; - more specialisations to be written for `Dense` and `CSR`/`Dense`; - more ergonomic selection of _method_, not just output type (for example, you should be able to specify you want the `Dense` specialisation of `eigs` even if you pass it a `CSR`); - more ergonomic dispatchers for matrix creation (e.g. how exactly will `qutip.basis` function, and how will users add specialisations?); - documentation, both user-facing and developer-facing; - fix algorithms in `add_csr` and `matmul_csr` to use `csr.Accumulator` (should provide a speedup and remove some sorts); - fix `isherm_csr` (see #1350 - `isherm_csr` uses the same algorithm, so has the same problem)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1351
https://github.com/qutip/qutip/pull/1351:767,Testability,test,tests,767,"Finally, `Qobj` can use any backing data store. This fairly small and simple PR is effectively the culmination of all the work on `dev.major` over the last few months, and effectively is just like flicking a switch to turn on all the capabilities that we've built up through #1282, #1296, #1332, #1338 and #1341. There is still a lot of work to be done, but I'm trying to transition to smaller, easier-to-check PRs to make review easier. Possibly incomplete to do list:; - write a proper `data.create`; - possibly add the dispatchers in as `data.Data` mathematical methods (e.g. `__matmul__`); - add options for controlling default output types from the dispatchers; - tests for `Qobj` with both types; - tests for creation and property routines of the data layer; - tests for the dispatch operation; - tests for conversion operations; - more specialisations to be written for `Dense` and `CSR`/`Dense`; - more ergonomic selection of _method_, not just output type (for example, you should be able to specify you want the `Dense` specialisation of `eigs` even if you pass it a `CSR`); - more ergonomic dispatchers for matrix creation (e.g. how exactly will `qutip.basis` function, and how will users add specialisations?); - documentation, both user-facing and developer-facing; - fix algorithms in `add_csr` and `matmul_csr` to use `csr.Accumulator` (should provide a speedup and remove some sorts); - fix `isherm_csr` (see #1350 - `isherm_csr` uses the same algorithm, so has the same problem)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1351
https://github.com/qutip/qutip/pull/1351:803,Testability,test,tests,803,"Finally, `Qobj` can use any backing data store. This fairly small and simple PR is effectively the culmination of all the work on `dev.major` over the last few months, and effectively is just like flicking a switch to turn on all the capabilities that we've built up through #1282, #1296, #1332, #1338 and #1341. There is still a lot of work to be done, but I'm trying to transition to smaller, easier-to-check PRs to make review easier. Possibly incomplete to do list:; - write a proper `data.create`; - possibly add the dispatchers in as `data.Data` mathematical methods (e.g. `__matmul__`); - add options for controlling default output types from the dispatchers; - tests for `Qobj` with both types; - tests for creation and property routines of the data layer; - tests for the dispatch operation; - tests for conversion operations; - more specialisations to be written for `Dense` and `CSR`/`Dense`; - more ergonomic selection of _method_, not just output type (for example, you should be able to specify you want the `Dense` specialisation of `eigs` even if you pass it a `CSR`); - more ergonomic dispatchers for matrix creation (e.g. how exactly will `qutip.basis` function, and how will users add specialisations?); - documentation, both user-facing and developer-facing; - fix algorithms in `add_csr` and `matmul_csr` to use `csr.Accumulator` (should provide a speedup and remove some sorts); - fix `isherm_csr` (see #1350 - `isherm_csr` uses the same algorithm, so has the same problem)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1351
https://github.com/qutip/qutip/pull/1351:70,Usability,simpl,simple,70,"Finally, `Qobj` can use any backing data store. This fairly small and simple PR is effectively the culmination of all the work on `dev.major` over the last few months, and effectively is just like flicking a switch to turn on all the capabilities that we've built up through #1282, #1296, #1332, #1338 and #1341. There is still a lot of work to be done, but I'm trying to transition to smaller, easier-to-check PRs to make review easier. Possibly incomplete to do list:; - write a proper `data.create`; - possibly add the dispatchers in as `data.Data` mathematical methods (e.g. `__matmul__`); - add options for controlling default output types from the dispatchers; - tests for `Qobj` with both types; - tests for creation and property routines of the data layer; - tests for the dispatch operation; - tests for conversion operations; - more specialisations to be written for `Dense` and `CSR`/`Dense`; - more ergonomic selection of _method_, not just output type (for example, you should be able to specify you want the `Dense` specialisation of `eigs` even if you pass it a `CSR`); - more ergonomic dispatchers for matrix creation (e.g. how exactly will `qutip.basis` function, and how will users add specialisations?); - documentation, both user-facing and developer-facing; - fix algorithms in `add_csr` and `matmul_csr` to use `csr.Accumulator` (should provide a speedup and remove some sorts); - fix `isherm_csr` (see #1350 - `isherm_csr` uses the same algorithm, so has the same problem)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1351
https://github.com/qutip/qutip/pull/1352:64,Availability,toler,tolerance,64,"In certain cases in matrices containing values smaller than the tolerance for Hermicity, a matrix can be considered Hermitian even if its transpose does not have the same sparsity pattern as itself. The previous version of this function would give false negatives in these circumstances, whereas now we fall back on the more computationally and memory intensive version of constructing the transpose completely, and comparing element-wise. We offset some of this slowdown by optimising the floating-point comparisons to avoid calls to `sqrt` (via `abs`), and by removing a redundant test of the sparsity pattern in the inner loop. Fixes #1350 for the `master` branch, but still to do for `dev.major`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1352
https://github.com/qutip/qutip/pull/1352:573,Availability,redundant,redundant,573,"In certain cases in matrices containing values smaller than the tolerance for Hermicity, a matrix can be considered Hermitian even if its transpose does not have the same sparsity pattern as itself. The previous version of this function would give false negatives in these circumstances, whereas now we fall back on the more computationally and memory intensive version of constructing the transpose completely, and comparing element-wise. We offset some of this slowdown by optimising the floating-point comparisons to avoid calls to `sqrt` (via `abs`), and by removing a redundant test of the sparsity pattern in the inner loop. Fixes #1350 for the `master` branch, but still to do for `dev.major`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1352
https://github.com/qutip/qutip/pull/1352:520,Safety,avoid,avoid,520,"In certain cases in matrices containing values smaller than the tolerance for Hermicity, a matrix can be considered Hermitian even if its transpose does not have the same sparsity pattern as itself. The previous version of this function would give false negatives in these circumstances, whereas now we fall back on the more computationally and memory intensive version of constructing the transpose completely, and comparing element-wise. We offset some of this slowdown by optimising the floating-point comparisons to avoid calls to `sqrt` (via `abs`), and by removing a redundant test of the sparsity pattern in the inner loop. Fixes #1350 for the `master` branch, but still to do for `dev.major`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1352
https://github.com/qutip/qutip/pull/1352:573,Safety,redund,redundant,573,"In certain cases in matrices containing values smaller than the tolerance for Hermicity, a matrix can be considered Hermitian even if its transpose does not have the same sparsity pattern as itself. The previous version of this function would give false negatives in these circumstances, whereas now we fall back on the more computationally and memory intensive version of constructing the transpose completely, and comparing element-wise. We offset some of this slowdown by optimising the floating-point comparisons to avoid calls to `sqrt` (via `abs`), and by removing a redundant test of the sparsity pattern in the inner loop. Fixes #1350 for the `master` branch, but still to do for `dev.major`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1352
https://github.com/qutip/qutip/pull/1352:583,Testability,test,test,583,"In certain cases in matrices containing values smaller than the tolerance for Hermicity, a matrix can be considered Hermitian even if its transpose does not have the same sparsity pattern as itself. The previous version of this function would give false negatives in these circumstances, whereas now we fall back on the more computationally and memory intensive version of constructing the transpose completely, and comparing element-wise. We offset some of this slowdown by optimising the floating-point comparisons to avoid calls to `sqrt` (via `abs`), and by removing a redundant test of the sparsity pattern in the inner loop. Fixes #1350 for the `master` branch, but still to do for `dev.major`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1352
https://github.com/qutip/qutip/issues/1354:1711,Availability,failure,failures,1711,"**Describe the bug**; As described in the title, ``file_`` in ``_file_list().add(file_)`` already has the extension ``'.pyx'`` (this is done by _import_str() in qobjevo_codegen.py), it is unnecessary to add yet another suffix. **To Reproduce**; This can be verified by add a line printing out ``file_`` in ``_file_list().clean()`` ; then run any test that can trigger it (for example ``test_QobjEvo_with_state()``) and observe the output. **Expected behavior**; Should only have a single ``'.pyx'`` in ``file_``. **Your Environment**; ```; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, and Boxi Li; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.6.0.dev0+8e181cc4; Numpy Version: 1.19.1; Scipy Version: 1.5.0; Cython Version: 0.29.21; Matplotlib Version: 3.3.1; Python Version: 3.8.5; Number of CPUs: 8; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Windows (AMD64); Installation path: C:\Users\berry\PycharmProjects\qutip\qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; ```. **Additional context**; I discovered this when dealing with some test failures in windows, it seems that there are multiple problems in ``qobjevo.py`` (actually, what I really wanted to figure out in the first place was that some compiled modules would be deleted before being imported). Anyway, I will update this issue whenever I make any progress.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1354
https://github.com/qutip/qutip/issues/1354:1216,Deployability,Install,Installed,1216,"**Describe the bug**; As described in the title, ``file_`` in ``_file_list().add(file_)`` already has the extension ``'.pyx'`` (this is done by _import_str() in qobjevo_codegen.py), it is unnecessary to add yet another suffix. **To Reproduce**; This can be verified by add a line printing out ``file_`` in ``_file_list().clean()`` ; then run any test that can trigger it (for example ``test_QobjEvo_with_state()``) and observe the output. **Expected behavior**; Should only have a single ``'.pyx'`` in ``file_``. **Your Environment**; ```; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, and Boxi Li; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.6.0.dev0+8e181cc4; Numpy Version: 1.19.1; Scipy Version: 1.5.0; Cython Version: 0.29.21; Matplotlib Version: 3.3.1; Python Version: 3.8.5; Number of CPUs: 8; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Windows (AMD64); Installation path: C:\Users\berry\PycharmProjects\qutip\qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; ```. **Additional context**; I discovered this when dealing with some test failures in windows, it seems that there are multiple problems in ``qobjevo.py`` (actually, what I really wanted to figure out in the first place was that some compiled modules would be deleted before being imported). Anyway, I will update this issue whenever I make any progress.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1354
https://github.com/qutip/qutip/issues/1354:1287,Deployability,Install,Installation,1287,"**Describe the bug**; As described in the title, ``file_`` in ``_file_list().add(file_)`` already has the extension ``'.pyx'`` (this is done by _import_str() in qobjevo_codegen.py), it is unnecessary to add yet another suffix. **To Reproduce**; This can be verified by add a line printing out ``file_`` in ``_file_list().clean()`` ; then run any test that can trigger it (for example ``test_QobjEvo_with_state()``) and observe the output. **Expected behavior**; Should only have a single ``'.pyx'`` in ``file_``. **Your Environment**; ```; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, and Boxi Li; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.6.0.dev0+8e181cc4; Numpy Version: 1.19.1; Scipy Version: 1.5.0; Cython Version: 0.29.21; Matplotlib Version: 3.3.1; Python Version: 3.8.5; Number of CPUs: 8; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Windows (AMD64); Installation path: C:\Users\berry\PycharmProjects\qutip\qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; ```. **Additional context**; I discovered this when dealing with some test failures in windows, it seems that there are multiple problems in ``qobjevo.py`` (actually, what I really wanted to figure out in the first place was that some compiled modules would be deleted before being imported). Anyway, I will update this issue whenever I make any progress.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1354
https://github.com/qutip/qutip/issues/1354:1944,Deployability,update,update,1944,"**Describe the bug**; As described in the title, ``file_`` in ``_file_list().add(file_)`` already has the extension ``'.pyx'`` (this is done by _import_str() in qobjevo_codegen.py), it is unnecessary to add yet another suffix. **To Reproduce**; This can be verified by add a line printing out ``file_`` in ``_file_list().clean()`` ; then run any test that can trigger it (for example ``test_QobjEvo_with_state()``) and observe the output. **Expected behavior**; Should only have a single ``'.pyx'`` in ``file_``. **Your Environment**; ```; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, and Boxi Li; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.6.0.dev0+8e181cc4; Numpy Version: 1.19.1; Scipy Version: 1.5.0; Cython Version: 0.29.21; Matplotlib Version: 3.3.1; Python Version: 3.8.5; Number of CPUs: 8; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Windows (AMD64); Installation path: C:\Users\berry\PycharmProjects\qutip\qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; ```. **Additional context**; I discovered this when dealing with some test failures in windows, it seems that there are multiple problems in ``qobjevo.py`` (actually, what I really wanted to figure out in the first place was that some compiled modules would be deleted before being imported). Anyway, I will update this issue whenever I make any progress.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1354
https://github.com/qutip/qutip/issues/1354:346,Testability,test,test,346,"**Describe the bug**; As described in the title, ``file_`` in ``_file_list().add(file_)`` already has the extension ``'.pyx'`` (this is done by _import_str() in qobjevo_codegen.py), it is unnecessary to add yet another suffix. **To Reproduce**; This can be verified by add a line printing out ``file_`` in ``_file_list().clean()`` ; then run any test that can trigger it (for example ``test_QobjEvo_with_state()``) and observe the output. **Expected behavior**; Should only have a single ``'.pyx'`` in ``file_``. **Your Environment**; ```; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, and Boxi Li; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.6.0.dev0+8e181cc4; Numpy Version: 1.19.1; Scipy Version: 1.5.0; Cython Version: 0.29.21; Matplotlib Version: 3.3.1; Python Version: 3.8.5; Number of CPUs: 8; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Windows (AMD64); Installation path: C:\Users\berry\PycharmProjects\qutip\qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; ```. **Additional context**; I discovered this when dealing with some test failures in windows, it seems that there are multiple problems in ``qobjevo.py`` (actually, what I really wanted to figure out in the first place was that some compiled modules would be deleted before being imported). Anyway, I will update this issue whenever I make any progress.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1354
https://github.com/qutip/qutip/issues/1354:1706,Testability,test,test,1706,"**Describe the bug**; As described in the title, ``file_`` in ``_file_list().add(file_)`` already has the extension ``'.pyx'`` (this is done by _import_str() in qobjevo_codegen.py), it is unnecessary to add yet another suffix. **To Reproduce**; This can be verified by add a line printing out ``file_`` in ``_file_list().clean()`` ; then run any test that can trigger it (for example ``test_QobjEvo_with_state()``) and observe the output. **Expected behavior**; Should only have a single ``'.pyx'`` in ``file_``. **Your Environment**; ```; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, and Boxi Li; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.6.0.dev0+8e181cc4; Numpy Version: 1.19.1; Scipy Version: 1.5.0; Cython Version: 0.29.21; Matplotlib Version: 3.3.1; Python Version: 3.8.5; Number of CPUs: 8; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Windows (AMD64); Installation path: C:\Users\berry\PycharmProjects\qutip\qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; ```. **Additional context**; I discovered this when dealing with some test failures in windows, it seems that there are multiple problems in ``qobjevo.py`` (actually, what I really wanted to figure out in the first place was that some compiled modules would be deleted before being imported). Anyway, I will update this issue whenever I make any progress.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1354
https://github.com/qutip/qutip/pull/1355:74,Testability,test,tests,74,"increased ``maxiter`` at ``test_driven_cavity_power_gmres()`` to 10000 in tests/test_steadystate.py; resolved mutable default value at ``parallel_map()`` in parallel.py; resolved mutable default value at various places in qobjevo.py; cleaned up now defunct class ``_file_list`` in qobjevo.py (fixes #1354). **Description**; Fixes #1354, increases ``maxiter`` at ``test_driven_cavity_power_gmres()`` to ``10000`` in ``tests/test_steadystate.py``. **Related issues or PRs**; fix #1354. **Changelog**; Increased ``maxiter`` at ``test_driven_cavity_power_gmres()`` to 10000 in tests/test_steadystate.py.; Resolved mutable default value at ``parallel_map()`` in parallel.py.; Resolved mutable default value at various places in qobjevo.py.; Cleaned up now defunct class ``_file_list`` in qobjevo.py (fixes #1354).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1355
https://github.com/qutip/qutip/pull/1355:417,Testability,test,tests,417,"increased ``maxiter`` at ``test_driven_cavity_power_gmres()`` to 10000 in tests/test_steadystate.py; resolved mutable default value at ``parallel_map()`` in parallel.py; resolved mutable default value at various places in qobjevo.py; cleaned up now defunct class ``_file_list`` in qobjevo.py (fixes #1354). **Description**; Fixes #1354, increases ``maxiter`` at ``test_driven_cavity_power_gmres()`` to ``10000`` in ``tests/test_steadystate.py``. **Related issues or PRs**; fix #1354. **Changelog**; Increased ``maxiter`` at ``test_driven_cavity_power_gmres()`` to 10000 in tests/test_steadystate.py.; Resolved mutable default value at ``parallel_map()`` in parallel.py.; Resolved mutable default value at various places in qobjevo.py.; Cleaned up now defunct class ``_file_list`` in qobjevo.py (fixes #1354).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1355
https://github.com/qutip/qutip/pull/1355:573,Testability,test,tests,573,"increased ``maxiter`` at ``test_driven_cavity_power_gmres()`` to 10000 in tests/test_steadystate.py; resolved mutable default value at ``parallel_map()`` in parallel.py; resolved mutable default value at various places in qobjevo.py; cleaned up now defunct class ``_file_list`` in qobjevo.py (fixes #1354). **Description**; Fixes #1354, increases ``maxiter`` at ``test_driven_cavity_power_gmres()`` to ``10000`` in ``tests/test_steadystate.py``. **Related issues or PRs**; fix #1354. **Changelog**; Increased ``maxiter`` at ``test_driven_cavity_power_gmres()`` to 10000 in tests/test_steadystate.py.; Resolved mutable default value at ``parallel_map()`` in parallel.py.; Resolved mutable default value at various places in qobjevo.py.; Cleaned up now defunct class ``_file_list`` in qobjevo.py (fixes #1354).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1355
https://github.com/qutip/qutip/pull/1356:210,Testability,test,tests,210,"**Description**; - Support `X`, `Y`, `Z` gates in gate decomposition. Decompose them into `RX`, `RY`, `RZ` gates, with the corresponding global phase. Now `X`, `Y`, `Z` can be used in `Processor`.; - Modernize tests for `CavityQED` and `SpinChain`. **Changelog**; XYZ gates decomposition and modernizing tests",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1356
https://github.com/qutip/qutip/pull/1356:304,Testability,test,tests,304,"**Description**; - Support `X`, `Y`, `Z` gates in gate decomposition. Decompose them into `RX`, `RY`, `RZ` gates, with the corresponding global phase. Now `X`, `Y`, `Z` can be used in `Processor`.; - Modernize tests for `CavityQED` and `SpinChain`. **Changelog**; XYZ gates decomposition and modernizing tests",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1356
https://github.com/qutip/qutip/issues/1357:916,Deployability,update,update,916,"Hi, I'm wondering if it's possible to control the precision of 'predictor-corrector' solver of the photocurrent_mesolve? Seems like the 'tol' has no effect on the 'predictor-corrector' solver. Here's my code. I was trying to use stochastic master equation to generate the outcome photon sequence from a CPT set up, but I got a diverged outcome sometimes. ```; from qutip import *; import matplotlib.pyplot as plt; import numpy as np; import matplotlib as mpl. params = {; 	'axes.labelsize': 12,; 	'legend.fontsize': 10,; 	'xtick.labelsize': 10,; 	'ytick.labelsize': 10,; 	'figure.figsize': [3*1.4/1.2, 2.8/1.2],#2.3; 	'lines.linewidth' : 1,; 	'axes.linewidth':0.9,; 	'figure.subplot.left':0,; 	'figure.subplot.right':1,; 	'figure.subplot.bottom':0,; 	'figure.subplot.top':1,; 	'grid.linestyle':'--',; 	'axes.grid':False,; 	""font.family"":""serif"",; 	""xtick.direction"":""in"",; 	""ytick.direction"":""in"",. 	}; mpl.rcParams.update(params). T = 100; N = 100000; Gamma = 2*np.pi*13; Omega = 2*np.pi*2. times = np.linspace(0,T,N); ge = fock(3, 0) * fock(3, 1).dag(); se = fock(3, 2) * fock(3, 1).dag(); ss = fock(3, 2) * fock(3, 2).dag(); ee = fock(3, 1) * fock(3, 1).dag(); dark = (fock(3, 2) - fock(3, 0)).unit(); dd = dark*dark.dag(). bias = 2*np.pi*0.1. psi0 = dark. H = Omega * (ge + ge.dag() + se + se.dag()) + bias*ss. result_sme = photocurrent_mesolve(H, psi0, times, c_ops = [],sc_ops = [np.sqrt(Gamma/2)*ge + np.sqrt(Gamma/2)*se]\; 	, e_ops = [dd, ee], store_measurement=True, options=Options(store_states=True), nsubsteps=100, \; 	solver='predictor-corrector'). hermitian = [(result_sme.states[0][i]).isherm for i in range(N)]. plt.plot(times, result_sme.expect[0], color = 'orange', label='dark'); plt.plot(times, result_sme.expect[1], color = 'black', label='e'); plt.plot(times, hermitian, color = 'blue'); plt.xlim(0,100); plt.xlabel('Time'); plt.ylabel('Population'); plt.savefig('sme.pdf',bbox_inches='tight',pad_inches=0); plt.close(). ```; And the result,; [sme.pdf](https://github.com/qutip/q",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1357
https://github.com/qutip/qutip/issues/1357:64,Safety,predict,predictor-corrector,64,"Hi, I'm wondering if it's possible to control the precision of 'predictor-corrector' solver of the photocurrent_mesolve? Seems like the 'tol' has no effect on the 'predictor-corrector' solver. Here's my code. I was trying to use stochastic master equation to generate the outcome photon sequence from a CPT set up, but I got a diverged outcome sometimes. ```; from qutip import *; import matplotlib.pyplot as plt; import numpy as np; import matplotlib as mpl. params = {; 	'axes.labelsize': 12,; 	'legend.fontsize': 10,; 	'xtick.labelsize': 10,; 	'ytick.labelsize': 10,; 	'figure.figsize': [3*1.4/1.2, 2.8/1.2],#2.3; 	'lines.linewidth' : 1,; 	'axes.linewidth':0.9,; 	'figure.subplot.left':0,; 	'figure.subplot.right':1,; 	'figure.subplot.bottom':0,; 	'figure.subplot.top':1,; 	'grid.linestyle':'--',; 	'axes.grid':False,; 	""font.family"":""serif"",; 	""xtick.direction"":""in"",; 	""ytick.direction"":""in"",. 	}; mpl.rcParams.update(params). T = 100; N = 100000; Gamma = 2*np.pi*13; Omega = 2*np.pi*2. times = np.linspace(0,T,N); ge = fock(3, 0) * fock(3, 1).dag(); se = fock(3, 2) * fock(3, 1).dag(); ss = fock(3, 2) * fock(3, 2).dag(); ee = fock(3, 1) * fock(3, 1).dag(); dark = (fock(3, 2) - fock(3, 0)).unit(); dd = dark*dark.dag(). bias = 2*np.pi*0.1. psi0 = dark. H = Omega * (ge + ge.dag() + se + se.dag()) + bias*ss. result_sme = photocurrent_mesolve(H, psi0, times, c_ops = [],sc_ops = [np.sqrt(Gamma/2)*ge + np.sqrt(Gamma/2)*se]\; 	, e_ops = [dd, ee], store_measurement=True, options=Options(store_states=True), nsubsteps=100, \; 	solver='predictor-corrector'). hermitian = [(result_sme.states[0][i]).isherm for i in range(N)]. plt.plot(times, result_sme.expect[0], color = 'orange', label='dark'); plt.plot(times, result_sme.expect[1], color = 'black', label='e'); plt.plot(times, hermitian, color = 'blue'); plt.xlim(0,100); plt.xlabel('Time'); plt.ylabel('Population'); plt.savefig('sme.pdf',bbox_inches='tight',pad_inches=0); plt.close(). ```; And the result,; [sme.pdf](https://github.com/qutip/q",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1357
https://github.com/qutip/qutip/issues/1357:164,Safety,predict,predictor-corrector,164,"Hi, I'm wondering if it's possible to control the precision of 'predictor-corrector' solver of the photocurrent_mesolve? Seems like the 'tol' has no effect on the 'predictor-corrector' solver. Here's my code. I was trying to use stochastic master equation to generate the outcome photon sequence from a CPT set up, but I got a diverged outcome sometimes. ```; from qutip import *; import matplotlib.pyplot as plt; import numpy as np; import matplotlib as mpl. params = {; 	'axes.labelsize': 12,; 	'legend.fontsize': 10,; 	'xtick.labelsize': 10,; 	'ytick.labelsize': 10,; 	'figure.figsize': [3*1.4/1.2, 2.8/1.2],#2.3; 	'lines.linewidth' : 1,; 	'axes.linewidth':0.9,; 	'figure.subplot.left':0,; 	'figure.subplot.right':1,; 	'figure.subplot.bottom':0,; 	'figure.subplot.top':1,; 	'grid.linestyle':'--',; 	'axes.grid':False,; 	""font.family"":""serif"",; 	""xtick.direction"":""in"",; 	""ytick.direction"":""in"",. 	}; mpl.rcParams.update(params). T = 100; N = 100000; Gamma = 2*np.pi*13; Omega = 2*np.pi*2. times = np.linspace(0,T,N); ge = fock(3, 0) * fock(3, 1).dag(); se = fock(3, 2) * fock(3, 1).dag(); ss = fock(3, 2) * fock(3, 2).dag(); ee = fock(3, 1) * fock(3, 1).dag(); dark = (fock(3, 2) - fock(3, 0)).unit(); dd = dark*dark.dag(). bias = 2*np.pi*0.1. psi0 = dark. H = Omega * (ge + ge.dag() + se + se.dag()) + bias*ss. result_sme = photocurrent_mesolve(H, psi0, times, c_ops = [],sc_ops = [np.sqrt(Gamma/2)*ge + np.sqrt(Gamma/2)*se]\; 	, e_ops = [dd, ee], store_measurement=True, options=Options(store_states=True), nsubsteps=100, \; 	solver='predictor-corrector'). hermitian = [(result_sme.states[0][i]).isherm for i in range(N)]. plt.plot(times, result_sme.expect[0], color = 'orange', label='dark'); plt.plot(times, result_sme.expect[1], color = 'black', label='e'); plt.plot(times, hermitian, color = 'blue'); plt.xlim(0,100); plt.xlabel('Time'); plt.ylabel('Population'); plt.savefig('sme.pdf',bbox_inches='tight',pad_inches=0); plt.close(). ```; And the result,; [sme.pdf](https://github.com/qutip/q",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1357
https://github.com/qutip/qutip/issues/1357:1539,Safety,predict,predictor-corrector,1539,"ems like the 'tol' has no effect on the 'predictor-corrector' solver. Here's my code. I was trying to use stochastic master equation to generate the outcome photon sequence from a CPT set up, but I got a diverged outcome sometimes. ```; from qutip import *; import matplotlib.pyplot as plt; import numpy as np; import matplotlib as mpl. params = {; 	'axes.labelsize': 12,; 	'legend.fontsize': 10,; 	'xtick.labelsize': 10,; 	'ytick.labelsize': 10,; 	'figure.figsize': [3*1.4/1.2, 2.8/1.2],#2.3; 	'lines.linewidth' : 1,; 	'axes.linewidth':0.9,; 	'figure.subplot.left':0,; 	'figure.subplot.right':1,; 	'figure.subplot.bottom':0,; 	'figure.subplot.top':1,; 	'grid.linestyle':'--',; 	'axes.grid':False,; 	""font.family"":""serif"",; 	""xtick.direction"":""in"",; 	""ytick.direction"":""in"",. 	}; mpl.rcParams.update(params). T = 100; N = 100000; Gamma = 2*np.pi*13; Omega = 2*np.pi*2. times = np.linspace(0,T,N); ge = fock(3, 0) * fock(3, 1).dag(); se = fock(3, 2) * fock(3, 1).dag(); ss = fock(3, 2) * fock(3, 2).dag(); ee = fock(3, 1) * fock(3, 1).dag(); dark = (fock(3, 2) - fock(3, 0)).unit(); dd = dark*dark.dag(). bias = 2*np.pi*0.1. psi0 = dark. H = Omega * (ge + ge.dag() + se + se.dag()) + bias*ss. result_sme = photocurrent_mesolve(H, psi0, times, c_ops = [],sc_ops = [np.sqrt(Gamma/2)*ge + np.sqrt(Gamma/2)*se]\; 	, e_ops = [dd, ee], store_measurement=True, options=Options(store_states=True), nsubsteps=100, \; 	solver='predictor-corrector'). hermitian = [(result_sme.states[0][i]).isherm for i in range(N)]. plt.plot(times, result_sme.expect[0], color = 'orange', label='dark'); plt.plot(times, result_sme.expect[1], color = 'black', label='e'); plt.plot(times, hermitian, color = 'blue'); plt.xlim(0,100); plt.xlabel('Time'); plt.ylabel('Population'); plt.savefig('sme.pdf',bbox_inches='tight',pad_inches=0); plt.close(). ```; And the result,; [sme.pdf](https://github.com/qutip/qutip/files/5207120/sme.pdf); (The decline of the blue curve means the density matrix is no longer Hermitian thus diverge.)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1357
https://github.com/qutip/qutip/issues/1358:535,Availability,error,error,535,"**Describe the bug**; I need at some point to modify the internal representation of a state, so I use `myobject.full()`, then I modify the matrix, and recreate a state using `Qobj` (let me know if it's not the usual way to proceed). However, it turns out that the output state does not behave like the initial state: for example I can't apply ptrace on it. Here is a minimal working example:; ``` python; from qutip import *; init_state = tensor(basis(2,0), basis(2,0)); copy_state = Qobj(init_state.full()); init_state.ptrace(0) # No error; copy_state.ptrace(0) # Error !; ```. Demo in the terminal:; ```; In [39]: from qutip import * . In [40]: init_state = tensor(basis(2,0), basis(2,0)) . In [41]: init_state ; Out[41]: ; Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. In [42]: copy_state = Qobj(init_state.full()) . In [43]: copy_state ; Out[43]: ; Quantum object: dims = [[4], [1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. In [44]: init_state.ptrace(0) ; Out[44]: ; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 0.]]. In [45]: copy_state.ptrace(0) ; ---------------------------------------------------------------------------; TypeError Traceback (most recent call last); <ipython-input-45-5b91e5c389a5> in <module>; ----> 1 copy_state.ptrace(0). /nix/store/63j2vgz5klgnr814blqrqhj0mzvb2nyj-qutip-4.5.2/lib/python3.8/site-packages/qutip/qobj.py in ptrace(self, sel, sparse); 1353 return q.tidyup() if settings.auto_tidyup else q; 1354 else:; -> 1355 return _ptrace_dense(self, sel); 1356 ; 1357 def permute(self, order):. /nix/store/63j2vgz5klgnr814blqrqhj0mzvb2nyj-qutip-4.5.2/lib/python3.8/site-packages/qutip/qobj.py in _ptrace_dense(Q, sel); 2197 rd = list(rd); 2198 if isket(Q):; -> 2199 vmat = (Q.full(); 2200 .reshape(rd); 2201 .transpose(sel + qtrace). TypeError: 'numpy.float64' object cannot be interpreted as an integer. ```. **Expected",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1358
https://github.com/qutip/qutip/issues/1358:565,Availability,Error,Error,565,"**Describe the bug**; I need at some point to modify the internal representation of a state, so I use `myobject.full()`, then I modify the matrix, and recreate a state using `Qobj` (let me know if it's not the usual way to proceed). However, it turns out that the output state does not behave like the initial state: for example I can't apply ptrace on it. Here is a minimal working example:; ``` python; from qutip import *; init_state = tensor(basis(2,0), basis(2,0)); copy_state = Qobj(init_state.full()); init_state.ptrace(0) # No error; copy_state.ptrace(0) # Error !; ```. Demo in the terminal:; ```; In [39]: from qutip import * . In [40]: init_state = tensor(basis(2,0), basis(2,0)) . In [41]: init_state ; Out[41]: ; Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. In [42]: copy_state = Qobj(init_state.full()) . In [43]: copy_state ; Out[43]: ; Quantum object: dims = [[4], [1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. In [44]: init_state.ptrace(0) ; Out[44]: ; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 0.]]. In [45]: copy_state.ptrace(0) ; ---------------------------------------------------------------------------; TypeError Traceback (most recent call last); <ipython-input-45-5b91e5c389a5> in <module>; ----> 1 copy_state.ptrace(0). /nix/store/63j2vgz5klgnr814blqrqhj0mzvb2nyj-qutip-4.5.2/lib/python3.8/site-packages/qutip/qobj.py in ptrace(self, sel, sparse); 1353 return q.tidyup() if settings.auto_tidyup else q; 1354 else:; -> 1355 return _ptrace_dense(self, sel); 1356 ; 1357 def permute(self, order):. /nix/store/63j2vgz5klgnr814blqrqhj0mzvb2nyj-qutip-4.5.2/lib/python3.8/site-packages/qutip/qobj.py in _ptrace_dense(Q, sel); 2197 rd = list(rd); 2198 if isket(Q):; -> 2199 vmat = (Q.full(); 2200 .reshape(rd); 2201 .transpose(sel + qtrace). TypeError: 'numpy.float64' object cannot be interpreted as an integer. ```. **Expected",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1358
https://github.com/qutip/qutip/issues/1358:2279,Deployability,install,installed,2279,"peError Traceback (most recent call last); <ipython-input-45-5b91e5c389a5> in <module>; ----> 1 copy_state.ptrace(0). /nix/store/63j2vgz5klgnr814blqrqhj0mzvb2nyj-qutip-4.5.2/lib/python3.8/site-packages/qutip/qobj.py in ptrace(self, sel, sparse); 1353 return q.tidyup() if settings.auto_tidyup else q; 1354 else:; -> 1355 return _ptrace_dense(self, sel); 1356 ; 1357 def permute(self, order):. /nix/store/63j2vgz5klgnr814blqrqhj0mzvb2nyj-qutip-4.5.2/lib/python3.8/site-packages/qutip/qobj.py in _ptrace_dense(Q, sel); 2197 rd = list(rd); 2198 if isket(Q):; -> 2199 vmat = (Q.full(); 2200 .reshape(rd); 2201 .transpose(sel + qtrace). TypeError: 'numpy.float64' object cannot be interpreted as an integer. ```. **Expected behavior**; I would expect that `Qobj(myobject.full())` is a copy of `myobject`, but it turns out it's not (can't ptrace). Note that if it is not a bug (completely possible), I'd be curious to know what is the proper way to do what I need to do. **Your Environment**. qutip is installed via nix:. ```; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, and Boxi Li; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.2; Numpy Version: 1.18.1; Scipy Version: 1.4.1; Cython Version: None; Matplotlib Version: 3.1.3; Python Version: 3.8.3; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64); Installation path: /nix/store/63j2vgz5klgnr814blqrqhj0mzvb2nyj-qutip-4.5.2/lib/python3.8/site-packages/qutip; ==============================================================================; Please cite QuTiP in your publication.; =====================",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1358
https://github.com/qutip/qutip/issues/1358:2962,Deployability,Install,Installed,2962,"qhj0mzvb2nyj-qutip-4.5.2/lib/python3.8/site-packages/qutip/qobj.py in ptrace(self, sel, sparse); 1353 return q.tidyup() if settings.auto_tidyup else q; 1354 else:; -> 1355 return _ptrace_dense(self, sel); 1356 ; 1357 def permute(self, order):. /nix/store/63j2vgz5klgnr814blqrqhj0mzvb2nyj-qutip-4.5.2/lib/python3.8/site-packages/qutip/qobj.py in _ptrace_dense(Q, sel); 2197 rd = list(rd); 2198 if isket(Q):; -> 2199 vmat = (Q.full(); 2200 .reshape(rd); 2201 .transpose(sel + qtrace). TypeError: 'numpy.float64' object cannot be interpreted as an integer. ```. **Expected behavior**; I would expect that `Qobj(myobject.full())` is a copy of `myobject`, but it turns out it's not (can't ptrace). Note that if it is not a bug (completely possible), I'd be curious to know what is the proper way to do what I need to do. **Your Environment**. qutip is installed via nix:. ```; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, and Boxi Li; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.2; Numpy Version: 1.18.1; Scipy Version: 1.4.1; Cython Version: None; Matplotlib Version: 3.1.3; Python Version: 3.8.3; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64); Installation path: /nix/store/63j2vgz5klgnr814blqrqhj0mzvb2nyj-qutip-4.5.2/lib/python3.8/site-packages/qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1358
https://github.com/qutip/qutip/issues/1358:3033,Deployability,Install,Installation,3033,"qhj0mzvb2nyj-qutip-4.5.2/lib/python3.8/site-packages/qutip/qobj.py in ptrace(self, sel, sparse); 1353 return q.tidyup() if settings.auto_tidyup else q; 1354 else:; -> 1355 return _ptrace_dense(self, sel); 1356 ; 1357 def permute(self, order):. /nix/store/63j2vgz5klgnr814blqrqhj0mzvb2nyj-qutip-4.5.2/lib/python3.8/site-packages/qutip/qobj.py in _ptrace_dense(Q, sel); 2197 rd = list(rd); 2198 if isket(Q):; -> 2199 vmat = (Q.full(); 2200 .reshape(rd); 2201 .transpose(sel + qtrace). TypeError: 'numpy.float64' object cannot be interpreted as an integer. ```. **Expected behavior**; I would expect that `Qobj(myobject.full())` is a copy of `myobject`, but it turns out it's not (can't ptrace). Note that if it is not a bug (completely possible), I'd be curious to know what is the proper way to do what I need to do. **Your Environment**. qutip is installed via nix:. ```; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, and Boxi Li; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.2; Numpy Version: 1.18.1; Scipy Version: 1.4.1; Cython Version: None; Matplotlib Version: 3.1.3; Python Version: 3.8.3; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64); Installation path: /nix/store/63j2vgz5klgnr814blqrqhj0mzvb2nyj-qutip-4.5.2/lib/python3.8/site-packages/qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1358
https://github.com/qutip/qutip/issues/1359:71,Usability,guid,guide,71,"Hi all,. I'm getting to the point where I have enough of a developers' guide written, and we should start thinking about how and where to merge it in. It's currently hosted on my account at [jakelishman/qutip-devguide](https://github.com/jakelishman/qutip-devguide), with a rendered version at https://jakelishman.github.io/qutip-devguide. The section on the data layer hopefully gives quite a lot of detail on why the data layer exists, how it works, and how it's implemented. The whole data layer is still in alpha (check out the `dev.major` branch if you want to play with it, and the rest of what will become QuTiP 5.0), so some of the text will need to change, but hopefully it's now enough that if I get hit by a bus tomorrow, the work isn't incomprehensible. Any suggestions on parts to expand are welcome - either leave them in this issue, or make issues/PRs against my repository for the time being (until it's merged somewhere under QuTiP control). Clearly the documentation and notebooks sections aren't written yet, and at some point I'll migrate the packaging and distribution instructions into the dev guide too.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1359
https://github.com/qutip/qutip/issues/1359:959,Usability,Clear,Clearly,959,"Hi all,. I'm getting to the point where I have enough of a developers' guide written, and we should start thinking about how and where to merge it in. It's currently hosted on my account at [jakelishman/qutip-devguide](https://github.com/jakelishman/qutip-devguide), with a rendered version at https://jakelishman.github.io/qutip-devguide. The section on the data layer hopefully gives quite a lot of detail on why the data layer exists, how it works, and how it's implemented. The whole data layer is still in alpha (check out the `dev.major` branch if you want to play with it, and the rest of what will become QuTiP 5.0), so some of the text will need to change, but hopefully it's now enough that if I get hit by a bus tomorrow, the work isn't incomprehensible. Any suggestions on parts to expand are welcome - either leave them in this issue, or make issues/PRs against my repository for the time being (until it's merged somewhere under QuTiP control). Clearly the documentation and notebooks sections aren't written yet, and at some point I'll migrate the packaging and distribution instructions into the dev guide too.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1359
https://github.com/qutip/qutip/issues/1359:1116,Usability,guid,guide,1116,"Hi all,. I'm getting to the point where I have enough of a developers' guide written, and we should start thinking about how and where to merge it in. It's currently hosted on my account at [jakelishman/qutip-devguide](https://github.com/jakelishman/qutip-devguide), with a rendered version at https://jakelishman.github.io/qutip-devguide. The section on the data layer hopefully gives quite a lot of detail on why the data layer exists, how it works, and how it's implemented. The whole data layer is still in alpha (check out the `dev.major` branch if you want to play with it, and the rest of what will become QuTiP 5.0), so some of the text will need to change, but hopefully it's now enough that if I get hit by a bus tomorrow, the work isn't incomprehensible. Any suggestions on parts to expand are welcome - either leave them in this issue, or make issues/PRs against my repository for the time being (until it's merged somewhere under QuTiP control). Clearly the documentation and notebooks sections aren't written yet, and at some point I'll migrate the packaging and distribution instructions into the dev guide too.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1359
https://github.com/qutip/qutip/issues/1360:326,Usability,guid,guide,326,"For now, there is no description of the chosen value of hbar in the documentation of the [evolution solvers](http://qutip.org/docs/latest/apidoc/functions.html#dynamics-and-time-evolution). It seems that the convention `hbar = 1` is used, but it should be documented both in the doctrings of `sesolve`, `mesolve`… and in the [guide](http://qutip.org/docs/latest/guide/dynamics/dynamics-master.html). I even think that the solved equation should be explicitly written in the docstring.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1360
https://github.com/qutip/qutip/issues/1360:362,Usability,guid,guide,362,"For now, there is no description of the chosen value of hbar in the documentation of the [evolution solvers](http://qutip.org/docs/latest/apidoc/functions.html#dynamics-and-time-evolution). It seems that the convention `hbar = 1` is used, but it should be documented both in the doctrings of `sesolve`, `mesolve`… and in the [guide](http://qutip.org/docs/latest/guide/dynamics/dynamics-master.html). I even think that the solved equation should be explicitly written in the docstring.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1360
https://github.com/qutip/qutip/pull/1361:28,Usability,simpl,simplification,28,Minor change - just fixes a simplification I accidentally left in when writing the original function.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1361
https://github.com/qutip/qutip/pull/1362:241,Energy Efficiency,reduce,reduces,241,"This relaxes the amount of sorting required in the `add_csr` operation. In the current version in `dev.major`, both the left and right matrices are sorted in all cases. This PR makes `add_csr` an `Accumulator` operation, which straight away reduces the number of sorts required to one. Second, I add a track inside `scatter` to know whether the scatters were in sorted order; if so, there's no need to sort within `gather`, which removes the other sort from `add_csr`. Effectively, this means that `add_csr` is O(n) when both input matrices are sorted (the most common) and O(n lg(n)) when either isn't, and we don't actually have to perform a separate test to decide between them. In practice, this is around a 2x speedup for most common sparse matrices, and goes up from there. I have also made `Accumulator` a C struct, and all the operations on it header-file only. This allows them to be operated on without holding the GIL (though threaded access to the same one would be unsafe anyway), and it also allows them to be inlined - if they are defined in the `pyx` file, then they will be compiled into a separate object and so must be called. We had talked about making `CSR` have a ""guarantee"" that it is always sorted, but I haven't implemented that here. Because of the changes to `scatter`, that would no longer give an algorithmic speedup in this case for matrices that are sorted (although we could avoid the use of `Accumulator` which would be more efficient). All of the operations I have written return a sorted matrix, so generally matrices will tend to become sorted over time anyway.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1362
https://github.com/qutip/qutip/pull/1362:1459,Energy Efficiency,efficient,efficient,1459,"This relaxes the amount of sorting required in the `add_csr` operation. In the current version in `dev.major`, both the left and right matrices are sorted in all cases. This PR makes `add_csr` an `Accumulator` operation, which straight away reduces the number of sorts required to one. Second, I add a track inside `scatter` to know whether the scatters were in sorted order; if so, there's no need to sort within `gather`, which removes the other sort from `add_csr`. Effectively, this means that `add_csr` is O(n) when both input matrices are sorted (the most common) and O(n lg(n)) when either isn't, and we don't actually have to perform a separate test to decide between them. In practice, this is around a 2x speedup for most common sparse matrices, and goes up from there. I have also made `Accumulator` a C struct, and all the operations on it header-file only. This allows them to be operated on without holding the GIL (though threaded access to the same one would be unsafe anyway), and it also allows them to be inlined - if they are defined in the `pyx` file, then they will be compiled into a separate object and so must be called. We had talked about making `CSR` have a ""guarantee"" that it is always sorted, but I haven't implemented that here. Because of the changes to `scatter`, that would no longer give an algorithmic speedup in this case for matrices that are sorted (although we could avoid the use of `Accumulator` which would be more efficient). All of the operations I have written return a sorted matrix, so generally matrices will tend to become sorted over time anyway.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1362
https://github.com/qutip/qutip/pull/1362:634,Performance,perform,perform,634,"This relaxes the amount of sorting required in the `add_csr` operation. In the current version in `dev.major`, both the left and right matrices are sorted in all cases. This PR makes `add_csr` an `Accumulator` operation, which straight away reduces the number of sorts required to one. Second, I add a track inside `scatter` to know whether the scatters were in sorted order; if so, there's no need to sort within `gather`, which removes the other sort from `add_csr`. Effectively, this means that `add_csr` is O(n) when both input matrices are sorted (the most common) and O(n lg(n)) when either isn't, and we don't actually have to perform a separate test to decide between them. In practice, this is around a 2x speedup for most common sparse matrices, and goes up from there. I have also made `Accumulator` a C struct, and all the operations on it header-file only. This allows them to be operated on without holding the GIL (though threaded access to the same one would be unsafe anyway), and it also allows them to be inlined - if they are defined in the `pyx` file, then they will be compiled into a separate object and so must be called. We had talked about making `CSR` have a ""guarantee"" that it is always sorted, but I haven't implemented that here. Because of the changes to `scatter`, that would no longer give an algorithmic speedup in this case for matrices that are sorted (although we could avoid the use of `Accumulator` which would be more efficient). All of the operations I have written return a sorted matrix, so generally matrices will tend to become sorted over time anyway.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1362
https://github.com/qutip/qutip/pull/1362:978,Safety,unsafe,unsafe,978,"This relaxes the amount of sorting required in the `add_csr` operation. In the current version in `dev.major`, both the left and right matrices are sorted in all cases. This PR makes `add_csr` an `Accumulator` operation, which straight away reduces the number of sorts required to one. Second, I add a track inside `scatter` to know whether the scatters were in sorted order; if so, there's no need to sort within `gather`, which removes the other sort from `add_csr`. Effectively, this means that `add_csr` is O(n) when both input matrices are sorted (the most common) and O(n lg(n)) when either isn't, and we don't actually have to perform a separate test to decide between them. In practice, this is around a 2x speedup for most common sparse matrices, and goes up from there. I have also made `Accumulator` a C struct, and all the operations on it header-file only. This allows them to be operated on without holding the GIL (though threaded access to the same one would be unsafe anyway), and it also allows them to be inlined - if they are defined in the `pyx` file, then they will be compiled into a separate object and so must be called. We had talked about making `CSR` have a ""guarantee"" that it is always sorted, but I haven't implemented that here. Because of the changes to `scatter`, that would no longer give an algorithmic speedup in this case for matrices that are sorted (although we could avoid the use of `Accumulator` which would be more efficient). All of the operations I have written return a sorted matrix, so generally matrices will tend to become sorted over time anyway.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1362
https://github.com/qutip/qutip/pull/1362:1408,Safety,avoid,avoid,1408,"This relaxes the amount of sorting required in the `add_csr` operation. In the current version in `dev.major`, both the left and right matrices are sorted in all cases. This PR makes `add_csr` an `Accumulator` operation, which straight away reduces the number of sorts required to one. Second, I add a track inside `scatter` to know whether the scatters were in sorted order; if so, there's no need to sort within `gather`, which removes the other sort from `add_csr`. Effectively, this means that `add_csr` is O(n) when both input matrices are sorted (the most common) and O(n lg(n)) when either isn't, and we don't actually have to perform a separate test to decide between them. In practice, this is around a 2x speedup for most common sparse matrices, and goes up from there. I have also made `Accumulator` a C struct, and all the operations on it header-file only. This allows them to be operated on without holding the GIL (though threaded access to the same one would be unsafe anyway), and it also allows them to be inlined - if they are defined in the `pyx` file, then they will be compiled into a separate object and so must be called. We had talked about making `CSR` have a ""guarantee"" that it is always sorted, but I haven't implemented that here. Because of the changes to `scatter`, that would no longer give an algorithmic speedup in this case for matrices that are sorted (although we could avoid the use of `Accumulator` which would be more efficient). All of the operations I have written return a sorted matrix, so generally matrices will tend to become sorted over time anyway.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1362
https://github.com/qutip/qutip/pull/1362:946,Security,access,access,946,"This relaxes the amount of sorting required in the `add_csr` operation. In the current version in `dev.major`, both the left and right matrices are sorted in all cases. This PR makes `add_csr` an `Accumulator` operation, which straight away reduces the number of sorts required to one. Second, I add a track inside `scatter` to know whether the scatters were in sorted order; if so, there's no need to sort within `gather`, which removes the other sort from `add_csr`. Effectively, this means that `add_csr` is O(n) when both input matrices are sorted (the most common) and O(n lg(n)) when either isn't, and we don't actually have to perform a separate test to decide between them. In practice, this is around a 2x speedup for most common sparse matrices, and goes up from there. I have also made `Accumulator` a C struct, and all the operations on it header-file only. This allows them to be operated on without holding the GIL (though threaded access to the same one would be unsafe anyway), and it also allows them to be inlined - if they are defined in the `pyx` file, then they will be compiled into a separate object and so must be called. We had talked about making `CSR` have a ""guarantee"" that it is always sorted, but I haven't implemented that here. Because of the changes to `scatter`, that would no longer give an algorithmic speedup in this case for matrices that are sorted (although we could avoid the use of `Accumulator` which would be more efficient). All of the operations I have written return a sorted matrix, so generally matrices will tend to become sorted over time anyway.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1362
https://github.com/qutip/qutip/pull/1362:653,Testability,test,test,653,"This relaxes the amount of sorting required in the `add_csr` operation. In the current version in `dev.major`, both the left and right matrices are sorted in all cases. This PR makes `add_csr` an `Accumulator` operation, which straight away reduces the number of sorts required to one. Second, I add a track inside `scatter` to know whether the scatters were in sorted order; if so, there's no need to sort within `gather`, which removes the other sort from `add_csr`. Effectively, this means that `add_csr` is O(n) when both input matrices are sorted (the most common) and O(n lg(n)) when either isn't, and we don't actually have to perform a separate test to decide between them. In practice, this is around a 2x speedup for most common sparse matrices, and goes up from there. I have also made `Accumulator` a C struct, and all the operations on it header-file only. This allows them to be operated on without holding the GIL (though threaded access to the same one would be unsafe anyway), and it also allows them to be inlined - if they are defined in the `pyx` file, then they will be compiled into a separate object and so must be called. We had talked about making `CSR` have a ""guarantee"" that it is always sorted, but I haven't implemented that here. Because of the changes to `scatter`, that would no longer give an algorithmic speedup in this case for matrices that are sorted (although we could avoid the use of `Accumulator` which would be more efficient). All of the operations I have written return a sorted matrix, so generally matrices will tend to become sorted over time anyway.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1362
https://github.com/qutip/qutip/pull/1363:304,Availability,error,errors,304,"Fix a testing set-up regression made in #1348 - the version of SciPy was meant to be constrained to <1.5 to test compatibility with the older version of the sparse matrices, but the version constraint got omitted when I rewrote the `.travis.yml` file. The specific bugs that that test is meant to catch (errors handling `scipy.sparse.csr_matrix` matrix multiplication) can't be present in this branch anyway, because the new data types don't use scipy internals. Still, it's good to test against older versions of scipy as well - in 1.5 they changed some numerics in the eigenvalue solvers, which caused a whole bunch of our tests to break because we relied on the gauge and order of the vectors returned remaining constant.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1363
https://github.com/qutip/qutip/pull/1363:6,Testability,test,testing,6,"Fix a testing set-up regression made in #1348 - the version of SciPy was meant to be constrained to <1.5 to test compatibility with the older version of the sparse matrices, but the version constraint got omitted when I rewrote the `.travis.yml` file. The specific bugs that that test is meant to catch (errors handling `scipy.sparse.csr_matrix` matrix multiplication) can't be present in this branch anyway, because the new data types don't use scipy internals. Still, it's good to test against older versions of scipy as well - in 1.5 they changed some numerics in the eigenvalue solvers, which caused a whole bunch of our tests to break because we relied on the gauge and order of the vectors returned remaining constant.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1363
https://github.com/qutip/qutip/pull/1363:108,Testability,test,test,108,"Fix a testing set-up regression made in #1348 - the version of SciPy was meant to be constrained to <1.5 to test compatibility with the older version of the sparse matrices, but the version constraint got omitted when I rewrote the `.travis.yml` file. The specific bugs that that test is meant to catch (errors handling `scipy.sparse.csr_matrix` matrix multiplication) can't be present in this branch anyway, because the new data types don't use scipy internals. Still, it's good to test against older versions of scipy as well - in 1.5 they changed some numerics in the eigenvalue solvers, which caused a whole bunch of our tests to break because we relied on the gauge and order of the vectors returned remaining constant.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1363
https://github.com/qutip/qutip/pull/1363:280,Testability,test,test,280,"Fix a testing set-up regression made in #1348 - the version of SciPy was meant to be constrained to <1.5 to test compatibility with the older version of the sparse matrices, but the version constraint got omitted when I rewrote the `.travis.yml` file. The specific bugs that that test is meant to catch (errors handling `scipy.sparse.csr_matrix` matrix multiplication) can't be present in this branch anyway, because the new data types don't use scipy internals. Still, it's good to test against older versions of scipy as well - in 1.5 they changed some numerics in the eigenvalue solvers, which caused a whole bunch of our tests to break because we relied on the gauge and order of the vectors returned remaining constant.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1363
https://github.com/qutip/qutip/pull/1363:483,Testability,test,test,483,"Fix a testing set-up regression made in #1348 - the version of SciPy was meant to be constrained to <1.5 to test compatibility with the older version of the sparse matrices, but the version constraint got omitted when I rewrote the `.travis.yml` file. The specific bugs that that test is meant to catch (errors handling `scipy.sparse.csr_matrix` matrix multiplication) can't be present in this branch anyway, because the new data types don't use scipy internals. Still, it's good to test against older versions of scipy as well - in 1.5 they changed some numerics in the eigenvalue solvers, which caused a whole bunch of our tests to break because we relied on the gauge and order of the vectors returned remaining constant.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1363
https://github.com/qutip/qutip/pull/1363:625,Testability,test,tests,625,"Fix a testing set-up regression made in #1348 - the version of SciPy was meant to be constrained to <1.5 to test compatibility with the older version of the sparse matrices, but the version constraint got omitted when I rewrote the `.travis.yml` file. The specific bugs that that test is meant to catch (errors handling `scipy.sparse.csr_matrix` matrix multiplication) can't be present in this branch anyway, because the new data types don't use scipy internals. Still, it's good to test against older versions of scipy as well - in 1.5 they changed some numerics in the eigenvalue solvers, which caused a whole bunch of our tests to break because we relied on the gauge and order of the vectors returned remaining constant.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1363
https://github.com/qutip/qutip/issues/1364:64,Integrability,depend,dependent,64,"Hi, I am wondering if qutip can calculate the average of a time-dependent observable or probability of a time-dependent state when simulate a time-dependent Hamiltonian. It sounds a little weird, but it indeed occurs when we consider a time-dependent Hamiltonian in a new state representation. The related unitary transformation can be time-dependent. Do built-in solver support it? . For example, ; ```; observable = [[O1,coeff1],[O2,coeff2],...]; output = qt.sesolve(H,psi0,times,observable); ```; where `coeff1(t,args)` and `coeff2(t,args)` are coefficient functions.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1364
https://github.com/qutip/qutip/issues/1364:110,Integrability,depend,dependent,110,"Hi, I am wondering if qutip can calculate the average of a time-dependent observable or probability of a time-dependent state when simulate a time-dependent Hamiltonian. It sounds a little weird, but it indeed occurs when we consider a time-dependent Hamiltonian in a new state representation. The related unitary transformation can be time-dependent. Do built-in solver support it? . For example, ; ```; observable = [[O1,coeff1],[O2,coeff2],...]; output = qt.sesolve(H,psi0,times,observable); ```; where `coeff1(t,args)` and `coeff2(t,args)` are coefficient functions.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1364
https://github.com/qutip/qutip/issues/1364:147,Integrability,depend,dependent,147,"Hi, I am wondering if qutip can calculate the average of a time-dependent observable or probability of a time-dependent state when simulate a time-dependent Hamiltonian. It sounds a little weird, but it indeed occurs when we consider a time-dependent Hamiltonian in a new state representation. The related unitary transformation can be time-dependent. Do built-in solver support it? . For example, ; ```; observable = [[O1,coeff1],[O2,coeff2],...]; output = qt.sesolve(H,psi0,times,observable); ```; where `coeff1(t,args)` and `coeff2(t,args)` are coefficient functions.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1364
https://github.com/qutip/qutip/issues/1364:241,Integrability,depend,dependent,241,"Hi, I am wondering if qutip can calculate the average of a time-dependent observable or probability of a time-dependent state when simulate a time-dependent Hamiltonian. It sounds a little weird, but it indeed occurs when we consider a time-dependent Hamiltonian in a new state representation. The related unitary transformation can be time-dependent. Do built-in solver support it? . For example, ; ```; observable = [[O1,coeff1],[O2,coeff2],...]; output = qt.sesolve(H,psi0,times,observable); ```; where `coeff1(t,args)` and `coeff2(t,args)` are coefficient functions.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1364
https://github.com/qutip/qutip/issues/1364:341,Integrability,depend,dependent,341,"Hi, I am wondering if qutip can calculate the average of a time-dependent observable or probability of a time-dependent state when simulate a time-dependent Hamiltonian. It sounds a little weird, but it indeed occurs when we consider a time-dependent Hamiltonian in a new state representation. The related unitary transformation can be time-dependent. Do built-in solver support it? . For example, ; ```; observable = [[O1,coeff1],[O2,coeff2],...]; output = qt.sesolve(H,psi0,times,observable); ```; where `coeff1(t,args)` and `coeff2(t,args)` are coefficient functions.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1364
https://github.com/qutip/qutip/pull/1365:17,Deployability,Integrat,Integrate,17,**Description**; Integrate the scheduler into Processor. Users can choose to first schedule the circuit/control pulses before running the simulation. **Changelog**; Supports Processor with the scheduler.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1365
https://github.com/qutip/qutip/pull/1365:31,Energy Efficiency,schedul,scheduler,31,**Description**; Integrate the scheduler into Processor. Users can choose to first schedule the circuit/control pulses before running the simulation. **Changelog**; Supports Processor with the scheduler.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1365
https://github.com/qutip/qutip/pull/1365:83,Energy Efficiency,schedul,schedule,83,**Description**; Integrate the scheduler into Processor. Users can choose to first schedule the circuit/control pulses before running the simulation. **Changelog**; Supports Processor with the scheduler.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1365
https://github.com/qutip/qutip/pull/1365:193,Energy Efficiency,schedul,scheduler,193,**Description**; Integrate the scheduler into Processor. Users can choose to first schedule the circuit/control pulses before running the simulation. **Changelog**; Supports Processor with the scheduler.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1365
https://github.com/qutip/qutip/pull/1365:17,Integrability,Integrat,Integrate,17,**Description**; Integrate the scheduler into Processor. Users can choose to first schedule the circuit/control pulses before running the simulation. **Changelog**; Supports Processor with the scheduler.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1365
https://github.com/qutip/qutip/issues/1366:178,Integrability,depend,dependent,178,"Dear Everyone,. Thanks for the great job with Qutip package. I am amazed by the package and how various models and techniques are implemented on it. . I have been using the time-dependent bloch-redfield solver lately and the runtime is superb when I convert all the Hamiltonian and the collapse operators to string format, and use the solver option reuse_rhs=True. I really wish I could run sweeps over the bath parameters while still retaining the original Hamiltonian without having to recompile it. It would be nice if you could extend the scope of args so that bath parameters could also be passed as arguments of the call. . The second issue is that the cython file that the brmesolver creates is missing the import scypi.spe, that is the special functions from Scipy. One needs to add the following lines to the BR_codegen:. import scipy.special as spe; cimport scipy.special as spe",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1366
https://github.com/qutip/qutip/issues/1366:532,Modifiability,extend,extend,532,"Dear Everyone,. Thanks for the great job with Qutip package. I am amazed by the package and how various models and techniques are implemented on it. . I have been using the time-dependent bloch-redfield solver lately and the runtime is superb when I convert all the Hamiltonian and the collapse operators to string format, and use the solver option reuse_rhs=True. I really wish I could run sweeps over the bath parameters while still retaining the original Hamiltonian without having to recompile it. It would be nice if you could extend the scope of args so that bath parameters could also be passed as arguments of the call. . The second issue is that the cython file that the brmesolver creates is missing the import scypi.spe, that is the special functions from Scipy. One needs to add the following lines to the BR_codegen:. import scipy.special as spe; cimport scipy.special as spe",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1366
https://github.com/qutip/qutip/pull/1367:244,Performance,optimiz,optimization,244,"**Description**; Added the possibility of providing a custom initial pulse in qutip.control functions. The user can now use the following syntax:; ```; init_pulse_params = {}; init_pulse_params['init_custom_pulse'] = my_init_pulse_array. # Run optimization; result = optimize_pulse_unitary(H_drift, H_control, uni_ini, uni_targ,; num_tslots, gate_time, ; init_pulse_type='CUSTOM', init_pulse_params=init_pulse_params); ```; when calling functions such as optimize_pulse_unitary() or optimize_pulse(). The custom array should be passed in the init_pulse_params dictionnary, and should be of size (n_tslots x n_ctrls). **Changelog**; Added the possibility of providing a custom initial pulse in qutip.control functions.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1367
https://github.com/qutip/qutip/issues/1368:797,Availability,error,error,797,"I am trying to run this code to test mcsolve():; ```; import numpy as np; from qutip import *. def hamiltonian_t(t, args):; #; # evaluate the hamiltonian at time t. ; #; H0 = args['H0']; H1 = args['H1']; w = args['w']. return H0 + H1 * np.sin(w*t). N = 2 # set where to truncate Fock state for cavity; a = destroy(N); psi0 = basis(N, 0) # define initial state. w_c = 1.0 * 2 * np.pi # cavity frequency; w = w_c; kappa = 0.001 * 2 * np.pi. H0 = w_c * a.dag()*a # time-independent term; H1 = kappa*(a.dag() + a) # time-dependent term. c_ops = [] # Build collapse operators; c_ops.append(np.sqrt(kappa) * a). args = {'H0': H0, 'H1': H1, 'w': w}. times = np.linspace(0, 10, 100) # define time vector. output = mcsolve(hamiltonian_t, psi0, times, c_ops, [a.dag()*a], args=args); ```. I am getting this error:; ```; Traceback (most recent call last):; File ""/usr/local/lib64/python3.6/site-packages/qutip/mcsolve.py"", line 365, in run_test; rhs, ode_args = self.ss.makefunc(ss); NameError: name 'ss' is not defined. During handling of the above exception, another exception occurred:. Traceback (most recent call last):; File ""mc_solve_example2.py"", line 33, in <module>; output = mcsolve(hamiltonian_t, psi0, times, c_ops, [a.dag()*a], args=args); File ""/usr/local/lib64/python3.6/site-packages/qutip/mcsolve.py"", line 223, in mcsolve; mc.run_test(); File ""/usr/local/lib64/python3.6/site-packages/qutip/mcsolve.py"", line 368, in run_test; raise Exception(""Error calculating H""); Exception: Error calculating H; ```. Here is the output of qutip.about(); ```; QuTiP Version: 4.5.1; Numpy Version: 1.18.4; Scipy Version: 1.4.1; Cython Version: 0.29.19; Matplotlib Version: 3.2.1; Python Version: 3.6.8; Number of CPUs: 112; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64); ```. Any advice how to fix that?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1368
https://github.com/qutip/qutip/issues/1368:1452,Availability,Error,Error,1452,"I am trying to run this code to test mcsolve():; ```; import numpy as np; from qutip import *. def hamiltonian_t(t, args):; #; # evaluate the hamiltonian at time t. ; #; H0 = args['H0']; H1 = args['H1']; w = args['w']. return H0 + H1 * np.sin(w*t). N = 2 # set where to truncate Fock state for cavity; a = destroy(N); psi0 = basis(N, 0) # define initial state. w_c = 1.0 * 2 * np.pi # cavity frequency; w = w_c; kappa = 0.001 * 2 * np.pi. H0 = w_c * a.dag()*a # time-independent term; H1 = kappa*(a.dag() + a) # time-dependent term. c_ops = [] # Build collapse operators; c_ops.append(np.sqrt(kappa) * a). args = {'H0': H0, 'H1': H1, 'w': w}. times = np.linspace(0, 10, 100) # define time vector. output = mcsolve(hamiltonian_t, psi0, times, c_ops, [a.dag()*a], args=args); ```. I am getting this error:; ```; Traceback (most recent call last):; File ""/usr/local/lib64/python3.6/site-packages/qutip/mcsolve.py"", line 365, in run_test; rhs, ode_args = self.ss.makefunc(ss); NameError: name 'ss' is not defined. During handling of the above exception, another exception occurred:. Traceback (most recent call last):; File ""mc_solve_example2.py"", line 33, in <module>; output = mcsolve(hamiltonian_t, psi0, times, c_ops, [a.dag()*a], args=args); File ""/usr/local/lib64/python3.6/site-packages/qutip/mcsolve.py"", line 223, in mcsolve; mc.run_test(); File ""/usr/local/lib64/python3.6/site-packages/qutip/mcsolve.py"", line 368, in run_test; raise Exception(""Error calculating H""); Exception: Error calculating H; ```. Here is the output of qutip.about(); ```; QuTiP Version: 4.5.1; Numpy Version: 1.18.4; Scipy Version: 1.4.1; Cython Version: 0.29.19; Matplotlib Version: 3.2.1; Python Version: 3.6.8; Number of CPUs: 112; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64); ```. Any advice how to fix that?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1368
https://github.com/qutip/qutip/issues/1368:1486,Availability,Error,Error,1486,"I am trying to run this code to test mcsolve():; ```; import numpy as np; from qutip import *. def hamiltonian_t(t, args):; #; # evaluate the hamiltonian at time t. ; #; H0 = args['H0']; H1 = args['H1']; w = args['w']. return H0 + H1 * np.sin(w*t). N = 2 # set where to truncate Fock state for cavity; a = destroy(N); psi0 = basis(N, 0) # define initial state. w_c = 1.0 * 2 * np.pi # cavity frequency; w = w_c; kappa = 0.001 * 2 * np.pi. H0 = w_c * a.dag()*a # time-independent term; H1 = kappa*(a.dag() + a) # time-dependent term. c_ops = [] # Build collapse operators; c_ops.append(np.sqrt(kappa) * a). args = {'H0': H0, 'H1': H1, 'w': w}. times = np.linspace(0, 10, 100) # define time vector. output = mcsolve(hamiltonian_t, psi0, times, c_ops, [a.dag()*a], args=args); ```. I am getting this error:; ```; Traceback (most recent call last):; File ""/usr/local/lib64/python3.6/site-packages/qutip/mcsolve.py"", line 365, in run_test; rhs, ode_args = self.ss.makefunc(ss); NameError: name 'ss' is not defined. During handling of the above exception, another exception occurred:. Traceback (most recent call last):; File ""mc_solve_example2.py"", line 33, in <module>; output = mcsolve(hamiltonian_t, psi0, times, c_ops, [a.dag()*a], args=args); File ""/usr/local/lib64/python3.6/site-packages/qutip/mcsolve.py"", line 223, in mcsolve; mc.run_test(); File ""/usr/local/lib64/python3.6/site-packages/qutip/mcsolve.py"", line 368, in run_test; raise Exception(""Error calculating H""); Exception: Error calculating H; ```. Here is the output of qutip.about(); ```; QuTiP Version: 4.5.1; Numpy Version: 1.18.4; Scipy Version: 1.4.1; Cython Version: 0.29.19; Matplotlib Version: 3.2.1; Python Version: 3.6.8; Number of CPUs: 112; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64); ```. Any advice how to fix that?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1368
https://github.com/qutip/qutip/issues/1368:1745,Deployability,Install,Installed,1745,"I am trying to run this code to test mcsolve():; ```; import numpy as np; from qutip import *. def hamiltonian_t(t, args):; #; # evaluate the hamiltonian at time t. ; #; H0 = args['H0']; H1 = args['H1']; w = args['w']. return H0 + H1 * np.sin(w*t). N = 2 # set where to truncate Fock state for cavity; a = destroy(N); psi0 = basis(N, 0) # define initial state. w_c = 1.0 * 2 * np.pi # cavity frequency; w = w_c; kappa = 0.001 * 2 * np.pi. H0 = w_c * a.dag()*a # time-independent term; H1 = kappa*(a.dag() + a) # time-dependent term. c_ops = [] # Build collapse operators; c_ops.append(np.sqrt(kappa) * a). args = {'H0': H0, 'H1': H1, 'w': w}. times = np.linspace(0, 10, 100) # define time vector. output = mcsolve(hamiltonian_t, psi0, times, c_ops, [a.dag()*a], args=args); ```. I am getting this error:; ```; Traceback (most recent call last):; File ""/usr/local/lib64/python3.6/site-packages/qutip/mcsolve.py"", line 365, in run_test; rhs, ode_args = self.ss.makefunc(ss); NameError: name 'ss' is not defined. During handling of the above exception, another exception occurred:. Traceback (most recent call last):; File ""mc_solve_example2.py"", line 33, in <module>; output = mcsolve(hamiltonian_t, psi0, times, c_ops, [a.dag()*a], args=args); File ""/usr/local/lib64/python3.6/site-packages/qutip/mcsolve.py"", line 223, in mcsolve; mc.run_test(); File ""/usr/local/lib64/python3.6/site-packages/qutip/mcsolve.py"", line 368, in run_test; raise Exception(""Error calculating H""); Exception: Error calculating H; ```. Here is the output of qutip.about(); ```; QuTiP Version: 4.5.1; Numpy Version: 1.18.4; Scipy Version: 1.4.1; Cython Version: 0.29.19; Matplotlib Version: 3.2.1; Python Version: 3.6.8; Number of CPUs: 112; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64); ```. Any advice how to fix that?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1368
https://github.com/qutip/qutip/issues/1368:517,Integrability,depend,dependent,517,"I am trying to run this code to test mcsolve():; ```; import numpy as np; from qutip import *. def hamiltonian_t(t, args):; #; # evaluate the hamiltonian at time t. ; #; H0 = args['H0']; H1 = args['H1']; w = args['w']. return H0 + H1 * np.sin(w*t). N = 2 # set where to truncate Fock state for cavity; a = destroy(N); psi0 = basis(N, 0) # define initial state. w_c = 1.0 * 2 * np.pi # cavity frequency; w = w_c; kappa = 0.001 * 2 * np.pi. H0 = w_c * a.dag()*a # time-independent term; H1 = kappa*(a.dag() + a) # time-dependent term. c_ops = [] # Build collapse operators; c_ops.append(np.sqrt(kappa) * a). args = {'H0': H0, 'H1': H1, 'w': w}. times = np.linspace(0, 10, 100) # define time vector. output = mcsolve(hamiltonian_t, psi0, times, c_ops, [a.dag()*a], args=args); ```. I am getting this error:; ```; Traceback (most recent call last):; File ""/usr/local/lib64/python3.6/site-packages/qutip/mcsolve.py"", line 365, in run_test; rhs, ode_args = self.ss.makefunc(ss); NameError: name 'ss' is not defined. During handling of the above exception, another exception occurred:. Traceback (most recent call last):; File ""mc_solve_example2.py"", line 33, in <module>; output = mcsolve(hamiltonian_t, psi0, times, c_ops, [a.dag()*a], args=args); File ""/usr/local/lib64/python3.6/site-packages/qutip/mcsolve.py"", line 223, in mcsolve; mc.run_test(); File ""/usr/local/lib64/python3.6/site-packages/qutip/mcsolve.py"", line 368, in run_test; raise Exception(""Error calculating H""); Exception: Error calculating H; ```. Here is the output of qutip.about(); ```; QuTiP Version: 4.5.1; Numpy Version: 1.18.4; Scipy Version: 1.4.1; Cython Version: 0.29.19; Matplotlib Version: 3.2.1; Python Version: 3.6.8; Number of CPUs: 112; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64); ```. Any advice how to fix that?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1368
https://github.com/qutip/qutip/issues/1368:32,Testability,test,test,32,"I am trying to run this code to test mcsolve():; ```; import numpy as np; from qutip import *. def hamiltonian_t(t, args):; #; # evaluate the hamiltonian at time t. ; #; H0 = args['H0']; H1 = args['H1']; w = args['w']. return H0 + H1 * np.sin(w*t). N = 2 # set where to truncate Fock state for cavity; a = destroy(N); psi0 = basis(N, 0) # define initial state. w_c = 1.0 * 2 * np.pi # cavity frequency; w = w_c; kappa = 0.001 * 2 * np.pi. H0 = w_c * a.dag()*a # time-independent term; H1 = kappa*(a.dag() + a) # time-dependent term. c_ops = [] # Build collapse operators; c_ops.append(np.sqrt(kappa) * a). args = {'H0': H0, 'H1': H1, 'w': w}. times = np.linspace(0, 10, 100) # define time vector. output = mcsolve(hamiltonian_t, psi0, times, c_ops, [a.dag()*a], args=args); ```. I am getting this error:; ```; Traceback (most recent call last):; File ""/usr/local/lib64/python3.6/site-packages/qutip/mcsolve.py"", line 365, in run_test; rhs, ode_args = self.ss.makefunc(ss); NameError: name 'ss' is not defined. During handling of the above exception, another exception occurred:. Traceback (most recent call last):; File ""mc_solve_example2.py"", line 33, in <module>; output = mcsolve(hamiltonian_t, psi0, times, c_ops, [a.dag()*a], args=args); File ""/usr/local/lib64/python3.6/site-packages/qutip/mcsolve.py"", line 223, in mcsolve; mc.run_test(); File ""/usr/local/lib64/python3.6/site-packages/qutip/mcsolve.py"", line 368, in run_test; raise Exception(""Error calculating H""); Exception: Error calculating H; ```. Here is the output of qutip.about(); ```; QuTiP Version: 4.5.1; Numpy Version: 1.18.4; Scipy Version: 1.4.1; Cython Version: 0.29.19; Matplotlib Version: 3.2.1; Python Version: 3.6.8; Number of CPUs: 112; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64); ```. Any advice how to fix that?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1368
https://github.com/qutip/qutip/pull/1369:251,Performance,optimiz,optimization,251,"**Description**; - Added the possibility of providing a custom initial pulse in qutip.control functions. The user can now use the following syntax:. ```; init_pulse_params = {}; init_pulse_params['init_custom_pulse'] = my_init_pulse_array. # Run some optimization; result = optimize_pulse(H_drift, H_control, uni_ini, uni_targ,; num_tslots, gate_time, ; init_pulse_type='CUSTOM', init_pulse_params=init_pulse_params); ```; The custom array should be passed in the init_pulse_params dictionnary, and should be of size (n_tslots x n_ctrls). - Added the possibility of giving a different upper and lower bound for every control at every time slot, instead of a single bound for all controls and all time slots. The upper and lower bound should be arrays of size (n_tslots x n_ctrls). The syntax is the following:; ```; lbound = np.zeros((num_tslots, num_ctrls)); lbound = my_lbound_array; ubound = np.zeros((num_tslots, num_ctrls)); ubound = my_ubound_array. # Run some optimization; result = optimize_pulse(H_drift, H_control, uni_ini, uni_targ,; num_tslots, gate_time, ; amp_lbound = lbound, amp_ubound = ubound); ```. **Changelog**; Added new features for initial pulses to the qutip.control functions.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1369
https://github.com/qutip/qutip/pull/1369:967,Performance,optimiz,optimization,967,"**Description**; - Added the possibility of providing a custom initial pulse in qutip.control functions. The user can now use the following syntax:. ```; init_pulse_params = {}; init_pulse_params['init_custom_pulse'] = my_init_pulse_array. # Run some optimization; result = optimize_pulse(H_drift, H_control, uni_ini, uni_targ,; num_tslots, gate_time, ; init_pulse_type='CUSTOM', init_pulse_params=init_pulse_params); ```; The custom array should be passed in the init_pulse_params dictionnary, and should be of size (n_tslots x n_ctrls). - Added the possibility of giving a different upper and lower bound for every control at every time slot, instead of a single bound for all controls and all time slots. The upper and lower bound should be arrays of size (n_tslots x n_ctrls). The syntax is the following:; ```; lbound = np.zeros((num_tslots, num_ctrls)); lbound = my_lbound_array; ubound = np.zeros((num_tslots, num_ctrls)); ubound = my_ubound_array. # Run some optimization; result = optimize_pulse(H_drift, H_control, uni_ini, uni_targ,; num_tslots, gate_time, ; amp_lbound = lbound, amp_ubound = ubound); ```. **Changelog**; Added new features for initial pulses to the qutip.control functions.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1369
https://github.com/qutip/qutip/issues/1371:315,Availability,error,errors,315,"@tehruhn and I found that trying to install qutip from pip with the latest python 3.9 fails. When we run the installations from a fresh conda env (conda 4.8.5) using pip as. ```; pip install qutip; ```; or with conda (using both). ```; conda install -c conda-forge qutip; conda install qutip; ```. we get different errors. The errors do not occur if we use python3.8 while creating the conda environment as. ```; conda create -n py38 python==3.8; ```. Looking at the error it seems there is specification that prohibits python 3.9. @jakelishman @Ericgig any idea about this?. # Steps to reproduce (with conda 4.8.5). ```; conda create -n qutip-test python=3.9; conda activate qutip-test; conda install -c conda-forge qutip; ```. ### Error; ```; Collecting package metadata (current_repodata.json): done; Solving environment: failed with initial frozen solve. Retrying with flexible solve.; Solving environment: failed with repodata from current_repodata.json, will retry with next repodata source.; Collecting package metadata (repodata.json): done; Solving environment: failed with initial frozen solve. Retrying with flexible solve.; Solving environment: \; Found conflicts! Looking for incompatible packages.; This can take several minutes. Press CTRL-C to abort.; failed. UnsatisfiableError: The following specifications were found; to be incompatible with the existing python installation in your environment:. Specifications:. - qutip -> python[version='2.7.*|3.5.*|3.6.*|>=2.7,<2.8.0a0|>=3.6,<3.7.0a0|>=3.7,<3.8.0a0|>=3.8,<3.9.0a0|>=3.5,<3.6.0a0|3.4.*']. Your python: python=3.9. If python is on the left-most side of the chain, that's the version you've asked for.; When python appears to the right, that indicates that the thing on the left is somehow; not available for the python version you are constrained to. Note that conda will not; change your python version to a different minor version unless you explicitly specify; that. Note that strict channel priority may have removed packages",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1371
https://github.com/qutip/qutip/issues/1371:327,Availability,error,errors,327,"@tehruhn and I found that trying to install qutip from pip with the latest python 3.9 fails. When we run the installations from a fresh conda env (conda 4.8.5) using pip as. ```; pip install qutip; ```; or with conda (using both). ```; conda install -c conda-forge qutip; conda install qutip; ```. we get different errors. The errors do not occur if we use python3.8 while creating the conda environment as. ```; conda create -n py38 python==3.8; ```. Looking at the error it seems there is specification that prohibits python 3.9. @jakelishman @Ericgig any idea about this?. # Steps to reproduce (with conda 4.8.5). ```; conda create -n qutip-test python=3.9; conda activate qutip-test; conda install -c conda-forge qutip; ```. ### Error; ```; Collecting package metadata (current_repodata.json): done; Solving environment: failed with initial frozen solve. Retrying with flexible solve.; Solving environment: failed with repodata from current_repodata.json, will retry with next repodata source.; Collecting package metadata (repodata.json): done; Solving environment: failed with initial frozen solve. Retrying with flexible solve.; Solving environment: \; Found conflicts! Looking for incompatible packages.; This can take several minutes. Press CTRL-C to abort.; failed. UnsatisfiableError: The following specifications were found; to be incompatible with the existing python installation in your environment:. Specifications:. - qutip -> python[version='2.7.*|3.5.*|3.6.*|>=2.7,<2.8.0a0|>=3.6,<3.7.0a0|>=3.7,<3.8.0a0|>=3.8,<3.9.0a0|>=3.5,<3.6.0a0|3.4.*']. Your python: python=3.9. If python is on the left-most side of the chain, that's the version you've asked for.; When python appears to the right, that indicates that the thing on the left is somehow; not available for the python version you are constrained to. Note that conda will not; change your python version to a different minor version unless you explicitly specify; that. Note that strict channel priority may have removed packages",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1371
https://github.com/qutip/qutip/issues/1371:467,Availability,error,error,467,"@tehruhn and I found that trying to install qutip from pip with the latest python 3.9 fails. When we run the installations from a fresh conda env (conda 4.8.5) using pip as. ```; pip install qutip; ```; or with conda (using both). ```; conda install -c conda-forge qutip; conda install qutip; ```. we get different errors. The errors do not occur if we use python3.8 while creating the conda environment as. ```; conda create -n py38 python==3.8; ```. Looking at the error it seems there is specification that prohibits python 3.9. @jakelishman @Ericgig any idea about this?. # Steps to reproduce (with conda 4.8.5). ```; conda create -n qutip-test python=3.9; conda activate qutip-test; conda install -c conda-forge qutip; ```. ### Error; ```; Collecting package metadata (current_repodata.json): done; Solving environment: failed with initial frozen solve. Retrying with flexible solve.; Solving environment: failed with repodata from current_repodata.json, will retry with next repodata source.; Collecting package metadata (repodata.json): done; Solving environment: failed with initial frozen solve. Retrying with flexible solve.; Solving environment: \; Found conflicts! Looking for incompatible packages.; This can take several minutes. Press CTRL-C to abort.; failed. UnsatisfiableError: The following specifications were found; to be incompatible with the existing python installation in your environment:. Specifications:. - qutip -> python[version='2.7.*|3.5.*|3.6.*|>=2.7,<2.8.0a0|>=3.6,<3.7.0a0|>=3.7,<3.8.0a0|>=3.8,<3.9.0a0|>=3.5,<3.6.0a0|3.4.*']. Your python: python=3.9. If python is on the left-most side of the chain, that's the version you've asked for.; When python appears to the right, that indicates that the thing on the left is somehow; not available for the python version you are constrained to. Note that conda will not; change your python version to a different minor version unless you explicitly specify; that. Note that strict channel priority may have removed packages",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1371
https://github.com/qutip/qutip/issues/1371:733,Availability,Error,Error,733,"@tehruhn and I found that trying to install qutip from pip with the latest python 3.9 fails. When we run the installations from a fresh conda env (conda 4.8.5) using pip as. ```; pip install qutip; ```; or with conda (using both). ```; conda install -c conda-forge qutip; conda install qutip; ```. we get different errors. The errors do not occur if we use python3.8 while creating the conda environment as. ```; conda create -n py38 python==3.8; ```. Looking at the error it seems there is specification that prohibits python 3.9. @jakelishman @Ericgig any idea about this?. # Steps to reproduce (with conda 4.8.5). ```; conda create -n qutip-test python=3.9; conda activate qutip-test; conda install -c conda-forge qutip; ```. ### Error; ```; Collecting package metadata (current_repodata.json): done; Solving environment: failed with initial frozen solve. Retrying with flexible solve.; Solving environment: failed with repodata from current_repodata.json, will retry with next repodata source.; Collecting package metadata (repodata.json): done; Solving environment: failed with initial frozen solve. Retrying with flexible solve.; Solving environment: \; Found conflicts! Looking for incompatible packages.; This can take several minutes. Press CTRL-C to abort.; failed. UnsatisfiableError: The following specifications were found; to be incompatible with the existing python installation in your environment:. Specifications:. - qutip -> python[version='2.7.*|3.5.*|3.6.*|>=2.7,<2.8.0a0|>=3.6,<3.7.0a0|>=3.7,<3.8.0a0|>=3.8,<3.9.0a0|>=3.5,<3.6.0a0|3.4.*']. Your python: python=3.9. If python is on the left-most side of the chain, that's the version you've asked for.; When python appears to the right, that indicates that the thing on the left is somehow; not available for the python version you are constrained to. Note that conda will not; change your python version to a different minor version unless you explicitly specify; that. Note that strict channel priority may have removed packages",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1371
https://github.com/qutip/qutip/issues/1371:1766,Availability,avail,available,1766," install qutip from pip with the latest python 3.9 fails. When we run the installations from a fresh conda env (conda 4.8.5) using pip as. ```; pip install qutip; ```; or with conda (using both). ```; conda install -c conda-forge qutip; conda install qutip; ```. we get different errors. The errors do not occur if we use python3.8 while creating the conda environment as. ```; conda create -n py38 python==3.8; ```. Looking at the error it seems there is specification that prohibits python 3.9. @jakelishman @Ericgig any idea about this?. # Steps to reproduce (with conda 4.8.5). ```; conda create -n qutip-test python=3.9; conda activate qutip-test; conda install -c conda-forge qutip; ```. ### Error; ```; Collecting package metadata (current_repodata.json): done; Solving environment: failed with initial frozen solve. Retrying with flexible solve.; Solving environment: failed with repodata from current_repodata.json, will retry with next repodata source.; Collecting package metadata (repodata.json): done; Solving environment: failed with initial frozen solve. Retrying with flexible solve.; Solving environment: \; Found conflicts! Looking for incompatible packages.; This can take several minutes. Press CTRL-C to abort.; failed. UnsatisfiableError: The following specifications were found; to be incompatible with the existing python installation in your environment:. Specifications:. - qutip -> python[version='2.7.*|3.5.*|3.6.*|>=2.7,<2.8.0a0|>=3.6,<3.7.0a0|>=3.7,<3.8.0a0|>=3.8,<3.9.0a0|>=3.5,<3.6.0a0|3.4.*']. Your python: python=3.9. If python is on the left-most side of the chain, that's the version you've asked for.; When python appears to the right, that indicates that the thing on the left is somehow; not available for the python version you are constrained to. Note that conda will not; change your python version to a different minor version unless you explicitly specify; that. Note that strict channel priority may have removed packages required for satisfiability.; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1371
https://github.com/qutip/qutip/issues/1371:36,Deployability,install,install,36,"@tehruhn and I found that trying to install qutip from pip with the latest python 3.9 fails. When we run the installations from a fresh conda env (conda 4.8.5) using pip as. ```; pip install qutip; ```; or with conda (using both). ```; conda install -c conda-forge qutip; conda install qutip; ```. we get different errors. The errors do not occur if we use python3.8 while creating the conda environment as. ```; conda create -n py38 python==3.8; ```. Looking at the error it seems there is specification that prohibits python 3.9. @jakelishman @Ericgig any idea about this?. # Steps to reproduce (with conda 4.8.5). ```; conda create -n qutip-test python=3.9; conda activate qutip-test; conda install -c conda-forge qutip; ```. ### Error; ```; Collecting package metadata (current_repodata.json): done; Solving environment: failed with initial frozen solve. Retrying with flexible solve.; Solving environment: failed with repodata from current_repodata.json, will retry with next repodata source.; Collecting package metadata (repodata.json): done; Solving environment: failed with initial frozen solve. Retrying with flexible solve.; Solving environment: \; Found conflicts! Looking for incompatible packages.; This can take several minutes. Press CTRL-C to abort.; failed. UnsatisfiableError: The following specifications were found; to be incompatible with the existing python installation in your environment:. Specifications:. - qutip -> python[version='2.7.*|3.5.*|3.6.*|>=2.7,<2.8.0a0|>=3.6,<3.7.0a0|>=3.7,<3.8.0a0|>=3.8,<3.9.0a0|>=3.5,<3.6.0a0|3.4.*']. Your python: python=3.9. If python is on the left-most side of the chain, that's the version you've asked for.; When python appears to the right, that indicates that the thing on the left is somehow; not available for the python version you are constrained to. Note that conda will not; change your python version to a different minor version unless you explicitly specify; that. Note that strict channel priority may have removed packages",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1371
https://github.com/qutip/qutip/issues/1371:109,Deployability,install,installations,109,"@tehruhn and I found that trying to install qutip from pip with the latest python 3.9 fails. When we run the installations from a fresh conda env (conda 4.8.5) using pip as. ```; pip install qutip; ```; or with conda (using both). ```; conda install -c conda-forge qutip; conda install qutip; ```. we get different errors. The errors do not occur if we use python3.8 while creating the conda environment as. ```; conda create -n py38 python==3.8; ```. Looking at the error it seems there is specification that prohibits python 3.9. @jakelishman @Ericgig any idea about this?. # Steps to reproduce (with conda 4.8.5). ```; conda create -n qutip-test python=3.9; conda activate qutip-test; conda install -c conda-forge qutip; ```. ### Error; ```; Collecting package metadata (current_repodata.json): done; Solving environment: failed with initial frozen solve. Retrying with flexible solve.; Solving environment: failed with repodata from current_repodata.json, will retry with next repodata source.; Collecting package metadata (repodata.json): done; Solving environment: failed with initial frozen solve. Retrying with flexible solve.; Solving environment: \; Found conflicts! Looking for incompatible packages.; This can take several minutes. Press CTRL-C to abort.; failed. UnsatisfiableError: The following specifications were found; to be incompatible with the existing python installation in your environment:. Specifications:. - qutip -> python[version='2.7.*|3.5.*|3.6.*|>=2.7,<2.8.0a0|>=3.6,<3.7.0a0|>=3.7,<3.8.0a0|>=3.8,<3.9.0a0|>=3.5,<3.6.0a0|3.4.*']. Your python: python=3.9. If python is on the left-most side of the chain, that's the version you've asked for.; When python appears to the right, that indicates that the thing on the left is somehow; not available for the python version you are constrained to. Note that conda will not; change your python version to a different minor version unless you explicitly specify; that. Note that strict channel priority may have removed packages",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1371
https://github.com/qutip/qutip/issues/1371:183,Deployability,install,install,183,"@tehruhn and I found that trying to install qutip from pip with the latest python 3.9 fails. When we run the installations from a fresh conda env (conda 4.8.5) using pip as. ```; pip install qutip; ```; or with conda (using both). ```; conda install -c conda-forge qutip; conda install qutip; ```. we get different errors. The errors do not occur if we use python3.8 while creating the conda environment as. ```; conda create -n py38 python==3.8; ```. Looking at the error it seems there is specification that prohibits python 3.9. @jakelishman @Ericgig any idea about this?. # Steps to reproduce (with conda 4.8.5). ```; conda create -n qutip-test python=3.9; conda activate qutip-test; conda install -c conda-forge qutip; ```. ### Error; ```; Collecting package metadata (current_repodata.json): done; Solving environment: failed with initial frozen solve. Retrying with flexible solve.; Solving environment: failed with repodata from current_repodata.json, will retry with next repodata source.; Collecting package metadata (repodata.json): done; Solving environment: failed with initial frozen solve. Retrying with flexible solve.; Solving environment: \; Found conflicts! Looking for incompatible packages.; This can take several minutes. Press CTRL-C to abort.; failed. UnsatisfiableError: The following specifications were found; to be incompatible with the existing python installation in your environment:. Specifications:. - qutip -> python[version='2.7.*|3.5.*|3.6.*|>=2.7,<2.8.0a0|>=3.6,<3.7.0a0|>=3.7,<3.8.0a0|>=3.8,<3.9.0a0|>=3.5,<3.6.0a0|3.4.*']. Your python: python=3.9. If python is on the left-most side of the chain, that's the version you've asked for.; When python appears to the right, that indicates that the thing on the left is somehow; not available for the python version you are constrained to. Note that conda will not; change your python version to a different minor version unless you explicitly specify; that. Note that strict channel priority may have removed packages",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1371
https://github.com/qutip/qutip/issues/1371:242,Deployability,install,install,242,"@tehruhn and I found that trying to install qutip from pip with the latest python 3.9 fails. When we run the installations from a fresh conda env (conda 4.8.5) using pip as. ```; pip install qutip; ```; or with conda (using both). ```; conda install -c conda-forge qutip; conda install qutip; ```. we get different errors. The errors do not occur if we use python3.8 while creating the conda environment as. ```; conda create -n py38 python==3.8; ```. Looking at the error it seems there is specification that prohibits python 3.9. @jakelishman @Ericgig any idea about this?. # Steps to reproduce (with conda 4.8.5). ```; conda create -n qutip-test python=3.9; conda activate qutip-test; conda install -c conda-forge qutip; ```. ### Error; ```; Collecting package metadata (current_repodata.json): done; Solving environment: failed with initial frozen solve. Retrying with flexible solve.; Solving environment: failed with repodata from current_repodata.json, will retry with next repodata source.; Collecting package metadata (repodata.json): done; Solving environment: failed with initial frozen solve. Retrying with flexible solve.; Solving environment: \; Found conflicts! Looking for incompatible packages.; This can take several minutes. Press CTRL-C to abort.; failed. UnsatisfiableError: The following specifications were found; to be incompatible with the existing python installation in your environment:. Specifications:. - qutip -> python[version='2.7.*|3.5.*|3.6.*|>=2.7,<2.8.0a0|>=3.6,<3.7.0a0|>=3.7,<3.8.0a0|>=3.8,<3.9.0a0|>=3.5,<3.6.0a0|3.4.*']. Your python: python=3.9. If python is on the left-most side of the chain, that's the version you've asked for.; When python appears to the right, that indicates that the thing on the left is somehow; not available for the python version you are constrained to. Note that conda will not; change your python version to a different minor version unless you explicitly specify; that. Note that strict channel priority may have removed packages",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1371
https://github.com/qutip/qutip/issues/1371:278,Deployability,install,install,278,"@tehruhn and I found that trying to install qutip from pip with the latest python 3.9 fails. When we run the installations from a fresh conda env (conda 4.8.5) using pip as. ```; pip install qutip; ```; or with conda (using both). ```; conda install -c conda-forge qutip; conda install qutip; ```. we get different errors. The errors do not occur if we use python3.8 while creating the conda environment as. ```; conda create -n py38 python==3.8; ```. Looking at the error it seems there is specification that prohibits python 3.9. @jakelishman @Ericgig any idea about this?. # Steps to reproduce (with conda 4.8.5). ```; conda create -n qutip-test python=3.9; conda activate qutip-test; conda install -c conda-forge qutip; ```. ### Error; ```; Collecting package metadata (current_repodata.json): done; Solving environment: failed with initial frozen solve. Retrying with flexible solve.; Solving environment: failed with repodata from current_repodata.json, will retry with next repodata source.; Collecting package metadata (repodata.json): done; Solving environment: failed with initial frozen solve. Retrying with flexible solve.; Solving environment: \; Found conflicts! Looking for incompatible packages.; This can take several minutes. Press CTRL-C to abort.; failed. UnsatisfiableError: The following specifications were found; to be incompatible with the existing python installation in your environment:. Specifications:. - qutip -> python[version='2.7.*|3.5.*|3.6.*|>=2.7,<2.8.0a0|>=3.6,<3.7.0a0|>=3.7,<3.8.0a0|>=3.8,<3.9.0a0|>=3.5,<3.6.0a0|3.4.*']. Your python: python=3.9. If python is on the left-most side of the chain, that's the version you've asked for.; When python appears to the right, that indicates that the thing on the left is somehow; not available for the python version you are constrained to. Note that conda will not; change your python version to a different minor version unless you explicitly specify; that. Note that strict channel priority may have removed packages",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1371
https://github.com/qutip/qutip/issues/1371:694,Deployability,install,install,694,"@tehruhn and I found that trying to install qutip from pip with the latest python 3.9 fails. When we run the installations from a fresh conda env (conda 4.8.5) using pip as. ```; pip install qutip; ```; or with conda (using both). ```; conda install -c conda-forge qutip; conda install qutip; ```. we get different errors. The errors do not occur if we use python3.8 while creating the conda environment as. ```; conda create -n py38 python==3.8; ```. Looking at the error it seems there is specification that prohibits python 3.9. @jakelishman @Ericgig any idea about this?. # Steps to reproduce (with conda 4.8.5). ```; conda create -n qutip-test python=3.9; conda activate qutip-test; conda install -c conda-forge qutip; ```. ### Error; ```; Collecting package metadata (current_repodata.json): done; Solving environment: failed with initial frozen solve. Retrying with flexible solve.; Solving environment: failed with repodata from current_repodata.json, will retry with next repodata source.; Collecting package metadata (repodata.json): done; Solving environment: failed with initial frozen solve. Retrying with flexible solve.; Solving environment: \; Found conflicts! Looking for incompatible packages.; This can take several minutes. Press CTRL-C to abort.; failed. UnsatisfiableError: The following specifications were found; to be incompatible with the existing python installation in your environment:. Specifications:. - qutip -> python[version='2.7.*|3.5.*|3.6.*|>=2.7,<2.8.0a0|>=3.6,<3.7.0a0|>=3.7,<3.8.0a0|>=3.8,<3.9.0a0|>=3.5,<3.6.0a0|3.4.*']. Your python: python=3.9. If python is on the left-most side of the chain, that's the version you've asked for.; When python appears to the right, that indicates that the thing on the left is somehow; not available for the python version you are constrained to. Note that conda will not; change your python version to a different minor version unless you explicitly specify; that. Note that strict channel priority may have removed packages",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1371
https://github.com/qutip/qutip/issues/1371:1381,Deployability,install,installation,1381," install qutip from pip with the latest python 3.9 fails. When we run the installations from a fresh conda env (conda 4.8.5) using pip as. ```; pip install qutip; ```; or with conda (using both). ```; conda install -c conda-forge qutip; conda install qutip; ```. we get different errors. The errors do not occur if we use python3.8 while creating the conda environment as. ```; conda create -n py38 python==3.8; ```. Looking at the error it seems there is specification that prohibits python 3.9. @jakelishman @Ericgig any idea about this?. # Steps to reproduce (with conda 4.8.5). ```; conda create -n qutip-test python=3.9; conda activate qutip-test; conda install -c conda-forge qutip; ```. ### Error; ```; Collecting package metadata (current_repodata.json): done; Solving environment: failed with initial frozen solve. Retrying with flexible solve.; Solving environment: failed with repodata from current_repodata.json, will retry with next repodata source.; Collecting package metadata (repodata.json): done; Solving environment: failed with initial frozen solve. Retrying with flexible solve.; Solving environment: \; Found conflicts! Looking for incompatible packages.; This can take several minutes. Press CTRL-C to abort.; failed. UnsatisfiableError: The following specifications were found; to be incompatible with the existing python installation in your environment:. Specifications:. - qutip -> python[version='2.7.*|3.5.*|3.6.*|>=2.7,<2.8.0a0|>=3.6,<3.7.0a0|>=3.7,<3.8.0a0|>=3.8,<3.9.0a0|>=3.5,<3.6.0a0|3.4.*']. Your python: python=3.9. If python is on the left-most side of the chain, that's the version you've asked for.; When python appears to the right, that indicates that the thing on the left is somehow; not available for the python version you are constrained to. Note that conda will not; change your python version to a different minor version unless you explicitly specify; that. Note that strict channel priority may have removed packages required for satisfiability.; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1371
https://github.com/qutip/qutip/issues/1371:873,Modifiability,flexible,flexible,873,"@tehruhn and I found that trying to install qutip from pip with the latest python 3.9 fails. When we run the installations from a fresh conda env (conda 4.8.5) using pip as. ```; pip install qutip; ```; or with conda (using both). ```; conda install -c conda-forge qutip; conda install qutip; ```. we get different errors. The errors do not occur if we use python3.8 while creating the conda environment as. ```; conda create -n py38 python==3.8; ```. Looking at the error it seems there is specification that prohibits python 3.9. @jakelishman @Ericgig any idea about this?. # Steps to reproduce (with conda 4.8.5). ```; conda create -n qutip-test python=3.9; conda activate qutip-test; conda install -c conda-forge qutip; ```. ### Error; ```; Collecting package metadata (current_repodata.json): done; Solving environment: failed with initial frozen solve. Retrying with flexible solve.; Solving environment: failed with repodata from current_repodata.json, will retry with next repodata source.; Collecting package metadata (repodata.json): done; Solving environment: failed with initial frozen solve. Retrying with flexible solve.; Solving environment: \; Found conflicts! Looking for incompatible packages.; This can take several minutes. Press CTRL-C to abort.; failed. UnsatisfiableError: The following specifications were found; to be incompatible with the existing python installation in your environment:. Specifications:. - qutip -> python[version='2.7.*|3.5.*|3.6.*|>=2.7,<2.8.0a0|>=3.6,<3.7.0a0|>=3.7,<3.8.0a0|>=3.8,<3.9.0a0|>=3.5,<3.6.0a0|3.4.*']. Your python: python=3.9. If python is on the left-most side of the chain, that's the version you've asked for.; When python appears to the right, that indicates that the thing on the left is somehow; not available for the python version you are constrained to. Note that conda will not; change your python version to a different minor version unless you explicitly specify; that. Note that strict channel priority may have removed packages",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1371
https://github.com/qutip/qutip/issues/1371:1119,Modifiability,flexible,flexible,1119," install qutip from pip with the latest python 3.9 fails. When we run the installations from a fresh conda env (conda 4.8.5) using pip as. ```; pip install qutip; ```; or with conda (using both). ```; conda install -c conda-forge qutip; conda install qutip; ```. we get different errors. The errors do not occur if we use python3.8 while creating the conda environment as. ```; conda create -n py38 python==3.8; ```. Looking at the error it seems there is specification that prohibits python 3.9. @jakelishman @Ericgig any idea about this?. # Steps to reproduce (with conda 4.8.5). ```; conda create -n qutip-test python=3.9; conda activate qutip-test; conda install -c conda-forge qutip; ```. ### Error; ```; Collecting package metadata (current_repodata.json): done; Solving environment: failed with initial frozen solve. Retrying with flexible solve.; Solving environment: failed with repodata from current_repodata.json, will retry with next repodata source.; Collecting package metadata (repodata.json): done; Solving environment: failed with initial frozen solve. Retrying with flexible solve.; Solving environment: \; Found conflicts! Looking for incompatible packages.; This can take several minutes. Press CTRL-C to abort.; failed. UnsatisfiableError: The following specifications were found; to be incompatible with the existing python installation in your environment:. Specifications:. - qutip -> python[version='2.7.*|3.5.*|3.6.*|>=2.7,<2.8.0a0|>=3.6,<3.7.0a0|>=3.7,<3.8.0a0|>=3.8,<3.9.0a0|>=3.5,<3.6.0a0|3.4.*']. Your python: python=3.9. If python is on the left-most side of the chain, that's the version you've asked for.; When python appears to the right, that indicates that the thing on the left is somehow; not available for the python version you are constrained to. Note that conda will not; change your python version to a different minor version unless you explicitly specify; that. Note that strict channel priority may have removed packages required for satisfiability.; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1371
https://github.com/qutip/qutip/issues/1371:1260,Safety,abort,abort,1260," install qutip from pip with the latest python 3.9 fails. When we run the installations from a fresh conda env (conda 4.8.5) using pip as. ```; pip install qutip; ```; or with conda (using both). ```; conda install -c conda-forge qutip; conda install qutip; ```. we get different errors. The errors do not occur if we use python3.8 while creating the conda environment as. ```; conda create -n py38 python==3.8; ```. Looking at the error it seems there is specification that prohibits python 3.9. @jakelishman @Ericgig any idea about this?. # Steps to reproduce (with conda 4.8.5). ```; conda create -n qutip-test python=3.9; conda activate qutip-test; conda install -c conda-forge qutip; ```. ### Error; ```; Collecting package metadata (current_repodata.json): done; Solving environment: failed with initial frozen solve. Retrying with flexible solve.; Solving environment: failed with repodata from current_repodata.json, will retry with next repodata source.; Collecting package metadata (repodata.json): done; Solving environment: failed with initial frozen solve. Retrying with flexible solve.; Solving environment: \; Found conflicts! Looking for incompatible packages.; This can take several minutes. Press CTRL-C to abort.; failed. UnsatisfiableError: The following specifications were found; to be incompatible with the existing python installation in your environment:. Specifications:. - qutip -> python[version='2.7.*|3.5.*|3.6.*|>=2.7,<2.8.0a0|>=3.6,<3.7.0a0|>=3.7,<3.8.0a0|>=3.8,<3.9.0a0|>=3.5,<3.6.0a0|3.4.*']. Your python: python=3.9. If python is on the left-most side of the chain, that's the version you've asked for.; When python appears to the right, that indicates that the thing on the left is somehow; not available for the python version you are constrained to. Note that conda will not; change your python version to a different minor version unless you explicitly specify; that. Note that strict channel priority may have removed packages required for satisfiability.; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1371
https://github.com/qutip/qutip/issues/1371:644,Testability,test,test,644,"@tehruhn and I found that trying to install qutip from pip with the latest python 3.9 fails. When we run the installations from a fresh conda env (conda 4.8.5) using pip as. ```; pip install qutip; ```; or with conda (using both). ```; conda install -c conda-forge qutip; conda install qutip; ```. we get different errors. The errors do not occur if we use python3.8 while creating the conda environment as. ```; conda create -n py38 python==3.8; ```. Looking at the error it seems there is specification that prohibits python 3.9. @jakelishman @Ericgig any idea about this?. # Steps to reproduce (with conda 4.8.5). ```; conda create -n qutip-test python=3.9; conda activate qutip-test; conda install -c conda-forge qutip; ```. ### Error; ```; Collecting package metadata (current_repodata.json): done; Solving environment: failed with initial frozen solve. Retrying with flexible solve.; Solving environment: failed with repodata from current_repodata.json, will retry with next repodata source.; Collecting package metadata (repodata.json): done; Solving environment: failed with initial frozen solve. Retrying with flexible solve.; Solving environment: \; Found conflicts! Looking for incompatible packages.; This can take several minutes. Press CTRL-C to abort.; failed. UnsatisfiableError: The following specifications were found; to be incompatible with the existing python installation in your environment:. Specifications:. - qutip -> python[version='2.7.*|3.5.*|3.6.*|>=2.7,<2.8.0a0|>=3.6,<3.7.0a0|>=3.7,<3.8.0a0|>=3.8,<3.9.0a0|>=3.5,<3.6.0a0|3.4.*']. Your python: python=3.9. If python is on the left-most side of the chain, that's the version you've asked for.; When python appears to the right, that indicates that the thing on the left is somehow; not available for the python version you are constrained to. Note that conda will not; change your python version to a different minor version unless you explicitly specify; that. Note that strict channel priority may have removed packages",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1371
https://github.com/qutip/qutip/issues/1371:682,Testability,test,test,682,"@tehruhn and I found that trying to install qutip from pip with the latest python 3.9 fails. When we run the installations from a fresh conda env (conda 4.8.5) using pip as. ```; pip install qutip; ```; or with conda (using both). ```; conda install -c conda-forge qutip; conda install qutip; ```. we get different errors. The errors do not occur if we use python3.8 while creating the conda environment as. ```; conda create -n py38 python==3.8; ```. Looking at the error it seems there is specification that prohibits python 3.9. @jakelishman @Ericgig any idea about this?. # Steps to reproduce (with conda 4.8.5). ```; conda create -n qutip-test python=3.9; conda activate qutip-test; conda install -c conda-forge qutip; ```. ### Error; ```; Collecting package metadata (current_repodata.json): done; Solving environment: failed with initial frozen solve. Retrying with flexible solve.; Solving environment: failed with repodata from current_repodata.json, will retry with next repodata source.; Collecting package metadata (repodata.json): done; Solving environment: failed with initial frozen solve. Retrying with flexible solve.; Solving environment: \; Found conflicts! Looking for incompatible packages.; This can take several minutes. Press CTRL-C to abort.; failed. UnsatisfiableError: The following specifications were found; to be incompatible with the existing python installation in your environment:. Specifications:. - qutip -> python[version='2.7.*|3.5.*|3.6.*|>=2.7,<2.8.0a0|>=3.6,<3.7.0a0|>=3.7,<3.8.0a0|>=3.8,<3.9.0a0|>=3.5,<3.6.0a0|3.4.*']. Your python: python=3.9. If python is on the left-most side of the chain, that's the version you've asked for.; When python appears to the right, that indicates that the thing on the left is somehow; not available for the python version you are constrained to. Note that conda will not; change your python version to a different minor version unless you explicitly specify; that. Note that strict channel priority may have removed packages",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1371
https://github.com/qutip/qutip/issues/1372:730,Testability,assert,assert,730,"- output; ```python; U1 != U2; myFid: 0.158 qutipFid: 2.746; myFid: 0.167 qutipFid: 3.371; myFid: 0.117 qutipFid: 2.769; myFid: 0.164 qutipFid: 3.479; myFid: 0.255 qutipFid: 2.700; myFid: 0.255 qutipFid: 2.662; myFid: 0.293 qutipFid: 2.768; myFid: 0.166 qutipFid: 2.658; myFid: 0.195 qutipFid: 3.453; myFid: 0.292 qutipFid: 2.807. U1 == U2; myFid: 1.000 qutipFid: 2.650; myFid: 1.000 qutipFid: 2.857; myFid: 1.000 qutipFid: 1.855; myFid: 1.000 qutipFid: 2.506; myFid: 1.000 qutipFid: 1.926; myFid: 1.000 qutipFid: 1.556; myFid: 1.000 qutipFid: 1.916; myFid: 1.000 qutipFid: 1.989; myFid: 1.000 qutipFid: 2.971; myFid: 1.000 qutipFid: 1.835; ```; - to reproduce; ```python; import numpy as np; from qutip import *. def fid(A, B):; assert A.shape == B.shape; fids = []; A = A.T; B = B.T; for i in range(A.shape[0]):; v1 = A[i]; v2 = B[i]; fidi = ( np.abs( np.dot( np.conj(v1), v2 ) ) )**2; fids.append(fidi); return np.mean(np.array(fids)). def test2():; def compare(U1, U2):; myFid = fid(U1.full(), U2.full()); qutipFid = fidelity(U1, U2); print('myFid: %.3f qutipFid: %.3f' % (myFid, qutipFid)); print(""U1 != U2""); for i in range(10):; U1 = rand_unitary(5); U2 = rand_unitary(5); compare(U1, U2); print(""\nU1 == U2""); for i in range(10):; U1 = rand_unitary(5); compare(U1, U1). test2(); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1372
https://github.com/qutip/qutip/issues/1373:2317,Availability,ping,ping,2317," we'd like to keep doing what we're doing, with the support, since 2018, of @NumFOCUS, which supports scientific open source projects, and, from now on, the additional support of @unitaryfund, a non-profit that supports open-source projects in quantum technologies. . Below we reproduce a governance document that we will add to a new repository at [github.com/qutip/governance](https://github.com/qutip/governance). We are looking forward to help the growth of the user community, engage it with code contributions and bug reports, and make this awesome scientific open-source project even more sustainable. We will update all related information at [github.com/qutip/governance](https://github.com/qutip/governance), on QuTiP website's news section (http://qutip.org/news.html) and on the QuTiP google group (https://groups.google.com/forum/#!forum/qutip). . Below it is reported how we got there and the text we're adding to the governance. Before making any more official announcements, we thought it nice to ping the community watching this repository. . **Timeline regarding governance talks**:; * April 2018: QuTiP Joins NumFOCUS as an Affiliated Project (and since then participates in Google Summer of Code).; * September 2018: a slide presentation is shared among lead developers with ideas on QuTiP development and governance. ([Link](https://docs.google.com/presentation/d/1lBfS7v4WxduvWy-rf1Vd-hSEeNOK4at91ALuaH58AnQ/edit?usp=sharing)); * February 2019: The first QuTiP developers workshop is held in RIKEN, Wako, Japan, to discuss development and roadmap ([Link](https://docs.google.com/presentation/d/1lBfS7v4WxduvWy-rf1Vd-hSEeNOK4at91ALuaH58AnQ/edit?usp=sharing)); * 2019-2020: Seminars given in USA, Asia, and Europe about QuTiP and how the users community can get more engaged, collecting feedback on the package and project. ; * April-May 2020: Discussions for governance creation are revamped; * May-August 2020: First draft document created and circulated among core developers a",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1373
https://github.com/qutip/qutip/issues/1373:4974,Availability,down,downloaded,4974,"te-of-the-art research in open quantum systems using QuTiP. It provides the most comprehensive toolbox to characterize noise and dissipation affecting quantum systems as well as quantum information processing features. QuTiP has been developed and maintained by a group of open-source contributors for several years and has been used for research, teaching and in the emerging quantum technology industry. The QuTiP community has grown immensely with several projects that build on top of it. In this document we refer to the “QuTiP project” or “ the project” with reference to all software developed under the QuTiP Github organization, hosted at “[www.github.com/qutip](www.github.com/qutip)” and all related activities involving its community happening through its official channels. **<span style=""text-decoration:underline;"">The Community</span>**. QuTiP is at the center of a lively ecosystem and creative community. As of October 2020, QuTiP’s large community comprises over 80 code contributors and thousands of users that have downloaded the software over 300’000 times. QuTiP enables an infrastructure of other scientific libraries for the investigation of specific quantum physics or quantum information processing features. . There are several ways through which members of the wider QuTiP community can receive information on QuTiP. This is through any of its official channels: the Google forum; the qutip.org/news webpage tracking the releases on Github, and opening [Issues](https://github.com/qutip/qutip/issues) on Github to file bug reports or discuss and proposed enhancements. Users are encouraged to contribute bug fixes or enhancements to the project with [Pull Requests](https://github.com/qutip/qutip/pulls). **<span style=""text-decoration:underline;"">Governance</span>**. This governance document outlines the governance of the QuTiP project, in order to better serve the community and provide robust liveliness and sustained maintenance for the project. Changes to this docu",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1373
https://github.com/qutip/qutip/issues/1373:5858,Availability,robust,robust,5858," ecosystem and creative community. As of October 2020, QuTiP’s large community comprises over 80 code contributors and thousands of users that have downloaded the software over 300’000 times. QuTiP enables an infrastructure of other scientific libraries for the investigation of specific quantum physics or quantum information processing features. . There are several ways through which members of the wider QuTiP community can receive information on QuTiP. This is through any of its official channels: the Google forum; the qutip.org/news webpage tracking the releases on Github, and opening [Issues](https://github.com/qutip/qutip/issues) on Github to file bug reports or discuss and proposed enhancements. Users are encouraged to contribute bug fixes or enhancements to the project with [Pull Requests](https://github.com/qutip/qutip/pulls). **<span style=""text-decoration:underline;"">Governance</span>**. This governance document outlines the governance of the QuTiP project, in order to better serve the community and provide robust liveliness and sustained maintenance for the project. Changes to this document need to be approved by ¾ of the Admin Team. The contents of this QuTiP Governance are shown on QuTiP’s website (qutip.org/goverance) and in its documentation. The changes are tracked at github.com/qutip/governance. We view this governance model as the formalization of what we are already doing, rather than a change in direction. This document is composed of information regarding the following:. **1. Code of Conduct**. **2. Admin Team: Tasks, Composition, Decisions, Communications.**. **3. Board: Tasks, Composition, Decisions, Communications.**. **4. Non-profit Support.**. ### 1. Code of Conduct. The Contributor Covenant [Code of Conduct](https://github.com/qutip/qutip/blob/master/CODE_OF_CONDUCT.md) applies to all of QuTiP activities. QuTiP project members and contributors agree to abide by it and to build an inclusive community where criticism is provided and taken cons",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1373
https://github.com/qutip/qutip/issues/1373:5890,Availability,mainten,maintenance,5890," ecosystem and creative community. As of October 2020, QuTiP’s large community comprises over 80 code contributors and thousands of users that have downloaded the software over 300’000 times. QuTiP enables an infrastructure of other scientific libraries for the investigation of specific quantum physics or quantum information processing features. . There are several ways through which members of the wider QuTiP community can receive information on QuTiP. This is through any of its official channels: the Google forum; the qutip.org/news webpage tracking the releases on Github, and opening [Issues](https://github.com/qutip/qutip/issues) on Github to file bug reports or discuss and proposed enhancements. Users are encouraged to contribute bug fixes or enhancements to the project with [Pull Requests](https://github.com/qutip/qutip/pulls). **<span style=""text-decoration:underline;"">Governance</span>**. This governance document outlines the governance of the QuTiP project, in order to better serve the community and provide robust liveliness and sustained maintenance for the project. Changes to this document need to be approved by ¾ of the Admin Team. The contents of this QuTiP Governance are shown on QuTiP’s website (qutip.org/goverance) and in its documentation. The changes are tracked at github.com/qutip/governance. We view this governance model as the formalization of what we are already doing, rather than a change in direction. This document is composed of information regarding the following:. **1. Code of Conduct**. **2. Admin Team: Tasks, Composition, Decisions, Communications.**. **3. Board: Tasks, Composition, Decisions, Communications.**. **4. Non-profit Support.**. ### 1. Code of Conduct. The Contributor Covenant [Code of Conduct](https://github.com/qutip/qutip/blob/master/CODE_OF_CONDUCT.md) applies to all of QuTiP activities. QuTiP project members and contributors agree to abide by it and to build an inclusive community where criticism is provided and taken cons",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1373
https://github.com/qutip/qutip/issues/1373:10264,Availability,mainten,maintenance,10264,"minated by the admin team among core developers and major contributors, and are voted by the admin team with a majority vote. Prospective Admin Team members can send self-candidatures with their proposed candidature, and two brief statements: one explaining their past involvement with the QuTiP project, and one with their commitment to the QuTiP for the future, e.g., how they would help and support the project in their activity. Emeriti Admin Team members, including previous core contributors, are listed on the QuTiP website (at qutip.org/devs), governance (github.com/qutip/governance) and documentation. **<span style=""text-decoration:underline;"">Decisions</span>**; Each admin team member has a vote in decisions. As much as possible, admins try to take in feedback on changes from the wider community and timely communicate major changes in the software. . **<span style=""text-decoration:underline;"">Communications</span>**; The admin team agrees to keep in touch regularly, through the qutip-admin channel or chosed communication medium, through the repositories’ maintenance, and with regular virtual or in-person meetings. The admin team drafts a report, [once] a year and submits it to the Board to inform it of developments on the project. ### 3. Board; **Members of the Board make sure that the Admin Team and project is well supported financially and logistically.** Thanks to them helping enable the financial and logistics support, through scientific advisory and by keeping an eye on the project, they make the life of the admin team easier. . **<span style=""text-decoration:underline;"">Tasks</span>**; Board members are volunteers that pledge to:. - Meet** [once] **a year to review the development of the project (also online).; - Be consulted for scientific advice by the admins. ; - Help settle conflicts or roadblocks that may arise on the project development. ; - Help review student applications of interns that may volunteer or work on the QuTiP project.; - Try to provide ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1373
https://github.com/qutip/qutip/issues/1373:11224,Availability,mainten,maintenance,11224,"el or chosed communication medium, through the repositories’ maintenance, and with regular virtual or in-person meetings. The admin team drafts a report, [once] a year and submits it to the Board to inform it of developments on the project. ### 3. Board; **Members of the Board make sure that the Admin Team and project is well supported financially and logistically.** Thanks to them helping enable the financial and logistics support, through scientific advisory and by keeping an eye on the project, they make the life of the admin team easier. . **<span style=""text-decoration:underline;"">Tasks</span>**; Board members are volunteers that pledge to:. - Meet** [once] **a year to review the development of the project (also online).; - Be consulted for scientific advice by the admins. ; - Help settle conflicts or roadblocks that may arise on the project development. ; - Help review student applications of interns that may volunteer or work on the QuTiP project.; - Try to provide funding for QuTiP development and maintenance.; - Become ambassadors for scientific open source in general and QuTiP in particular.; - Take formal decisions to allocate eventual funds, upon recommendation of the Admin Team. . **<span style=""text-decoration:underline;"">Composition</span>**; Initial board members are invited by the admin team, based on their track-record in supporting the project and future helping it grow. The admins elect new board members, in agreement with existing board members or upon the suggestion of the current board. Additional prospective board members should send an email with their proposed candidature and two brief statements: one explaining their past involvement with the QuTiP project and one with their commitment to the QuTiP for the future, e.g., how they would help and support the project in their activity. The minimum number of board members is **[three]** and maximum is **[seven]**. Board seats are held **[indefinitely]**. The board can decide, by majority vote, t",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1373
https://github.com/qutip/qutip/issues/1373:13756,Availability,avail,availability,13756,"are not engaged with the project, do not reply to communications or attend board meetings. . **<span style=""text-decoration:underline;"">Decisions</span>**; Each board member has a vote in decisions, which are taken by a majority vote. . **<span style=""text-decoration:underline;"">Communications</span>**; The board agrees to meet **[once a year]** (also via online meeting). The board is informed at least **[once a year]** by the Admin Team on QuTiP development and other activities (via email in the qutip-board channel). . ### 4. Non-profit Support; Since 2018, QuTiP is an affiliated project of [NumFOCUS](https://numfocus.org/), a 501(c)(3) nonprofit organization registered in the USA. The mission of NumFOCUS is to promote open practices in research, data, and scientific computing **[Unitary Fund](http://unitary.fund/)** pledges to support the QuTiP project as a fiscally sponsored project. QuTiP remains an affiliated project of NumFOCUS. [Unitary Fund](http://unitary.fund/) is a 501(c)(3) nonprofit organization registered in the USA working to create a quantum technology ecosystem that benefits the most people. Due to its role in the quantum software community, Unitary Fund pledges to: . * Promote the knowledge of QuTiP in the quantum software and sci-dev community.; * Provide scientific and technical software advice upon request of the Admin team and Board. ; * Provide logistic and financial support for code projects and meetings (subject to request by the QuTiP admins and availability of Unitary Fund funds). ; * Accept financial support on behalf of the QuTiP project. These funds will be allocated to and managed by the QuTiP admins on board’s approval in coordination with Unitary Fund. ; * Provide access to expert legal advice (subject to request by the QuTiP board or admin team and availability of Unitary Fund funds) through its legal counsel, useful for matters related to licensing, copyright, collaborations with industry and to protect the QuTiP brand and project.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1373
https://github.com/qutip/qutip/issues/1373:14073,Availability,avail,availability,14073,"are not engaged with the project, do not reply to communications or attend board meetings. . **<span style=""text-decoration:underline;"">Decisions</span>**; Each board member has a vote in decisions, which are taken by a majority vote. . **<span style=""text-decoration:underline;"">Communications</span>**; The board agrees to meet **[once a year]** (also via online meeting). The board is informed at least **[once a year]** by the Admin Team on QuTiP development and other activities (via email in the qutip-board channel). . ### 4. Non-profit Support; Since 2018, QuTiP is an affiliated project of [NumFOCUS](https://numfocus.org/), a 501(c)(3) nonprofit organization registered in the USA. The mission of NumFOCUS is to promote open practices in research, data, and scientific computing **[Unitary Fund](http://unitary.fund/)** pledges to support the QuTiP project as a fiscally sponsored project. QuTiP remains an affiliated project of NumFOCUS. [Unitary Fund](http://unitary.fund/) is a 501(c)(3) nonprofit organization registered in the USA working to create a quantum technology ecosystem that benefits the most people. Due to its role in the quantum software community, Unitary Fund pledges to: . * Promote the knowledge of QuTiP in the quantum software and sci-dev community.; * Provide scientific and technical software advice upon request of the Admin team and Board. ; * Provide logistic and financial support for code projects and meetings (subject to request by the QuTiP admins and availability of Unitary Fund funds). ; * Accept financial support on behalf of the QuTiP project. These funds will be allocated to and managed by the QuTiP admins on board’s approval in coordination with Unitary Fund. ; * Provide access to expert legal advice (subject to request by the QuTiP board or admin team and availability of Unitary Fund funds) through its legal counsel, useful for matters related to licensing, copyright, collaborations with industry and to protect the QuTiP brand and project.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1373
https://github.com/qutip/qutip/issues/1373:1921,Deployability,update,update,1921,"oid feature creeps. Not to mention all the help provided in Qutip's google group, a forum for bugs, physics questions and research ideas. Over the years, the QuTiP project has enabled a large ecosystem of supported libraries, such as `Krotov` (cc @goerz and others), `pyEPR` (cc @zlatko-minev), `scqubits` (cc @jkochNU), and many others. . With this governance model, we'd like to keep doing what we're doing, with the support, since 2018, of @NumFOCUS, which supports scientific open source projects, and, from now on, the additional support of @unitaryfund, a non-profit that supports open-source projects in quantum technologies. . Below we reproduce a governance document that we will add to a new repository at [github.com/qutip/governance](https://github.com/qutip/governance). We are looking forward to help the growth of the user community, engage it with code contributions and bug reports, and make this awesome scientific open-source project even more sustainable. We will update all related information at [github.com/qutip/governance](https://github.com/qutip/governance), on QuTiP website's news section (http://qutip.org/news.html) and on the QuTiP google group (https://groups.google.com/forum/#!forum/qutip). . Below it is reported how we got there and the text we're adding to the governance. Before making any more official announcements, we thought it nice to ping the community watching this repository. . **Timeline regarding governance talks**:; * April 2018: QuTiP Joins NumFOCUS as an Affiliated Project (and since then participates in Google Summer of Code).; * September 2018: a slide presentation is shared among lead developers with ideas on QuTiP development and governance. ([Link](https://docs.google.com/presentation/d/1lBfS7v4WxduvWy-rf1Vd-hSEeNOK4at91ALuaH58AnQ/edit?usp=sharing)); * February 2019: The first QuTiP developers workshop is held in RIKEN, Wako, Japan, to discuss development and roadmap ([Link](https://docs.google.com/presentation/d/1lBfS7v4WxduvWy-rf",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1373
https://github.com/qutip/qutip/issues/1373:3377,Deployability,update,update,3377,"imeline regarding governance talks**:; * April 2018: QuTiP Joins NumFOCUS as an Affiliated Project (and since then participates in Google Summer of Code).; * September 2018: a slide presentation is shared among lead developers with ideas on QuTiP development and governance. ([Link](https://docs.google.com/presentation/d/1lBfS7v4WxduvWy-rf1Vd-hSEeNOK4at91ALuaH58AnQ/edit?usp=sharing)); * February 2019: The first QuTiP developers workshop is held in RIKEN, Wako, Japan, to discuss development and roadmap ([Link](https://docs.google.com/presentation/d/1lBfS7v4WxduvWy-rf1Vd-hSEeNOK4at91ALuaH58AnQ/edit?usp=sharing)); * 2019-2020: Seminars given in USA, Asia, and Europe about QuTiP and how the users community can get more engaged, collecting feedback on the package and project. ; * April-May 2020: Discussions for governance creation are revamped; * May-August 2020: First draft document created and circulated among core developers and project creators.; * Fall 2020: Feedback from NumFOCUS, Unitary Fund, update on the governance document. # QuTiP Governance Document. **<span style=""text-decoration:underline;"">The Project</span>**. QuTiP, the Quantum Toolbox in Python, is an open-source software to study and simulate quantum systems. It provides functionalities to define and simulate the dynamics of quantum systems and thus provides tools to develop an intuitive understanding of quantum mechanics. Apart from the educational aspect where QuTiP can be used to visualize and simulate simple quantum systems, there exists advanced functionalities that enable state-of-the-art research in open quantum systems using QuTiP. It provides the most comprehensive toolbox to characterize noise and dissipation affecting quantum systems as well as quantum information processing features. QuTiP has been developed and maintained by a group of open-source contributors for several years and has been used for research, teaching and in the emerging quantum technology industry. The QuTiP community has ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1373
https://github.com/qutip/qutip/issues/1373:5388,Deployability,release,releases,5388,"ects that build on top of it. In this document we refer to the “QuTiP project” or “ the project” with reference to all software developed under the QuTiP Github organization, hosted at “[www.github.com/qutip](www.github.com/qutip)” and all related activities involving its community happening through its official channels. **<span style=""text-decoration:underline;"">The Community</span>**. QuTiP is at the center of a lively ecosystem and creative community. As of October 2020, QuTiP’s large community comprises over 80 code contributors and thousands of users that have downloaded the software over 300’000 times. QuTiP enables an infrastructure of other scientific libraries for the investigation of specific quantum physics or quantum information processing features. . There are several ways through which members of the wider QuTiP community can receive information on QuTiP. This is through any of its official channels: the Google forum; the qutip.org/news webpage tracking the releases on Github, and opening [Issues](https://github.com/qutip/qutip/issues) on Github to file bug reports or discuss and proposed enhancements. Users are encouraged to contribute bug fixes or enhancements to the project with [Pull Requests](https://github.com/qutip/qutip/pulls). **<span style=""text-decoration:underline;"">Governance</span>**. This governance document outlines the governance of the QuTiP project, in order to better serve the community and provide robust liveliness and sustained maintenance for the project. Changes to this document need to be approved by ¾ of the Admin Team. The contents of this QuTiP Governance are shown on QuTiP’s website (qutip.org/goverance) and in its documentation. The changes are tracked at github.com/qutip/governance. We view this governance model as the formalization of what we are already doing, rather than a change in direction. This document is composed of information regarding the following:. **1. Code of Conduct**. **2. Admin Team: Tasks, Composition",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1373
https://github.com/qutip/qutip/issues/1373:7633,Deployability,release,release,7633,"QuTiP activities. QuTiP project members and contributors agree to abide by it and to build an inclusive community where criticism is provided and taken constructively and with empathy. Admin team members are responsible to enforce the Code of Conduct. Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at qutip-admin@googlegroups.com _[activate this or alternate email]_. . ### 2. Admin Team; **The Admin Team leads technical code development and manages directly QuTiP-related activities.** It’s thanks to their work and the broader community that the QuTiP project keeps lively, the software is maintained and the features keep expanding and improving. . **<span style=""text-decoration:underline;"">Tasks</span>**. The admin team is listed on the qutip website and specific areas of competence are shown. Members of the admin team pledge to volunteer to:. - Maintain the project through software release updates and bug fixes (core code development, documentation, notebooks, website, other Github-related things). . **- Make decisions about specific technical issues, features, bugs and pull requests. They are the primary mechanism of guiding the code review process and merging pull requests. This includes closing pull requests or issues that are inactive for long or deemed not relevant. **. - Develop new features in qutip/qutip and qutip/other-libraries. ; - Help keep a steady pace of qutip library releases (e.g., ~2 minor releases/year). ; - Actively participate / respond to the qutip-dev internal forum.; - Help in the Q&A support group, qutip public forum. ; - Volunteer time for remote mentorship.; - Discuss code developments.; - Once a year, on a rotation basis, one admin team member is responsible for drafting a report for the QuTiP board.; - **For each subproject that is not qutip/qutip, at least one admin should actively be watching the repository.**. - If there are new projects that wish to come under the umbr",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1373
https://github.com/qutip/qutip/issues/1373:7641,Deployability,update,updates,7641,"QuTiP activities. QuTiP project members and contributors agree to abide by it and to build an inclusive community where criticism is provided and taken constructively and with empathy. Admin team members are responsible to enforce the Code of Conduct. Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at qutip-admin@googlegroups.com _[activate this or alternate email]_. . ### 2. Admin Team; **The Admin Team leads technical code development and manages directly QuTiP-related activities.** It’s thanks to their work and the broader community that the QuTiP project keeps lively, the software is maintained and the features keep expanding and improving. . **<span style=""text-decoration:underline;"">Tasks</span>**. The admin team is listed on the qutip website and specific areas of competence are shown. Members of the admin team pledge to volunteer to:. - Maintain the project through software release updates and bug fixes (core code development, documentation, notebooks, website, other Github-related things). . **- Make decisions about specific technical issues, features, bugs and pull requests. They are the primary mechanism of guiding the code review process and merging pull requests. This includes closing pull requests or issues that are inactive for long or deemed not relevant. **. - Develop new features in qutip/qutip and qutip/other-libraries. ; - Help keep a steady pace of qutip library releases (e.g., ~2 minor releases/year). ; - Actively participate / respond to the qutip-dev internal forum.; - Help in the Q&A support group, qutip public forum. ; - Volunteer time for remote mentorship.; - Discuss code developments.; - Once a year, on a rotation basis, one admin team member is responsible for drafting a report for the QuTiP board.; - **For each subproject that is not qutip/qutip, at least one admin should actively be watching the repository.**. - If there are new projects that wish to come under the umbr",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1373
https://github.com/qutip/qutip/issues/1373:8144,Deployability,release,releases,8144,"; **The Admin Team leads technical code development and manages directly QuTiP-related activities.** It’s thanks to their work and the broader community that the QuTiP project keeps lively, the software is maintained and the features keep expanding and improving. . **<span style=""text-decoration:underline;"">Tasks</span>**. The admin team is listed on the qutip website and specific areas of competence are shown. Members of the admin team pledge to volunteer to:. - Maintain the project through software release updates and bug fixes (core code development, documentation, notebooks, website, other Github-related things). . **- Make decisions about specific technical issues, features, bugs and pull requests. They are the primary mechanism of guiding the code review process and merging pull requests. This includes closing pull requests or issues that are inactive for long or deemed not relevant. **. - Develop new features in qutip/qutip and qutip/other-libraries. ; - Help keep a steady pace of qutip library releases (e.g., ~2 minor releases/year). ; - Actively participate / respond to the qutip-dev internal forum.; - Help in the Q&A support group, qutip public forum. ; - Volunteer time for remote mentorship.; - Discuss code developments.; - Once a year, on a rotation basis, one admin team member is responsible for drafting a report for the QuTiP board.; - **For each subproject that is not qutip/qutip, at least one admin should actively be watching the repository.**. - If there are new projects that wish to come under the umbrella of qutip/, either one of the existing admins should get involved with the project, or the maintainer/developer of the new project joins the admin team upon a consensus reached by the existing admins. **<span style=""text-decoration:underline;"">Composition</span>**; Admin Team members are Team members with [Owner rights](https://github.com/orgs/qutip/people?query=role%3Aowner#) in QuTiP’s main Github Repository (qutip/qutip) that have been active i",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1373
https://github.com/qutip/qutip/issues/1373:8169,Deployability,release,releases,8169,"lopment and manages directly QuTiP-related activities.** It’s thanks to their work and the broader community that the QuTiP project keeps lively, the software is maintained and the features keep expanding and improving. . **<span style=""text-decoration:underline;"">Tasks</span>**. The admin team is listed on the qutip website and specific areas of competence are shown. Members of the admin team pledge to volunteer to:. - Maintain the project through software release updates and bug fixes (core code development, documentation, notebooks, website, other Github-related things). . **- Make decisions about specific technical issues, features, bugs and pull requests. They are the primary mechanism of guiding the code review process and merging pull requests. This includes closing pull requests or issues that are inactive for long or deemed not relevant. **. - Develop new features in qutip/qutip and qutip/other-libraries. ; - Help keep a steady pace of qutip library releases (e.g., ~2 minor releases/year). ; - Actively participate / respond to the qutip-dev internal forum.; - Help in the Q&A support group, qutip public forum. ; - Volunteer time for remote mentorship.; - Discuss code developments.; - Once a year, on a rotation basis, one admin team member is responsible for drafting a report for the QuTiP board.; - **For each subproject that is not qutip/qutip, at least one admin should actively be watching the repository.**. - If there are new projects that wish to come under the umbrella of qutip/, either one of the existing admins should get involved with the project, or the maintainer/developer of the new project joins the admin team upon a consensus reached by the existing admins. **<span style=""text-decoration:underline;"">Composition</span>**; Admin Team members are Team members with [Owner rights](https://github.com/orgs/qutip/people?query=role%3Aowner#) in QuTiP’s main Github Repository (qutip/qutip) that have been active in the past one year. . Additional Admin Team",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1373
https://github.com/qutip/qutip/issues/1373:1900,Energy Efficiency,sustainab,sustainable,1900,"m/qutip/qutip.github.io) as well as the other packages that are now being spin out in the QuTiP Github organization to avoid feature creeps. Not to mention all the help provided in Qutip's google group, a forum for bugs, physics questions and research ideas. Over the years, the QuTiP project has enabled a large ecosystem of supported libraries, such as `Krotov` (cc @goerz and others), `pyEPR` (cc @zlatko-minev), `scqubits` (cc @jkochNU), and many others. . With this governance model, we'd like to keep doing what we're doing, with the support, since 2018, of @NumFOCUS, which supports scientific open source projects, and, from now on, the additional support of @unitaryfund, a non-profit that supports open-source projects in quantum technologies. . Below we reproduce a governance document that we will add to a new repository at [github.com/qutip/governance](https://github.com/qutip/governance). We are looking forward to help the growth of the user community, engage it with code contributions and bug reports, and make this awesome scientific open-source project even more sustainable. We will update all related information at [github.com/qutip/governance](https://github.com/qutip/governance), on QuTiP website's news section (http://qutip.org/news.html) and on the QuTiP google group (https://groups.google.com/forum/#!forum/qutip). . Below it is reported how we got there and the text we're adding to the governance. Before making any more official announcements, we thought it nice to ping the community watching this repository. . **Timeline regarding governance talks**:; * April 2018: QuTiP Joins NumFOCUS as an Affiliated Project (and since then participates in Google Summer of Code).; * September 2018: a slide presentation is shared among lead developers with ideas on QuTiP development and governance. ([Link](https://docs.google.com/presentation/d/1lBfS7v4WxduvWy-rf1Vd-hSEeNOK4at91ALuaH58AnQ/edit?usp=sharing)); * February 2019: The first QuTiP developers workshop is held i",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1373
https://github.com/qutip/qutip/issues/1373:11350,Energy Efficiency,allocate,allocate,11350,"ear and submits it to the Board to inform it of developments on the project. ### 3. Board; **Members of the Board make sure that the Admin Team and project is well supported financially and logistically.** Thanks to them helping enable the financial and logistics support, through scientific advisory and by keeping an eye on the project, they make the life of the admin team easier. . **<span style=""text-decoration:underline;"">Tasks</span>**; Board members are volunteers that pledge to:. - Meet** [once] **a year to review the development of the project (also online).; - Be consulted for scientific advice by the admins. ; - Help settle conflicts or roadblocks that may arise on the project development. ; - Help review student applications of interns that may volunteer or work on the QuTiP project.; - Try to provide funding for QuTiP development and maintenance.; - Become ambassadors for scientific open source in general and QuTiP in particular.; - Take formal decisions to allocate eventual funds, upon recommendation of the Admin Team. . **<span style=""text-decoration:underline;"">Composition</span>**; Initial board members are invited by the admin team, based on their track-record in supporting the project and future helping it grow. The admins elect new board members, in agreement with existing board members or upon the suggestion of the current board. Additional prospective board members should send an email with their proposed candidature and two brief statements: one explaining their past involvement with the QuTiP project and one with their commitment to the QuTiP for the future, e.g., how they would help and support the project in their activity. The minimum number of board members is **[three]** and maximum is **[seven]**. Board seats are held **[indefinitely]**. The board can decide, by majority vote, to remove a board member for good reasons, e.g., if they are not engaged with the project, do not reply to communications or attend board meetings. . **<span style=",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1373
https://github.com/qutip/qutip/issues/1373:13874,Energy Efficiency,allocate,allocated,13874,"are not engaged with the project, do not reply to communications or attend board meetings. . **<span style=""text-decoration:underline;"">Decisions</span>**; Each board member has a vote in decisions, which are taken by a majority vote. . **<span style=""text-decoration:underline;"">Communications</span>**; The board agrees to meet **[once a year]** (also via online meeting). The board is informed at least **[once a year]** by the Admin Team on QuTiP development and other activities (via email in the qutip-board channel). . ### 4. Non-profit Support; Since 2018, QuTiP is an affiliated project of [NumFOCUS](https://numfocus.org/), a 501(c)(3) nonprofit organization registered in the USA. The mission of NumFOCUS is to promote open practices in research, data, and scientific computing **[Unitary Fund](http://unitary.fund/)** pledges to support the QuTiP project as a fiscally sponsored project. QuTiP remains an affiliated project of NumFOCUS. [Unitary Fund](http://unitary.fund/) is a 501(c)(3) nonprofit organization registered in the USA working to create a quantum technology ecosystem that benefits the most people. Due to its role in the quantum software community, Unitary Fund pledges to: . * Promote the knowledge of QuTiP in the quantum software and sci-dev community.; * Provide scientific and technical software advice upon request of the Admin team and Board. ; * Provide logistic and financial support for code projects and meetings (subject to request by the QuTiP admins and availability of Unitary Fund funds). ; * Accept financial support on behalf of the QuTiP project. These funds will be allocated to and managed by the QuTiP admins on board’s approval in coordination with Unitary Fund. ; * Provide access to expert legal advice (subject to request by the QuTiP board or admin team and availability of Unitary Fund funds) through its legal counsel, useful for matters related to licensing, copyright, collaborations with industry and to protect the QuTiP brand and project.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1373
https://github.com/qutip/qutip/issues/1373:5522,Modifiability,enhance,enhancements,5522,"project” with reference to all software developed under the QuTiP Github organization, hosted at “[www.github.com/qutip](www.github.com/qutip)” and all related activities involving its community happening through its official channels. **<span style=""text-decoration:underline;"">The Community</span>**. QuTiP is at the center of a lively ecosystem and creative community. As of October 2020, QuTiP’s large community comprises over 80 code contributors and thousands of users that have downloaded the software over 300’000 times. QuTiP enables an infrastructure of other scientific libraries for the investigation of specific quantum physics or quantum information processing features. . There are several ways through which members of the wider QuTiP community can receive information on QuTiP. This is through any of its official channels: the Google forum; the qutip.org/news webpage tracking the releases on Github, and opening [Issues](https://github.com/qutip/qutip/issues) on Github to file bug reports or discuss and proposed enhancements. Users are encouraged to contribute bug fixes or enhancements to the project with [Pull Requests](https://github.com/qutip/qutip/pulls). **<span style=""text-decoration:underline;"">Governance</span>**. This governance document outlines the governance of the QuTiP project, in order to better serve the community and provide robust liveliness and sustained maintenance for the project. Changes to this document need to be approved by ¾ of the Admin Team. The contents of this QuTiP Governance are shown on QuTiP’s website (qutip.org/goverance) and in its documentation. The changes are tracked at github.com/qutip/governance. We view this governance model as the formalization of what we are already doing, rather than a change in direction. This document is composed of information regarding the following:. **1. Code of Conduct**. **2. Admin Team: Tasks, Composition, Decisions, Communications.**. **3. Board: Tasks, Composition, Decisions, Communications",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1373
https://github.com/qutip/qutip/issues/1373:5584,Modifiability,enhance,enhancements,5584,".github.com/qutip](www.github.com/qutip)” and all related activities involving its community happening through its official channels. **<span style=""text-decoration:underline;"">The Community</span>**. QuTiP is at the center of a lively ecosystem and creative community. As of October 2020, QuTiP’s large community comprises over 80 code contributors and thousands of users that have downloaded the software over 300’000 times. QuTiP enables an infrastructure of other scientific libraries for the investigation of specific quantum physics or quantum information processing features. . There are several ways through which members of the wider QuTiP community can receive information on QuTiP. This is through any of its official channels: the Google forum; the qutip.org/news webpage tracking the releases on Github, and opening [Issues](https://github.com/qutip/qutip/issues) on Github to file bug reports or discuss and proposed enhancements. Users are encouraged to contribute bug fixes or enhancements to the project with [Pull Requests](https://github.com/qutip/qutip/pulls). **<span style=""text-decoration:underline;"">Governance</span>**. This governance document outlines the governance of the QuTiP project, in order to better serve the community and provide robust liveliness and sustained maintenance for the project. Changes to this document need to be approved by ¾ of the Admin Team. The contents of this QuTiP Governance are shown on QuTiP’s website (qutip.org/goverance) and in its documentation. The changes are tracked at github.com/qutip/governance. We view this governance model as the formalization of what we are already doing, rather than a change in direction. This document is composed of information regarding the following:. **1. Code of Conduct**. **2. Admin Team: Tasks, Composition, Decisions, Communications.**. **3. Board: Tasks, Composition, Decisions, Communications.**. **4. Non-profit Support.**. ### 1. Code of Conduct. The Contributor Covenant [Code of Conduct](ht",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1373
https://github.com/qutip/qutip/issues/1373:935,Safety,avoid,avoid,935,"The current QuTiP admin team (@quantshah, @BoxiLi, @ajgpitch, @Ericgig, @nwlambert, and @nathanshammah) has been working on a governance model and document in the past few months. We'd like to propose this to the broader QuTiP community of contributors and users. The main takeaway is that QuTiP has grown enormously in use in the past few years, thanks to the work of its creators, @jrjohansson and @nonhermitian, and a devoted group of core developers (among whose: @arnelg, @cgranade and many others), as well as now, over 80 [contributors](https://github.com/qutip/qutip/graphs/contributors) to the main `qutip/qutip` repository, as well as all the help on [`qutip-notebooks`](https://github.com/qutip/qutip-notebooks), [`qutip-doc`](https://github.com/qutip/qutip-doc), and [`qutip.github.io`](https://github.com/qutip/qutip.github.io) as well as the other packages that are now being spin out in the QuTiP Github organization to avoid feature creeps. Not to mention all the help provided in Qutip's google group, a forum for bugs, physics questions and research ideas. Over the years, the QuTiP project has enabled a large ecosystem of supported libraries, such as `Krotov` (cc @goerz and others), `pyEPR` (cc @zlatko-minev), `scqubits` (cc @jkochNU), and many others. . With this governance model, we'd like to keep doing what we're doing, with the support, since 2018, of @NumFOCUS, which supports scientific open source projects, and, from now on, the additional support of @unitaryfund, a non-profit that supports open-source projects in quantum technologies. . Below we reproduce a governance document that we will add to a new repository at [github.com/qutip/governance](https://github.com/qutip/governance). We are looking forward to help the growth of the user community, engage it with code contributions and bug reports, and make this awesome scientific open-source project even more sustainable. We will update all related information at [github.com/qutip/governance](https://github.c",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1373
https://github.com/qutip/qutip/issues/1373:13986,Security,access,access,13986,"are not engaged with the project, do not reply to communications or attend board meetings. . **<span style=""text-decoration:underline;"">Decisions</span>**; Each board member has a vote in decisions, which are taken by a majority vote. . **<span style=""text-decoration:underline;"">Communications</span>**; The board agrees to meet **[once a year]** (also via online meeting). The board is informed at least **[once a year]** by the Admin Team on QuTiP development and other activities (via email in the qutip-board channel). . ### 4. Non-profit Support; Since 2018, QuTiP is an affiliated project of [NumFOCUS](https://numfocus.org/), a 501(c)(3) nonprofit organization registered in the USA. The mission of NumFOCUS is to promote open practices in research, data, and scientific computing **[Unitary Fund](http://unitary.fund/)** pledges to support the QuTiP project as a fiscally sponsored project. QuTiP remains an affiliated project of NumFOCUS. [Unitary Fund](http://unitary.fund/) is a 501(c)(3) nonprofit organization registered in the USA working to create a quantum technology ecosystem that benefits the most people. Due to its role in the quantum software community, Unitary Fund pledges to: . * Promote the knowledge of QuTiP in the quantum software and sci-dev community.; * Provide scientific and technical software advice upon request of the Admin team and Board. ; * Provide logistic and financial support for code projects and meetings (subject to request by the QuTiP admins and availability of Unitary Fund funds). ; * Accept financial support on behalf of the QuTiP project. These funds will be allocated to and managed by the QuTiP admins on board’s approval in coordination with Unitary Fund. ; * Provide access to expert legal advice (subject to request by the QuTiP board or admin team and availability of Unitary Fund funds) through its legal counsel, useful for matters related to licensing, copyright, collaborations with industry and to protect the QuTiP brand and project.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1373
https://github.com/qutip/qutip/issues/1373:10557,Testability,log,logistically,10557,"ir commitment to the QuTiP for the future, e.g., how they would help and support the project in their activity. Emeriti Admin Team members, including previous core contributors, are listed on the QuTiP website (at qutip.org/devs), governance (github.com/qutip/governance) and documentation. **<span style=""text-decoration:underline;"">Decisions</span>**; Each admin team member has a vote in decisions. As much as possible, admins try to take in feedback on changes from the wider community and timely communicate major changes in the software. . **<span style=""text-decoration:underline;"">Communications</span>**; The admin team agrees to keep in touch regularly, through the qutip-admin channel or chosed communication medium, through the repositories’ maintenance, and with regular virtual or in-person meetings. The admin team drafts a report, [once] a year and submits it to the Board to inform it of developments on the project. ### 3. Board; **Members of the Board make sure that the Admin Team and project is well supported financially and logistically.** Thanks to them helping enable the financial and logistics support, through scientific advisory and by keeping an eye on the project, they make the life of the admin team easier. . **<span style=""text-decoration:underline;"">Tasks</span>**; Board members are volunteers that pledge to:. - Meet** [once] **a year to review the development of the project (also online).; - Be consulted for scientific advice by the admins. ; - Help settle conflicts or roadblocks that may arise on the project development. ; - Help review student applications of interns that may volunteer or work on the QuTiP project.; - Try to provide funding for QuTiP development and maintenance.; - Become ambassadors for scientific open source in general and QuTiP in particular.; - Take formal decisions to allocate eventual funds, upon recommendation of the Admin Team. . **<span style=""text-decoration:underline;"">Composition</span>**; Initial board members are inv",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1373
https://github.com/qutip/qutip/issues/1373:10621,Testability,log,logistics,10621,"previous core contributors, are listed on the QuTiP website (at qutip.org/devs), governance (github.com/qutip/governance) and documentation. **<span style=""text-decoration:underline;"">Decisions</span>**; Each admin team member has a vote in decisions. As much as possible, admins try to take in feedback on changes from the wider community and timely communicate major changes in the software. . **<span style=""text-decoration:underline;"">Communications</span>**; The admin team agrees to keep in touch regularly, through the qutip-admin channel or chosed communication medium, through the repositories’ maintenance, and with regular virtual or in-person meetings. The admin team drafts a report, [once] a year and submits it to the Board to inform it of developments on the project. ### 3. Board; **Members of the Board make sure that the Admin Team and project is well supported financially and logistically.** Thanks to them helping enable the financial and logistics support, through scientific advisory and by keeping an eye on the project, they make the life of the admin team easier. . **<span style=""text-decoration:underline;"">Tasks</span>**; Board members are volunteers that pledge to:. - Meet** [once] **a year to review the development of the project (also online).; - Be consulted for scientific advice by the admins. ; - Help settle conflicts or roadblocks that may arise on the project development. ; - Help review student applications of interns that may volunteer or work on the QuTiP project.; - Try to provide funding for QuTiP development and maintenance.; - Become ambassadors for scientific open source in general and QuTiP in particular.; - Take formal decisions to allocate eventual funds, upon recommendation of the Admin Team. . **<span style=""text-decoration:underline;"">Composition</span>**; Initial board members are invited by the admin team, based on their track-record in supporting the project and future helping it grow. The admins elect new board members, in agree",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1373
https://github.com/qutip/qutip/issues/1373:13650,Testability,log,logistic,13650,"are not engaged with the project, do not reply to communications or attend board meetings. . **<span style=""text-decoration:underline;"">Decisions</span>**; Each board member has a vote in decisions, which are taken by a majority vote. . **<span style=""text-decoration:underline;"">Communications</span>**; The board agrees to meet **[once a year]** (also via online meeting). The board is informed at least **[once a year]** by the Admin Team on QuTiP development and other activities (via email in the qutip-board channel). . ### 4. Non-profit Support; Since 2018, QuTiP is an affiliated project of [NumFOCUS](https://numfocus.org/), a 501(c)(3) nonprofit organization registered in the USA. The mission of NumFOCUS is to promote open practices in research, data, and scientific computing **[Unitary Fund](http://unitary.fund/)** pledges to support the QuTiP project as a fiscally sponsored project. QuTiP remains an affiliated project of NumFOCUS. [Unitary Fund](http://unitary.fund/) is a 501(c)(3) nonprofit organization registered in the USA working to create a quantum technology ecosystem that benefits the most people. Due to its role in the quantum software community, Unitary Fund pledges to: . * Promote the knowledge of QuTiP in the quantum software and sci-dev community.; * Provide scientific and technical software advice upon request of the Admin team and Board. ; * Provide logistic and financial support for code projects and meetings (subject to request by the QuTiP admins and availability of Unitary Fund funds). ; * Accept financial support on behalf of the QuTiP project. These funds will be allocated to and managed by the QuTiP admins on board’s approval in coordination with Unitary Fund. ; * Provide access to expert legal advice (subject to request by the QuTiP board or admin team and availability of Unitary Fund funds) through its legal counsel, useful for matters related to licensing, copyright, collaborations with industry and to protect the QuTiP brand and project.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1373
https://github.com/qutip/qutip/issues/1373:3111,Usability,feedback,feedback,3111,"n QuTiP website's news section (http://qutip.org/news.html) and on the QuTiP google group (https://groups.google.com/forum/#!forum/qutip). . Below it is reported how we got there and the text we're adding to the governance. Before making any more official announcements, we thought it nice to ping the community watching this repository. . **Timeline regarding governance talks**:; * April 2018: QuTiP Joins NumFOCUS as an Affiliated Project (and since then participates in Google Summer of Code).; * September 2018: a slide presentation is shared among lead developers with ideas on QuTiP development and governance. ([Link](https://docs.google.com/presentation/d/1lBfS7v4WxduvWy-rf1Vd-hSEeNOK4at91ALuaH58AnQ/edit?usp=sharing)); * February 2019: The first QuTiP developers workshop is held in RIKEN, Wako, Japan, to discuss development and roadmap ([Link](https://docs.google.com/presentation/d/1lBfS7v4WxduvWy-rf1Vd-hSEeNOK4at91ALuaH58AnQ/edit?usp=sharing)); * 2019-2020: Seminars given in USA, Asia, and Europe about QuTiP and how the users community can get more engaged, collecting feedback on the package and project. ; * April-May 2020: Discussions for governance creation are revamped; * May-August 2020: First draft document created and circulated among core developers and project creators.; * Fall 2020: Feedback from NumFOCUS, Unitary Fund, update on the governance document. # QuTiP Governance Document. **<span style=""text-decoration:underline;"">The Project</span>**. QuTiP, the Quantum Toolbox in Python, is an open-source software to study and simulate quantum systems. It provides functionalities to define and simulate the dynamics of quantum systems and thus provides tools to develop an intuitive understanding of quantum mechanics. Apart from the educational aspect where QuTiP can be used to visualize and simulate simple quantum systems, there exists advanced functionalities that enable state-of-the-art research in open quantum systems using QuTiP. It provides the most compr",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1373
https://github.com/qutip/qutip/issues/1373:3339,Usability,Feedback,Feedback,3339,"imeline regarding governance talks**:; * April 2018: QuTiP Joins NumFOCUS as an Affiliated Project (and since then participates in Google Summer of Code).; * September 2018: a slide presentation is shared among lead developers with ideas on QuTiP development and governance. ([Link](https://docs.google.com/presentation/d/1lBfS7v4WxduvWy-rf1Vd-hSEeNOK4at91ALuaH58AnQ/edit?usp=sharing)); * February 2019: The first QuTiP developers workshop is held in RIKEN, Wako, Japan, to discuss development and roadmap ([Link](https://docs.google.com/presentation/d/1lBfS7v4WxduvWy-rf1Vd-hSEeNOK4at91ALuaH58AnQ/edit?usp=sharing)); * 2019-2020: Seminars given in USA, Asia, and Europe about QuTiP and how the users community can get more engaged, collecting feedback on the package and project. ; * April-May 2020: Discussions for governance creation are revamped; * May-August 2020: First draft document created and circulated among core developers and project creators.; * Fall 2020: Feedback from NumFOCUS, Unitary Fund, update on the governance document. # QuTiP Governance Document. **<span style=""text-decoration:underline;"">The Project</span>**. QuTiP, the Quantum Toolbox in Python, is an open-source software to study and simulate quantum systems. It provides functionalities to define and simulate the dynamics of quantum systems and thus provides tools to develop an intuitive understanding of quantum mechanics. Apart from the educational aspect where QuTiP can be used to visualize and simulate simple quantum systems, there exists advanced functionalities that enable state-of-the-art research in open quantum systems using QuTiP. It provides the most comprehensive toolbox to characterize noise and dissipation affecting quantum systems as well as quantum information processing features. QuTiP has been developed and maintained by a group of open-source contributors for several years and has been used for research, teaching and in the emerging quantum technology industry. The QuTiP community has ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1373
https://github.com/qutip/qutip/issues/1373:3731,Usability,intuit,intuitive,3731,"fS7v4WxduvWy-rf1Vd-hSEeNOK4at91ALuaH58AnQ/edit?usp=sharing)); * February 2019: The first QuTiP developers workshop is held in RIKEN, Wako, Japan, to discuss development and roadmap ([Link](https://docs.google.com/presentation/d/1lBfS7v4WxduvWy-rf1Vd-hSEeNOK4at91ALuaH58AnQ/edit?usp=sharing)); * 2019-2020: Seminars given in USA, Asia, and Europe about QuTiP and how the users community can get more engaged, collecting feedback on the package and project. ; * April-May 2020: Discussions for governance creation are revamped; * May-August 2020: First draft document created and circulated among core developers and project creators.; * Fall 2020: Feedback from NumFOCUS, Unitary Fund, update on the governance document. # QuTiP Governance Document. **<span style=""text-decoration:underline;"">The Project</span>**. QuTiP, the Quantum Toolbox in Python, is an open-source software to study and simulate quantum systems. It provides functionalities to define and simulate the dynamics of quantum systems and thus provides tools to develop an intuitive understanding of quantum mechanics. Apart from the educational aspect where QuTiP can be used to visualize and simulate simple quantum systems, there exists advanced functionalities that enable state-of-the-art research in open quantum systems using QuTiP. It provides the most comprehensive toolbox to characterize noise and dissipation affecting quantum systems as well as quantum information processing features. QuTiP has been developed and maintained by a group of open-source contributors for several years and has been used for research, teaching and in the emerging quantum technology industry. The QuTiP community has grown immensely with several projects that build on top of it. In this document we refer to the “QuTiP project” or “ the project” with reference to all software developed under the QuTiP Github organization, hosted at “[www.github.com/qutip](www.github.com/qutip)” and all related activities involving its community happening",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1373
https://github.com/qutip/qutip/issues/1373:3861,Usability,simpl,simple,3861,"://docs.google.com/presentation/d/1lBfS7v4WxduvWy-rf1Vd-hSEeNOK4at91ALuaH58AnQ/edit?usp=sharing)); * 2019-2020: Seminars given in USA, Asia, and Europe about QuTiP and how the users community can get more engaged, collecting feedback on the package and project. ; * April-May 2020: Discussions for governance creation are revamped; * May-August 2020: First draft document created and circulated among core developers and project creators.; * Fall 2020: Feedback from NumFOCUS, Unitary Fund, update on the governance document. # QuTiP Governance Document. **<span style=""text-decoration:underline;"">The Project</span>**. QuTiP, the Quantum Toolbox in Python, is an open-source software to study and simulate quantum systems. It provides functionalities to define and simulate the dynamics of quantum systems and thus provides tools to develop an intuitive understanding of quantum mechanics. Apart from the educational aspect where QuTiP can be used to visualize and simulate simple quantum systems, there exists advanced functionalities that enable state-of-the-art research in open quantum systems using QuTiP. It provides the most comprehensive toolbox to characterize noise and dissipation affecting quantum systems as well as quantum information processing features. QuTiP has been developed and maintained by a group of open-source contributors for several years and has been used for research, teaching and in the emerging quantum technology industry. The QuTiP community has grown immensely with several projects that build on top of it. In this document we refer to the “QuTiP project” or “ the project” with reference to all software developed under the QuTiP Github organization, hosted at “[www.github.com/qutip](www.github.com/qutip)” and all related activities involving its community happening through its official channels. **<span style=""text-decoration:underline;"">The Community</span>**. QuTiP is at the center of a lively ecosystem and creative community. As of October 2020, QuTiP’",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1373
https://github.com/qutip/qutip/issues/1373:7874,Usability,guid,guiding,7874,"sible to enforce the Code of Conduct. Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at qutip-admin@googlegroups.com _[activate this or alternate email]_. . ### 2. Admin Team; **The Admin Team leads technical code development and manages directly QuTiP-related activities.** It’s thanks to their work and the broader community that the QuTiP project keeps lively, the software is maintained and the features keep expanding and improving. . **<span style=""text-decoration:underline;"">Tasks</span>**. The admin team is listed on the qutip website and specific areas of competence are shown. Members of the admin team pledge to volunteer to:. - Maintain the project through software release updates and bug fixes (core code development, documentation, notebooks, website, other Github-related things). . **- Make decisions about specific technical issues, features, bugs and pull requests. They are the primary mechanism of guiding the code review process and merging pull requests. This includes closing pull requests or issues that are inactive for long or deemed not relevant. **. - Develop new features in qutip/qutip and qutip/other-libraries. ; - Help keep a steady pace of qutip library releases (e.g., ~2 minor releases/year). ; - Actively participate / respond to the qutip-dev internal forum.; - Help in the Q&A support group, qutip public forum. ; - Volunteer time for remote mentorship.; - Discuss code developments.; - Once a year, on a rotation basis, one admin team member is responsible for drafting a report for the QuTiP board.; - **For each subproject that is not qutip/qutip, at least one admin should actively be watching the repository.**. - If there are new projects that wish to come under the umbrella of qutip/, either one of the existing admins should get involved with the project, or the maintainer/developer of the new project joins the admin team upon a consensus reached by the existing admins. **<span s",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1373
https://github.com/qutip/qutip/issues/1373:9955,Usability,feedback,feedback,9955," [Owner rights](https://github.com/orgs/qutip/people?query=role%3Aowner#) in QuTiP’s main Github Repository (qutip/qutip) that have been active in the past one year. . Additional Admin Team members can be nominated by the admin team among core developers and major contributors, and are voted by the admin team with a majority vote. Prospective Admin Team members can send self-candidatures with their proposed candidature, and two brief statements: one explaining their past involvement with the QuTiP project, and one with their commitment to the QuTiP for the future, e.g., how they would help and support the project in their activity. Emeriti Admin Team members, including previous core contributors, are listed on the QuTiP website (at qutip.org/devs), governance (github.com/qutip/governance) and documentation. **<span style=""text-decoration:underline;"">Decisions</span>**; Each admin team member has a vote in decisions. As much as possible, admins try to take in feedback on changes from the wider community and timely communicate major changes in the software. . **<span style=""text-decoration:underline;"">Communications</span>**; The admin team agrees to keep in touch regularly, through the qutip-admin channel or chosed communication medium, through the repositories’ maintenance, and with regular virtual or in-person meetings. The admin team drafts a report, [once] a year and submits it to the Board to inform it of developments on the project. ### 3. Board; **Members of the Board make sure that the Admin Team and project is well supported financially and logistically.** Thanks to them helping enable the financial and logistics support, through scientific advisory and by keeping an eye on the project, they make the life of the admin team easier. . **<span style=""text-decoration:underline;"">Tasks</span>**; Board members are volunteers that pledge to:. - Meet** [once] **a year to review the development of the project (also online).; - Be consulted for scientific advice by th",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1373
https://github.com/qutip/qutip/issues/1375:96,Availability,error,error,96,"If I try to calculate the time evolution of a mixed state by `mcsolve`, `mcsolve` will raise an error: `initial state must be a state vector`. It seems that we cannot define a single quantum trajectory for a mixed state from a physics perspective. But it is still possible that we can replace H|psi> and c|psi> with -i* [H,rho] and c * rho * c^\dagger respectively to simulate. I am not sure it is a faster way compared to `mesolve`. Can I do a Monte Carlo evolution for a mixed state in QuTip? Thanks.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1375
https://github.com/qutip/qutip/issues/1376:522,Availability,error,error,522,"This is code from a jupyter notebook in which I am trying to plot a graph of mesolve. Times is the variable that specifies the scale of the x axis (in units of s). I need to plot over 1ms, but it takes so long to plot that I think it just get stuck. If I plot over a much smaller scale, like 10^-6, it plots with no problem, but even then it can only do so if the number of points is small. It seems that the issue is with nsteps. As you can see, I have made nsteps very large already and if I make it any larger I get an error. I've tried debugging this to the best of my abilities but I've hit a dead end and I just can't find any useful info on nsteps online. %matplotlib inline. import matplotlib.pyplot as plt; import numpy as np; import qutip as q; import cmath; import matplotlib as mpl; from mpl_toolkits.mplot3d import Axes3D. rc_dict = {; ""figure.subplot.bottom"": 0.11,; ""figure.subplot.hspace"": 0.2,; ""figure.subplot.left"": 0.125,; ""figure.subplot.right"": 0.9,; ""figure.subplot.top"": 0.88,; ""figure.subplot.wspace"": 0.2,; ""figure.figsize"":(10,10/1.61),; ""axes.grid"": True,; ""text.usetex"": True,; ""grid.linestyle"": "":"",; ""grid.color"": ""black"", #; ""legend.fontsize"": 20,; ""lines.linewidth"": 2.5,; ""axes.linewidth"": 1.5,; ""font.family"": [""serif""],; ""font.sans-serif"": ""Times New Roman Bold"",; ""font.size"":26,; }; plt.rcParams.update(rc_dict). qutip_options = q.Odeoptions(; store_states=True,; nsteps=2000000000000; ). si, sx, sy, sz=q.qeye(2), q.sigmax(), q.sigmay(), q.sigmaz(); sp, sm=q.sigmap(), q.sigmam(); state_z_plus=q.basis(2,0); state_z_minus=q.basis(2,1); state_x_plus=1.0/cmath.sqrt(2)* (q.basis(2,0) + q.basis(2,1)); state_x_minus=1.0/cmath.sqrt(2)* (q.basis(2,0) - q.basis(2,1)); state_y_plus=1.0/cmath.sqrt(2)* (q.basis(2,0) + 1j* q.basis(2,1)); state_y_minus=1.0/cmath.sqrt(2)* (q.basis(2,0) - 1j* q.basis(2,1)). h = 6.62607015e-34; b = 0.1786195317554453 ; b_AC = 3.572390635108906e-05 ; g = 2; u = 9.274E-24 ; w = g*u*b/h . gamma_phi = 442; gamma_minus = 1. epsilon = g*u*b/h",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1376
https://github.com/qutip/qutip/issues/1376:1334,Deployability,update,update,1334,"can only do so if the number of points is small. It seems that the issue is with nsteps. As you can see, I have made nsteps very large already and if I make it any larger I get an error. I've tried debugging this to the best of my abilities but I've hit a dead end and I just can't find any useful info on nsteps online. %matplotlib inline. import matplotlib.pyplot as plt; import numpy as np; import qutip as q; import cmath; import matplotlib as mpl; from mpl_toolkits.mplot3d import Axes3D. rc_dict = {; ""figure.subplot.bottom"": 0.11,; ""figure.subplot.hspace"": 0.2,; ""figure.subplot.left"": 0.125,; ""figure.subplot.right"": 0.9,; ""figure.subplot.top"": 0.88,; ""figure.subplot.wspace"": 0.2,; ""figure.figsize"":(10,10/1.61),; ""axes.grid"": True,; ""text.usetex"": True,; ""grid.linestyle"": "":"",; ""grid.color"": ""black"", #; ""legend.fontsize"": 20,; ""lines.linewidth"": 2.5,; ""axes.linewidth"": 1.5,; ""font.family"": [""serif""],; ""font.sans-serif"": ""Times New Roman Bold"",; ""font.size"":26,; }; plt.rcParams.update(rc_dict). qutip_options = q.Odeoptions(; store_states=True,; nsteps=2000000000000; ). si, sx, sy, sz=q.qeye(2), q.sigmax(), q.sigmay(), q.sigmaz(); sp, sm=q.sigmap(), q.sigmam(); state_z_plus=q.basis(2,0); state_z_minus=q.basis(2,1); state_x_plus=1.0/cmath.sqrt(2)* (q.basis(2,0) + q.basis(2,1)); state_x_minus=1.0/cmath.sqrt(2)* (q.basis(2,0) - q.basis(2,1)); state_y_plus=1.0/cmath.sqrt(2)* (q.basis(2,0) + 1j* q.basis(2,1)); state_y_minus=1.0/cmath.sqrt(2)* (q.basis(2,0) - 1j* q.basis(2,1)). h = 6.62607015e-34; b = 0.1786195317554453 ; b_AC = 3.572390635108906e-05 ; g = 2; u = 9.274E-24 ; w = g*u*b/h . gamma_phi = 442; gamma_minus = 1. epsilon = g*u*b/h*(2*cmath.pi); Delta = g*u*b_AC/h*(2*cmath.pi). H = epsilon/2 * sz . times=np.linspace(0, 0.001*cmath.pi/2, 5). state0=(state_x_plus)/(np.sqrt(1)). H/(2*cmath.pi). results=q.mesolve(H, state0, times, c_ops=[], e_ops=[sx, sy, sz], options=qutip_options). fig, ax=plt.subplots(); ax.plot(times, results.expect[0], label=r'$\langle \sigma_x \ra",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1376
https://github.com/qutip/qutip/issues/1376:99,Modifiability,variab,variable,99,"This is code from a jupyter notebook in which I am trying to plot a graph of mesolve. Times is the variable that specifies the scale of the x axis (in units of s). I need to plot over 1ms, but it takes so long to plot that I think it just get stuck. If I plot over a much smaller scale, like 10^-6, it plots with no problem, but even then it can only do so if the number of points is small. It seems that the issue is with nsteps. As you can see, I have made nsteps very large already and if I make it any larger I get an error. I've tried debugging this to the best of my abilities but I've hit a dead end and I just can't find any useful info on nsteps online. %matplotlib inline. import matplotlib.pyplot as plt; import numpy as np; import qutip as q; import cmath; import matplotlib as mpl; from mpl_toolkits.mplot3d import Axes3D. rc_dict = {; ""figure.subplot.bottom"": 0.11,; ""figure.subplot.hspace"": 0.2,; ""figure.subplot.left"": 0.125,; ""figure.subplot.right"": 0.9,; ""figure.subplot.top"": 0.88,; ""figure.subplot.wspace"": 0.2,; ""figure.figsize"":(10,10/1.61),; ""axes.grid"": True,; ""text.usetex"": True,; ""grid.linestyle"": "":"",; ""grid.color"": ""black"", #; ""legend.fontsize"": 20,; ""lines.linewidth"": 2.5,; ""axes.linewidth"": 1.5,; ""font.family"": [""serif""],; ""font.sans-serif"": ""Times New Roman Bold"",; ""font.size"":26,; }; plt.rcParams.update(rc_dict). qutip_options = q.Odeoptions(; store_states=True,; nsteps=2000000000000; ). si, sx, sy, sz=q.qeye(2), q.sigmax(), q.sigmay(), q.sigmaz(); sp, sm=q.sigmap(), q.sigmam(); state_z_plus=q.basis(2,0); state_z_minus=q.basis(2,1); state_x_plus=1.0/cmath.sqrt(2)* (q.basis(2,0) + q.basis(2,1)); state_x_minus=1.0/cmath.sqrt(2)* (q.basis(2,0) - q.basis(2,1)); state_y_plus=1.0/cmath.sqrt(2)* (q.basis(2,0) + 1j* q.basis(2,1)); state_y_minus=1.0/cmath.sqrt(2)* (q.basis(2,0) - 1j* q.basis(2,1)). h = 6.62607015e-34; b = 0.1786195317554453 ; b_AC = 3.572390635108906e-05 ; g = 2; u = 9.274E-24 ; w = g*u*b/h . gamma_phi = 442; gamma_minus = 1. epsilon = g*u*b/h",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1376
https://github.com/qutip/qutip/issues/1377:379,Availability,error,error,379,"**Describe the issue**; Hello,; I'm studying the classical case of a driven qubit, and i want to know the steady state of the system. **To Reproduce**; I declared the following Hamiltonian; ```python; H_0 = 0.5 * h * w_eg * sigmaz(); H_1 = A * sigmax(); def H_1_t(t, args):; return cos(w * t). H = [H_0, [H_1, H_1_t]]; ```; but using `rho_ss = steadystate(H, c_ops)` returns the error; ```; TypeError: Solving for steady states requires Liouvillian (super) operators; ```; This implies that i can't see the spectrum through `spectrum(H, w, c_ops, sigmap(), sigmam())` because it calculates the steady state first, and so returns the same error.; A way to do that is by calculating the propagator and then the FFT of the correlation function; ```python; U = propagator(H, 2 * pi / w, c_ops); rho_ss = propagator_steadystate(U); rho_ss; corr = correlation_2op_1t(H, rho_ss, t, c_ops, sigmap(), sigmam()); wlist1, spec1 = spectrum_correlation_fft(t, corr); ```. Of course using `steadystate(H, c_ops)` function is much simpler and straightforward, and my question is if is it normal that `steadystate(H, c_ops)` returns error.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1377
https://github.com/qutip/qutip/issues/1377:638,Availability,error,error,638,"**Describe the issue**; Hello,; I'm studying the classical case of a driven qubit, and i want to know the steady state of the system. **To Reproduce**; I declared the following Hamiltonian; ```python; H_0 = 0.5 * h * w_eg * sigmaz(); H_1 = A * sigmax(); def H_1_t(t, args):; return cos(w * t). H = [H_0, [H_1, H_1_t]]; ```; but using `rho_ss = steadystate(H, c_ops)` returns the error; ```; TypeError: Solving for steady states requires Liouvillian (super) operators; ```; This implies that i can't see the spectrum through `spectrum(H, w, c_ops, sigmap(), sigmam())` because it calculates the steady state first, and so returns the same error.; A way to do that is by calculating the propagator and then the FFT of the correlation function; ```python; U = propagator(H, 2 * pi / w, c_ops); rho_ss = propagator_steadystate(U); rho_ss; corr = correlation_2op_1t(H, rho_ss, t, c_ops, sigmap(), sigmam()); wlist1, spec1 = spectrum_correlation_fft(t, corr); ```. Of course using `steadystate(H, c_ops)` function is much simpler and straightforward, and my question is if is it normal that `steadystate(H, c_ops)` returns error.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1377
https://github.com/qutip/qutip/issues/1377:1117,Availability,error,error,1117,"**Describe the issue**; Hello,; I'm studying the classical case of a driven qubit, and i want to know the steady state of the system. **To Reproduce**; I declared the following Hamiltonian; ```python; H_0 = 0.5 * h * w_eg * sigmaz(); H_1 = A * sigmax(); def H_1_t(t, args):; return cos(w * t). H = [H_0, [H_1, H_1_t]]; ```; but using `rho_ss = steadystate(H, c_ops)` returns the error; ```; TypeError: Solving for steady states requires Liouvillian (super) operators; ```; This implies that i can't see the spectrum through `spectrum(H, w, c_ops, sigmap(), sigmam())` because it calculates the steady state first, and so returns the same error.; A way to do that is by calculating the propagator and then the FFT of the correlation function; ```python; U = propagator(H, 2 * pi / w, c_ops); rho_ss = propagator_steadystate(U); rho_ss; corr = correlation_2op_1t(H, rho_ss, t, c_ops, sigmap(), sigmam()); wlist1, spec1 = spectrum_correlation_fft(t, corr); ```. Of course using `steadystate(H, c_ops)` function is much simpler and straightforward, and my question is if is it normal that `steadystate(H, c_ops)` returns error.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1377
https://github.com/qutip/qutip/issues/1377:1016,Usability,simpl,simpler,1016,"**Describe the issue**; Hello,; I'm studying the classical case of a driven qubit, and i want to know the steady state of the system. **To Reproduce**; I declared the following Hamiltonian; ```python; H_0 = 0.5 * h * w_eg * sigmaz(); H_1 = A * sigmax(); def H_1_t(t, args):; return cos(w * t). H = [H_0, [H_1, H_1_t]]; ```; but using `rho_ss = steadystate(H, c_ops)` returns the error; ```; TypeError: Solving for steady states requires Liouvillian (super) operators; ```; This implies that i can't see the spectrum through `spectrum(H, w, c_ops, sigmap(), sigmam())` because it calculates the steady state first, and so returns the same error.; A way to do that is by calculating the propagator and then the FFT of the correlation function; ```python; U = propagator(H, 2 * pi / w, c_ops); rho_ss = propagator_steadystate(U); rho_ss; corr = correlation_2op_1t(H, rho_ss, t, c_ops, sigmap(), sigmam()); wlist1, spec1 = spectrum_correlation_fft(t, corr); ```. Of course using `steadystate(H, c_ops)` function is much simpler and straightforward, and my question is if is it normal that `steadystate(H, c_ops)` returns error.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1377
https://github.com/qutip/qutip/issues/1378:1602,Availability,error,errors,1602,"so I am completely new to this, so maybe I did not do the right thing, which is common.; qutip.about() shows me the following things:. --------------------. QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, and Boxi Li; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.2; Numpy Version: 1.18.5; Scipy Version: 1.5.3; Cython Version: 0.29.21; Matplotlib Version: 3.3.2; Python Version: 3.7.8; Number of CPUs: 6; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Windows (AMD64); Installation path: C:\Users\***\AppData\Local\Continuum\anaconda3\lib\site-packages\qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`. --------------------. What I have done so far:; - installed qutip from source following the instructions; --- the ""zspmv_openmp.cpp"" problem is solved; --- everything is installed without errors. - Updated all packages/spyder/python/anaconda/... - installed Visual Studio Build Tools 2019 (2) Version 16.7.7; --- this includes ""C++ Buildtools"" (maybe not important, but also "".NET Desktop-Buildtools"" and "".NET Core-Buuildtools"". - I checked, whether openmp is installed in anaconda powershell prompt via ""conda install -c conda-forge openmp""; --- it shows ""# All requested packages already installed."" So it seems openmp is already installed. It would be a great help, if you give me a possible solution to this. Thanks in advance!!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1378
https://github.com/qutip/qutip/issues/1378:35,Deployability,Install,Installed,35,"Hello,. I'm trying to make ""OPENMP Installed: False"" to ""OPENMP Installed: True"", but somehow it does not work.; I have never tried to use openmp, so I am completely new to this, so maybe I did not do the right thing, which is common.; qutip.about() shows me the following things:. --------------------. QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, and Boxi Li; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.2; Numpy Version: 1.18.5; Scipy Version: 1.5.3; Cython Version: 0.29.21; Matplotlib Version: 3.3.2; Python Version: 3.7.8; Number of CPUs: 6; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Windows (AMD64); Installation path: C:\Users\***\AppData\Local\Continuum\anaconda3\lib\site-packages\qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`. --------------------. What I have done so far:; - installed qutip from source following the instructions; --- the ""zspmv_openmp.cpp"" problem is solved; --- everything is installed without errors. - Updated all packages/spyder/python/anaconda/... - installed Visual Studio Build Tools 2019 (2) Version 16.7.7; --- this includes ""C++ Buildtools"" (maybe not important, but also "".NET Desktop-Buildtools"" and "".NET Core-Buuildtools"". - I checked, whether openmp is installed in anaconda powershell prompt via ""conda install -c conda-forge openmp""; --- it shows ""# All requested packages alre",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1378
https://github.com/qutip/qutip/issues/1378:64,Deployability,Install,Installed,64,"Hello,. I'm trying to make ""OPENMP Installed: False"" to ""OPENMP Installed: True"", but somehow it does not work.; I have never tried to use openmp, so I am completely new to this, so maybe I did not do the right thing, which is common.; qutip.about() shows me the following things:. --------------------. QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, and Boxi Li; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.2; Numpy Version: 1.18.5; Scipy Version: 1.5.3; Cython Version: 0.29.21; Matplotlib Version: 3.3.2; Python Version: 3.7.8; Number of CPUs: 6; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Windows (AMD64); Installation path: C:\Users\***\AppData\Local\Continuum\anaconda3\lib\site-packages\qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`. --------------------. What I have done so far:; - installed qutip from source following the instructions; --- the ""zspmv_openmp.cpp"" problem is solved; --- everything is installed without errors. - Updated all packages/spyder/python/anaconda/... - installed Visual Studio Build Tools 2019 (2) Version 16.7.7; --- this includes ""C++ Buildtools"" (maybe not important, but also "".NET Desktop-Buildtools"" and "".NET Core-Buuildtools"". - I checked, whether openmp is installed in anaconda powershell prompt via ""conda install -c conda-forge openmp""; --- it shows ""# All requested packages alre",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1378
https://github.com/qutip/qutip/issues/1378:966,Deployability,Install,Installed,966,", but somehow it does not work.; I have never tried to use openmp, so I am completely new to this, so maybe I did not do the right thing, which is common.; qutip.about() shows me the following things:. --------------------. QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, and Boxi Li; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.2; Numpy Version: 1.18.5; Scipy Version: 1.5.3; Cython Version: 0.29.21; Matplotlib Version: 3.3.2; Python Version: 3.7.8; Number of CPUs: 6; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Windows (AMD64); Installation path: C:\Users\***\AppData\Local\Continuum\anaconda3\lib\site-packages\qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`. --------------------. What I have done so far:; - installed qutip from source following the instructions; --- the ""zspmv_openmp.cpp"" problem is solved; --- everything is installed without errors. - Updated all packages/spyder/python/anaconda/... - installed Visual Studio Build Tools 2019 (2) Version 16.7.7; --- this includes ""C++ Buildtools"" (maybe not important, but also "".NET Desktop-Buildtools"" and "".NET Core-Buuildtools"". - I checked, whether openmp is installed in anaconda powershell prompt via ""conda install -c conda-forge openmp""; --- it shows ""# All requested packages already installed."" So it seems openmp is already installed. It would be a great hel",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1378
https://github.com/qutip/qutip/issues/1378:1037,Deployability,Install,Installation,1037,", but somehow it does not work.; I have never tried to use openmp, so I am completely new to this, so maybe I did not do the right thing, which is common.; qutip.about() shows me the following things:. --------------------. QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, and Boxi Li; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.2; Numpy Version: 1.18.5; Scipy Version: 1.5.3; Cython Version: 0.29.21; Matplotlib Version: 3.3.2; Python Version: 3.7.8; Number of CPUs: 6; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Windows (AMD64); Installation path: C:\Users\***\AppData\Local\Continuum\anaconda3\lib\site-packages\qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`. --------------------. What I have done so far:; - installed qutip from source following the instructions; --- the ""zspmv_openmp.cpp"" problem is solved; --- everything is installed without errors. - Updated all packages/spyder/python/anaconda/... - installed Visual Studio Build Tools 2019 (2) Version 16.7.7; --- this includes ""C++ Buildtools"" (maybe not important, but also "".NET Desktop-Buildtools"" and "".NET Core-Buuildtools"". - I checked, whether openmp is installed in anaconda powershell prompt via ""conda install -c conda-forge openmp""; --- it shows ""# All requested packages already installed."" So it seems openmp is already installed. It would be a great hel",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1378
https://github.com/qutip/qutip/issues/1378:1464,Deployability,install,installed,1464,"so I am completely new to this, so maybe I did not do the right thing, which is common.; qutip.about() shows me the following things:. --------------------. QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, and Boxi Li; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.2; Numpy Version: 1.18.5; Scipy Version: 1.5.3; Cython Version: 0.29.21; Matplotlib Version: 3.3.2; Python Version: 3.7.8; Number of CPUs: 6; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Windows (AMD64); Installation path: C:\Users\***\AppData\Local\Continuum\anaconda3\lib\site-packages\qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`. --------------------. What I have done so far:; - installed qutip from source following the instructions; --- the ""zspmv_openmp.cpp"" problem is solved; --- everything is installed without errors. - Updated all packages/spyder/python/anaconda/... - installed Visual Studio Build Tools 2019 (2) Version 16.7.7; --- this includes ""C++ Buildtools"" (maybe not important, but also "".NET Desktop-Buildtools"" and "".NET Core-Buuildtools"". - I checked, whether openmp is installed in anaconda powershell prompt via ""conda install -c conda-forge openmp""; --- it shows ""# All requested packages already installed."" So it seems openmp is already installed. It would be a great help, if you give me a possible solution to this. Thanks in advance!!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1378
https://github.com/qutip/qutip/issues/1378:1584,Deployability,install,installed,1584,"so I am completely new to this, so maybe I did not do the right thing, which is common.; qutip.about() shows me the following things:. --------------------. QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, and Boxi Li; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.2; Numpy Version: 1.18.5; Scipy Version: 1.5.3; Cython Version: 0.29.21; Matplotlib Version: 3.3.2; Python Version: 3.7.8; Number of CPUs: 6; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Windows (AMD64); Installation path: C:\Users\***\AppData\Local\Continuum\anaconda3\lib\site-packages\qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`. --------------------. What I have done so far:; - installed qutip from source following the instructions; --- the ""zspmv_openmp.cpp"" problem is solved; --- everything is installed without errors. - Updated all packages/spyder/python/anaconda/... - installed Visual Studio Build Tools 2019 (2) Version 16.7.7; --- this includes ""C++ Buildtools"" (maybe not important, but also "".NET Desktop-Buildtools"" and "".NET Core-Buuildtools"". - I checked, whether openmp is installed in anaconda powershell prompt via ""conda install -c conda-forge openmp""; --- it shows ""# All requested packages already installed."" So it seems openmp is already installed. It would be a great help, if you give me a possible solution to this. Thanks in advance!!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1378
https://github.com/qutip/qutip/issues/1378:1612,Deployability,Update,Updated,1612,"so I am completely new to this, so maybe I did not do the right thing, which is common.; qutip.about() shows me the following things:. --------------------. QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, and Boxi Li; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.2; Numpy Version: 1.18.5; Scipy Version: 1.5.3; Cython Version: 0.29.21; Matplotlib Version: 3.3.2; Python Version: 3.7.8; Number of CPUs: 6; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Windows (AMD64); Installation path: C:\Users\***\AppData\Local\Continuum\anaconda3\lib\site-packages\qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`. --------------------. What I have done so far:; - installed qutip from source following the instructions; --- the ""zspmv_openmp.cpp"" problem is solved; --- everything is installed without errors. - Updated all packages/spyder/python/anaconda/... - installed Visual Studio Build Tools 2019 (2) Version 16.7.7; --- this includes ""C++ Buildtools"" (maybe not important, but also "".NET Desktop-Buildtools"" and "".NET Core-Buuildtools"". - I checked, whether openmp is installed in anaconda powershell prompt via ""conda install -c conda-forge openmp""; --- it shows ""# All requested packages already installed."" So it seems openmp is already installed. It would be a great help, if you give me a possible solution to this. Thanks in advance!!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1378
https://github.com/qutip/qutip/issues/1378:1662,Deployability,install,installed,1662,"so I am completely new to this, so maybe I did not do the right thing, which is common.; qutip.about() shows me the following things:. --------------------. QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, and Boxi Li; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.2; Numpy Version: 1.18.5; Scipy Version: 1.5.3; Cython Version: 0.29.21; Matplotlib Version: 3.3.2; Python Version: 3.7.8; Number of CPUs: 6; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Windows (AMD64); Installation path: C:\Users\***\AppData\Local\Continuum\anaconda3\lib\site-packages\qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`. --------------------. What I have done so far:; - installed qutip from source following the instructions; --- the ""zspmv_openmp.cpp"" problem is solved; --- everything is installed without errors. - Updated all packages/spyder/python/anaconda/... - installed Visual Studio Build Tools 2019 (2) Version 16.7.7; --- this includes ""C++ Buildtools"" (maybe not important, but also "".NET Desktop-Buildtools"" and "".NET Core-Buuildtools"". - I checked, whether openmp is installed in anaconda powershell prompt via ""conda install -c conda-forge openmp""; --- it shows ""# All requested packages already installed."" So it seems openmp is already installed. It would be a great help, if you give me a possible solution to this. Thanks in advance!!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1378
https://github.com/qutip/qutip/issues/1378:1875,Deployability,install,installed,1875,"so I am completely new to this, so maybe I did not do the right thing, which is common.; qutip.about() shows me the following things:. --------------------. QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, and Boxi Li; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.2; Numpy Version: 1.18.5; Scipy Version: 1.5.3; Cython Version: 0.29.21; Matplotlib Version: 3.3.2; Python Version: 3.7.8; Number of CPUs: 6; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Windows (AMD64); Installation path: C:\Users\***\AppData\Local\Continuum\anaconda3\lib\site-packages\qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`. --------------------. What I have done so far:; - installed qutip from source following the instructions; --- the ""zspmv_openmp.cpp"" problem is solved; --- everything is installed without errors. - Updated all packages/spyder/python/anaconda/... - installed Visual Studio Build Tools 2019 (2) Version 16.7.7; --- this includes ""C++ Buildtools"" (maybe not important, but also "".NET Desktop-Buildtools"" and "".NET Core-Buuildtools"". - I checked, whether openmp is installed in anaconda powershell prompt via ""conda install -c conda-forge openmp""; --- it shows ""# All requested packages already installed."" So it seems openmp is already installed. It would be a great help, if you give me a possible solution to this. Thanks in advance!!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1378
https://github.com/qutip/qutip/issues/1378:1926,Deployability,install,install,1926,"so I am completely new to this, so maybe I did not do the right thing, which is common.; qutip.about() shows me the following things:. --------------------. QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, and Boxi Li; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.2; Numpy Version: 1.18.5; Scipy Version: 1.5.3; Cython Version: 0.29.21; Matplotlib Version: 3.3.2; Python Version: 3.7.8; Number of CPUs: 6; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Windows (AMD64); Installation path: C:\Users\***\AppData\Local\Continuum\anaconda3\lib\site-packages\qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`. --------------------. What I have done so far:; - installed qutip from source following the instructions; --- the ""zspmv_openmp.cpp"" problem is solved; --- everything is installed without errors. - Updated all packages/spyder/python/anaconda/... - installed Visual Studio Build Tools 2019 (2) Version 16.7.7; --- this includes ""C++ Buildtools"" (maybe not important, but also "".NET Desktop-Buildtools"" and "".NET Core-Buuildtools"". - I checked, whether openmp is installed in anaconda powershell prompt via ""conda install -c conda-forge openmp""; --- it shows ""# All requested packages already installed."" So it seems openmp is already installed. It would be a great help, if you give me a possible solution to this. Thanks in advance!!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1378
https://github.com/qutip/qutip/issues/1378:2005,Deployability,install,installed,2005,"so I am completely new to this, so maybe I did not do the right thing, which is common.; qutip.about() shows me the following things:. --------------------. QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, and Boxi Li; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.2; Numpy Version: 1.18.5; Scipy Version: 1.5.3; Cython Version: 0.29.21; Matplotlib Version: 3.3.2; Python Version: 3.7.8; Number of CPUs: 6; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Windows (AMD64); Installation path: C:\Users\***\AppData\Local\Continuum\anaconda3\lib\site-packages\qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`. --------------------. What I have done so far:; - installed qutip from source following the instructions; --- the ""zspmv_openmp.cpp"" problem is solved; --- everything is installed without errors. - Updated all packages/spyder/python/anaconda/... - installed Visual Studio Build Tools 2019 (2) Version 16.7.7; --- this includes ""C++ Buildtools"" (maybe not important, but also "".NET Desktop-Buildtools"" and "".NET Core-Buuildtools"". - I checked, whether openmp is installed in anaconda powershell prompt via ""conda install -c conda-forge openmp""; --- it shows ""# All requested packages already installed."" So it seems openmp is already installed. It would be a great help, if you give me a possible solution to this. Thanks in advance!!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1378
https://github.com/qutip/qutip/issues/1378:2047,Deployability,install,installed,2047,"so I am completely new to this, so maybe I did not do the right thing, which is common.; qutip.about() shows me the following things:. --------------------. QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, and Boxi Li; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.2; Numpy Version: 1.18.5; Scipy Version: 1.5.3; Cython Version: 0.29.21; Matplotlib Version: 3.3.2; Python Version: 3.7.8; Number of CPUs: 6; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Windows (AMD64); Installation path: C:\Users\***\AppData\Local\Continuum\anaconda3\lib\site-packages\qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`. --------------------. What I have done so far:; - installed qutip from source following the instructions; --- the ""zspmv_openmp.cpp"" problem is solved; --- everything is installed without errors. - Updated all packages/spyder/python/anaconda/... - installed Visual Studio Build Tools 2019 (2) Version 16.7.7; --- this includes ""C++ Buildtools"" (maybe not important, but also "".NET Desktop-Buildtools"" and "".NET Core-Buuildtools"". - I checked, whether openmp is installed in anaconda powershell prompt via ""conda install -c conda-forge openmp""; --- it shows ""# All requested packages already installed."" So it seems openmp is already installed. It would be a great help, if you give me a possible solution to this. Thanks in advance!!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1378
https://github.com/qutip/qutip/issues/1378:1897,Energy Efficiency,power,powershell,1897,"so I am completely new to this, so maybe I did not do the right thing, which is common.; qutip.about() shows me the following things:. --------------------. QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, and Boxi Li; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.2; Numpy Version: 1.18.5; Scipy Version: 1.5.3; Cython Version: 0.29.21; Matplotlib Version: 3.3.2; Python Version: 3.7.8; Number of CPUs: 6; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Windows (AMD64); Installation path: C:\Users\***\AppData\Local\Continuum\anaconda3\lib\site-packages\qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`. --------------------. What I have done so far:; - installed qutip from source following the instructions; --- the ""zspmv_openmp.cpp"" problem is solved; --- everything is installed without errors. - Updated all packages/spyder/python/anaconda/... - installed Visual Studio Build Tools 2019 (2) Version 16.7.7; --- this includes ""C++ Buildtools"" (maybe not important, but also "".NET Desktop-Buildtools"" and "".NET Core-Buuildtools"". - I checked, whether openmp is installed in anaconda powershell prompt via ""conda install -c conda-forge openmp""; --- it shows ""# All requested packages already installed."" So it seems openmp is already installed. It would be a great help, if you give me a possible solution to this. Thanks in advance!!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1378
https://github.com/qutip/qutip/pull/1380:232,Testability,test,testing,232,**Description**; Minor changes to correct invalid string literals and close files opened by `hardware_info.py`. This removes warnings that currently appear when importing quTiP with non-standard warnings settings (for instance when testing a code that import quTiP). **Changelog**; Give a short description of the PR in a few words. This will be shown in the QuTiP change log after the PR gets merged.; For example: ; Fixed invalid string literals and proporly close opened files.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1380
https://github.com/qutip/qutip/pull/1380:372,Testability,log,log,372,**Description**; Minor changes to correct invalid string literals and close files opened by `hardware_info.py`. This removes warnings that currently appear when importing quTiP with non-standard warnings settings (for instance when testing a code that import quTiP). **Changelog**; Give a short description of the PR in a few words. This will be shown in the QuTiP change log after the PR gets merged.; For example: ; Fixed invalid string literals and proporly close opened files.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1380
https://github.com/qutip/qutip/pull/1381:255,Deployability,release,release,255,"#1347 changed the setup of the tests, but it went unnoticed (sorry!) that the Python version wasn't set correctly; we've been silently testing everything against python-latest since then. That wasn't an issue as long as Python 3.8 was the latest, but the release of Python 3.9 (and the fact we haven't rebuilt a binary distribution of QuTiP for 3.9) caused all Linux builds to break. Mac builds were unaffected because they set `$_PYTHON_VERSION` to a string literal. The Linux Python version was not set correctly because it attempted to set it to the definition of `$TRAVIS_PYTHON_VERSION` _as defined during the `env` stage of the Travis build_. Unfortunately, this environment variable isn't defined until after that stage, which caused us to pass an empty constraint on the Python version to conda, resulting in us getting the latest version. This moves this part of the environment setup into the pre-install phase so `TRAVIS_PYTHON_VERSION` is now set, and guards it with a conditional so the mac builds can still neatly override the standard setup. **Changelog**; Fix Python version setting in CI tests.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1381
https://github.com/qutip/qutip/pull/1381:907,Deployability,install,install,907,"#1347 changed the setup of the tests, but it went unnoticed (sorry!) that the Python version wasn't set correctly; we've been silently testing everything against python-latest since then. That wasn't an issue as long as Python 3.8 was the latest, but the release of Python 3.9 (and the fact we haven't rebuilt a binary distribution of QuTiP for 3.9) caused all Linux builds to break. Mac builds were unaffected because they set `$_PYTHON_VERSION` to a string literal. The Linux Python version was not set correctly because it attempted to set it to the definition of `$TRAVIS_PYTHON_VERSION` _as defined during the `env` stage of the Travis build_. Unfortunately, this environment variable isn't defined until after that stage, which caused us to pass an empty constraint on the Python version to conda, resulting in us getting the latest version. This moves this part of the environment setup into the pre-install phase so `TRAVIS_PYTHON_VERSION` is now set, and guards it with a conditional so the mac builds can still neatly override the standard setup. **Changelog**; Fix Python version setting in CI tests.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1381
https://github.com/qutip/qutip/pull/1381:681,Modifiability,variab,variable,681,"#1347 changed the setup of the tests, but it went unnoticed (sorry!) that the Python version wasn't set correctly; we've been silently testing everything against python-latest since then. That wasn't an issue as long as Python 3.8 was the latest, but the release of Python 3.9 (and the fact we haven't rebuilt a binary distribution of QuTiP for 3.9) caused all Linux builds to break. Mac builds were unaffected because they set `$_PYTHON_VERSION` to a string literal. The Linux Python version was not set correctly because it attempted to set it to the definition of `$TRAVIS_PYTHON_VERSION` _as defined during the `env` stage of the Travis build_. Unfortunately, this environment variable isn't defined until after that stage, which caused us to pass an empty constraint on the Python version to conda, resulting in us getting the latest version. This moves this part of the environment setup into the pre-install phase so `TRAVIS_PYTHON_VERSION` is now set, and guards it with a conditional so the mac builds can still neatly override the standard setup. **Changelog**; Fix Python version setting in CI tests.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1381
https://github.com/qutip/qutip/pull/1381:31,Testability,test,tests,31,"#1347 changed the setup of the tests, but it went unnoticed (sorry!) that the Python version wasn't set correctly; we've been silently testing everything against python-latest since then. That wasn't an issue as long as Python 3.8 was the latest, but the release of Python 3.9 (and the fact we haven't rebuilt a binary distribution of QuTiP for 3.9) caused all Linux builds to break. Mac builds were unaffected because they set `$_PYTHON_VERSION` to a string literal. The Linux Python version was not set correctly because it attempted to set it to the definition of `$TRAVIS_PYTHON_VERSION` _as defined during the `env` stage of the Travis build_. Unfortunately, this environment variable isn't defined until after that stage, which caused us to pass an empty constraint on the Python version to conda, resulting in us getting the latest version. This moves this part of the environment setup into the pre-install phase so `TRAVIS_PYTHON_VERSION` is now set, and guards it with a conditional so the mac builds can still neatly override the standard setup. **Changelog**; Fix Python version setting in CI tests.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1381
https://github.com/qutip/qutip/pull/1381:135,Testability,test,testing,135,"#1347 changed the setup of the tests, but it went unnoticed (sorry!) that the Python version wasn't set correctly; we've been silently testing everything against python-latest since then. That wasn't an issue as long as Python 3.8 was the latest, but the release of Python 3.9 (and the fact we haven't rebuilt a binary distribution of QuTiP for 3.9) caused all Linux builds to break. Mac builds were unaffected because they set `$_PYTHON_VERSION` to a string literal. The Linux Python version was not set correctly because it attempted to set it to the definition of `$TRAVIS_PYTHON_VERSION` _as defined during the `env` stage of the Travis build_. Unfortunately, this environment variable isn't defined until after that stage, which caused us to pass an empty constraint on the Python version to conda, resulting in us getting the latest version. This moves this part of the environment setup into the pre-install phase so `TRAVIS_PYTHON_VERSION` is now set, and guards it with a conditional so the mac builds can still neatly override the standard setup. **Changelog**; Fix Python version setting in CI tests.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1381
https://github.com/qutip/qutip/pull/1381:1105,Testability,test,tests,1105,"#1347 changed the setup of the tests, but it went unnoticed (sorry!) that the Python version wasn't set correctly; we've been silently testing everything against python-latest since then. That wasn't an issue as long as Python 3.8 was the latest, but the release of Python 3.9 (and the fact we haven't rebuilt a binary distribution of QuTiP for 3.9) caused all Linux builds to break. Mac builds were unaffected because they set `$_PYTHON_VERSION` to a string literal. The Linux Python version was not set correctly because it attempted to set it to the definition of `$TRAVIS_PYTHON_VERSION` _as defined during the `env` stage of the Travis build_. Unfortunately, this environment variable isn't defined until after that stage, which caused us to pass an empty constraint on the Python version to conda, resulting in us getting the latest version. This moves this part of the environment setup into the pre-install phase so `TRAVIS_PYTHON_VERSION` is now set, and guards it with a conditional so the mac builds can still neatly override the standard setup. **Changelog**; Fix Python version setting in CI tests.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1381
https://github.com/qutip/qutip/issues/1382:585,Availability,error,error,585,"Unexpected behaviour in ``Qobj.permute()`` in dev.major branch. **To Reproduce**; E.g. take any permutation of identity matrices for 'large' system size (e.g. `n>=16`), which should still result in the identity matrix:; ```python; >>> import numpy as np; >>> from qutip import tensor, qeye; >>> n = 16; >>> np.isclose(tensor([qeye(2)] * n).permute(list(range(n)))[0,0], 1.0); False; ```. **Expected behavior**; In this example, the permutation should do nothing and full matrix should be diag(1, 1, 1,...), but it is giving diag(0, 1, 1, ...). This occurs for me at `n>=16`. Note, the error is of course not confined to trivial permutations of the identity operator, but this seemed the cleanest case to present. **Your Environment**; QuTiP Version: 5.0.0b1.dev0+b862fe9; Numpy Version: 1.19.2; Scipy Version: 1.5.2; Cython Version: 0.29.21; Matplotlib Version: 3.3.2; Python Version: 3.7.9; Number of CPUs: 4; BLAS Info: INTEL MKL; INTEL MKL Ext: True; Platform Info: Darwin (x86_64). **Additional context**; This affects the `expand` functions (e.g. `expand_operator`, `gate_expand_2toN`).; I do not get this error in v4.5.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1382
https://github.com/qutip/qutip/issues/1382:1111,Availability,error,error,1111,"Unexpected behaviour in ``Qobj.permute()`` in dev.major branch. **To Reproduce**; E.g. take any permutation of identity matrices for 'large' system size (e.g. `n>=16`), which should still result in the identity matrix:; ```python; >>> import numpy as np; >>> from qutip import tensor, qeye; >>> n = 16; >>> np.isclose(tensor([qeye(2)] * n).permute(list(range(n)))[0,0], 1.0); False; ```. **Expected behavior**; In this example, the permutation should do nothing and full matrix should be diag(1, 1, 1,...), but it is giving diag(0, 1, 1, ...). This occurs for me at `n>=16`. Note, the error is of course not confined to trivial permutations of the identity operator, but this seemed the cleanest case to present. **Your Environment**; QuTiP Version: 5.0.0b1.dev0+b862fe9; Numpy Version: 1.19.2; Scipy Version: 1.5.2; Cython Version: 0.29.21; Matplotlib Version: 3.3.2; Python Version: 3.7.9; Number of CPUs: 4; BLAS Info: INTEL MKL; INTEL MKL Ext: True; Platform Info: Darwin (x86_64). **Additional context**; This affects the `expand` functions (e.g. `expand_operator`, `gate_expand_2toN`).; I do not get this error in v4.5.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1382
https://github.com/qutip/qutip/pull/1383:65,Testability,test,tests,65,Duplicate of #1381 for `dev.major` - should fix the super broken tests.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1383
https://github.com/qutip/qutip/pull/1384:396,Deployability,release,release,396,"First remove the completely unnecessary triplicated calls to `_Indexer.single()` by caching the results. An otherwise sensible use of the sparse code would get ruined by vastly over-using the call, which is exactly what the special-case is trying to avoid. Second, fix a buggy line: in `_dimensions_csr_sparse` there used to be the lines (229--230) that's hard to spot in the diff because of the release of the GIL in this commit:; ```python; if n:; out.row_index[index.single(row) + 1] = len; ```; where the assignment should have been `n`, not `len`. `len` is the longest row seen before now, so the first row seen would also be zeroed out by this function. Also, a matrix with some rows having more elements in that others would set the wrong values in later short rows, probably causing a segfault. Release the GIL when we don't need it for iteration - that's often a free speedup in Cython code. Fixes #1382.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1384
https://github.com/qutip/qutip/pull/1384:803,Deployability,Release,Release,803,"First remove the completely unnecessary triplicated calls to `_Indexer.single()` by caching the results. An otherwise sensible use of the sparse code would get ruined by vastly over-using the call, which is exactly what the special-case is trying to avoid. Second, fix a buggy line: in `_dimensions_csr_sparse` there used to be the lines (229--230) that's hard to spot in the diff because of the release of the GIL in this commit:; ```python; if n:; out.row_index[index.single(row) + 1] = len; ```; where the assignment should have been `n`, not `len`. `len` is the longest row seen before now, so the first row seen would also be zeroed out by this function. Also, a matrix with some rows having more elements in that others would set the wrong values in later short rows, probably causing a segfault. Release the GIL when we don't need it for iteration - that's often a free speedup in Cython code. Fixes #1382.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1384
https://github.com/qutip/qutip/pull/1384:250,Safety,avoid,avoid,250,"First remove the completely unnecessary triplicated calls to `_Indexer.single()` by caching the results. An otherwise sensible use of the sparse code would get ruined by vastly over-using the call, which is exactly what the special-case is trying to avoid. Second, fix a buggy line: in `_dimensions_csr_sparse` there used to be the lines (229--230) that's hard to spot in the diff because of the release of the GIL in this commit:; ```python; if n:; out.row_index[index.single(row) + 1] = len; ```; where the assignment should have been `n`, not `len`. `len` is the longest row seen before now, so the first row seen would also be zeroed out by this function. Also, a matrix with some rows having more elements in that others would set the wrong values in later short rows, probably causing a segfault. Release the GIL when we don't need it for iteration - that's often a free speedup in Cython code. Fixes #1382.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1384
https://github.com/qutip/qutip/issues/1385:351,Availability,down,downgrade,351,"**Describe the bug**; When plotting the Bloch sphere with qutip and matplotlib >=3.3.0 the sphere appears deformed in z-direction.; This is a result of a change in matplotlib Axes3D: https://matplotlib.org/3.3.0/users/whats_new.html#d-axes-improvements. **To Reproduce**. ```python; import qutip; b = qutip.Bloch(); b.show(); ```. **Work around**; 1) downgrade to matplotlib 3.2.2; or; 2) set aspect ratio manually; ```python; import qutip; b = qutip.Bloch(); b.show(); if hasattr(b.axes, 'set_box_aspect'):; b.axes.set_box_aspect([1,1,1]); ```. **Environment**; QuTiP Version: 4.5.2; Numpy Version: 1.19.2; Scipy Version: 1.5.2; Cython Version: 0.29.21; Matplotlib Version: 3.3.2; Python Version: 3.7.9; Number of CPUs: 6; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Linux (x86_64)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1385
https://github.com/qutip/qutip/issues/1385:753,Deployability,Install,Installed,753,"**Describe the bug**; When plotting the Bloch sphere with qutip and matplotlib >=3.3.0 the sphere appears deformed in z-direction.; This is a result of a change in matplotlib Axes3D: https://matplotlib.org/3.3.0/users/whats_new.html#d-axes-improvements. **To Reproduce**. ```python; import qutip; b = qutip.Bloch(); b.show(); ```. **Work around**; 1) downgrade to matplotlib 3.2.2; or; 2) set aspect ratio manually; ```python; import qutip; b = qutip.Bloch(); b.show(); if hasattr(b.axes, 'set_box_aspect'):; b.axes.set_box_aspect([1,1,1]); ```. **Environment**; QuTiP Version: 4.5.2; Numpy Version: 1.19.2; Scipy Version: 1.5.2; Cython Version: 0.29.21; Matplotlib Version: 3.3.2; Python Version: 3.7.9; Number of CPUs: 6; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Linux (x86_64)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1385
https://github.com/qutip/qutip/issues/1386:212,Availability,error,error,212,"**While using Qutip Latest version on Spyder with these imports:** ; from qutip import *; from scipy import *; import os.path; import numpy as np; import matplotlib.pylab as plt; import os. **I got the following error while calculating f_modes and f_energies""**. `Traceback (most recent call last):. File ""/media/rahul/DATA/IISER-PUNE-2019/MBL_copy_30-10-2020/MBL/new_codes/CDT.py"", line 121, in <module>; f_modes_0, f_energies = floquet_modes(H, T, args, True). File ""/home/rahul/anaconda3/lib/python3.8/site-packages/qutip/floquet.py"", line 102, in floquet_modes; U = propagator(H, T, [], args). File ""/home/rahul/anaconda3/lib/python3.8/site-packages/qutip/propagator.py"", line 184, in propagator; output = sesolve(H2, psi0, tlist, [],. File ""/home/rahul/anaconda3/lib/python3.8/site-packages/qutip/sesolve.py"", line 157, in sesolve; ss = _sesolve_QobjEvo(H, tlist, args, options). File ""/home/rahul/anaconda3/lib/python3.8/site-packages/qutip/sesolve.py"", line 185, in _sesolve_QobjEvo; H_td = -1.0j * QobjEvo(H, args, tlist=tlist). File ""/home/rahul/anaconda3/lib/python3.8/site-packages/qutip/qobjevo.py"", line 467, in __init__; self.args = args.copy(). **AttributeError: 'float' object has no attribute 'copy'`**. Earlier in my previous system with older version of qutip and python this used to work fine",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1386
https://github.com/qutip/qutip/issues/1387:1473,Testability,test,tested,1473,"Dear Quip-developers and users,. _Sorry for the label ""BUG"" - I thought it was before I could understand it!_. I was trying to go through the smesolver in Qutip, and find it difficult to understand what value to be chosen for dW_factors in smesolver, which is [1.0] by default. The workflow of smesolver is as follows:. - In stochastic.py, the solver options are decided based on user's input and sets the solver to smesolve; - It calls the _sesolve_generic function in stochastic.py ; - _sesolve_generic calls the _single_trajectory function in stochastic.py; - _single_trajectory calls the cy_sesolve_single_trajectory function in ssolver class of cy/stochastic.pyx . - The noise is to be multiplied by the variance of the Wiener noise, which is done in line 482-483 anyway, as given below:. ```; if self.noise_type == 0:; np.random.seed(self.seed[n]); return np.random.randn(self.num_step, self.num_substeps, self.num_dw) *\; np.sqrt(self.dt); ```. - In the function cy_sesolve_single_trajectory, the measurements are computed as follows: ; ```; if sso.store_measurement:; for m_idx, m in enumerate(sso.cm_ops):; m_expt = m.compiled_qobjevo.expect(t, rho_t); measurements[t_idx, m_idx] = m_expt + self.dW_factor[m_idx] * \; sum(noise[t_idx, :, m_idx]) / (self.dt * self.num_substeps); ```; What should be the exact [dW_factors] one should choose when m_ops is explicitly given (for example m_ops=[x])? Should it be sqrt(Gamma), where Gamma is the damping factor? I have tested that dW_factors=[1] generates very strong noise. . Thanks in advance; Sangkha Borah; OIST, Japan",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1387
https://github.com/qutip/qutip/issues/1388:171,Availability,toler,tolerance,171,"**Describe the bug**; I'm trying to get the spectrum of a qubit inside a cavity. For certain values of coupling it works, but for others not. I think this is a problem of tolerance for small numbers, i have set `qutip.settings.auto_tidyup = False` and `qutip.settings.atol = 1e-100`. **To Reproduce**; When it doesn't work it returns:; ```; <ipython-input-3-eaf63cc10951> in do_spectrum(eta, T, w_l, lowfilter); 88 #####################; 89 ; ---> 90 spec_cavity = spectrum(H_d, w_l, c_ops, Am_O, Ap_O); 91 spec_qubit = spectrum(H_d, w_l, c_ops, Sm_O, Sp_O); 92 . ~/.local/lib/python3.8/site-packages/qutip/correlation.py in spectrum(H, wlist, c_ops, a_op, b_op, solver, use_pinv); 541 ; 542 if solver == ""es"":; --> 543 return _spectrum_es(H, wlist, c_ops, a_op, b_op); 544 elif solver == ""pi"":; 545 return _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv). ~/.local/lib/python3.8/site-packages/qutip/correlation.py in _spectrum_es(H, wlist, c_ops, a_op, b_op); 1185 ; 1186 # correlation; -> 1187 corr_es = expect(a_op, es); 1188 ; 1189 # covariance. ~/.local/lib/python3.8/site-packages/qutip/expect.py in expect(oper, state); 75 ; 76 elif isinstance(oper, Qobj) and isinstance(state, eseries):; ---> 77 return _single_eseries_expect(oper, state); 78 ; 79 elif isinstance(oper, (list, np.ndarray)):. ~/.local/lib/python3.8/site-packages/qutip/expect.py in _single_eseries_expect(oper, state); 130 out = eseries(); 131 ; --> 132 if isoper(state.ampl[0]):; 133 out.rates = state.rates; 134 out.ampl = np.array([expect(oper, a) for a in state.ampl]). IndexError: index 0 is out of bounds for axis 0 with size 0; ```. **Expected behavior**; The expecter behavior is the normal returns of the spectrum, as it happens with other values of coupling. **Your Environment**; ```; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Current a",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1388
https://github.com/qutip/qutip/issues/1388:2434,Deployability,Install,Installed,2434,"3.8/site-packages/qutip/correlation.py in spectrum(H, wlist, c_ops, a_op, b_op, solver, use_pinv); 541 ; 542 if solver == ""es"":; --> 543 return _spectrum_es(H, wlist, c_ops, a_op, b_op); 544 elif solver == ""pi"":; 545 return _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv). ~/.local/lib/python3.8/site-packages/qutip/correlation.py in _spectrum_es(H, wlist, c_ops, a_op, b_op); 1185 ; 1186 # correlation; -> 1187 corr_es = expect(a_op, es); 1188 ; 1189 # covariance. ~/.local/lib/python3.8/site-packages/qutip/expect.py in expect(oper, state); 75 ; 76 elif isinstance(oper, Qobj) and isinstance(state, eseries):; ---> 77 return _single_eseries_expect(oper, state); 78 ; 79 elif isinstance(oper, (list, np.ndarray)):. ~/.local/lib/python3.8/site-packages/qutip/expect.py in _single_eseries_expect(oper, state); 130 out = eseries(); 131 ; --> 132 if isoper(state.ampl[0]):; 133 out.rates = state.rates; 134 out.ampl = np.array([expect(oper, a) for a in state.ampl]). IndexError: index 0 is out of bounds for axis 0 with size 0; ```. **Expected behavior**; The expecter behavior is the normal returns of the spectrum, as it happens with other values of coupling. **Your Environment**; ```; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, and Boxi Li; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.2; Numpy Version: 1.18.3; Scipy Version: 1.4.1; Cython Version: 0.29.21; Matplotlib Version: 3.2.1; Python Version: 3.8.5; Number of CPUs: 2; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64); Installation path: /home/alberto/.local/lib/python3.8/site-packages/qutip; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1388
https://github.com/qutip/qutip/issues/1388:2505,Deployability,Install,Installation,2505,"3.8/site-packages/qutip/correlation.py in spectrum(H, wlist, c_ops, a_op, b_op, solver, use_pinv); 541 ; 542 if solver == ""es"":; --> 543 return _spectrum_es(H, wlist, c_ops, a_op, b_op); 544 elif solver == ""pi"":; 545 return _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv). ~/.local/lib/python3.8/site-packages/qutip/correlation.py in _spectrum_es(H, wlist, c_ops, a_op, b_op); 1185 ; 1186 # correlation; -> 1187 corr_es = expect(a_op, es); 1188 ; 1189 # covariance. ~/.local/lib/python3.8/site-packages/qutip/expect.py in expect(oper, state); 75 ; 76 elif isinstance(oper, Qobj) and isinstance(state, eseries):; ---> 77 return _single_eseries_expect(oper, state); 78 ; 79 elif isinstance(oper, (list, np.ndarray)):. ~/.local/lib/python3.8/site-packages/qutip/expect.py in _single_eseries_expect(oper, state); 130 out = eseries(); 131 ; --> 132 if isoper(state.ampl[0]):; 133 out.rates = state.rates; 134 out.ampl = np.array([expect(oper, a) for a in state.ampl]). IndexError: index 0 is out of bounds for axis 0 with size 0; ```. **Expected behavior**; The expecter behavior is the normal returns of the spectrum, as it happens with other values of coupling. **Your Environment**; ```; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, and Boxi Li; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.2; Numpy Version: 1.18.3; Scipy Version: 1.4.1; Cython Version: 0.29.21; Matplotlib Version: 3.2.1; Python Version: 3.8.5; Number of CPUs: 2; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64); Installation path: /home/alberto/.local/lib/python3.8/site-packages/qutip; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1388
https://github.com/qutip/qutip/issues/1388:103,Modifiability,coupling,coupling,103,"**Describe the bug**; I'm trying to get the spectrum of a qubit inside a cavity. For certain values of coupling it works, but for others not. I think this is a problem of tolerance for small numbers, i have set `qutip.settings.auto_tidyup = False` and `qutip.settings.atol = 1e-100`. **To Reproduce**; When it doesn't work it returns:; ```; <ipython-input-3-eaf63cc10951> in do_spectrum(eta, T, w_l, lowfilter); 88 #####################; 89 ; ---> 90 spec_cavity = spectrum(H_d, w_l, c_ops, Am_O, Ap_O); 91 spec_qubit = spectrum(H_d, w_l, c_ops, Sm_O, Sp_O); 92 . ~/.local/lib/python3.8/site-packages/qutip/correlation.py in spectrum(H, wlist, c_ops, a_op, b_op, solver, use_pinv); 541 ; 542 if solver == ""es"":; --> 543 return _spectrum_es(H, wlist, c_ops, a_op, b_op); 544 elif solver == ""pi"":; 545 return _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv). ~/.local/lib/python3.8/site-packages/qutip/correlation.py in _spectrum_es(H, wlist, c_ops, a_op, b_op); 1185 ; 1186 # correlation; -> 1187 corr_es = expect(a_op, es); 1188 ; 1189 # covariance. ~/.local/lib/python3.8/site-packages/qutip/expect.py in expect(oper, state); 75 ; 76 elif isinstance(oper, Qobj) and isinstance(state, eseries):; ---> 77 return _single_eseries_expect(oper, state); 78 ; 79 elif isinstance(oper, (list, np.ndarray)):. ~/.local/lib/python3.8/site-packages/qutip/expect.py in _single_eseries_expect(oper, state); 130 out = eseries(); 131 ; --> 132 if isoper(state.ampl[0]):; 133 out.rates = state.rates; 134 out.ampl = np.array([expect(oper, a) for a in state.ampl]). IndexError: index 0 is out of bounds for axis 0 with size 0; ```. **Expected behavior**; The expecter behavior is the normal returns of the spectrum, as it happens with other values of coupling. **Your Environment**; ```; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Current a",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1388
https://github.com/qutip/qutip/issues/1388:1736,Modifiability,coupling,coupling,1736,"3.8/site-packages/qutip/correlation.py in spectrum(H, wlist, c_ops, a_op, b_op, solver, use_pinv); 541 ; 542 if solver == ""es"":; --> 543 return _spectrum_es(H, wlist, c_ops, a_op, b_op); 544 elif solver == ""pi"":; 545 return _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv). ~/.local/lib/python3.8/site-packages/qutip/correlation.py in _spectrum_es(H, wlist, c_ops, a_op, b_op); 1185 ; 1186 # correlation; -> 1187 corr_es = expect(a_op, es); 1188 ; 1189 # covariance. ~/.local/lib/python3.8/site-packages/qutip/expect.py in expect(oper, state); 75 ; 76 elif isinstance(oper, Qobj) and isinstance(state, eseries):; ---> 77 return _single_eseries_expect(oper, state); 78 ; 79 elif isinstance(oper, (list, np.ndarray)):. ~/.local/lib/python3.8/site-packages/qutip/expect.py in _single_eseries_expect(oper, state); 130 out = eseries(); 131 ; --> 132 if isoper(state.ampl[0]):; 133 out.rates = state.rates; 134 out.ampl = np.array([expect(oper, a) for a in state.ampl]). IndexError: index 0 is out of bounds for axis 0 with size 0; ```. **Expected behavior**; The expecter behavior is the normal returns of the spectrum, as it happens with other values of coupling. **Your Environment**; ```; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, and Boxi Li; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.2; Numpy Version: 1.18.3; Scipy Version: 1.4.1; Cython Version: 0.29.21; Matplotlib Version: 3.2.1; Python Version: 3.8.5; Number of CPUs: 2; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64); Installation path: /home/alberto/.local/lib/python3.8/site-packages/qutip; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1388
https://github.com/qutip/qutip/issues/1389:22,Deployability,Install,Installing,22,"**Describe the bug**; Installing the qutip on ubuntu 20.04.1 shows the following warnings:; ```; $ sudo apt install python3-qutip ; …; Entpacken von python3-qutip (4.4.1-6build1) ...; python3-qutip (4.4.1-6build1) wird eingerichtet ...; /usr/lib/python3/dist-packages/qutip/_mkl/spmv.py:53: SyntaxWarning: ""is"" ; with a literal. Did you mean ""==""?; if x.ndim is 1:; /usr/lib/python3/dist-packages/qutip/qobjevo.py:776: SyntaxWarning: ""is no; t"" with a literal. Did you mean ""!=""?; if self.compiled and self.compiled.split()[2] is not ""cte"":; /usr/lib/python3/dist-packages/qutip/qobjevo.py:1045: SyntaxWarning: ""is"" ; with a literal. Did you mean ""==""?; elif op1.type is ""array"":; /usr/lib/python3/dist-packages/qutip/qobjevo.py:1070: SyntaxWarning: ""is"" ; with a literal. Did you mean ""==""?; elif self.ops[_set[0]].type is ""string"":; /usr/lib/python3/dist-packages/qutip/qobjevo.py:1079: SyntaxWarning: ""is"" ; with a literal. Did you mean ""==""?; elif self.ops[_set[0]].type is ""array"":; /usr/lib/python3/dist-packages/qutip/qobjevo.py:1534: SyntaxWarning: ""is n; ot"" with a literal. Did you mean ""!=""?; for key in self.__dict__ if key is not ""compiled_qobjevo""}; ```. **To Reproduce**; Install qutip on ubuntu 20.04.1 via `sudo apt install python3-qutip`. **Expected behavior**; No warnings during the installation of qutip. **Your Environment**; ```; >>> qutip.about(). QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.4.1; Numpy Version: 1.17.4; Scipy Version: 1.4.1; Cython Version: 0.29.14; Matplotlib Version: 3.1.2; Python Version: 3.8.5; Number of CPUs: 2; BLAS Info: OPENBLAS; OPENMP Installed: True; INTEL MKL Ext:",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1389
https://github.com/qutip/qutip/issues/1389:108,Deployability,install,install,108,"**Describe the bug**; Installing the qutip on ubuntu 20.04.1 shows the following warnings:; ```; $ sudo apt install python3-qutip ; …; Entpacken von python3-qutip (4.4.1-6build1) ...; python3-qutip (4.4.1-6build1) wird eingerichtet ...; /usr/lib/python3/dist-packages/qutip/_mkl/spmv.py:53: SyntaxWarning: ""is"" ; with a literal. Did you mean ""==""?; if x.ndim is 1:; /usr/lib/python3/dist-packages/qutip/qobjevo.py:776: SyntaxWarning: ""is no; t"" with a literal. Did you mean ""!=""?; if self.compiled and self.compiled.split()[2] is not ""cte"":; /usr/lib/python3/dist-packages/qutip/qobjevo.py:1045: SyntaxWarning: ""is"" ; with a literal. Did you mean ""==""?; elif op1.type is ""array"":; /usr/lib/python3/dist-packages/qutip/qobjevo.py:1070: SyntaxWarning: ""is"" ; with a literal. Did you mean ""==""?; elif self.ops[_set[0]].type is ""string"":; /usr/lib/python3/dist-packages/qutip/qobjevo.py:1079: SyntaxWarning: ""is"" ; with a literal. Did you mean ""==""?; elif self.ops[_set[0]].type is ""array"":; /usr/lib/python3/dist-packages/qutip/qobjevo.py:1534: SyntaxWarning: ""is n; ot"" with a literal. Did you mean ""!=""?; for key in self.__dict__ if key is not ""compiled_qobjevo""}; ```. **To Reproduce**; Install qutip on ubuntu 20.04.1 via `sudo apt install python3-qutip`. **Expected behavior**; No warnings during the installation of qutip. **Your Environment**; ```; >>> qutip.about(). QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.4.1; Numpy Version: 1.17.4; Scipy Version: 1.4.1; Cython Version: 0.29.14; Matplotlib Version: 3.1.2; Python Version: 3.8.5; Number of CPUs: 2; BLAS Info: OPENBLAS; OPENMP Installed: True; INTEL MKL Ext:",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1389
https://github.com/qutip/qutip/issues/1389:1187,Deployability,Install,Install,1187,"udo apt install python3-qutip ; …; Entpacken von python3-qutip (4.4.1-6build1) ...; python3-qutip (4.4.1-6build1) wird eingerichtet ...; /usr/lib/python3/dist-packages/qutip/_mkl/spmv.py:53: SyntaxWarning: ""is"" ; with a literal. Did you mean ""==""?; if x.ndim is 1:; /usr/lib/python3/dist-packages/qutip/qobjevo.py:776: SyntaxWarning: ""is no; t"" with a literal. Did you mean ""!=""?; if self.compiled and self.compiled.split()[2] is not ""cte"":; /usr/lib/python3/dist-packages/qutip/qobjevo.py:1045: SyntaxWarning: ""is"" ; with a literal. Did you mean ""==""?; elif op1.type is ""array"":; /usr/lib/python3/dist-packages/qutip/qobjevo.py:1070: SyntaxWarning: ""is"" ; with a literal. Did you mean ""==""?; elif self.ops[_set[0]].type is ""string"":; /usr/lib/python3/dist-packages/qutip/qobjevo.py:1079: SyntaxWarning: ""is"" ; with a literal. Did you mean ""==""?; elif self.ops[_set[0]].type is ""array"":; /usr/lib/python3/dist-packages/qutip/qobjevo.py:1534: SyntaxWarning: ""is n; ot"" with a literal. Did you mean ""!=""?; for key in self.__dict__ if key is not ""compiled_qobjevo""}; ```. **To Reproduce**; Install qutip on ubuntu 20.04.1 via `sudo apt install python3-qutip`. **Expected behavior**; No warnings during the installation of qutip. **Your Environment**; ```; >>> qutip.about(). QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.4.1; Numpy Version: 1.17.4; Scipy Version: 1.4.1; Cython Version: 0.29.14; Matplotlib Version: 3.1.2; Python Version: 3.8.5; Number of CPUs: 2; BLAS Info: OPENBLAS; OPENMP Installed: True; INTEL MKL Ext: False; Platform Info: Linux (x86_64); Installation path: /usr/lib/python3/dist-packages/qutip; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1389
https://github.com/qutip/qutip/issues/1389:1233,Deployability,install,install,1233,"udo apt install python3-qutip ; …; Entpacken von python3-qutip (4.4.1-6build1) ...; python3-qutip (4.4.1-6build1) wird eingerichtet ...; /usr/lib/python3/dist-packages/qutip/_mkl/spmv.py:53: SyntaxWarning: ""is"" ; with a literal. Did you mean ""==""?; if x.ndim is 1:; /usr/lib/python3/dist-packages/qutip/qobjevo.py:776: SyntaxWarning: ""is no; t"" with a literal. Did you mean ""!=""?; if self.compiled and self.compiled.split()[2] is not ""cte"":; /usr/lib/python3/dist-packages/qutip/qobjevo.py:1045: SyntaxWarning: ""is"" ; with a literal. Did you mean ""==""?; elif op1.type is ""array"":; /usr/lib/python3/dist-packages/qutip/qobjevo.py:1070: SyntaxWarning: ""is"" ; with a literal. Did you mean ""==""?; elif self.ops[_set[0]].type is ""string"":; /usr/lib/python3/dist-packages/qutip/qobjevo.py:1079: SyntaxWarning: ""is"" ; with a literal. Did you mean ""==""?; elif self.ops[_set[0]].type is ""array"":; /usr/lib/python3/dist-packages/qutip/qobjevo.py:1534: SyntaxWarning: ""is n; ot"" with a literal. Did you mean ""!=""?; for key in self.__dict__ if key is not ""compiled_qobjevo""}; ```. **To Reproduce**; Install qutip on ubuntu 20.04.1 via `sudo apt install python3-qutip`. **Expected behavior**; No warnings during the installation of qutip. **Your Environment**; ```; >>> qutip.about(). QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.4.1; Numpy Version: 1.17.4; Scipy Version: 1.4.1; Cython Version: 0.29.14; Matplotlib Version: 3.1.2; Python Version: 3.8.5; Number of CPUs: 2; BLAS Info: OPENBLAS; OPENMP Installed: True; INTEL MKL Ext: False; Platform Info: Linux (x86_64); Installation path: /usr/lib/python3/dist-packages/qutip; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1389
https://github.com/qutip/qutip/issues/1389:1303,Deployability,install,installation,1303,"udo apt install python3-qutip ; …; Entpacken von python3-qutip (4.4.1-6build1) ...; python3-qutip (4.4.1-6build1) wird eingerichtet ...; /usr/lib/python3/dist-packages/qutip/_mkl/spmv.py:53: SyntaxWarning: ""is"" ; with a literal. Did you mean ""==""?; if x.ndim is 1:; /usr/lib/python3/dist-packages/qutip/qobjevo.py:776: SyntaxWarning: ""is no; t"" with a literal. Did you mean ""!=""?; if self.compiled and self.compiled.split()[2] is not ""cte"":; /usr/lib/python3/dist-packages/qutip/qobjevo.py:1045: SyntaxWarning: ""is"" ; with a literal. Did you mean ""==""?; elif op1.type is ""array"":; /usr/lib/python3/dist-packages/qutip/qobjevo.py:1070: SyntaxWarning: ""is"" ; with a literal. Did you mean ""==""?; elif self.ops[_set[0]].type is ""string"":; /usr/lib/python3/dist-packages/qutip/qobjevo.py:1079: SyntaxWarning: ""is"" ; with a literal. Did you mean ""==""?; elif self.ops[_set[0]].type is ""array"":; /usr/lib/python3/dist-packages/qutip/qobjevo.py:1534: SyntaxWarning: ""is n; ot"" with a literal. Did you mean ""!=""?; for key in self.__dict__ if key is not ""compiled_qobjevo""}; ```. **To Reproduce**; Install qutip on ubuntu 20.04.1 via `sudo apt install python3-qutip`. **Expected behavior**; No warnings during the installation of qutip. **Your Environment**; ```; >>> qutip.about(). QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.4.1; Numpy Version: 1.17.4; Scipy Version: 1.4.1; Cython Version: 0.29.14; Matplotlib Version: 3.1.2; Python Version: 3.8.5; Number of CPUs: 2; BLAS Info: OPENBLAS; OPENMP Installed: True; INTEL MKL Ext: False; Platform Info: Linux (x86_64); Installation path: /usr/lib/python3/dist-packages/qutip; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1389
https://github.com/qutip/qutip/issues/1389:1970,Deployability,Install,Installed,1970,"udo apt install python3-qutip ; …; Entpacken von python3-qutip (4.4.1-6build1) ...; python3-qutip (4.4.1-6build1) wird eingerichtet ...; /usr/lib/python3/dist-packages/qutip/_mkl/spmv.py:53: SyntaxWarning: ""is"" ; with a literal. Did you mean ""==""?; if x.ndim is 1:; /usr/lib/python3/dist-packages/qutip/qobjevo.py:776: SyntaxWarning: ""is no; t"" with a literal. Did you mean ""!=""?; if self.compiled and self.compiled.split()[2] is not ""cte"":; /usr/lib/python3/dist-packages/qutip/qobjevo.py:1045: SyntaxWarning: ""is"" ; with a literal. Did you mean ""==""?; elif op1.type is ""array"":; /usr/lib/python3/dist-packages/qutip/qobjevo.py:1070: SyntaxWarning: ""is"" ; with a literal. Did you mean ""==""?; elif self.ops[_set[0]].type is ""string"":; /usr/lib/python3/dist-packages/qutip/qobjevo.py:1079: SyntaxWarning: ""is"" ; with a literal. Did you mean ""==""?; elif self.ops[_set[0]].type is ""array"":; /usr/lib/python3/dist-packages/qutip/qobjevo.py:1534: SyntaxWarning: ""is n; ot"" with a literal. Did you mean ""!=""?; for key in self.__dict__ if key is not ""compiled_qobjevo""}; ```. **To Reproduce**; Install qutip on ubuntu 20.04.1 via `sudo apt install python3-qutip`. **Expected behavior**; No warnings during the installation of qutip. **Your Environment**; ```; >>> qutip.about(). QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.4.1; Numpy Version: 1.17.4; Scipy Version: 1.4.1; Cython Version: 0.29.14; Matplotlib Version: 3.1.2; Python Version: 3.8.5; Number of CPUs: 2; BLAS Info: OPENBLAS; OPENMP Installed: True; INTEL MKL Ext: False; Platform Info: Linux (x86_64); Installation path: /usr/lib/python3/dist-packages/qutip; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1389
https://github.com/qutip/qutip/issues/1389:2040,Deployability,Install,Installation,2040,"udo apt install python3-qutip ; …; Entpacken von python3-qutip (4.4.1-6build1) ...; python3-qutip (4.4.1-6build1) wird eingerichtet ...; /usr/lib/python3/dist-packages/qutip/_mkl/spmv.py:53: SyntaxWarning: ""is"" ; with a literal. Did you mean ""==""?; if x.ndim is 1:; /usr/lib/python3/dist-packages/qutip/qobjevo.py:776: SyntaxWarning: ""is no; t"" with a literal. Did you mean ""!=""?; if self.compiled and self.compiled.split()[2] is not ""cte"":; /usr/lib/python3/dist-packages/qutip/qobjevo.py:1045: SyntaxWarning: ""is"" ; with a literal. Did you mean ""==""?; elif op1.type is ""array"":; /usr/lib/python3/dist-packages/qutip/qobjevo.py:1070: SyntaxWarning: ""is"" ; with a literal. Did you mean ""==""?; elif self.ops[_set[0]].type is ""string"":; /usr/lib/python3/dist-packages/qutip/qobjevo.py:1079: SyntaxWarning: ""is"" ; with a literal. Did you mean ""==""?; elif self.ops[_set[0]].type is ""array"":; /usr/lib/python3/dist-packages/qutip/qobjevo.py:1534: SyntaxWarning: ""is n; ot"" with a literal. Did you mean ""!=""?; for key in self.__dict__ if key is not ""compiled_qobjevo""}; ```. **To Reproduce**; Install qutip on ubuntu 20.04.1 via `sudo apt install python3-qutip`. **Expected behavior**; No warnings during the installation of qutip. **Your Environment**; ```; >>> qutip.about(). QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.4.1; Numpy Version: 1.17.4; Scipy Version: 1.4.1; Cython Version: 0.29.14; Matplotlib Version: 3.1.2; Python Version: 3.8.5; Number of CPUs: 2; BLAS Info: OPENBLAS; OPENMP Installed: True; INTEL MKL Ext: False; Platform Info: Linux (x86_64); Installation path: /usr/lib/python3/dist-packages/qutip; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1389
https://github.com/qutip/qutip/pull/1390:615,Deployability,update,update,615,"**Checklist**; Thank you for contributing to QuTiP! Please make sure you have finished the following tasks before opening the PR. - [x] Please read [Contributing to QuTiP Development](https://github.com/qutip/qutip-doc/blob/master/CONTRIBUTING.md); - [x] Contributions to qutip should follow the [pep8 style](https://www.python.org/dev/peps/pep-0008/).; You can use [pycodestyle](http://pycodestyle.pycqa.org/en/latest/index.html) to check your code automatically; - [x] Please add tests to cover your changes if applicable.; - [x] If the behavior of the code has changed or new feature has been added, please also update the [documentation](https://github.com/qutip/qutip-doc) and the [notebook](https://github.com/qutip/qutip-notebooks). Feel free to ask if you are not sure. Delete this checklist after you have completed all the tasks. If you have not finished them all, you can also open a [Draft Pull Request](https://github.blog/2019-02-14-introducing-draft-pull-requests/) to let the others know this on-going work and keep this checklist in the PR description. **Description**; Fix one warning of #1389 , the others have already been fixed in the main branch. **Related issues or PRs**; Fixes #1389 . **Changelog**; Fix one installation warning.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1390
https://github.com/qutip/qutip/pull/1390:1233,Deployability,install,installation,1233,"**Checklist**; Thank you for contributing to QuTiP! Please make sure you have finished the following tasks before opening the PR. - [x] Please read [Contributing to QuTiP Development](https://github.com/qutip/qutip-doc/blob/master/CONTRIBUTING.md); - [x] Contributions to qutip should follow the [pep8 style](https://www.python.org/dev/peps/pep-0008/).; You can use [pycodestyle](http://pycodestyle.pycqa.org/en/latest/index.html) to check your code automatically; - [x] Please add tests to cover your changes if applicable.; - [x] If the behavior of the code has changed or new feature has been added, please also update the [documentation](https://github.com/qutip/qutip-doc) and the [notebook](https://github.com/qutip/qutip-notebooks). Feel free to ask if you are not sure. Delete this checklist after you have completed all the tasks. If you have not finished them all, you can also open a [Draft Pull Request](https://github.blog/2019-02-14-introducing-draft-pull-requests/) to let the others know this on-going work and keep this checklist in the PR description. **Description**; Fix one warning of #1389 , the others have already been fixed in the main branch. **Related issues or PRs**; Fixes #1389 . **Changelog**; Fix one installation warning.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1390
https://github.com/qutip/qutip/pull/1390:482,Testability,test,tests,482,"**Checklist**; Thank you for contributing to QuTiP! Please make sure you have finished the following tasks before opening the PR. - [x] Please read [Contributing to QuTiP Development](https://github.com/qutip/qutip-doc/blob/master/CONTRIBUTING.md); - [x] Contributions to qutip should follow the [pep8 style](https://www.python.org/dev/peps/pep-0008/).; You can use [pycodestyle](http://pycodestyle.pycqa.org/en/latest/index.html) to check your code automatically; - [x] Please add tests to cover your changes if applicable.; - [x] If the behavior of the code has changed or new feature has been added, please also update the [documentation](https://github.com/qutip/qutip-doc) and the [notebook](https://github.com/qutip/qutip-notebooks). Feel free to ask if you are not sure. Delete this checklist after you have completed all the tasks. If you have not finished them all, you can also open a [Draft Pull Request](https://github.blog/2019-02-14-introducing-draft-pull-requests/) to let the others know this on-going work and keep this checklist in the PR description. **Description**; Fix one warning of #1389 , the others have already been fixed in the main branch. **Related issues or PRs**; Fixes #1389 . **Changelog**; Fix one installation warning.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1390
https://github.com/qutip/qutip/issues/1391:159,Availability,error,error,159,"After installing qutip, in order to test qutip installation, I type ""python"" in terminal and then type ""import qutip.testing as qt"", getteing to the following error. import qutip.testing as qt; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; ModuleNotFoundError: No module named 'qutip'; >>> qt.run(); Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; NameError: name 'qt' is not defined. If anyone can help to solve the problem?; Thanks",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1391
https://github.com/qutip/qutip/issues/1391:6,Deployability,install,installing,6,"After installing qutip, in order to test qutip installation, I type ""python"" in terminal and then type ""import qutip.testing as qt"", getteing to the following error. import qutip.testing as qt; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; ModuleNotFoundError: No module named 'qutip'; >>> qt.run(); Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; NameError: name 'qt' is not defined. If anyone can help to solve the problem?; Thanks",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1391
https://github.com/qutip/qutip/issues/1391:47,Deployability,install,installation,47,"After installing qutip, in order to test qutip installation, I type ""python"" in terminal and then type ""import qutip.testing as qt"", getteing to the following error. import qutip.testing as qt; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; ModuleNotFoundError: No module named 'qutip'; >>> qt.run(); Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; NameError: name 'qt' is not defined. If anyone can help to solve the problem?; Thanks",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1391
https://github.com/qutip/qutip/issues/1391:36,Testability,test,test,36,"After installing qutip, in order to test qutip installation, I type ""python"" in terminal and then type ""import qutip.testing as qt"", getteing to the following error. import qutip.testing as qt; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; ModuleNotFoundError: No module named 'qutip'; >>> qt.run(); Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; NameError: name 'qt' is not defined. If anyone can help to solve the problem?; Thanks",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1391
https://github.com/qutip/qutip/issues/1391:117,Testability,test,testing,117,"After installing qutip, in order to test qutip installation, I type ""python"" in terminal and then type ""import qutip.testing as qt"", getteing to the following error. import qutip.testing as qt; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; ModuleNotFoundError: No module named 'qutip'; >>> qt.run(); Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; NameError: name 'qt' is not defined. If anyone can help to solve the problem?; Thanks",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1391
https://github.com/qutip/qutip/issues/1391:179,Testability,test,testing,179,"After installing qutip, in order to test qutip installation, I type ""python"" in terminal and then type ""import qutip.testing as qt"", getteing to the following error. import qutip.testing as qt; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; ModuleNotFoundError: No module named 'qutip'; >>> qt.run(); Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; NameError: name 'qt' is not defined. If anyone can help to solve the problem?; Thanks",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1391
https://github.com/qutip/qutip/issues/1395:95,Availability,error,error,95,"**Describe the bug**; Running Qutip on an **M1** MacBook Pro on import I can get the following error:. File ""/Users/otanan/miniforge3/envs/main/lib/python3.9/site-packages/qutip-4.5.0-py3.9-macosx-11.0-arm64.egg/qutip/__init__.py"", line 144, in <module>; info = qutip.hardware_info.hardware_info(); File ""/Users/otanan/miniforge3/envs/main/lib/python3.9/site-packages/qutip-4.5.0-py3.9-macosx-11.0-arm64.egg/qutip/hardware_info.py"", line 123, in hardware_info; out = _mac_hardware_info(); File ""/Users/otanan/miniforge3/envs/main/lib/python3.9/site-packages/qutip-4.5.0-py3.9-macosx-11.0-arm64.egg/qutip/hardware_info.py"", line 48, in _mac_hardware_info; results.update({'cpu_freq': int(float(os.popen('sysctl -n machdep.cpu.brand_string'); IndexError: list index out of range. **Your Environment**; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.0; Numpy Version: 1.19.4; Scipy Version: 1.5.3; Cython Version: 0.29.21; Matplotlib Version: 3.3.3; Python Version: 3.9.0; Number of CPUs: 8; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (arm64); Installation path: /Users/otanan/miniforge3/envs/main/lib/python3.9/site-packages/qutip-4.5.0-py3.9-macosx-11.0-arm64.egg/qutip. **Additional context**; I was able to ""fix"" the issue by simply commenting out lines 48 and 49 in Qutip's hardware_info.py.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1395
https://github.com/qutip/qutip/issues/1395:663,Deployability,update,update,663,"**Describe the bug**; Running Qutip on an **M1** MacBook Pro on import I can get the following error:. File ""/Users/otanan/miniforge3/envs/main/lib/python3.9/site-packages/qutip-4.5.0-py3.9-macosx-11.0-arm64.egg/qutip/__init__.py"", line 144, in <module>; info = qutip.hardware_info.hardware_info(); File ""/Users/otanan/miniforge3/envs/main/lib/python3.9/site-packages/qutip-4.5.0-py3.9-macosx-11.0-arm64.egg/qutip/hardware_info.py"", line 123, in hardware_info; out = _mac_hardware_info(); File ""/Users/otanan/miniforge3/envs/main/lib/python3.9/site-packages/qutip-4.5.0-py3.9-macosx-11.0-arm64.egg/qutip/hardware_info.py"", line 48, in _mac_hardware_info; results.update({'cpu_freq': int(float(os.popen('sysctl -n machdep.cpu.brand_string'); IndexError: list index out of range. **Your Environment**; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.0; Numpy Version: 1.19.4; Scipy Version: 1.5.3; Cython Version: 0.29.21; Matplotlib Version: 3.3.3; Python Version: 3.9.0; Number of CPUs: 8; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (arm64); Installation path: /Users/otanan/miniforge3/envs/main/lib/python3.9/site-packages/qutip-4.5.0-py3.9-macosx-11.0-arm64.egg/qutip. **Additional context**; I was able to ""fix"" the issue by simply commenting out lines 48 and 49 in Qutip's hardware_info.py.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1395
https://github.com/qutip/qutip/issues/1395:1452,Deployability,Install,Installed,1452,"**Describe the bug**; Running Qutip on an **M1** MacBook Pro on import I can get the following error:. File ""/Users/otanan/miniforge3/envs/main/lib/python3.9/site-packages/qutip-4.5.0-py3.9-macosx-11.0-arm64.egg/qutip/__init__.py"", line 144, in <module>; info = qutip.hardware_info.hardware_info(); File ""/Users/otanan/miniforge3/envs/main/lib/python3.9/site-packages/qutip-4.5.0-py3.9-macosx-11.0-arm64.egg/qutip/hardware_info.py"", line 123, in hardware_info; out = _mac_hardware_info(); File ""/Users/otanan/miniforge3/envs/main/lib/python3.9/site-packages/qutip-4.5.0-py3.9-macosx-11.0-arm64.egg/qutip/hardware_info.py"", line 48, in _mac_hardware_info; results.update({'cpu_freq': int(float(os.popen('sysctl -n machdep.cpu.brand_string'); IndexError: list index out of range. **Your Environment**; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.0; Numpy Version: 1.19.4; Scipy Version: 1.5.3; Cython Version: 0.29.21; Matplotlib Version: 3.3.3; Python Version: 3.9.0; Number of CPUs: 8; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (arm64); Installation path: /Users/otanan/miniforge3/envs/main/lib/python3.9/site-packages/qutip-4.5.0-py3.9-macosx-11.0-arm64.egg/qutip. **Additional context**; I was able to ""fix"" the issue by simply commenting out lines 48 and 49 in Qutip's hardware_info.py.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1395
https://github.com/qutip/qutip/issues/1395:1523,Deployability,Install,Installation,1523,"**Describe the bug**; Running Qutip on an **M1** MacBook Pro on import I can get the following error:. File ""/Users/otanan/miniforge3/envs/main/lib/python3.9/site-packages/qutip-4.5.0-py3.9-macosx-11.0-arm64.egg/qutip/__init__.py"", line 144, in <module>; info = qutip.hardware_info.hardware_info(); File ""/Users/otanan/miniforge3/envs/main/lib/python3.9/site-packages/qutip-4.5.0-py3.9-macosx-11.0-arm64.egg/qutip/hardware_info.py"", line 123, in hardware_info; out = _mac_hardware_info(); File ""/Users/otanan/miniforge3/envs/main/lib/python3.9/site-packages/qutip-4.5.0-py3.9-macosx-11.0-arm64.egg/qutip/hardware_info.py"", line 48, in _mac_hardware_info; results.update({'cpu_freq': int(float(os.popen('sysctl -n machdep.cpu.brand_string'); IndexError: list index out of range. **Your Environment**; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.0; Numpy Version: 1.19.4; Scipy Version: 1.5.3; Cython Version: 0.29.21; Matplotlib Version: 3.3.3; Python Version: 3.9.0; Number of CPUs: 8; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (arm64); Installation path: /Users/otanan/miniforge3/envs/main/lib/python3.9/site-packages/qutip-4.5.0-py3.9-macosx-11.0-arm64.egg/qutip. **Additional context**; I was able to ""fix"" the issue by simply commenting out lines 48 and 49 in Qutip's hardware_info.py.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1395
https://github.com/qutip/qutip/issues/1395:1709,Usability,simpl,simply,1709,"**Describe the bug**; Running Qutip on an **M1** MacBook Pro on import I can get the following error:. File ""/Users/otanan/miniforge3/envs/main/lib/python3.9/site-packages/qutip-4.5.0-py3.9-macosx-11.0-arm64.egg/qutip/__init__.py"", line 144, in <module>; info = qutip.hardware_info.hardware_info(); File ""/Users/otanan/miniforge3/envs/main/lib/python3.9/site-packages/qutip-4.5.0-py3.9-macosx-11.0-arm64.egg/qutip/hardware_info.py"", line 123, in hardware_info; out = _mac_hardware_info(); File ""/Users/otanan/miniforge3/envs/main/lib/python3.9/site-packages/qutip-4.5.0-py3.9-macosx-11.0-arm64.egg/qutip/hardware_info.py"", line 48, in _mac_hardware_info; results.update({'cpu_freq': int(float(os.popen('sysctl -n machdep.cpu.brand_string'); IndexError: list index out of range. **Your Environment**; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.0; Numpy Version: 1.19.4; Scipy Version: 1.5.3; Cython Version: 0.29.21; Matplotlib Version: 3.3.3; Python Version: 3.9.0; Number of CPUs: 8; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (arm64); Installation path: /Users/otanan/miniforge3/envs/main/lib/python3.9/site-packages/qutip-4.5.0-py3.9-macosx-11.0-arm64.egg/qutip. **Additional context**; I was able to ""fix"" the issue by simply commenting out lines 48 and 49 in Qutip's hardware_info.py.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1395
https://github.com/qutip/qutip/issues/1396:178,Availability,error,error,178,"I installed qutip through Anaconda on MacBook M1. The installation was successful but when I tried to verify the installation through `from qutip import *`, I received following error:; `Traceback (most recent call last):; File ""/Users/akhil/opt/anaconda3/lib/python3.8/site-packages/qutip/__init__.py"", line 46, in <module>; __IPYTHON__; NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:. Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; File ""/Users/akhil/opt/anaconda3/lib/python3.8/site-packages/qutip/__init__.py"", line 49, in <module>; qutip.settings.ipython = False; AttributeError: partially initialized module 'qutip' has no attribute 'settings' (most likely due to a circular import)`",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1396
https://github.com/qutip/qutip/issues/1396:2,Deployability,install,installed,2,"I installed qutip through Anaconda on MacBook M1. The installation was successful but when I tried to verify the installation through `from qutip import *`, I received following error:; `Traceback (most recent call last):; File ""/Users/akhil/opt/anaconda3/lib/python3.8/site-packages/qutip/__init__.py"", line 46, in <module>; __IPYTHON__; NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:. Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; File ""/Users/akhil/opt/anaconda3/lib/python3.8/site-packages/qutip/__init__.py"", line 49, in <module>; qutip.settings.ipython = False; AttributeError: partially initialized module 'qutip' has no attribute 'settings' (most likely due to a circular import)`",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1396
https://github.com/qutip/qutip/issues/1396:54,Deployability,install,installation,54,"I installed qutip through Anaconda on MacBook M1. The installation was successful but when I tried to verify the installation through `from qutip import *`, I received following error:; `Traceback (most recent call last):; File ""/Users/akhil/opt/anaconda3/lib/python3.8/site-packages/qutip/__init__.py"", line 46, in <module>; __IPYTHON__; NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:. Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; File ""/Users/akhil/opt/anaconda3/lib/python3.8/site-packages/qutip/__init__.py"", line 49, in <module>; qutip.settings.ipython = False; AttributeError: partially initialized module 'qutip' has no attribute 'settings' (most likely due to a circular import)`",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1396
